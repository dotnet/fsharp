<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ja" original="../Tutorial.fsx">
    <body>
      <trans-unit id="SampleHeader">
        <source>This sample will guide you through elements of the F# language.</source>
        <target state="translated">このサンプルは、F# 言語の要素を紹介します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Instructions-Line1">
        <source>To execute the code in F# Interactive, highlight a section of code and press Alt-Enter or right-click</source>
        <target state="translated">F# インタラクティブでコードを実行するには、コードの一部を強調表示して、Alt キーを押しながら Enter キーを押すか、右マウス ボタンをクリックし</target>
        <note />
      </trans-unit>
      <trans-unit id="Instructions-Line2">
        <source>and select "Execute in Interactive".  You can open the F# Interactive Window from the "View" menu.</source>
        <target state="translated">[対話形式で実行]5D; を選択します。[表示]5D; メニューから F# インタラクティブ ウィンドウを開くことができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreAbout">
        <source>For more about F#, see:</source>
        <target state="translated">F# の詳細については、次のページを参照してください:</target>
        <note />
      </trans-unit>
      <trans-unit id="SeeDocumentaton">
        <source>To see this tutorial in documentation form, see:</source>
        <target state="translated">このチュートリアルをドキュメント形式で表示するには、次を参照してください:</target>
        <note />
      </trans-unit>
      <trans-unit id="LearnMoreAbout">
        <source>To learn more about applied F# programming, use</source>
        <target state="translated">適用された F# プログラミングの詳細については、次を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="ToInstall-Line1">
        <source>To install the Visual F# Power Tools, use</source>
        <target state="translated">Visual F# Power Tools をインストールするには、次を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="ToInstall-Line2">
        <source>'Tools' --&gt; 'Extensions and Updates' --&gt; `Online` and search</source>
        <target state="translated">[ツール]5D; --&gt; [拡張機能と更新プログラム]5D; --&gt; [オンライン]5D; と検索</target>
        <note />
      </trans-unit>
      <trans-unit id="AdditionalTemplates-Line1">
        <source>For additional templates to use with F#, see the 'Online Templates' in Visual Studio,</source>
        <target state="translated">F# で使用するその他のテンプレートについては、Visual Studio の 'オンライン テンプレート' を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AdditionalTemplates-Line2">
        <source>'New Project' --&gt; 'Online Templates'</source>
        <target state="translated">([新しいプロジェクト]5D; --&gt; [オンライン テンプレート]5D;) を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportsComments">
        <source>F# supports three kinds of comments:</source>
        <target state="translated">F# は、3 種類のコメントをサポートしています:</target>
        <note />
      </trans-unit>
      <trans-unit id="DoubleSlash">
        <source>1. Double-slash comments.  These are used in most situations.</source>
        <target state="translated">1. ダブルスラッシュ コメント。これはほとんどの場合に使用されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="MLStyle">
        <source>2. ML-style Block comments.  These aren't used that often.</source>
        <target state="translated">2. ML スタイル ブロック コメント。これはそれほど頻繁には使用されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="TripleSlash-Line1">
        <source>3. Triple-slash comments.  These are used for documenting functions, types, and so on.</source>
        <target state="translated">3. トリプル スラッシュ コメント。これは、関数や型などの文書化に使用されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="TripleSlash-Line2">
        <source>They will appear as text when you hover over something which is decorated with these comments.</source>
        <target state="translated">このコメントで修飾されているものをポイントすると、これがテキストとして表示されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line1">
        <source>They also support .NET-style XML comments, which allow you to generate reference documentation,</source>
        <target state="translated">これは .NET スタイルの XML コメントもサポートしています。このコメントを使用すると、リファレンス ドキュメントを生成できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line2">
        <source>and they also allow editors (such as Visual Studio) to extract information from them.</source>
        <target state="translated">また、(Visual Studio などの) エディターでそこから情報を抽出することもできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/xml-documentation</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/xml-documentation</target>
        <note />
      </trans-unit>
      <trans-unit id="OpenNamespaces">
        <source>Open namespaces using the 'open' keyword.</source>
        <target state="translated">'open' キーワードを使用して名前空間を開きます。</target>
        <note />
      </trans-unit>
      <trans-unit id="LearnMore">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/import-declarations-the-open-keyword</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/import-declarations-the-open-keyword</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line1">
        <source>A module is a grouping of F# code, such as values, types, and function values.</source>
        <target state="translated">モジュールは、値、型、関数値などの、F# コードのグループ化です。</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line2">
        <source>Grouping code in modules helps keep related code together and helps avoid name conflicts in your program.</source>
        <target state="translated">コードをモジュールにグループ化することで、関連コードを 1 つにまとめて、プログラムでの名前の競合を回避することができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/modules</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/modules</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleInt">
        <source>This is a sample integer.</source>
        <target state="translated">これは、サンプルの整数値です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleFloat">
        <source>This is a sample floating point number.</source>
        <target state="translated">これは、サンプルの浮動小数点数です。</target>
        <note />
      </trans-unit>
      <trans-unit id="Computed-Line1">
        <source>This computed a new number by some arithmetic.  Numeric types are converted using</source>
        <target state="translated">算術によって新しい数値が算出されました。数値型は以下を使用するよう変換されています</target>
        <note />
      </trans-unit>
      <trans-unit id="Computed-Line2">
        <source>functions 'int', 'double' and so on.</source>
        <target state="translated">関数の 'int'、'double' などです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListNumbers">
        <source>This is a list of the numbers from 0 to 99.</source>
        <target state="translated">これは 0 ～ 99 の数値のリストです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListSquares">
        <source>This is a list of all tuples containing all the numbers from 0 to 99 and their squares.</source>
        <target state="translated">これは、0 ～ 99 のすべての数値とその二乗を含むすべてのタプルのリストです。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintList1">
        <source>The next line prints a list that includes tuples, using '%A' for generic printing.</source>
        <target state="translated">次の行は、タプルを含むリストを出力します。一般的な出力に '%A' を使用しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleIntType">
        <source>This is a sample integer with a type annotation</source>
        <target state="translated">これは、型の注釈付きのサンプルの整数です</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line1">
        <source>Values in F# are immutable by default.  They cannot be changed</source>
        <target state="translated">既定では、F# の値は不変です。明示的に変更可能として指定しない限り、</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line2">
        <source>in the course of a program's execution unless explicitly marked as mutable.</source>
        <target state="translated">プログラムの実行の過程で変更することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/values/index#why-immutable</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/values/index#why-immutable</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line1">
        <source>Binding a value to a name via 'let' makes it immutable.</source>
        <target state="translated">'let' を介して値を名前にバインドすると、変更できなくなります。</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line2">
        <source>The second line of code fails to compile because 'number' is immutable and bound.</source>
        <target state="translated">コードの 2 番目の行は、'number' が変更できず、バインドされているため、コンパイルに失敗します。</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line3">
        <source>Re-defining 'number' to be a different value is not allowed in F#.</source>
        <target state="translated">F# では、'number' を別の値に再定義することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableKeyword">
        <source>A mutable binding.  This is required to be able to mutate the value of 'otherNumber'.</source>
        <target state="translated">変更可能なバインド。これは 'otherNumber' の値を変更できるようにするために必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line1">
        <source>When mutating a value, use '&lt;-' to assign a new value.</source>
        <target state="translated">値を変換する場合は、'&lt;-' を使用して新しい値を割り当てます。</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line2">
        <source>You could not use '=' here for this purpose since it is used for equality</source>
        <target state="translated">この場合、'=' は等価を示すために使用するため、ここで使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line3">
        <source>or other contexts such as 'let' or 'module'</source>
        <target state="translated">または、'let' や 'module' などの他のコンテキスト</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line1">
        <source>Much of F# programming consists of defining functions that transform input data to produce</source>
        <target state="translated">F# プログラミングの多くは、生成する入力データを変換する定義する関数で構成されています</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line2">
        <source>useful results.</source>
        <target state="translated">有用な結果。</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/functions/</target>
        <note />
      </trans-unit>
      <trans-unit id="LetFunction-Line1">
        <source>You use 'let' to define a function. This one accepts an integer argument and returns an integer.</source>
        <target state="translated">関数を定義するには、'let' を使用します。これは整数の引数を受け取り、整数を返します。</target>
        <note />
      </trans-unit>
      <trans-unit id="LetFunction-Line2">
        <source>Parentheses are optional for function arguments, except for when you use an explicit type annotation.</source>
        <target state="translated">明示的な型の注釈を使用する場合を除いて、かっこは関数引数では省略可能です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyFunction-Line1">
        <source>Apply the function, naming the function return result using 'let'.</source>
        <target state="translated">関数を適用します。'let' を使用し、関数の戻り値の結果に名前を付けます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyFunction-Line2">
        <source>The variable type is inferred from the function return type.</source>
        <target state="translated">変数の型は、関数の戻り値の型から推論されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line1">
        <source>This line uses '%d' to print the result as an integer. This is type-safe.</source>
        <target state="translated">この行は '%d' を使用して結果を整数として出力します。これはタイプ セーフです。</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line2">
        <source>If 'result1' were not of type 'int', then the line would fail to compile.</source>
        <target state="translated">'result1' が 'int' 型でなかった場合、行はコンパイルに失敗します。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeAnnotation">
        <source>When needed, annotate the type of a parameter name using '(argument:type)'.  Parentheses are required.</source>
        <target state="translated">必要であれば、'(引数:型)' を使用してパラメーター名の型に注釈を付けます。かっこは必須です。</target>
        <note />
      </trans-unit>
      <trans-unit id="Conditionals-Line1">
        <source>Conditionals use if/then/elid/elif/else.</source>
        <target state="translated">条件は、if/then/elid/elif/else を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Conditionals-Line2">
        <source>Note that F# uses whitespace indentation-aware syntax, similar to languages like Python.</source>
        <target state="translated">F# は Python などの言語のように、空白のインデント対応構文を使用することに注意してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line3">
        <source>This line uses '%f' to print the result as a float.  As with '%d' above, this is type-safe.</source>
        <target state="translated">この行は  '%f' を使用して結果を浮動小数として出力します。上記の '%d' と同様に、これはタイプ セーフです。</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line1">
        <source>Booleans are fundamental data types in F#.  Here are some examples of Booleans and conditional logic.</source>
        <target state="translated">ブール値は F# の基本のデータ型です。ブール値と条件ロジックの例をいくつか示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line2">
        <source>To learn more, see:</source>
        <target state="translated">詳細については、次を参照してください:</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line3">
        <source>and</source>
        <target state="translated">AND</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanValues">
        <source>Booleans values are 'true' and 'false'.</source>
        <target state="translated">ブール型の値は 'true' と 'false' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanOperators">
        <source>Operators on booleans are 'not', '&amp;&amp;' and '||'.</source>
        <target state="translated">ブール値の演算子は 'not'、'&amp;&amp;'、および '||' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanPrintf">
        <source>This line uses '%b'to print a boolean value.  This is type-safe.</source>
        <target state="translated">この行は '%b' を使用してブール値を出力します。これはタイプ セーフです。</target>
        <note />
      </trans-unit>
      <trans-unit id="Strings-Line1">
        <source>Strings are fundamental data types in F#.  Here are some examples of Strings and basic String manipulation.</source>
        <target state="translated">文字列は F# の基本のデータ型です。文字列と基本的な文字列操作の例をいくつか示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Strings-Line2">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/strings</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/strings</target>
        <note />
      </trans-unit>
      <trans-unit id="StringQuotes">
        <source>Strings use double quotes.</source>
        <target state="translated">文字列は二重引用符を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="StringLiterals-Line1">
        <source>Strings can also use @ to create a verbatim string literal.</source>
        <target state="translated">文字列は @ を使用して、verbatim 文字列リテラルを作成することもできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="StringLiterals-Line2">
        <source>This will ignore escape characters such as '\', '\n', '\t', etc.</source>
        <target state="translated">これは、'\'、'\n'、'\t' などのエスケープ文字を無視します。</target>
        <note />
      </trans-unit>
      <trans-unit id="StringTripleQuotes">
        <source>String literals can also use triple-quotes.</source>
        <target state="translated">文字列リテラルは三重引用符を使用することもできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="StringConcatenation">
        <source>String concatenation is normally done with the '+' operator.</source>
        <target state="translated">通常、文字列の連結は '+' 演算子を使用して実行されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="StringPrinting">
        <source>This line uses '%s' to print a string value.  This is type-safe.</source>
        <target state="translated">この行は、'%s' を使用して文字列値を出力します。これはタイプ セーフです。</target>
        <note />
      </trans-unit>
      <trans-unit id="Substrings-Line1">
        <source>Substrings use the indexer notation.  This line extracts the first 7 characters as a substring.</source>
        <target state="translated">サブ文字列はインデクサー表記を使用します。この行はサブ文字列として最初の 7 文字を抽出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Substrings-Line2">
        <source>Note that like many languages, Strings are zero-indexed in F#.</source>
        <target state="translated">多くの言語と同様に、F# では、文字列のインデックスは 0 から始まることに注意してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="Tuples-Line1">
        <source>Tuples are simple combinations of data values into a combined value.</source>
        <target state="translated">タプルは、データ値と合計値の単純な組み合わせです。</target>
        <note />
      </trans-unit>
      <trans-unit id="Tuples-Line2">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/tuples</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/tuples</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleInteger">
        <source>A simple tuple of integers.</source>
        <target state="translated">整数のシンプルなタプルです。</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line1">
        <source>A function that swaps the order of two values in a tuple.</source>
        <target state="translated">タプルの 2 つの値の順序を入れ替える関数。</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line2">
        <source>F# Type Inference will automatically generalize the function to have a generic type,</source>
        <target state="translated">F# 型の推定は、ジェネリック型を持つように関数を自動的に一般化し、</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line3">
        <source>meaning that it will work with any type.</source>
        <target state="translated">任意の型で動作することを意味します。</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleMultiType-Line1">
        <source>A tuple consisting of an integer, a string,</source>
        <target state="translated">タプルを構成するのは、整数、文字列、</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleMultiType-Line2">
        <source>and a double-precision floating point number.</source>
        <target state="translated">および倍精度浮動小数点数です。</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleTypeAnnotation-Line1">
        <source>A simple tuple of integers with a type annotation.</source>
        <target state="translated">型の注釈が指定された整数のシンプルなタプル。</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleTypeAnnotation-Line2">
        <source>Type annotations for tuples use the * symbol to separate elements</source>
        <target state="translated">タプルの型の注釈では、要素を区切るために * の記号を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line1">
        <source>Tuples are normally objects, but they can also be represented as structs.</source>
        <target state="translated">タプルは通常はオブジェクトですが、構造体として表すこともできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line2">
        <source>These interoperate completely with structs in C# and Visual Basic.NET; however,</source>
        <target state="translated">C# と Visual Basic.NET では、これらは構造体と完全に相互運用されます。ただし、</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line3">
        <source>struct tuples are not implicitly convertable with object tuples (often called reference tuples).</source>
        <target state="translated">構造体のタプルは、オブジェクト タプル (参照タプルと呼ばれることが多い) と暗黙的に変換できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line4">
        <source>The second line below will fail to compile because of this.  Uncomment it to see what happens.</source>
        <target state="translated">このため、以下の 2 番目の行はコンパイルに失敗します。発生する事象を確認するには、コメントを解除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleConvert-Line1">
        <source>Although you cannot implicitly convert between struct tuples and reference tuples,</source>
        <target state="translated">構造体タプルと参照タプル間で暗黙的に変換することはできませんが、</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleConvert-Line2">
        <source>you can explicitly convert via pattern matching, as demonstrated below.</source>
        <target state="translated">以下に示すように、パターン マッチングを使用して明示的に変換できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line1">
        <source>The F# pipe operators ('|&gt;', '&lt;|', etc.) and F# composition operators ('&gt;&gt;', '&lt;&lt;')</source>
        <target state="translated">F# パイプ演算子 ('|&gt;'、'&lt;|' など) と F# 合成演算子 ('&gt;&gt;'、'&lt;&lt;')</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line2">
        <source>are used extensively when processing data.  These operators are themselves functions</source>
        <target state="translated">は、データの処理時に幅広く使用されます。これらの演算子はそれ自体が関数であり、</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line3">
        <source>which make use of Partial Application.</source>
        <target state="translated">部分適用を利用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line4">
        <source>To learn more about these operators, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/#function-composition-and-pipelining</source>
        <target state="translated">これらの演算子の詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/functions/#function-composition-and-pipelining</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line5">
        <source>To learn more about Partial Application, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/#partial-application-of-arguments</source>
        <target state="translated">部分適用の詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/functions/#partial-application-of-arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="Squares">
        <source>Squares a value.</source>
        <target state="translated">値を 2 乗します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddOne">
        <source>Adds 1 to a value.</source>
        <target state="translated">値に 1 を追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestOdd">
        <source>Tests if an integer value is odd via modulo.</source>
        <target state="translated">剰余を使って整数値が奇数であるかどうかをテストします。</target>
        <note />
      </trans-unit>
      <trans-unit id="NumberList1">
        <source>A list of 5 numbers.  More on lists later.</source>
        <target state="translated">5 個の数値のリストです。リストの詳細については後述。</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithoutPipes-Line1">
        <source>Given a list of integers, it filters out the even numbers,</source>
        <target state="translated">整数のリストを指定すると、偶数を除外し、</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithoutPipes-Line2">
        <source>squares the resulting odds, and adds 1 to the squared odds.</source>
        <target state="translated">結果の奇数を 2 乗し、2 乗した奇数に 1 を加算します。</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line1">
        <source>A shorter way to write 'squareOddValuesAndAddOne' is to nest each</source>
        <target state="translated">'squareOddValuesAndAddOne' を記述するためのより簡単な方法は、</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line2">
        <source>sub-result into the function calls themselves.</source>
        <target state="translated">それぞれのサブ結果を関数呼び出し自体に入れ子にすることです。</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line3">
        <source>This makes the function much shorter, but it's difficult to see the</source>
        <target state="translated">これにより、関数は大幅に短くなりますが、データが処理される順序を</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line4">
        <source>order in which the data is processed.</source>
        <target state="translated">判別するのは難しくなります。</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line1">
        <source>A preferred way to write 'squareOddValuesAndAddOne' is to use F# pipe operators.</source>
        <target state="translated">'squareOddValuesAndAddOne' を記述するための推奨される方法は、F# パイプ演算子を使用する方法です。</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line2">
        <source>This allows you to avoid creating intermediate results, but is much more readable</source>
        <target state="translated">これにより、中間結果を作成しなくてもよくなります。また、</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line3">
        <source>than nesting function calls like 'squareOddValuesAndAddOneNested'</source>
        <target state="translated">'squareOddValuesAndAddOneNested' のような関数呼び出しを入れ子にするよりもはるかに読みやすくすることができます</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line1">
        <source>You can shorten 'squareOddValuesAndAddOnePipeline' by moving the second `List.map` call</source>
        <target state="translated">ラムダ関数を使用して、2 番目の `List.map` 呼び出しを先頭に移動することにより、</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line2">
        <source>into the first, using a Lambda Function.</source>
        <target state="translated">'squareOddValuesAndAddOnePipeline' を短くすることができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line3">
        <source>Note that pipelines are also being used inside the lambda function.  F# pipe operators</source>
        <target state="translated">パイプラインはラムダ関数の内部でも使用されることに注意してください。F# パイプ演算子は、</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line4">
        <source>can be used for single values as well.  This makes them very powerful for processing data.</source>
        <target state="translated">単一の値にも使用できます。これにより、データ処理能力が向上します。</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line1">
        <source>Lastly, you can eliminate the need to explicitly take 'values' in as a parameter by using '&gt;&gt;'</source>
        <target state="translated">最後に、'&gt;&gt;' を使用して次の 2 つのコア操作を作成すると、'values' をパラメーターとして</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line2">
        <source>to compose the two core operations: filtering out even numbers, then squaring and adding one.</source>
        <target state="translated">明示的に受け取る必要がなくなります: 偶数を除外してから、2 乗して 1 を加算する。</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line3">
        <source>Likewise, the 'fun x -&gt; ...' bit of the lambda expression is also not needed, because 'x' is simply</source>
        <target state="translated">同様に、ラムダ式の 'fun x -&gt; ...' ビットも必要ありません。 'x' は単に、</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line4">
        <source>being defined in that scope so that it can be passed to a functional pipeline.  Thus, '&gt;&gt;' can be used</source>
        <target state="translated">関数型パイプラインに渡すことができるようにそのスコープ内で定義されているだけだからです。そのため、</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line5">
        <source>there as well.</source>
        <target state="translated">そこでも同様に '&gt;&gt;' を使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line6">
        <source>The result of 'squareOddValuesAndAddOneComposition' is itself another function which takes a</source>
        <target state="translated">'squareOddValuesAndAddOneComposition' の結果は、それ自体が別の関数です。その関数は、</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line7">
        <source>list of integers as its input.  If you execute 'squareOddValuesAndAddOneComposition' with a list</source>
        <target state="translated">整数のリストを入力として受け取ります。整数のリストを指定して 'squareOddValuesAndAddOneComposition' を</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line8">
        <source>of integers, you'll notice that it produces the same results as previous functions.</source>
        <target state="translated">実行すると、前の関数と同じ結果が生成されることがわかります。</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line9">
        <source>This is using what is known as function composition.  This is possible because functions in F#</source>
        <target state="translated">これは、関数合成と呼ばれるものを使用しています。これが可能なのは、F# の関数が</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line10">
        <source>use Partial Application and the input and output types of each data processing operation match</source>
        <target state="translated">部分適用を使用しており、各データ処理操作の入力と出力の型が、使用している</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line11">
        <source>the signatures of the functions we're using.</source>
        <target state="translated">関数のシグネチャと一致するためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line1">
        <source>Lists are ordered, immutable, singly-linked lists.  They are eager in their evaluation.</source>
        <target state="translated">リストは、順序指定された、変更できない単方向リストです。  リストは集中評価されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line2">
        <source>This module shows various ways to generate lists and process lists with some functions</source>
        <target state="translated">このモジュールは、リストを生成し、F# コア ライブラリ内の 'List' モジュールに含まれる</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line3">
        <source>in the 'List' module in the F# Core Library.</source>
        <target state="translated">いくつかの関数を使用してリストを処理するためのさまざまな方法を示しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/lists</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/lists</target>
        <note />
      </trans-unit>
      <trans-unit id="ListEmptyDefinition">
        <source>Lists are defined using [ ... ].  This is an empty list.</source>
        <target state="translated">リストは [ ... ] を使用して定義されます。これは空のリストです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListElementDefinition">
        <source>This is a list with 3 elements.  ';' is used to separate elements on the same line.</source>
        <target state="translated">これは 3 つの要素を含むリストです。';' は同じ行にある要素を区切るために使用されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListNewlineElements">
        <source>You can also separate elements by placing them on their own lines.</source>
        <target state="translated">要素は、それぞれの行に配置することで分割することもできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="NumberList2">
        <source>This is a list of integers from 1 to 1000</source>
        <target state="translated">これは 1 ～ 1000 の整数のリストです</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputation-Line1">
        <source>Lists can also be generated by computations. This is a list containing</source>
        <target state="translated">リストは計算によっても生成できます。これは、次を含むリストです:</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputation-Line2">
        <source>all the days of the year.</source>
        <target state="translated">1 年のすべての日。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintList2">
        <source>Print the first 5 elements of 'daysList' using 'List.take'.</source>
        <target state="translated">'List.take' を使用して 'daysList' の最初の 5 つの要素を出力します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputationConditional-Line1">
        <source>Computations can include conditionals.  This is a list containing the tuples</source>
        <target state="translated">計算には条件を含めることができます。これはタプルを含むリストです</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputationConditional-Line2">
        <source>which are the coordinates of the black squares on a chess board.</source>
        <target state="translated">チェス盤の黒いマス目の座標のタプルを含むリストです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line1">
        <source>Lists can be transformed using 'List.map' and other functional programming combinators.</source>
        <target state="translated">リストは 'List.map' と他の関数型プログラミング連結子を使用して変換することができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line2">
        <source>This definition produces a new list by squaring the numbers in numberList, using the pipeline</source>
        <target state="translated">この定義は、パイプラインを使用して numberList 内の数値を 2 乗することによって新しいリストを生成します</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line3">
        <source>operator to pass an argument to List.map.</source>
        <target state="translated">引数を List.map に渡す演算子です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListFilter-Line1">
        <source>There are many other list combinations. The following computes the sum of the squares of the</source>
        <target state="translated">他に多くのリストの組み合わせがあります。次の二乗和をコンピューティングします:</target>
        <note />
      </trans-unit>
      <trans-unit id="ListFilter-Line2">
        <source>numbers divisible by 3.</source>
        <target state="translated">3 で割り切れる数。</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line1">
        <source>Arrays are fixed-size, mutable collections of elements of the same type.</source>
        <target state="translated">配列は、型が同じ要素の固定サイズの変更可能なコレクションです。</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line2">
        <source>Although they are similar to Lists (they support enumeration and have similar combinators for data processing),</source>
        <target state="translated">これらはリストと似ています (列挙型をサポートし、データ処理のための同様の連結子を備えています) が、</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line3">
        <source>they are generally faster and support fast random access.  This comes at the cost of being less safe by being mutable.</source>
        <target state="translated">一般的により高速であり、高速ランダム アクセスをサポートしています。その代わり、変更可能であるため安全性が低下します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/arrays</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/arrays</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyArray">
        <source>This is The empty array.  Note that the syntax is similar to that of Lists, but uses `[| ... |]` instead.</source>
        <target state="translated">これは空の配列です。構文はリストの構文と似ていますが、代わりに `[| ... |]` を使用することにご注意ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayConstructionList">
        <source>Arrays are specified using the same range of constructs as lists.</source>
        <target state="translated">配列は、リストと同じコンストラクトの範囲を使用して指定されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayConstructionRange">
        <source>This is an array of numbers from 1 to 1000.</source>
        <target state="translated">これは 1 ～ 1000 の数値の配列です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayComputationConstruction">
        <source>This is an array containing only the words "hello" and "world".</source>
        <target state="translated">これは "hello" と "world" のみを含む配列です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayInit">
        <source>This is an array initialized by index and containing the even numbers from 0 to 2000.</source>
        <target state="translated">これはインデックスによって初期化され、0 ～ 2000 の間の偶数を含む配列です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArraySlicing">
        <source>Sub-arrays are extracted using slicing notation.</source>
        <target state="translated">サブ配列はスライス表記法を使用して抽出されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayLooping">
        <source>You can loop over arrays and lists using 'for' loops.</source>
        <target state="translated">'for' ループを使用して、配列とリストに渡ってループできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayAssignment-Line1">
        <source>You can modify the contents of an an array element by using the left arrow assignment operator.</source>
        <target state="translated">左矢印代入演算子を使用して、配列要素の内容を変更できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayAssignment-Line2">
        <source>To learn more about this operator, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/values/index#mutable-variables</source>
        <target state="translated">この演算子の詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/values/index#mutable-variables</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayMap-Line1">
        <source>You can transform arrays using 'Array.map' and other functional programming operations.</source>
        <target state="translated">'Array.map' と他の関数型プログラミング操作を使用して、配列を変換できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayMap-Line2">
        <source>The following calculates the sum of the lengths of the words that start with 'h'.</source>
        <target state="translated">以下は、'h' で始まる単語の長さの合計を計算します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line1">
        <source>Sequences are a logical series of elements, all of the same type.  These are a more general type than Lists and Arrays.</source>
        <target state="translated">シーケンスは論理的な一連の要素であり、すべてが同じ型です。これらはリストや配列よりも一般的な型です。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line2">
        <source>Sequences are evaluated on-demand and are re-evaluated each time they are iterated.</source>
        <target state="translated">シーケンスはオンデマンドで評価され、繰り返されるたびに再評価されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line3">
        <source>An F# sequence is an alias for a .NET System.Collections.Generic.IEnumerable&lt;'T&gt;.</source>
        <target state="translated">F# シーケンスは .NET System.Collections.Generic.IEnumerable&lt;'T&gt; のエイリアスです。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line4">
        <source>Sequence processing functions can be applied to Lists and Arrays as well.</source>
        <target state="translated">シーケンス処理関数はリストと配列にも適用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line5">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/sequences</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/sequences</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptySequence">
        <source>This is the empty sequence.</source>
        <target state="translated">これは空のシーケンスです。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceOfValues">
        <source>This a sequence of values.</source>
        <target state="translated">これは一連の値です。</target>
        <note />
      </trans-unit>
      <trans-unit id="OnDemandSequence">
        <source>This is an on-demand sequence from 1 to 1000.</source>
        <target state="translated">これは 1 ～ 1000 のオンデマンドのシーケンスです。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceComposition">
        <source>This is a sequence producing the words "hello" and "world"</source>
        <target state="translated">これは 単語 "hello" と "world" を生成するシーケンスです</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceInit">
        <source>This sequence producing the even numbers up to 2000.</source>
        <target state="translated">このシーケンスは、2000 までの偶数を生成します。</target>
        <note />
      </trans-unit>
      <trans-unit id="InfiniteSequence-Line1">
        <source>This is an infinite sequence which is a random walk.</source>
        <target state="translated">これはランダム ウォークである無限シーケンスです。</target>
        <note />
      </trans-unit>
      <trans-unit id="InfiniteSequence-Line2">
        <source>This example uses yield! to return each element of a subsequence.</source>
        <target state="translated">この例では、yield! を使用して、サブシーケンスの各要素を返します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequence100Elements">
        <source>This example shows the first 100 elements of the random walk.</source>
        <target state="translated">この例では、ランダム ウォークの最初の 100 要素を示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line1">
        <source>Recursive functions can call themselves. In F#, functions are only recursive</source>
        <target state="translated">再帰関数は自身を呼び出すことができます。F# では、関数は単に再帰的です</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line2">
        <source>when declared using 'let rec'.</source>
        <target state="translated">'let rec' を使用して宣言される場合。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line3">
        <source>Recursion is the preferred way to process sequences or collections in F#.</source>
        <target state="translated">再帰は、F# でシーケンスまたはコレクションを処理するための推奨される方法です。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/index#recursive-functions</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/functions/index#recursive-functions</target>
        <note />
      </trans-unit>
      <trans-unit id="RecFunDef-Line1">
        <source>This example shows a recursive function that computes the factorial of an</source>
        <target state="translated">この例では、次の階乗をコンピューティングする再帰関数を示します</target>
        <note />
      </trans-unit>
      <trans-unit id="RecRunDef-Line2">
        <source>integer. It uses 'let rec' to define a recursive function.</source>
        <target state="translated">整数。'let rec' を使用して、再帰関数を定義します。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line1">
        <source>Computes the greatest common factor of two integers.</source>
        <target state="translated">2 つの整数の最大公約数をコンピューティングします。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line2">
        <source>Since all of the recursive calls are tail calls,</source>
        <target state="translated">すべての再帰呼び出しは末尾呼び出しであるため、</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line3">
        <source>the compiler will turn the function into a loop,</source>
        <target state="translated">コンパイラは関数をループにします</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line4">
        <source>which improves performance and reduces memory consumption.</source>
        <target state="translated">これによりパフォーマンスが向上し、メモリの消費を抑えることができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumList">
        <source>This example computes the sum of a list of integers using recursion.</source>
        <target state="translated">この例では、再帰を使用して整数のリストの合計をコンピューティングします。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTail">
        <source>This makes 'sumList' tail recursive, using a helper function with a result accumulator.</source>
        <target state="translated">これは、ヘルパー関数を結果アキュムレータと共に使用して 'sumList' を末尾再帰にします。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTailInvoke-Line1">
        <source>This invokes the tail recursive helper function, providing '0' as a seed accumulator.</source>
        <target state="translated">これは、シード アキュムレータとして '0' を指定して、末尾再帰的なヘルパー関数を呼び出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTailInvoke-Line2">
        <source>An approach like this is common in F#.</source>
        <target state="translated">F# では、このようなアプローチは一般的です。</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line1">
        <source>Records are an aggregate of named values, with optional members (such as methods).</source>
        <target state="translated">レコードは、オプションのメンバー (メソッドなど) を含む名前付きの値の集約です。</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line2">
        <source>They are immutable and have structural equality semantics.</source>
        <target state="translated">これらは変更できず、構造上の等価セマンティクスを持ちます。</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/records</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/records</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordDefinition">
        <source>This example shows how to define a new record type.</source>
        <target state="translated">この例では、新しいレコード型を定義する方法を示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordInstantiation1">
        <source>This example shows how to instantiate a record type.</source>
        <target state="translated">この例では、レコードの種類をインスタンス化する方法を示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordInstantiation2">
        <source>You can also do this on the same line with ';' separators.</source>
        <target state="translated">';' 区切りを使用して、同じ行でこれを行うこともできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line1">
        <source>This example shows how to use "copy-and-update" on record values. It creates</source>
        <target state="translated">この例では、レコード値で "copy-and-update" を使用する方法を示します。次を作成します:</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line2">
        <source>a new record value that is a copy of contact1, but has different values for</source>
        <target state="translated">contact1 のコピーであるレコード値。ただし、次の値は異なります:</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line3">
        <source>the 'Phone' and 'Verified' fields.</source>
        <target state="translated">[電話番号]5D; および [検証済み]5D; フィールド。</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/copy-and-update-record-expressions</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/copy-and-update-record-expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="ProcessRecord-Line1">
        <source>This example shows how to write a function that processes a record value.</source>
        <target state="translated">この例では、レコード値を処理する関数を書き込む方法を示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProcessRecord-Line2">
        <source>It converts a 'ContactCard' object to a string.</source>
        <target state="translated">'ContactCard' オブジェクトを文字列に変換します。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordWithMember-Line1">
        <source>This is an example of a Record with a member.</source>
        <target state="translated">これは、メンバーを含むレコードの例です。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordWithMember-Line2">
        <source>Members can implement object-oriented members.</source>
        <target state="translated">メンバーはオブジェクト指向のメンバーを実装できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordAccess">
        <source>Members are accessed via the '.' operator on an instantiated type.</source>
        <target state="translated">メンバーには、インスタンス化された型に対する '.' 演算子を介してアクセスできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line1">
        <source>Records can also be represented as structs via the 'Struct' attribute.</source>
        <target state="translated">レコードは 'Struct' 属性を介して構造体として表すこともできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line2">
        <source>This is helpful in situations where the performance of structs outweighs</source>
        <target state="translated">これは、構造体のパフォーマンスが参照型の柔軟性よりも</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line3">
        <source>the flexibility of reference types.</source>
        <target state="translated">重要である場合に役立ちます。</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line1">
        <source>Discriminated Unions (DU for short) are values which could be a number of named forms or cases.</source>
        <target state="translated">判別共用体 (略して DU) は、多数の名前付きのフォームまたはケースである可能性のある値です。</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line2">
        <source>Data stored in DUs can be one of several distinct values.</source>
        <target state="translated">DU の格納データは、複数の個別の値のいずれかになります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/discriminated-unions</target>
        <note />
      </trans-unit>
      <trans-unit id="CardSuit">
        <source>The following represents the suit of a playing card.</source>
        <target state="translated">たとえば、次は一揃いのトランプを表します。</target>
        <note />
      </trans-unit>
      <trans-unit id="CardRank">
        <source>A Disciminated Union can also be used to represent the rank of a playing card.</source>
        <target state="translated">判別共用体はトランプのランクを表すためにも使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="CardRankValue">
        <source>Represents the rank of cards 2 .. 10</source>
        <target state="translated">2 ～ 10 の札のランクを表します</target>
        <note />
      </trans-unit>
      <trans-unit id="CardMember">
        <source>Discriminated Unions can also implement object-oriented members.</source>
        <target state="translated">判別共用体はオブジェクト指向のメンバーを実装することもできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="CardType-Line1">
        <source>This is a record type that combines a Suit and a Rank.</source>
        <target state="translated">これは Suit と Rank を組み合わせたレコード型です。</target>
        <note />
      </trans-unit>
      <trans-unit id="CardType-Line2">
        <source>It's common to use both Records and Disciminated Unions when representing data.</source>
        <target state="translated">データを表すときには、レコードと判別共用体の両方を使用するのが一般的です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ComputeFullDeck">
        <source>This computes a list representing all the cards in the deck.</source>
        <target state="translated">これは、一組のトランプのすべてのカードを表すリストをコンピューティングします。</target>
        <note />
      </trans-unit>
      <trans-unit id="CardToString">
        <source>This example converts a 'Card' object to a string.</source>
        <target state="translated">この例では 'Card' オブジェクトを文字列に変換します。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintAllCards">
        <source>This example prints all the cards in a playing deck.</source>
        <target state="translated">この例では、一組のトランプのカードすべてを印刷します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line1">
        <source>Single-case DUs are often used for domain modeling.  This can buy you extra type safety</source>
        <target state="translated">単一ケースの DU は、ドメイン モデリングで多く使用されます。これにより、文字列や整数などの</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line2">
        <source>over primitive types such as strings and ints.</source>
        <target state="translated">プリミティブ型に加えて、さらにタイプ セーフが追加されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line3">
        <source>Single-case DUs cannot be implicitly converted to or from the type they wrap.</source>
        <target state="translated">単一ケースの DU は、ラップする型との間で暗黙的に変換することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line4">
        <source>For example, a function which takes in an Address cannot accept a string as that input,</source>
        <target state="translated">たとえば、アドレスを受け取る関数は文字列をその入力として受け入れることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line5">
        <source>or vive/versa.</source>
        <target state="translated">(その逆もできません)。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateSingleCaseDu">
        <source>You can easily instantiate a single-case DU as follows.</source>
        <target state="translated">次のように、単一ケースの DU のインスタンスを簡単に作成できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnwrapSingleCaseDu">
        <source>When you need the value, you can unwrap the underlying value with a simple function.</source>
        <target state="translated">値が必要な場合は、簡単な関数を使用して基になる値のラップを解除できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintSingleCaseDu">
        <source>Printing single-case DUs is simple with unwrapping functions.</source>
        <target state="translated">単一ケースの DU は、関数のラップを解除するだけで出力できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line1">
        <source>Disciminated Unions also support recursive definitions.</source>
        <target state="translated">判別共用体は再帰的な定義もサポートしています。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line2">
        <source>This represents a Binary Search Tree, with one case being the Empty tree,</source>
        <target state="translated">これはバイナリ検索ツリーを表します。片方のケースは空のツリーであり、</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line3">
        <source>and the other being a Node with a value and two subtrees.</source>
        <target state="translated">もう片方は値と 2 つのサブツリーを含む Node です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SearchBinaryTree-Line1">
        <source>Check if an item exists in the binary search tree.</source>
        <target state="translated">バイナリ検索ツリーにアイテムが存在するかどうかを確認します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SearchBinaryTree-Line2">
        <source>Searches recursively using Pattern Matching.  Returns true if it exists; otherwise, false.</source>
        <target state="translated">パターン マッチングを使用して再帰的に検索します。存在する場合は true を返し、そうでない場合は false を返します。</target>
        <note />
      </trans-unit>
      <trans-unit id="CheckLeftSubtree">
        <source>Check the left subtree.</source>
        <target state="translated">左側のサブツリーを確認します。</target>
        <note />
      </trans-unit>
      <trans-unit id="CheckRightSubtree">
        <source>Check the right subtree.</source>
        <target state="translated">右側のサブツリーを確認します。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line1">
        <source>Inserts an item in the Binary Search Tree.</source>
        <target state="translated">バイナリ検索ツリーにアイテムを挿入します。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line2">
        <source>Finds the place to insert recursively using Pattern Matching, then inserts a new node.</source>
        <target state="translated">パターン マッチングを使用して再帰的に挿入する場所を検索し、新しいノードを挿入します。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line3">
        <source>If the item is already present, it does not insert anything.</source>
        <target state="translated">アイテムが既に存在する場合は、何も挿入しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line4">
        <source>No need to insert, it already exists; return the node.</source>
        <target state="translated">既に存在しているため、挿入する必要はありません。ノードを返します。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line5">
        <source>Call into left subtree.</source>
        <target state="translated">左側のサブツリーに呼び出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line6">
        <source>Call into right subtree.</source>
        <target state="translated">右側のサブツリーに呼び出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line1">
        <source>Discriminated Unions can also be represented as structs via the 'Struct' attribute.</source>
        <target state="translated">判別共用体は、'Struct' 属性を介して構造体として表すこともできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line2">
        <source>This is helpful in situations where the performance of structs outweighs</source>
        <target state="translated">これは、構造体のパフォーマンスが参照型の柔軟性よりも</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line3">
        <source>the flexibility of reference types.</source>
        <target state="translated">重要である場合に役立ちます。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line4">
        <source>However, there are two important things to know when doing this:</source>
        <target state="translated">ただし、これを行うときに理解しておく必要のある重要な点が 2 つあります:</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line5">
        <source>1. A struct DU cannot be recursively-defined.</source>
        <target state="translated">1. 構造体 DU は再帰的に定義できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line6">
        <source>2. A struct DU must have unique names for each of its cases.</source>
        <target state="translated">2. 構造体 DU の名前は各ケースに対して一意である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line1">
        <source>Pattern Matching is a feature of F# that allows you to utilize Patterns,</source>
        <target state="translated">パターン マッチングはパターンを使用できるようにする F# の機能です。</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line2">
        <source>which are a way to compare data with a logical structure or structures,</source>
        <target state="translated">これは、データと 1 つまたは複数の論理構造を比較したり、</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line3">
        <source>decompose data into constituent parts, or extract information from data in various ways.</source>
        <target state="translated">データを構成要素部分に分解したり、さまざまな方法でデータから情報を抽出したりするための方法です。</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line4">
        <source>You can then dispatch on the "shape" of a pattern via Pattern Matching.</source>
        <target state="translated">その後、パターン マッチングを介してパターンの "形" でディスパッチできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line5">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/pattern-matching</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/pattern-matching</target>
        <note />
      </trans-unit>
      <trans-unit id="PersonRecord">
        <source>A record for a person's first and last name</source>
        <target state="translated">個人の姓および名のレコード</target>
        <note />
      </trans-unit>
      <trans-unit id="EmployeeDu">
        <source>A Discriminated Union of 3 different kinds of employees</source>
        <target state="translated">3 種類の社員の判別共用体</target>
        <note />
      </trans-unit>
      <trans-unit id="CountEmployees-Line1">
        <source>Count everyone underneath the employee in the management hierarchy,</source>
        <target state="translated">管理階層構造の中で、ある社員の下にいる全員の数を数えます</target>
        <note />
      </trans-unit>
      <trans-unit id="CountEmployees-Line2">
        <source>including the employee.</source>
        <target state="translated">(その社員自身を含む)。</target>
        <note />
      </trans-unit>
      <trans-unit id="FindDave-Line1">
        <source>Find all managers/executives named "Dave" who do not have any reports.</source>
        <target state="translated">名前が "Dave" で、レポートのないすべてのマネージャー/役員を検索します。</target>
        <note />
      </trans-unit>
      <trans-unit id="FindDave-Line2">
        <source>This uses the 'function' shorthand to as a lambda expression.</source>
        <target state="translated">これは、ラムダ式として 'function' の短縮形を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchEmptyList">
        <source>[] matches an empty list.</source>
        <target state="translated">[] は空白のリストに一致します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchWildcard-Line1">
        <source>'_' is a wildcard pattern that matches anything.</source>
        <target state="translated">'_' は、任意のものに一致するワイルドカード パターンです。</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchWildCard-Line2">
        <source>This handles the "or else" case.</source>
        <target state="translated">これは "or else" ケースを処理します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchShorthand-Line1">
        <source>You can also use the shorthand function construct for pattern matching,</source>
        <target state="translated">パターン マッチングのために、短縮形の関数コンストラクトを使用することもできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchShorthand-Line2">
        <source>which is useful when you're writing functions which make use of Partial Application.</source>
        <target state="translated">これは、部分適用を利用する関数を記述している場合に役立ちます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ParseHelpers">
        <source>Define some more functions which parse with the helper function.</source>
        <target state="translated">ヘルパー関数で解析する別の関数をいくつか定義します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line1">
        <source>Active Patterns are another powerful construct to use with pattern matching.</source>
        <target state="translated">アクティブなパターンは、パターン マッチングで使用するもう 1 つの強力なコンストラクトです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line2">
        <source>They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</source>
        <target state="translated">パターン マッチの呼び出しサイトで分解して、入力データをカスタム フォームにパーティション分割できるようにします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/active-patterns</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/active-patterns</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchActivePattern">
        <source>Pattern Matching via 'function' keyword and Active Patterns often looks like this.</source>
        <target state="translated">'function' キーワードとアクティブ パターンによるパターン マッチングは、多くの場合、次のようになります。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintParse">
        <source>Call the printer with some different values to parse.</source>
        <target state="translated">解析するいくつかの異なる値でプリンターを呼び出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line1">
        <source>Option values are any kind of value tagged with either 'Some' or 'None'.</source>
        <target state="translated">オプション値とは、'Some' または 'None' がタグされたあらゆる種類の値です。</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line2">
        <source>They are used extensively in F# code to represent the cases where many other</source>
        <target state="translated">F# コードで広く使用され、他の多くの言語で null 参照が使用される</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line3">
        <source>languages would use null references.</source>
        <target state="translated">ケースを表します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/options</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/options</target>
        <note />
      </trans-unit>
      <trans-unit id="ZipCode">
        <source>First, define a zipcode defined via Single-case Discriminated Union.</source>
        <target state="translated">まず、単一ケースの判別共用体を介して定義した郵便番号を定義します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Customer">
        <source>Next, define a type where the ZipCode is optional.</source>
        <target state="translated">次に、郵便番号が省略可能である型を定義します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ShippingCalculator-Line1">
        <source>Next, define an interface type that represents an object to compute the shipping zone for the customer's zip code,</source>
        <target state="translated">次に、オブジェクトを表すインターフェイスの型を定義して、顧客の郵便番号の出荷ゾーンをコンピューティングし、</target>
        <note />
      </trans-unit>
      <trans-unit id="ShippingCalculator-Line2">
        <source>given implementations for the 'getState' and 'getShippingZone' abstract methods.</source>
        <target state="translated">'getState' および 'getShippingZone' 抽象メソッドの実装が指定されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line1">
        <source>Next, calculate a shipping zone for a customer using a calculator instance.</source>
        <target state="translated">次に、電卓のインスタンスを使用して顧客の出荷ゾーンを計算します。</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line2">
        <source>This uses combinators in the Option module to allow a functional pipeline for</source>
        <target state="translated">これは、オプション モジュール内の連結子を使用することにより、オプションを使用したデータ変換のために</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line3">
        <source>transforming data with Optionals.</source>
        <target state="translated">関数型パイプラインを使用できるようにします。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line1">
        <source>Units of measure are a way to annotate primitive numeric types in a type-safe way.</source>
        <target state="translated">測定単位は、タイプ セーフな方法でプリミティブな数値型に注釈を付ける方法です。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line2">
        <source>You can then perform type-safe arithmetic on these values.</source>
        <target state="translated">次に、これらの値に対してタイプ セーフの算術を実行できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/units-of-measure</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/units-of-measure</target>
        <note />
      </trans-unit>
      <trans-unit id="CommonUnits">
        <source>First, open a collection of common unit names</source>
        <target state="translated">まず、共通の単位名のコレクションを開きます</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineUnitConstant">
        <source>Define a unitized constant</source>
        <target state="translated">単位化された定数を定義します</target>
        <note />
      </trans-unit>
      <trans-unit id="MileUnit">
        <source>Next, define a new unit type</source>
        <target state="translated">次に、新しい単位の種類を定義します</target>
        <note />
      </trans-unit>
      <trans-unit id="MileToMeter">
        <source>Conversion factor mile to meter.</source>
        <target state="translated">マイルからメートルへの変換係数。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineMileConstant">
        <source>Define a unitized constant</source>
        <target state="translated">単位化された定数を定義します</target>
        <note />
      </trans-unit>
      <trans-unit id="ComputeMileToMeter">
        <source>Compute  metric-system constant</source>
        <target state="translated">メートル法の定数をコンピューティングします</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintUnitsOfMeasure">
        <source>Values using Units of Measure can be used just like the primitive numeric type for things like printing.</source>
        <target state="translated">測定単位を使用する値は、印刷などに対するプリミティブな数値型と同じように使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line1">
        <source>Classes are a way of defining new object types in F#, and support standard Object-oriented constructs.</source>
        <target state="translated">クラスは、F# で新しいオブジェクト型を定義する方法であり、標準のオブジェクト指向のコンストラクトをサポートします。</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line2">
        <source>They can have a variety of members (methods, properties, events, etc.)</source>
        <target state="translated">さまざまなメンバー (メンバー、プロパティ、イベントなど) を含めることができます</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line3">
        <source>To learn more about Classes, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/classes</source>
        <target state="translated">クラスの詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/classes</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line4">
        <source>To learn more about Members, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members</source>
        <target state="translated">メンバーの詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/members</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line1">
        <source>A simple two-dimensional Vector class.</source>
        <target state="translated">単純な 2 次元のベクター クラス。</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line2">
        <source>The class's constructor is on the first line,</source>
        <target state="translated">クラスのコンストラクターは最初の行にあり、</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line3">
        <source>and takes two arguments: dx and dy, both of type 'double'.</source>
        <target state="translated">また、dx と dy の 2 つの引数を取ります。どちらも 'double' 型です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInternalField-Line1">
        <source>This internal field stores the length of the vector, computed when the</source>
        <target state="translated">この内部フィールドはベクトルの長さを格納します。これは、次の時点でにコンピューティングされます:</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInternalField-Line2">
        <source>object is constructed</source>
        <target state="translated">オブジェクトが構築されます</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisKeyword-Line1">
        <source>'this' specifies a name for the object's self identifier.</source>
        <target state="translated">'this' は、オブジェクトの自己識別子の名前を指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisKeyword-Line2">
        <source>In instance methods, it must appear before the member name.</source>
        <target state="translated">インスタンス メソッドでは、メンバー名の前に表示される必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MemberMethod">
        <source>This member is a method.  The previous members were properties.</source>
        <target state="translated">このメンバーはメソッドです。前のメンバーはプロパティでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateClass">
        <source>This is how you instantiate the Vector2D class.</source>
        <target state="translated">これは、Vector2D クラスのインスタンスを作成する方法です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ScaledVector">
        <source>Get a new scaled vector object, without modifying the original object.</source>
        <target state="translated">元のオブジェクトを変更せずに、新しくスケーリングされたベクター オブジェクトを取得します。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line1">
        <source>Generic classes allow types to be defined with respect to a set of type parameters.</source>
        <target state="translated">ジェネリック クラスでは、型パラメーターのセットに対して型を定義することができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line2">
        <source>In the following, 'T is the type parameter for the class.</source>
        <target state="translated">以下では、'T はクラスの型パラメーターです。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/generics/</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalField">
        <source>This internal field store the states in a list.</source>
        <target state="translated">この内部フィールドは状態をリストに保存します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddElement">
        <source>Add a new element to the list of states.</source>
        <target state="translated">状態のリストに新しい要素を追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment">
        <source>use the '&lt;-' operator to mutate the value.</source>
        <target state="translated">'&lt;-' 演算子を使用して、値を変換します。</target>
        <note />
      </trans-unit>
      <trans-unit id="History">
        <source>Get the entire list of historical states.</source>
        <target state="translated">状態の履歴のリスト全体を取得します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Current">
        <source>Get the latest state.</source>
        <target state="translated">最新の状態を取得します。</target>
        <note />
      </trans-unit>
      <trans-unit id="InferredTypeParameter">
        <source>An 'int' instance of the state tracker class. Note that the type parameter is inferred.</source>
        <target state="translated">状態トラッカー クラスの 'int' インスタンス。型パラメーターは推論されていることに注意してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddState">
        <source>Add a state</source>
        <target state="translated">状態を追加します</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line1">
        <source>Interfaces are object types with only 'abstract' members.</source>
        <target state="translated">インターフェイスは 'abstract' メンバーのみを持つオブジェクト型です。</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line2">
        <source>Object types and object expressions can implement interfaces.</source>
        <target state="translated">オブジェクト型とオブジェクト式はインターフェイスを実装できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/interfaces</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposable">
        <source>This is a type that implements IDisposable.</source>
        <target state="translated">これは IDisposable を実装する型です。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableImplementation">
        <source>This is the implementation of IDisposable members.</source>
        <target state="translated">これは IDisposable メンバーの実装です。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line1">
        <source>This is an object that implements IDisposable via an Object Expression</source>
        <target state="translated">これは、オブジェクト式を使用して IDisposable を実装するオブジェクトです</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line2">
        <source>Unlike other languages such as C# or Java, a new type definition is not needed</source>
        <target state="translated">C# や Java などの他の言語とは異なり、インターフェイスを実装するために</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line3">
        <source>to implement an interface.</source>
        <target state="translated">新しい型定義は必要ありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line1">
        <source>The FSharp.Core library defines a range of parallel processing functions.  Here</source>
        <target state="translated">FSharp.Core ライブラリは並列処理関数の範囲を定義します。ここでは</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line2">
        <source>you use some functions for parallel processing over arrays.</source>
        <target state="translated">アレイ全体で並列処理に対していくつかの関数を使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line3">
        <source>To learn more, see: https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/array.parallel-module-%5Bfsharp%5D</source>
        <target state="translated">詳細については、次を参照してください: https://msdn.microsoft.com/ja-jp/visualfsharpdocs/conceptual/array.parallel-module-%5Bfsharp%5D</target>
        <note />
      </trans-unit>
      <trans-unit id="InputArray">
        <source>First, an array of inputs.</source>
        <target state="translated">まず、入力の配列です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpensiveFunction">
        <source>Next, define a functions that does some CPU intensive computation.</source>
        <target state="translated">次に、CPU 集約型の計算を実行する関数を定義します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ParallelMap">
        <source>Next, do a parallel map over a large input array.</source>
        <target state="translated">次に、大きい入力配列に対して並列マップを実行します。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintParallel">
        <source>Next, print the results.</source>
        <target state="translated">次に、結果を印刷します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Events-Line1">
        <source>Events are a common idiom for .NET programming, especially with WinForms or WPF applications.</source>
        <target state="translated">イベントは、特に WinForms または WPF アプリケーションでの .NET プログラミングの一般的な用法です。</target>
        <note />
      </trans-unit>
      <trans-unit id="Events-Line2">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/events</source>
        <target state="translated">詳細については、次を参照してください: https://docs.microsoft.com/ja-jp/dotnet/articles/fsharp/language-reference/members/events</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleEvent">
        <source>First, create instance of Event object that consists of subscription point (event.Publish) and event trigger (event.Trigger).</source>
        <target state="translated">まず、サブスクリプション ポイント (event.Publish) およびイベント トリガー (event.Trigger) で構成されるイベント オブジェクトのインスタンスを作成します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddEventHandler1">
        <source>Next, add handler to the event.</source>
        <target state="translated">次に、ハンドラーをイベントに追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="TriggerEvent">
        <source>Next, trigger the event.</source>
        <target state="translated">次に、イベントをトリガーします。</target>
        <note />
      </trans-unit>
      <trans-unit id="EventWithArgs">
        <source>Next, create an instance of Event that follows standard .NET convention: (sender, EventArgs).</source>
        <target state="translated">次に、標準的な .NET 表記規則に従うイベントのインスタンスを作成します: (sender, EventArgs)。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddEventHandler2">
        <source>Next, add a handler for this new event.</source>
        <target state="translated">次に、この新しいイベントのハンドラーを追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="TriggerEventWithArgs">
        <source>Next, trigger this event (note that sender argument should be set).</source>
        <target state="translated">次に、このイベントをトリガーします (sender 引数を設定する必要があります)。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>