<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="de" original="../Tutorial.fsx">
    <body>
      <trans-unit id="SampleHeader">
        <source>This sample will guide you through elements of the F# language.</source>
        <target state="translated">Dieses Beispiel zeigt Ihnen verschiedene Elemente der F#-Programmiersprache.</target>
        <note />
      </trans-unit>
      <trans-unit id="Instructions-Line1">
        <source>To execute the code in F# Interactive, highlight a section of code and press Alt-Enter or right-click</source>
        <target state="translated">Markieren Sie zum Ausführen des Codes in F# Interactive einen Codeabschnitt, und drücken Sie dann entweder ALT+EINGABETASTE oder klicken Sie mit der rechten Maustaste</target>
        <note />
      </trans-unit>
      <trans-unit id="Instructions-Line2">
        <source>and select "Execute in Interactive".  You can open the F# Interactive Window from the "View" menu.</source>
        <target state="translated">und wählen Sie "In Interactive ausführen" aus.  Sie können das F# Interactive-Fenster über das Menü "Ansicht" öffnen.</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreAbout">
        <source>For more about F#, see:</source>
        <target state="translated">Weitere Informationen zu F# finden Sie unter:</target>
        <note />
      </trans-unit>
      <trans-unit id="SeeDocumentaton">
        <source>To see this tutorial in documentation form, see:</source>
        <target state="translated">Dieses Tutorial ist auch als Dokumentation verfügbar. Siehe hierzu:</target>
        <note />
      </trans-unit>
      <trans-unit id="LearnMoreAbout">
        <source>To learn more about applied F# programming, use</source>
        <target state="translated">Verwenden Sie Folgendes, um weitere Informationen zur praktischen F#-Programmierung zu erhalten</target>
        <note />
      </trans-unit>
      <trans-unit id="ToInstall-Line1">
        <source>To install the Visual F# Power Tools, use</source>
        <target state="translated">Verwenden Sie Folgendes, um die Visual F# Power Tools zu installieren</target>
        <note />
      </trans-unit>
      <trans-unit id="ToInstall-Line2">
        <source>'Tools' --&gt; 'Extensions and Updates' --&gt; `Online` and search</source>
        <target state="translated">"Extras" &gt; "Erweiterungen und Updates" &gt; "Online", und suchen Sie nach</target>
        <note />
      </trans-unit>
      <trans-unit id="AdditionalTemplates-Line1">
        <source>For additional templates to use with F#, see the 'Online Templates' in Visual Studio,</source>
        <target state="translated">Weitere Vorlagen zum Verwenden mit F# finden Sie in Visual Studio unter "Onlinevorlagen",</target>
        <note />
      </trans-unit>
      <trans-unit id="AdditionalTemplates-Line2">
        <source>'New Project' --&gt; 'Online Templates'</source>
        <target state="translated">"Neue Projekte" &gt; "Onlinevorlagen".</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportsComments">
        <source>F# supports three kinds of comments:</source>
        <target state="translated">F# unterstützt drei Arten von Kommentaren:</target>
        <note />
      </trans-unit>
      <trans-unit id="DoubleSlash">
        <source>1. Double-slash comments.  These are used in most situations.</source>
        <target state="translated">1. Kommentare mit doppeltem Schrägstrich. Diese werden in den meisten Situationen verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="MLStyle">
        <source>2. ML-style Block comments.  These aren't used that often.</source>
        <target state="translated">2. Blockkommentare im ML-Stil. Diese werden nicht sehr häufig verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="TripleSlash-Line1">
        <source>3. Triple-slash comments.  These are used for documenting functions, types, and so on.</source>
        <target state="translated">3. Kommentare mit drei Schrägstrichen. Diese werden zum Dokumentieren von Funktionen, Typen usw. verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="TripleSlash-Line2">
        <source>They will appear as text when you hover over something which is decorated with these comments.</source>
        <target state="translated">Sie erscheinen als Text, wenn Sie den Mauszeiger über einem Element positionieren, das mit diesen Kommentaren versehen ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line1">
        <source>They also support .NET-style XML comments, which allow you to generate reference documentation,</source>
        <target state="translated">Sie bieten außerdem Unterstützung für XML-Kommentare im .NET-Stil zum Generieren von Referenzdokumentation,</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line2">
        <source>and they also allow editors (such as Visual Studio) to extract information from them.</source>
        <target state="translated">und sie ermöglichen das Extrahieren von Informationen über Editoren (z.B. Visual Studio).</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/xml-documentation</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/xml-documentation.</target>
        <note />
      </trans-unit>
      <trans-unit id="OpenNamespaces">
        <source>Open namespaces using the 'open' keyword.</source>
        <target state="translated">Öffnen Sie Namespaces mit dem Schlüsselwort "open".</target>
        <note />
      </trans-unit>
      <trans-unit id="LearnMore">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/import-declarations-the-open-keyword</source>
        <target state="translated">Weitere Informationen finden Sie hier: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/import-declarations-the-open-keyword.</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line1">
        <source>A module is a grouping of F# code, such as values, types, and function values.</source>
        <target state="translated">Ein Modul ist eine Gruppierung von F#-Code, z.B. Werte, Typen und Funktionswerte.</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line2">
        <source>Grouping code in modules helps keep related code together and helps avoid name conflicts in your program.</source>
        <target state="translated">Die Codegruppierung in Modulen ermöglicht das Zusammenfassen von zueinander in Beziehung stehendem Code sowie das Vermeiden von Namenskonflikten in Ihrem Programm.</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/modules</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/modules.</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleInt">
        <source>This is a sample integer.</source>
        <target state="translated">Dies ist ein Beispiel für eine Ganzzahl.</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleFloat">
        <source>This is a sample floating point number.</source>
        <target state="translated">Dies ist ein Beispiel für eine Gleitkommazahl.</target>
        <note />
      </trans-unit>
      <trans-unit id="Computed-Line1">
        <source>This computed a new number by some arithmetic.  Numeric types are converted using</source>
        <target state="translated">Hier wird mithilfe einer arithmetischen Operation eine neue Zahl berechnet. Numerische Typen werden unter Verwendung der</target>
        <note />
      </trans-unit>
      <trans-unit id="Computed-Line2">
        <source>functions 'int', 'double' and so on.</source>
        <target state="translated">Funktionen "int", "double" usw. konvertiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListNumbers">
        <source>This is a list of the numbers from 0 to 99.</source>
        <target state="translated">Dies ist eine Liste der Zahlen von 0 bis 99.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListSquares">
        <source>This is a list of all tuples containing all the numbers from 0 to 99 and their squares.</source>
        <target state="translated">Dies ist eine Liste aller Tupel, die alle Zahlen von 0 bis 99 sowie Ihre Quadratzahlen enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintList1">
        <source>The next line prints a list that includes tuples, using '%A' for generic printing.</source>
        <target state="translated">Die nächste Zeile gibt eine Liste mit Tupeln aus, wobei "%A" für die generische Ausgabe verwendet wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleIntType">
        <source>This is a sample integer with a type annotation</source>
        <target state="translated">Dies ist ein Beispiel für eine ganze Zahl mit einer Typanmerkung.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line1">
        <source>Values in F# are immutable by default.  They cannot be changed</source>
        <target state="translated">Werte in F# sind standardmäßig unveränderlich. Sie können im Verlauf</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line2">
        <source>in the course of a program's execution unless explicitly marked as mutable.</source>
        <target state="translated">der Ausführung eines Programms nicht geändert werden – es sei denn, sie sind explizit als änderbar gekennzeichnet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/values/index#why-immutable</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/values/index#why-immutable</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line1">
        <source>Binding a value to a name via 'let' makes it immutable.</source>
        <target state="translated">Wenn ein Wert mithilfe von "let" an einen Namen gebunden wird, ist er unveränderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line2">
        <source>The second line of code fails to compile because 'number' is immutable and bound.</source>
        <target state="translated">Die zweite Codezeile kann nicht kompiliert werden, da "number" unveränderlich und gebunden ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line3">
        <source>Re-defining 'number' to be a different value is not allowed in F#.</source>
        <target state="translated">"number" darf in F# nicht als ein anderer Wert neu definiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableKeyword">
        <source>A mutable binding.  This is required to be able to mutate the value of 'otherNumber'.</source>
        <target state="translated">Eine veränderliche Bindung. Dies ist erforderlich, damit der Wert von "otherNumber" verändert werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line1">
        <source>When mutating a value, use '&lt;-' to assign a new value.</source>
        <target state="translated">Wenn Sie einen Wert verändern, weisen Sie mithilfe von "&lt;-" einen neuen Wert zu.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line2">
        <source>You could not use '=' here for this purpose since it is used for equality</source>
        <target state="translated">Sie können "=" hier nicht verwenden, da es für Gleichheit verwendet wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line3">
        <source>or other contexts such as 'let' or 'module'</source>
        <target state="translated">oder andere Kontexte wie "let" oder "module"</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line1">
        <source>Much of F# programming consists of defining functions that transform input data to produce</source>
        <target state="translated">Bei der F#-Programmierung werden größtenteils Funktionen definiert, die Eingabedaten in hilfreiche</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line2">
        <source>useful results.</source>
        <target state="translated">Ergebnisse umwandelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/functions/</target>
        <note />
      </trans-unit>
      <trans-unit id="LetFunction-Line1">
        <source>You use 'let' to define a function. This one accepts an integer argument and returns an integer.</source>
        <target state="translated">Verwenden Sie "let", um eine Funktion zu definieren. Diese akzeptiert ein Integer-Argument und gibt einen Integer zurück.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetFunction-Line2">
        <source>Parentheses are optional for function arguments, except for when you use an explicit type annotation.</source>
        <target state="translated">Klammern sind für Funktionsargumente optional, außer wenn Sie eine explizite Typanmerkung verwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyFunction-Line1">
        <source>Apply the function, naming the function return result using 'let'.</source>
        <target state="translated">Die Funktion anwenden, und das Rückgabeergebnis der Funktion mithilfe von "let" benennen.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyFunction-Line2">
        <source>The variable type is inferred from the function return type.</source>
        <target state="translated">Der Variablentyp wird vom Rückgabetyp der Funktion abgeleitet.</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line1">
        <source>This line uses '%d' to print the result as an integer. This is type-safe.</source>
        <target state="translated">Diese Zeile verwendet "%d", um das Ergebnis als Integer zu drucken. Dies ist typsicher.</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line2">
        <source>If 'result1' were not of type 'int', then the line would fail to compile.</source>
        <target state="translated">Wenn "result1" nicht vom Typ "int" wäre, käme es bei der Kompilierung der Zeile zu einem Fehler.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeAnnotation">
        <source>When needed, annotate the type of a parameter name using '(argument:type)'.  Parentheses are required.</source>
        <target state="translated">Blenden Sie bei Bedarf den Typ eines Parameternamens mithilfe von "(argument:type)" ein. Klammern sind erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="Conditionals-Line1">
        <source>Conditionals use if/then/elid/elif/else.</source>
        <target state="translated">Für Bedingungen wird Folgendes verwendet: if/then/elid/elif/else.</target>
        <note />
      </trans-unit>
      <trans-unit id="Conditionals-Line2">
        <source>Note that F# uses whitespace indentation-aware syntax, similar to languages like Python.</source>
        <target state="translated">Bei der Syntax von F# werden ebenso wie bei Sprachen wie Python leerzeichenbasierte Einzüge beachtet.</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line3">
        <source>This line uses '%f' to print the result as a float.  As with '%d' above, this is type-safe.</source>
        <target state="translated">Diese Zeile verwendet "%f", um das Ergebnis als float-Eigenschaft zu drucken. Wie auch zuvor bei "%d" ist dies typsicher.</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line1">
        <source>Booleans are fundamental data types in F#.  Here are some examples of Booleans and conditional logic.</source>
        <target state="translated">Boolesche Werte sind grundlegende Datentypen in F#. Hier finden Sie einige Beispiele für boolesche Werte und Bedingungen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line2">
        <source>To learn more, see:</source>
        <target state="translated">Weitere Informationen finden Sie unter:</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line3">
        <source>and</source>
        <target state="translated">Und</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanValues">
        <source>Booleans values are 'true' and 'false'.</source>
        <target state="translated">Boolesche Werte sind "true" und "false".</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanOperators">
        <source>Operators on booleans are 'not', '&amp;&amp;' and '||'.</source>
        <target state="translated">Operatoren für boolesche Werte sind "not", "&amp;&amp;" und "||".</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanPrintf">
        <source>This line uses '%b'to print a boolean value.  This is type-safe.</source>
        <target state="translated">Diese Zeile verwendet "%b" zum Drucken eines booleschen Werts. Dies ist typsicher.</target>
        <note />
      </trans-unit>
      <trans-unit id="Strings-Line1">
        <source>Strings are fundamental data types in F#.  Here are some examples of Strings and basic String manipulation.</source>
        <target state="translated">Zeichenfolgen sind grundlegende Datentypen in F#. Hier finden Sie einige Beispiele für Zeichenfolgen und Zeichenfolgenmanipulationen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Strings-Line2">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/strings</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/strings</target>
        <note />
      </trans-unit>
      <trans-unit id="StringQuotes">
        <source>Strings use double quotes.</source>
        <target state="translated">Für Zeichenfolgen werden doppelte Anführungszeichen verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringLiterals-Line1">
        <source>Strings can also use @ to create a verbatim string literal.</source>
        <target state="translated">Mit "@" lassen sich ausführliche Zeichenfolgenliterale erstellen.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringLiterals-Line2">
        <source>This will ignore escape characters such as '\', '\n', '\t', etc.</source>
        <target state="translated">Dadurch werden Escapezeichen wie "\", "\n", "\t" usw. ignoriert.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringTripleQuotes">
        <source>String literals can also use triple-quotes.</source>
        <target state="translated">Für Zeichenfolgen können auch dreifache Anführungszeichen verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringConcatenation">
        <source>String concatenation is normally done with the '+' operator.</source>
        <target state="translated">Die Verkettung von Zeichenfolgen erfolgt in der Regel mit dem Operator "+".</target>
        <note />
      </trans-unit>
      <trans-unit id="StringPrinting">
        <source>This line uses '%s' to print a string value.  This is type-safe.</source>
        <target state="translated">Diese Zeile verwendet "%s" zum Drucken eines Zeichenfolgewerts. Dies ist typsicher.</target>
        <note />
      </trans-unit>
      <trans-unit id="Substrings-Line1">
        <source>Substrings use the indexer notation.  This line extracts the first 7 characters as a substring.</source>
        <target state="translated">Für Teilzeichenfolgen wird die Indexernotation verwendet. Diese Zeile extrahiert die ersten sieben Zeichen als Teilzeichenfolge.</target>
        <note />
      </trans-unit>
      <trans-unit id="Substrings-Line2">
        <source>Note that like many languages, Strings are zero-indexed in F#.</source>
        <target state="translated">Im Gegensatz zu den meisten anderen Sprachen sind Zeichenfolgen in F# nullindiziert.</target>
        <note />
      </trans-unit>
      <trans-unit id="Tuples-Line1">
        <source>Tuples are simple combinations of data values into a combined value.</source>
        <target state="translated">Tupel sind einfache Datenwertkombinationen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Tuples-Line2">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/tuples</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/tuples</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleInteger">
        <source>A simple tuple of integers.</source>
        <target state="translated">Ein einfaches Tupel aus Integerwerten.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line1">
        <source>A function that swaps the order of two values in a tuple.</source>
        <target state="translated">Eine Funktion, die die Reihenfolge von zwei Werten in einem Tupel austauscht.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line2">
        <source>F# Type Inference will automatically generalize the function to have a generic type,</source>
        <target state="translated">Der F#-Typrückschluss generalisiert die Funktion automatisch und erstellt einen generischen Typ,</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line3">
        <source>meaning that it will work with any type.</source>
        <target state="translated">d. h. er funktioniert mit jedem Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleMultiType-Line1">
        <source>A tuple consisting of an integer, a string,</source>
        <target state="translated">Ein Tupel aus einem Integer, einer Zeichenfolge</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleMultiType-Line2">
        <source>and a double-precision floating point number.</source>
        <target state="translated">und einer Gleitkommazahl mit doppelter Genauigkeit.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleTypeAnnotation-Line1">
        <source>A simple tuple of integers with a type annotation.</source>
        <target state="translated">Ein einfaches Tupel aus Integerwerten mit einer Typanmerkung.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleTypeAnnotation-Line2">
        <source>Type annotations for tuples use the * symbol to separate elements</source>
        <target state="translated">Typanmerkungen für Tupel trennen Elemente durch das *-Symbol.</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line1">
        <source>Tuples are normally objects, but they can also be represented as structs.</source>
        <target state="translated">Tupel sind normalerweise Objekte, sie können aber auch als Strukturen dargestellt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line2">
        <source>These interoperate completely with structs in C# and Visual Basic.NET; however,</source>
        <target state="translated">Sie arbeiten mit Strukturen in C# und Visual Basic.Net vollständig zusammen.</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line3">
        <source>struct tuples are not implicitly convertable with object tuples (often called reference tuples).</source>
        <target state="translated">Strukturtupel sind jedoch nicht implizit mit Objekttupeln (häufig als Referenztupel bezeichnet) konvertierbar.</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line4">
        <source>The second line below will fail to compile because of this.  Uncomment it to see what happens.</source>
        <target state="translated">Die unten angezeigte zweite Zeile kann aus diesem Grund nicht kompiliert werden. Heben Sie die Auskommentierung auf, und sehen Sie, was passiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleConvert-Line1">
        <source>Although you cannot implicitly convert between struct tuples and reference tuples,</source>
        <target state="translated">Sie können zwar nicht implizit zwischen Strukturtupeln und Verweistupeln konvertieren,</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleConvert-Line2">
        <source>you can explicitly convert via pattern matching, as demonstrated below.</source>
        <target state="translated">Sie können aber wie unten gezeigt eine explizite Konvertierung über den Musterabgleich durchführen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line1">
        <source>The F# pipe operators ('|&gt;', '&lt;|', etc.) and F# composition operators ('&gt;&gt;', '&lt;&lt;')</source>
        <target state="translated">Die F#-PipeOperatoren ("|&gt;", "&lt;|" usw.) und die F#-Zusammensetzungsoperatoren ("&gt;&gt;", "&lt;&lt;")</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line2">
        <source>are used extensively when processing data.  These operators are themselves functions</source>
        <target state="translated">werden bei der Datenverarbeitung umfassend eingesetzt. Diese Operatoren sind Funktionen,</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line3">
        <source>which make use of Partial Application.</source>
        <target state="translated">die die partielle Anwendung nutzen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line4">
        <source>To learn more about these operators, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/#function-composition-and-pipelining</source>
        <target state="translated">Weitere Informationen zu diesen Operatoren finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/functions/#function-composition-and-pipelining</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line5">
        <source>To learn more about Partial Application, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/#partial-application-of-arguments</source>
        <target state="translated">Weitere Informationen zur partiellen Anwendung finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/functions/#partial-application-of-arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="Squares">
        <source>Squares a value.</source>
        <target state="translated">Quadriert einen Wert.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddOne">
        <source>Adds 1 to a value.</source>
        <target state="translated">Addiert 1 zu einem Wert hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestOdd">
        <source>Tests if an integer value is odd via modulo.</source>
        <target state="translated">Testet mit Modulo, ob ein Integerwert gerade ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="NumberList1">
        <source>A list of 5 numbers.  More on lists later.</source>
        <target state="translated">Eine Liste mit fünf Nummern. Weitere Informationen zu Listen finden Sie später.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithoutPipes-Line1">
        <source>Given a list of integers, it filters out the even numbers,</source>
        <target state="translated">Aus einer Liste mit Integern werden die geraden Zahlen herausgefiltert,</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithoutPipes-Line2">
        <source>squares the resulting odds, and adds 1 to the squared odds.</source>
        <target state="translated">die sich ergebenden ungeraden Zahlen werden quadratiert, und zu dem Ergebnis wird 1 hinzuaddiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line1">
        <source>A shorter way to write 'squareOddValuesAndAddOne' is to nest each</source>
        <target state="translated">Eine kürzere Möglichkeit zum Schreiben von "squareOddValuesAndAddOne" besteht im Verschachteln von jedem</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line2">
        <source>sub-result into the function calls themselves.</source>
        <target state="translated">Teilergebnis im Funktionsaufruf selbst.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line3">
        <source>This makes the function much shorter, but it's difficult to see the</source>
        <target state="translated">Dadurch wird die Funktion viel kürzer,</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line4">
        <source>order in which the data is processed.</source>
        <target state="translated">die Reihenfolge der Datenverarbeitung ist jedoch schlechter sichtbar.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line1">
        <source>A preferred way to write 'squareOddValuesAndAddOne' is to use F# pipe operators.</source>
        <target state="translated">Eine bevorzugte Möglichkeit zum Schreiben von "squareOddValuesAndAddOne" besteht in der Verwendung von F#-Pipe-Operatoren.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line2">
        <source>This allows you to avoid creating intermediate results, but is much more readable</source>
        <target state="translated">Dadurch können Sie verhindern, dass Zwischenergebnisse erstellt werden, dies ist jedoch besser lesbar</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line3">
        <source>than nesting function calls like 'squareOddValuesAndAddOneNested'</source>
        <target state="translated">als verschachtelte Funktionsaufrufe wie "squareOddValuesAndAddOneNested".</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line1">
        <source>You can shorten 'squareOddValuesAndAddOnePipeline' by moving the second `List.map` call</source>
        <target state="translated">Sie können "squareOddValuesAndAddOnePipeline" kürzen, indem Sie den zweiten "List.map"-Aufruf</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line2">
        <source>into the first, using a Lambda Function.</source>
        <target state="translated">mithilfe einer Lambda-Funktion in den ersten verschieben.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line3">
        <source>Note that pipelines are also being used inside the lambda function.  F# pipe operators</source>
        <target state="translated">Pipelines werden auch innerhalb der Lambda-Funktion verwendet. F#-Pipe-Operatoren</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line4">
        <source>can be used for single values as well.  This makes them very powerful for processing data.</source>
        <target state="translated">können auch für einzelne Werte verwendet werden. So ist eine leistungsstarke Datenverarbeitung möglich.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line1">
        <source>Lastly, you can eliminate the need to explicitly take 'values' in as a parameter by using '&gt;&gt;'</source>
        <target state="translated">Es ist nicht mehr erforderlich, "values" als Parameter aufzunehmen, indem Sie mithilfe von "&gt;&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line2">
        <source>to compose the two core operations: filtering out even numbers, then squaring and adding one.</source>
        <target state="translated">die beiden zentralen Vorgänge erstellen: Herausfiltern von geraden Zahlen, Quadratieren und Addieren von 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line3">
        <source>Likewise, the 'fun x -&gt; ...' bit of the lambda expression is also not needed, because 'x' is simply</source>
        <target state="translated">Der Teil "fun x -&gt; ..." des Lambdaausdrucks ist dementsprechend ebenfalls nicht erforderlich, da "x" lediglich</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line4">
        <source>being defined in that scope so that it can be passed to a functional pipeline.  Thus, '&gt;&gt;' can be used</source>
        <target state="translated">in dem Bereich definiert wird, damit es an eine Funktionspipeline übergeben werden kann. Daher kann "&gt;&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line5">
        <source>there as well.</source>
        <target state="translated">dort ebenfalls verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line6">
        <source>The result of 'squareOddValuesAndAddOneComposition' is itself another function which takes a</source>
        <target state="translated">Das Ergebnis von "squareOddValuesAndAddOneComposition" selbst ist eine andere Funktion, die eine</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line7">
        <source>list of integers as its input.  If you execute 'squareOddValuesAndAddOneComposition' with a list</source>
        <target state="translated">Liste von Integern als Eingabe verwendet. Wenn Sie "squareOddValuesAndAddOneComposition" mit einer Liste</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line8">
        <source>of integers, you'll notice that it produces the same results as previous functions.</source>
        <target state="translated">von Integern ausführen, erhalten Sie das gleiche Ergebnis wie bei vorherigen Funktionen.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line9">
        <source>This is using what is known as function composition.  This is possible because functions in F#</source>
        <target state="translated">Dabei wird die so genannte Funktionskomposition verwendet. Das ist möglich, da Funktionen in F#</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line10">
        <source>use Partial Application and the input and output types of each data processing operation match</source>
        <target state="translated">die partielle Anwendung nutzen, und die Ein- und Ausgabetypen jedes Datenverarbeitungsvorgangs</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line11">
        <source>the signatures of the functions we're using.</source>
        <target state="translated">mit den Signaturen der verwendeten Funktionen übereinstimmen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line1">
        <source>Lists are ordered, immutable, singly-linked lists.  They are eager in their evaluation.</source>
        <target state="translated">Listen sind geordnete, unveränderliche, einfach verknüpfte Listen. Ihre Auswertung ist streng.</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line2">
        <source>This module shows various ways to generate lists and process lists with some functions</source>
        <target state="translated">Dieses Modul zeigt verschiedene Möglichkeiten zum Erstellen von Listen und Prozesslisten mit einigen Funktionen</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line3">
        <source>in the 'List' module in the F# Core Library.</source>
        <target state="translated">im Modul "List" in der F#-Kernbibliothek.</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/lists</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/lists</target>
        <note />
      </trans-unit>
      <trans-unit id="ListEmptyDefinition">
        <source>Lists are defined using [ ... ].  This is an empty list.</source>
        <target state="translated">Listen werden mithilfe von "[ ... ]" definiert. Dies ist eine leere Liste.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListElementDefinition">
        <source>This is a list with 3 elements.  ';' is used to separate elements on the same line.</source>
        <target state="translated">Dies ist eine Liste mit drei Elementen. ";" dient dazu, Elemente in der gleichen Zeile zu trennen.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListNewlineElements">
        <source>You can also separate elements by placing them on their own lines.</source>
        <target state="translated">Sie können Elemente auch trennen, indem Sie sie in separaten Zeilen einfügen.</target>
        <note />
      </trans-unit>
      <trans-unit id="NumberList2">
        <source>This is a list of integers from 1 to 1000</source>
        <target state="translated">Dies ist eine Liste mit ganzen Zahlen von 1 bis 1000.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputation-Line1">
        <source>Lists can also be generated by computations. This is a list containing</source>
        <target state="translated">Listen können auch mithilfe von Berechnungen generiert werden. Dies ist eine Liste mit</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputation-Line2">
        <source>all the days of the year.</source>
        <target state="translated">allen Tagen des Jahres.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintList2">
        <source>Print the first 5 elements of 'daysList' using 'List.take'.</source>
        <target state="translated">Drucken Sie mithilfe von "List.take" die ersten fünf Elemente in "daysList".</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputationConditional-Line1">
        <source>Computations can include conditionals.  This is a list containing the tuples</source>
        <target state="translated">Berechnungen können Bedingungen enthalten. Dies ist eine Liste mit den Tupeln,</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputationConditional-Line2">
        <source>which are the coordinates of the black squares on a chess board.</source>
        <target state="translated">bei denen es sich um die Koordinaten der schwarzen Felder auf einem Schachbrett handelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line1">
        <source>Lists can be transformed using 'List.map' and other functional programming combinators.</source>
        <target state="translated">Listen können mithilfe von "List.map" und anderen funktionalen Programmierkombinatoren umgewandelt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line2">
        <source>This definition produces a new list by squaring the numbers in numberList, using the pipeline</source>
        <target state="translated">Diese Definition erzeugt eine neue Liste, indem die Zahlen in "numberList" quadriert werden. Dabei wird der Pipeline</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line3">
        <source>operator to pass an argument to List.map.</source>
        <target state="translated">Operator verwendet, um ein Argument an "List.map" zu übergeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListFilter-Line1">
        <source>There are many other list combinations. The following computes the sum of the squares of the</source>
        <target state="translated">Es stehen noch viele andere Listenkombinationen zur Verfügung. Mit dem Folgenden wird die Summe der Quadrate der</target>
        <note />
      </trans-unit>
      <trans-unit id="ListFilter-Line2">
        <source>numbers divisible by 3.</source>
        <target state="translated">durch 3 teilbaren Zahlen berechnet.</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line1">
        <source>Arrays are fixed-size, mutable collections of elements of the same type.</source>
        <target state="translated">Arrays sind veränderliche Sammlungen fester Größe, die Elemente des gleichen Typs enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line2">
        <source>Although they are similar to Lists (they support enumeration and have similar combinators for data processing),</source>
        <target state="translated">Sie ähneln Listen (sie unterstützen Enumeration und haben ähnliche Combinators für die Datenverarbeitung),</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line3">
        <source>they are generally faster and support fast random access.  This comes at the cost of being less safe by being mutable.</source>
        <target state="translated">sind im Allgemeinen jedoch schneller und unterstützen einen schnellen wahlfreien Zugriff. Dafür sind sie jedoch weniger sicher, da sie veränderlich sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/arrays</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/arrays</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyArray">
        <source>This is The empty array.  Note that the syntax is similar to that of Lists, but uses `[| ... |]` instead.</source>
        <target state="translated">Dies ist das leere Array. Die Syntax ähnelt der von Listen, verwendet jedoch stattdessen "[| ... |]".</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayConstructionList">
        <source>Arrays are specified using the same range of constructs as lists.</source>
        <target state="translated">Arrays werden mithilfe der gleichen Konstrukte angegeben wie Listen.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayConstructionRange">
        <source>This is an array of numbers from 1 to 1000.</source>
        <target state="translated">Dies ist ein Array mit Zahlen von 1 bis 1000.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayComputationConstruction">
        <source>This is an array containing only the words "hello" and "world".</source>
        <target state="translated">Dieses Array enthält nur die Wörter "hello" und "world".</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayInit">
        <source>This is an array initialized by index and containing the even numbers from 0 to 2000.</source>
        <target state="translated">Dieses Array wurde per Index initialisiert und enthält gerade Zahlen von 0 bis 2000.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArraySlicing">
        <source>Sub-arrays are extracted using slicing notation.</source>
        <target state="translated">Teilarrays werden mithilfe der Segmentnotation extrahiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayLooping">
        <source>You can loop over arrays and lists using 'for' loops.</source>
        <target state="translated">Mit For-Schleifen können Sie bei Arrays und Listen Schleifen ausführen.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayAssignment-Line1">
        <source>You can modify the contents of an an array element by using the left arrow assignment operator.</source>
        <target state="translated">Sie können die Inhalte eines Arrayelements mithilfe des Zuweisungsoperators "Pfeil nach links" ändern.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayAssignment-Line2">
        <source>To learn more about this operator, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/values/index#mutable-variables</source>
        <target state="translated">Weitere Informationen zu diesem Operator finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/values/index#mutable-variables</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayMap-Line1">
        <source>You can transform arrays using 'Array.map' and other functional programming operations.</source>
        <target state="translated">Sie können Arrays mithilfe von "Array.map" und anderen funktionalen Programmiervorgängen umwandeln.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayMap-Line2">
        <source>The following calculates the sum of the lengths of the words that start with 'h'.</source>
        <target state="translated">Mit Folgendem wird die Summe der Längen von Wörtern berechnet, die mit "h" beginnen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line1">
        <source>Sequences are a logical series of elements, all of the same type.  These are a more general type than Lists and Arrays.</source>
        <target state="translated">Sequenzen sind logische Serien von Elementen, die alle vom gleichen Typ sind. Ihr Typ ist allgemeiner als Listen und Arrays.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line2">
        <source>Sequences are evaluated on-demand and are re-evaluated each time they are iterated.</source>
        <target state="translated">Sequenzen werden bei Bedarf ausgewertet und bei jeder Iteration erneut ausgewertet.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line3">
        <source>An F# sequence is an alias for a .NET System.Collections.Generic.IEnumerable&lt;'T&gt;.</source>
        <target state="translated">Eine F#-Sequenz ist ein Alias für .NET System.Collections.Generic.IEnumerable&lt;'T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line4">
        <source>Sequence processing functions can be applied to Lists and Arrays as well.</source>
        <target state="translated">Funktionen mit Sequenzverarbeitung können auch auf Listen und Arrays angewendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line5">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/sequences</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/sequences</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptySequence">
        <source>This is the empty sequence.</source>
        <target state="translated">Dies ist die leere Sequenz.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceOfValues">
        <source>This a sequence of values.</source>
        <target state="translated">Dies ist eine Sequenz mit Werten.</target>
        <note />
      </trans-unit>
      <trans-unit id="OnDemandSequence">
        <source>This is an on-demand sequence from 1 to 1000.</source>
        <target state="translated">Dies ist eine bedarfsbasierte Sequenz von 1 bis 1000.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceComposition">
        <source>This is a sequence producing the words "hello" and "world"</source>
        <target state="translated">Diese Sequenz generiert die Wörter "hello" und "world".</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceInit">
        <source>This sequence producing the even numbers up to 2000.</source>
        <target state="translated">Diese Sequenz erzeugt gerade Zahlen bis 2000.</target>
        <note />
      </trans-unit>
      <trans-unit id="InfiniteSequence-Line1">
        <source>This is an infinite sequence which is a random walk.</source>
        <target state="translated">Dies ist eine unendliche Sequenz und ermöglicht Zufallsdurchläufe.</target>
        <note />
      </trans-unit>
      <trans-unit id="InfiniteSequence-Line2">
        <source>This example uses yield! to return each element of a subsequence.</source>
        <target state="translated">In diesem Beispiel werden mithilfe von "yield!" die einzelnen Elemente einer Untersequenz zurückgegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequence100Elements">
        <source>This example shows the first 100 elements of the random walk.</source>
        <target state="translated">Dieses Beispiel zeigt die ersten 100 Elemente des Zufallsdurchlaufs.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line1">
        <source>Recursive functions can call themselves. In F#, functions are only recursive</source>
        <target state="translated">Rekursive Funktionen können sich selbst aufrufen. In F# sind Funktionen nur rekursiv,</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line2">
        <source>when declared using 'let rec'.</source>
        <target state="translated">für die Deklaration mithilfe von "let rec".</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line3">
        <source>Recursion is the preferred way to process sequences or collections in F#.</source>
        <target state="translated">Rekursion ist die bevorzugte Möglichkeit zum Verarbeiten von Sequenzen oder Sammlungen in F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/index#recursive-functions</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/functions/index#recursive-functions</target>
        <note />
      </trans-unit>
      <trans-unit id="RecFunDef-Line1">
        <source>This example shows a recursive function that computes the factorial of an</source>
        <target state="translated">Dieses Beispiel zeigt eine rekursive Funktion, die die Fakultät einer ganzen</target>
        <note />
      </trans-unit>
      <trans-unit id="RecRunDef-Line2">
        <source>integer. It uses 'let rec' to define a recursive function.</source>
        <target state="translated">Zahl berechnet. Zum Definieren einer rekursiven Funktion wird "let rec" verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line1">
        <source>Computes the greatest common factor of two integers.</source>
        <target state="translated">Berechnet den höchsten gemeinsamen Faktor von zwei Integern.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line2">
        <source>Since all of the recursive calls are tail calls,</source>
        <target state="translated">Da alle rekursiven Aufrufe Endeaufrufe sind,</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line3">
        <source>the compiler will turn the function into a loop,</source>
        <target state="translated">wandelt der Compiler die Funktion in eine Schleife um,</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line4">
        <source>which improves performance and reduces memory consumption.</source>
        <target state="translated">was die Leistung verbessert und die Arbeitsspeicherbedarf reduziert.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumList">
        <source>This example computes the sum of a list of integers using recursion.</source>
        <target state="translated">Dieses Beispiel berechnet mithilfe von Rekursion die Summe einer Liste von Integern.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTail">
        <source>This makes 'sumList' tail recursive, using a helper function with a result accumulator.</source>
        <target state="translated">Mithilfe einer Hilfsfunktion mit einem Ergebnisakkumulator wird "sumList" endrekursiv.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTailInvoke-Line1">
        <source>This invokes the tail recursive helper function, providing '0' as a seed accumulator.</source>
        <target state="translated">Dies ruft die endrekursive Hilfsfunktion auf und verwendet "0" als Startwertakkumulator.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTailInvoke-Line2">
        <source>An approach like this is common in F#.</source>
        <target state="translated">Dies ist eine häufige Vorgehensweise in F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line1">
        <source>Records are an aggregate of named values, with optional members (such as methods).</source>
        <target state="translated">Datensätze sind ein Aggregat aus benannten Werten mit optionalen Membern (wie etwa Methoden).</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line2">
        <source>They are immutable and have structural equality semantics.</source>
        <target state="translated">Sie sind nicht veränderlich und verfügen über eine strukturelle Gleichheitssemantik.</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/records</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/records</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordDefinition">
        <source>This example shows how to define a new record type.</source>
        <target state="translated">Dieses Beispiel zeigt, wie ein neuer Datensatztyp definiert wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordInstantiation1">
        <source>This example shows how to instantiate a record type.</source>
        <target state="translated">In diesem Beispiel erfahren Sie, wie Sie einen Datensatztyp instanziieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordInstantiation2">
        <source>You can also do this on the same line with ';' separators.</source>
        <target state="translated">Das ist in der gleichen Zeile auch mit dem Trennzeichen ";" möglich.</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line1">
        <source>This example shows how to use "copy-and-update" on record values. It creates</source>
        <target state="translated">Dieses Beispiel zeigt die Verwendung von "Kopieren und aktualisieren" für Datensatzwerte. Es wird</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line2">
        <source>a new record value that is a copy of contact1, but has different values for</source>
        <target state="translated">ein neuer Datensatz als Kopie von "contact1" erstellt, der jedoch über andere Werte</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line3">
        <source>the 'Phone' and 'Verified' fields.</source>
        <target state="translated">für die Felder "Phone" und "Verified" verfügt.</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/copy-and-update-record-expressions</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/copy-and-update-record-expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="ProcessRecord-Line1">
        <source>This example shows how to write a function that processes a record value.</source>
        <target state="translated">Dieses Beispiel veranschaulicht das Schreiben einer Funktion zum Verarbeiten eines Datensatzwerts.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProcessRecord-Line2">
        <source>It converts a 'ContactCard' object to a string.</source>
        <target state="translated">Es konvertiert ein Objekt vom Typ "ContactCard" in eine Zeichenfolge.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordWithMember-Line1">
        <source>This is an example of a Record with a member.</source>
        <target state="translated">Dies ist ein Beispiel für einen Datensatz mit einem Member.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordWithMember-Line2">
        <source>Members can implement object-oriented members.</source>
        <target state="translated">Member können objektorientierte Member implementieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordAccess">
        <source>Members are accessed via the '.' operator on an instantiated type.</source>
        <target state="translated">Auf Member wird über den Operator "." in einem instanziierten Typ zugegriffen.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line1">
        <source>Records can also be represented as structs via the 'Struct' attribute.</source>
        <target state="translated">Datensätze können mithilfe des Attributs "Struct" auch als Strukturen dargestellt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line2">
        <source>This is helpful in situations where the performance of structs outweighs</source>
        <target state="translated">Dies ist in Situationen hilfreich, in denen die Leistung der Strukturen wichtiger ist als</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line3">
        <source>the flexibility of reference types.</source>
        <target state="translated">die Flexibilität der Verweistypen.</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line1">
        <source>Discriminated Unions (DU for short) are values which could be a number of named forms or cases.</source>
        <target state="translated">Diskriminierte Unions (DUs) sind Werte, die eine Anzahl benannter Formen oder Fälle sein können.</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line2">
        <source>Data stored in DUs can be one of several distinct values.</source>
        <target state="translated">In DUs gespeicherte Daten können einer von verschiedenen eindeutigen Werten sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/discriminated-unions</target>
        <note />
      </trans-unit>
      <trans-unit id="CardSuit">
        <source>The following represents the suit of a playing card.</source>
        <target state="translated">Folgendes stellt die Farbe einer Spielkarte dar.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardRank">
        <source>A Disciminated Union can also be used to represent the rank of a playing card.</source>
        <target state="translated">Eine diskriminierte Union kann auch verwendet werden, um den Rang einer Spielkarte darzustellen.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardRankValue">
        <source>Represents the rank of cards 2 .. 10</source>
        <target state="translated">Stellt den Rang der Karten 2 bis 10 dar 10</target>
        <note />
      </trans-unit>
      <trans-unit id="CardMember">
        <source>Discriminated Unions can also implement object-oriented members.</source>
        <target state="translated">Diskriminierte Unions können objektorientierte Member implementieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardType-Line1">
        <source>This is a record type that combines a Suit and a Rank.</source>
        <target state="translated">Dieser Datensatztyp kombiniert eine Farbe und einen Rang.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardType-Line2">
        <source>It's common to use both Records and Disciminated Unions when representing data.</source>
        <target state="translated">Beim Darstellen von Daten werden häufig sowohl Datensätze als auch diskriminierte Unions verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ComputeFullDeck">
        <source>This computes a list representing all the cards in the deck.</source>
        <target state="translated">Dies berechnet eine Liste mit allen Karten im Stapel.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardToString">
        <source>This example converts a 'Card' object to a string.</source>
        <target state="translated">Dieses Beispiel konvertiert ein Objekt vom Typ "Card" in eine Zeichenfolge.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintAllCards">
        <source>This example prints all the cards in a playing deck.</source>
        <target state="translated">Dieses Beispiel gibt alle Karten in einem Kartenstapel aus.</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line1">
        <source>Single-case DUs are often used for domain modeling.  This can buy you extra type safety</source>
        <target state="translated">Einzelfall-DUs werden häufig für die Domänenmodellierung verwendet. Dadurch erhalten Sie zusätzliche Typsicherheit</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line2">
        <source>over primitive types such as strings and ints.</source>
        <target state="translated">für primitive Typen wie Zeichenfolgen und Integer.</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line3">
        <source>Single-case DUs cannot be implicitly converted to or from the type they wrap.</source>
        <target state="translated">Eine implizite Konvertierung von Einzelfall-DUs in den umschlossenen Typ oder aus diesem Typ ist nicht möglich.</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line4">
        <source>For example, a function which takes in an Address cannot accept a string as that input,</source>
        <target state="translated">Beispielsweise eine Funktion, die eine Adresse akzeptiert, kann keine Zeichenfolge als Eingabe akzeptieren</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line5">
        <source>or vive/versa.</source>
        <target state="translated">(oder umgekehrt).</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateSingleCaseDu">
        <source>You can easily instantiate a single-case DU as follows.</source>
        <target state="translated">Sie können Einzelfall-DUs folgendermaßen instanziieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnwrapSingleCaseDu">
        <source>When you need the value, you can unwrap the underlying value with a simple function.</source>
        <target state="translated">Wenn Sie den Wert benötigen, können Sie den zugrunde liegenden Wert mit einer einfachen Funktion entpacken.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintSingleCaseDu">
        <source>Printing single-case DUs is simple with unwrapping functions.</source>
        <target state="translated">Mit entpackten Funktionen lassen sich Einzelfall-DUs einfach drucken.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line1">
        <source>Disciminated Unions also support recursive definitions.</source>
        <target state="translated">Diskriminierte Unions unterstützen auch rekursive Definitionen.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line2">
        <source>This represents a Binary Search Tree, with one case being the Empty tree,</source>
        <target state="translated">Dies stellt eine Struktur für die Binärsuche dar, wobei ein Fall eine leere Struktur ist</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line3">
        <source>and the other being a Node with a value and two subtrees.</source>
        <target state="translated">und der andere Fall einen Knoten mit einem Wert und zwei Unterstrukturen darstellt.</target>
        <note />
      </trans-unit>
      <trans-unit id="SearchBinaryTree-Line1">
        <source>Check if an item exists in the binary search tree.</source>
        <target state="translated">Prüfen Sie, ob die Struktur für die Binärsuche ein Element enthält.</target>
        <note />
      </trans-unit>
      <trans-unit id="SearchBinaryTree-Line2">
        <source>Searches recursively using Pattern Matching.  Returns true if it exists; otherwise, false.</source>
        <target state="translated">Sucht rekursiv mithilfe des Musterabgleichs. Gibt bei vorhandenem Element "true" aus, andernfalls "false".</target>
        <note />
      </trans-unit>
      <trans-unit id="CheckLeftSubtree">
        <source>Check the left subtree.</source>
        <target state="translated">Prüfen Sie die linke Unterstruktur.</target>
        <note />
      </trans-unit>
      <trans-unit id="CheckRightSubtree">
        <source>Check the right subtree.</source>
        <target state="translated">Prüfen Sie die rechte Unterstruktur.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line1">
        <source>Inserts an item in the Binary Search Tree.</source>
        <target state="translated">Fügt in die Struktur für die Binärsuche ein Element ein.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line2">
        <source>Finds the place to insert recursively using Pattern Matching, then inserts a new node.</source>
        <target state="translated">Findet die Position für das rekursive Einfügen mithilfe des Musterabgleichs und fügt anschließend einen neuen Knoten ein.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line3">
        <source>If the item is already present, it does not insert anything.</source>
        <target state="translated">Wenn das Element bereits vorhanden ist, wird nichts eingefügt.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line4">
        <source>No need to insert, it already exists; return the node.</source>
        <target state="translated">Einfügen nicht erforderlich, da bereits vorhanden; Knoten zurückgeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line5">
        <source>Call into left subtree.</source>
        <target state="translated">Aufruf in linker Unterstruktur.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line6">
        <source>Call into right subtree.</source>
        <target state="translated">Aufruf in rechter Unterstruktur.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line1">
        <source>Discriminated Unions can also be represented as structs via the 'Struct' attribute.</source>
        <target state="translated">Diskriminierte Unions können mithilfe des Attributs "Struct" auch als Struktur dargestellt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line2">
        <source>This is helpful in situations where the performance of structs outweighs</source>
        <target state="translated">Dies ist in Situationen hilfreich, in denen die Leistung der Strukturen wichtiger ist als</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line3">
        <source>the flexibility of reference types.</source>
        <target state="translated">die Flexibilität der Verweistypen.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line4">
        <source>However, there are two important things to know when doing this:</source>
        <target state="translated">Dabei sind jedoch zwei Punkte zu beachten:</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line5">
        <source>1. A struct DU cannot be recursively-defined.</source>
        <target state="translated">1. Eine Struktur-DU kann nicht rekursiv definiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line6">
        <source>2. A struct DU must have unique names for each of its cases.</source>
        <target state="translated">2. In einer Struktur-DU muss jeder Fall einen eindeutigen Namen haben.</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line1">
        <source>Pattern Matching is a feature of F# that allows you to utilize Patterns,</source>
        <target state="translated">Der Musterabgleich ist eine Funktion von F#, die Ihnen die Verwendung von Mustern ermöglicht,</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line2">
        <source>which are a way to compare data with a logical structure or structures,</source>
        <target state="translated">die eine Möglichkeit sind, um Daten mit logischen Strukturen oder Strukturen zu vergleichen,</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line3">
        <source>decompose data into constituent parts, or extract information from data in various ways.</source>
        <target state="translated">Daten in ihre Einzelteile zu zerlegen oder auf verschiedene Weise Informationen aus Daten zu extrahieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line4">
        <source>You can then dispatch on the "shape" of a pattern via Pattern Matching.</source>
        <target state="translated">Das Verteilen ist anschließend mithilfe des Musterabgleichs anhand der Form eines Musters möglich.</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line5">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/pattern-matching</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/pattern-matching</target>
        <note />
      </trans-unit>
      <trans-unit id="PersonRecord">
        <source>A record for a person's first and last name</source>
        <target state="translated">Ein Datensatz für den Vor- und Nachnamen einer Person</target>
        <note />
      </trans-unit>
      <trans-unit id="EmployeeDu">
        <source>A Discriminated Union of 3 different kinds of employees</source>
        <target state="translated">Eine diskriminierte Union mit drei verschiedenen Arten von Mitarbeitern</target>
        <note />
      </trans-unit>
      <trans-unit id="CountEmployees-Line1">
        <source>Count everyone underneath the employee in the management hierarchy,</source>
        <target state="translated">Zählen Sie alle Personen unterhalb des Angestellten in der Verwaltungshierarchie,</target>
        <note />
      </trans-unit>
      <trans-unit id="CountEmployees-Line2">
        <source>including the employee.</source>
        <target state="translated">einschließlich des Angestellten.</target>
        <note />
      </trans-unit>
      <trans-unit id="FindDave-Line1">
        <source>Find all managers/executives named "Dave" who do not have any reports.</source>
        <target state="translated">Suchen Sie alle Manager/Führungskräfte mit dem Namen "Dave", die über keine Berichte verfügen.</target>
        <note />
      </trans-unit>
      <trans-unit id="FindDave-Line2">
        <source>This uses the 'function' shorthand to as a lambda expression.</source>
        <target state="translated">Dies verwendet die Kurzform "function" als Lambdaausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchEmptyList">
        <source>[] matches an empty list.</source>
        <target state="translated">[] entspricht einer leeren Liste.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchWildcard-Line1">
        <source>'_' is a wildcard pattern that matches anything.</source>
        <target state="translated">"_" ist ein Platzhaltermuster, das mit allem übereinstimmt</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchWildCard-Line2">
        <source>This handles the "or else" case.</source>
        <target state="translated">Dies behandelt den "or else"-Fall.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchShorthand-Line1">
        <source>You can also use the shorthand function construct for pattern matching,</source>
        <target state="translated">Sie können das Kurzform-Funktionskonstrukt auch für den Musterabgleich verwenden,</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchShorthand-Line2">
        <source>which is useful when you're writing functions which make use of Partial Application.</source>
        <target state="translated">was beim Schreiben von Funktionen, die die partielle Anwendung nutzen, hilfreich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParseHelpers">
        <source>Define some more functions which parse with the helper function.</source>
        <target state="translated">Definieren Sie weitere Funktionen, die eine Analyse mithilfe der Hilfsfunktion durchführen.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line1">
        <source>Active Patterns are another powerful construct to use with pattern matching.</source>
        <target state="translated">Aktive Muster sind ein weiteres leistungsstarkes Konstrukt, das beim Musterabgleich verwendet werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line2">
        <source>They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</source>
        <target state="translated">Sie ermöglichen eine Partitionierung der Eingabedaten in benutzerdefinierte Formen, wobei sie an der Musterabgleichs-Aufrufsite zerlegt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/active-patterns</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/active-patterns</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchActivePattern">
        <source>Pattern Matching via 'function' keyword and Active Patterns often looks like this.</source>
        <target state="translated">Der Musterabgleich mithilfe des Schlüsselworts "function" und das aktive Muster sehen häufig wie folgt aus.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintParse">
        <source>Call the printer with some different values to parse.</source>
        <target state="translated">Rufen Sie den Drucker mit unterschiedlichen zu analysierenden Werten auf.</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line1">
        <source>Option values are any kind of value tagged with either 'Some' or 'None'.</source>
        <target state="translated">Bei Optionswerten handelt es sich um eine beliebige Art von Werten, die entweder mit "Some" oder mit "None" markiert sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line2">
        <source>They are used extensively in F# code to represent the cases where many other</source>
        <target state="translated">Sie werden in F#-Code umfassend verwendet, um die Fälle darzustellen, in denen viele</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line3">
        <source>languages would use null references.</source>
        <target state="translated">Sprachen NULL-Verweise verwenden würden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/options</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/options</target>
        <note />
      </trans-unit>
      <trans-unit id="ZipCode">
        <source>First, define a zipcode defined via Single-case Discriminated Union.</source>
        <target state="translated">Definieren Sie als Erstes eine Postleitzahl, die über eine diskriminierte Einzelfall-Union definiert ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="Customer">
        <source>Next, define a type where the ZipCode is optional.</source>
        <target state="translated">Definieren Sie als Nächstes einen Typ, bei dem "ZipCode" optional ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="ShippingCalculator-Line1">
        <source>Next, define an interface type that represents an object to compute the shipping zone for the customer's zip code,</source>
        <target state="translated">Definieren Sie dann einen Schnittstellentyp, der ein Objekt zum Berechnen der Versandkosten für die Postleitzahl des Kunden repräsentiert,</target>
        <note />
      </trans-unit>
      <trans-unit id="ShippingCalculator-Line2">
        <source>given implementations for the 'getState' and 'getShippingZone' abstract methods.</source>
        <target state="translated">sofern Implementierungen für die abstrakten Methoden "getState" und "getShippingZone" vorhanden sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line1">
        <source>Next, calculate a shipping zone for a customer using a calculator instance.</source>
        <target state="translated">Berechnen Sie nun mithilfe einer Rechnerinstanz die Versandkosten für einen Kunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line2">
        <source>This uses combinators in the Option module to allow a functional pipeline for</source>
        <target state="translated">Dies verwendet Kombinatoren im Option-Modul für eine funktionale Pipeline zum</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line3">
        <source>transforming data with Optionals.</source>
        <target state="translated">Transformieren von Daten mit Optionen.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line1">
        <source>Units of measure are a way to annotate primitive numeric types in a type-safe way.</source>
        <target state="translated">Maßeinheiten sind eine Möglichkeit, um für primitive numerische Typen typsicher den Änderungsverlauf einzublenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line2">
        <source>You can then perform type-safe arithmetic on these values.</source>
        <target state="translated">Anschließend können Sie für diese Werte die typsichere Arithmetik ausführen.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/units-of-measure</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/units-of-measure</target>
        <note />
      </trans-unit>
      <trans-unit id="CommonUnits">
        <source>First, open a collection of common unit names</source>
        <target state="translated">Öffnen Sie zunächst eine Auflistung mit allgemeinen Einheitennamen.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineUnitConstant">
        <source>Define a unitized constant</source>
        <target state="translated">Definieren Sie eine einheitliche Konstante.</target>
        <note />
      </trans-unit>
      <trans-unit id="MileUnit">
        <source>Next, define a new unit type</source>
        <target state="translated">Definieren Sie als Nächstes einen neuen Einheitentyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="MileToMeter">
        <source>Conversion factor mile to meter.</source>
        <target state="translated">Faktor für die Umrechnung von Meilen in Meter.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineMileConstant">
        <source>Define a unitized constant</source>
        <target state="translated">Definieren Sie eine einheitliche Konstante.</target>
        <note />
      </trans-unit>
      <trans-unit id="ComputeMileToMeter">
        <source>Compute  metric-system constant</source>
        <target state="translated">Berechnen Sie die Konstante für das metrische System.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintUnitsOfMeasure">
        <source>Values using Units of Measure can be used just like the primitive numeric type for things like printing.</source>
        <target state="translated">Werte, die Maßeinheiten verwenden, können wie der primitive numerische Typ z.B. zum Drucken genutzt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line1">
        <source>Classes are a way of defining new object types in F#, and support standard Object-oriented constructs.</source>
        <target state="translated">Klassen sind eine Möglichkeit zum Definieren neuer Objekttypen in F#. Sie unterstützen standardmäßige objektorientierte Konstrukte.</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line2">
        <source>They can have a variety of members (methods, properties, events, etc.)</source>
        <target state="translated">Sie können über verschiedene Member verfügen (Methoden, Eigenschaften, Ereignisse usw.)</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line3">
        <source>To learn more about Classes, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/classes</source>
        <target state="translated">Weitere Informationen zu Klassen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/classes</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line4">
        <source>To learn more about Members, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members</source>
        <target state="translated">Weitere Informationen zu Membern finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/members</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line1">
        <source>A simple two-dimensional Vector class.</source>
        <target state="translated">Eine einfache, zweidimensionale Vektorklasse.</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line2">
        <source>The class's constructor is on the first line,</source>
        <target state="translated">Der Konstruktor der Klasse befindet sich in der ersten Zeile</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line3">
        <source>and takes two arguments: dx and dy, both of type 'double'.</source>
        <target state="translated">und akzeptiert zwei Argumente: dx und dy, beide vom Typ "double".</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInternalField-Line1">
        <source>This internal field stores the length of the vector, computed when the</source>
        <target state="translated">Dieses interne Feld speichert die Länge des Vektors, die berechnet wird, wenn</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInternalField-Line2">
        <source>object is constructed</source>
        <target state="translated">das Objekt konstruiert wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisKeyword-Line1">
        <source>'this' specifies a name for the object's self identifier.</source>
        <target state="translated">"this" gibt einen Namen für den Selbstbezeichner des Objekts an.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisKeyword-Line2">
        <source>In instance methods, it must appear before the member name.</source>
        <target state="translated">In Instanzmethoden muss dies vor dem Membernamen angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="MemberMethod">
        <source>This member is a method.  The previous members were properties.</source>
        <target state="translated">Dieser Member ist eine Methode. Die vorherigen Member waren Eigenschaften.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateClass">
        <source>This is how you instantiate the Vector2D class.</source>
        <target state="translated">So instanziieren Sie die Vector2D-Klasse.</target>
        <note />
      </trans-unit>
      <trans-unit id="ScaledVector">
        <source>Get a new scaled vector object, without modifying the original object.</source>
        <target state="translated">Rufen Sie ein neues skaliertes Vektorobjekt ab, ohne das ursprüngliche Objekt zu verändern.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line1">
        <source>Generic classes allow types to be defined with respect to a set of type parameters.</source>
        <target state="translated">Generische Klassen ermöglichen das Definieren von Typen in Bezug auf eine Gruppe von Typparametern.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line2">
        <source>In the following, 'T is the type parameter for the class.</source>
        <target state="translated">Im Folgenden ist 'T der Typparameter für die Klasse.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/generics/</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalField">
        <source>This internal field store the states in a list.</source>
        <target state="translated">Dieses interne Feld speichert die Zustände in einer Liste.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddElement">
        <source>Add a new element to the list of states.</source>
        <target state="translated">Der Liste der Zustände ein neues Element hinzufügen</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment">
        <source>use the '&lt;-' operator to mutate the value.</source>
        <target state="translated">Den "&lt;-"-Operator verwenden, um den Wert zu mutieren</target>
        <note />
      </trans-unit>
      <trans-unit id="History">
        <source>Get the entire list of historical states.</source>
        <target state="translated">Die gesamte Liste der Verlaufszustände abrufen</target>
        <note />
      </trans-unit>
      <trans-unit id="Current">
        <source>Get the latest state.</source>
        <target state="translated">Den aktuellen Zustand abrufen</target>
        <note />
      </trans-unit>
      <trans-unit id="InferredTypeParameter">
        <source>An 'int' instance of the state tracker class. Note that the type parameter is inferred.</source>
        <target state="translated">Eine int-Instanz der state tracker-Klasse. Beachten Sie, dass der Typ-Parameter abgeleitet wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddState">
        <source>Add a state</source>
        <target state="translated">Einen Zustand hinzufügen</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line1">
        <source>Interfaces are object types with only 'abstract' members.</source>
        <target state="translated">Schnittstellen sind Objekttypen, die nur über abstrakte Member verfügen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line2">
        <source>Object types and object expressions can implement interfaces.</source>
        <target state="translated">Objekttypen und Objektausdrücke können Schnittstellen implementieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/interfaces</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposable">
        <source>This is a type that implements IDisposable.</source>
        <target state="translated">Dieser Typ implementiert "IDisposable".</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableImplementation">
        <source>This is the implementation of IDisposable members.</source>
        <target state="translated">Dies ist die Implementierung von IDisposable-Membern.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line1">
        <source>This is an object that implements IDisposable via an Object Expression</source>
        <target state="translated">Dies ist ein Objekt, das IDisposable über einen Objektausdruck implementiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line2">
        <source>Unlike other languages such as C# or Java, a new type definition is not needed</source>
        <target state="translated">Im Gegensatz zu anderen Sprachen wie C# oder Java ist keine neue Typendefinition erforderlich,</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line3">
        <source>to implement an interface.</source>
        <target state="translated">um eine Schnittstelle zu implementieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line1">
        <source>The FSharp.Core library defines a range of parallel processing functions.  Here</source>
        <target state="translated">Die Bibliothek "FSharp.Core" definiert eine Reihe paralleler Verarbeitungsfunktionen. Hier</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line2">
        <source>you use some functions for parallel processing over arrays.</source>
        <target state="translated">verwenden Sie einige Funktionen zur parallelen Verarbeitung über Arrays.</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line3">
        <source>To learn more, see: https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/array.parallel-module-%5Bfsharp%5D</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://msdn.microsoft.com/de-de/visualfsharpdocs/conceptual/array.parallel-module-%5Bfsharp%5D</target>
        <note />
      </trans-unit>
      <trans-unit id="InputArray">
        <source>First, an array of inputs.</source>
        <target state="translated">Definieren Sie zunächst ein Array mit Eingaben.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpensiveFunction">
        <source>Next, define a functions that does some CPU intensive computation.</source>
        <target state="translated">Definieren Sie dann eine Funktion mit CPU-intensiven Berechnungen.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParallelMap">
        <source>Next, do a parallel map over a large input array.</source>
        <target state="translated">Führen Sie als Nächstes eine parallele Zuordnung für ein umfangreiches Eingabearray durch.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintParallel">
        <source>Next, print the results.</source>
        <target state="translated">Geben Sie die Ergebnisse aus.</target>
        <note />
      </trans-unit>
      <trans-unit id="Events-Line1">
        <source>Events are a common idiom for .NET programming, especially with WinForms or WPF applications.</source>
        <target state="translated">Ereignisse sind ein gängiger Begriff bei der .NET-Programmierung, v. a. bei WinForms oder WPF-Anwendungen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Events-Line2">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/events</source>
        <target state="translated">Weitere Informationen finden Sie unter: https://docs.microsoft.com/de-de/dotnet/articles/fsharp/language-reference/members/events</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleEvent">
        <source>First, create instance of Event object that consists of subscription point (event.Publish) and event trigger (event.Trigger).</source>
        <target state="translated">Erstellen Sie zunächst eine Instanz des Event-Objekts mit Abonnementpunkt (event.Publish) und Ereignisauslöser (event.Trigger).</target>
        <note />
      </trans-unit>
      <trans-unit id="AddEventHandler1">
        <source>Next, add handler to the event.</source>
        <target state="translated">Fügen Sie dem Ereignis einen Handler hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="TriggerEvent">
        <source>Next, trigger the event.</source>
        <target state="translated">Lösen Sie das Ereignis aus.</target>
        <note />
      </trans-unit>
      <trans-unit id="EventWithArgs">
        <source>Next, create an instance of Event that follows standard .NET convention: (sender, EventArgs).</source>
        <target state="translated">Erstellen Sie als Nächstes eine Event-Instanz gemäß der .NET-Standardkonvention: (sender, EventArgs)</target>
        <note />
      </trans-unit>
      <trans-unit id="AddEventHandler2">
        <source>Next, add a handler for this new event.</source>
        <target state="translated">Fügen Sie einen Handler für das neue Ereignis hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="TriggerEventWithArgs">
        <source>Next, trigger this event (note that sender argument should be set).</source>
        <target state="translated">Lösen Sie das Ereignis aus. (Hinweis: das sender-Argument muss festgelegt sein.)</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>