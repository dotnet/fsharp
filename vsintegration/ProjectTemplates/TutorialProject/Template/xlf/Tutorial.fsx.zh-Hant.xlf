<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Tutorial.fsx">
    <body>
      <trans-unit id="SampleHeader">
        <source>This sample will guide you through elements of the F# language.</source>
        <target state="translated">此範例將引導您了解 F# 語言的項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="Instructions-Line1">
        <source>To execute the code in F# Interactive, highlight a section of code and press Alt-Enter or right-click</source>
        <target state="translated">若要執行 F# 互動中的程式碼，請反白顯示某個程式碼區段並按下 Alt-Enter，或者以滑鼠右鍵按一下</target>
        <note />
      </trans-unit>
      <trans-unit id="Instructions-Line2">
        <source>and select "Execute in Interactive".  You can open the F# Interactive Window from the "View" menu.</source>
        <target state="translated">並選取 [以互動方式執行]。您可以從 [檢視] 功能表開啟 F# 互動式視窗。</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreAbout">
        <source>For more about F#, see:</source>
        <target state="translated">如需有關 F# 的詳細資訊，請參閱:</target>
        <note />
      </trans-unit>
      <trans-unit id="SeeDocumentaton">
        <source>To see this tutorial in documentation form, see:</source>
        <target state="translated">若要參閱文件表單中的此教學課程，請參閱:</target>
        <note />
      </trans-unit>
      <trans-unit id="LearnMoreAbout">
        <source>To learn more about applied F# programming, use</source>
        <target state="translated">如需深入了解套用的 F# 程式設計，請使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ToInstall-Line1">
        <source>To install the Visual F# Power Tools, use</source>
        <target state="translated">若要安裝 Visual F# Power Tools，請使用</target>
        <note />
      </trans-unit>
      <trans-unit id="ToInstall-Line2">
        <source>'Tools' --&gt; 'Extensions and Updates' --&gt; `Online` and search</source>
        <target state="translated">[工具]5D; --&gt; [延伸模組和更新]5D; --&gt; [連線]5D; 並搜尋</target>
        <note />
      </trans-unit>
      <trans-unit id="AdditionalTemplates-Line1">
        <source>For additional templates to use with F#, see the 'Online Templates' in Visual Studio,</source>
        <target state="translated">如需有關搭配 F# 一起使用的其他範本，請參閱 Visual Studio 中的 [線上範本]5D;，</target>
        <note />
      </trans-unit>
      <trans-unit id="AdditionalTemplates-Line2">
        <source>'New Project' --&gt; 'Online Templates'</source>
        <target state="translated">[新增專案]5D; --&gt; [線上範本]5D;</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportsComments">
        <source>F# supports three kinds of comments:</source>
        <target state="translated">F# 支援三種註解:</target>
        <note />
      </trans-unit>
      <trans-unit id="DoubleSlash">
        <source>1. Double-slash comments.  These are used in most situations.</source>
        <target state="translated">1. 將註解加上雙斜線。適用於大部分的情況。</target>
        <note />
      </trans-unit>
      <trans-unit id="MLStyle">
        <source>2. ML-style Block comments.  These aren't used that often.</source>
        <target state="translated">2. 將註解加上 ML 樣式區塊。較不常使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="TripleSlash-Line1">
        <source>3. Triple-slash comments.  These are used for documenting functions, types, and so on.</source>
        <target state="translated">3. 將註解加上三斜線。適用於記錄函式、類型等。</target>
        <note />
      </trans-unit>
      <trans-unit id="TripleSlash-Line2">
        <source>They will appear as text when you hover over something which is decorated with these comments.</source>
        <target state="translated">當您暫留在以這些註解為裝飾的項目上時，這些註解會顯示為文字。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line1">
        <source>They also support .NET-style XML comments, which allow you to generate reference documentation,</source>
        <target state="translated">這些註解也支援 .NET 樣式的 XML 註解，讓您可以產生參考文件，</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line2">
        <source>and they also allow editors (such as Visual Studio) to extract information from them.</source>
        <target state="translated">也讓編輯者 (像是 Visual Studio) 可以從註解中擷取資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/xml-documentation</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/zh-tw/dotnet/articles/fsharp/language-reference/xml-documentation</target>
        <note />
      </trans-unit>
      <trans-unit id="OpenNamespaces">
        <source>Open namespaces using the 'open' keyword.</source>
        <target state="translated">使用 'open' 關鍵字開啟命名空間。</target>
        <note />
      </trans-unit>
      <trans-unit id="LearnMore">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/import-declarations-the-open-keyword</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/zh-tw/dotnet/articles/fsharp/language-reference/import-declarations-the-open-keyword</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line1">
        <source>A module is a grouping of F# code, such as values, types, and function values.</source>
        <target state="translated">模組是 F# 程式碼的分組，例如值、類型及函式值。</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line2">
        <source>Grouping code in modules helps keep related code together and helps avoid name conflicts in your program.</source>
        <target state="translated">將程式碼分組為模組有助於將相關的程式碼整合在一塊，且能避免程式發生名稱衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/modules</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/zh-tw/dotnet/articles/fsharp/language-reference/modules</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleInt">
        <source>This is a sample integer.</source>
        <target state="translated">此為範例整數。</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleFloat">
        <source>This is a sample floating point number.</source>
        <target state="translated">此為範例浮點數。</target>
        <note />
      </trans-unit>
      <trans-unit id="Computed-Line1">
        <source>This computed a new number by some arithmetic.  Numeric types are converted using</source>
        <target state="translated">這使用了一些算數來計算新數字。使用函式 'int'、'double' 等</target>
        <note />
      </trans-unit>
      <trans-unit id="Computed-Line2">
        <source>functions 'int', 'double' and so on.</source>
        <target state="translated">來轉換數字類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListNumbers">
        <source>This is a list of the numbers from 0 to 99.</source>
        <target state="translated">此為從 0 到 99 的數字清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListSquares">
        <source>This is a list of all tuples containing all the numbers from 0 to 99 and their squares.</source>
        <target state="translated">此為所有 Tuple 的清單，內含從 0 到 99 的所有數字及其平方。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintList1">
        <source>The next line prints a list that includes tuples, using '%A' for generic printing.</source>
        <target state="translated">下一行會使用 '%A' 執行一般列印，來列印包含 Tuple 的清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleIntType">
        <source>This is a sample integer with a type annotation</source>
        <target state="translated">此為具有型別註解的範例整數</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line1">
        <source>Values in F# are immutable by default.  They cannot be changed</source>
        <target state="translated">根據預設，F# 中的值是不可變的。於程式執行過程中，除非明確標示為可變的</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line2">
        <source>in the course of a program's execution unless explicitly marked as mutable.</source>
        <target state="translated">否則無法對其進行變更。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/values/index#why-immutable</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/values/index#why-immutable</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line1">
        <source>Binding a value to a name via 'let' makes it immutable.</source>
        <target state="translated">透過 'let' 將值繫結到名稱，即可將它設為不可變動。</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line2">
        <source>The second line of code fails to compile because 'number' is immutable and bound.</source>
        <target state="translated">因為 'number' 無法變動並已繫結，所以無法編譯第二行程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line3">
        <source>Re-defining 'number' to be a different value is not allowed in F#.</source>
        <target state="translated">在 F# 中，不得將 'number' 重新定義為不同的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableKeyword">
        <source>A mutable binding.  This is required to be able to mutate the value of 'otherNumber'.</source>
        <target state="translated">可變動的繫結。需要此項目才可變更 'otherNumber' 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line1">
        <source>When mutating a value, use '&lt;-' to assign a new value.</source>
        <target state="translated">變動值時，請使用 '&lt;-' 指派新的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line2">
        <source>You could not use '=' here for this purpose since it is used for equality</source>
        <target state="translated">'=' 在此表示等於，所以無法用於此用途</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line3">
        <source>or other contexts such as 'let' or 'module'</source>
        <target state="translated">或其他內容，例如 'let' 或 'module'</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line1">
        <source>Much of F# programming consists of defining functions that transform input data to produce</source>
        <target state="translated">F# 程式設計時常需要定義函式來轉換輸入資料，從而產生</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line2">
        <source>useful results.</source>
        <target state="translated">實用的結果。</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/</target>
        <note />
      </trans-unit>
      <trans-unit id="LetFunction-Line1">
        <source>You use 'let' to define a function. This one accepts an integer argument and returns an integer.</source>
        <target state="translated">您可以使用 'let' 來定義函式。此接受整數引數，並會傳回整數。</target>
        <note />
      </trans-unit>
      <trans-unit id="LetFunction-Line2">
        <source>Parentheses are optional for function arguments, except for when you use an explicit type annotation.</source>
        <target state="translated">對函式引數來說不一定要使用括號，但使用明確的型別註解時例外。</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyFunction-Line1">
        <source>Apply the function, naming the function return result using 'let'.</source>
        <target state="translated">套用函式，使用 'let' 命名函數會傳回結果。</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyFunction-Line2">
        <source>The variable type is inferred from the function return type.</source>
        <target state="translated">變數型別是從函式傳回型別推斷出來。</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line1">
        <source>This line uses '%d' to print the result as an integer. This is type-safe.</source>
        <target state="translated">此行使用 '%d' 以整數形式列印結果。這是型別安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line2">
        <source>If 'result1' were not of type 'int', then the line would fail to compile.</source>
        <target state="translated">如果 'result1' 的類型不是 'int'，則無法編譯該行。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeAnnotation">
        <source>When needed, annotate the type of a parameter name using '(argument:type)'.  Parentheses are required.</source>
        <target state="translated">需要時，請使用 '(argument:type)' 為參數名稱的類型加上標註。需要使用括號。</target>
        <note />
      </trans-unit>
      <trans-unit id="Conditionals-Line1">
        <source>Conditionals use if/then/elid/elif/else.</source>
        <target state="translated">條件使用 if/then/elid/elif/else。</target>
        <note />
      </trans-unit>
      <trans-unit id="Conditionals-Line2">
        <source>Note that F# uses whitespace indentation-aware syntax, similar to languages like Python.</source>
        <target state="translated">請注意，F# 使用空白縮排感知語法，其與 Python 這類語言類似。</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line3">
        <source>This line uses '%f' to print the result as a float.  As with '%d' above, this is type-safe.</source>
        <target state="translated">此行使用 '%f' 以浮點形式列印結果。與上述 '%d' 相同，這是型別安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line1">
        <source>Booleans are fundamental data types in F#.  Here are some examples of Booleans and conditional logic.</source>
        <target state="translated">布林值是 F# 中的基本資料類型。以下是一些布林值與條件式邏輯的範例。</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line2">
        <source>To learn more, see:</source>
        <target state="translated">若要深入了解，請參閱:</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line3">
        <source>and</source>
        <target state="translated">及</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanValues">
        <source>Booleans values are 'true' and 'false'.</source>
        <target state="translated">布林值為 'true' 和 'false'。</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanOperators">
        <source>Operators on booleans are 'not', '&amp;&amp;' and '||'.</source>
        <target state="translated">布林值上的運算子為 'not'、'&amp;&amp;' 和 '||'。</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanPrintf">
        <source>This line uses '%b'to print a boolean value.  This is type-safe.</source>
        <target state="translated">此行使用 '%b' 列印布林值。這是型別安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="Strings-Line1">
        <source>Strings are fundamental data types in F#.  Here are some examples of Strings and basic String manipulation.</source>
        <target state="translated">字串在 F# 中是基本的資料類型。以下是一些字串與基本字串操作的範例。</target>
        <note />
      </trans-unit>
      <trans-unit id="Strings-Line2">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/strings</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/strings</target>
        <note />
      </trans-unit>
      <trans-unit id="StringQuotes">
        <source>Strings use double quotes.</source>
        <target state="translated">字串使用雙引號。</target>
        <note />
      </trans-unit>
      <trans-unit id="StringLiterals-Line1">
        <source>Strings can also use @ to create a verbatim string literal.</source>
        <target state="translated">字串也可使用 @ 來建立逐字字串常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="StringLiterals-Line2">
        <source>This will ignore escape characters such as '\', '\n', '\t', etc.</source>
        <target state="translated">這將會忽略逸出字元，例如 '\'、'\n'、'\t' 等等。</target>
        <note />
      </trans-unit>
      <trans-unit id="StringTripleQuotes">
        <source>String literals can also use triple-quotes.</source>
        <target state="translated">字串常值也可使用三引號。</target>
        <note />
      </trans-unit>
      <trans-unit id="StringConcatenation">
        <source>String concatenation is normally done with the '+' operator.</source>
        <target state="translated">串連字串通常使用 '+' 運算子進行。</target>
        <note />
      </trans-unit>
      <trans-unit id="StringPrinting">
        <source>This line uses '%s' to print a string value.  This is type-safe.</source>
        <target state="translated">此行使用 '%s' 列印字串值。這是型別安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="Substrings-Line1">
        <source>Substrings use the indexer notation.  This line extracts the first 7 characters as a substring.</source>
        <target state="translated">子字串使用索引子標記法。此行會擷取前 7 個字元作為子字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="Substrings-Line2">
        <source>Note that like many languages, Strings are zero-indexed in F#.</source>
        <target state="translated">請注意，就像許多語言一樣，字串在 F# 中會以零為基底編製索引。</target>
        <note />
      </trans-unit>
      <trans-unit id="Tuples-Line1">
        <source>Tuples are simple combinations of data values into a combined value.</source>
        <target state="translated">元組是簡單的資料值合併為合併值。</target>
        <note />
      </trans-unit>
      <trans-unit id="Tuples-Line2">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/tuples</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/tuples</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleInteger">
        <source>A simple tuple of integers.</source>
        <target state="translated">簡式整數元組。</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line1">
        <source>A function that swaps the order of two values in a tuple.</source>
        <target state="translated">將元組中兩個值的順序互換的函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line2">
        <source>F# Type Inference will automatically generalize the function to have a generic type,</source>
        <target state="translated">F# 型別推斷會自動將函式一般化成泛型類型，</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line3">
        <source>meaning that it will work with any type.</source>
        <target state="translated">表示其可與任何類型搭配運作。</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleMultiType-Line1">
        <source>A tuple consisting of an integer, a string,</source>
        <target state="translated">元組，包含整數、字串、</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleMultiType-Line2">
        <source>and a double-precision floating point number.</source>
        <target state="translated">和雙精確度浮點數。</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleTypeAnnotation-Line1">
        <source>A simple tuple of integers with a type annotation.</source>
        <target state="translated">具有類型註釋之整數的簡單元組。</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleTypeAnnotation-Line2">
        <source>Type annotations for tuples use the * symbol to separate elements</source>
        <target state="translated">元組的類型註釋會使用 * 符號分隔項目</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line1">
        <source>Tuples are normally objects, but they can also be represented as structs.</source>
        <target state="translated">元組一般是物件，但也可以用結構形式呈現。</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line2">
        <source>These interoperate completely with structs in C# and Visual Basic.NET; however,</source>
        <target state="translated">這些會與 C# 和 Visual Basic .NET 中的結構完全相互操作; 不過，</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line3">
        <source>struct tuples are not implicitly convertable with object tuples (often called reference tuples).</source>
        <target state="translated">結構元組無法利用物件元組 (通常稱為參考元組) 進行隱含轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line4">
        <source>The second line below will fail to compile because of this.  Uncomment it to see what happens.</source>
        <target state="translated">因此，將無法編譯以下的第二行。請取消它的註解，看看會如何。</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleConvert-Line1">
        <source>Although you cannot implicitly convert between struct tuples and reference tuples,</source>
        <target state="translated">雖然您不能隱含地在結構元組及參考元組間進行轉換，</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleConvert-Line2">
        <source>you can explicitly convert via pattern matching, as demonstrated below.</source>
        <target state="translated">但您可透過模式比對明確地轉換，如下所示。</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line1">
        <source>The F# pipe operators ('|&gt;', '&lt;|', etc.) and F# composition operators ('&gt;&gt;', '&lt;&lt;')</source>
        <target state="translated">F# 管道運算子 ('|&gt;'、'&lt;|' 等) 與 F# 組合運算子 ('&gt;&gt;'、'&lt;&lt;')</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line2">
        <source>are used extensively when processing data.  These operators are themselves functions</source>
        <target state="translated">廣泛用於處理資料時。這些運算子本身就是函式</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line3">
        <source>which make use of Partial Application.</source>
        <target state="translated">其會利用局部應用程式。</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line4">
        <source>To learn more about these operators, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/#function-composition-and-pipelining</source>
        <target state="translated">若要深入了解這些運算子，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/#function-composition-and-pipelining</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line5">
        <source>To learn more about Partial Application, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/#partial-application-of-arguments</source>
        <target state="translated">若要深入了解局部應用程式，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/#partial-application-of-arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="Squares">
        <source>Squares a value.</source>
        <target state="translated">產生值的平方。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddOne">
        <source>Adds 1 to a value.</source>
        <target state="translated">將值加 1。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestOdd">
        <source>Tests if an integer value is odd via modulo.</source>
        <target state="translated">測試整數值是否為經過模數的奇數。</target>
        <note />
      </trans-unit>
      <trans-unit id="NumberList1">
        <source>A list of 5 numbers.  More on lists later.</source>
        <target state="translated">5 個數字的清單。清單上稍後會有更多項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithoutPipes-Line1">
        <source>Given a list of integers, it filters out the even numbers,</source>
        <target state="translated">提供整數清單，它會篩選出偶數，</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithoutPipes-Line2">
        <source>squares the resulting odds, and adds 1 to the squared odds.</source>
        <target state="translated">取結果奇數的平方值，並對平方後的奇數加 1。</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line1">
        <source>A shorter way to write 'squareOddValuesAndAddOne' is to nest each</source>
        <target state="translated">撰寫 'squareOddValuesAndAddOne' 較簡短的方式是巢狀每個項目</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line2">
        <source>sub-result into the function calls themselves.</source>
        <target state="translated">子結果進入函式呼叫本身。</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line3">
        <source>This makes the function much shorter, but it's difficult to see the</source>
        <target state="translated">這會將函式設成更短，但較難查看</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line4">
        <source>order in which the data is processed.</source>
        <target state="translated">資料的處理順序。</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line1">
        <source>A preferred way to write 'squareOddValuesAndAddOne' is to use F# pipe operators.</source>
        <target state="translated">撰寫 'squareOddValuesAndAddOne' 的慣用方式是使用 F# 管道運算子。</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line2">
        <source>This allows you to avoid creating intermediate results, but is much more readable</source>
        <target state="translated">這可讓您避免建立中繼結果，但比較容易閱讀</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line3">
        <source>than nesting function calls like 'squareOddValuesAndAddOneNested'</source>
        <target state="translated">，相較於 'squareOddValuesAndAddOneNested' 這類的巢狀函式呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line1">
        <source>You can shorten 'squareOddValuesAndAddOnePipeline' by moving the second `List.map` call</source>
        <target state="translated">您可以移動第二個 'List.map' 呼叫來縮短 'squareOddValuesAndAddOnePipeline'</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line2">
        <source>into the first, using a Lambda Function.</source>
        <target state="translated">到第一個項目，使用 Lambda 函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line3">
        <source>Note that pipelines are also being used inside the lambda function.  F# pipe operators</source>
        <target state="translated">請注意，管線也會用於 lambda 函式內。F# 管道運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line4">
        <source>can be used for single values as well.  This makes them very powerful for processing data.</source>
        <target state="translated">也可以用於單一值。如此可讓它們在處理資料時功能極為強大。</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line1">
        <source>Lastly, you can eliminate the need to explicitly take 'values' in as a parameter by using '&gt;&gt;'</source>
        <target state="translated">最後，您不需要使用 '&gt;&gt;' 來明確接受 'values' 作為參數</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line2">
        <source>to compose the two core operations: filtering out even numbers, then squaring and adding one.</source>
        <target state="translated">以撰寫兩個核心作業: 篩選出偶數，然後取其平方值再加一。</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line3">
        <source>Likewise, the 'fun x -&gt; ...' bit of the lambda expression is also not needed, because 'x' is simply</source>
        <target state="translated">同樣地，也不需要 lambda 運算式的 'fun x -&gt; ...' 位元，因為 'x' 只是</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line4">
        <source>being defined in that scope so that it can be passed to a functional pipeline.  Thus, '&gt;&gt;' can be used</source>
        <target state="translated">定義於該範圍內，以將它傳遞至功能管線。因此，可以使用 '&gt;&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line5">
        <source>there as well.</source>
        <target state="translated">也會在該處。</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line6">
        <source>The result of 'squareOddValuesAndAddOneComposition' is itself another function which takes a</source>
        <target state="translated">'squareOddValuesAndAddOneComposition' 的結果本身是另一個函式，且該函式接受</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line7">
        <source>list of integers as its input.  If you execute 'squareOddValuesAndAddOneComposition' with a list</source>
        <target state="translated">作為輸入的整數清單。如果您執行 'squareOddValuesAndAddOneComposition' 時搭配清單</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line8">
        <source>of integers, you'll notice that it produces the same results as previous functions.</source>
        <target state="translated">(整數)，您將注意到它會產生與先前函式相同的結果。</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line9">
        <source>This is using what is known as function composition.  This is possible because functions in F#</source>
        <target state="translated">這將使用所謂的函式組合。原因可能是 F# 中的函式</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line10">
        <source>use Partial Application and the input and output types of each data processing operation match</source>
        <target state="translated">使用局部應用程式，以及每個資料處理作業相符的輸入與輸出類型</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line11">
        <source>the signatures of the functions we're using.</source>
        <target state="translated">所使用之函式的簽章。</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line1">
        <source>Lists are ordered, immutable, singly-linked lists.  They are eager in their evaluation.</source>
        <target state="translated">清單是已排序且不可變動的單向連結清單。它們於評估時會即刻進行運算。</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line2">
        <source>This module shows various ways to generate lists and process lists with some functions</source>
        <target state="translated">此模組示範產生清單及利用某些函式處理清單的各種方法</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line3">
        <source>in the 'List' module in the F# Core Library.</source>
        <target state="translated">在 F# 核心程式庫的 'List' 模組中。</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/lists</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/lists</target>
        <note />
      </trans-unit>
      <trans-unit id="ListEmptyDefinition">
        <source>Lists are defined using [ ... ].  This is an empty list.</source>
        <target state="translated">清單使用 [ ... ] 定義。這是空白清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListElementDefinition">
        <source>This is a list with 3 elements.  ';' is used to separate elements on the same line.</source>
        <target state="translated">這是內含 3 個項目的清單。使用 ';' 分隔同一行的項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListNewlineElements">
        <source>You can also separate elements by placing them on their own lines.</source>
        <target state="translated">您也可以將項目放在各自的行上加以分隔。</target>
        <note />
      </trans-unit>
      <trans-unit id="NumberList2">
        <source>This is a list of integers from 1 to 1000</source>
        <target state="translated">此為從 1 到 1000 的整數清單</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputation-Line1">
        <source>Lists can also be generated by computations. This is a list containing</source>
        <target state="translated">計算也可產生清單。此清單內含</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputation-Line2">
        <source>all the days of the year.</source>
        <target state="translated">當年每一天。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintList2">
        <source>Print the first 5 elements of 'daysList' using 'List.take'.</source>
        <target state="translated">使用 'List.take' 列印 'daysList' 的前 5 個項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputationConditional-Line1">
        <source>Computations can include conditionals.  This is a list containing the tuples</source>
        <target state="translated">計算可包含條件。此為內含元組的清單</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputationConditional-Line2">
        <source>which are the coordinates of the black squares on a chess board.</source>
        <target state="translated">其為棋盤上黑方格的座標。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line1">
        <source>Lists can be transformed using 'List.map' and other functional programming combinators.</source>
        <target state="translated">可以使用 'List.map' 及其他函式程式設計結合器轉換清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line2">
        <source>This definition produces a new list by squaring the numbers in numberList, using the pipeline</source>
        <target state="translated">此定義會產生新的清單，方法是使用管線使 numberList 中的數字成平方</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line3">
        <source>operator to pass an argument to List.map.</source>
        <target state="translated">運算子以將引數傳遞到 List.map。</target>
        <note />
      </trans-unit>
      <trans-unit id="ListFilter-Line1">
        <source>There are many other list combinations. The following computes the sum of the squares of the</source>
        <target state="translated">還有許多其他清單組合。以下會計算下項的平方總和:</target>
        <note />
      </trans-unit>
      <trans-unit id="ListFilter-Line2">
        <source>numbers divisible by 3.</source>
        <target state="translated">可由 3 整除的數字。</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line1">
        <source>Arrays are fixed-size, mutable collections of elements of the same type.</source>
        <target state="translated">陣列是固定大小且類型相同的可變動項目集合。</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line2">
        <source>Although they are similar to Lists (they support enumeration and have similar combinators for data processing),</source>
        <target state="translated">陣列雖與清單 (支援列舉，並具有類似的結合器可用於資料處理) 相似，但</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line3">
        <source>they are generally faster and support fast random access.  This comes at the cost of being less safe by being mutable.</source>
        <target state="translated">陣列通常比較快，而且支援快速隨機存取。但可變動的代價是安全性變低。</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/arrays</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/arrays</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyArray">
        <source>This is The empty array.  Note that the syntax is similar to that of Lists, but uses `[| ... |]` instead.</source>
        <target state="translated">此為空白的陣列。請注意與清單前置詞相似的前置詞，請改用 `[| ... |]`。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayConstructionList">
        <source>Arrays are specified using the same range of constructs as lists.</source>
        <target state="translated">使用與所列相同的建構範圍指定陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayConstructionRange">
        <source>This is an array of numbers from 1 to 1000.</source>
        <target state="translated">這是從 1 到 1000 的數字陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayComputationConstruction">
        <source>This is an array containing only the words "hello" and "world".</source>
        <target state="translated">這是僅包含 "hello" 與 "world" 字詞的陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayInit">
        <source>This is an array initialized by index and containing the even numbers from 0 to 2000.</source>
        <target state="translated">這是由索引初始化的陣列，內含從 0 到 2000 之間的偶數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArraySlicing">
        <source>Sub-arrays are extracted using slicing notation.</source>
        <target state="translated">使用了切割標記法來擷取子陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayLooping">
        <source>You can loop over arrays and lists using 'for' loops.</source>
        <target state="translated">您可以使用 'for' 迴圈逐一反覆執行陣列與清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayAssignment-Line1">
        <source>You can modify the contents of an an array element by using the left arrow assignment operator.</source>
        <target state="translated">您可以使用向左鍵指派運算子來修改陣列元素的內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayAssignment-Line2">
        <source>To learn more about this operator, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/values/index#mutable-variables</source>
        <target state="translated">若要深入了解此運算子，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/values/index#mutable-variables</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayMap-Line1">
        <source>You can transform arrays using 'Array.map' and other functional programming operations.</source>
        <target state="translated">您可以使用 'Array.map' 及其他功能程式設計作業來轉換陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayMap-Line2">
        <source>The following calculates the sum of the lengths of the words that start with 'h'.</source>
        <target state="translated">以下會計算 'h' 開頭的字組之長度總和。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line1">
        <source>Sequences are a logical series of elements, all of the same type.  These are a more general type than Lists and Arrays.</source>
        <target state="translated">序列是一系列的邏輯項目，全部皆為相同的類型。它是比清單及陣列更常見的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line2">
        <source>Sequences are evaluated on-demand and are re-evaluated each time they are iterated.</source>
        <target state="translated">序列是視需要評估，並在每次反覆執行時重新評估。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line3">
        <source>An F# sequence is an alias for a .NET System.Collections.Generic.IEnumerable&lt;'T&gt;.</source>
        <target state="translated">F# 序列是 .NET System.Collections.Generic.IEnumerable&lt;'T&gt; 的別名。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line4">
        <source>Sequence processing functions can be applied to Lists and Arrays as well.</source>
        <target state="translated">序列處理函式也可以套用到清單和陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line5">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/sequences</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/sequences</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptySequence">
        <source>This is the empty sequence.</source>
        <target state="translated">此為空白序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceOfValues">
        <source>This a sequence of values.</source>
        <target state="translated">這是值的序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="OnDemandSequence">
        <source>This is an on-demand sequence from 1 to 1000.</source>
        <target state="translated">此為從 1 到 1000 的隨選序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceComposition">
        <source>This is a sequence producing the words "hello" and "world"</source>
        <target state="translated">此為產生 "hello" 及 "world" 的序列</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceInit">
        <source>This sequence producing the even numbers up to 2000.</source>
        <target state="translated">此序列產生 2000 以下的偶數。</target>
        <note />
      </trans-unit>
      <trans-unit id="InfiniteSequence-Line1">
        <source>This is an infinite sequence which is a random walk.</source>
        <target state="translated">這是屬於隨機漫步的無限序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="InfiniteSequence-Line2">
        <source>This example uses yield! to return each element of a subsequence.</source>
        <target state="translated">此範例使用 yield! 傳回序列的每個元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequence100Elements">
        <source>This example shows the first 100 elements of the random walk.</source>
        <target state="translated">此範例顯示了隨機漫步的前 100 個項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line1">
        <source>Recursive functions can call themselves. In F#, functions are only recursive</source>
        <target state="translated">遞迴函式可以呼叫其本身。在 F# 中，函式均為遞迴</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line2">
        <source>when declared using 'let rec'.</source>
        <target state="translated">(於使用 'let rec' 宣告時)。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line3">
        <source>Recursion is the preferred way to process sequences or collections in F#.</source>
        <target state="translated">遞迴是處理 F# 中序列或集合的慣用方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/index#recursive-functions</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/index#recursive-functions</target>
        <note />
      </trans-unit>
      <trans-unit id="RecFunDef-Line1">
        <source>This example shows a recursive function that computes the factorial of an</source>
        <target state="translated">此範例顯示遞迴函式，其可計算下項的階乘:</target>
        <note />
      </trans-unit>
      <trans-unit id="RecRunDef-Line2">
        <source>integer. It uses 'let rec' to define a recursive function.</source>
        <target state="translated">整數。其使用 'let rec' 來定義遞迴函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line1">
        <source>Computes the greatest common factor of two integers.</source>
        <target state="translated">計算兩個整數的最大公因數。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line2">
        <source>Since all of the recursive calls are tail calls,</source>
        <target state="translated">因為所有遞迴呼叫都是先計算細項的呼叫 (tail call)，所以</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line3">
        <source>the compiler will turn the function into a loop,</source>
        <target state="translated">編譯器會將函式轉換為迴圈，</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line4">
        <source>which improves performance and reduces memory consumption.</source>
        <target state="translated">以改善效能並降低記憶體耗用。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumList">
        <source>This example computes the sum of a list of integers using recursion.</source>
        <target state="translated">此範例會計算使用遞迴之整數清單的總和。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTail">
        <source>This makes 'sumList' tail recursive, using a helper function with a result accumulator.</source>
        <target state="translated">這會將 'sumList' 設成尾遞迴，使用內含結果累加器的 Helper 函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTailInvoke-Line1">
        <source>This invokes the tail recursive helper function, providing '0' as a seed accumulator.</source>
        <target state="translated">這會叫用尾遞迴 helper 函式，提供 '0' 作為種子累加器。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTailInvoke-Line2">
        <source>An approach like this is common in F#.</source>
        <target state="translated">在 F# 中，這類方式十分常見。</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line1">
        <source>Records are an aggregate of named values, with optional members (such as methods).</source>
        <target state="translated">記錄是具有選擇性成員 (例如方法) 之具名值的彙總。</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line2">
        <source>They are immutable and have structural equality semantics.</source>
        <target state="translated">它們不可變動，且具有結構相等的語意。</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/records</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/records</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordDefinition">
        <source>This example shows how to define a new record type.</source>
        <target state="translated">此範例示範如何定義新記錄類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordInstantiation1">
        <source>This example shows how to instantiate a record type.</source>
        <target state="translated">此範例示範如何具現化記錄類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordInstantiation2">
        <source>You can also do this on the same line with ';' separators.</source>
        <target state="translated">您也可以使用 ';' 分隔符號，在同一行執行此作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line1">
        <source>This example shows how to use "copy-and-update" on record values. It creates</source>
        <target state="translated">此範例顯示如何在記錄值上使用 "copy-and-update"。其會建立</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line2">
        <source>a new record value that is a copy of contact1, but has different values for</source>
        <target state="translated">新記錄值，其為 contact1 的複本，但對於下項有不同的值:</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line3">
        <source>the 'Phone' and 'Verified' fields.</source>
        <target state="translated">[Phone]5D; 與 [Verified]5D; 欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/copy-and-update-record-expressions</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/copy-and-update-record-expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="ProcessRecord-Line1">
        <source>This example shows how to write a function that processes a record value.</source>
        <target state="translated">此範例示範如何寫入會處理記錄值的函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProcessRecord-Line2">
        <source>It converts a 'ContactCard' object to a string.</source>
        <target state="translated">其會將 'ContactCard' 物件轉換為字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordWithMember-Line1">
        <source>This is an example of a Record with a member.</source>
        <target state="translated">這是內含成員之記錄的範例。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordWithMember-Line2">
        <source>Members can implement object-oriented members.</source>
        <target state="translated">成員可以實作物件導向成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordAccess">
        <source>Members are accessed via the '.' operator on an instantiated type.</source>
        <target state="translated">成員透過在具現化類型上的 '.' 運算子加以存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line1">
        <source>Records can also be represented as structs via the 'Struct' attribute.</source>
        <target state="translated">記錄也可透過 'Struct' 屬性以結構形式呈現。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line2">
        <source>This is helpful in situations where the performance of structs outweighs</source>
        <target state="translated">它在結構效能較優的情況下很有用</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line3">
        <source>the flexibility of reference types.</source>
        <target state="translated">參考類型的彈性。</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line1">
        <source>Discriminated Unions (DU for short) are values which could be a number of named forms or cases.</source>
        <target state="translated">差異聯集 (簡寫為 DU) 是可能為數個具名表單或案例的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line2">
        <source>Data stored in DUs can be one of several distinct values.</source>
        <target state="translated">DU 中所儲存的資料可以是數個相異值中的一個。</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions</target>
        <note />
      </trans-unit>
      <trans-unit id="CardSuit">
        <source>The following represents the suit of a playing card.</source>
        <target state="translated">以下代表一副撲克牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="CardRank">
        <source>A Disciminated Union can also be used to represent the rank of a playing card.</source>
        <target state="translated">差異聯集也可用以代表一張撲克牌的順位。</target>
        <note />
      </trans-unit>
      <trans-unit id="CardRankValue">
        <source>Represents the rank of cards 2 .. 10</source>
        <target state="translated">代表 2 .. 10 這幾張牌的順位</target>
        <note />
      </trans-unit>
      <trans-unit id="CardMember">
        <source>Discriminated Unions can also implement object-oriented members.</source>
        <target state="translated">差異聯集也可以實作物件導向成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="CardType-Line1">
        <source>This is a record type that combines a Suit and a Rank.</source>
        <target state="translated">這是合併了 Suit 和 Rank 的記錄類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="CardType-Line2">
        <source>It's common to use both Records and Disciminated Unions when representing data.</source>
        <target state="translated">代表資料時，通常會使用記錄與差異聯集。</target>
        <note />
      </trans-unit>
      <trans-unit id="ComputeFullDeck">
        <source>This computes a list representing all the cards in the deck.</source>
        <target state="translated">這會計算代表一疊牌中所有牌的清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="CardToString">
        <source>This example converts a 'Card' object to a string.</source>
        <target state="translated">此範例將 'Card' 物件轉換為字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintAllCards">
        <source>This example prints all the cards in a playing deck.</source>
        <target state="translated">此範例會列印牌局的所有紙牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line1">
        <source>Single-case DUs are often used for domain modeling.  This can buy you extra type safety</source>
        <target state="translated">單一案例 DU 通常用於網域模型。這讓使用類型變得更加安全</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line2">
        <source>over primitive types such as strings and ints.</source>
        <target state="translated">針對基本類型，例如 strings 和 ints。</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line3">
        <source>Single-case DUs cannot be implicitly converted to or from the type they wrap.</source>
        <target state="translated">單一案例 DU 無法隱含地轉換成它們所包裝的類型，反之亦然。</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line4">
        <source>For example, a function which takes in an Address cannot accept a string as that input,</source>
        <target state="translated">例如，接受位址的函式無法接受字串作為輸入，</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line5">
        <source>or vive/versa.</source>
        <target state="translated">反之亦然。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateSingleCaseDu">
        <source>You can easily instantiate a single-case DU as follows.</source>
        <target state="translated">您可以輕鬆地具現化單一案例 DU，如下所示。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnwrapSingleCaseDu">
        <source>When you need the value, you can unwrap the underlying value with a simple function.</source>
        <target state="translated">當您需要值時，可以使用簡單的函式來展開基礎值。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintSingleCaseDu">
        <source>Printing single-case DUs is simple with unwrapping functions.</source>
        <target state="translated">使用展開 (unwrap) 函式來列印單一案例的 DU 十分簡單。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line1">
        <source>Disciminated Unions also support recursive definitions.</source>
        <target state="translated">差異聯集也支援遞迴定義。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line2">
        <source>This represents a Binary Search Tree, with one case being the Empty tree,</source>
        <target state="translated">這代表二進位搜尋樹狀結構，其中有一個案例是空的樹狀結構，</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line3">
        <source>and the other being a Node with a value and two subtrees.</source>
        <target state="translated">而另一個是具有一個值和兩個子樹狀結構的節點。</target>
        <note />
      </trans-unit>
      <trans-unit id="SearchBinaryTree-Line1">
        <source>Check if an item exists in the binary search tree.</source>
        <target state="translated">請確認二進位搜尋樹狀結構中是否已有項目存在。</target>
        <note />
      </trans-unit>
      <trans-unit id="SearchBinaryTree-Line2">
        <source>Searches recursively using Pattern Matching.  Returns true if it exists; otherwise, false.</source>
        <target state="translated">使用模式比對進行遞迴搜尋。若存在即傳回 true; 否則傳回 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="CheckLeftSubtree">
        <source>Check the left subtree.</source>
        <target state="translated">請檢查左樹狀子結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="CheckRightSubtree">
        <source>Check the right subtree.</source>
        <target state="translated">請檢查右樹狀子結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line1">
        <source>Inserts an item in the Binary Search Tree.</source>
        <target state="translated">在二進位搜尋樹狀結構中插入項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line2">
        <source>Finds the place to insert recursively using Pattern Matching, then inserts a new node.</source>
        <target state="translated">尋找要使用模式比對遞迴插入的位置，然後插入新節點。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line3">
        <source>If the item is already present, it does not insert anything.</source>
        <target state="translated">如果該項目已經存在，就不會插入任何內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line4">
        <source>No need to insert, it already exists; return the node.</source>
        <target state="translated">其已存在，所以無須插入; 傳回該節點。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line5">
        <source>Call into left subtree.</source>
        <target state="translated">呼叫左樹狀子結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line6">
        <source>Call into right subtree.</source>
        <target state="translated">呼叫右樹狀子結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line1">
        <source>Discriminated Unions can also be represented as structs via the 'Struct' attribute.</source>
        <target state="translated">差異聯集也可透過 'Struct' 屬性以結構形式呈現。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line2">
        <source>This is helpful in situations where the performance of structs outweighs</source>
        <target state="translated">它在結構效能較優的情況下很有用</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line3">
        <source>the flexibility of reference types.</source>
        <target state="translated">參考類型的彈性。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line4">
        <source>However, there are two important things to know when doing this:</source>
        <target state="translated">但執行這項作業時，需要知道兩件重要的事情:</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line5">
        <source>1. A struct DU cannot be recursively-defined.</source>
        <target state="translated">1. 不可遞迴定義結構 DU。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line6">
        <source>2. A struct DU must have unique names for each of its cases.</source>
        <target state="translated">2. 結構 DU 的每個案例都必須要有唯一的名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line1">
        <source>Pattern Matching is a feature of F# that allows you to utilize Patterns,</source>
        <target state="translated">模式比對是讓您能利用模式的一項 F# 功能，</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line2">
        <source>which are a way to compare data with a logical structure or structures,</source>
        <target state="translated">這是使用一或多個邏輯結構來比對資料的方式，</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line3">
        <source>decompose data into constituent parts, or extract information from data in various ways.</source>
        <target state="translated">將資料分解為構成組件，或透過各種方式來擷取資料中的資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line4">
        <source>You can then dispatch on the "shape" of a pattern via Pattern Matching.</source>
        <target state="translated">接著可根據透過比對模式之模式的「形狀」加以分派。</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line5">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/pattern-matching</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/pattern-matching</target>
        <note />
      </trans-unit>
      <trans-unit id="PersonRecord">
        <source>A record for a person's first and last name</source>
        <target state="translated">人員姓名的記錄</target>
        <note />
      </trans-unit>
      <trans-unit id="EmployeeDu">
        <source>A Discriminated Union of 3 different kinds of employees</source>
        <target state="translated">3 種不同種類員工的差異聯集</target>
        <note />
      </trans-unit>
      <trans-unit id="CountEmployees-Line1">
        <source>Count everyone underneath the employee in the management hierarchy,</source>
        <target state="translated">計算管理階層中該員工下的每位人員，</target>
        <note />
      </trans-unit>
      <trans-unit id="CountEmployees-Line2">
        <source>including the employee.</source>
        <target state="translated">包括員工。</target>
        <note />
      </trans-unit>
      <trans-unit id="FindDave-Line1">
        <source>Find all managers/executives named "Dave" who do not have any reports.</source>
        <target state="translated">尋找沒有任何報表且名為 "Dave" 的所有經理/主管。</target>
        <note />
      </trans-unit>
      <trans-unit id="FindDave-Line2">
        <source>This uses the 'function' shorthand to as a lambda expression.</source>
        <target state="translated">這會使用 'function' 速記作為 lambda 運算式。</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchEmptyList">
        <source>[] matches an empty list.</source>
        <target state="translated">[] 代表空的清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchWildcard-Line1">
        <source>'_' is a wildcard pattern that matches anything.</source>
        <target state="translated">'_' 是符合所有項目的萬用字元模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchWildCard-Line2">
        <source>This handles the "or else" case.</source>
        <target state="translated">這會處理 "or else" 案例。</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchShorthand-Line1">
        <source>You can also use the shorthand function construct for pattern matching,</source>
        <target state="translated">您也可以使用速記函式建構來進行模式比對，</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchShorthand-Line2">
        <source>which is useful when you're writing functions which make use of Partial Application.</source>
        <target state="translated">適用於撰寫可利用局部應用程式的函式時。</target>
        <note />
      </trans-unit>
      <trans-unit id="ParseHelpers">
        <source>Define some more functions which parse with the helper function.</source>
        <target state="translated">再額外定義一些使用 Helper 函式進行剖析的函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line1">
        <source>Active Patterns are another powerful construct to use with pattern matching.</source>
        <target state="translated">現用模式是另一項功能強大之建構，可與模式比對搭配使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line2">
        <source>They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</source>
        <target state="translated">它們可讓您將輸入資料分割到多個自訂表單，於模式比對呼叫網站進行分解。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/active-patterns</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/active-patterns</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchActivePattern">
        <source>Pattern Matching via 'function' keyword and Active Patterns often looks like this.</source>
        <target state="translated">透過 'function' 關鍵字與現用模式進行模式比對，通常看來如下。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintParse">
        <source>Call the printer with some different values to parse.</source>
        <target state="translated">透過解析一些不同的值來呼叫印表機。</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line1">
        <source>Option values are any kind of value tagged with either 'Some' or 'None'.</source>
        <target state="translated">選項值是以 'Some' 或 'None' 標記的任何一種值。</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line2">
        <source>They are used extensively in F# code to represent the cases where many other</source>
        <target state="translated">它們廣泛用於 F# 程式碼中，來代表許多其他語言會</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line3">
        <source>languages would use null references.</source>
        <target state="translated">使用 null 參考的狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/options</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/options</target>
        <note />
      </trans-unit>
      <trans-unit id="ZipCode">
        <source>First, define a zipcode defined via Single-case Discriminated Union.</source>
        <target state="translated">首先，定義透過單一案例差異聯集所定義的郵遞區號。</target>
        <note />
      </trans-unit>
      <trans-unit id="Customer">
        <source>Next, define a type where the ZipCode is optional.</source>
        <target state="translated">接著，定義不一定需要 ZipCode 的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ShippingCalculator-Line1">
        <source>Next, define an interface type that represents an object to compute the shipping zone for the customer's zip code,</source>
        <target state="translated">然後，定義代表物件的介面類型，以計算客戶郵遞區號的郵寄區域，</target>
        <note />
      </trans-unit>
      <trans-unit id="ShippingCalculator-Line2">
        <source>given implementations for the 'getState' and 'getShippingZone' abstract methods.</source>
        <target state="translated">'getState' 和 'getShippingZone' 抽象方法的指定實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line1">
        <source>Next, calculate a shipping zone for a customer using a calculator instance.</source>
        <target state="translated">接下來，為使用計算機執行個體的客戶計算出貨區。</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line2">
        <source>This uses combinators in the Option module to allow a functional pipeline for</source>
        <target state="translated">這會在 Option 模組中使用結合器，以允許在執行下列功能時使用功能管線:</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line3">
        <source>transforming data with Optionals.</source>
        <target state="translated">使用選用項目來轉換資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line1">
        <source>Units of measure are a way to annotate primitive numeric types in a type-safe way.</source>
        <target state="translated">測量單位是以型別安全方式為基本數值類型加上註釋的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line2">
        <source>You can then perform type-safe arithmetic on these values.</source>
        <target state="translated">接著可以在這些值上執行型別安全算術。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/units-of-measure</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/units-of-measure</target>
        <note />
      </trans-unit>
      <trans-unit id="CommonUnits">
        <source>First, open a collection of common unit names</source>
        <target state="translated">首先，開啟常用單位名稱的集合</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineUnitConstant">
        <source>Define a unitized constant</source>
        <target state="translated">定義 unitized 常數</target>
        <note />
      </trans-unit>
      <trans-unit id="MileUnit">
        <source>Next, define a new unit type</source>
        <target state="translated">接著，定義新單位類型</target>
        <note />
      </trans-unit>
      <trans-unit id="MileToMeter">
        <source>Conversion factor mile to meter.</source>
        <target state="translated">英哩到公尺的轉換因數。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineMileConstant">
        <source>Define a unitized constant</source>
        <target state="translated">定義 unitized 常數</target>
        <note />
      </trans-unit>
      <trans-unit id="ComputeMileToMeter">
        <source>Compute  metric-system constant</source>
        <target state="translated">計算計量系統常數</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintUnitsOfMeasure">
        <source>Values using Units of Measure can be used just like the primitive numeric type for things like printing.</source>
        <target state="translated">使用測量單位之值的用法，就像是列印這類作業的基本數字類型一樣。</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line1">
        <source>Classes are a way of defining new object types in F#, and support standard Object-oriented constructs.</source>
        <target state="translated">類別是在 F# 中定義新物件類型的一種方式，且支援標準物件導向建構。</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line2">
        <source>They can have a variety of members (methods, properties, events, etc.)</source>
        <target state="translated">它們可以有各式不同的成員 (方法、屬性、事件等等)</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line3">
        <source>To learn more about Classes, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/classes</source>
        <target state="translated">若要深入了解類別，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/classes</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line4">
        <source>To learn more about Members, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members</source>
        <target state="translated">若要深入了解成員，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line1">
        <source>A simple two-dimensional Vector class.</source>
        <target state="translated">簡式二維向量類別。</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line2">
        <source>The class's constructor is on the first line,</source>
        <target state="translated">類別的建構函式位於第一行，</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line3">
        <source>and takes two arguments: dx and dy, both of type 'double'.</source>
        <target state="translated">並接受兩種引數: dx 與 dy，兩者的類型都是 'double'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInternalField-Line1">
        <source>This internal field stores the length of the vector, computed when the</source>
        <target state="translated">這個內部欄位會儲存向量長度，計算時機為</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInternalField-Line2">
        <source>object is constructed</source>
        <target state="translated">物件已建構</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisKeyword-Line1">
        <source>'this' specifies a name for the object's self identifier.</source>
        <target state="translated">'this' 會為物件的自我識別碼指定名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisKeyword-Line2">
        <source>In instance methods, it must appear before the member name.</source>
        <target state="translated">在執行個體方法中，它必須出現在成員名稱前面。</target>
        <note />
      </trans-unit>
      <trans-unit id="MemberMethod">
        <source>This member is a method.  The previous members were properties.</source>
        <target state="translated">此成員是方法。先前的成員是屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateClass">
        <source>This is how you instantiate the Vector2D class.</source>
        <target state="translated">這是 Vector2D 類別的具現化方式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ScaledVector">
        <source>Get a new scaled vector object, without modifying the original object.</source>
        <target state="translated">取得全新且可縮放大小的向量物件，但不修改原始物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line1">
        <source>Generic classes allow types to be defined with respect to a set of type parameters.</source>
        <target state="translated">泛型類別可定義關乎一組類型參數的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line2">
        <source>In the following, 'T is the type parameter for the class.</source>
        <target state="translated">在下列範例中，'T 是類別的型別參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalField">
        <source>This internal field store the states in a list.</source>
        <target state="translated">此內部欄位會以清單形式儲存狀態。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddElement">
        <source>Add a new element to the list of states.</source>
        <target state="translated">新增項目至狀態清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment">
        <source>use the '&lt;-' operator to mutate the value.</source>
        <target state="translated">使用 '&lt;-' 運算子可變動值。</target>
        <note />
      </trans-unit>
      <trans-unit id="History">
        <source>Get the entire list of historical states.</source>
        <target state="translated">取得完整的歷程狀態清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="Current">
        <source>Get the latest state.</source>
        <target state="translated">取得最新狀態。</target>
        <note />
      </trans-unit>
      <trans-unit id="InferredTypeParameter">
        <source>An 'int' instance of the state tracker class. Note that the type parameter is inferred.</source>
        <target state="translated">狀態追蹤器類別的 'int' 執行個體。請注意，型別參數是推斷出來的。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddState">
        <source>Add a state</source>
        <target state="translated">加入狀態</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line1">
        <source>Interfaces are object types with only 'abstract' members.</source>
        <target state="translated">介面為只有 'abstract' 成員的物件類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line2">
        <source>Object types and object expressions can implement interfaces.</source>
        <target state="translated">物件類型與物件運算式可以實作介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/interfaces</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposable">
        <source>This is a type that implements IDisposable.</source>
        <target state="translated">這是實作 IDisposable 的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableImplementation">
        <source>This is the implementation of IDisposable members.</source>
        <target state="translated">這是 IDisposable 成員的實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line1">
        <source>This is an object that implements IDisposable via an Object Expression</source>
        <target state="translated">這是透過物件運算式實作 IDisposable 的物件</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line2">
        <source>Unlike other languages such as C# or Java, a new type definition is not needed</source>
        <target state="translated">與 C# 或 Java 等其他這類語言不同，不需要新的類型定義</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line3">
        <source>to implement an interface.</source>
        <target state="translated">以實作介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line1">
        <source>The FSharp.Core library defines a range of parallel processing functions.  Here</source>
        <target state="translated">FSharp.Core 程式庫定義一個範圍內的平行處理函式。這裡</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line2">
        <source>you use some functions for parallel processing over arrays.</source>
        <target state="translated">您可以使用一些函式對陣列進行平行處理。</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line3">
        <source>To learn more, see: https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/array.parallel-module-%5Bfsharp%5D</source>
        <target state="translated">若要深入了解，請參閱: https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/array.parallel-module-%5Bfsharp%5D</target>
        <note />
      </trans-unit>
      <trans-unit id="InputArray">
        <source>First, an array of inputs.</source>
        <target state="translated">首先，輸入的陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpensiveFunction">
        <source>Next, define a functions that does some CPU intensive computation.</source>
        <target state="translated">接下來，定義執行某些 CPU 密集型計算的函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ParallelMap">
        <source>Next, do a parallel map over a large input array.</source>
        <target state="translated">接下來，對大型輸入陣列執行平行對應。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintParallel">
        <source>Next, print the results.</source>
        <target state="translated">接下來，列印結果。</target>
        <note />
      </trans-unit>
      <trans-unit id="Events-Line1">
        <source>Events are a common idiom for .NET programming, especially with WinForms or WPF applications.</source>
        <target state="translated">事件是 .NET 程式設計的常見慣用語，特別是使用 WinForms 或 WPF 應用程式時。</target>
        <note />
      </trans-unit>
      <trans-unit id="Events-Line2">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/events</source>
        <target state="translated">若要深入了解，請參閱: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/events</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleEvent">
        <source>First, create instance of Event object that consists of subscription point (event.Publish) and event trigger (event.Trigger).</source>
        <target state="translated">首先，建立由訂閱點 (event.Publish) 與事件觸發程序 (event.Trigger) 所組成之事件物件的執行個體。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddEventHandler1">
        <source>Next, add handler to the event.</source>
        <target state="translated">接下來，將處理常式新增到事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="TriggerEvent">
        <source>Next, trigger the event.</source>
        <target state="translated">接下來，觸發該事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="EventWithArgs">
        <source>Next, create an instance of Event that follows standard .NET convention: (sender, EventArgs).</source>
        <target state="translated">接下來，為遵循標準 .NET 慣例的事件建立執行個體: (sender, EventArgs)。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddEventHandler2">
        <source>Next, add a handler for this new event.</source>
        <target state="translated">接下來，為此新事件新增處理常式。</target>
        <note />
      </trans-unit>
      <trans-unit id="TriggerEventWithArgs">
        <source>Next, trigger this event (note that sender argument should be set).</source>
        <target state="translated">接下來，觸發此事件 (請注意，應該設定 sender 引數)。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>