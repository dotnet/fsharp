<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../Tutorial.fsx">
    <body>
      <trans-unit id="SampleHeader">
        <source>This sample will guide you through elements of the F# language.</source>
        <target state="translated">이 샘플에서는 F# 언어의 요소에 대해 안내합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Instructions-Line1">
        <source>To execute the code in F# Interactive, highlight a section of code and press Alt-Enter or right-click</source>
        <target state="translated">F# 대화형에서 코드를 실행하려면 코드 섹션을 강조 표시하고 &lt;Alt+Enter&gt;를 누르거나 마우스 오른쪽 단추를 클릭한 다음</target>
        <note />
      </trans-unit>
      <trans-unit id="Instructions-Line2">
        <source>and select "Execute in Interactive".  You can open the F# Interactive Window from the "View" menu.</source>
        <target state="translated">"대화형으로 실행"을 선택하세요.  "보기" 메뉴에서 F# 대화형 창을 열 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreAbout">
        <source>For more about F#, see:</source>
        <target state="translated">F#에 대한 자세한 내용은 다음을 참조하세요:</target>
        <note />
      </trans-unit>
      <trans-unit id="SeeDocumentaton">
        <source>To see this tutorial in documentation form, see:</source>
        <target state="translated">이 자습서를 설명서 형식으로 보려면 다음을 참조하세요:</target>
        <note />
      </trans-unit>
      <trans-unit id="LearnMoreAbout">
        <source>To learn more about applied F# programming, use</source>
        <target state="translated">적용된 F# 프로그래밍에 대해 자세히 알아보려면 다음을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ToInstall-Line1">
        <source>To install the Visual F# Power Tools, use</source>
        <target state="translated">Visual F# Power 도구를 설치하려면 다음을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ToInstall-Line2">
        <source>'Tools' --&gt; 'Extensions and Updates' --&gt; `Online` and search</source>
        <target state="translated">'도구' --&gt; '확장 및 업데이트' --&gt; `온라인`으로 이동하고 검색합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AdditionalTemplates-Line1">
        <source>For additional templates to use with F#, see the 'Online Templates' in Visual Studio,</source>
        <target state="translated">F#과 함께 사용할 수 있는 추가 템플릿은 Visual Studio의 다음 위치에서 '온라인 템플릿'을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AdditionalTemplates-Line2">
        <source>'New Project' --&gt; 'Online Templates'</source>
        <target state="translated">'새 프로젝트' --&gt; '온라인 템플릿'</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportsComments">
        <source>F# supports three kinds of comments:</source>
        <target state="translated">F#에서는 세 가지 종류의 주석을 지원합니다:</target>
        <note />
      </trans-unit>
      <trans-unit id="DoubleSlash">
        <source>1. Double-slash comments.  These are used in most situations.</source>
        <target state="translated">1. 이중 슬래시 주석은 대부분의 경우에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MLStyle">
        <source>2. ML-style Block comments.  These aren't used that often.</source>
        <target state="translated">2. ML 스타일 블록 주석은 자주 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TripleSlash-Line1">
        <source>3. Triple-slash comments.  These are used for documenting functions, types, and so on.</source>
        <target state="translated">3. 삼중 슬래시 주석은 함수, 형식 등을 설명하는 경우에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TripleSlash-Line2">
        <source>They will appear as text when you hover over something which is decorated with these comments.</source>
        <target state="translated">이러한 주석으로 데코레이트된 항목 위에 마우스를 올리면 텍스트로 표시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line1">
        <source>They also support .NET-style XML comments, which allow you to generate reference documentation,</source>
        <target state="translated">참조 문서를 생성할 수 있는 .NET 스타일 XML 주석도 지원하며,</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line2">
        <source>and they also allow editors (such as Visual Studio) to extract information from them.</source>
        <target state="translated">또한 편집기(예: Visual Studio)에서 정보를 추출할 수 있도록 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/xml-documentation</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/xml-documentation</target>
        <note />
      </trans-unit>
      <trans-unit id="OpenNamespaces">
        <source>Open namespaces using the 'open' keyword.</source>
        <target state="translated">'open' 키워드를 사용하여 네임스페이스를 엽니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="LearnMore">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/import-declarations-the-open-keyword</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/import-declarations-the-open-keyword</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line1">
        <source>A module is a grouping of F# code, such as values, types, and function values.</source>
        <target state="translated">모듈은 값, 형식, 함수 값 같은 F# 코드의 그룹화입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line2">
        <source>Grouping code in modules helps keep related code together and helps avoid name conflicts in your program.</source>
        <target state="translated">모듈로 코드를 그룹화하면 관련 코드를 함께 유지하고 프로그램에서 이름 충돌을 방지하는 데 도움이 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/modules</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/modules</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleInt">
        <source>This is a sample integer.</source>
        <target state="translated">샘플 정수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleFloat">
        <source>This is a sample floating point number.</source>
        <target state="translated">샘플 부동 소수점 숫자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Computed-Line1">
        <source>This computed a new number by some arithmetic.  Numeric types are converted using</source>
        <target state="translated">산술을 사용하여 새 수를 계산했습니다. 숫자 형식은</target>
        <note />
      </trans-unit>
      <trans-unit id="Computed-Line2">
        <source>functions 'int', 'double' and so on.</source>
        <target state="translated">'int', 'double' 등의 함수를 사용하여 변환됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListNumbers">
        <source>This is a list of the numbers from 0 to 99.</source>
        <target state="translated">0에서 99까지의 숫자 목록입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListSquares">
        <source>This is a list of all tuples containing all the numbers from 0 to 99 and their squares.</source>
        <target state="translated">0에서 99까지의 모든 숫자와 제곱을 포함하는 모든 튜플 목록입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintList1">
        <source>The next line prints a list that includes tuples, using '%A' for generic printing.</source>
        <target state="translated">다음 줄은 제네릭 출력에 대해 '%A'을(를) 사용하여 튜플을 포함하는 목록을 출력합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleIntType">
        <source>This is a sample integer with a type annotation</source>
        <target state="translated">형식 주석이 있는 샘플 정수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line1">
        <source>Values in F# are immutable by default.  They cannot be changed</source>
        <target state="translated">F#의 값은 기본적으로 변경할 수 없습니다. 변경 가능으로</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line2">
        <source>in the course of a program's execution unless explicitly marked as mutable.</source>
        <target state="translated">명시적으로 표시되지 않는 한 프로그램 실행 중 변경할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/values/index#why-immutable</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/values/index#why-immutable</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line1">
        <source>Binding a value to a name via 'let' makes it immutable.</source>
        <target state="translated">'let'을 통해 값을 이름에 바인딩하면 값을 변경할 수 없게 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line2">
        <source>The second line of code fails to compile because 'number' is immutable and bound.</source>
        <target state="translated">'number'는 변경이 불가능하고 바인딩되어 있으므로 코드의 두 번째 줄이 컴파일되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line3">
        <source>Re-defining 'number' to be a different value is not allowed in F#.</source>
        <target state="translated">F#에서는 'number'를 다른 값으로 다시 정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableKeyword">
        <source>A mutable binding.  This is required to be able to mutate the value of 'otherNumber'.</source>
        <target state="translated">변경할 수 있는 바인딩은 'otherNumber' 값을 변경하기 위해 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line1">
        <source>When mutating a value, use '&lt;-' to assign a new value.</source>
        <target state="translated">값을 변경할 때는 '&lt;-'를 사용하여 새 값을 할당하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line2">
        <source>You could not use '=' here for this purpose since it is used for equality</source>
        <target state="translated">'='이 같음에 대해 사용되지 않으므로 여기에서 이 용도로 '='을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line3">
        <source>or other contexts such as 'let' or 'module'</source>
        <target state="translated">또는 'let'이나 'module' 같은 기타 컨텍스트</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line1">
        <source>Much of F# programming consists of defining functions that transform input data to produce</source>
        <target state="translated">대부분의 F# 프로그래밍은 유용한 결과를 생성하기 위해 입력 데이터를 변환하는 함수 정의로</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line2">
        <source>useful results.</source>
        <target state="translated">구성됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/</target>
        <note />
      </trans-unit>
      <trans-unit id="LetFunction-Line1">
        <source>You use 'let' to define a function. This one accepts an integer argument and returns an integer.</source>
        <target state="translated">'let'을 사용하여 정수 인수를 받고 정수를 반환하는 함수를 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetFunction-Line2">
        <source>Parentheses are optional for function arguments, except for when you use an explicit type annotation.</source>
        <target state="translated">괄호는 명시적 형식 주석을 사용하는 경우 외에는 함수 인수에 선택적으로 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyFunction-Line1">
        <source>Apply the function, naming the function return result using 'let'.</source>
        <target state="translated">함수를 적용하고, 'let'을 사용하여 함수 반환 결과에 이름을 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyFunction-Line2">
        <source>The variable type is inferred from the function return type.</source>
        <target state="translated">변수 형식은 함수 반환 형식에서 유추됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line1">
        <source>This line uses '%d' to print the result as an integer. This is type-safe.</source>
        <target state="translated">이 줄은 '%d'을(를) 사용하여 결과를 integer로 인쇄합니다. 이 코드는 형식이 안전합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line2">
        <source>If 'result1' were not of type 'int', then the line would fail to compile.</source>
        <target state="translated">'result1'이 'int' 형식이 아닌 경우 줄이 컴파일되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeAnnotation">
        <source>When needed, annotate the type of a parameter name using '(argument:type)'.  Parentheses are required.</source>
        <target state="translated">필요한 경우 '(argument:type)'을 사용하여 매개 변수 이름 형식에 대한 주석을 답니다. 괄호가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Conditionals-Line1">
        <source>Conditionals use if/then/elid/elif/else.</source>
        <target state="translated">조건은 if/then/elid/elif/else를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Conditionals-Line2">
        <source>Note that F# uses whitespace indentation-aware syntax, similar to languages like Python.</source>
        <target state="translated">F#은 Python과 같은 언어처럼 공백 들여쓰기 인식 구문을 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line3">
        <source>This line uses '%f' to print the result as a float.  As with '%d' above, this is type-safe.</source>
        <target state="translated">이 줄은 '%f'을(를) 사용하여 결과를 float으로 인쇄합니다. 위의 '%d'처럼 이 코드는 형식이 안전합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line1">
        <source>Booleans are fundamental data types in F#.  Here are some examples of Booleans and conditional logic.</source>
        <target state="translated">부울은 F#에서 기본적인 데이터 형식입니다. 다음은 부울 및 조건부 논리의 몇 가지 예입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line2">
        <source>To learn more, see:</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요:</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line3">
        <source>and</source>
        <target state="translated">그리고</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanValues">
        <source>Booleans values are 'true' and 'false'.</source>
        <target state="translated">부울 값은 'true' 및 'false'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanOperators">
        <source>Operators on booleans are 'not', '&amp;&amp;' and '||'.</source>
        <target state="translated">부울의 연산자는 'not', '&amp;&amp;' 및 '||'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanPrintf">
        <source>This line uses '%b'to print a boolean value.  This is type-safe.</source>
        <target state="translated">이 줄은 '%b'을(를) 사용하여 부울 값을 인쇄합니다. 이 코드는 형식이 안전합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Strings-Line1">
        <source>Strings are fundamental data types in F#.  Here are some examples of Strings and basic String manipulation.</source>
        <target state="translated">문자열은 F#에서 기본적인 데이터 형식입니다. 다음은 문자열 및 기본 문자열 조작의 몇 가지 예입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Strings-Line2">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/strings</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/strings</target>
        <note />
      </trans-unit>
      <trans-unit id="StringQuotes">
        <source>Strings use double quotes.</source>
        <target state="translated">문자열은 큰따옴표를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringLiterals-Line1">
        <source>Strings can also use @ to create a verbatim string literal.</source>
        <target state="translated">또한 문자열은 @을 사용하여 축자 문자열 리터럴을 만듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringLiterals-Line2">
        <source>This will ignore escape characters such as '\', '\n', '\t', etc.</source>
        <target state="translated">이 경우 '\', '\n', '\t' 등과 같은 이스케이프 문자열을 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringTripleQuotes">
        <source>String literals can also use triple-quotes.</source>
        <target state="translated">또한 문자열 리터럴은 세 따옴표를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringConcatenation">
        <source>String concatenation is normally done with the '+' operator.</source>
        <target state="translated">문자열 연결은 일반적으로 '+' 연산자로 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringPrinting">
        <source>This line uses '%s' to print a string value.  This is type-safe.</source>
        <target state="translated">이 줄은 '%s'을(를) 사용하여 문자열 값을 인쇄합니다. 이 코드는 형식이 안전합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Substrings-Line1">
        <source>Substrings use the indexer notation.  This line extracts the first 7 characters as a substring.</source>
        <target state="translated">부분 문자열은 인덱서 표기법을 사용합니다. 이 줄은 처음 7개 문자를 부분 문자열로 추출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Substrings-Line2">
        <source>Note that like many languages, Strings are zero-indexed in F#.</source>
        <target state="translated">다른 여러 언어처럼 F#에서는 문자열이 0으로 인덱싱됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Tuples-Line1">
        <source>Tuples are simple combinations of data values into a combined value.</source>
        <target state="translated">튜플은 데이터 값을 조합된 값으로 만드는 간단한 조합입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Tuples-Line2">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/tuples</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/tuples</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleInteger">
        <source>A simple tuple of integers.</source>
        <target state="translated">단순한 정수 튜플입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line1">
        <source>A function that swaps the order of two values in a tuple.</source>
        <target state="translated">튜플에 있는 두 값의 순서를 바꾸는 함수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line2">
        <source>F# Type Inference will automatically generalize the function to have a generic type,</source>
        <target state="translated">F# 형식 유추에서는 자동으로 함수를 제너릭 형식으로 일반화하므로,</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line3">
        <source>meaning that it will work with any type.</source>
        <target state="translated">모든 형식에 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleMultiType-Line1">
        <source>A tuple consisting of an integer, a string,</source>
        <target state="translated">정수, 문자열 및 배정밀도 부동 소수점</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleMultiType-Line2">
        <source>and a double-precision floating point number.</source>
        <target state="translated">숫자로 구성된 튜플입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleTypeAnnotation-Line1">
        <source>A simple tuple of integers with a type annotation.</source>
        <target state="translated">형식 주석이 포함된 단순한 정수 튜플입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleTypeAnnotation-Line2">
        <source>Type annotations for tuples use the * symbol to separate elements</source>
        <target state="translated">튜플에 대한 형식 주석은 * 기호를 사용하여 요소를 구분합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line1">
        <source>Tuples are normally objects, but they can also be represented as structs.</source>
        <target state="translated">튜플은 일반적으로 개체이지만 구조체로 나타낼 수도 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line2">
        <source>These interoperate completely with structs in C# and Visual Basic.NET; however,</source>
        <target state="translated">이러한 구조체는 C# 및 Visual Basic.NET의 구조체와 완벽히 상호 운용되지만,</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line3">
        <source>struct tuples are not implicitly convertable with object tuples (often called reference tuples).</source>
        <target state="translated">구조체 튜플은 개체 튜플(참조 튜플이라고도 함)로 암시적인 변환을 할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line4">
        <source>The second line below will fail to compile because of this.  Uncomment it to see what happens.</source>
        <target state="translated">이로써 아래 두 번째 줄은 컴파일되지 않으며 결과를 확인하려면 이 줄의 주석 처리를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleConvert-Line1">
        <source>Although you cannot implicitly convert between struct tuples and reference tuples,</source>
        <target state="translated">구조체 튜플과 참조 튜플 간을 암시적으로 변환할 수 없지만,</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleConvert-Line2">
        <source>you can explicitly convert via pattern matching, as demonstrated below.</source>
        <target state="translated">아래 설명된 것처럼 패턴 일치를 통해 명시적으로 변환할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line1">
        <source>The F# pipe operators ('|&gt;', '&lt;|', etc.) and F# composition operators ('&gt;&gt;', '&lt;&lt;')</source>
        <target state="translated">F# 파이프 연산자('|&gt;', '&lt;|' 등) 및 F# 합성 연산자('&gt;&gt;', '&lt;&lt;')는</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line2">
        <source>are used extensively when processing data.  These operators are themselves functions</source>
        <target state="translated">데이터를 처리할 때 광범위하게 사용됩니다. 이러한 연산자는 자체가 함수이며</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line3">
        <source>which make use of Partial Application.</source>
        <target state="translated">부분 애플리케이션을 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line4">
        <source>To learn more about these operators, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/#function-composition-and-pipelining</source>
        <target state="translated">이러한 연산자에 대해 자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/#function-composition-and-pipelining</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line5">
        <source>To learn more about Partial Application, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/#partial-application-of-arguments</source>
        <target state="translated">부분 애플리케이션에 대해 자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/#partial-application-of-arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="Squares">
        <source>Squares a value.</source>
        <target state="translated">값을 제곱합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddOne">
        <source>Adds 1 to a value.</source>
        <target state="translated">값에 1을 더합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestOdd">
        <source>Tests if an integer value is odd via modulo.</source>
        <target state="translated">모듈로를 통해 정수 값이 홀수인지 테스트합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NumberList1">
        <source>A list of 5 numbers.  More on lists later.</source>
        <target state="translated">5개 숫자 목록입니다. 추가 숫자는 나중에 표시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithoutPipes-Line1">
        <source>Given a list of integers, it filters out the even numbers,</source>
        <target state="translated">정수 목록인 경우 짝수를 필터링하고,</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithoutPipes-Line2">
        <source>squares the resulting odds, and adds 1 to the squared odds.</source>
        <target state="translated">결과 홀수를 제곱하고 제곱한 홀수에 1을 더합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line1">
        <source>A shorter way to write 'squareOddValuesAndAddOne' is to nest each</source>
        <target state="translated">'squareOddValuesAndAddOne'을 더 짧게 작성하려면</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line2">
        <source>sub-result into the function calls themselves.</source>
        <target state="translated">각 하위 결과를 함수 호출 자체에 중첩합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line3">
        <source>This makes the function much shorter, but it's difficult to see the</source>
        <target state="translated">그러면 함수가 더 짧아지지만 데이터가 처리되는 순서를</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line4">
        <source>order in which the data is processed.</source>
        <target state="translated">알아보기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line1">
        <source>A preferred way to write 'squareOddValuesAndAddOne' is to use F# pipe operators.</source>
        <target state="translated">'squareOddValuesAndAddOne'을 작성하려면 기본적으로 F# 파이프 연산자를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line2">
        <source>This allows you to avoid creating intermediate results, but is much more readable</source>
        <target state="translated">그러면 중간 결과를 생성하지 않아도 되며</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line3">
        <source>than nesting function calls like 'squareOddValuesAndAddOneNested'</source>
        <target state="translated">'squareOddValuesAndAddOneNested'와 같이 함수 호출을 중첩할 때보다 읽기도 쉽습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line1">
        <source>You can shorten 'squareOddValuesAndAddOnePipeline' by moving the second `List.map` call</source>
        <target state="translated">'squareOddValuesAndAddOnePipeline'을 줄이려면 두 번째 `List.map` 호출을</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line2">
        <source>into the first, using a Lambda Function.</source>
        <target state="translated">람다 함수를 사용하여 첫 번째로 이동합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line3">
        <source>Note that pipelines are also being used inside the lambda function.  F# pipe operators</source>
        <target state="translated">파이프라인은 람다 함수 내에도 사용됩니다. F# 파이프 연산자는</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line4">
        <source>can be used for single values as well.  This makes them very powerful for processing data.</source>
        <target state="translated">단일 값에도 사용할 수 있습니다. 따라서 데이터 처리에 매우 유용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line1">
        <source>Lastly, you can eliminate the need to explicitly take 'values' in as a parameter by using '&gt;&gt;'</source>
        <target state="translated">마지막으로 명시적으로 'values'를 매개 변수로 사용할 필요가 없습니다. '&gt;&gt;'를 사용하여</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line2">
        <source>to compose the two core operations: filtering out even numbers, then squaring and adding one.</source>
        <target state="translated">짝수를 필터링한 다음 제곱하고 1을 더하는 두 가지 핵심 작업을 작성하면 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line3">
        <source>Likewise, the 'fun x -&gt; ...' bit of the lambda expression is also not needed, because 'x' is simply</source>
        <target state="translated">마찬가지로 'fun x -&gt; ...' 람다 식도 필요하지 않습니다. 'x'를 해당 범위에서 간단히</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line4">
        <source>being defined in that scope so that it can be passed to a functional pipeline.  Thus, '&gt;&gt;' can be used</source>
        <target state="translated">정의하여 함수 파이프라인에 전달할 수 있기 때문입니다. 따라서 여기에서도 '&gt;&gt;'를</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line5">
        <source>there as well.</source>
        <target state="translated">사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line6">
        <source>The result of 'squareOddValuesAndAddOneComposition' is itself another function which takes a</source>
        <target state="translated">'squareOddValuesAndAddOneComposition'의 결과 자체도 정수 목록을 입력으로 사용하는</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line7">
        <source>list of integers as its input.  If you execute 'squareOddValuesAndAddOneComposition' with a list</source>
        <target state="translated">다른 함수입니다. 'squareOddValuesAndAddOneComposition'을 정수 목록을 사용하여</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line8">
        <source>of integers, you'll notice that it produces the same results as previous functions.</source>
        <target state="translated">실행하는 경우 이전 함수와 동일한 결과를 생성합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line9">
        <source>This is using what is known as function composition.  This is possible because functions in F#</source>
        <target state="translated">여기서는 이른바 함수 컴퍼지션을 사용합니다. 이것이 가능한 이유는 F#의 함수가</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line10">
        <source>use Partial Application and the input and output types of each data processing operation match</source>
        <target state="translated">부분 애플리케이션을 사용하고 각 데이터 처리 작업의 입력 및 출력 형식이 사용 중인 함수의</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line11">
        <source>the signatures of the functions we're using.</source>
        <target state="translated">시그니처와 일치하기 때문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line1">
        <source>Lists are ordered, immutable, singly-linked lists.  They are eager in their evaluation.</source>
        <target state="translated">순서가 지정되고 변경 불가능한 단일 연결 목록으로 즉시 평가됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line2">
        <source>This module shows various ways to generate lists and process lists with some functions</source>
        <target state="translated">이 모듈에서는 F# 주요 라이브러리의 'List' 모듈에 있는 일부 함수를 사용하여 목록을 생성하고</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line3">
        <source>in the 'List' module in the F# Core Library.</source>
        <target state="translated">목록을 처리하는 다양한 방법을 보여 줍니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/lists</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/lists</target>
        <note />
      </trans-unit>
      <trans-unit id="ListEmptyDefinition">
        <source>Lists are defined using [ ... ].  This is an empty list.</source>
        <target state="translated">목록은 [ ... ]을 사용하여 정의됩니다. 이것은 빈 목록입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListElementDefinition">
        <source>This is a list with 3 elements.  ';' is used to separate elements on the same line.</source>
        <target state="translated">3개 요소가 포함된 목록입니다. 동일한 줄에서 ';'을 사용하여 요소를 구분합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListNewlineElements">
        <source>You can also separate elements by placing them on their own lines.</source>
        <target state="translated">요소를 다른 줄에 배치하여 요소를 구분할 수도 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NumberList2">
        <source>This is a list of integers from 1 to 1000</source>
        <target state="translated">이것은 1에서 1000까지의 정수 리스트입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputation-Line1">
        <source>Lists can also be generated by computations. This is a list containing</source>
        <target state="translated">리스트는 계산에 의해서도 생성될 수 있습니다. 다음은</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputation-Line2">
        <source>all the days of the year.</source>
        <target state="translated">연중 모든 날짜를 포함하는 리스트입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintList2">
        <source>Print the first 5 elements of 'daysList' using 'List.take'.</source>
        <target state="translated">'daysList'의 처음 5개 요소를 'List.take'를 사용하여 인쇄합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputationConditional-Line1">
        <source>Computations can include conditionals.  This is a list containing the tuples</source>
        <target state="translated">계산은 조건을 포함할 수 있습니다. 다음은</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputationConditional-Line2">
        <source>which are the coordinates of the black squares on a chess board.</source>
        <target state="translated">체스 보드에서 검은색 칸의 좌표를 가리키는 튜플이 포함된 리스트입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line1">
        <source>Lists can be transformed using 'List.map' and other functional programming combinators.</source>
        <target state="translated">리스트는 'List.map' 및 기타 함수 프로그래밍 조합기를 사용하여 변환될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line2">
        <source>This definition produces a new list by squaring the numbers in numberList, using the pipeline</source>
        <target state="translated">이 정의는 인수를 List.map으로 전달하기 위해 파이프라인 연산자를 사용하여 numberList의 숫자를</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line3">
        <source>operator to pass an argument to List.map.</source>
        <target state="translated">제곱하여 새 리스트를 생성합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListFilter-Line1">
        <source>There are many other list combinations. The following computes the sum of the squares of the</source>
        <target state="translated">다른 리스트 조합이 많이 있습니다. 다음은</target>
        <note />
      </trans-unit>
      <trans-unit id="ListFilter-Line2">
        <source>numbers divisible by 3.</source>
        <target state="translated">3으로 나눠지는 수의 제곱의 합을 계산합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line1">
        <source>Arrays are fixed-size, mutable collections of elements of the same type.</source>
        <target state="translated">배열은 고정 크기이며 같은 형식의 요소로 구성된 변경 가능한 컬렉션입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line2">
        <source>Although they are similar to Lists (they support enumeration and have similar combinators for data processing),</source>
        <target state="translated">배열은 목록과 마찬가지로 열거형을 지원하고 데이터 처리를 위한 유사한 조합기를 사용하지만,</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line3">
        <source>they are generally faster and support fast random access.  This comes at the cost of being less safe by being mutable.</source>
        <target state="translated">배열은 일반적으로 더 빠르고 빠른 임의 액세스를 지원합니다. 변경이 가능하므로 덜 안전하다는 단점은 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/arrays</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/arrays</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyArray">
        <source>This is The empty array.  Note that the syntax is similar to that of Lists, but uses `[| ... |]` instead.</source>
        <target state="translated">빈 배열입니다. 목록의 구문과 유사하지만 `[| ... |]`을 대신 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayConstructionList">
        <source>Arrays are specified using the same range of constructs as lists.</source>
        <target state="translated">배열은 리스트와 같은 범위의 구문을 사용하여 지정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayConstructionRange">
        <source>This is an array of numbers from 1 to 1000.</source>
        <target state="translated">1에서 1000까지의 숫자 배열입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayComputationConstruction">
        <source>This is an array containing only the words "hello" and "world".</source>
        <target state="translated">"hello"와 "world"라는 단어만 포함된 배열입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayInit">
        <source>This is an array initialized by index and containing the even numbers from 0 to 2000.</source>
        <target state="translated">0에서 2000까지의 짝수가 포함되고 인덱스로 초기화된 배열입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArraySlicing">
        <source>Sub-arrays are extracted using slicing notation.</source>
        <target state="translated">하위 배열은 조각화 표기법을 사용하여 추출됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayLooping">
        <source>You can loop over arrays and lists using 'for' loops.</source>
        <target state="translated">'for' 루프를 사용하여 배열 및 목록을 반복할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayAssignment-Line1">
        <source>You can modify the contents of an an array element by using the left arrow assignment operator.</source>
        <target state="translated">왼쪽 화살표 대입 연산자를 사용하여 배열 요소의 내용을 수정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayAssignment-Line2">
        <source>To learn more about this operator, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/values/index#mutable-variables</source>
        <target state="translated">이 연산자에 대해 자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/values/index#mutable-variables</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayMap-Line1">
        <source>You can transform arrays using 'Array.map' and other functional programming operations.</source>
        <target state="translated">'Array'map' 및 기타 함수 프로그래밍 연산을 사용하여 배열을 변환할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayMap-Line2">
        <source>The following calculates the sum of the lengths of the words that start with 'h'.</source>
        <target state="translated">다음은 'h'로 시작하는 단어 길이의 합을 계산합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line1">
        <source>Sequences are a logical series of elements, all of the same type.  These are a more general type than Lists and Arrays.</source>
        <target state="translated">시퀀스는 모두 형식이 같은 요소가 논리적으로 연속되는 것입니다. 목록 및 배열보다 일반적인 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line2">
        <source>Sequences are evaluated on-demand and are re-evaluated each time they are iterated.</source>
        <target state="translated">시퀀스는 요청 시 계산되며 반복될 때마다 다시 계산됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line3">
        <source>An F# sequence is an alias for a .NET System.Collections.Generic.IEnumerable&lt;'T&gt;.</source>
        <target state="translated">F# 시퀀스는 .NET System.Collections.Generic.IEnumerable&lt;'T&gt;의 별칭입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line4">
        <source>Sequence processing functions can be applied to Lists and Arrays as well.</source>
        <target state="translated">시퀀스 처리 함수는 리스트와 배열 모두에 적용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line5">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/sequences</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/sequences</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptySequence">
        <source>This is the empty sequence.</source>
        <target state="translated">빈 시퀀스입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceOfValues">
        <source>This a sequence of values.</source>
        <target state="translated">시퀀스 값입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OnDemandSequence">
        <source>This is an on-demand sequence from 1 to 1000.</source>
        <target state="translated">1에서 1000까지의 요청 시 시퀀스입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceComposition">
        <source>This is a sequence producing the words "hello" and "world"</source>
        <target state="translated">"hello"와 "world"라는 단어를 생성하는 시퀀스입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceInit">
        <source>This sequence producing the even numbers up to 2000.</source>
        <target state="translated">2000까지의 짝수를 생성하는 시퀀스입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InfiniteSequence-Line1">
        <source>This is an infinite sequence which is a random walk.</source>
        <target state="translated">임의 행로인 무한 시퀀스입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InfiniteSequence-Line2">
        <source>This example uses yield! to return each element of a subsequence.</source>
        <target state="translated">이 예에서는 yield!를 사용하여 하위 시퀀스의 각 요소를 반환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequence100Elements">
        <source>This example shows the first 100 elements of the random walk.</source>
        <target state="translated">이 예에서는 임의 행로의 처음 100개 요소를 보여 줍니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line1">
        <source>Recursive functions can call themselves. In F#, functions are only recursive</source>
        <target state="translated">재귀 함수는 자신을 호출할 수 있습니다. F#에서 함수는</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line2">
        <source>when declared using 'let rec'.</source>
        <target state="translated">'let rec'을 사용하여 선언할 때에만 반복됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line3">
        <source>Recursion is the preferred way to process sequences or collections in F#.</source>
        <target state="translated">재귀는 F#에서 시퀀스 또는 컬렉션을 처리하는 기본 방법입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/index#recursive-functions</source>
        <target state="translated">자세히 알아보려면 https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/index#recursive-functions를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecFunDef-Line1">
        <source>This example shows a recursive function that computes the factorial of an</source>
        <target state="translated">이 예에서는 정수의 계승을 계산하는 재귀 함수를 보여 줍니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecRunDef-Line2">
        <source>integer. It uses 'let rec' to define a recursive function.</source>
        <target state="translated">'let rec'를 사용하여 재귀 함수를 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line1">
        <source>Computes the greatest common factor of two integers.</source>
        <target state="translated">두 정수의 최대 공약수를 계산합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line2">
        <source>Since all of the recursive calls are tail calls,</source>
        <target state="translated">모든 재귀 호출은 마무리 호출이므로,</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line3">
        <source>the compiler will turn the function into a loop,</source>
        <target state="translated">컴파일러에서는 함수를 루프로 전환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line4">
        <source>which improves performance and reduces memory consumption.</source>
        <target state="translated">루프는 성능을 향상시키고 메모리 소비량을 줄여 줍니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumList">
        <source>This example computes the sum of a list of integers using recursion.</source>
        <target state="translated">이 예제에서는 재귀를 사용하여 정수 목록의 합을 계산합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTail">
        <source>This makes 'sumList' tail recursive, using a helper function with a result accumulator.</source>
        <target state="translated">도우미 함수와 결과 누적기를 사용하여 'sumList'를 마무리 재귀 함수로 만듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTailInvoke-Line1">
        <source>This invokes the tail recursive helper function, providing '0' as a seed accumulator.</source>
        <target state="translated">'0'을 시드 누적기로 제공하여 마무리 재귀 도우미 함수를 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTailInvoke-Line2">
        <source>An approach like this is common in F#.</source>
        <target state="translated">F#에서 이와 같은 접근 방식이 일반적입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line1">
        <source>Records are an aggregate of named values, with optional members (such as methods).</source>
        <target state="translated">레코드는 명명된 값의 집계이며, 필요에 따라 메서드와 같은 선택적 멤버도 포함합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line2">
        <source>They are immutable and have structural equality semantics.</source>
        <target state="translated">레코드는 변경 불가능하며 구조적으로 같음 의미 체계가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/records</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/records</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordDefinition">
        <source>This example shows how to define a new record type.</source>
        <target state="translated">이 예에서는 새 레코드 형식을 정의하는 방법을 보여 줍니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordInstantiation1">
        <source>This example shows how to instantiate a record type.</source>
        <target state="translated">이 예제에서는 레코드 형식을 인스턴스화하는 방법을 보여 줍니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordInstantiation2">
        <source>You can also do this on the same line with ';' separators.</source>
        <target state="translated">동일한 줄에서 ';' 구분 기호를 사용하여 이 작업을 수행할 수도 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line1">
        <source>This example shows how to use "copy-and-update" on record values. It creates</source>
        <target state="translated">이 예에서는 레코드 값에 "copy-and-update"를 사용하는 방법을 보여 줍니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line2">
        <source>a new record value that is a copy of contact1, but has different values for</source>
        <target state="translated">contact1의 복사본인 새 레코드 값을 만들지만</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line3">
        <source>the 'Phone' and 'Verified' fields.</source>
        <target state="translated">'Phone'과 'Verified' 필드의 값이 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/copy-and-update-record-expressions</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/copy-and-update-record-expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="ProcessRecord-Line1">
        <source>This example shows how to write a function that processes a record value.</source>
        <target state="translated">이 예에서는 레코드 값을 처리하는 함수를 작성하는 방법을 보여 줍니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProcessRecord-Line2">
        <source>It converts a 'ContactCard' object to a string.</source>
        <target state="translated">'ContactCard' 개체를 문자열로 변환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordWithMember-Line1">
        <source>This is an example of a Record with a member.</source>
        <target state="translated">멤버가 하나인 레코드의 예제입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordWithMember-Line2">
        <source>Members can implement object-oriented members.</source>
        <target state="translated">멤버는 개체 지향 멤버를 구현할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordAccess">
        <source>Members are accessed via the '.' operator on an instantiated type.</source>
        <target state="translated">인스턴스화된 형식에서 '.' 연산자를 통해 멤버에 액세스합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line1">
        <source>Records can also be represented as structs via the 'Struct' attribute.</source>
        <target state="translated">'Struct' 특성을 통해 레코드를 구조체로 나타낼 수도 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line2">
        <source>This is helpful in situations where the performance of structs outweighs</source>
        <target state="translated">구조체 성능이 참조 형식의 유연성보다 중요한 경우에</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line3">
        <source>the flexibility of reference types.</source>
        <target state="translated">유용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line1">
        <source>Discriminated Unions (DU for short) are values which could be a number of named forms or cases.</source>
        <target state="translated">구분된 공용 구조체(줄여서 DU)는 여러 명명된 폼 또는 케이스일 수 있는 값입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line2">
        <source>Data stored in DUs can be one of several distinct values.</source>
        <target state="translated">DU에 저장된 데이터는 여러 고유한 값 중 하나일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions</target>
        <note />
      </trans-unit>
      <trans-unit id="CardSuit">
        <source>The following represents the suit of a playing card.</source>
        <target state="translated">다음은 플레인 카드의 짝패를 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardRank">
        <source>A Disciminated Union can also be used to represent the rank of a playing card.</source>
        <target state="translated">구분된 공용 구조체를 사용하여 플레잉 카드의 순위를 나타낼 수도 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardRankValue">
        <source>Represents the rank of cards 2 .. 10</source>
        <target state="translated">카드 2부터 10까지의 순위를 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardMember">
        <source>Discriminated Unions can also implement object-oriented members.</source>
        <target state="translated">구분된 공용 구조체는 개체 지향 멤버도 구현할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardType-Line1">
        <source>This is a record type that combines a Suit and a Rank.</source>
        <target state="translated">짝패와 순위를 조합하는 레코드 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardType-Line2">
        <source>It's common to use both Records and Disciminated Unions when representing data.</source>
        <target state="translated">일반적으로 레코드와 구분된 공용 구조체를 모두 사용하여 데이터를 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ComputeFullDeck">
        <source>This computes a list representing all the cards in the deck.</source>
        <target state="translated">데크에 있는 모든 카드를 나타내는 목록을 계산합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardToString">
        <source>This example converts a 'Card' object to a string.</source>
        <target state="translated">이 예에서는 'Card' 개체를 문자열로 변환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintAllCards">
        <source>This example prints all the cards in a playing deck.</source>
        <target state="translated">이 예에서는 플레잉 데크의 모든 카드를 인쇄합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line1">
        <source>Single-case DUs are often used for domain modeling.  This can buy you extra type safety</source>
        <target state="translated">단일 케이스 DU를 도메인 모델링에 사용하는 경우가 많습니다. 그러면 문자열 및 정수와 같은</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line2">
        <source>over primitive types such as strings and ints.</source>
        <target state="translated">기본 형식보다 형식 안전성을 추가로 얻을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line3">
        <source>Single-case DUs cannot be implicitly converted to or from the type they wrap.</source>
        <target state="translated">단일 케이스 DU를 래핑하는 형식으로 암시적으로 변환하거나 반대로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line4">
        <source>For example, a function which takes in an Address cannot accept a string as that input,</source>
        <target state="translated">예를 들어 주소에서 사용하는 함수는 문자열을 입력으로 사용할 수 없으며,</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line5">
        <source>or vive/versa.</source>
        <target state="translated">그 반대도 마찬가지입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateSingleCaseDu">
        <source>You can easily instantiate a single-case DU as follows.</source>
        <target state="translated">다음과 같이 단일 케이스 DU를 쉽게 인스턴스화할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnwrapSingleCaseDu">
        <source>When you need the value, you can unwrap the underlying value with a simple function.</source>
        <target state="translated">값이 필요하면 간단한 함수로 내부 값을 래핑 해제할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintSingleCaseDu">
        <source>Printing single-case DUs is simple with unwrapping functions.</source>
        <target state="translated">래핑 해제 함수로 단일 케이스 DU를 간단히 인쇄할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line1">
        <source>Disciminated Unions also support recursive definitions.</source>
        <target state="translated">구분된 공용 구조체는 재귀 정의도 지원합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line2">
        <source>This represents a Binary Search Tree, with one case being the Empty tree,</source>
        <target state="translated">이진 검색 트리를 나타냅니다. 여기서 한 케이스는 빈 트리이고</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line3">
        <source>and the other being a Node with a value and two subtrees.</source>
        <target state="translated">다른 케이스는 값과 두 개의 하위 트리를 포함하는 노드입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SearchBinaryTree-Line1">
        <source>Check if an item exists in the binary search tree.</source>
        <target state="translated">이진 검색 트리에 항목이 있는지 확인합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SearchBinaryTree-Line2">
        <source>Searches recursively using Pattern Matching.  Returns true if it exists; otherwise, false.</source>
        <target state="translated">패턴 일치를 사용하여 재귀적으로 검색합니다. 있으면 true를 반환하고 그렇지 않은 경우 false를 반환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CheckLeftSubtree">
        <source>Check the left subtree.</source>
        <target state="translated">왼쪽 하위 트리를 확인합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CheckRightSubtree">
        <source>Check the right subtree.</source>
        <target state="translated">오른쪽 하위 트리를 확인합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line1">
        <source>Inserts an item in the Binary Search Tree.</source>
        <target state="translated">이진 검색 트리에 항목을 삽입합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line2">
        <source>Finds the place to insert recursively using Pattern Matching, then inserts a new node.</source>
        <target state="translated">패턴 일치를 사용하여 재귀적으로 삽입할 위치를 찾은 다음 새 노드를 삽입합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line3">
        <source>If the item is already present, it does not insert anything.</source>
        <target state="translated">항목이 이미 있으면 아무 항목도 삽입하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line4">
        <source>No need to insert, it already exists; return the node.</source>
        <target state="translated">이미 항목이 있으므로 삽입할 필요가 없습니다. 노드를 반환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line5">
        <source>Call into left subtree.</source>
        <target state="translated">왼쪽 하위 트리를 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line6">
        <source>Call into right subtree.</source>
        <target state="translated">오른쪽 하위 트리를 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line1">
        <source>Discriminated Unions can also be represented as structs via the 'Struct' attribute.</source>
        <target state="translated">'Struct' 특성을 통해 구분된 공용 구조체를 구조체로 나타낼 수도 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line2">
        <source>This is helpful in situations where the performance of structs outweighs</source>
        <target state="translated">구조체 성능이 참조 형식의 유연성보다 중요한 경우에</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line3">
        <source>the flexibility of reference types.</source>
        <target state="translated">유용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line4">
        <source>However, there are two important things to know when doing this:</source>
        <target state="translated">하지만 이 작업을 수행할 때는 다음 두 가지 중요한 사항을 알고 있어야 합니다:</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line5">
        <source>1. A struct DU cannot be recursively-defined.</source>
        <target state="translated">1. 구조체 DU는 재귀적으로 정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line6">
        <source>2. A struct DU must have unique names for each of its cases.</source>
        <target state="translated">2. 각 케이스마다 구조체 DU의 이름이 고유해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line1">
        <source>Pattern Matching is a feature of F# that allows you to utilize Patterns,</source>
        <target state="translated">패턴 일치는 패턴을 활용할 수 있는 F#의 기능이며,</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line2">
        <source>which are a way to compare data with a logical structure or structures,</source>
        <target state="translated">패턴을 사용하면 데이터를 논리 구조와 비교하거나,</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line3">
        <source>decompose data into constituent parts, or extract information from data in various ways.</source>
        <target state="translated">데이터를 구성 부분으로 분해하거나, 다양한 방법으로 데이터에서 정보를 추출할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line4">
        <source>You can then dispatch on the "shape" of a pattern via Pattern Matching.</source>
        <target state="translated">그런 다음 패턴 일치를 사용하여 패턴의 "모양"을 디스패치할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line5">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/pattern-matching</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/pattern-matching</target>
        <note />
      </trans-unit>
      <trans-unit id="PersonRecord">
        <source>A record for a person's first and last name</source>
        <target state="translated">사람의 성과 이름에 대한 레코드입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EmployeeDu">
        <source>A Discriminated Union of 3 different kinds of employees</source>
        <target state="translated">세 가지 다른 직원 유형이 있는 구분된 공용 구조체</target>
        <note />
      </trans-unit>
      <trans-unit id="CountEmployees-Line1">
        <source>Count everyone underneath the employee in the management hierarchy,</source>
        <target state="translated">관리 계층 구조에서 이 직원을 포함하여 이 아래에 있는 모든 직원의 수를</target>
        <note />
      </trans-unit>
      <trans-unit id="CountEmployees-Line2">
        <source>including the employee.</source>
        <target state="translated">셉니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FindDave-Line1">
        <source>Find all managers/executives named "Dave" who do not have any reports.</source>
        <target state="translated">이름이 "Dave"이고 부하직원이 없는 모든 관리자/간부를 찾습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FindDave-Line2">
        <source>This uses the 'function' shorthand to as a lambda expression.</source>
        <target state="translated">여기서는 'function' 약어를 람다 식으로 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchEmptyList">
        <source>[] matches an empty list.</source>
        <target state="translated">[]는 빈 목록과 일치합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchWildcard-Line1">
        <source>'_' is a wildcard pattern that matches anything.</source>
        <target state="translated">'_'는 모든 항목과 일치하는 와일드카드 패턴입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchWildCard-Line2">
        <source>This handles the "or else" case.</source>
        <target state="translated">이 와일드카드 패턴은 "or else" 케이스를 처리합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchShorthand-Line1">
        <source>You can also use the shorthand function construct for pattern matching,</source>
        <target state="translated">패턴 일치에 약어 형식 함수 구문을 사용할 수도 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchShorthand-Line2">
        <source>which is useful when you're writing functions which make use of Partial Application.</source>
        <target state="translated">이 구문은 부분 애플리케이션을 사용하는 함수를 작성할 때 유용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParseHelpers">
        <source>Define some more functions which parse with the helper function.</source>
        <target state="translated">도우미 함수를 사용하여 구문 분석하는 함수를 더 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line1">
        <source>Active Patterns are another powerful construct to use with pattern matching.</source>
        <target state="translated">활성 패턴은 패턴 일치와 함께 사용하면 유용한 다른 구문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line2">
        <source>They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</source>
        <target state="translated">활성 패턴을 사용하면 입력 데이터를 사용자 지정 폼으로 분할하고, 패턴 일치 호출 사이트에서 이 폼을 분해할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/active-patterns</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/active-patterns</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchActivePattern">
        <source>Pattern Matching via 'function' keyword and Active Patterns often looks like this.</source>
        <target state="translated">'function' 키워드 및 활성 패턴을 통한 패턴 일치는 이처럼 보이는 경우가 많습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintParse">
        <source>Call the printer with some different values to parse.</source>
        <target state="translated">구문 분석할 다른 값을 사용하여 프린터를 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line1">
        <source>Option values are any kind of value tagged with either 'Some' or 'None'.</source>
        <target state="translated">옵션 값에는 'Some' 또는 'None'으로 태그 처리된 모든 종류의 값을 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line2">
        <source>They are used extensively in F# code to represent the cases where many other</source>
        <target state="translated">F# 코드에서 광범위하게 사용되어 다른 언어에서는 null 참조를 사용하는 케이스를</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line3">
        <source>languages would use null references.</source>
        <target state="translated">나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line4">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/options</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/options</target>
        <note />
      </trans-unit>
      <trans-unit id="ZipCode">
        <source>First, define a zipcode defined via Single-case Discriminated Union.</source>
        <target state="translated">먼저 단일 케이스 구분된 공용 구조체를 통해 정의된 우편 번호를 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Customer">
        <source>Next, define a type where the ZipCode is optional.</source>
        <target state="translated">다음으로 ZipCode가 선택 사항인 형식을 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ShippingCalculator-Line1">
        <source>Next, define an interface type that represents an object to compute the shipping zone for the customer's zip code,</source>
        <target state="translated">그리고 고객의 우편 번호에 대한 배송 영역을 계산하기 위해 개체를 나타내는 인터페이스 형식을 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ShippingCalculator-Line2">
        <source>given implementations for the 'getState' and 'getShippingZone' abstract methods.</source>
        <target state="translated">고객의 우편 번호에 대한 쇼핑 지역을 계산하는 추상 클래스입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line1">
        <source>Next, calculate a shipping zone for a customer using a calculator instance.</source>
        <target state="translated">다음으로 계산기 인스턴스를 사용하여 고객의 배송 영역을 계산합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line2">
        <source>This uses combinators in the Option module to allow a functional pipeline for</source>
        <target state="translated">여기서는 Option 모듈 내의 조합기를 사용하여 함수 파이프라인에서</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line3">
        <source>transforming data with Optionals.</source>
        <target state="translated">Optionals를 통해 데이터를 변환할 수 있게 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line1">
        <source>Units of measure are a way to annotate primitive numeric types in a type-safe way.</source>
        <target state="translated">측정 단위를 사용하면 형식이 안전한 방식으로 기본 숫자 형식에 주석을 달 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line2">
        <source>You can then perform type-safe arithmetic on these values.</source>
        <target state="translated">그런 다음 이러한 값에 대해 형식이 안전한 산술 연산을 수행할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/units-of-measure</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/units-of-measure</target>
        <note />
      </trans-unit>
      <trans-unit id="CommonUnits">
        <source>First, open a collection of common unit names</source>
        <target state="translated">먼저 일반적인 단위 이름의 컬렉션을 엽니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineUnitConstant">
        <source>Define a unitized constant</source>
        <target state="translated">결합된 상수 정의</target>
        <note />
      </trans-unit>
      <trans-unit id="MileUnit">
        <source>Next, define a new unit type</source>
        <target state="translated">다음으로 새 단위 형식을 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MileToMeter">
        <source>Conversion factor mile to meter.</source>
        <target state="translated">마일 대 미터 변환 비율입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineMileConstant">
        <source>Define a unitized constant</source>
        <target state="translated">결합된 상수 정의</target>
        <note />
      </trans-unit>
      <trans-unit id="ComputeMileToMeter">
        <source>Compute  metric-system constant</source>
        <target state="translated">미터 단위 상수를 계산합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintUnitsOfMeasure">
        <source>Values using Units of Measure can be used just like the primitive numeric type for things like printing.</source>
        <target state="translated">측정 단위를 사용하는 값은 인쇄와 같은 작업에 기본 숫자 형식처럼 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line1">
        <source>Classes are a way of defining new object types in F#, and support standard Object-oriented constructs.</source>
        <target state="translated">클래스는 F#에서 새 개체 형식을 정의하는 방법이며 표준 개체 지향 구문을 지원합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line2">
        <source>They can have a variety of members (methods, properties, events, etc.)</source>
        <target state="translated">클래스는 다양한 멤버(메서드, 속성, 이벤트 등)를 포함할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line3">
        <source>To learn more about Classes, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/classes</source>
        <target state="translated">클래스에 대해 자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/classes</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line4">
        <source>To learn more about Members, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members</source>
        <target state="translated">멤버에 대해 자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line1">
        <source>A simple two-dimensional Vector class.</source>
        <target state="translated">단순한 2차원 벡터 클래스입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line2">
        <source>The class's constructor is on the first line,</source>
        <target state="translated">클래스의 생성자는 첫 줄에 있고,</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line3">
        <source>and takes two arguments: dx and dy, both of type 'double'.</source>
        <target state="translated">'double' 형식의 두 인수 dx 및 dy를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInternalField-Line1">
        <source>This internal field stores the length of the vector, computed when the</source>
        <target state="translated">이 내부 필드는 개체가 생성될 때 계산된 벡터 길이를</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInternalField-Line2">
        <source>object is constructed</source>
        <target state="translated">저장합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisKeyword-Line1">
        <source>'this' specifies a name for the object's self identifier.</source>
        <target state="translated">'this'는 개체 자체의 식별자에 대한 이름을 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisKeyword-Line2">
        <source>In instance methods, it must appear before the member name.</source>
        <target state="translated">인스턴스 메서드에서는 멤버 이름 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MemberMethod">
        <source>This member is a method.  The previous members were properties.</source>
        <target state="translated">이 멤버는 메서드입니다. 이전 멤버는 속성이었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateClass">
        <source>This is how you instantiate the Vector2D class.</source>
        <target state="translated">Vector2D 클래스를 인스턴스화하는 방법은 다음과 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ScaledVector">
        <source>Get a new scaled vector object, without modifying the original object.</source>
        <target state="translated">원래 개체를 수정하지 않고 비율이 조정된 새 벡터 개체를 가져옵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line1">
        <source>Generic classes allow types to be defined with respect to a set of type parameters.</source>
        <target state="translated">제네릭 클래스를 통해 형식 매개변수 집합에 대해 형식을 정의할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line2">
        <source>In the following, 'T is the type parameter for the class.</source>
        <target state="translated">다음에서 'T는 클래스의 형식 매개 변수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalField">
        <source>This internal field store the states in a list.</source>
        <target state="translated">이 내부 필드는 목록에 상태를 저장합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddElement">
        <source>Add a new element to the list of states.</source>
        <target state="translated">상태 리스트에 새 요소를 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment">
        <source>use the '&lt;-' operator to mutate the value.</source>
        <target state="translated">'&lt;-' 연산자를 사용하여 값을 변경합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="History">
        <source>Get the entire list of historical states.</source>
        <target state="translated">기록 상태의 전체 목록을 가져옵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Current">
        <source>Get the latest state.</source>
        <target state="translated">최신 상태를 가져옵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InferredTypeParameter">
        <source>An 'int' instance of the state tracker class. Note that the type parameter is inferred.</source>
        <target state="translated">상태 추적기 클래스의 'int' 인스턴스입니다. 형식 매개 변수는 유추됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddState">
        <source>Add a state</source>
        <target state="translated">상태를 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line1">
        <source>Interfaces are object types with only 'abstract' members.</source>
        <target state="translated">인터페이스는 '추상' 멤버만 있는 개체 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line2">
        <source>Object types and object expressions can implement interfaces.</source>
        <target state="translated">개체 형식 및 개체 식은 인터페이스를 구현할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line3">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/interfaces</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposable">
        <source>This is a type that implements IDisposable.</source>
        <target state="translated">IDisposable를 구현하는 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableImplementation">
        <source>This is the implementation of IDisposable members.</source>
        <target state="translated">IDisposable 멤버의 구현입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line1">
        <source>This is an object that implements IDisposable via an Object Expression</source>
        <target state="translated">개체 식을 통해 IDisposable을 구현하는 개체입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line2">
        <source>Unlike other languages such as C# or Java, a new type definition is not needed</source>
        <target state="translated">C# 또는 Java와 같은 다른 언어와 달리 인터페이스를 구현하기 위해 새 형식 정의가</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line3">
        <source>to implement an interface.</source>
        <target state="translated">필요하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line1">
        <source>The FSharp.Core library defines a range of parallel processing functions.  Here</source>
        <target state="translated">FSharp.Core 라이브러리는 병렬 처리 함수 범위를 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line2">
        <source>you use some functions for parallel processing over arrays.</source>
        <target state="translated">여기에서 배열에 대해 병렬 처리 함수를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line3">
        <source>To learn more, see: https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/array.parallel-module-%5Bfsharp%5D</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/array.parallel-module-%5Bfsharp%5D</target>
        <note />
      </trans-unit>
      <trans-unit id="InputArray">
        <source>First, an array of inputs.</source>
        <target state="translated">먼저 입력 배열입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpensiveFunction">
        <source>Next, define a functions that does some CPU intensive computation.</source>
        <target state="translated">다음으로 CPU를 많이 사용하는 계산을 수행하는 함수를 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParallelMap">
        <source>Next, do a parallel map over a large input array.</source>
        <target state="translated">다음으로 큰 입력 배열에 대해 병렬 맵을 수행합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintParallel">
        <source>Next, print the results.</source>
        <target state="translated">다음으로 결과를 인쇄합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Events-Line1">
        <source>Events are a common idiom for .NET programming, especially with WinForms or WPF applications.</source>
        <target state="translated">이벤트는 특히 WinForms 또는 WPF 애플리케이션을 사용하는 .NET 프로그래밍에서 일반적으로 사용되는 말입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Events-Line2">
        <source>To learn more, see: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/events</source>
        <target state="translated">자세히 알아보려면 다음을 참조하세요. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/events</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleEvent">
        <source>First, create instance of Event object that consists of subscription point (event.Publish) and event trigger (event.Trigger).</source>
        <target state="translated">먼저 구독 지점(event.Publish)과 이벤트 트리거(event.Trigger)로 구성된 Event 개체의 인스턴스를 만듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddEventHandler1">
        <source>Next, add handler to the event.</source>
        <target state="translated">다음으로 이벤트에 처리기를 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TriggerEvent">
        <source>Next, trigger the event.</source>
        <target state="translated">다음으로 이벤트를 트리거합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EventWithArgs">
        <source>Next, create an instance of Event that follows standard .NET convention: (sender, EventArgs).</source>
        <target state="translated">다음으로 표준 .NET 규칙(sender, EventArgs)을 따르는 Event의 인스턴스를 만듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddEventHandler2">
        <source>Next, add a handler for this new event.</source>
        <target state="translated">다음으로 이 새 이벤트에 대한 처리기를 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TriggerEventWithArgs">
        <source>Next, trigger this event (note that sender argument should be set).</source>
        <target state="translated">다음으로 이 이벤트를 트리거합니다(sender 인수를 설정해야 함).</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>