<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="fr" original="../Tutorial.fsx">
    <body>
      <trans-unit id="SampleHeader">
        <source>This sample will guide you through elements of the F# language.</source>
        <target state="translated">Cet exemple est destiné à vous montrer les différents éléments du langage F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="Instructions-Line1">
        <source>To execute the code in F# Interactive, highlight a section of code and press Alt-Enter or right-click</source>
        <target state="translated">Pour exécuter le code dans F# Interactive, mettez en surbrillance une portion du code, puis appuyez sur Alt+Entrée ou cliquez avec le bouton droit,</target>
        <note />
      </trans-unit>
      <trans-unit id="Instructions-Line2">
        <source>and select "Execute in Interactive".  You can open the F# Interactive Window from the "View" menu.</source>
        <target state="translated">puis sélectionnez Exécuter en mode interactif.  Pour ouvrir la fenêtre F# Interactive, accédez au menu Affichage.</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreAbout">
        <source>For more about F#, see:</source>
        <target state="translated">Pour en savoir plus sur F#, consultez :</target>
        <note />
      </trans-unit>
      <trans-unit id="LearnMoreAbout">
        <source>To learn more about applied F# programming, use</source>
        <target state="translated">Pour en savoir plus sur la programmation F# appliquée, utilisez</target>
        <note />
      </trans-unit>
      <trans-unit id="SeeDocumentation">
        <source>To see this tutorial in documentation form, see:</source>
        <target state="new">To see this tutorial in documentation form, see:</target>
        <note />
      </trans-unit>
      <trans-unit id="ToInstall-Line1">
        <source>To install the Visual F# Power Tools, use</source>
        <target state="translated">Pour installer Visual F# Power Tools, utilisez</target>
        <note />
      </trans-unit>
      <trans-unit id="ToInstall-Line2">
        <source>'Tools' --&gt; 'Extensions and Updates' --&gt; `Online` and search</source>
        <target state="translated">'Outils' --&gt; 'Extensions et mises à jour' --&gt; `En ligne` et rechercher</target>
        <note />
      </trans-unit>
      <trans-unit id="AdditionalTemplates-Line1">
        <source>For additional templates to use with F#, see the 'Online Templates' in Visual Studio,</source>
        <target state="translated">Pour consulter d'autres modèles d'utilisation du langage F#, cliquez sur Modèles en ligne dans Visual Studio,</target>
        <note />
      </trans-unit>
      <trans-unit id="AdditionalTemplates-Line2">
        <source>'New Project' --&gt; 'Online Templates'</source>
        <target state="translated">'Nouveau projet' --&gt; 'Modèles en ligne'</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportsComments">
        <source>F# supports three kinds of comments:</source>
        <target state="translated">F# prend en charge trois genres de commentaires :</target>
        <note />
      </trans-unit>
      <trans-unit id="DoubleSlash">
        <source>1. Double-slash comments.  These are used in most situations.</source>
        <target state="translated">1. Commentaires avec double barre oblique (utilisés dans la plupart des cas).</target>
        <note />
      </trans-unit>
      <trans-unit id="MLStyle">
        <source>2. ML-style Block comments.  These aren't used that often.</source>
        <target state="translated">2. Commentaires de bloc de style ML (rarement utilisés).</target>
        <note />
      </trans-unit>
      <trans-unit id="TripleSlash-Line1">
        <source>3. Triple-slash comments.  These are used for documenting functions, types, and so on.</source>
        <target state="translated">3. Commentaires avec triple barre oblique (utilisés pour documenter les fonctions, les types, etc.).</target>
        <note />
      </trans-unit>
      <trans-unit id="TripleSlash-Line2">
        <source>They will appear as text when you hover over something which is decorated with these comments.</source>
        <target state="translated">Ils apparaissent sous forme de texte quand vous pointez sur un élément décoré avec ces commentaires.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line1">
        <source>They also support .NET-style XML comments, which allow you to generate reference documentation,</source>
        <target state="translated">Ils prennent également en charge les commentaires XML de style .NET, ce qui vous permet de générer une documentation de référence.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line2">
        <source>and they also allow editors (such as Visual Studio) to extract information from them.</source>
        <target state="translated">Les éditeurs tels que Visual Studio peuvent également extraire des informations à partir de ces commentaires.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlComments-Line3">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/xml-documentation</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/xml-documentation</target>
        <note />
      </trans-unit>
      <trans-unit id="OpenNamespaces">
        <source>Open namespaces using the 'open' keyword.</source>
        <target state="translated">Ouvrir des espaces de noms à l'aide du mot clé 'open'.</target>
        <note />
      </trans-unit>
      <trans-unit id="LearnMore">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/import-declarations-the-open-keyword</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/import-declarations-the-open-keyword</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line1">
        <source>A module is a grouping of F# code, such as values, types, and function values.</source>
        <target state="translated">Un module est un regroupement d’éléments de code F#, comme des valeurs, des types et des valeurs de fonction.</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line2">
        <source>Grouping code in modules helps keep related code together and helps avoid name conflicts in your program.</source>
        <target state="translated">Le regroupement du code dans les modules permet de conserver le code associé ensemble et d'éviter les conflits de noms dans votre programme.</target>
        <note />
      </trans-unit>
      <trans-unit id="Module-Line3">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/modules</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/modules</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleInt">
        <source>This is a sample integer.</source>
        <target state="translated">Exemple d'entier.</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleFloat">
        <source>This is a sample floating point number.</source>
        <target state="translated">Exemple de nombre à virgule flottante.</target>
        <note />
      </trans-unit>
      <trans-unit id="Computed-Line1">
        <source>This computed a new number by some arithmetic.  Numeric types are converted using</source>
        <target state="translated">Nouveau nombre calculé par une opération arithmétique. Les types numériques sont convertis à l'aide des</target>
        <note />
      </trans-unit>
      <trans-unit id="Computed-Line2">
        <source>functions 'int', 'double' and so on.</source>
        <target state="translated">fonctions 'int', 'double', etc.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListNumbers">
        <source>This is a list of the numbers from 0 to 99.</source>
        <target state="translated">Liste des nombres de 0 à 99.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListSquares">
        <source>This is a list of all tuples containing all the numbers from 0 to 99 and their squares.</source>
        <target state="translated">Liste de tous les tuples contenant tous les nombres de 0 à 99 et leur carré.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintList1">
        <source>The next line prints a list that includes tuples, using '%A' for generic printing.</source>
        <target state="translated">La ligne suivante imprime une liste comprenant des tuples, en utilisant '%A' pour l'impression générique.</target>
        <note />
      </trans-unit>
      <trans-unit id="SampleIntType">
        <source>This is a sample integer with a type annotation</source>
        <target state="translated">Exemple d'entier avec une annotation de type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line1">
        <source>Values in F# are immutable by default.  They cannot be changed</source>
        <target state="translated">Les valeurs en F# sont immuables par défaut. Elles ne peuvent pas être changées</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line2">
        <source>in the course of a program's execution unless explicitly marked as mutable.</source>
        <target state="translated">durant l'exécution d'un programme, sauf si elles sont explicitement marquées comme mutables.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValuesImmutable-Line3">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/values/index#why-immutable</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/values/index#why-immutable</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line1">
        <source>Binding a value to a name via 'let' makes it immutable.</source>
        <target state="translated">Le fait de lier une valeur à un nom au moyen de 'let' la rend non modifiable.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line2">
        <source>The second line of code fails to compile because 'number' is immutable and bound.</source>
        <target state="translated">La compilation de la deuxième ligne de code échoue, car 'number' est non modifiable et lié.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetKeyword-Line3">
        <source>Re-defining 'number' to be a different value is not allowed in F#.</source>
        <target state="translated">La redéfinition de 'number' en une valeur différente n'est pas autorisée dans F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableKeyword">
        <source>A mutable binding.  This is required to be able to mutate the value of 'otherNumber'.</source>
        <target state="translated">Liaison mutable. Obligatoire pour muter la valeur de 'otherNumber'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line1">
        <source>When mutating a value, use '&lt;-' to assign a new value.</source>
        <target state="translated">En cas de mutation d'une valeur, utilisez '&lt;-' pour assigner une nouvelle valeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line2">
        <source>You could not use '=' here for this purpose since it is used for equality</source>
        <target state="translated">Vous ne pouvez pas utiliser '=' ici à cet effet, car il est utilisé pour l'égalité</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment-Line3">
        <source>or other contexts such as 'let' or 'module'</source>
        <target state="translated">ou autres contextes tels que 'let' ou 'module'</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line1">
        <source>Much of F# programming consists of defining functions that transform input data to produce</source>
        <target state="translated">La programmation F# consiste en grande partie à définir des fonctions qui transforment des données d'entrée pour produire des</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line2">
        <source>useful results.</source>
        <target state="translated">résultats utiles.</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionsModule-Line3">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/functions/</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/functions/</target>
        <note />
      </trans-unit>
      <trans-unit id="LetFunction-Line1">
        <source>You use 'let' to define a function. This one accepts an integer argument and returns an integer.</source>
        <target state="translated">Utilisez 'let' pour définir une fonction. Celle-ci accepte un argument entier et retourne un entier.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetFunction-Line2">
        <source>Parentheses are optional for function arguments, except for when you use an explicit type annotation.</source>
        <target state="translated">Les parenthèses sont facultatives pour les arguments de fonction, sauf quand vous utilisez une annotation de type explicite.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyFunction-Line1">
        <source>Apply the function, naming the function return result using 'let'.</source>
        <target state="translated">Appliquez la fonction, en nommant le résultat de retour de la fonction à l'aide de 'let'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyFunction-Line2">
        <source>The variable type is inferred from the function return type.</source>
        <target state="translated">Le type de variable est déduit du type de retour de la fonction.</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line1">
        <source>This line uses '%d' to print the result as an integer. This is type-safe.</source>
        <target state="translated">Cette ligne utilise '%d' pour imprimer le résultat comme entier. Cette opération est de type sécurisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line2">
        <source>If 'result1' were not of type 'int', then the line would fail to compile.</source>
        <target state="translated">Si 'result1' n'est pas de type 'int', la compilation de la ligne échoue.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeAnnotation">
        <source>When needed, annotate the type of a parameter name using '(argument:type)'.  Parentheses are required.</source>
        <target state="translated">Si nécessaire, annotez le type d'un nom de paramètre en utilisant '(argument:type)'. Les parenthèses sont obligatoires.</target>
        <note />
      </trans-unit>
      <trans-unit id="Conditionals-Line1">
        <source>Conditionals use if/then/elid/elif/else.</source>
        <target state="translated">Les conditions utilisent if/then/elid/elif/else.</target>
        <note />
      </trans-unit>
      <trans-unit id="Conditionals-Line2">
        <source>Note that F# uses whitespace indentation-aware syntax, similar to languages like Python.</source>
        <target state="translated">Notez que F# utilise une syntaxe prenant en charge la mise en retrait à l'aide d'espaces, comme Python.</target>
        <note />
      </trans-unit>
      <trans-unit id="printf-Line3">
        <source>This line uses '%f' to print the result as a float.  As with '%d' above, this is type-safe.</source>
        <target state="translated">Cette ligne utilise '%f' pour imprimer le résultat comme float. Comme '%d' ci-dessus, cette opération est de type sécurisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line1">
        <source>Booleans are fundamental data types in F#.  Here are some examples of Booleans and conditional logic.</source>
        <target state="translated">Les booléens sont des types de données fondamentaux en F#. Voici quelques exemples illustrant des booléens et la logique conditionnelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line2">
        <source>To learn more, see:</source>
        <target state="translated">Pour en savoir plus, consultez :</target>
        <note />
      </trans-unit>
      <trans-unit id="Booleans-Line3">
        <source>and</source>
        <target state="translated">Et</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanValues">
        <source>Booleans values are 'true' and 'false'.</source>
        <target state="translated">Les valeurs booléennes sont 'true' et 'false'.</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanOperators">
        <source>Operators on booleans are 'not', '&amp;&amp;' and '||'.</source>
        <target state="translated">Les opérateurs sur les booléens sont 'not', '&amp;&amp;' et '||'.</target>
        <note />
      </trans-unit>
      <trans-unit id="BooleanPrintf">
        <source>This line uses '%b'to print a boolean value.  This is type-safe.</source>
        <target state="translated">Cette ligne utilise '%b' pour imprimer une valeur booléenne. Cette opération est de type sécurisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="Strings-Line1">
        <source>Strings are fundamental data types in F#.  Here are some examples of Strings and basic String manipulation.</source>
        <target state="translated">Les chaînes sont des types de données fondamentaux en F#. Voici quelques exemples illustrant des chaînes et la manipulation de chaînes de base.</target>
        <note />
      </trans-unit>
      <trans-unit id="Strings-Line2">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/strings</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/strings</target>
        <note />
      </trans-unit>
      <trans-unit id="StringQuotes">
        <source>Strings use double quotes.</source>
        <target state="translated">Les chaînes utilisent des guillemets doubles.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringLiterals-Line1">
        <source>Strings can also use @ to create a verbatim string literal.</source>
        <target state="translated">Les chaînes peuvent également utiliser @ pour créer un littéral de chaîne textuelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringLiterals-Line2">
        <source>This will ignore escape characters such as '\', '\n', '\t', etc.</source>
        <target state="translated">Les caractères d'échappement tels que '\', '\n', '\t', etc. sont ainsi ignorés.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringTripleQuotes">
        <source>String literals can also use triple-quotes.</source>
        <target state="translated">Les littéraux de chaîne peuvent également utiliser des guillemets triples.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringConcatenation">
        <source>String concatenation is normally done with the '+' operator.</source>
        <target state="translated">L'opérateur '+' est généralement utilisé pour la concaténation de chaînes.</target>
        <note />
      </trans-unit>
      <trans-unit id="StringPrinting">
        <source>This line uses '%s' to print a string value.  This is type-safe.</source>
        <target state="translated">Cette ligne utilise '%s' pour imprimer une valeur de chaîne. Cette opération est de type sécurisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="Substrings-Line1">
        <source>Substrings use the indexer notation.  This line extracts the first 7 characters as a substring.</source>
        <target state="translated">Les sous-chaînes utilisent la notation de l'indexeur. Cette ligne extrait les 7 premiers caractères comme sous-chaîne.</target>
        <note />
      </trans-unit>
      <trans-unit id="Substrings-Line2">
        <source>Note that like many languages, Strings are zero-indexed in F#.</source>
        <target state="translated">Comme dans bien d'autres langages, les chaînes ont un index de base zéro en F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="Tuples-Line1">
        <source>Tuples are simple combinations of data values into a combined value.</source>
        <target state="translated">Les tuples sont des combinaisons simples de valeurs de données formant une valeur combinée.</target>
        <note />
      </trans-unit>
      <trans-unit id="Tuples-Line2">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/tuples</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/tuples</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleInteger">
        <source>A simple tuple of integers.</source>
        <target state="translated">Tuple simple d'entiers.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line1">
        <source>A function that swaps the order of two values in a tuple.</source>
        <target state="translated">Fonction qui inverse l'ordre de deux valeurs d'un tuple.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line2">
        <source>F# Type Inference will automatically generalize the function to have a generic type,</source>
        <target state="translated">L'inférence de type F# généralise automatiquement la fonction pour qu'elle soit de type générique,</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleFunction-Line3">
        <source>meaning that it will work with any type.</source>
        <target state="translated">ce qui signifie qu'elle peut fonctionner avec n'importe quel type.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleMultiType-Line1">
        <source>A tuple consisting of an integer, a string,</source>
        <target state="translated">Tuple constitué d'un entier, d'une chaîne</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleMultiType-Line2">
        <source>and a double-precision floating point number.</source>
        <target state="translated">et d'un nombre à virgule flottante à double précision.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleTypeAnnotation-Line1">
        <source>A simple tuple of integers with a type annotation.</source>
        <target state="translated">Tuple simple d'entiers avec une annotation de type.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleTypeAnnotation-Line2">
        <source>Type annotations for tuples use the * symbol to separate elements</source>
        <target state="translated">Annotations de type pour les tuples qui utilisent le symbole * afin de séparer les éléments</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line1">
        <source>Tuples are normally objects, but they can also be represented as structs.</source>
        <target state="translated">Les tuples sont généralement des objets, mais peuvent aussi être représentés sous forme de structs.</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line2">
        <source>These interoperate completely with structs in C# and Visual Basic.NET; however,</source>
        <target state="translated">Ils interagissent entièrement avec les structs en C# et Visual Basic .NET ; cependant,</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line3">
        <source>struct tuples are not implicitly convertable with object tuples (often called reference tuples).</source>
        <target state="translated">les tuples de type struct ne sont pas implicitement convertibles avec des tuples d'objet (souvent appelés tuples de référence).</target>
        <note />
      </trans-unit>
      <trans-unit id="StructTuple-Line4">
        <source>The second line below will fail to compile because of this.  Uncomment it to see what happens.</source>
        <target state="translated">La compilation de la deuxième ligne ci-dessous échoue à cause de cela. Supprimez les marques de commentaire pour voir ce qui se passe.</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleConvert-Line1">
        <source>Although you cannot implicitly convert between struct tuples and reference tuples,</source>
        <target state="translated">Bien que vous ne puissiez pas effectuer de conversion implicite entre les tuples de type struct et les tuples de type référence,</target>
        <note />
      </trans-unit>
      <trans-unit id="TupleConvert-Line2">
        <source>you can explicitly convert via pattern matching, as demonstrated below.</source>
        <target state="translated">vous pouvez effectuer une conversion explicite à l'aide de critères spéciaux, comme indiqué ci-dessous.</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line1">
        <source>The F# pipe operators ('|&gt;', '&lt;|', etc.) and F# composition operators ('&gt;&gt;', '&lt;&lt;')</source>
        <target state="translated">Les opérateurs de canal F# ('|&gt;', '&lt;|', etc.) et les opérateurs de composition F# ('&gt;&gt;', '&lt;&lt;')</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line2">
        <source>are used extensively when processing data.  These operators are themselves functions</source>
        <target state="translated">sont très utilisés de façon pour le traitement des données. Ces opérateurs sont eux-mêmes des fonctions</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line3">
        <source>which make use of Partial Application.</source>
        <target state="translated">qui utilisent l'application partielle.</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line4">
        <source>To learn more about these operators, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/functions/#function-composition-and-pipelining</source>
        <target state="translated">Pour en savoir plus sur ces opérateurs, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/functions/#function-composition-and-pipelining</target>
        <note />
      </trans-unit>
      <trans-unit id="Pipes-Line5">
        <source>To learn more about Partial Application, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/functions/#partial-application-of-arguments</source>
        <target state="translated">Pour en savoir plus sur l'application partielle, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/functions/#partial-application-of-arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="Squares">
        <source>Squares a value.</source>
        <target state="translated">Met une valeur au carré.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddOne">
        <source>Adds 1 to a value.</source>
        <target state="translated">Ajoute 1 à une valeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestOdd">
        <source>Tests if an integer value is odd via modulo.</source>
        <target state="translated">Teste si une valeur entière est impaire à l'aide d'une opération modulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="NumberList1">
        <source>A list of 5 numbers.  More on lists later.</source>
        <target state="translated">Liste de 5 nombres. Nous reviendrons sur les listes plus tard.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithoutPipes-Line1">
        <source>Given a list of integers, it filters out the even numbers,</source>
        <target state="translated">Pour une liste d'entiers donnée, élimine les nombres pairs par filtrage,</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithoutPipes-Line2">
        <source>squares the resulting odds, and adds 1 to the squared odds.</source>
        <target state="translated">met au carré les nombres impairs résultants, puis ajoute 1 au carré des nombres impairs.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line1">
        <source>A shorter way to write 'squareOddValuesAndAddOne' is to nest each</source>
        <target state="translated">Pour écrire plus rapidement 'squareOddValuesAndAddOne', imbriquez chaque</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line2">
        <source>sub-result into the function calls themselves.</source>
        <target state="translated">sous-résultat dans les appels de fonction.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line3">
        <source>This makes the function much shorter, but it's difficult to see the</source>
        <target state="translated">La fonction est ainsi considérablement raccourcie, mais il est difficile de voir</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterShorter-Line4">
        <source>order in which the data is processed.</source>
        <target state="translated">l'ordre dans lequel les données sont traitées.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line1">
        <source>A preferred way to write 'squareOddValuesAndAddOne' is to use F# pipe operators.</source>
        <target state="translated">Pour écrire 'squareOddValuesAndAddOne', utilisez de préférence des opérateurs de canal F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line2">
        <source>This allows you to avoid creating intermediate results, but is much more readable</source>
        <target state="translated">Aucun résultat intermédiaire n'est créé, mais la syntaxe est beaucoup plus lisible</target>
        <note />
      </trans-unit>
      <trans-unit id="FilterWithPipes-Line3">
        <source>than nesting function calls like 'squareOddValuesAndAddOneNested'</source>
        <target state="translated">que d'imbriquer des appels de fonction comme 'squareOddValuesAndAddOneNested'</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line1">
        <source>You can shorten 'squareOddValuesAndAddOnePipeline' by moving the second `List.map` call</source>
        <target state="translated">Vous pouvez raccourcir 'squareOddValuesAndAddOnePipeline' en déplaçant le second appel 'List.map'</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line2">
        <source>into the first, using a Lambda Function.</source>
        <target state="translated">dans le premier en utilisant une fonction lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line3">
        <source>Note that pipelines are also being used inside the lambda function.  F# pipe operators</source>
        <target state="translated">Notez que les pipelines sont également utilisés dans la fonction lambda. Les opérateurs de canal F#</target>
        <note />
      </trans-unit>
      <trans-unit id="PipeInLambda-Line4">
        <source>can be used for single values as well.  This makes them very powerful for processing data.</source>
        <target state="translated">peuvent également être utilisés pour des valeurs uniques. Ils sont donc très efficaces dans le traitement des données.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line1">
        <source>Lastly, you can eliminate the need to explicitly take 'values' in as a parameter by using '&gt;&gt;'</source>
        <target state="translated">Enfin, vous pouvez éliminer la nécessité d'accepter explicitement 'values' comme paramètre en utilisant '&gt;&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line2">
        <source>to compose the two core operations: filtering out even numbers, then squaring and adding one.</source>
        <target state="translated">pour composer les deux opérations principales : élimination des nombres pairs par filtrage, puis mise au carré et ajout d'une unité.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line3">
        <source>Likewise, the 'fun x -&gt; ...' bit of the lambda expression is also not needed, because 'x' is simply</source>
        <target state="translated">De même, la partie 'fun x -&gt; ...' de l'expression lambda n'est pas nécessaire, car 'x' est simplement</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line4">
        <source>being defined in that scope so that it can be passed to a functional pipeline.  Thus, '&gt;&gt;' can be used</source>
        <target state="translated">défini dans cette portée pour pouvoir être passé à un pipeline fonctionnel. Vous pouvez donc utiliser '&gt;&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line5">
        <source>there as well.</source>
        <target state="translated">ici aussi.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line6">
        <source>The result of 'squareOddValuesAndAddOneComposition' is itself another function which takes a</source>
        <target state="translated">Le résultat de 'squareOddValuesAndAddOneComposition' est une autre fonction qui accepte une</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line7">
        <source>list of integers as its input.  If you execute 'squareOddValuesAndAddOneComposition' with a list</source>
        <target state="translated">liste d'entiers comme entrée. Si vous exécutez 'squareOddValuesAndAddOneComposition' avec une liste</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line8">
        <source>of integers, you'll notice that it produces the same results as previous functions.</source>
        <target state="translated">d'entiers, les résultats sont identiques à ceux des fonctions précédentes.</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line9">
        <source>This is using what is known as function composition.  This is possible because functions in F#</source>
        <target state="translated">C'est ce qui s'appelle la composition de fonctions. Cela vient du fait que les fonctions dans F#</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line10">
        <source>use Partial Application and the input and output types of each data processing operation match</source>
        <target state="translated">utilisent l'application partielle et que les types d'entrée et de sortie de chaque opération de traitement de données correspondent</target>
        <note />
      </trans-unit>
      <trans-unit id="PipesComposition-Line11">
        <source>the signatures of the functions we're using.</source>
        <target state="translated">aux signatures des fonctions que nous utilisons.</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line1">
        <source>Lists are ordered, immutable, singly-linked lists.  They are eager in their evaluation.</source>
        <target state="translated">Les listes sont ordonnées, non modifiables et liées individuellement. Elles font l'objet d'une évaluation stricte.</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line2">
        <source>This module shows various ways to generate lists and process lists with some functions</source>
        <target state="translated">Ce module montre différentes façons de générer et de traiter des listes à l'aide de fonctions</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line3">
        <source>in the 'List' module in the F# Core Library.</source>
        <target state="translated">du module 'List' de la bibliothèque principale F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="Lists-Line4">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/lists</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/lists</target>
        <note />
      </trans-unit>
      <trans-unit id="ListEmptyDefinition">
        <source>Lists are defined using [ ... ].  This is an empty list.</source>
        <target state="translated">Les listes sont définies à l'aide de [ ... ]. Il s'agit d'une liste vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListElementDefinition">
        <source>This is a list with 3 elements.  ';' is used to separate elements on the same line.</source>
        <target state="translated">Il s'agit d'une liste avec 3 éléments. ';' permet de séparer des éléments sur la même ligne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListNewlineElements">
        <source>You can also separate elements by placing them on their own lines.</source>
        <target state="translated">Vous pouvez également séparer des éléments en les plaçant chacun sur une ligne.</target>
        <note />
      </trans-unit>
      <trans-unit id="NumberList2">
        <source>This is a list of integers from 1 to 1000</source>
        <target state="translated">Il s'agit de la liste des entiers de 1 à 1 000</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputation-Line1">
        <source>Lists can also be generated by computations. This is a list containing</source>
        <target state="translated">Les listes peuvent également être générées par calculs. Il s'agit d'une liste contenant</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputation-Line2">
        <source>all the days of the year.</source>
        <target state="translated">tous les jours de l'année.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintList2">
        <source>Print the first 5 elements of 'daysList' using 'List.take'.</source>
        <target state="translated">Imprimez les 5 premiers éléments de 'daysList' en utilisant 'List.take'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputationConditional-Line1">
        <source>Computations can include conditionals.  This is a list containing the tuples</source>
        <target state="translated">Les calculs peuvent inclure des conditions. Il s'agit d'une liste contenant les tuples</target>
        <note />
      </trans-unit>
      <trans-unit id="ListComputationConditional-Line2">
        <source>which are the coordinates of the black squares on a chess board.</source>
        <target state="translated">qui sont les coordonnées des cases noires d'un échiquier.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line1">
        <source>Lists can be transformed using 'List.map' and other functional programming combinators.</source>
        <target state="translated">Les listes peuvent être transformées à l'aide de 'List.map' et d'autres combinateurs de programmation fonctionnelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line2">
        <source>This definition produces a new list by squaring the numbers in numberList, using the pipeline</source>
        <target state="translated">Cette définition produit une nouvelle liste en mettant au carré les nombres de numberList à l'aide de</target>
        <note />
      </trans-unit>
      <trans-unit id="ListMap-Line3">
        <source>operator to pass an argument to List.map.</source>
        <target state="translated">l'opérateur du pipeline pour passer un argument à List.map.</target>
        <note />
      </trans-unit>
      <trans-unit id="ListFilter-Line1">
        <source>There are many other list combinations. The following computes the sum of the squares of the</source>
        <target state="translated">Il existe de nombreuses autres combinaisons de listes. La combinaison suivante calcule la somme des carrés des</target>
        <note />
      </trans-unit>
      <trans-unit id="ListFilter-Line2">
        <source>numbers divisible by 3.</source>
        <target state="translated">nombres divisibles par 3.</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line1">
        <source>Arrays are fixed-size, mutable collections of elements of the same type.</source>
        <target state="translated">Les tableaux sont des collections de taille fixe et mutables d'éléments du même type.</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line2">
        <source>Although they are similar to Lists (they support enumeration and have similar combinators for data processing),</source>
        <target state="translated">Bien qu'ils soient semblables aux listes (prise en charge de l'énumération et combinateurs similaires pour le traitement des données),</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line3">
        <source>they are generally faster and support fast random access.  This comes at the cost of being less safe by being mutable.</source>
        <target state="translated">ils offrent généralement une vitesse accrue et prennent en charge l'accès aléatoire rapide. Ils sont toutefois moins sécurisés du fait de leur mutabilité.</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays-Line4">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/arrays</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/arrays</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyArray">
        <source>This is The empty array.  Note that the syntax is similar to that of Lists, but uses `[| ... |]` instead.</source>
        <target state="translated">Tableau vide. Notez que la syntaxe est semblable à celle des listes, mais '[| ... |]' est utilisé à la place.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayConstructionList">
        <source>Arrays are specified using the same range of constructs as lists.</source>
        <target state="translated">Les tableaux sont spécifiés à l'aide de la même plage de constructions que les listes.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayConstructionRange">
        <source>This is an array of numbers from 1 to 1000.</source>
        <target state="translated">Il s'agit d'un tableau de nombres de 1 à 1 000.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayComputationConstruction">
        <source>This is an array containing only the words "hello" and "world".</source>
        <target state="translated">Il s'agit d'un tableau contenant uniquement les mots "hello" et "world".</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayInit">
        <source>This is an array initialized by index and containing the even numbers from 0 to 2000.</source>
        <target state="translated">Il s'agit d'un tableau lancé par index, qui contient les nombres pairs de 0 à 2 000.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArraySlicing">
        <source>Sub-arrays are extracted using slicing notation.</source>
        <target state="translated">Les sous-tableaux sont extraits à l'aide de la notation de découpage.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayLooping">
        <source>You can loop over arrays and lists using 'for' loops.</source>
        <target state="translated">Vous pouvez effectuer une boucle sur des tableaux et des listes à l'aide de boucles 'for'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayAssignment-Line1">
        <source>You can modify the contents of an array element by using the left arrow assignment operator.</source>
        <target state="needs-review-translation">Vous pouvez modifier le contenu d'un élément de tableau à l'aide de l'opérateur d'assignation flèche gauche.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayAssignment-Line2">
        <source>To learn more about this operator, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/values/index#mutable-variables</source>
        <target state="translated">Pour en savoir plus sur cet opérateur, voir : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/values/index#mutable-variables</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayMap-Line1">
        <source>You can transform arrays using 'Array.map' and other functional programming operations.</source>
        <target state="translated">Vous pouvez transformer des tableaux à l'aide de 'Array.map' et d'autres opérations de programmation fonctionnelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayMap-Line2">
        <source>The following calculates the sum of the lengths of the words that start with 'h'.</source>
        <target state="translated">L'opération suivante calcule la somme des longueurs des mots qui commencent par 'h'.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line1">
        <source>Sequences are a logical series of elements, all of the same type.  These are a more general type than Lists and Arrays.</source>
        <target state="translated">Les séquences sont des séries logiques d'éléments du même type. Elles sont plus générales que les listes et les tableaux.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line2">
        <source>Sequences are evaluated on-demand and are re-evaluated each time they are iterated.</source>
        <target state="translated">Les séquences sont évaluées sur demande et sont réévaluées à chacune de leur itération.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line3">
        <source>An F# sequence is an alias for a .NET System.Collections.Generic.IEnumerable&lt;'T&gt;.</source>
        <target state="translated">Une séquence F# est un alias pour un System.Collections.Generic.IEnumerable .NET&lt;'T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line4">
        <source>Sequence processing functions can be applied to Lists and Arrays as well.</source>
        <target state="translated">Les fonctions de traitement de séquence peuvent être appliquées aux listes et aux tableaux également.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequences-Line5">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/sequences</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/sequences</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptySequence">
        <source>This is the empty sequence.</source>
        <target state="translated">Il s'agit de la séquence vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceOfValues">
        <source>This a sequence of values.</source>
        <target state="translated">Il s'agit d'une séquence de valeurs.</target>
        <note />
      </trans-unit>
      <trans-unit id="OnDemandSequence">
        <source>This is an on-demand sequence from 1 to 1000.</source>
        <target state="translated">Séquence à la demande de 1 à 1000.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceComposition">
        <source>This is a sequence producing the words "hello" and "world"</source>
        <target state="translated">Il s'agit d'une séquence produisant les mots "hello" et "world"</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceInit">
        <source>This sequence producing the even numbers up to 2000.</source>
        <target state="translated">Cette séquence produit les nombres pairs jusqu'à 2 000.</target>
        <note />
      </trans-unit>
      <trans-unit id="InfiniteSequence-Line1">
        <source>This is an infinite sequence which is a random walk.</source>
        <target state="translated">Il s'agit d'une séquence infinie correspondant à une marche aléatoire.</target>
        <note />
      </trans-unit>
      <trans-unit id="InfiniteSequence-Line2">
        <source>This example uses yield! to return each element of a subsequence.</source>
        <target state="translated">Cet exemple utilise yield! pour retourner chaque élément d'une sous-séquence.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sequence100Elements">
        <source>This example shows the first 100 elements of the random walk.</source>
        <target state="translated">Cet exemple montre les 100 premiers éléments de la marche aléatoire.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line1">
        <source>Recursive functions can call themselves. In F#, functions are only recursive</source>
        <target state="translated">Les fonctions récursives peuvent s'appeler elles-mêmes. En F#, les fonctions sont uniquement récursives</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line2">
        <source>when declared using 'let rec'.</source>
        <target state="translated">en cas de déclaration avec 'let rec'.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line3">
        <source>Recursion is the preferred way to process sequences or collections in F#.</source>
        <target state="translated">Il est recommandé d'utiliser la récursivité pour traiter des séquences ou des collections en F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveFunctions-Line4">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/functions/index#recursive-functions</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/functions/index#recursive-functions</target>
        <note />
      </trans-unit>
      <trans-unit id="RecFunDef-Line1">
        <source>This example shows a recursive function that computes the factorial of an</source>
        <target state="translated">Cet exemple montre une fonction récursive qui calcule la factorielle d'un</target>
        <note />
      </trans-unit>
      <trans-unit id="RecRunDef-Line2">
        <source>integer. It uses 'let rec' to define a recursive function.</source>
        <target state="translated">entier. Il utilise 'let rec' pour définir une fonction récursive.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line1">
        <source>Computes the greatest common factor of two integers.</source>
        <target state="translated">Calcule le plus grand commun diviseur de deux entiers.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line2">
        <source>Since all of the recursive calls are tail calls,</source>
        <target state="translated">Comme tous les appels récursifs sont des appels terminaux,</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line3">
        <source>the compiler will turn the function into a loop,</source>
        <target state="translated">le compilateur transforme la fonction en boucle,</target>
        <note />
      </trans-unit>
      <trans-unit id="RecGcd-Line4">
        <source>which improves performance and reduces memory consumption.</source>
        <target state="translated">ce qui améliore le niveau de performance et réduit la consommation de mémoire.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumList">
        <source>This example computes the sum of a list of integers using recursion.</source>
        <target state="translated">Cet exemple calcule la somme d'une liste d'entiers à l'aide de la récursivité.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTail">
        <source>This makes 'sumList' tail recursive, using a helper function with a result accumulator.</source>
        <target state="translated">'sumList' est converti en fonction à récursivité terminale, en utilisant une fonction d'assistance avec accumulateur de résultats.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTailInvoke-Line1">
        <source>This invokes the tail recursive helper function, providing '0' as a seed accumulator.</source>
        <target state="translated">La fonction d'assistance de récursivité terminale est appelée et fournit '0' comme accumulateur de valeurs initiales.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecSumListTailInvoke-Line2">
        <source>An approach like this is common in F#.</source>
        <target state="translated">Une telle approche est courante en F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line1">
        <source>Records are an aggregate of named values, with optional members (such as methods).</source>
        <target state="translated">Les enregistrements sont des agrégats de valeurs nommées, avec des membres facultatifs (comme des méthodes).</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line2">
        <source>They are immutable and have structural equality semantics.</source>
        <target state="translated">Ils ne sont pas modifiables et ont une sémantique d'égalité structurelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="Records-Line3">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/records</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/records</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordDefinition">
        <source>This example shows how to define a new record type.</source>
        <target state="translated">Cet exemple montre comment définir un nouveau type d'enregistrement.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordInstantiation1">
        <source>This example shows how to instantiate a record type.</source>
        <target state="translated">Cet exemple montre comment instancier un type d'enregistrement.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordInstantiation2">
        <source>You can also do this on the same line with ';' separators.</source>
        <target state="translated">Vous pouvez également effectuer cette opération sur la même ligne avec des séparateurs ';'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line1">
        <source>This example shows how to use "copy-and-update" on record values. It creates</source>
        <target state="translated">Cet exemple montre comment utiliser "copy-and-update" sur des valeurs d'enregistrement. Il crée</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line2">
        <source>a new record value that is a copy of contact1, but has different values for</source>
        <target state="translated">une nouvelle valeur d'enregistrement qui est une copie de contact1, mais qui a différentes valeurs pour</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line3">
        <source>the 'Phone' and 'Verified' fields.</source>
        <target state="translated">les champs 'Phone' et 'Verified'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UpdateRecord-Line4">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/copy-and-update-record-expressions</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/copy-and-update-record-expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="ProcessRecord-Line1">
        <source>This example shows how to write a function that processes a record value.</source>
        <target state="translated">Cet exemple montre comment écrire une fonction qui traite une valeur d'enregistrement.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProcessRecord-Line2">
        <source>It converts a 'ContactCard' object to a string.</source>
        <target state="translated">Il convertit un objet 'ContactCard' en chaîne.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordWithMember-Line1">
        <source>This is an example of a Record with a member.</source>
        <target state="translated">Il s'agit d'un exemple d'enregistrement avec un membre.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordWithMember-Line2">
        <source>Members can implement object-oriented members.</source>
        <target state="translated">Les membres peuvent implémenter des membres orientés objet.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordAccess">
        <source>Members are accessed via the '.' operator on an instantiated type.</source>
        <target state="translated">Les membres sont accessibles au moyen de l'opérateur '.' sur un type instancié.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line1">
        <source>Records can also be represented as structs via the 'Struct' attribute.</source>
        <target state="translated">Les enregistrements peuvent également être représentés sous forme de structs par le biais de l'attribut 'Struct'.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line2">
        <source>This is helpful in situations where the performance of structs outweighs</source>
        <target state="translated">Cela peut s'avérer utile dans les situations où le niveau de performance des structs l'emporte</target>
        <note />
      </trans-unit>
      <trans-unit id="RecordStruct-Line3">
        <source>the flexibility of reference types.</source>
        <target state="translated">sur la flexibilité des types de référence.</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line1">
        <source>Discriminated Unions (DU for short) are values which could be a number of named forms or cases.</source>
        <target state="translated">Les unions discriminées sont des valeurs qui peuvent correspondre à un certain nombre de formulaires ou de cas nommés.</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line2">
        <source>Data stored in DUs can be one of several distinct values.</source>
        <target state="translated">Les données stockées dans les unions discriminées peuvent prendre une valeur parmi plusieurs valeurs distinctes.</target>
        <note />
      </trans-unit>
      <trans-unit id="DiscriminatedUnions-Line3">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/discriminated-unions</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/discriminated-unions</target>
        <note />
      </trans-unit>
      <trans-unit id="CardSuit">
        <source>The following represents the suit of a playing card.</source>
        <target state="translated">Ce qui suit représente la couleur d'une carte à jouer.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardRank">
        <source>A Discriminated Union can also be used to represent the rank of a playing card.</source>
        <target state="needs-review-translation">Une union discriminée peut également servir à représenter le rang d'une carte à jouer.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardRankValue">
        <source>Represents the rank of cards 2 .. 10</source>
        <target state="translated">Représente le rang des cartes 2 .. 10</target>
        <note />
      </trans-unit>
      <trans-unit id="CardMember">
        <source>Discriminated Unions can also implement object-oriented members.</source>
        <target state="translated">Les unions discriminées peuvent également implémenter des membres orientés objet.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardType-Line1">
        <source>This is a record type that combines a Suit and a Rank.</source>
        <target state="translated">Il s'agit d'un type d'enregistrement qui combine une couleur et un rang.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardType-Line2">
        <source>It's common to use both Records and Discriminated Unions when representing data.</source>
        <target state="needs-review-translation">Il est fréquent d'utiliser à la fois des enregistrements et des unions discriminées pour représenter des données.</target>
        <note />
      </trans-unit>
      <trans-unit id="ComputeFullDeck">
        <source>This computes a list representing all the cards in the deck.</source>
        <target state="translated">Ceci calcule une liste représentant toutes les cartes du paquet.</target>
        <note />
      </trans-unit>
      <trans-unit id="CardToString">
        <source>This example converts a 'Card' object to a string.</source>
        <target state="translated">Cet exemple convertit un objet 'Card' en chaîne.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintAllCards">
        <source>This example prints all the cards in a playing deck.</source>
        <target state="translated">Cet exemple imprime toutes les cartes d'un jeu de cartes.</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line1">
        <source>Single-case DUs are often used for domain modeling.  This can buy you extra type safety</source>
        <target state="translated">Les unions discriminées à cas unique sont souvent utilisées pour la modélisation de domaines. Il peut en résulter une meilleure cohérence des types</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line2">
        <source>over primitive types such as strings and ints.</source>
        <target state="translated">sur des types primitifs tels que les chaînes et les entiers.</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line3">
        <source>Single-case DUs cannot be implicitly converted to or from the type they wrap.</source>
        <target state="translated">Les unions discriminées à cas unique ne peuvent pas être converties implicitement vers ou à partir du type qu'elles incluent dans un wrapper.</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line4">
        <source>For example, a function which takes in an Address cannot accept a string as that input,</source>
        <target state="translated">Par exemple, une fonction qui accepte une adresse ne peut pas accepter une chaîne comme entrée</target>
        <note />
      </trans-unit>
      <trans-unit id="SingleCaseDu-Line5">
        <source>or vive/versa.</source>
        <target state="translated">ou vice versa.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateSingleCaseDu">
        <source>You can easily instantiate a single-case DU as follows.</source>
        <target state="translated">Vous pouvez facilement instancier une union discriminée à cas unique comme suit.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnwrapSingleCaseDu">
        <source>When you need the value, you can unwrap the underlying value with a simple function.</source>
        <target state="translated">Quand vous avez besoin de la valeur, vous pouvez exclure la valeur sous-jacente du wrapper à l'aide d'une fonction simple.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintSingleCaseDu">
        <source>Printing single-case DUs is simple with unwrapping functions.</source>
        <target state="translated">Les fonctions d'exclusion d'un wrapper facilitent l'impression d'unions discriminées à cas unique.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line1">
        <source>Discriminated Unions also support recursive definitions.</source>
        <target state="needs-review-translation">Les unions discriminées prennent également en charge les définitions récursives.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line2">
        <source>This represents a Binary Search Tree, with one case being the Empty tree,</source>
        <target state="translated">Ceci représente un arbre de recherche binaire, l'un des cas étant l'arbre vide</target>
        <note />
      </trans-unit>
      <trans-unit id="DuRecursiveDef-Line3">
        <source>and the other being a Node with a value and two subtrees.</source>
        <target state="translated">et l'autre étant un nœud avec une valeur et deux sous-arbres.</target>
        <note />
      </trans-unit>
      <trans-unit id="SearchBinaryTree-Line1">
        <source>Check if an item exists in the binary search tree.</source>
        <target state="translated">Vérifiez si un élément existe dans l'arbre de recherche binaire.</target>
        <note />
      </trans-unit>
      <trans-unit id="SearchBinaryTree-Line2">
        <source>Searches recursively using Pattern Matching.  Returns true if it exists; otherwise, false.</source>
        <target state="translated">Effectue une recherche récursive à l'aide de critères spéciaux. Retourne true si l'élément existe ; sinon, false.</target>
        <note />
      </trans-unit>
      <trans-unit id="CheckLeftSubtree">
        <source>Check the left subtree.</source>
        <target state="translated">Vérifiez le sous-arbre gauche.</target>
        <note />
      </trans-unit>
      <trans-unit id="CheckRightSubtree">
        <source>Check the right subtree.</source>
        <target state="translated">Vérifiez le sous-arbre droit.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line1">
        <source>Inserts an item in the Binary Search Tree.</source>
        <target state="translated">Insère un élément dans l'arbre de recherche binaire.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line2">
        <source>Finds the place to insert recursively using Pattern Matching, then inserts a new node.</source>
        <target state="translated">Recherche l'emplacement de l'insertion récursive à l'aide de critères spéciaux, puis insère un nouveau nœud.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line3">
        <source>If the item is already present, it does not insert anything.</source>
        <target state="translated">Si l'élément est déjà présent, rien n'est inséré.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line4">
        <source>No need to insert, it already exists; return the node.</source>
        <target state="translated">Insertion inutile, car l'élément existe déjà ; retournez le nœud.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line5">
        <source>Call into left subtree.</source>
        <target state="translated">Appelez le sous-arbre gauche.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryTreeInsert-Line6">
        <source>Call into right subtree.</source>
        <target state="translated">Appelez le sous-arbre droit.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line1">
        <source>Discriminated Unions can also be represented as structs via the 'Struct' attribute.</source>
        <target state="translated">Les unions discriminées peuvent également être représentées sous forme de structs au moyen de l'attribut 'Struct'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line2">
        <source>This is helpful in situations where the performance of structs outweighs</source>
        <target state="translated">Cela peut s'avérer utile dans les situations où le niveau de performance des structs l'emporte</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line3">
        <source>the flexibility of reference types.</source>
        <target state="translated">sur la flexibilité des types de référence.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line4">
        <source>However, there are two important things to know when doing this:</source>
        <target state="translated">Cependant, retenez les deux points suivants si vous procédez de la sorte :</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line5">
        <source>1. A struct DU cannot be recursively-defined.</source>
        <target state="translated">1. Une union discriminée struct ne peut pas être définie de manière récursive.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuStruct-Line6">
        <source>2. A struct DU must have unique names for each of its cases.</source>
        <target state="translated">2. Une union discriminée struct doit avoir des noms uniques pour chacun de ses cas.</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line1">
        <source>Pattern Matching is a feature of F# that allows you to utilize Patterns,</source>
        <target state="translated">Les critères spéciaux sont une fonctionnalité de F# qui vous permet d'utiliser des modèles</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line2">
        <source>which are a way to compare data with a logical structure or structures,</source>
        <target state="translated">pour comparer des données avec une ou plusieurs structures logiques,</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line3">
        <source>decompose data into constituent parts, or extract information from data in various ways.</source>
        <target state="translated">décomposer des données en parties constitutives ou extraire des informations à partir de données de plusieurs façons.</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line4">
        <source>You can then dispatch on the "shape" of a pattern via Pattern Matching.</source>
        <target state="translated">Vous pouvez ensuite effectuer une répartition selon la "forme" d'un modèle à l'aide de critères spéciaux.</target>
        <note />
      </trans-unit>
      <trans-unit id="PatternMatching-Line5">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/pattern-matching</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/pattern-matching</target>
        <note />
      </trans-unit>
      <trans-unit id="PersonRecord">
        <source>A record for a person's first and last name</source>
        <target state="translated">Enregistrement contenant le nom et le prénom d'une personne</target>
        <note />
      </trans-unit>
      <trans-unit id="EmployeeDu">
        <source>A Discriminated Union of 3 different kinds of employees</source>
        <target state="translated">Union discriminée de 3 genres d'employés différents</target>
        <note />
      </trans-unit>
      <trans-unit id="CountEmployees-Line1">
        <source>Count everyone underneath the employee in the management hierarchy,</source>
        <target state="translated">Comptez tout le monde sous l'employé dans la hiérarchie de gestion</target>
        <note />
      </trans-unit>
      <trans-unit id="CountEmployees-Line2">
        <source>including the employee.</source>
        <target state="translated">(employé inclus).</target>
        <note />
      </trans-unit>
      <trans-unit id="FindDave-Line1">
        <source>Find all managers/executives named "Dave" who do not have any reports.</source>
        <target state="translated">Recherchez tous les responsables ou cadres dont le prénom est "Dave" et qui ne disposent d'aucun rapport.</target>
        <note />
      </trans-unit>
      <trans-unit id="FindDave-Line2">
        <source>This uses the 'function' shorthand to as a lambda expression.</source>
        <target state="translated">Le raccourci 'function' est utilisé comme expression lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchEmptyList">
        <source>[] matches an empty list.</source>
        <target state="translated">[] correspond à une liste vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchWildcard-Line1">
        <source>'_' is a wildcard pattern that matches anything.</source>
        <target state="translated">'_' est un modèle générique qui correspond à n'importe quel élément.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchWildCard-Line2">
        <source>This handles the "or else" case.</source>
        <target state="translated">Ceci permet de gérer le cas "or else".</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchShorthand-Line1">
        <source>You can also use the shorthand function construct for pattern matching,</source>
        <target state="translated">Vous pouvez également utiliser la construction de fonction raccourcie pour les critères spéciaux,</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchShorthand-Line2">
        <source>which is useful when you're writing functions which make use of Partial Application.</source>
        <target state="translated">ce qui peut s'avérer utile quand vous écrivez des fonctions qui utilisent l'application partielle.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParseHelpers">
        <source>Define some more functions which parse with the helper function.</source>
        <target state="translated">Définissez d'autres fonctions d'analyse avec la fonction d'assistance.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line1">
        <source>Active Patterns are another powerful construct to use with pattern matching.</source>
        <target state="translated">Les modèles actifs sont une autre construction efficace à utiliser avec les critères spéciaux.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line2">
        <source>They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</source>
        <target state="translated">Ils permettent de partitionner des données d'entrée dans des formulaires personnalisés, en les décomposant au niveau du site d'appel de correspondance au modèle.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivePatterns-Line3">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/active-patterns</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/active-patterns</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchActivePattern">
        <source>Pattern Matching via 'function' keyword and Active Patterns often looks like this.</source>
        <target state="translated">Les critères spéciaux avec le mot clé 'function' et les modèles actifs ressemblent souvent à ceci.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintParse">
        <source>Call the printer with some different values to parse.</source>
        <target state="translated">Appelez l'imprimante avec des valeurs différentes à analyser.</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line1">
        <source>Option values are any kind of value tagged with either 'Some' or 'None'.</source>
        <target state="translated">Les valeurs d'option sont tout type de valeur marquée avec 'Some' ou 'None'.</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line2">
        <source>They are used extensively in F# code to represent the cases where many other</source>
        <target state="translated">Elles sont très utilisées dans le code F# pour représenter les cas où de nombreux autres</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line3">
        <source>languages would use null references.</source>
        <target state="translated">langages utilisent des références null.</target>
        <note />
      </trans-unit>
      <trans-unit id="Option-Line4">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/options</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/options</target>
        <note />
      </trans-unit>
      <trans-unit id="ZipCode">
        <source>First, define a zipcode defined via Single-case Discriminated Union.</source>
        <target state="translated">Commencez par définir un code postal au moyen d'une union discriminée à cas unique.</target>
        <note />
      </trans-unit>
      <trans-unit id="Customer">
        <source>Next, define a type where the ZipCode is optional.</source>
        <target state="translated">Définissez ensuite un type où ZipCode est facultatif.</target>
        <note />
      </trans-unit>
      <trans-unit id="ShippingCalculator-Line1">
        <source>Next, define an interface type that represents an object to compute the shipping zone for the customer's zip code,</source>
        <target state="translated">Ensuite, définissez un type d'interface qui représente un objet pour calculer la zone d'expédition correspondant au code postal du client,</target>
        <note />
      </trans-unit>
      <trans-unit id="ShippingCalculator-Line2">
        <source>given implementations for the 'getState' and 'getShippingZone' abstract methods.</source>
        <target state="translated">en fonction des implémentations des méthodes abstraites 'getState' et 'getShippingZone'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line1">
        <source>Next, calculate a shipping zone for a customer using a calculator instance.</source>
        <target state="translated">Ensuite, calculez une zone d'expédition pour un client à l'aide d'une instance de calculatrice.</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line2">
        <source>This uses combinators in the Option module to allow a functional pipeline for</source>
        <target state="translated">Des combinateurs du module Option sont utilisés pour permettre à un pipeline fonctionnel de</target>
        <note />
      </trans-unit>
      <trans-unit id="CalcShippingZone-Line3">
        <source>transforming data with Optionals.</source>
        <target state="translated">transformer les données avec Optionals.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line1">
        <source>Units of measure are a way to annotate primitive numeric types in a type-safe way.</source>
        <target state="translated">Les unités de mesure sont un moyen d'annoter les types numériques primitifs de manière sécurisée pour les types.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line2">
        <source>You can then perform type-safe arithmetic on these values.</source>
        <target state="translated">Vous pouvez ensuite effectuer des opérations arithmétiques de type sécurisé sur ces valeurs.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitsOfMeasure-Line3">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/units-of-measure</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/units-of-measure</target>
        <note />
      </trans-unit>
      <trans-unit id="CommonUnits">
        <source>First, open a collection of common unit names</source>
        <target state="translated">Pour commencer, ouvrez une collection de noms d'unité courants</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineUnitConstant">
        <source>Define a unitized constant</source>
        <target state="translated">Définissez une constante unifiée</target>
        <note />
      </trans-unit>
      <trans-unit id="MileUnit">
        <source>Next, define a new unit type</source>
        <target state="translated">Ensuite, définissez un nouveau type d'unité</target>
        <note />
      </trans-unit>
      <trans-unit id="MileToMeter">
        <source>Conversion factor mile to meter.</source>
        <target state="translated">Facteur de conversion mile en mètre.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineMileConstant">
        <source>Define a unitized constant</source>
        <target state="translated">Définissez une constante unifiée</target>
        <note />
      </trans-unit>
      <trans-unit id="ComputeMileToMeter">
        <source>Compute  metric-system constant</source>
        <target state="translated">Calculez la constante de système métrique</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintUnitsOfMeasure">
        <source>Values using Units of Measure can be used just like the primitive numeric type for things like printing.</source>
        <target state="translated">Les valeurs avec des unités de mesure s'utilisent de la même façon que le type numérique primitif dans des opérations comme l'impression.</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line1">
        <source>Classes are a way of defining new object types in F#, and support standard Object-oriented constructs.</source>
        <target state="translated">Les classes sont un moyen de définir de nouveaux types d'objet en F#. Elles prennent en charge les constructions orientées objet standard.</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line2">
        <source>They can have a variety of members (methods, properties, events, etc.)</source>
        <target state="translated">Elles peuvent avoir différents membres (méthodes, propriétés, événements, etc.)</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line3">
        <source>To learn more about Classes, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/classes</source>
        <target state="translated">Pour en savoir plus sur les Cours, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/classes</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes-Line4">
        <source>To learn more about Members, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/members</source>
        <target state="translated">Pour en savoir plus sur les membres, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/members</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line1">
        <source>A simple two-dimensional Vector class.</source>
        <target state="translated">Classe Vector à deux dimensions simple.</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line2">
        <source>The class's constructor is on the first line,</source>
        <target state="translated">Le constructeur de la classe est sur la première ligne</target>
        <note />
      </trans-unit>
      <trans-unit id="Vector-Line3">
        <source>and takes two arguments: dx and dy, both of type 'double'.</source>
        <target state="translated">et accepte deux arguments : dx et dy (tous deux de type 'double').</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInternalField-Line1">
        <source>This internal field stores the length of the vector, computed when the</source>
        <target state="translated">Ce champ interne stocke la longueur du vecteur, calculée quand</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInternalField-Line2">
        <source>object is constructed</source>
        <target state="translated">l'objet est construit</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisKeyword-Line1">
        <source>'this' specifies a name for the object's self identifier.</source>
        <target state="translated">'this' spécifie un nom pour l'auto-identificateur de l'objet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThisKeyword-Line2">
        <source>In instance methods, it must appear before the member name.</source>
        <target state="translated">Dans les méthodes d'instance, il doit apparaître avant le nom du membre.</target>
        <note />
      </trans-unit>
      <trans-unit id="MemberMethod">
        <source>This member is a method.  The previous members were properties.</source>
        <target state="translated">Ce membre est une méthode. Les membres précédents étaient des propriétés.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateClass">
        <source>This is how you instantiate the Vector2D class.</source>
        <target state="translated">Voici comment instancier la classe Vector2D.</target>
        <note />
      </trans-unit>
      <trans-unit id="ScaledVector">
        <source>Get a new scaled vector object, without modifying the original object.</source>
        <target state="translated">Obtenez un nouvel objet vector mis à l'échelle, sans modifier l'objet d'origine.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line1">
        <source>Generic classes allow types to be defined with respect to a set of type parameters.</source>
        <target state="translated">Les classes génériques autorisent la définition des types par rapport à un jeu de paramètres de type.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line2">
        <source>In the following, 'T is the type parameter for the class.</source>
        <target state="translated">Dans ce qui suit, 'T est le paramètre de type pour la classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericClasses-Line3">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/generics/</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/generics/</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalField">
        <source>This internal field store the states in a list.</source>
        <target state="translated">Ce champ interne stocke les états dans une liste.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddElement">
        <source>Add a new element to the list of states.</source>
        <target state="translated">Ajoutez un nouvel élément à la liste d'états.</target>
        <note />
      </trans-unit>
      <trans-unit id="MutableAssignment">
        <source>use the '&lt;-' operator to mutate the value.</source>
        <target state="translated">utilisez l'opérateur '&lt;-' pour muter la valeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="History">
        <source>Get the entire list of historical states.</source>
        <target state="translated">Obtenez la liste complète des états historiques.</target>
        <note />
      </trans-unit>
      <trans-unit id="Current">
        <source>Get the latest state.</source>
        <target state="translated">Obtenez le dernier état.</target>
        <note />
      </trans-unit>
      <trans-unit id="InferredTypeParameter">
        <source>An 'int' instance of the state tracker class. Note that the type parameter is inferred.</source>
        <target state="translated">Instance 'int' de la classe de suivi des états. Notez que le paramètre de type est déduit.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddState">
        <source>Add a state</source>
        <target state="translated">Ajouter un état</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line1">
        <source>Interfaces are object types with only 'abstract' members.</source>
        <target state="translated">Les interfaces sont des types d'objet avec des membres 'abstract' uniquement.</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line2">
        <source>Object types and object expressions can implement interfaces.</source>
        <target state="translated">Les types et expressions d'objet peuvent implémenter des interfaces.</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces-Line3">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/interfaces</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposable">
        <source>This is a type that implements IDisposable.</source>
        <target state="translated">Type qui implémente IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableImplementation">
        <source>This is the implementation of IDisposable members.</source>
        <target state="translated">Implémentation de membres IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line1">
        <source>This is an object that implements IDisposable via an Object Expression</source>
        <target state="translated">Objet qui implémente IDisposable à l'aide d'une expression d'objet</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line2">
        <source>Unlike other languages such as C# or Java, a new type definition is not needed</source>
        <target state="translated">Contrairement à d'autres langages tels que C# ou Java, une nouvelle définition de type n'est pas nécessaire</target>
        <note />
      </trans-unit>
      <trans-unit id="IDisposableObjectExpression-Line3">
        <source>to implement an interface.</source>
        <target state="translated">pour implémenter une interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line1">
        <source>The FSharp.Core library defines a range of parallel processing functions.  Here</source>
        <target state="translated">La bibliothèque FSharp.Core définit une plage de fonctions de traitement parallèle. Ici</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line2">
        <source>you use some functions for parallel processing over arrays.</source>
        <target state="translated">vous utilisez des fonctions pour le traitement parallèle des tableaux.</target>
        <note />
      </trans-unit>
      <trans-unit id="Parallel-Line3">
        <source>To learn more, see: https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/array.parallel-module-%5Bfsharp%5D</source>
        <target state="translated">Pour en savoir plus, consultez : https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/array.parallel-module-%5Bfsharp%5D</target>
        <note />
      </trans-unit>
      <trans-unit id="InputArray">
        <source>First, an array of inputs.</source>
        <target state="translated">Tout d'abord, un tableau d'entrées.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpensiveFunction">
        <source>Next, define a functions that does some CPU intensive computation.</source>
        <target state="translated">Ensuite, définissez une fonction qui effectue un calcul nécessitant une utilisation intensive du processeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParallelMap">
        <source>Next, do a parallel map over a large input array.</source>
        <target state="translated">Ensuite, effectuez un mappage parallèle sur un grand tableau d'entrée.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrintParallel">
        <source>Next, print the results.</source>
        <target state="translated">Ensuite, imprimez les résultats.</target>
        <note />
      </trans-unit>
      <trans-unit id="Events-Line1">
        <source>Events are a common idiom for .NET programming, especially with WinForms or WPF applications.</source>
        <target state="translated">Les événements sont un idiome courant de la programmation .NET, en particulier avec les applications WinForms ou WPF.</target>
        <note />
      </trans-unit>
      <trans-unit id="Events-Line2">
        <source>To learn more, see: https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/members/events</source>
        <target state="translated">Pour en savoir plus, consultez : https://learn.microsoft.com/dotnet/articles/fsharp/language-reference/members/events</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleEvent">
        <source>First, create instance of Event object that consists of subscription point (event.Publish) and event trigger (event.Trigger).</source>
        <target state="translated">Pour commencer, créez une instance d'objet Event qui se compose d'un point d'abonnement (event.Publish) et d'un déclencheur d'événements (event.Trigger).</target>
        <note />
      </trans-unit>
      <trans-unit id="AddEventHandler1">
        <source>Next, add handler to the event.</source>
        <target state="translated">Ensuite, ajoutez un gestionnaire à l'événement.</target>
        <note />
      </trans-unit>
      <trans-unit id="TriggerEvent">
        <source>Next, trigger the event.</source>
        <target state="translated">Ensuite, déclenchez l'événement.</target>
        <note />
      </trans-unit>
      <trans-unit id="EventWithArgs">
        <source>Next, create an instance of Event that follows standard .NET convention: (sender, EventArgs).</source>
        <target state="translated">Ensuite, créez une instance d'événement qui respecte la convention .NET standard : (sender, EventArgs).</target>
        <note />
      </trans-unit>
      <trans-unit id="AddEventHandler2">
        <source>Next, add a handler for this new event.</source>
        <target state="translated">Ensuite, ajoutez un gestionnaire à ce nouvel événement.</target>
        <note />
      </trans-unit>
      <trans-unit id="TriggerEventWithArgs">
        <source>Next, trigger this event (note that sender argument should be set).</source>
        <target state="translated">Ensuite, déclenchez cet événement (notez que l'argument sender doit être défini).</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>