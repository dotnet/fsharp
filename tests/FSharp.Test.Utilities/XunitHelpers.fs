#nowarn "0044"
namespace FSharp.Test

open System
open System.IO
open System.Text
open System.Threading

open Xunit.Sdk
open Xunit.Abstractions

module internal TestConsole =
    /// Redirects reads performed on different async execution contexts to the relevant TextReader held by AsyncLocal.
    type RedirectingTextReader(initial: TextReader) =
        inherit TextReader()
        let holder = AsyncLocal<_>()
        do holder.Value <- initial

        override _.Peek() = holder.Value.Peek()
        override _.Read() = holder.Value.Read()
        member _.Set (reader: TextReader) = holder.Value <- reader

    /// Redirects writes performed on different async execution contexts to the relevant TextWriter held by AsyncLocal.
    type RedirectingTextWriter(initial: TextWriter) =
        inherit TextWriter()
        let holder = AsyncLocal<_>()
        do holder.Value <- initial

        override _.Encoding = Encoding.UTF8
        override _.Write(value: char) = holder.Value.Write(value)
        override _.Write(value: string) = holder.Value.Write(value)
        override _.WriteLine(value: string) = holder.Value.WriteLine(value)
        member _.Value = holder.Value
        member _.Set (writer: TextWriter) = holder.Value <- writer

    let localIn = new RedirectingTextReader(TextReader.Null)
    let localOut = new RedirectingTextWriter(TextWriter.Null)
    let localError = new RedirectingTextWriter(TextWriter.Null)

    let initStreamsCapture () = 
        Console.SetIn localIn
        Console.SetOut localOut
        Console.SetError localError

    let resetWriters() =
        new StringWriter() |> localOut.Set
        new StringWriter() |> localError.Set

type TestConsole =
    static member OutText =
        Console.Out.Flush()
        string TestConsole.localOut.Value

    static member ErrorText =
        Console.Error.Flush()
        string TestConsole.localError.Value


// To use xUnit means to customize it. The following abomination adds 3 features:
// - Capturing console output individually and in parallel for each test
// - Internally parallelize test classes and theories. Test cases and theory cases included in a single class or F# module can execute simultaneously
// - Add some autogenerated traits for filtering tests

/// Passes captured console output to xUnit.
type ConsoleCapturingTestRunner(test, messageBus, testClass, constructorArguments, testMethod, testMethodArguments, skipReason, beforeAfterAttributes, aggregator, cancellationTokenSource) =
    inherit XunitTestRunner(test, messageBus, testClass, constructorArguments, testMethod, testMethodArguments, skipReason, beforeAfterAttributes, aggregator, cancellationTokenSource)

    member _.BaseInvokeTestMethodAsync aggregator = base.InvokeTestMethodAsync aggregator
    override this.InvokeTestAsync (aggregator: ExceptionAggregator): Tasks.Task<decimal * string> =
        task {
            TestConsole.resetWriters()
            let! executionTime = this.BaseInvokeTestMethodAsync aggregator
            let output =
                seq {
                    TestConsole.OutText
                    if not (String.IsNullOrEmpty TestConsole.ErrorText) then
                        ""
                        "=========== Standard Error ==========="
                        ""
                        TestConsole.ErrorText
                } |> String.concat Environment.NewLine
            return executionTime, output
        }

/// Disables custom internal parallelization.
/// Execute test cases in a class or a module one by one instead of all at once. Allow other collections to run simultaneously.
[<AttributeUsage(AttributeTargets.Class ||| AttributeTargets.Method, AllowMultiple = false)>]
type RunInSequenceAttribute() = inherit Attribute()

module TestCaseCustomizations =
    // Internally parallelize test classes and theories.
    // Based on https://www.meziantou.net/parallelize-test-cases-execution-in-xunit.htm
    // The trick is to assign a unique test collection to each case.
    // Since test collection is xUnit's unit of parallelization, it will execute everything in parallel including theory cases.
    let rewriteTestMethod (testCase: ITestCase) : ITestMethod =
        let canFullyParallelize =
            // does not belong to a defined collection
            isNull testCase.TestMethod.TestClass.TestCollection.CollectionDefinition
            && testCase.TestMethod.TestClass.Class.GetCustomAttributes(typeof<Xunit.CollectionAttribute>) |> Seq.isEmpty
            // is not marked with `[<RunInSequence>]` attribute
            && testCase.TestMethod.Method.GetCustomAttributes(typeof<RunInSequenceAttribute>) |> Seq.isEmpty
            && testCase.TestMethod.TestClass.Class.GetCustomAttributes(typeof<RunInSequenceAttribute>) |> Seq.isEmpty

        if canFullyParallelize then
            let oldTestMethod = testCase.TestMethod
            let oldTestClass = oldTestMethod.TestClass
            let oldTestCollection = oldTestMethod.TestClass.TestCollection

            // Create a new collection with a unique id for the test case.
            let newTestCollection =
                    new TestCollection(
                        oldTestCollection.TestAssembly,
                        oldTestCollection.CollectionDefinition,
                        oldTestCollection.DisplayName,
                        Guid.NewGuid()
                    )

            let newTestClass = new TestClass(newTestCollection, oldTestClass.Class)
            TestMethod(newTestClass, oldTestMethod.Method)
        else
            testCase.TestMethod

    let addTraits (testCase: ITestCase) =
        // Proof of concept.
        // Distribute test cases reasonably evenly among number of execution nodes.
        // This might be helpful when running tests with parallel multi-agent strategy in CI.
        // SHA256 is probably overkill, but the assignment must be stable between test discoveries.
        let hashAlgorithm = Security.Cryptography.SHA256.Create()
        let assignNode numberOfBuckets =
            let bytes = hashAlgorithm.ComputeHash(Encoding.UTF8.GetBytes(testCase.UniqueID))
            let stableHashValue = BitConverter.ToUInt32(bytes, 0)
            stableHashValue % uint numberOfBuckets + 1u |> string

        // Add `Project` trait so a project can be selected or filtered out during a full solution test run. Example: --filter Project=FSharp.Compiler.ComponentTests
        testCase.Traits["Project"] <- ResizeArray [ testCase.TestMethod.TestClass.TestCollection.TestAssembly.Assembly.Name.Split(',')[0] ]
        // Assign test case to one of buckets numbered 1 .. 4 to easily distribute execution among many agents in CI. Example: --filter ExecutionNode=4
        // Number of nodes hardcoded as 4 here could eventually come from an env variable set by the CI.
        testCase.Traits["ExecutionNode"] <- ResizeArray [ assignNode 4 ]

type CustomTestCase =
    inherit XunitTestCase
    // xUinit demands this constructor for deserialization.
    new() = { inherit XunitTestCase() }
    
    new(sink: IMessageSink, md, mdo, testMethod, testMethodArgs) = { inherit XunitTestCase(sink, md, mdo, testMethod, testMethodArgs) }

    override testCase.RunAsync (_, bus, args, aggregator, cts) =
        let  runner : XunitTestCaseRunner =
            { new XunitTestCaseRunner(testCase, testCase.DisplayName, testCase.SkipReason, args, testCase.TestMethodArguments, bus, aggregator, cts) with
                override this.CreateTestRunner(test, bus, testCase, args, testMethod, methodArgs, skipReason, attrs, aggregator, cts) =
                    ConsoleCapturingTestRunner(test, bus, testCase, args, testMethod, methodArgs, skipReason, attrs, aggregator, cts)
            }
        runner.RunAsync()

    // Initialize is ensured by xUnit to run once before any property access.
    override testCase.Initialize () =
        base.Initialize()
        testCase.TestMethod <- TestCaseCustomizations.rewriteTestMethod testCase
        TestCaseCustomizations.addTraits testCase

type CustomTheoryTestCase =
    inherit XunitTheoryTestCase
    new() = { inherit XunitTheoryTestCase() }
    
    new(sink: IMessageSink, md, mdo, testMethod) = { inherit XunitTheoryTestCase(sink, md, mdo, testMethod) }

    override testCase.RunAsync (sink, bus, args, aggregator, cts) =
        let  runner : XunitTestCaseRunner =
            { new XunitTheoryTestCaseRunner(testCase, testCase.DisplayName, testCase.SkipReason, args, sink, bus, aggregator, cts) with
                override this.CreateTestRunner(test, bus, testCase, args, testMethod, methodArgs, skipReason, attrs, aggregator, cts) =
                    ConsoleCapturingTestRunner(test, bus, testCase, args, testMethod, methodArgs, skipReason, attrs, aggregator, cts)
            }
        runner.RunAsync()

    override testCase.Initialize () =
        base.Initialize()
        testCase.TestMethod <- TestCaseCustomizations.rewriteTestMethod testCase
        TestCaseCustomizations.addTraits testCase

/// Customized test framework providing console support and better parallelization for F# tests.
type TestRun(sink: IMessageSink) =
    inherit XunitTestFramework(sink)
    do
        // Init statics
        MessageSink.sinkWriter |> ignore
        TestConsole.initStreamsCapture()

    override this.CreateDiscoverer (assemblyInfo) =
        { new XunitTestFrameworkDiscoverer(assemblyInfo, this.SourceInformationProvider, this.DiagnosticMessageSink) with
            override _.FindTestsForType (testClass, includeSourceInformation, messageBus, options) =
                // Intercepts test discovery messages to augment test cases with additional capabilities.
                let customizingBus =
                   { new IMessageBus with
                        member _.QueueMessage (message: IMessageSinkMessage) =
                            match message with
                            | :? ITestCaseDiscoveryMessage as discoveryMessage ->
                                let customized: ITestCase =
                                    match discoveryMessage.TestCase with
                                    | :? XunitTheoryTestCase ->
                                        new CustomTheoryTestCase(
                                            sink,
                                            options.MethodDisplayOrDefault(),
                                            options.MethodDisplayOptionsOrDefault(),
                                            discoveryMessage.TestCase.TestMethod,
                                            SourceInformation = discoveryMessage.TestCase.SourceInformation
                                        )
                                    | :? XunitTestCase ->
                                        new CustomTestCase(
                                            sink,
                                            options.MethodDisplayOrDefault(),
                                            options.MethodDisplayOptionsOrDefault(),
                                            discoveryMessage.TestCase.TestMethod,
                                            discoveryMessage.TestCase.TestMethodArguments,
                                            SourceInformation = discoveryMessage.TestCase.SourceInformation
                                        )
                                    | testCase -> testCase
                                messageBus.QueueMessage(TestCaseDiscoveryMessage customized)
                            | _ ->
                                messageBus.QueueMessage message
                        member _.Dispose () = messageBus.Dispose() }
                base.FindTestsForType(testClass, includeSourceInformation, customizingBus, options)
        }
