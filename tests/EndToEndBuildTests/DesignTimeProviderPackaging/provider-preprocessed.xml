<!--
============================================================================================================================================
/home/runner/work/fsharp/fsharp/tests/EndToEndBuildTests/DesignTimeProviderPackaging/Provider/Provider.fsproj
============================================================================================================================================
-->
<Project>
  <!--
============================================================================================================================================
  <Import Project="Sdk.props" Sdk="Microsoft.NET.Sdk">
  This import was added implicitly because the Project element's Sdk attribute specified "Microsoft.NET.Sdk".

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(_AfterSdkPublishDependsOn)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_AfterSdkPublishDependsOn Condition="'$(UsingMicrosoftNETSdkWeb)' == 'true'">AfterPublish</_AfterSdkPublishDependsOn>
    <_AfterSdkPublishDependsOn Condition="'$(UsingMicrosoftNETSdkWeb)' != 'true'">Publish</_AfterSdkPublishDependsOn>
  </PropertyGroup>
  <Target Name="AfterSdkPublish" AfterTargets="$(_AfterSdkPublishDependsOn)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      Indicate to other targets that Microsoft.NET.Sdk is being used.

      This must be set here (as early as possible, before Microsoft.Common.props)
      so that everything that follows can depend on it.

      In particular, Directory.Build.props and nuget package props need to be able
      to use this flag and they are imported by Microsoft.Common.props.
    -->
    <UsingMicrosoftNETSdk>true</UsingMicrosoftNETSdk>
    <!--
      Indicate whether the set of SDK defaults that makes SDK style project concise are being used.
      For example: globbing, importing msbuild common targets.

      Similar to the property above, it must be set here.
    -->
    <UsingNETSdkDefaults>true</UsingNETSdkDefaults>
    <CustomAfterDirectoryBuildProps>$(CustomAfterDirectoryBuildProps);$(MSBuildThisFileDirectory)UseArtifactsOutputPath.props</CustomAfterDirectoryBuildProps>
  </PropertyGroup>
  <PropertyGroup Condition="'$(MSBuildProjectFullPath)' == '$(ProjectToOverrideProjectExtensionsPath)'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MSBuildProjectExtensionsPath>$(ProjectExtensionsPathForSpecifiedProject)</MSBuildProjectExtensionsPath>
  </PropertyGroup>
  <!--<Import Project="$(AlternateCommonProps)" Condition="'$(AlternateCommonProps)' != ''" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="'$(AlternateCommonProps)' == ''">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Current/Microsoft.Common.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <ImportByWildcardBeforeMicrosoftCommonProps Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == ''">true</ImportByWildcardBeforeMicrosoftCommonProps>
    <ImportByWildcardAfterMicrosoftCommonProps Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == ''">true</ImportByWildcardAfterMicrosoftCommonProps>
    <ImportUserLocationsByWildcardBeforeMicrosoftCommonProps Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonProps)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftCommonProps>
    <ImportUserLocationsByWildcardAfterMicrosoftCommonProps Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonProps)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftCommonProps>
    <ImportDirectoryBuildProps Condition="'$(ImportDirectoryBuildProps)' == ''">true</ImportDirectoryBuildProps>
  </PropertyGroup>
  <!--
      Determine the path to the directory build props file if the user did not disable $(ImportDirectoryBuildProps) and
      they did not already specify an absolute path to use via $(DirectoryBuildPropsPath)
  -->
  <PropertyGroup Condition="'$(ImportDirectoryBuildProps)' == 'true' and '$(DirectoryBuildPropsPath)' == ''">
    <_DirectoryBuildPropsFile Condition="'$(_DirectoryBuildPropsFile)' == ''">Directory.Build.props</_DirectoryBuildPropsFile>
    <_DirectoryBuildPropsBasePath Condition="'$(_DirectoryBuildPropsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildPropsFile)'))</_DirectoryBuildPropsBasePath>
    <DirectoryBuildPropsPath Condition="'$(_DirectoryBuildPropsBasePath)' != '' and '$(_DirectoryBuildPropsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildPropsBasePath)', '$(_DirectoryBuildPropsFile)'))</DirectoryBuildPropsPath>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeDirectoryBuildProps)" Condition="'$(CustomBeforeDirectoryBuildProps)' != ''" />-->
  <!--
============================================================================================================================================
  <Import Project="$(DirectoryBuildPropsPath)" Condition="'$(ImportDirectoryBuildProps)' == 'true' and exists('$(DirectoryBuildPropsPath)')">

/home/runner/work/fsharp/fsharp/tests/EndToEndBuildTests/Directory.Build.props
============================================================================================================================================
-->
  <PropertyGroup>
    <FSharpTestCompilerVersion Condition=" '$(FSharpTestCompilerVersion)' == '' ">net40</FSharpTestCompilerVersion>
    <RollForward>LatestMajor</RollForward>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$([MSBuild]::GetPathOfFileAbove('Directory.Build.props', '$(MSBuildThisFileDirectory)../'))">

/home/runner/work/fsharp/fsharp/tests/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$([MSBuild]::GetPathOfFileAbove('Directory.Build.props', '$(MSBuildThisFileDirectory)../'))">

/home/runner/work/fsharp/fsharp/Directory.Build.props
============================================================================================================================================
-->
  <PropertyGroup>
    <PackageProjectUrl>https://github.com/dotnet/fsharp</PackageProjectUrl>
    <RepositoryUrl>https://github.com/dotnet/fsharp</RepositoryUrl>
    <LangVersion Condition="'$(FSharpLangVersion)' != ''">$(FSharpLangVersion)</LangVersion>
    <RepoRoot Condition="'$(RepoRoot)' == ''">$(MSBuildThisFileDirectory)</RepoRoot>
    <AccelerateBuildsInVisualStudio>true</AccelerateBuildsInVisualStudio>
    <FSharpNetCoreProductDefaultTargetFramework>net10.0</FSharpNetCoreProductDefaultTargetFramework>
    <IgnoreMibc Condition="'$(IgnoreMibc)' == ''">$(DotNetBuildSourceOnly)</IgnoreMibc>
    <!-- When building the .NET product, there's no need to publish Windows PDBs. Any conversion to Windows PDBs will be done during staging, if necessary. -->
    <PublishWindowsPdb Condition="'$(DotNetBuild)' == 'true'">false</PublishWindowsPdb>
  </PropertyGroup>
  <!--
   When developers load the FSharp.Compiler.Service solution we set FSHARPCORE_USE_PACKAGE to true if it hasn't already been set to a value.
   This option ensures that building and testing uses the specified FSharp.Core nuget package instead of the local FSharp.Core project.
   We also disable arcade and reset certain artifacts and compiler paths to use default ones.
   All settings below can be overridden via CLI switches if needed. -->
  <PropertyGroup Condition="'$(SolutionName)' == 'FSharp.Compiler.Service' and '$(BUILDING_USING_DOTNET)' != 'false'">
    <BUILDING_USING_DOTNET>true</BUILDING_USING_DOTNET>
  </PropertyGroup>
  <PropertyGroup Condition="'$(SolutionName)' == 'FSharp.Benchmarks' and '$(BUILDING_USING_DOTNET)' != 'false'">
    <BUILDING_USING_DOTNET>true</BUILDING_USING_DOTNET>
  </PropertyGroup>
  <!-- Temporary workaround if proj-info is used, allows Ionide's evaluation to work correctly. -->
  <PropertyGroup Condition="'$(BUILDING_USING_DOTNET)' != 'false' and '$(DotnetProjInfo)' == 'true'">
    <BUILDING_USING_DOTNET>true</BUILDING_USING_DOTNET>
  </PropertyGroup>
  <!-- pick realsig value -->
  <PropertyGroup Condition="'$(BUILDING_USING_DOTNET)' != 'true' and '$(Configuration)' != 'Proto'">
    <OtherFlags Condition="'$(BuildNoRealsig)' == 'true'">$(OtherFlags) --realsig-</OtherFlags>
    <OtherFlags Condition="'$(BuildNoRealsig)' != 'true'">$(OtherFlags) --realsig+</OtherFlags>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Set PublishReadyToRun to speed up the build. -->
    <EnablePublishReadyToRun>true</EnablePublishReadyToRun>
    <!-- Crossgen2 is not built with source-built Mono-based .NET SDKs. -->
    <EnablePublishReadyToRun Condition="'$(DotNetBuildUseMonoRuntime)' == 'true'">false</EnablePublishReadyToRun>
  </PropertyGroup>
  <!--<Import Project="$(RepoRoot)/Directory.Build.props.user" Condition="Exists('$(RepoRoot)/Directory.Build.props.user')" />-->
  <PropertyGroup Condition="'$(BUILDING_USING_DOTNET)' == 'true'">
    <DisableAutoSetFscCompilerPath>false</DisableAutoSetFscCompilerPath>
    <FSHARPCORE_USE_PACKAGE Condition="'$(FSHARPCORE_USE_PACKAGE)' == ''">true</FSHARPCORE_USE_PACKAGE>
    <DISABLE_ARCADE Condition="'$(DISABLE_ARCADE)' == ''">true</DISABLE_ARCADE>
    <ArtifactsDir>$(MSBuildThisFileDirectory)artifacts/</ArtifactsDir>
    <OutputPath>$(ArtifactsDir)/bin/$(MSBuildProjectName)/$(Configuration)/</OutputPath>
    <IntermediateOutputPath>$(ArtifactsDir)obj/$(MSBuildProjectName)/$(Configuration)/</IntermediateOutputPath>
    <!-- Note, that default framework is used here (the one we use for development in the current cycle),
         since it's a non-arcade and non-sourcebuild scenario -->
    <FsLexPath>$(ArtifactsDir)/bin/fslex/$(Configuration)/$(FSharpNetCoreProductDefaultTargetFramework)/$(RuntimeIdentifier)/fslex.dll</FsLexPath>
    <FsYaccPath>$(ArtifactsDir)/bin/fsyacc/$(Configuration)/$(FSharpNetCoreProductDefaultTargetFramework)/$(RuntimeIdentifier)/fsyacc.dll</FsYaccPath>
    <DefineConstants>BUILDING_WITH_LKG;$(DefineConstants)</DefineConstants>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildThisFileDirectory)/eng/Versions.props" Condition="'$(DISABLE_ARCADE)' == 'true'" />-->
  <!--<Import Project="FSharpBuild.Directory.Build.props" Condition=" '$(FSharpTestCompilerVersion)' == '' " />-->
  <!-- To support source-build for the "next" version of .NET without forcing this repo to use it,
       we can utilize arcade's $(NetCurrent) property, and set it ourselves in the arcade-less scenarios.
       For FCS solution, we set it to one for current dev cycle.
       When used with arcade, and inserting/building for net8 branches, it will set it to net8.0, for net9 branches to net9.0 and so on. -->
  <Choose>
    <!-- Once we move to OOP in VS, and major dependants of FCS will move to netcore (not netstandard),
         we should also support $(NetPrevious) for all releases.
         This will likely include FCS and FSharp.Core as well as shipped products.
         Right now, it only covers products we ship (FSC and FSI), not NuGet packages. -->
    <When Condition="'$(DotNetBuildSourceOnly)' == 'true' AND '$(DotNetBuildFromVMR)' == 'true'">
      <PropertyGroup>
        <FSharpNetCoreProductTargetFramework>$(NetCurrent)</FSharpNetCoreProductTargetFramework>
      </PropertyGroup>
    </When>
    <Otherwise>
      <PropertyGroup>
        <FSharpNetCoreProductTargetFramework>$(FSharpNetCoreProductDefaultTargetFramework)</FSharpNetCoreProductTargetFramework>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <!-- It's important we set TFM before this, since FSharpTests.Directory.Build.props uses it.
       TODO(vlza): this build props looks outdated, since we only use $(FSharpTestCompilerVersion) in TP tests or cambridge suite (which we slowly want to migrate to xUnit).
                   We probably should remove or revisit it. -->
  <!--
============================================================================================================================================
  <Import Project="FSharpTests.Directory.Build.props" Condition=" '$(FSharpTestCompilerVersion)' != '' ">

/home/runner/work/fsharp/fsharp/FSharpTests.Directory.Build.props
============================================================================================================================================
-->
  <PropertyGroup>
    <BUILD_IN_FSHARP_REPOSITORY>true</BUILD_IN_FSHARP_REPOSITORY>
  </PropertyGroup>
  <PropertyGroup Condition="'$(FSharpTestCompilerVersion)' == 'net40'">
    <DisableAutoSetFscCompilerPath>true</DisableAutoSetFscCompilerPath>
    <FscToolPath>$(MSBuildThisFileDirectory)artifacts\bin\fsc\$(Configuration)\net472</FscToolPath>
    <FscToolExe>fsc.exe</FscToolExe>
    <DotnetFscCompilerPath />
    <FsiToolPath>$(MSBuildThisFileDirectory)artifacts\bin\fsi\$(Configuration)\net472</FsiToolPath>
    <FsiToolExe>fsi.exe</FsiToolExe>
    <DotnetFsiCompilerPath />
  </PropertyGroup>
  <PropertyGroup Condition="'$(FSharpTestCompilerVersion)' == 'coreclr'">
    <DisableAutoSetFscCompilerPath>true</DisableAutoSetFscCompilerPath>
    <FscToolPath>$([System.IO.Path]::GetDirectoryName('$(DOTNET_HOST_PATH)'))</FscToolPath>
    <FscToolExe Condition="'$(OS)' != 'Unix'">dotnet.exe</FscToolExe>
    <FscToolExe Condition="'$(OS)' == 'Unix'">dotnet</FscToolExe>
    <DotnetFscCompilerPath>$(MSBuildThisFileDirectory)artifacts\bin\fsc\$(Configuration)\$(FSharpNetCoreProductTargetFramework)\fsc.dll</DotnetFscCompilerPath>
    <FsiToolPath>$([System.IO.Path]::GetDirectoryName('$(DOTNET_HOST_PATH)'))</FsiToolPath>
    <FsiToolExe Condition="'$(OS)' != 'Unix'">dotnet.exe</FsiToolExe>
    <FsiToolExe Condition="'$(OS)' == 'Unix'">dotnet</FsiToolExe>
    <DotnetFsiCompilerPath>$(MSBuildThisFileDirectory)artifacts\bin\fsi\$(Configuration)\$(FSharpNetCoreProductTargetFramework)\fsi.dll</DotnetFsiCompilerPath>
  </PropertyGroup>
  <!-- SDK targets override -->
  <PropertyGroup>
    <_FSharpBuildTargetFramework Condition="'$(MSBuildRuntimeType)'!='Core'">net472</_FSharpBuildTargetFramework>
    <_FSharpBuildTargetFramework Condition="'$(MSBuildRuntimeType)'=='Core'">$(FSharpNetCoreProductTargetFramework)</_FSharpBuildTargetFramework>
    <_FSharpBuildBinPath>$(MSBuildThisFileDirectory)artifacts\bin\fsc\$(Configuration)\$(_FSharpBuildTargetFramework)</_FSharpBuildBinPath>
    <FSharpBuildAssemblyFile>$(_FSharpBuildBinPath)\FSharp.Build.dll</FSharpBuildAssemblyFile>
    <FSharpTargetsPath>$(_FSharpBuildBinPath)/Microsoft.FSharp.Targets</FSharpTargetsPath>
    <FSharpPropsShim>$(_FSharpBuildBinPath)/Microsoft.FSharp.NetSdk.props</FSharpPropsShim>
    <FSharpTargetsShim>$(_FSharpBuildBinPath)/Microsoft.FSharp.NetSdk.targets</FSharpTargetsShim>
    <FSharpOverridesTargetsShim>$(_FSharpBuildBinPath)/Microsoft.FSharp.Overrides.NetSdk.targets</FSharpOverridesTargetsShim>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/fsharp/fsharp/Directory.Build.props
============================================================================================================================================
-->
  <ItemGroup>
    <!-- If there is a README.md next to a project file, include it (for easier access in the IDE) -->
    <None Include="README.md" Condition="Exists('README.md')" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/fsharp/fsharp/tests/Directory.Build.props
============================================================================================================================================
-->
  <PropertyGroup>
    <ExcludeFromSourceOnlyBuild>true</ExcludeFromSourceOnlyBuild>
    <DebugType>portable</DebugType>
  </PropertyGroup>
  <!-- Do it the same way .NET Interactive does it, when skipping arcade, we should include test SDK explicitly -->
  <ItemGroup Condition="($(MSBuildProjectName.EndsWith('.Tests')) OR $(MSBuildProjectName.EndsWith('.ComponentTests')) OR $(MSBuildProjectName.EndsWith('.Test.Utilities')) OR $(MSBuildProjectName.EndsWith('.UnitTests'))) AND '$(DISABLE_ARCADE)' == 'true'">
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="$(MicrosoftNETTestSdkVersion)" />
  </ItemGroup>
  <PropertyGroup>
    <NoOptimizationData>false</NoOptimizationData>
    <NoInterfaceData>false</NoInterfaceData>
    <CompressMetadata>true</CompressMetadata>
    <ServerGarbageCollection>true</ServerGarbageCollection>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/fsharp/fsharp/tests/EndToEndBuildTests/Directory.Build.props
============================================================================================================================================
-->
  <!--<Import Project="$([MSBuild]::GetPathOfFileAbove('FSharpTests.Directory.Build.props', '$(MSBuildThisFileDirectory)../'))" />-->
  <PropertyGroup>
    <!-- Ensure end-to-end build tests can find recently-build FSharp.Core and test packages. -->
    <RestoreSources>
      $(RestoreSources);
      $(MSBuildThisFileDirectory)..\..\artifacts\packages\$(Configuration)\Release;
      $(MSBuildThisFileDirectory)..\..\artifacts\packages\$(Configuration)\Shipping;
      https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public/nuget/v3/index.json
    </RestoreSources>
    <RestoreSources Condition="Exists('$(MSBuildThisFileDirectory)BasicProvider\artifacts')">$(RestoreSources);$(MSBuildThisFileDirectory)BasicProvider\artifacts</RestoreSources>
    <RestoreSources Condition="Exists('$(MSBuildThisFileDirectory)ComboProvider\artifacts')">$(RestoreSources);$(MSBuildThisFileDirectory)ComboProvider\artifacts</RestoreSources>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Current/Microsoft.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(CustomAfterDirectoryBuildProps)" Condition="'$(CustomAfterDirectoryBuildProps)' != ''">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/Sdk/UseArtifactsOutputPath.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
UseArtifactsOutputPath.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- If ArtifactsPath or UseArtifactsOutput are set, then import .props to set ArtifactsPath here, so that BaseIntermediateOutputPath can be
       set in the ArtifactsPath.
       If the .props file is not imported here, it will be imported from Microsoft.NET.DefaultOutputPaths.targets, so that artifacts output
       properties can be set directly in the project file too (only in that case they won't affect the intermediate output). -->
  <!--<Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.DefaultArtifactsPath.props" Condition="'$(UseArtifactsOutput)' == 'true' Or '$(ArtifactsPath)' != ''" />-->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <UseArtifactsIntermediateOutput Condition="'$(UseArtifactsIntermediateOutput)' == ''">true</UseArtifactsIntermediateOutput>
    <ArtifactsProjectName Condition="'$(ArtifactsProjectName)' == ''">$(MSBuildProjectName)</ArtifactsProjectName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true' And '$(BaseIntermediateOutputPath)' == '' And '$(UseArtifactsIntermediateOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <BaseIntermediateOutputPath Condition="'$(IncludeProjectNameInArtifactsPaths)' == 'true'">$(ArtifactsPath)\obj\$(ArtifactsProjectName)\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == ''">$(ArtifactsPath)\obj\</BaseIntermediateOutputPath>
  </PropertyGroup>
  <!-- Record whether ArtifactsPath / UseArtifactsOutput was set at this point in evaluation.  We will generate an error if these properties are set
       after this point (ie in the project file). -->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_ArtifactsPathSetEarly>true</_ArtifactsPathSetEarly>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Current/Microsoft.Common.props
============================================================================================================================================
-->
  <!--
      Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
        $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.props

      Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
      management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
  -->
  <PropertyGroup>
    <!--
        The declaration of $(BaseIntermediateOutputPath) had to be moved up from Microsoft.Common.CurrentVersion.targets
        in order for the $(MSBuildProjectExtensionsPath) to use it as a default.
    -->
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)'=='' ">obj\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
    <_InitialBaseIntermediateOutputPath>$(BaseIntermediateOutputPath)</_InitialBaseIntermediateOutputPath>
    <MSBuildProjectExtensionsPath Condition="'$(MSBuildProjectExtensionsPath)' == '' ">$(BaseIntermediateOutputPath)</MSBuildProjectExtensionsPath>
    <!--
        Import paths that are relative default to be relative to the importing file.  However, since MSBuildExtensionsPath
        defaults to BaseIntermediateOutputPath we expect it to be relative to the project directory.  So if the path is relative
        it needs to be made absolute based on the project directory.
    -->
    <MSBuildProjectExtensionsPath Condition="'$([System.IO.Path]::IsPathRooted($(MSBuildProjectExtensionsPath)))' == 'false'">$([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(MSBuildProjectExtensionsPath)'))</MSBuildProjectExtensionsPath>
    <MSBuildProjectExtensionsPath Condition="!HasTrailingSlash('$(MSBuildProjectExtensionsPath)')">$(MSBuildProjectExtensionsPath)\</MSBuildProjectExtensionsPath>
    <!--
        Don't import project extensions during restore because NuGet restore generates them.  Importing them during restore will embed
        the pre-restore files in the binary log and then NuGet won't be able to embed the generated one after restore.  If some other
        project extension mechanism wants to import project extensions during restore, they need to explicitly set ImportProjectExtensionProps
    -->
    <ImportProjectExtensionProps Condition="$([MSBuild]::AreFeaturesEnabled('17.10')) And '$(ImportProjectExtensionProps)' == '' And '$(MSBuildIsRestoring)' == 'true'">false</ImportProjectExtensionProps>
    <ImportProjectExtensionProps Condition="'$(ImportProjectExtensionProps)' == ''">true</ImportProjectExtensionProps>
    <_InitialMSBuildProjectExtensionsPath Condition=" '$(ImportProjectExtensionProps)' == 'true' ">$(MSBuildProjectExtensionsPath)</_InitialMSBuildProjectExtensionsPath>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildProjectExtensionsPath)$(MSBuildProjectFile).*.props" Condition="'$(ImportProjectExtensionProps)' == 'true' and exists('$(MSBuildProjectExtensionsPath)')" />-->
  <!--
      Wildcard imports come from $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ directory.
      This is very similar to the same extension point used in Microsoft.Common.targets, which is located in
      the $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ directory.

      Unfortunately, there is already a file named "Microsoft.Common.props" in this directory,
      so we have to have a slightly different directory name to hold extensions.
  -->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')" />-->
  <PropertyGroup>
    <CustomBeforeMicrosoftCommonProps Condition="'$(CustomBeforeMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.Before.$(MSBuildThisFile)</CustomBeforeMicrosoftCommonProps>
    <CustomAfterMicrosoftCommonProps Condition="'$(CustomAfterMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.$(MSBuildThisFile)</CustomAfterMicrosoftCommonProps>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeMicrosoftCommonProps)" Condition="'$(CustomBeforeMicrosoftCommonProps)' != '' and Exists('$(CustomBeforeMicrosoftCommonProps)')" />-->
  <!-- This is used to determine whether Microsoft.Common.targets needs to import
      Microsoft.Common.props itself, or whether it has been imported previously,
      e.g. by the project itself. -->
  <PropertyGroup>
    <MicrosoftCommonPropsHasBeenImported>true</MicrosoftCommonPropsHasBeenImported>
  </PropertyGroup>
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' and '$(DefaultProjectConfiguration)' != '' ">$(DefaultProjectConfiguration)</Configuration>
    <Platform Condition=" '$(Platform)' == '' and '$(DefaultProjectPlatform)' != '' ">$(DefaultProjectPlatform)</Platform>
  </PropertyGroup>
  <PropertyGroup>
    <WMSJSProject Condition="'$(WMSJSProject)' == ''">WJProject</WMSJSProject>
    <WMSJSProjectDirectory Condition="'$(WMSJSProjectDirectory)' == ''">JavaScript</WMSJSProjectDirectory>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualStudioVersion.v*.Common.props" />-->
  <!--<Import Project="$(CustomAfterMicrosoftCommonProps)" Condition="'$(CustomAfterMicrosoftCommonProps)' != '' and Exists('$(CustomAfterMicrosoftCommonProps)')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')" />-->
  <!--
      Import NuGet.props file.
  -->
  <PropertyGroup>
    <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
    <NuGetPropsFile Condition="'$(NuGetPropsFile)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.props</NuGetPropsFile>
    <NuGetPropsFile Condition="'$(NuGetPropsFile)'==''">$(MSBuildToolsPath)\NuGet.props</NuGetPropsFile>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPropsFile)" Condition="Exists('$(NuGetPropsFile)')">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/NuGet.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
NuGet.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
      Import 'Directory.Packages.props' which will contain centralized packages for all the projects and solutions under
      the directory in which the file is present. This is similar to 'Directory.Build.props/targets' logic which is present
      in the common props/targets which serve a similar purpose.
  -->
  <PropertyGroup>
    <ImportDirectoryPackagesProps Condition="'$(ImportDirectoryPackagesProps)' == ''">true</ImportDirectoryPackagesProps>
  </PropertyGroup>
  <!--
      Determine the path to the 'Directory.Packages.props' file, if the user did not disable $(ImportDirectoryPackagesProps) and
      they did not already specify an absolute path to use via $(DirectoryPackagesPropsPath)
  -->
  <PropertyGroup Condition="'$(ImportDirectoryPackagesProps)' == 'true' and '$(DirectoryPackagesPropsPath)' == ''">
    <_DirectoryPackagesPropsFile Condition="'$(_DirectoryPackagesPropsFile)' == ''">Directory.Packages.props</_DirectoryPackagesPropsFile>
    <_DirectoryPackagesPropsBasePath Condition="'$(_DirectoryPackagesPropsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove('$(MSBuildProjectDirectory)', '$(_DirectoryPackagesPropsFile)'))</_DirectoryPackagesPropsBasePath>
    <DirectoryPackagesPropsPath Condition="'$(_DirectoryPackagesPropsBasePath)' != '' and '$(_DirectoryPackagesPropsFile)' != ''">$([MSBuild]::NormalizePath('$(_DirectoryPackagesPropsBasePath)', '$(_DirectoryPackagesPropsFile)'))</DirectoryPackagesPropsPath>
  </PropertyGroup>
  <!--<Import Project="$(DirectoryPackagesPropsPath)" Condition="'$(ImportDirectoryPackagesProps)' == 'true' and '$(DirectoryPackagesPropsPath)' != '' and Exists('$(DirectoryPackagesPropsPath)')" />-->
  <PropertyGroup Condition="'$(ImportDirectoryPackagesProps)' == 'true' and '$(DirectoryPackagesPropsPath)' != '' and Exists('$(DirectoryPackagesPropsPath)')">
    <CentralPackageVersionsFileImported>true</CentralPackageVersionsFileImported>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Current/Microsoft.Common.props
============================================================================================================================================
-->
  <PropertyGroup Condition=" '$(MSBuildLogVerboseTaskParameters)' != 'true' ">
    <DisableLogTaskParameter_ConvertToAbsolutePath_Path>true</DisableLogTaskParameter_ConvertToAbsolutePath_Path>
    <DisableLogTaskParameter_FindUnderPath_OutOfPath>true</DisableLogTaskParameter_FindUnderPath_OutOfPath>
    <DisableLogTaskParameter_RemoveDuplicates_Inputs>true</DisableLogTaskParameter_RemoveDuplicates_Inputs>
    <DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_AbsolutePaths>true</DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_AbsolutePaths>
    <DisableLogTaskParameterItemMetadata_Copy_CopiedFiles>true</DisableLogTaskParameterItemMetadata_Copy_CopiedFiles>
    <DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>true</DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>
    <DisableLogTaskParameterItemMetadata_Copy_SourceFiles>true</DisableLogTaskParameterItemMetadata_Copy_SourceFiles>
    <DisableLogTaskParameterItemMetadata_FindUnderPath_Files>true</DisableLogTaskParameterItemMetadata_FindUnderPath_Files>
    <DisableLogTaskParameterItemMetadata_FindUnderPath_InPath>true</DisableLogTaskParameterItemMetadata_FindUnderPath_InPath>
    <DisableLogTaskParameterItemMetadata_GenerateResource_FilesWritten>true</DisableLogTaskParameterItemMetadata_GenerateResource_FilesWritten>
    <DisableLogTaskParameterItemMetadata_Hash_ItemsToHash>true</DisableLogTaskParameterItemMetadata_Hash_ItemsToHash>
    <DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>true</DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>
    <DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>true</DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- This property disables the conflict resolution logic from the Microsoft.Packaging.Tools package, which is superceded by the logic here in the SDK -->
    <DisableHandlePackageFileConflicts>true</DisableHandlePackageFileConflicts>
  </PropertyGroup>
  <!-- Default configuration and platform to Debug|AnyCPU-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Configurations Condition=" '$(Configurations)' == '' ">Debug;Release</Configurations>
    <Platforms Condition=" '$(Platforms)' == '' ">AnyCPU</Platforms>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
  </PropertyGroup>
  <!-- Default the value of PackRelease for every project. Note that this is pre-evaluated by the CLI in an evaluation before evaluation (see ReleasePropertyProjectLocator.cs).
  Multitargeting pack splits a single 2 TFM project into 9 separate evaluations, with different target imports. Microsoft.NET.SDK.DefaultItems.Targets ...
  is where PublishRelease is defaulted because it depends on _TargetFrameworkVersionWithoutV. Some targets do not run in some instances of dotnet pack.
  So, we must set PackRelease here. Even though this occurs before project import, the project import can override PackRelease later, before the pre-evaluation, so this is fine.-->
  <PropertyGroup Condition="'$(PackRelease)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Do not depend on this value being correct until after project evaluation.-->
    <PackRelease>true</PackRelease>
  </PropertyGroup>
  <!-- User-facing configuration-agnostic defaults -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <OutputType Condition=" '$(OutputType)' == '' ">Library</OutputType>
    <FileAlignment Condition=" '$(FileAlignment)' == '' ">512</FileAlignment>
    <ErrorReport Condition=" '$(ErrorReport)' == '' ">prompt</ErrorReport>
    <AssemblyName Condition=" '$(AssemblyName)' == '' ">$(MSBuildProjectName)</AssemblyName>
    <Deterministic Condition=" '$(Deterministic)' == '' ">true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(RootNamespace)' == '' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Transform project name for RootNamespace: replace spaces and dashes with underscores, prefix with underscore if starts with digit -->
    <RootNamespace>$(MSBuildProjectName.Replace(" ", "_").Replace("-", "_"))</RootNamespace>
    <RootNamespace Condition=" $([System.Char]::IsDigit($(RootNamespace), 0)) ">_$(RootNamespace)</RootNamespace>
  </PropertyGroup>
  <!-- User-facing configuration-specific defaults -->
  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DebugSymbols Condition=" '$(DebugSymbols)' == '' ">true</DebugSymbols>
    <Optimize Condition=" '$(Optimize)' == '' ">false</Optimize>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Optimize Condition=" '$(Optimize)' == '' ">true</Optimize>
  </PropertyGroup>
  <!-- User-facing platform-specific defaults -->
  <!--
    NOTE:

     * We cannot compare against $(Platform) directly as that will give VS cause to instantiate extra
       configurations, for each combination, which leads to performance problems and clutter in the sln
       in the common AnyCPU-only case.

     * We cannot just set $(PlatformTarget) to $(Platform) here because $(Platform) can be set to anything
       at the solution level, but there are a fixed set valid $(PlatformTarget) values that can be passed
       to the compiler. It is up to the user to explicitly set PlatformTarget to non-AnyCPU (if desired)
       outside the 1:1 defaults below.
  -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_PlatformWithoutConfigurationInference>$(Platform)</_PlatformWithoutConfigurationInference>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(_PlatformWithoutConfigurationInference)' == 'x64' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PlatformTarget Condition=" '$(PlatformTarget)' == '' ">x64</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(_PlatformWithoutConfigurationInference)' == 'x86' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PlatformTarget Condition=" '$(PlatformTarget)' == '' ">x86</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(_PlatformWithoutConfigurationInference)' == 'ARM' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PlatformTarget Condition=" '$(PlatformTarget)' == '' ">ARM</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(_PlatformWithoutConfigurationInference)' == 'arm64' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PlatformTarget Condition=" '$(PlatformTarget)' == '' ">arm64</PlatformTarget>
  </PropertyGroup>
  <!-- Default settings for all projects built with this Sdk package -->
  <PropertyGroup Condition=" '$(AssemblySearchPaths)' == '' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- By default exclude GAC, registry, output directory from search paths. -->
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseCandidateAssemblyFiles)' != 'false'">{CandidateAssemblyFiles}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseHintPathFromItem)' != 'false'">$(AssemblySearchPaths);{HintPathFromItem}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseTargetFrameworkDirectory)' != 'false'">$(AssemblySearchPaths);{TargetFrameworkDirectory}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseRawFileName)' != 'false'">$(AssemblySearchPaths);{RawFileName}</AssemblySearchPaths>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DebugType Condition="'$(DebugSymbols)' == 'false'">None</DebugType>
    <DebugType Condition=" '$(DebugType)' == '' ">portable</DebugType>
    <!-- This will turn off the base UWP-specific 'ResolveNuGetPackages' target -->
    <ResolveNuGetPackages>false</ResolveNuGetPackages>
    <!-- Skip import of Microsoft.NuGet.props and Microsoft.NuGet.targets -->
    <SkipImportNuGetProps>true</SkipImportNuGetProps>
    <SkipImportNuGetBuildTargets>true</SkipImportNuGetBuildTargets>
    <!-- NuGet should always restore .NET SDK projects with "PackageReference" style restore.  Setting this property will
         cause the right thing to happen even if there aren't any PackageReference items in the project, such as when
         a project targets .NET Framework and doesn't have any direct package dependencies. -->
    <RestoreProjectStyle>PackageReference</RestoreProjectStyle>
    <DesignTimeAssemblySearchPaths Condition=" '$(DesignTimeAssemblySearchPaths)' == '' ">$(AssemblySearchPaths)</DesignTimeAssemblySearchPaths>
    <AllowUnsafeBlocks Condition="'$(AllowUnsafeBlocks)'==''">false</AllowUnsafeBlocks>
    <TreatWarningsAsErrors Condition="'$(TreatWarningsAsErrors)'==''">false</TreatWarningsAsErrors>
    <Prefer32Bit Condition="'$(Prefer32Bit)'==''">false</Prefer32Bit>
    <PreferNativeArm64 Condition="'$(PreferNativeArm64)'==''">false</PreferNativeArm64>
    <SignAssembly Condition="'$(SignAssembly)'==''">false</SignAssembly>
    <DelaySign Condition="'$(DelaySign)'==''">false</DelaySign>
    <GeneratePackageOnBuild Condition="'$(GeneratePackageOnBuild)'==''">false</GeneratePackageOnBuild>
    <PackageRequireLicenseAcceptance Condition="'$(PackageRequireLicenseAcceptance)'==''">false</PackageRequireLicenseAcceptance>
    <DebugSymbols Condition="'$(DebugSymbols)'==''">false</DebugSymbols>
    <CheckForOverflowUnderflow Condition="'$(CheckForOverflowUnderflow)'==''">false</CheckForOverflowUnderflow>
    <AutomaticallyUseReferenceAssemblyPackages Condition="'$(AutomaticallyUseReferenceAssemblyPackages)'==''">true</AutomaticallyUseReferenceAssemblyPackages>
    <MicrosoftNETFrameworkReferenceAssembliesLatestPackageVersion>1.0.3</MicrosoftNETFrameworkReferenceAssembliesLatestPackageVersion>
    <CopyConflictingTransitiveContent>false</CopyConflictingTransitiveContent>
    <MSBuildCopyContentTransitively Condition="'$(MSBuildCopyContentTransitively)' == ''">true</MSBuildCopyContentTransitively>
    <ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts Condition="'$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)' == ''">true</ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts>
    <!-- Uncomment this once https://github.com/Microsoft/visualfsharp/issues/3207 gets fixed -->
    <!-- <WarningsAsErrors>$(WarningsAsErrors);NU1605</WarningsAsErrors> -->
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Path to project that the .NET CLI will build in order to generate deps.json files for .NET CLI tools -->
    <ToolDepsJsonGeneratorProject>$(MSBuildThisFileDirectory)GenerateDeps\GenerateDeps.proj</ToolDepsJsonGeneratorProject>
  </PropertyGroup>
  <!-- Default item includes (globs and implicit references) -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.DefaultItems.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.DefaultItems.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.DefaultItems.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(NETCoreSdkBundledVersionsProps)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETCoreSdkBundledVersionsProps>$(MSBuildThisFileDirectory)..\..\..\Microsoft.NETCoreSdk.BundledVersions.props</NETCoreSdkBundledVersionsProps>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NETCoreSdkBundledVersionsProps)" Condition="Exists('$(NETCoreSdkBundledVersionsProps)')">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Microsoft.NETCoreSdk.BundledVersions.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NETCoreSdk.BundledVersions.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <NetCoreRoot Condition="'$(NetCoreRoot)' == ''">$([MSBuild]::NormalizePath('$(MSBuildThisFileDirectory)../../'))</NetCoreRoot>
    <NetCoreTargetingPackRoot Condition="'$(NetCoreTargetingPackRoot)' == ''">$([MSBuild]::EnsureTrailingSlash('$(NetCoreRoot)'))packs</NetCoreTargetingPackRoot>
    <PrunePackageDataRoot Condition="'$(PrunePackageDataRoot)' == ''">$([MSBuild]::EnsureTrailingSlash('$(MSBuildThisFileDirectory)'))PrunePackageData</PrunePackageDataRoot>
    <_NetFrameworkHostedCompilersVersion>5.0.0-2.25420.111</_NetFrameworkHostedCompilersVersion>
    <NETCoreAppMaximumVersion>10.0</NETCoreAppMaximumVersion>
    <BundledNETCoreAppTargetFrameworkVersion>10.0</BundledNETCoreAppTargetFrameworkVersion>
    <BundledNETCoreAppPackageVersion>10.0.0-rc.1.25420.111</BundledNETCoreAppPackageVersion>
    <BundledNETStandardTargetFrameworkVersion>2.1</BundledNETStandardTargetFrameworkVersion>
    <BundledNETStandardPackageVersion>2.1.0</BundledNETStandardPackageVersion>
    <BundledNETCorePlatformsPackageVersion>10.0.0-rc.1.25420.111</BundledNETCorePlatformsPackageVersion>
    <BundledRuntimeIdentifierGraphFile>$(MSBuildThisFileDirectory)RuntimeIdentifierGraph.json</BundledRuntimeIdentifierGraphFile>
    <NETCoreSdkVersion>10.0.100-rc.1.25420.111</NETCoreSdkVersion>
    <SdkAnalysisLevel>10.0.100</SdkAnalysisLevel>
    <NETCoreSdkRuntimeIdentifier>linux-x64</NETCoreSdkRuntimeIdentifier>
    <NETCoreSdkPortableRuntimeIdentifier>linux-x64</NETCoreSdkPortableRuntimeIdentifier>
    <_NETCoreSdkIsPreview>true</_NETCoreSdkIsPreview>
  </PropertyGroup>
  <ItemGroup>
    <ImplicitPackageReferenceVersion Include="Microsoft.NETCore.App" TargetFrameworkVersion="1.0" DefaultVersion="1.0.5" LatestVersion="1.0.16" />
    <ImplicitPackageReferenceVersion Include="Microsoft.NETCore.App" TargetFrameworkVersion="1.1" DefaultVersion="1.1.2" LatestVersion="1.1.13" />
    <ImplicitPackageReferenceVersion Include="Microsoft.NETCore.App" TargetFrameworkVersion="2.0" DefaultVersion="2.0.0" LatestVersion="2.0.9" />
    <ImplicitPackageReferenceVersion Include="Microsoft.NETCore.App" TargetFrameworkVersion="2.1" DefaultVersion="2.1.0" LatestVersion="2.1.30" />
    <ImplicitPackageReferenceVersion Include="Microsoft.NETCore.App" TargetFrameworkVersion="2.2" DefaultVersion="2.2.0" LatestVersion="2.2.8" />
    <ImplicitPackageReferenceVersion Include="Microsoft.AspNetCore.App" TargetFrameworkVersion="2.1" DefaultVersion="2.1.1" LatestVersion="2.1.30" />
    <ImplicitPackageReferenceVersion Include="Microsoft.AspNetCore.All" TargetFrameworkVersion="2.1" DefaultVersion="2.1.1" LatestVersion="2.1.30" />
    <ImplicitPackageReferenceVersion Include="Microsoft.AspNetCore.App" TargetFrameworkVersion="2.2" DefaultVersion="2.2.0" LatestVersion="2.2.8" />
    <ImplicitPackageReferenceVersion Include="Microsoft.AspNetCore.All" TargetFrameworkVersion="2.2" DefaultVersion="2.2.0" LatestVersion="2.2.8" />
    <!-- .NET 10.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="10.0.0-rc.1.25420.111" LatestRuntimeFrameworkVersion="10.0.0-rc.1.25420.111" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="10.0.0-rc.1.25420.111" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-musl-loongarch64;android-arm64;android-x64" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="net10.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="10.0.0-rc.1.25420.111" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-musl-loongarch64" ExcludedRuntimeIdentifiers="android" />
    <KnownCrossgen2Pack Include="Microsoft.NETCore.App.Crossgen2" TargetFramework="net10.0" Crossgen2PackNamePattern="Microsoft.NETCore.App.Crossgen2.**RID**" Crossgen2PackVersion="10.0.0-rc.1.25420.111" Crossgen2RuntimeIdentifiers="linux-musl-x64;linux-x64;win-x64;linux-arm;linux-arm64;linux-musl-arm;linux-musl-arm64;osx-arm64;osx-x64;win-arm64;win-x86;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-loongarch64;linux-musl-loongarch64" />
    <KnownILCompilerPack Include="Microsoft.DotNet.ILCompiler" TargetFramework="net10.0" ILCompilerPackNamePattern="runtime.**RID**.Microsoft.DotNet.ILCompiler" ILCompilerRuntimePackNamePattern="Microsoft.NETCore.App.Runtime.NativeAOT.**RID**" ILCompilerPackVersion="10.0.0-rc.1.25420.111" ILCompilerRuntimeIdentifiers="linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;win-arm64;win-x64;osx-x64;osx-arm64;freebsd-x64;freebsd-arm64;linux-arm;linux-musl-arm;linux-loongarch64;linux-musl-loongarch64;win-x86;linux-riscv64;linux-musl-riscv64" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="10.0.0-rc.1.25420.111" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.NativeAOT.**RID**" RuntimePackRuntimeIdentifiers="ios-arm64;iossimulator-arm64;iossimulator-x64;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-arm64;maccatalyst-x64;linux-bionic-arm64;linux-bionic-x64;osx-arm64;osx-x64;freebsd-arm64;freebsd-x64;linux-x64;linux-arm;linux-arm64;linux-loongarch64;linux-bionic-arm;linux-musl-x64;linux-musl-arm;linux-musl-arm64;linux-musl-loongarch64;win-x64;win-x86;win-arm64;browser-wasm;wasi-wasm;linux-riscv64;linux-musl-riscv64;android-arm64;android-x64" RuntimePackLabels="NativeAOT" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="net10.0" ILLinkPackVersion="10.0.0-rc.1.25420.111" />
    <KnownWebAssemblySdkPack Include="Microsoft.NET.Sdk.WebAssembly.Pack" TargetFramework="net10.0" WebAssemblySdkPackVersion="10.0.0-rc.1.25420.111" />
    <KnownAspNetCorePack Include="Microsoft.AspNetCore.App.Internal.Assets" TargetFramework="net10.0" AspNetCorePackVersion="10.0.0-rc.1.25420.111" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="10.0.0-rc.1.25420.111" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.Mono.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;browser-wasm;ios-arm64;ios-arm;iossimulator-arm64;iossimulator-x64;iossimulator-x86;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-x64;maccatalyst-arm64;android-arm64;android-arm;android-x64;android-x86;freebsd-x64;freebsd-arm64;wasi-wasm;linux-riscv64;linux-musl-riscv64;linux-loongarch64;linux-musl-loongarch64" RuntimePackLabels="Mono" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="10.0.0-rc.1.25420.111" LatestRuntimeFrameworkVersion="10.0.0-rc.1.25420.111" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="10.0.0-rc.1.25420.111" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="10.0.0-rc.1.25420.111" LatestRuntimeFrameworkVersion="10.0.0-rc.1.25420.111" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="10.0.0-rc.1.25420.111" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="10.0.0-rc.1.25420.111" LatestRuntimeFrameworkVersion="10.0.0-rc.1.25420.111" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="10.0.0-rc.1.25420.111" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="10.0.0-rc.1.25420.111" LatestRuntimeFrameworkVersion="10.0.0-rc.1.25420.111" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="10.0.0-rc.1.25420.111" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;linux-musl-arm;win-arm64;osx-arm64;linux-s390x;linux-loongarch64;linux-ppc64le;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-loongarch64;linux-musl-loongarch64" RuntimePackExcludedRuntimeIdentifiers="android;linux-bionic" />
    <!-- .NET 9.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="9.0.0" LatestRuntimeFrameworkVersion="9.0.6" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="9.0.6" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-musl-loongarch64" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="net9.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="9.0.6" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-musl-loongarch64" ExcludedRuntimeIdentifiers="android" />
    <KnownCrossgen2Pack Include="Microsoft.NETCore.App.Crossgen2" TargetFramework="net9.0" Crossgen2PackNamePattern="Microsoft.NETCore.App.Crossgen2.**RID**" Crossgen2PackVersion="9.0.6" Crossgen2RuntimeIdentifiers="linux-musl-x64;linux-x64;win-x64;linux-arm;linux-arm64;linux-musl-arm;linux-musl-arm64;osx-arm64;osx-x64;win-arm64;win-x86;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-loongarch64;linux-musl-loongarch64" />
    <KnownILCompilerPack Include="Microsoft.DotNet.ILCompiler" TargetFramework="net9.0" ILCompilerPackNamePattern="runtime.**RID**.Microsoft.DotNet.ILCompiler" ILCompilerPackVersion="9.0.6" ILCompilerRuntimeIdentifiers="linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;win-arm64;win-x64;osx-x64;osx-arm64;freebsd-x64;freebsd-arm64;linux-arm;linux-musl-arm;linux-loongarch64;linux-musl-loongarch64;win-x86" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="9.0.6" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.NativeAOT.**RID**" RuntimePackRuntimeIdentifiers="ios-arm64;iossimulator-arm64;iossimulator-x64;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-arm64;maccatalyst-x64;linux-bionic-arm64;linux-bionic-x64;osx-arm64;osx-x64;freebsd-arm64;freebsd-x64;linux-x64;linux-arm;linux-arm64;linux-loongarch64;linux-bionic-arm;linux-musl-x64;linux-musl-arm;linux-musl-arm64;linux-musl-loongarch64;win-x64;win-x86;win-arm64;browser-wasm;wasi-wasm" RuntimePackLabels="NativeAOT" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="net9.0" ILLinkPackVersion="9.0.6" />
    <KnownWebAssemblySdkPack Include="Microsoft.NET.Sdk.WebAssembly.Pack" TargetFramework="net9.0" WebAssemblySdkPackVersion="10.0.0-rc.1.25420.111" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="9.0.6" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.Mono.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;browser-wasm;ios-arm64;ios-arm;iossimulator-arm64;iossimulator-x64;iossimulator-x86;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-x64;maccatalyst-arm64;android-arm64;android-arm;android-x64;android-x86;freebsd-x64;freebsd-arm64;wasi-wasm;linux-riscv64;linux-musl-riscv64;linux-loongarch64;linux-musl-loongarch64" RuntimePackLabels="Mono" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="9.0.0" LatestRuntimeFrameworkVersion="9.0.6" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="9.0.6" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="9.0.0" LatestRuntimeFrameworkVersion="9.0.6" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="9.0.6" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="9.0.0" LatestRuntimeFrameworkVersion="9.0.6" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="9.0.6" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="9.0.0" LatestRuntimeFrameworkVersion="9.0.6" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="9.0.6" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;linux-musl-arm;win-arm64;osx-arm64;linux-s390x;linux-loongarch64;linux-ppc64le;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-loongarch64;linux-musl-loongarch64" RuntimePackExcludedRuntimeIdentifiers="android;linux-bionic" />
    <!-- .NET 8.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="8.0.0" LatestRuntimeFrameworkVersion="8.0.17" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="8.0.17" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le;freebsd-x64;freebsd-arm64" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="net8.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="8.0.17" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le;freebsd-x64;freebsd-arm64" ExcludedRuntimeIdentifiers="android" />
    <KnownCrossgen2Pack Include="Microsoft.NETCore.App.Crossgen2" TargetFramework="net8.0" Crossgen2PackNamePattern="Microsoft.NETCore.App.Crossgen2.**RID**" Crossgen2PackVersion="8.0.17" Crossgen2RuntimeIdentifiers="linux-musl-x64;linux-x64;win-x64;linux-arm;linux-arm64;linux-musl-arm;linux-musl-arm64;osx-arm64;osx-x64;win-arm64;win-x86;freebsd-x64;freebsd-arm64" />
    <KnownILCompilerPack Include="Microsoft.DotNet.ILCompiler" TargetFramework="net8.0" ILCompilerPackNamePattern="runtime.**RID**.Microsoft.DotNet.ILCompiler" ILCompilerPackVersion="8.0.17" ILCompilerRuntimeIdentifiers="linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;win-arm64;win-x64;osx-x64;osx-arm64;freebsd-x64;freebsd-arm64" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="8.0.17" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.NativeAOT.**RID**" RuntimePackRuntimeIdentifiers="ios-arm64;iossimulator-arm64;iossimulator-x64;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-arm64;maccatalyst-x64;linux-bionic-arm64;linux-bionic-x64;osx-arm64;osx-x64;freebsd-arm64;freebsd-x64" RuntimePackLabels="NativeAOT" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="net8.0" ILLinkPackVersion="8.0.17" />
    <KnownWebAssemblySdkPack Include="Microsoft.NET.Sdk.WebAssembly.Pack" TargetFramework="net8.0" WebAssemblySdkPackVersion="10.0.0-rc.1.25420.111" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="8.0.17" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.Mono.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;browser-wasm;ios-arm64;ios-arm;iossimulator-arm64;iossimulator-x64;iossimulator-x86;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-x64;maccatalyst-arm64;android-arm64;android-arm;android-x64;android-x86;freebsd-x64;freebsd-arm64;wasi-wasm" RuntimePackLabels="Mono" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="8.0.0" LatestRuntimeFrameworkVersion="8.0.17" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="8.0.17" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="8.0.0" LatestRuntimeFrameworkVersion="8.0.17" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="8.0.17" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="8.0.0" LatestRuntimeFrameworkVersion="8.0.17" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="8.0.17" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="8.0.0" LatestRuntimeFrameworkVersion="8.0.17" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="8.0.17" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;linux-musl-arm;win-arm64;osx-arm64;linux-s390x;linux-loongarch64;linux-ppc64le;freebsd-x64;freebsd-arm64" RuntimePackExcludedRuntimeIdentifiers="android;linux-bionic" />
    <!-- .NET 7.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="net7.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="7.0.0" LatestRuntimeFrameworkVersion="7.0.20" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="7.0.20" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="net7.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="7.0.20" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le" ExcludedRuntimeIdentifiers="android" />
    <KnownCrossgen2Pack Include="Microsoft.NETCore.App.Crossgen2" TargetFramework="net7.0" Crossgen2PackNamePattern="Microsoft.NETCore.App.Crossgen2.**RID**" Crossgen2PackVersion="7.0.20" Crossgen2RuntimeIdentifiers="linux-musl-x64;linux-x64;win-x64;linux-arm;linux-arm64;linux-musl-arm;linux-musl-arm64;osx-arm64;osx-x64;win-arm;win-arm64;win-x86" />
    <KnownILCompilerPack Include="Microsoft.DotNet.ILCompiler" TargetFramework="net7.0" ILCompilerPackNamePattern="runtime.**RID**.Microsoft.DotNet.ILCompiler" ILCompilerPackVersion="7.0.20" ILCompilerRuntimeIdentifiers="linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;win-arm64;win-x64" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="net7.0" ILLinkPackVersion="7.0.100-1.23211.1" />
    <KnownWebAssemblySdkPack Include="Microsoft.NET.Sdk.WebAssembly.Pack" TargetFramework="net7.0" WebAssemblySdkPackVersion="10.0.0-rc.1.25420.111" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net7.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="7.0.20" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.Mono.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;browser-wasm;ios-arm64;ios-arm;iossimulator-arm64;iossimulator-x64;iossimulator-x86;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-x64;maccatalyst-arm64;android-arm64;android-arm;android-x64;android-x86" RuntimePackLabels="Mono" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="net7.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="7.0.0" LatestRuntimeFrameworkVersion="7.0.20" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="7.0.20" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="net7.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="7.0.0" LatestRuntimeFrameworkVersion="7.0.20" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="7.0.20" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="net7.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="7.0.0" LatestRuntimeFrameworkVersion="7.0.20" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="7.0.20" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="net7.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="7.0.0" LatestRuntimeFrameworkVersion="7.0.20" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="7.0.20" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;linux-musl-arm;win-arm64;osx-arm64;linux-s390x;linux-loongarch64;linux-ppc64le" RuntimePackExcludedRuntimeIdentifiers="android" />
    <!-- .NET 6.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="net6.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="6.0.0" LatestRuntimeFrameworkVersion="6.0.36" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="6.0.36" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="net6.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="6.0.36" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64" ExcludedRuntimeIdentifiers="android" />
    <KnownCrossgen2Pack Include="Microsoft.NETCore.App.Crossgen2" TargetFramework="net6.0" Crossgen2PackNamePattern="Microsoft.NETCore.App.Crossgen2.**RID**" Crossgen2PackVersion="6.0.36" Crossgen2RuntimeIdentifiers="linux-musl-x64;linux-x64;win-x64;linux-arm;linux-arm64;linux-musl-arm;linux-musl-arm64;osx-arm64;osx-x64;win-arm;win-arm64;win-x86" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="net6.0" ILLinkPackVersion="7.0.100-1.23211.1" />
    <KnownWebAssemblySdkPack Include="Microsoft.NET.Sdk.WebAssembly.Pack" TargetFramework="net6.0" WebAssemblySdkPackVersion="10.0.0-rc.1.25420.111" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net6.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="6.0.36" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.Mono.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;browser-wasm;ios-arm64;ios-arm;iossimulator-arm64;iossimulator-x64;iossimulator-x86;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-x64;maccatalyst-arm64;android-arm64;android-arm;android-x64;android-x86" RuntimePackLabels="Mono" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="net6.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="6.0.0" LatestRuntimeFrameworkVersion="6.0.36" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="6.0.36" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="net6.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="6.0.0" LatestRuntimeFrameworkVersion="6.0.36" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="6.0.36" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="net6.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="6.0.0" LatestRuntimeFrameworkVersion="6.0.36" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="6.0.36" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="net6.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="6.0.0" LatestRuntimeFrameworkVersion="6.0.36" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="6.0.36" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;linux-musl-arm;win-arm64;osx-arm64;linux-s390x;linux-loongarch64" />
    <!-- .NET 5.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="net5.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="5.0.0" LatestRuntimeFrameworkVersion="5.0.17" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="5.0.0" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;browser-wasm" IsTrimmable="true" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="net5.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="5.0.17" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm" />
    <KnownCrossgen2Pack Include="Microsoft.NETCore.App.Crossgen2" TargetFramework="net5.0" Crossgen2PackNamePattern="Microsoft.NETCore.App.Crossgen2.**RID**" Crossgen2PackVersion="5.0.17" Crossgen2RuntimeIdentifiers="linux-musl-x64;linux-x64;win-x64" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="net5.0" ILLinkPackVersion="7.0.100-1.23211.1" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="net5.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="5.0.0" LatestRuntimeFrameworkVersion="5.0.17" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="5.0.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="net5.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="5.0.0" LatestRuntimeFrameworkVersion="5.0.17" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="5.0.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="net5.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="5.0.0" LatestRuntimeFrameworkVersion="5.0.17" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="5.0.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="net5.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="5.0.0" LatestRuntimeFrameworkVersion="5.0.17" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="5.0.0" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;linux-musl-arm;win-arm64" />
    <!-- .NET Core 3.1  -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="netcoreapp3.1" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="3.1.0" LatestRuntimeFrameworkVersion="3.1.32" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="3.1.0" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86" IsTrimmable="true" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="netcoreapp3.1" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="3.1.32" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="netcoreapp3.1" ILLinkPackVersion="7.0.100-1.23211.1" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="netcoreapp3.1" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="3.1.0" LatestRuntimeFrameworkVersion="3.1.32" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="3.1.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="netcoreapp3.1" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="3.1.0" LatestRuntimeFrameworkVersion="3.1.32" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="3.1.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="netcoreapp3.1" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="3.1.0" LatestRuntimeFrameworkVersion="3.1.32" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="3.1.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="netcoreapp3.1" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="3.1.0" LatestRuntimeFrameworkVersion="3.1.32" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="3.1.10" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64" />
    <!-- .NET Core 3.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="netcoreapp3.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="3.0.0" LatestRuntimeFrameworkVersion="3.0.3" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="3.0.0" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86" IsTrimmable="true" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="netcoreapp3.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="3.0.3" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="netcoreapp3.0" ILLinkPackVersion="7.0.100-1.23211.1" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="netcoreapp3.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="3.0.0" LatestRuntimeFrameworkVersion="3.0.3" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="3.0.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="netcoreapp3.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="3.0.0" LatestRuntimeFrameworkVersion="3.0.3" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="3.0.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="netcoreapp3.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="3.0.0" LatestRuntimeFrameworkVersion="3.0.3" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="3.0.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="netcoreapp3.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="3.0.0" LatestRuntimeFrameworkVersion="3.0.3" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="3.0.1" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64" />
    <KnownFrameworkReference Include="NETStandard.Library" TargetFramework="netstandard2.1" TargetingPackName="NETStandard.Library.Ref" TargetingPackVersion="2.1.0" />
    <!-- Supported Windows versions -->
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.26100.0" WindowsSdkPackageVersion="10.0.26100.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.22621.0" WindowsSdkPackageVersion="10.0.22621.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.22000.0" WindowsSdkPackageVersion="10.0.22000.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.20348.0" WindowsSdkPackageVersion="10.0.20348.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.19041.0" WindowsSdkPackageVersion="10.0.19041.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.18362.0" WindowsSdkPackageVersion="10.0.18362.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.17763.0" WindowsSdkPackageVersion="10.0.17763.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.26100.0" WindowsSdkPackageVersion="10.0.26100.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.22621.0" WindowsSdkPackageVersion="10.0.22621.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.22000.0" WindowsSdkPackageVersion="10.0.22000.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.20348.0" WindowsSdkPackageVersion="10.0.20348.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.19041.0" WindowsSdkPackageVersion="10.0.19041.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.18362.0" WindowsSdkPackageVersion="10.0.18362.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.17763.0" WindowsSdkPackageVersion="10.0.17763.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.22000.0" WindowsSdkPackageVersion="10.0.22000.26" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.20348.0" WindowsSdkPackageVersion="10.0.20348.26" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.19041.0" WindowsSdkPackageVersion="10.0.19041.26" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.18362.0" WindowsSdkPackageVersion="10.0.18362.26" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.17763.0" WindowsSdkPackageVersion="10.0.17763.26" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="7.0" />
    <_KnownRuntimeIdentiferPlatforms Include="any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix" />
    <_ExcludedKnownRuntimeIdentiferPlatforms Include="rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.DefaultItems.props
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(NETCoreSdkBundledMSBuildInformationProps)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETCoreSdkBundledMSBuildInformationProps>$(MSBuildThisFileDirectory)..\..\..\Microsoft.NETCoreSdk.BundledMSBuildInformation.props</NETCoreSdkBundledMSBuildInformationProps>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NETCoreSdkBundledMSBuildInformationProps)" Condition="Exists('$(NETCoreSdkBundledMSBuildInformationProps)')">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Microsoft.NETCoreSdk.BundledMSBuildInformation.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NETCoreSdk.BundledMSBuildInformation.props
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.
Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <MinimumMSBuildVersion>17.13.0</MinimumMSBuildVersion>
    <BundledMSBuildVersion>17.15.0</BundledMSBuildVersion>
    <_MSBuildVersionMajorMinor>$([System.Version]::Parse('$(MSBuildVersion)').ToString(2))</_MSBuildVersionMajorMinor>
    <_IsDisjointMSBuildVersion>$([MSBuild]::VersionLessThan('$(_MSBuildVersionMajorMinor)', '17.15'))</_IsDisjointMSBuildVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.DefaultItems.props
============================================================================================================================================
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Disable web SDK implicit package versions for ASP.NET packages, since the .NET SDK now handles that -->
    <EnableWebSdkImplicitPackageVersions>false</EnableWebSdkImplicitPackageVersions>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <__WindowsAppSdkDefaultImageIncludes>**/*.png;**/*.bmp;**/*.jpg;**/*.dds;**/*.tif;**/*.tga;**/*.gif</__WindowsAppSdkDefaultImageIncludes>
  </PropertyGroup>
  <ItemGroup Condition=" '$(EnableDefaultItems)' == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Compile Include="**/*$(DefaultLanguageSourceExtension)" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" Condition=" '$(EnableDefaultCompileItems)' == 'true' " />
    <EmbeddedResource Include="**/*.resx" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" Condition=" '$(EnableDefaultEmbeddedResourceItems)' == 'true' " />
    <!-- Microsoft.WindowsAppSDK is a NuGet delivered SDK. EnableDefaultWindowsAppSdkContentItems and EnableDefaultWindowsAppSdkPRIResourceItems are overridable properties that the SDK will set to true by default. -->
    <Content Include="$(__WindowsAppSdkDefaultImageIncludes)" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" Condition=" '$(EnableDefaultContentItems)' != 'false' And '$(EnableDefaultWindowsAppSdkContentItems)' == 'true' " />
    <PRIResource Include="**/*.resw" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" Condition=" '$(EnableDefaultPRIResourceItems)' != 'false' And '$(EnableDefaultWindowsAppSdkPRIResourceItems)' == 'true' " />
  </ItemGroup>
  <ItemGroup Condition=" '$(EnableDefaultItems)' == 'true' And '$(EnableDefaultNoneItems)' == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <None Include="**/*" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" />
    <None Remove="**/*$(DefaultLanguageSourceExtension)" />
    <None Remove="**/*.resx" />
    <!-- Microsoft.WindowsAppSDK is a NuGet delivered SDK. EnableDefaultWindowsAppSdkContentItems and EnableDefaultWindowsAppSdkPRIResourceItems are overridable properties that the SDK will set to true by default. -->
    <None Remove="$(__WindowsAppSdkDefaultImageIncludes)" Condition=" '$(EnableDefaultWindowsAppSdkContentItems)' == 'true' " />
    <None Remove="**/*.resw" Condition=" '$(EnableDefaultWindowsAppSdkPRIResourceItems)' == 'true' " />
  </ItemGroup>
  <!-- Automatically reference NETStandard.Library or Microsoft.NETCore.App package if targeting the corresponding target framework.
      We can refer here in the .props file to properties set in the .targets files because items and their conditions are
      evaluated in the second pass of evaluation, after all properties have been evaluated. -->
  <ItemGroup Condition=" '$(DisableImplicitFrameworkReferences)' != 'true' and '$(TargetFrameworkIdentifier)' == '.NETStandard' And '$(_TargetFrameworkVersionWithoutV)' &lt; '2.1'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PackageReference Include="NETStandard.Library" Version="$(NETStandardImplicitPackageVersion)" IsImplicitlyDefined="true" />
    <!-- If targeting .NET Standard 2.0 or higher, then don't include a dependency on NETStandard.Library in the package produced by pack -->
    <PackageReference Update="NETStandard.Library" Condition=" ('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &gt;= '2.0') " PrivateAssets="All" Publish="true" />
  </ItemGroup>
  <ItemGroup Condition=" '$(DisableImplicitFrameworkReferences)' != 'true' and '$(TargetFrameworkIdentifier)' == '.NETStandard' And '$(_TargetFrameworkVersionWithoutV)' &gt;= '2.1'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <FrameworkReference Include="NETStandard.Library" IsImplicitlyDefined="true" Pack="false" PrivateAssets="All" />
  </ItemGroup>
  <ItemGroup Condition=" '$(DisableImplicitFrameworkReferences)' != 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Use implicit PackageReference for Microsoft.NETCore.App on versions prior to 3.0.  For 3.0 or higher, use
         an implicit FrameworkReference -->
    <PackageReference Include="Microsoft.NETCore.App" IsImplicitlyDefined="true" Condition="('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &lt; '3.0')" />
    <!-- For targeting .NET Core 2.0 or higher, don't include a dependency on Microsoft.NETCore.App in the package produced by pack.
         Packing an DotnetCliTool should include the Microsoft.NETCore.App package dependency. -->
    <PackageReference Update="Microsoft.NETCore.App" Condition="('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &gt;= '2.0') And ('$(PackageType)' != 'DotnetCliTool')" PrivateAssets="All" Publish="true" />
    <FrameworkReference Include="Microsoft.NETCore.App" IsImplicitlyDefined="true" Pack="false" PrivateAssets="All" Condition="('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0')" />
    <!-- Allow opt-in to Mono runtime pack for .NET 6.0 or higher -->
    <FrameworkReference Update="Microsoft.NETCore.App" RuntimePackLabels="Mono" Condition="'$(UseMonoRuntime)' == 'true' And ('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &gt;= '6.0')" />
    <!-- Allow opt-in to NativeAOT runtime pack for .NET 8.0 or higher -->
    <FrameworkReference Update="Microsoft.NETCore.App" RuntimePackLabels="NativeAOT" Condition="'$(_IsPublishing)' == 'true' and '$(PublishAotUsingRuntimePack)' == 'true' And ('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &gt;= '8.0')" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!-- Put workload resolution behind a feature flag.  It can be enabled either by setting the MSBuildEnableWorkloadResolver environment variable to true, or by
       putting an EnableWorkloadResolver.sentinel file beside the MSBuild SDK resolver DLL -->
  <PropertyGroup Condition="'$(MSBuildEnableWorkloadResolver)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <__DisableWorkloadResolverSentinelPath Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildBinPath)\DisableWorkloadResolver.sentinel</__DisableWorkloadResolverSentinelPath>
    <__DisableWorkloadResolverSentinelPath Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildToolsPath32)\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\DisableWorkloadResolver.sentinel</__DisableWorkloadResolverSentinelPath>
    <MSBuildEnableWorkloadResolver Condition="!Exists('$(__DisableWorkloadResolverSentinelPath)')">true</MSBuildEnableWorkloadResolver>
  </PropertyGroup>
  <!-- Import workload props -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.ImportWorkloads.props" Condition="'$(MSBuildEnableWorkloadResolver)' == 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.ImportWorkloads.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.ImportWorkloads.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Import workload props -->
  <!--<Import Project="AutoImport.props" Sdk="Microsoft.NET.SDK.WorkloadAutoImportPropsLocator" />-->
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!-- List of supported .NET Core and .NET Standard TFMs -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.SupportedTargetFrameworks.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.SupportedTargetFrameworks.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.SupportedTargetFrameworks.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- This file contains a list of the TFMs that are supported by this SDK for .NET Core, .NET Standard, and .NET Framework.
     This is used by VS to show the list of frameworks to which projects can be retargeted. -->
  <!-- .NET Core App -->
  <ItemGroup>
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v1.0" DisplayName=".NET Core 1.0" Alias="netcoreapp1.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v1.1" DisplayName=".NET Core 1.1" Alias="netcoreapp1.1" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v2.0" DisplayName=".NET Core 2.0" Alias="netcoreapp2.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v2.1" DisplayName=".NET Core 2.1" Alias="netcoreapp2.1" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v2.2" DisplayName=".NET Core 2.2" Alias="netcoreapp2.2" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v3.0" DisplayName=".NET Core 3.0" Alias="netcoreapp3.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v3.1" DisplayName=".NET Core 3.1" Alias="netcoreapp3.1" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v5.0" DisplayName=".NET 5.0" Alias="net5.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v6.0" DisplayName=".NET 6.0" Alias="net6.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v7.0" DisplayName=".NET 7.0" Alias="net7.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v8.0" DisplayName=".NET 8.0" Alias="net8.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v9.0" DisplayName=".NET 9.0" Alias="net9.0" Condition="$([MSBuild]::VersionGreaterThanOrEquals($(MSBuildVersion), '17.12.0'))" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v10.0" DisplayName=".NET 10.0" Alias="net10.0" />
  </ItemGroup>
  <PropertyGroup>
    <!-- This is for a better error experience when using an older VS (with an older SDK) to target a newer TFM. The value should be the min VS version for N+1 version-->
    <UnsupportedTargetFrameworkVersion>$([MSBuild]::Add($(NETCoreAppMaximumVersion), 1)).0</UnsupportedTargetFrameworkVersion>
    <MinimumVisualStudioVersionForUnsupportedTargetFrameworkVersion>17.16</MinimumVisualStudioVersionForUnsupportedTargetFrameworkVersion>
  </PropertyGroup>
  <!-- .NET Standard -->
  <ItemGroup>
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.0" DisplayName=".NET Standard 1.0" Alias="netstandard1.0" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.1" DisplayName=".NET Standard 1.1" Alias="netstandard1.1" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.2" DisplayName=".NET Standard 1.2" Alias="netstandard1.2" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.3" DisplayName=".NET Standard 1.3" Alias="netstandard1.3" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.4" DisplayName=".NET Standard 1.4" Alias="netstandard1.4" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.5" DisplayName=".NET Standard 1.5" Alias="netstandard1.5" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.6" DisplayName=".NET Standard 1.6" Alias="netstandard1.6" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v2.0" DisplayName=".NET Standard 2.0" Alias="netstandard2.0" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v2.1" DisplayName=".NET Standard 2.1" Alias="netstandard2.1" />
  </ItemGroup>
  <!-- .NET Framework -->
  <ItemGroup>
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v2.0" DisplayName=".NET Framework 2.0" Alias="net20" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v3.0" DisplayName=".NET Framework 3.0" Alias="net30" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v3.5" DisplayName=".NET Framework 3.5" Alias="net35" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.0" DisplayName=".NET Framework 4.0" Alias="net40" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.5" DisplayName=".NET Framework 4.5" Alias="net45" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.5.1" DisplayName=".NET Framework 4.5.1" Alias="net451" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.5.2" DisplayName=".NET Framework 4.5.2" Alias="net452" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.6" DisplayName=".NET Framework 4.6" Alias="net46" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.6.1" DisplayName=".NET Framework 4.6.1" Alias="net461" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.6.2" DisplayName=".NET Framework 4.6.2" Alias="net462" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.7" DisplayName=".NET Framework 4.7" Alias="net47" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.7.1" DisplayName=".NET Framework 4.7.1" Alias="net471" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.7.2" DisplayName=".NET Framework 4.7.2" Alias="net472" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.8" DisplayName=".NET Framework 4.8" Alias="net48" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.8.1" DisplayName=".NET Framework 4.8.1" Alias="net481" />
  </ItemGroup>
  <!-- All supported target frameworks -->
  <ItemGroup>
    <SupportedTargetFramework Include="@(SupportedNETCoreAppTargetFramework);@(SupportedNETStandardTargetFramework);@(SupportedNETFrameworkTargetFramework)" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!-- List of supported target platforms -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.SupportedPlatforms.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.SupportedPlatforms.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.SupportedPlatforms.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <ItemGroup>
    <!-- Platforms supported by this SDK for analyzer warnings. Spec: https://github.com/dotnet/designs/blob/main/accepted/2020/platform-exclusion/platform-exclusion.md  -->
    <SupportedPlatform Include="Linux" />
    <SupportedPlatform Include="macOS" />
    <SupportedPlatform Include="Windows" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!-- List of supported .NET windows target platform versions -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.WindowsSdkSupportedTargetPlatforms.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.WindowsSdkSupportedTargetPlatforms.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.WindowsSdkSupportedTargetPlatforms.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- This file contains a list of the windows target platform versions that are supported by this SDK for .NET. Supported versions are processed in _NormalizeTargetPlatformVersion -->
  <!-- These will be added to the BundledVersions.props that's generated in dotnet/installer.  So only add them here if we don't have that change yet -->
  <ItemGroup Condition="'@(WindowsSdkSupportedTargetPlatformVersion)' == ''">
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.19041.0" WindowsSdkPackageVersion="10.0.19041.16" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.18362.0" WindowsSdkPackageVersion="10.0.18362.16" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.17763.0" WindowsSdkPackageVersion="10.0.17763.16" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="7.0" />
  </ItemGroup>
  <ItemGroup>
    <SdkSupportedTargetPlatformVersion Condition="'$(TargetPlatformIdentifier)' == 'Windows'" Include="@(WindowsSdkSupportedTargetPlatformVersion)" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.SourceLink.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.SourceLink.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Suppress implicit SourceLink inclusion if any Microsoft.SourceLink package is referenced. -->
    <SuppressImplicitGitSourceLink Condition="'$(PkgMicrosoft_SourceLink_Common)' != ''">true</SuppressImplicitGitSourceLink>
    <_SourceLinkPropsImported>true</_SourceLinkPropsImported>
  </PropertyGroup>
  <!--<ImportGroup Condition="'$(SuppressImplicitGitSourceLink)' != 'true'">-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.Build.Tasks.Git\build\Microsoft.Build.Tasks.Git.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.Build.Tasks.Git/build/Microsoft.Build.Tasks.Git.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <PropertyGroup>
    <MicrosoftBuildTasksGitAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\Microsoft.Build.Tasks.Git.dll</MicrosoftBuildTasksGitAssemblyFile>
    <MicrosoftBuildTasksGitAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\Microsoft.Build.Tasks.Git.dll</MicrosoftBuildTasksGitAssemblyFile>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.Common\build\Microsoft.SourceLink.Common.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.SourceLink.Common/build/Microsoft.SourceLink.Common.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <PropertyGroup>
    <_MicrosoftSourceLinkCommonAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\Microsoft.SourceLink.Common.dll</_MicrosoftSourceLinkCommonAssemblyFile>
    <_MicrosoftSourceLinkCommonAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\Microsoft.SourceLink.Common.dll</_MicrosoftSourceLinkCommonAssemblyFile>
  </PropertyGroup>
  <PropertyGroup>
    <!--
      Used to suppress querying source control and features that use the information (e.g. git commit SHA).
    -->
    <EnableSourceControlManagerQueries Condition="'$(EnableSourceControlManagerQueries)' == ''">true</EnableSourceControlManagerQueries>
    <!--
      Do not generate SourceLink when building in the IDE or for Live Unit Testing.
    -->
    <EnableSourceLink Condition="'$(EnableSourceLink)' == '' and '$(DesignTimeBuild)' != 'true' and '$(BuildingForLiveUnitTesting)' != 'true'">true</EnableSourceLink>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.GitHub\build\Microsoft.SourceLink.GitHub.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.SourceLink.GitHub/build/Microsoft.SourceLink.GitHub.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <ItemGroup>
    <SourceLinkGitHubHost Include="github.com" ContentUrl="https://raw.githubusercontent.com" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.GitLab\build\Microsoft.SourceLink.GitLab.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.SourceLink.GitLab/build/Microsoft.SourceLink.GitLab.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <ItemGroup>
    <SourceLinkGitLabHost Include="gitlab.com" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.AzureRepos.Git\build\Microsoft.SourceLink.AzureRepos.Git.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.SourceLink.AzureRepos.Git/build/Microsoft.SourceLink.AzureRepos.Git.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <ItemGroup>
    <SourceLinkAzureReposGitHost Include="visualstudio.com" />
    <SourceLinkAzureReposGitHost Include="vsts.me" />
    <SourceLinkAzureReposGitHost Include="dev.azure.com" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.Bitbucket.Git\build\Microsoft.SourceLink.Bitbucket.Git.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.SourceLink.Bitbucket.Git/build/Microsoft.SourceLink.Bitbucket.Git.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <ItemGroup>
    <SourceLinkBitbucketGitHost Include="bitbucket.org" EnterpriseEdition="false" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.CSharp.props" Condition="'$(MSBuildProjectExtension)' == '.csproj'" />-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.VisualBasic.props" Condition="'$(MSBuildProjectExtension)' == '.vbproj'" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.FSharp.props" Condition="'$(MSBuildProjectExtension)' == '.fsproj'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.FSharp.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.FSharp.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- If any of these variables are set then we are building under the FSharp.NET.Sdk so use their logic -->
  <PropertyGroup Condition="'$(UseBundledFSharpTargets)' == '' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- If any of these variables are set then we are building under the FSharp.NET.Sdk so use their logic -->
    <UseBundledFSharpTargets Condition=" '$(_FscTaskAssemblyPath_net)' != '' or '$(_FscTaskAssemblyPath_netcoreapp1_0)' != '' or '$(_FscToolFullPath_net)' != '' or '$(_FscToolFullPath_netcoreapp1_0)' != '' ">false</UseBundledFSharpTargets>
    <UseBundledFSharpTargets Condition="'$(UseBundledFSharpTargets)' == '' ">true</UseBundledFSharpTargets>
  </PropertyGroup>
  <!-- Shim to select the correct Microsoft.NET.Sdk.FSharp.props file.
       If running under desktop select Microsoft.NET.Sdk.FSharp.props file from VS deployment,
       if running core msbuild select Microsoft.NET.Sdk.FSharp.props from dotnet cli deployment -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <FSharpPropsShim Condition=" '$(FSharpPropsShim)' == '' and Exists('$(MSBuildToolsPath)\FSharp\Microsoft.FSharp.NetSdk.props') ">$(MSBuildToolsPath)\FSharp\Microsoft.FSharp.NetSdk.props</FSharpPropsShim>
    <FSharpPropsShim Condition=" '$(FSharpPropsShim)' == '' and Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\FSharp\Microsoft.FSharp.NetSdk.props') ">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\FSharp\Microsoft.FSharp.NetSdk.props</FSharpPropsShim>
  </PropertyGroup>
  <!--<Import Project="$(FSharpPropsShim)" Condition=" '$(UseBundledFSharpTargets)' == 'true' and Exists('$(FSharpPropsShim)') " />-->
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PackTool.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.PackTool.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.PackTool.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PackProjectTool.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.PackProjectTool.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.PackProjectTool.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- This UsingTask is in the PackTool.props because there is usage of it in other areas of the product
       and on public GitHub: https://github.com/search?q=path%3A*.props+OR+path%3A*.targets+AND+%28NOT+path%3A*%2FMicrosoft.NET.PackTool.targets%29+AND+%28NOT+path%3A*%2FMicrosoft.NET.Publish.targets%29+GetNuGetShortFolderName&amp;type=code -->
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.GetNuGetShortFolderName" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetsForTfmSpecificContentInPackage>$(TargetsForTfmSpecificContentInPackage);_PackProjectToolValidation</TargetsForTfmSpecificContentInPackage>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)../../Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.props" Condition="Exists('$(MSBuildThisFileDirectory)../../Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.props')">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.props
============================================================================================================================================
-->
  <ItemDefinitionGroup Condition=" '$(_EnableWindowsDesktopGlobbing)' == 'true' ">
    <ApplicationDefinition>
      <Generator>MSBuild:Compile</Generator>
      <XamlRuntime>$(DefaultXamlRuntime)</XamlRuntime>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Page>
      <Generator>MSBuild:Compile</Generator>
      <XamlRuntime>$(DefaultXamlRuntime)</XamlRuntime>
      <SubType>Designer</SubType>
    </Page>
  </ItemDefinitionGroup>
  <ItemGroup Condition=" '$(_EnableWindowsDesktopGlobbing)' == 'true' ">
    <ApplicationDefinition Include="App.xaml" Condition="'$(EnableDefaultApplicationDefinition)' != 'false' And Exists('$(MSBuildProjectDirectory)/App.xaml') And '$(MSBuildProjectExtension)' == '.csproj'" />
    <ApplicationDefinition Include="Application.xaml" Condition="'$(EnableDefaultApplicationDefinition)' != 'false' And Exists('$(MSBuildProjectDirectory)/Application.xaml') And '$(MSBuildProjectExtension)' == '.vbproj'" />
    <Page Include="**/*.xaml" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder);@(ApplicationDefinition)" Condition="'$(EnableDefaultPageItems)' != 'false'" />
    <!--
      See https://github.com/dotnet/wpf/issues/685
      Visual Studio would prefer that we remove **/*.xaml instead of
      being more precise.

      <None Remove="@(Page)"
              Condition="'$(EnableDefaultPageItems)' != 'false'" />
      <None Remove="@(ApplicationDefinition)"
            Condition="'$(EnableDefaultApplicationDefinition)' != 'false'" />
    -->
    <None Remove="**/*.xaml" Condition="'$(EnableDefaultApplicationDefinition)' != 'false' And '$(EnableDefaultPageItems)' != 'false'" />
  </ItemGroup>
  <ItemGroup Condition=" '$(_EnableWindowsDesktopNetCoreFrameworkReferences)' == 'true' ">
    <FrameworkReference Include="Microsoft.WindowsDesktop.App" IsImplicitlyDefined="true" Condition="('$(UseWPF)' == 'true') And ('$(UseWindowsForms)' == 'true')" />
    <FrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" IsImplicitlyDefined="true" Condition="('$(UseWPF)' == 'true') And ('$(UseWindowsForms)' != 'true')" />
    <FrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" IsImplicitlyDefined="true" Condition="('$(UseWPF)' != 'true') And ('$(UseWindowsForms)' == 'true')" />
  </ItemGroup>
  <!--
    Traditionally, Visual Studio has supplied these references for .NET Framework based
    WPF Projects:

    .NET 3.x:   PresentationCore, PresentationFramework, WindowsBase
    .NET 4.x:   PresentationCore, PresentationFramework, WindowsBase, System.Xaml


    Microsoft.NET.WindowsDesktop.SDK will supply the following references to .NET Framework based
    WPF Projects:

    .NET 3.x:   PresentationCore, PresentationFramework, WindowsBase

    .NET 4.0:   PresentationCore, PresentationFramework, WindowsBase, System.Xaml,
                UIAutomationClient, UIAutomationClientSideProviders, UIAutomationProvider, UIAutomationTypes

    .NET 4.5+:  PresentationCore, PresentationFramework, WindowsBase, System.Xaml,
                UIAutomationClient, UIAutomationClientSideProviders, UIAutomationProvider, UIAutomationTypes
                System.Windows.Controls.Ribbon
  -->
  <ItemGroup Condition=" '$(_EnableWindowsDesktopNETFrameworkImplicitReference)' == 'true' ">
    <!--
      The following 3 _WpfCommonNetFxReference items normally require Condition="'$(_TargetFrameworkVersionValue)' >= '3.0'", since
      they are supported on .NET Framework 3.0 and above.

      This condition is implicitly satisfied by '$(_TargetFrameworkVersionValue)' >= '$(_WindowsDesktopSdkTargetFrameworkVersionFloor)'
      in the outer ItemGroup
    -->
    <_WpfCommonNetFxReference Include="WindowsBase" />
    <_WpfCommonNetFxReference Include="PresentationCore" />
    <_WpfCommonNetFxReference Include="PresentationFramework" />
    <_WpfCommonNetFxReference Include="System.Xaml" Condition="'$(_TargetFrameworkVersionValue)' != '' And '$(_TargetFrameworkVersionValue)' &gt;= '4.0'">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </_WpfCommonNetFxReference>
    <_WpfCommonNetFxReference Include="UIAutomationClient" Condition="'$(_TargetFrameworkVersionValue)' != '' And '$(_TargetFrameworkVersionValue)' &gt;= '4.0'" />
    <_WpfCommonNetFxReference Include="UIAutomationClientSideProviders" Condition="'$(_TargetFrameworkVersionValue)' != '' And '$(_TargetFrameworkVersionValue)' &gt;= '4.0'" />
    <_WpfCommonNetFxReference Include="UIAutomationProvider" Condition="'$(_TargetFrameworkVersionValue)' != '' And '$(_TargetFrameworkVersionValue)' &gt;= '4.0'" />
    <_WpfCommonNetFxReference Include="UIAutomationTypes" Condition="'$(_TargetFrameworkVersionValue)' != '' And '$(_TargetFrameworkVersionValue)' &gt;= '4.0'" />
    <_WpfCommonNetFxReference Include="System.Windows.Controls.Ribbon" Condition="'$(_TargetFrameworkVersionValue)' != '' And '$(_TargetFrameworkVersionValue)' &gt;= '4.5'" />
  </ItemGroup>
  <ItemGroup Condition=" '$(_EnableWindowsDesktopNETFrameworkImplicitReference)' == 'true' ">
    <_SDKImplicitReference Include="@(_WpfCommonNetFxReference)" Condition="'$(UseWPF)' == 'true'" />
    <_SDKImplicitReference Include="System.Windows.Forms" Condition="('$(UseWindowsForms)' == 'true') " />
    <_SDKImplicitReference Include="WindowsFormsIntegration" Condition=" ('$(UseWindowsForms)' == 'true') And ('$(UseWPF)' == 'true') " />
  </ItemGroup>
  <!--
        Supported (and unsupported) TargetFrameworks

        Visual Studio Project System determines the list of valid TargetFrameworks to show
        in the Project properties by querying SupportedTargetFramework values.

        The Project System does not refer to this list at this time for .NET Framework TFM's.
  -->
  <!--
    When WindowsDesktop SDK is used without setting UseWPF or UseWindowsForms, it shows a (suppressible) warning and functions much
    like Microsoft.NET.Sdk

    Likewise, when WindowsDesktop SDK is used with a netcore TFM that is less than 3.0, it will simply act as if it were an
    Microsoft.NET.Sdk project (and show a suppressible build-time warning).

    Detect these situations and skip updates to @(SupportedTargetFramework) etc.
  -->
  <ItemGroup Condition=" '$(_RemoveUnsupportedTargetFrameworksForWindowsDesktop)' == 'true' ">
    <!--
        Windows Forms and WPF are supported only on .NET Core 3.0+
    -->
    <_UnsupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v1.0" />
    <_UnsupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v1.1" />
    <_UnsupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v2.0" />
    <_UnsupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v2.1" />
    <_UnsupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v2.2" />
    <!--
        Windows Forms and WPF are not supported an any .NET Standard targets
    -->
    <_UnsupportedNETStandardTargetFramework Include="@(SupportedNETStandardTargetFramework)" />
    <!--
        Windows Forms was supported since .NET Framework 1.0, and is currently supported on
        .NET Framework 2.0+.

        WPF is supported on .NET Framework and WPF are supported on .NET Framework 3.0+

        In practice, the WindowsDesktop SDK is only supported on .NET Framework 3.0+ - this is controlled
        by $(_WindowsDesktopSdkTargetFrameworkVersionFloor), defined as 3.0, which applies to both .NETFramework
        and .NETCore.

        Here, we will encode .NET Framework 3.0 as the lowest supported version for both Windows Forms and WPF.

        The SDK does not define versions < 2.0 in @(SupportedNETFrameworkTargetFramework) list, so none of those
        need to be excluded here - removing 2.0 would suffice.
    -->
    <_UnsupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v2.0" />
    <SupportedNETCoreAppTargetFramework Remove="@(_UnsupportedNETCoreAppTargetFramework)" />
    <SupportedNETStandardTargetFramework Remove="@(_UnsupportedNETStandardTargetFramework)" />
    <SupportedNETFrameworkTargetFramework Remove="@(_UnsupportedNETFrameworkTargetFramework)" />
    <SupportedTargetFramework Remove="@(_UnsupportedNETCoreAppTargetFramework);@(_UnsupportedNETStandardTargetFramework);@(_UnsupportedNETFrameworkTargetFramework)" />
  </ItemGroup>
  <!--
    Import Windows Forms props.
    These come via the Windows Forms transport package, that can be found under
    https://github.com/dotnet/winforms/tree/main/pkg/Microsoft.Private.Winforms/sdk
  -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.WindowsDesktop.WindowsForms.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.WindowsForms.props
============================================================================================================================================
-->
  <!--
    This props file comes from dotnet/winforms. It gets ingested by dotnet/wpf and processed by
    packaging/Microsoft.NET.Sdk.WindowsDesktop project.
    
    It is referenced via Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.props.
   -->
  <!--
    ============================================================
                      GenerateImplicitNamespaceImports
    Generates implicit namespace imports source to intermediate directory for Windows Forms projects
    ============================================================
    -->
  <ItemGroup Condition="'$(UseWindowsForms)' == 'true' and ('$(ImplicitUsings)' == 'true' or '$(ImplicitUsings)' == 'enable')">
    <!--
      SDK defines the following global usings:
      * System
      * System.Collections.Generic
      * System.Linq
      * System.Threading.Tasks
    -->
    <Using Include="System.Drawing" />
    <Using Include="System.Windows.Forms" />
  </ItemGroup>
  <!-- Windows Forms source generator and analyzers -->
  <!--
============================================================================================================================================
  <Import Project="System.Windows.Forms.Analyzers.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/System.Windows.Forms.Analyzers.props
============================================================================================================================================
-->
  <!--
    This props file comes from dotnet/winforms. It gets ingested by dotnet/wpf and processed by
    packaging/Microsoft.NET.Sdk.WindowsDesktop project.

    It is referenced via Microsoft.NET.Sdk.WindowsDesktop.WindowsForms.props.
   -->
  <!-- Import for Windows Forms applications or when developing/testing locally -->
  <ItemGroup Condition="('$(UseWindowsForms)' == 'true') or ('$(ResolveWinFormsAnalyzersFromSdkRefPack)' == 'false')">
    <!-- Known Application properties -->
    <CompilerVisibleProperty Include="ApplicationManifest" />
    <CompilerVisibleProperty Include="StartupObject" />
    <!-- 
      Custom Application properties
      See for more details: https://github.com/dotnet/designs/blob/main/accepted/2021/winforms/streamline-application-bootstrap.md#msbuild-properties
      -->
    <CompilerVisibleProperty Include="ApplicationDefaultFont" />
    <CompilerVisibleProperty Include="ApplicationHighDpiMode" />
    <CompilerVisibleProperty Include="ApplicationUseCompatibleTextRendering" />
    <CompilerVisibleProperty Include="ApplicationVisualStyles" />
    <!-- If there is an app.manifest - let the generator explore it -->
    <AdditionalFiles Include="$(ApplicationManifest)" Condition="'$(ApplicationManifest)' != ''" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.WindowsForms.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.WindowsDesktop.WPF.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.WPF.props
============================================================================================================================================
-->
  <!--
    Generates implicit global namespace imports file <projectname>.ImplicitGlobalNamespaceImports.cs.
  -->
  <ItemGroup Condition="'$(UseWPF)' == 'true' and ('$(ImplicitUsings)' == 'true' or '$(ImplicitUsings)' == 'enable')">
    <Using Remove="System.IO" />
    <Using Remove="System.Net.Http" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Windows.props">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Windows.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Windows.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <ItemGroup Condition=" '$(IncludeWindowsSDKRefFrameworkReferences)' == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <FrameworkReference Include="Microsoft.Windows.SDK.NET.Ref.Windows" IsImplicitlyDefined="true" Pack="false" PrivateAssets="All" />
  </ItemGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MicrosoftNETWindowsWorkloadInstalled>true</MicrosoftNETWindowsWorkloadInstalled>
    <!--https://github.com/dotnet/sdk/issues/12403-->
    <_TargetFrameworkVersionValue>0.0</_TargetFrameworkVersionValue>
    <_WindowsDesktopSdkTargetFrameworkVersionFloor>3.0</_WindowsDesktopSdkTargetFrameworkVersionFloor>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
      Extensibility point for users to import build logic after all of the .NET SDKs .props are imported but before the project's contents are evaluated.
      This can be useful for overriding default globs or properties that the SDK sets.
      -->
  <!--<Import Project="$(AfterMicrosoftNetSdkProps)" Condition="$(AfterMicrosoftNetSdkProps) != ''" />-->
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/fsharp/fsharp/tests/EndToEndBuildTests/DesignTimeProviderPackaging/Provider/Provider.fsproj
============================================================================================================================================
-->
  <PropertyGroup>
    <OutputType>Library</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <FSharpCoreImplicitPackageVersion>$(FSharpCoreShippedPackageVersionValue)</FSharpCoreImplicitPackageVersion>
    <IsFSharpDesignTimeProvider>true</IsFSharpDesignTimeProvider>
  </PropertyGroup>
  <ItemGroup>
    <Compile Include="Library.fs" />
  </ItemGroup>
  <!--
============================================================================================================================================
  <Import Project="Sdk.targets" Sdk="Microsoft.NET.Sdk">
  This import was added implicitly because the Project element's Sdk attribute specified "Microsoft.NET.Sdk".

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="$(BeforeMicrosoftNETSdkTargets)" Condition="'$(BeforeMicrosoftNETSdkTargets)' != ''" />-->
  <!-- Using the same property as Microsoft.CSharp.targets and presumably Microsoft.VisualBasic.targets here -->
  <PropertyGroup Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <IsCrossTargetingBuild>true</IsCrossTargetingBuild>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.BeforeCommonCrossTargeting.targets" Condition="'$(IsCrossTargetingBuild)' == 'true'" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.BeforeCommon.targets" Condition="'$(IsCrossTargetingBuild)' != 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.BeforeCommon.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- For projects that aren't using Microsoft.NET.Sdk, these props files won't have been imported yet.
       So import them here. -->
  <!--<ImportGroup Condition="'$(UsingNETSdkDefaults)' != 'true'">-->
  <!--<Import Project="Microsoft.NET.Sdk.DefaultItems.props" />-->
  <!--<Import Project="Microsoft.NET.SupportedTargetFrameworks.props" />-->
  <!--<Import Project="Microsoft.NET.SupportedPlatforms.props" />-->
  <!--<Import Project="Microsoft.NET.WindowsSdkSupportedTargetPlatforms.props" />-->
  <!--</ImportGroup>-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_IsExecutable Condition="'$(OutputType)' == 'Exe' or '$(OutputType)'=='WinExe'">true</_IsExecutable>
  </PropertyGroup>
  <PropertyGroup Condition="'$(HasRuntimeOutput)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <HasRuntimeOutput>$(_IsExecutable)</HasRuntimeOutput>
    <_UsingDefaultForHasRuntimeOutput>true</_UsingDefaultForHasRuntimeOutput>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.DefaultAssemblyInfo.targets" Condition="'$(UsingNETSdkDefaults)' == 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DefaultAssemblyInfo.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DefaultAssemblyInfo.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition=" '$(Version)' == '' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <VersionPrefix Condition=" '$(VersionPrefix)' == '' ">1.0.0</VersionPrefix>
    <Version Condition=" '$(VersionSuffix)' != '' ">$(VersionPrefix)-$(VersionSuffix)</Version>
    <Version Condition=" '$(Version)' == '' ">$(VersionPrefix)</Version>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Authors Condition=" '$(Authors)'=='' ">$(AssemblyName)</Authors>
    <Company Condition=" '$(Company)'=='' ">$(Authors)</Company>
    <AssemblyTitle Condition=" '$(AssemblyTitle)' == '' ">$(AssemblyName)</AssemblyTitle>
    <Product Condition=" '$(Product)' == ''">$(AssemblyName)</Product>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!--
    Apply these defaults from Microsoft.Common.CurrentVersion.targets now since we're running before them,
    but need to adjust them and/or make decisions in terms of them.
   -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Configuration Condition="'$(Configuration)'==''">Debug</Configuration>
    <Platform Condition="'$(Platform)'==''">AnyCPU</Platform>
    <PlatformName Condition="'$(PlatformName)' == ''">$(Platform)</PlatformName>
  </PropertyGroup>
  <!-- Before any additional SDK targets are imported, import the publish profile.
       This allows the publish profile to set properties like RuntimeIdentifier and them be
       respected by the SDK. -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.ImportPublishProfile.targets" Condition="'$(PublishProfileImported)' != 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.ImportPublishProfile.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.ImportPublishProfile.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Default to having imported the publish profile so the Web SDK doesn't also attempt to do so. -->
    <PublishProfileImported>true</PublishProfileImported>
    <_PublishProfileDesignerFolder Condition="'$(AppDesignerFolder)' != ''">$(AppDesignerFolder)</_PublishProfileDesignerFolder>
    <_PublishProfileDesignerFolder Condition="'$(_PublishProfileDesignerFolder)' == ''">Properties</_PublishProfileDesignerFolder>
    <_PublishProfileRootFolder Condition="'$(_PublishProfileRootFolder)' == ''">$(MSBuildProjectDirectory)\$(_PublishProfileDesignerFolder)\PublishProfiles\</_PublishProfileRootFolder>
    <PublishProfileName Condition="'$(PublishProfileName)' == '' and '$(PublishProfile)' != ''">$([System.IO.Path]::GetFileNameWithoutExtension($(PublishProfile)))</PublishProfileName>
    <PublishProfileFullPath Condition="'$(PublishProfileFullPath)' == '' and '$(PublishProfileName)' != ''">$(_PublishProfileRootFolder)$(PublishProfileName).pubxml</PublishProfileFullPath>
    <WebPublishProfileFile Condition="'$(WebPublishProfileFile)' == '' and Exists('$(PublishProfileFullPath)')">$(PublishProfileFullPath)</WebPublishProfileFile>
    <!-- If the publish profile doesn't exist, mark as not imported.
       This allows the Web SDK to import some default profiles that come with the Web SDK.
       Publishing in Visual Studio sets `WebPublishProfileFile` as a global property.
       Therefore, check that `ProjectToOverrideProjectExtensionsPath` is equal to `MSBuildProjectFullPath`
       to limit the import to the project being published. -->
    <PublishProfileImported Condition="('$(ProjectToOverrideProjectExtensionsPath)' != '' and&#xA;                                        '$(ProjectToOverrideProjectExtensionsPath)' != '$(MSBuildProjectFullPath)') or&#xA;                                       '$(WebPublishProfileFile)' == '' or&#xA;                                       !Exists('$(WebPublishProfileFile)')">false</PublishProfileImported>
  </PropertyGroup>
  <!--<Import Project="$(WebPublishProfileFile)" Condition="'$(PublishProfileImported)' == 'true'" />-->
  <!--<Import Project="$(WebPublishProfileFile).user" Condition="'$(PublishProfileImported)' == 'true' and Exists('$(WebPublishProfileFile).user')" />-->
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!--
    Expand TargetFramework to TargetFrameworkIdentifier and TargetFrameworkVersion,
    and adjust intermediate and output paths to include it.
  -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.TargetFrameworkInference.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.TargetFrameworkInference.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.TargetFrameworkInference.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    Note that this file is only included when $(TargetFramework) is set and so we do not need to check that here.

    Common targets require that $(TargetFrameworkIdentifier) and $(TargetFrameworkVersion) are set by static evaluation
    before they are imported. In common cases (currently netstandard, netcoreapp, or net), we infer them from the short
    names given via TargetFramework to allow for terseness and lack of duplication in project files.

    For other cases, the user must supply them manually.

    For cases where inference is supported, the user need only specify the targets in TargetFrameworks, e.g:
      <PropertyGroup>
        <TargetFrameworks>net45;netstandard1.0</TargetFrameworks>
      </PropertyGroup>

    For cases where inference is not supported, identifier, version and profile can be specified explicitly as follows:
       <PropertyGroup>
         <TargetFrameworks>portable-net451+win81;xyz1.0</TargetFrameworks>
       <PropertyGroup>
       <PropertyGroup Condition="'$(TargetFramework)' == 'portable-net451+win81'">
         <TargetFrameworkIdentifier>.NETPortable</TargetFrameworkIdentifier>
         <TargetFrameworkVersion>v4.6</TargetFrameworkVersion>
         <TargetFrameworkProfile>Profile44</TargetFrameworkProfile>
       </PropertyGroup>
       <PropertyGroup Condition="'$(TargetFramework)' == 'xyz1.0'">
         <TargetFrameworkIdentifier>Xyz</TargetFrameworkVersion>
       <PropertyGroup>

    Note in the xyz1.0 case, which is meant to demonstrate a framework we don't yet recognize, we can still
    infer the version of 1.0. The user can also override it as always we honor a TargetFrameworkIdentifier
    or TargetFrameworkVersion that is already set.
   -->
  <!-- Hook for importing custom target framework parsing -->
  <!--<Import Project="$(BeforeTargetFrameworkInferenceTargets)" Condition="$(BeforeTargetFrameworkInferenceTargets) != ''" />-->
  <!--
    Parse TargetFramework properties.
  -->
  <PropertyGroup Condition="'$(TargetFramework)' != '' and ('$(TargetFrameworkIdentifier)' == '' or '$(TargetFrameworkVersion)' == '')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetFrameworkIdentifier>$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)'))</TargetFrameworkIdentifier>
    <TargetFrameworkVersion>v$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)', 2))</TargetFrameworkVersion>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_TargetFrameworkVersionWithoutV>$(TargetFrameworkVersion.TrimStart('vV'))</_TargetFrameworkVersionWithoutV>
  </PropertyGroup>
  <!--
    Parse TargetPlatform properties.
  -->
  <PropertyGroup Condition="'$(TargetFramework)' != '' and ('$(TargetPlatformIdentifier)' == '' or '$(TargetPlatformVersion)' == '')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == ''">$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)'))</TargetPlatformIdentifier>
    <TargetPlatformVersion Condition="'$(TargetPlatformIdentifier)' == 'Windows'">$([MSBuild]::GetTargetPlatformVersion('$(TargetFramework)', 4))</TargetPlatformVersion>
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == '' or ('$(TargetPlatformIdentifier)' == 'Windows' and !$([MSBuild]::VersionGreaterThanOrEquals($(TargetPlatformVersion), 10.0)))">$([MSBuild]::GetTargetPlatformVersion('$(TargetFramework)', 2))</TargetPlatformVersion>
    <TargetPlatformVersion Condition="$([MSBuild]::VersionEquals($(TargetPlatformVersion), 0.0))" />
    <!-- Normalize casing of windows to Windows -->
    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == 'Windows'">Windows</TargetPlatformIdentifier>
  </PropertyGroup>
  <!--
    Trigger an error if we're unable to infer the framework identifier and version.

    We have to evaluate this here and not in the target because by the time the target runs,
    Microsoft.Common.targets will have defaulted to .NETFramework,Version=v4.0
  -->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '' or '$(TargetFrameworkIdentifier)' == 'Unsupported' or '$(TargetFrameworkVersion)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_UnsupportedTargetFrameworkError>true</_UnsupportedTargetFrameworkError>
  </PropertyGroup>
  <!--
    NOTE: We must not validate the TFM before restore target runs as it prevents adding additional TFM
          support from being provided by a nuget package such as MSBuild.Sdk.Extras.

          We run before RunResolvePackageDependencies and GetReferenceAssemblyPaths so that design-time builds
          which do not currently invoke _CheckForInvalidConfigurationAndPlatform, will not trigger spurious
          errors that are only consequences of the root cause identified here.
  -->
  <Target Name="_CheckForUnsupportedTargetFramework" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;RunResolvePackageDependencies;GetFrameworkPaths;GetReferenceAssemblyPaths;Restore" Condition="'$(_UnsupportedTargetFrameworkError)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="!$(TargetFramework.Contains(';'))" ResourceName="CannotInferTargetFrameworkIdentifierAndVersion" FormatArguments="$([MSBuild]::Escape('$(TargetFramework)'))" />
    <NETSdkError Condition="$(TargetFramework.Contains(';'))" ResourceName="TargetFrameworkWithSemicolon" FormatArguments="$([MSBuild]::Escape('$(TargetFramework)'))" />
  </Target>
  <!-- Skip this target for design time builds when there are missing workload packs.
       This will prevent design time builds from failing and therefore allow
       Visual Studio to collect the workloads from the GetSuggestedWorkloads target -->
  <Target Name="_CheckForUnsupportedTargetPlatformIdentifier" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;RunResolvePackageDependencies;GetFrameworkPaths;GetReferenceAssemblyPaths;CollectPackageReferences" Condition="'$(TargetPlatformIdentifier)' != '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) And ('$(DesignTimeBuild)' != 'true' Or '@(MissingWorkloadPack)' == '')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <TargetPlatformSupported Condition="'$(TargetPlatformIdentifier)' == 'Windows'">true</TargetPlatformSupported>
      <UseWorkloadsSpecificError Condition="($(TargetPlatformIdentifier) == 'ios' or $(TargetPlatformIdentifier) == 'tvos' or $(TargetPlatformIdentifier) == 'maccatalyst' or $(TargetPlatformIdentifier) == 'android' or $(TargetPlatformIdentifier.StartsWith('browser'))) and '$(MSBuildEnableWorkloadResolver)' != 'true'">true</UseWorkloadsSpecificError>
    </PropertyGroup>
    <NETSdkError Condition="'$(TargetPlatformSupported)' != 'true' and '$(UseWorkloadsSpecificError)' != 'true'" ResourceName="UnsupportedTargetPlatformIdentifier" FormatArguments="$(TargetPlatformIdentifier)" />
    <NETSdkError Condition="'$(TargetPlatformSupported)' != 'true' and '$(UseWorkloadsSpecificError)' == 'true'" ResourceName="UnsupportedTargetPlatformIdentifierWithWorkloadsDisabled" FormatArguments="$(TargetPlatformIdentifier)" />
  </Target>
  <UsingTask TaskName="AllowEmptyTelemetry" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_CollectTargetFrameworkForTelemetry" AfterTargets="_CheckForUnsupportedTargetFramework" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <TFTelemetry Include="TargetFrameworkVersion" Value="$([MSBuild]::Escape('$(TargetFrameworkMoniker)'))" />
      <TFTelemetry Include="RuntimeIdentifier" Value="$(RuntimeIdentifier)" />
      <TFTelemetry Include="SelfContained" Value="$(SelfContained)" />
      <TFTelemetry Include="UseApphost" Value="$(UseApphost)" />
      <TFTelemetry Include="OutputType" Value="$(OutputType)" />
      <TFTelemetry Include="UseArtifactsOutput" Value="$(UseArtifactsOutput)" />
      <TFTelemetry Include="ArtifactsPathLocationType" Value="$(_ArtifactsPathLocationType)" />
    </ItemGroup>
    <AllowEmptyTelemetry EventName="targetframeworkeval" EventData="@(TFTelemetry)" />
  </Target>
  <!--
    Don't leave TargetFrameworkVersion empty if it still hasn't been determined. We will trigger the error above,
    but we need this to be a valid version so that our error message does not get pre-empted by failure to interpret
    version comparison expressions, which is currently unrecoverable in VS.

    Also don't leave TargetFrameworkIdentifier unset as it will be defaulted to .NETFramework by common targets, which
    can cause restore (which we cannot block, see above) to silently succeed for empty TargetFramework.
  -->
  <PropertyGroup Condition="'$(TargetFrameworkVersion)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetFrameworkVersion>v0.0</TargetFrameworkVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetFrameworkIdentifier>_</TargetFrameworkIdentifier>
  </PropertyGroup>
  <!--
    Trigger an error if targeting a higher version of .NET Core than is supported by the current SDK.
  -->
  <Target Name="_CheckForUnsupportedNETCoreVersion" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;Restore;CollectPackageReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(NETCoreAppMaximumVersion)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <DisplayVSMessage Condition="$([MSBuild]::VersionLessThan($(MSBuildVersion), '$(MinimumVisualStudioVersionForUnsupportedTargetFrameworkVersion)')) and '$(BuildingInsideVisualStudio)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' == '$(UnsupportedTargetFrameworkVersion)' and '$([MSBuild]::IsOSPlatform(`Windows`))' == 'true'">true</DisplayVSMessage>
    </PropertyGroup>
    <NETSdkError Condition="'$(_TargetFrameworkVersionWithoutV)' &gt; '$(NETCoreAppMaximumVersion)' and '$(DisplayVSMessage)' != 'true'" ResourceName="UnsupportedTargetFrameworkVersion" FormatArguments=".NET;$(_TargetFrameworkVersionWithoutV);$(NETCoreAppMaximumVersion)" />
    <NETSdkError Condition="'$(DisplayVSMessage)' == 'true'" ResourceName="UnsupportedVisualStudioVersion" FormatArguments=".NET;$(_TargetFrameworkVersionWithoutV);$(NETCoreAppMaximumVersion);$(MinimumVisualStudioVersionForUnsupportedTargetFrameworkVersion)" />
  </Target>
  <!--
    Trigger a warning if targeting a lower version of .NET Standard than is recommended
  -->
  <Target Name="_CheckForNotRecommendedNETStandardVersion" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;Restore;CollectPackageReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' and $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '2.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <!-- Default the check to true, but allow developers to turn the warning off. -->
      <CheckNotRecommendedTargetFramework Condition="'$(CheckNotRecommendedTargetFramework)' == ''">true</CheckNotRecommendedTargetFramework>
    </PropertyGroup>
    <NETSdkWarning Condition="'$(CheckNotRecommendedTargetFramework)' == 'true'" ResourceName="TargetFrameworkIsNotRecommended" FormatArguments="https://aka.ms/dotnet/dotnet-standard-guidance" />
  </Target>
  <!--
    Trigger an error if C++ project targeting a lower version of .NET Core than 3.1.
  -->
  <Target Name="_CheckForUnsupportedCppNETCoreVersion" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;Restore;CollectPackageReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &lt; '3.1' and ('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true')" ResourceName="CppRequiresTFMVersion31" />
  </Target>
  <!--C++/CLI has its own logic of determine TargetPlatformIdentifier and TargetPlatformVersion-->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) and ('$(Language)' != 'C++' or '$(_EnablePackageReferencesInVCProjects)' == 'true')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_EnableDefaultWindowsPlatform>false</_EnableDefaultWindowsPlatform>
    <UseOSWinMdReferences>false</UseOSWinMdReferences>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' And '$(NETStandardMaximumVersion)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETStandardMaximumVersion>2.1</NETStandardMaximumVersion>
  </PropertyGroup>
  <Target Name="_CheckForUnsupportedNETStandardVersion" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;Restore;CollectPackageReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' And '$(NETStandardMaximumVersion)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(_TargetFrameworkVersionWithoutV)' &gt; '$(NETStandardMaximumVersion)'" ResourceName="UnsupportedTargetFrameworkVersion" FormatArguments=".NET Standard;$(_TargetFrameworkVersionWithoutV);$(NETStandardMaximumVersion)" />
  </Target>
  <Target Name="_CheckForUnsupportedTargetFrameworkAndFeatureCombination" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;Restore;CollectPackageReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(UsingNETSdkDefaults)' != 'true'" ResourceName="NETFrameworkWithoutUsingNETSdkDefaults" />
  </Target>
  <Target Name="_CheckForSupportedOSPlatformVersionHigherThanTargetPlatformVersion" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetPlatformVersion)' != '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(SupportedOSPlatformVersion)' != '' and $(TargetPlatformVersion) != '' and $([MSBuild]::VersionGreaterThan($(SupportedOSPlatformVersion), $(TargetPlatformVersion)))" ResourceName="CannotHaveSupportedOSPlatformVersionHigherThanTargetPlatformVersion" FormatArguments="$(SupportedOSPlatformVersion);$(TargetPlatformVersion)" />
  </Target>
  <!--C++/CLI targets rely on the patch version of the Windows SDK version as TargetPlatformVersion. Skip the normalization.-->
  <Target Name="_NormalizeTargetPlatformVersion" BeforeTargets="ProcessFrameworkReferences" Condition="'$(TargetPlatformVersion)' != '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) and ('$(Language)' != 'C++' or '$(_EnablePackageReferencesInVCProjects)' == 'true')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ApplicableTargetPlatformVersion Include="@(SdkSupportedTargetPlatformVersion)" Condition="'@(SdkSupportedTargetPlatformVersion)' != '' and '%(SdkSupportedTargetPlatformVersion.DefineConstantsOnly)' != 'true'" RemoveMetadata="DefineConstantsOnly" />
      <_ValidTargetPlatformVersion Include="@(_ApplicableTargetPlatformVersion)" Condition="'@(_ApplicableTargetPlatformVersion)' != '' and $([MSBuild]::VersionEquals(%(Identity), $(TargetPlatformVersion)))" />
    </ItemGroup>
    <PropertyGroup>
      <TargetPlatformVersion Condition="'@(_ValidTargetPlatformVersion)' != '' and '@(_ValidTargetPlatformVersion-&gt;Distinct()-&gt;Count())' == '1' and '@(_ValidTargetPlatformVersion)' != '$(TargetPlatformVersion)'">@(_ValidTargetPlatformVersion-&gt;Distinct())</TargetPlatformVersion>
    </PropertyGroup>
  </Target>
  <Target Name="_CheckForInvalidTargetPlatformVersion" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" DependsOnTargets="_NormalizeTargetPlatformVersion" Condition="'$(TargetPlatformVersion)' != '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) and ('$(Language)' != 'C++' or '$(_EnablePackageReferencesInVCProjects)' == 'true')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <TargetPlatformVersionSupported Condition="'$(TargetPlatformVersionSupported)' == '' and '@(_ValidTargetPlatformVersion)' != ''">true</TargetPlatformVersionSupported>
      <_ValidTargetPlatformVersions Condition="'@(_ApplicableTargetPlatformVersion)' != ''">@(_ApplicableTargetPlatformVersion, '%0a')</_ValidTargetPlatformVersions>
      <_ValidTargetPlatformVersions Condition="'@(_ApplicableTargetPlatformVersion)' == ''">None</_ValidTargetPlatformVersions>
    </PropertyGroup>
    <NetSdkError Condition="'$(TargetPlatformVersionSupported)' != 'true'" ResourceName="InvalidTargetPlatformVersion" FormatArguments="$(TargetPlatformVersion);$(TargetPlatformIdentifier);$(_ValidTargetPlatformVersions)" />
  </Target>
  <!-- Hook for processing after target framework parsing (for example to customize output paths) -->
  <!--<Import Project="$(AfterTargetFrameworkInferenceTargets)" Condition="$(AfterTargetFrameworkInferenceTargets) != ''" />-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProduceReferenceAssembly Condition="'$(ProduceReferenceAssembly)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) and ('$(ProduceOnlyReferenceAssembly)' != 'true') and '$(MSBuildProjectExtension)' != '.fsproj'">true</ProduceReferenceAssembly>
    <ProduceReferenceAssembly Condition="'$(ProduceReferenceAssembly)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 7.0)) and ('$(ProduceOnlyReferenceAssembly)' != 'true') and '$(MSBuildProjectExtension)' == '.fsproj'">true</ProduceReferenceAssembly>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!-- Set default intermediate and output paths -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.DefaultOutputPaths.targets" Condition="'$(UsingNETSdkDefaults)' == 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DefaultOutputPaths.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DefaultOutputPaths.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    Note that common targets only set a default OutputPath if neither configuration nor
    platform were set by the user. This was used to validate that a valid configuration is passed,
    assuming the convention maintained by VS that every Configuration|Platform combination had
    an explicit OutputPath. Since we now want to support leaner project files with less
    duplication and more automatic defaults, we always set a default OutputPath.
   -->
  <!-- Projects which don't use Microsoft.NET.Sdk will typically define the OutputPath directly (usually in a
       Configuration-specific PropertyGroup), so in that case we won't append to it by default. -->
  <PropertyGroup Condition="'$(UsingNETSdkDefaults)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AppendTargetFrameworkToOutputPath Condition="'$(AppendTargetFrameworkToOutputPath)' == ''">true</AppendTargetFrameworkToOutputPath>
    <AppendPlatformToOutputPath Condition="'$(AppendPlatformToOutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">false</AppendPlatformToOutputPath>
    <AppendPlatformToOutputPath Condition="'$(AppendPlatformToOutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">true</AppendPlatformToOutputPath>
    <_PlatformToAppendToOutputPath Condition="'$(AppendPlatformToOutputPath)' == 'true'">$(PlatformName)\</_PlatformToAppendToOutputPath>
  </PropertyGroup>
  <!-- NOTE: If we want to default UseArtifactsOutput to true when targeting a given version of .NET or higher, this is where we would do it.

    It would look something like this:

  <PropertyGroup Condition="'$(UseArtifactsOutput)' == '' and
                            '$(TargetFrameworks)' == '' and
                            '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and
                            $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 8.0))">
    <UseArtifactsOutput>true</UseArtifactsOutput>
  </PropertyGroup>
  -->
  <!-- Import .props file to set ArtifactsPath if it wasn't already imported from Sdk.props (this is for the case when artifacts
       properties are set in the project file instead of Directory.Build.props -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.DefaultArtifactsPath.props" Condition="'$(_DefaultArtifactsPathPropsImported)' != 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DefaultArtifactsPath.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DefaultArtifactsPath.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- This .props file may be imported either from Sdk.props or from Microsoft.NET.DefaultOutputPaths.targets, depending
       on whether artifacts output properties were set in Directory.Build.props or not.

       Set a property to indicate it was imported, so we can avoid a duplicate import. -->
  <PropertyGroup>
    <_DefaultArtifactsPathPropsImported>true</_DefaultArtifactsPathPropsImported>
  </PropertyGroup>
  <!-- Setting ArtifactsPath automatically opts in to the artifacts output format -->
  <PropertyGroup Condition="'$(ArtifactsPath)' != '' And '$(UsingMicrosoftArtifactsSdk)' != 'true'">
    <UseArtifactsOutput Condition="'$(UseArtifactsOutput)' == ''">true</UseArtifactsOutput>
    <IncludeProjectNameInArtifactsPaths Condition="'$(IncludeProjectNameInArtifactsPaths)' == ''">true</IncludeProjectNameInArtifactsPaths>
    <_ArtifactsPathLocationType>ExplicitlySpecified</_ArtifactsPathLocationType>
  </PropertyGroup>
  <!-- Set up base output folders if UseArtifactsOutput is set -->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true' And '$(ArtifactsPath)' == '' And '$(_DirectoryBuildPropsBasePath)' != ''">
    <!-- Default ArtifactsPath to be in the directory where Directory.Build.props is found
         Note that we do not append a backslash to the ArtifactsPath as we do with most paths, because it may be a global property passed in on the command-line which we can't easily change -->
    <ArtifactsPath>$(_DirectoryBuildPropsBasePath)\artifacts</ArtifactsPath>
    <IncludeProjectNameInArtifactsPaths Condition="'$(IncludeProjectNameInArtifactsPaths)' == ''">true</IncludeProjectNameInArtifactsPaths>
    <_ArtifactsPathLocationType>DirectoryBuildPropsFolder</_ArtifactsPathLocationType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true' And '$(ArtifactsPath)' == ''">
    <!-- If there was no Directory.Build.props file, then put the artifacts path in the project folder -->
    <ArtifactsPath>$(MSBuildProjectDirectory)\artifacts</ArtifactsPath>
    <_ArtifactsPathLocationType>ProjectFolder</_ArtifactsPathLocationType>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DefaultOutputPaths.targets
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ArtifactsProjectName Condition="'$(ArtifactsProjectName)' == ''">$(MSBuildProjectName)</ArtifactsProjectName>
    <ArtifactsBinOutputName Condition="'$(ArtifactsBinOutputName)' == ''">bin</ArtifactsBinOutputName>
    <ArtifactsPublishOutputName Condition="'$(ArtifactsPublishOutputName)' == ''">publish</ArtifactsPublishOutputName>
    <ArtifactsPackageOutputName Condition="'$(ArtifactsPackageOutputName)' == ''">package</ArtifactsPackageOutputName>
    <!-- By default MSBuild won't allow tracking/automatic clean-up of files that are outside of a Project's child directory structure.
         This flag opts us into a mode where the Common targets will track and clean such files, which is good because
         in Artifacts layout virtually all transitive and package references are such files. 
         See https://github.com/dotnet/msbuild/pull/12096 for full details. -->
    <TrackFileWritesShareableOutsideOfProjectDirectory>true</TrackFileWritesShareableOutsideOfProjectDirectory>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true' And '$(ArtifactsPivots)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ArtifactsPivots>$(Configuration.ToLowerInvariant())</ArtifactsPivots>
    <!-- Include the TargetFramework in the pivots if the project is multi-targeted (ie TargetFrameworks) is defined -->
    <ArtifactsPivots Condition="'$(TargetFrameworks)' != '' And '$(TargetFramework)' != ''">$(ArtifactsPivots)_$(TargetFramework.ToLowerInvariant())</ArtifactsPivots>
    <!-- This targets file is evaluated before RuntimeIdentifierInference.targets, so this will only include the
         RuntimeIdentifier in the path if it was explicitly specified, not if it was inferred.  This is the
         behavior we want.

         The BlazorWebAssembly .props file sets the RuntimeIdentifier to browser-wasm, so treat that as a special case.
         -->
    <ArtifactsPivots Condition="'$(RuntimeIdentifier)' != '' And !('$(RuntimeIdentifier)' == 'browser-wasm' And '$(AppendRuntimeIdentifierToOutputPath)' == 'false')">$(ArtifactsPivots)_$(RuntimeIdentifier.ToLowerInvariant())</ArtifactsPivots>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true' And '$(IncludeProjectNameInArtifactsPaths)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Set artifacts paths when project name should be included in the path -->
    <BaseOutputPath Condition="'$(BaseOutputPath)' == ''">$(ArtifactsPath)\$(ArtifactsBinOutputName)\$(ArtifactsProjectName)\</BaseOutputPath>
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == '' And '$(UseArtifactsIntermediateOutput)' == 'true'">$(ArtifactsPath)\obj\$(ArtifactsProjectName)\</BaseIntermediateOutputPath>
    <PublishDir Condition="'$(PublishDir)' == ''">$(ArtifactsPath)\$(ArtifactsPublishOutputName)\$(ArtifactsProjectName)\$(ArtifactsPivots)\</PublishDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true' And '$(IncludeProjectNameInArtifactsPaths)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Set artifacts paths when project name should not be included in the path -->
    <BaseOutputPath Condition="'$(BaseOutputPath)' == ''">$(ArtifactsPath)\$(ArtifactsBinOutputName)\</BaseOutputPath>
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == '' And '$(UseArtifactsIntermediateOutput)' == 'true'">$(ArtifactsPath)\obj\</BaseIntermediateOutputPath>
    <PublishDir Condition="'$(PublishDir)' == ''">$(ArtifactsPath)\$(ArtifactsPublishOutputName)\$(ArtifactsPivots)\</PublishDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <OutputPath Condition="'$(OutputPath)' == ''">$(BaseOutputPath)$(ArtifactsPivots)\</OutputPath>
    <IntermediateOutputPath Condition=" $(IntermediateOutputPath) == '' And '$(UseArtifactsIntermediateOutput)' == 'true'">$(BaseIntermediateOutputPath)$(ArtifactsPivots)\</IntermediateOutputPath>
    <!-- The package output path does not include the project name, and only includes the Configuration as a pivot -->
    <PackageOutputPath Condition="'$(PackageOutputPath)' == ''">$(ArtifactsPath)\$(ArtifactsPackageOutputName)\$(Configuration.ToLowerInvariant())\</PackageOutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <BaseOutputPath Condition="'$(BaseOutputPath)' == ''">bin\</BaseOutputPath>
    <BaseOutputPath Condition="!HasTrailingSlash('$(BaseOutputPath)')">$(BaseOutputPath)\</BaseOutputPath>
    <OutputPath Condition="'$(OutputPath)' == ''">$(BaseOutputPath)$(_PlatformToAppendToOutputPath)$(Configuration)\</OutputPath>
    <OutputPath Condition="!HasTrailingSlash('$(OutputPath)')">$(OutputPath)\</OutputPath>
  </PropertyGroup>
  <!-- If "UseArtifactsOutput" wasn't set when the MSBuild project extensions .props files were imported, then use "obj" in the project folder for the intermediate output path
         instead a folder under ArtifactsPath.  To have the intermediate output path in the artifacts folder, "UseArtifactsOutput" should be set in Directory.Build.props-->
  <PropertyGroup Condition="'$(UseArtifactsIntermediateOutput)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == ''">obj\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
    <IntermediateOutputPath Condition=" $(IntermediateOutputPath) == '' ">$(BaseIntermediateOutputPath)$(_PlatformToAppendToOutputPath)$(Configuration)\</IntermediateOutputPath>
    <IntermediateOutputPath Condition="!HasTrailingSlash('$(IntermediateOutputPath)')">$(IntermediateOutputPath)\</IntermediateOutputPath>
  </PropertyGroup>
  <!-- Set the package output path (for nuget pack target) now, before the TargetFramework is appended -->
  <PropertyGroup Condition="'$(PackageOutputPath)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PackageOutputPath Condition="'$(UseArtifactsOutput)' != 'true'">$(OutputPath)</PackageOutputPath>
  </PropertyGroup>
  <!-- Exclude files from OutputPath and IntermediateOutputPath from default item globs.  Use the value
       of these properties before the TargetFramework is appended, so that if these values are specified
       in the project file, the specified value will be used for the exclude. -->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DefaultItemExcludes>$(DefaultItemExcludes);$(OutputPath)/**</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);$(IntermediateOutputPath)/**</DefaultItemExcludes>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DefaultItemExcludes>$(DefaultItemExcludes);$(ArtifactsPath)/**</DefaultItemExcludes>
    <!-- Exclude bin and obj folders to avoid issues with projects that switch to using artifacts output format -->
    <DefaultItemExcludes>$(DefaultItemExcludes);bin/**;obj/**</DefaultItemExcludes>
  </PropertyGroup>
  <!--
    Append $(TargetFramework) directory to output and intermediate paths to prevent bin clashes between
    targets.
   -->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' != 'true' and&#xA;                            '$(AppendTargetFrameworkToOutputPath)' == 'true' and '$(TargetFramework)' != '' and '$(_UnsupportedTargetFrameworkError)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <OutputPath>$(OutputPath)$(TargetFramework.ToLowerInvariant())\</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' != 'true' and&#xA;                            '$(AppendTargetFrameworkToOutputPath)' == 'true' and '$(TargetFramework)' != '' and '$(_UnsupportedTargetFrameworkError)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <IntermediateOutputPath>$(IntermediateOutputPath)$(TargetFramework.ToLowerInvariant())\</IntermediateOutputPath>
  </PropertyGroup>
  <Target Name="_CheckForUnsupportedArtifactsPath" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Generate an error if ArtifactsPath or UseArtifactsOutput are set in the project file.

         We generate an error because if they are set in the project file, it is too late to change the intermediate output path,
         and because it would be confusing to set the property in the project file and have the artifacts path depend on whether
         there happened to be a Directory.Build.props file defined.
    -->
    <NetSdkError Condition="'$(UseArtifactsOutput)' == 'true' and '$(_ArtifactsPathSetEarly)' != 'true'" ResourceName="ArtifactsPathCannotBeSetInProject" />
    <NetSdkError Condition="'$(_ArtifactsPathLocationType)' == 'ProjectFolder'" ResourceName="UseArtifactsOutputRequiresDirectoryBuildProps" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!-- Related issue: https://github.com/dotnet/sdk/issues/12324-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Import winfx targets when we're targeting .NETFramework and not importing the newer WindowsDesktop targets via `UseWPF`. -->
    <ImportFrameworkWinFXTargets Condition="'$(ImportFrameworkWinFXTargets)' == '' and '$(UseWPF)' != 'true' and '$(TargetFrameworkIdentifier)' == '.NETFramework'">true</ImportFrameworkWinFXTargets>
    <!-- Otherwise, don't import. -->
    <ImportFrameworkWinFXTargets Condition="'$(ImportFrameworkWinFXTargets)' == ''">false</ImportFrameworkWinFXTargets>
  </PropertyGroup>
  <!--
    Import targets from RazorSDK if referenced
    Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Sdk.BeforeCommon.targets
    Sdks\Microsoft.NET.Sdk.Razor\targets\Microsoft.NET.Sdk.Razor.BeforeCommon.targets
  -->
  <!--<Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.NET.Sdk.Razor\targets\Microsoft.NET.Sdk.Razor.BeforeCommon.targets" Condition="'$(UsingMicrosoftNETSdkRazor)' == 'true'" />-->
  <!-- Import workload targets -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.ImportWorkloads.targets" Condition="'$(MSBuildEnableWorkloadResolver)' == 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.ImportWorkloads.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.ImportWorkloads.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Workload support -->
  <!-- Import workload manifests -->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100-preview.6/microsoft.net.sdk.android/36.0.0-preview.6.169/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'android' ">-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.Android.Sdk.net10" Condition=" $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '10.0')) " />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.Android.Sdk.net9" Condition=" $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0')) " />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.Android.Sdk.net8" Condition=" $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '8.0')) " />-->
  <!--<Import Project="Eol.targets" Sdk="Microsoft.Android.Sdk.net10" Condition=" $([MSBuild]::VersionLessThanOrEquals($(TargetFrameworkVersion), '7.0')) " />-->
  <!--</ImportGroup>-->
  <ItemGroup Condition=" '$(TargetPlatformIdentifier)' == 'android' and $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0')) ">
    <KnownFrameworkReference Update="Microsoft.Android" LatestRuntimeFrameworkVersion="35.0.78" TargetingPackVersion="35.0.78" />
  </ItemGroup>
  <ItemGroup Condition=" '$(TargetPlatformIdentifier)' == 'android' and $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '8.0')) ">
    <KnownFrameworkReference Update="Microsoft.Android" LatestRuntimeFrameworkVersion="34.0.154" TargetingPackVersion="34.0.154" />
  </ItemGroup>
  <ItemGroup Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '8.0')) ">
    <SdkSupportedTargetPlatformIdentifier Include="android" DisplayName="Android" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100-preview.6/microsoft.net.sdk.ios/18.5.10415-net10-p6/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'iOS' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '10.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.iOS.Sdk.net10.0_18.5" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.iOS.Windows.Sdk.Aliased.net10.0_18.5" Condition=" $([MSBuild]::IsOSPlatform('windows'))" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'iOS' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.iOS.Sdk.net9.0_18.0" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.iOS.Windows.Sdk.Aliased.net9.0_18.0" Condition=" $([MSBuild]::IsOSPlatform('windows'))" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'iOS' And '$(UsingAppleNETSdk)' != 'true'">-->
  <!--<Import Project="Sdk-eol.props" Sdk="Microsoft.iOS.Sdk.net10.0_18.5" Condition=" $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '9.0'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.iOS.Sdk.net10.0_18.5" Condition=" $([MSBuild]::VersionGreaterThan($(TargetFrameworkVersion), '10.0'))" />-->
  <!--</ImportGroup>-->
  <ItemGroup Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0')) ">
    <SdkSupportedTargetPlatformIdentifier Include="ios" DisplayName="iOS" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100-preview.6/microsoft.net.sdk.maccatalyst/18.5.10415-net10-p6/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'MacCatalyst' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '10.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.MacCatalyst.Sdk.net10.0_18.5" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'MacCatalyst' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.MacCatalyst.Sdk.net9.0_18.0" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'MacCatalyst' And '$(UsingAppleNETSdk)' != 'true'">-->
  <!--<Import Project="Sdk-eol.props" Sdk="Microsoft.MacCatalyst.Sdk.net10.0_18.5" Condition=" $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '9.0'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.MacCatalyst.Sdk.net10.0_18.5" Condition=" $([MSBuild]::VersionGreaterThan($(TargetFrameworkVersion), '10.0'))" />-->
  <!--</ImportGroup>-->
  <ItemGroup Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0')) ">
    <SdkSupportedTargetPlatformIdentifier Include="maccatalyst" DisplayName="MacCatalyst" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100-preview.6/microsoft.net.sdk.macos/15.5.10415-net10-p6/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'macOS' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '10.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.macOS.Sdk.net10.0_15.5" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'macOS' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.macOS.Sdk.net9.0_15.0" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'macOS' And '$(UsingAppleNETSdk)' != 'true'">-->
  <!--<Import Project="Sdk-eol.props" Sdk="Microsoft.macOS.Sdk.net10.0_15.5" Condition=" $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '9.0'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.macOS.Sdk.net10.0_15.5" Condition=" $([MSBuild]::VersionGreaterThan($(TargetFrameworkVersion), '10.0'))" />-->
  <!--</ImportGroup>-->
  <ItemGroup Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0')) ">
    <SdkSupportedTargetPlatformIdentifier Include="macos" DisplayName="macOS" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100-preview.6/microsoft.net.sdk.maui/10.0.0-preview.6.25359.8/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--
      .NET MAUI telemetry and failure tracking. These are used to detect when the user specified one of the
      various <UseMaui*> properties, but for some reason the workload was not installed correctly.
  -->
  <ItemGroup>
    <ProjectCapability Condition=" '$(UseMaui)' == 'true' " Include="UseMaui" />
    <ProjectCapability Condition=" '$(UseMauiCore)' == 'true' " Include="UseMauiCore" />
    <ProjectCapability Condition=" '$(UseMauiNuGets)' == 'true' " Include="UseMauiNuGets" />
    <ProjectCapability Condition=" '$(UseMauiEssentials)' == 'true' " Include="UseMauiEssentials" />
    <ProjectCapability Condition=" '$(UseMauiAssets)' == 'true' " Include="UseMauiAssets" />
  </ItemGroup>
  <!--
      Specifying any of the <UseMaui*> properties will enable the maui workload. BundledVersions.targets enables
      the specific parts of .NET MAUI SDK.
  -->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.Maui.Sdk.net10" Condition=" ('$(UseMaui)' == 'true' or '$(UseMauiCore)' == 'true' or '$(UseMauiEssentials)' == 'true' or '$(UseMauiAssets)' == 'true') and ($([MSBuild]::VersionEquals($(TargetFrameworkVersion), '10.0'))) and ('$(SkipMauiWorkloadManifest)' != 'true') " />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.Maui.Sdk.net9" Condition=" ('$(UseMaui)' == 'true' or '$(UseMauiCore)' == 'true' or '$(UseMauiEssentials)' == 'true' or '$(UseMauiAssets)' == 'true') and ($([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0'))) and ('$(SkipMauiWorkloadManifest)' != 'true') " />-->
  <!--
      Previous versions of the .NET MAUI SDK used **FromWorkload**, so replace with explicit versions.
      The BundledVersions.targets that is imported is from the previous SDK, so all the other values are correct.
  -->
  <ItemGroup Condition=" $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0')) and ('$(SkipMauiWorkloadManifest)' != 'true') ">
    <KnownFrameworkReference Update="Microsoft.Maui.Core" DefaultRuntimeFrameworkVersion="$(MauiVersion)" LatestRuntimeFrameworkVersion="$(MauiVersion)" TargetingPackVersion="$(MauiVersion)" />
    <KnownFrameworkReference Update="Microsoft.Maui.Controls" DefaultRuntimeFrameworkVersion="$(MauiVersion)" LatestRuntimeFrameworkVersion="$(MauiVersion)" TargetingPackVersion="$(MauiVersion)" />
    <KnownFrameworkReference Update="Microsoft.Maui.Essentials" DefaultRuntimeFrameworkVersion="$(MauiVersion)" LatestRuntimeFrameworkVersion="$(MauiVersion)" TargetingPackVersion="$(MauiVersion)" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100-preview.6/microsoft.net.sdk.tvos/18.5.10415-net10-p6/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'tvOS' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '10.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.tvOS.Sdk.net10.0_18.5" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'tvOS' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.tvOS.Sdk.net9.0_18.0" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'tvOS' And '$(UsingAppleNETSdk)' != 'true'">-->
  <!--<Import Project="Sdk-eol.props" Sdk="Microsoft.tvOS.Sdk.net10.0_18.5" Condition=" $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '9.0'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.tvOS.Sdk.net10.0_18.5" Condition=" $([MSBuild]::VersionGreaterThan($(TargetFrameworkVersion), '10.0'))" />-->
  <!--</ImportGroup>-->
  <ItemGroup Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0')) ">
    <SdkSupportedTargetPlatformIdentifier Include="tvos" DisplayName="tvOS" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100/microsoft.net.workload.mono.toolchain.current/10.0.100-rc.1.25420.111/WorkloadManifest.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <PropertyGroup>
    <_RuntimePackInWorkloadVersionCurrent>10.0.0-rc.1.25420.111</_RuntimePackInWorkloadVersionCurrent>
    <_RuntimePackInWorkloadVersion9>9.0.7</_RuntimePackInWorkloadVersion9>
    <_RuntimePackInWorkloadVersion8>8.0.18</_RuntimePackInWorkloadVersion8>
    <_RuntimePackInWorkloadVersion7>7.0.20</_RuntimePackInWorkloadVersion7>
    <_RuntimePackInWorkloadVersion6>6.0.36</_RuntimePackInWorkloadVersion6>
    <TargetsCurrent Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '10.0'))">true</TargetsCurrent>
    <!-- Disabled until next release: force net10.0 to use the current targets until the SDK can target net11.0 -->
    <!--
    <TreatPreviousAsCurrent Condition="'$(TreatPreviousAsCurrent)' == ''">true</TreatPreviousAsCurrent>
    <TargetsCurrent Condition="'$(TreatPreviousAsCurrent)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '10.0'))">true</TargetsCurrent>
    -->
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetsCurrent)' != 'true'">
    <TargetsNet9 Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '9.0'))">true</TargetsNet9>
    <TargetsNet8 Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '8.0'))">true</TargetsNet8>
    <TargetsNet7 Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '7.0'))">true</TargetsNet7>
    <TargetsNet6 Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '6.0'))">true</TargetsNet6>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildThisFileDirectory)WorkloadManifest.Wasi.targets" Condition="'$(RuntimeIdentifier)' == 'wasi-wasm'" />-->
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'">
    <_BrowserWorkloadNotSupportedForTFM Condition="$([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '6.0'))">true</_BrowserWorkloadNotSupportedForTFM>
    <_BrowserWorkloadDisabled>$(_BrowserWorkloadNotSupportedForTFM)</_BrowserWorkloadDisabled>
    <_UsingBlazorOrWasmSdk Condition="'$(UsingMicrosoftNETSdkBlazorWebAssembly)' == 'true' or '$(UsingMicrosoftNETSdkWebAssembly)' == 'true'">true</_UsingBlazorOrWasmSdk>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm'">
    <SelfContained>true</SelfContained>
    <WasmNativeWorkloadAvailable Condition="'$(TargetsCurrent)' == 'true'">$(WasmNativeWorkload10)</WasmNativeWorkloadAvailable>
    <WasmNativeWorkloadAvailable Condition="'$(TargetsNet9)' == 'true'">$(WasmNativeWorkload9)</WasmNativeWorkloadAvailable>
    <WasmNativeWorkloadAvailable Condition="'$(TargetsNet8)' == 'true'">$(WasmNativeWorkload8)</WasmNativeWorkloadAvailable>
    <WasmNativeWorkloadAvailable Condition="'$(TargetsNet7)' == 'true'">$(WasmNativeWorkload7)</WasmNativeWorkloadAvailable>
    <WasmNativeWorkloadAvailable Condition="'$(TargetsNet6)' == 'true'">$(WasmNativeWorkload)</WasmNativeWorkloadAvailable>
    <WasmNativeWorkloadAvailable Condition="'$(WasmNativeWorkloadAvailable)' == '' or '$(WasmNativeWorkload)' == 'false'">false</WasmNativeWorkloadAvailable>
    <WasmNativeWorkload>$(WasmNativeWorkloadAvailable)</WasmNativeWorkload>
  </PropertyGroup>
  <!-- Runtime feature defaults to trim unnecessary code -->
  <!--<Import Project="$(MSBuildThisFileDirectory)WasmFeatures.props" Condition="'$(RuntimeIdentifier)' == 'browser-wasm' or '$(RuntimeIdentifier)' == 'wasi-wasm'" />-->
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'">
    <!-- Keep in sync with $(PropertiesThatTriggerRelinking) -->
    <_WasmNativeWorkloadNeeded Condition="&#xA;        '$(WasmEnableSIMD)' == 'false' or&#xA;        '$(WasmEnableExceptionHandling)' == 'false' or&#xA;        '$(InvariantTimezone)' == 'true' or&#xA;        '$(WasmNativeStrip)' == 'false' or&#xA;        '$(WasmNativeDebugSymbols)' == 'true' or&#xA;        '$(WasmSingleFileBundle)' == 'false' or&#xA;        '$(EnableDiagnostics)' == 'true' or&#xA;        '$(WasmProfilers)' != '' or&#xA;        '$(RunAOTCompilation)' == 'true' or&#xA;        '$(WasmBuildNative)' == 'true' or&#xA;        '$(WasmGenerateAppBundle)' == 'true' or&#xA;        '$(_UsingBlazorOrWasmSdk)' != 'true' or&#xA;        '$(EmccInitialHeapSize)' != '' or&#xA;        '$(EmccMaximumHeapSize)' != '' ">true</_WasmNativeWorkloadNeeded>
    <UsingBrowserRuntimeWorkload Condition="'$(_BrowserWorkloadNotSupportedForTFM)' == 'true'">false</UsingBrowserRuntimeWorkload>
    <UsingBrowserRuntimeWorkload Condition="'$(UsingBrowserRuntimeWorkload)' == '' and '$(_WasmNativeWorkloadNeeded)' == 'true'">true</UsingBrowserRuntimeWorkload>
    <UsingBrowserRuntimeWorkload Condition="'$(UsingBrowserRuntimeWorkload)' == ''">$(WasmNativeWorkloadAvailable)</UsingBrowserRuntimeWorkload>
  </PropertyGroup>
  <!-- Mono AOT library mode support -->
  <PropertyGroup Condition="'$(PublishAot)' != 'true' and '$(NativeLib)' != ''">
    <_IsAndroidLibraryMode Condition="'$(RuntimeIdentifier)' == 'android-arm64' or '$(RuntimeIdentifier)' == 'android-arm' or '$(RuntimeIdentifier)' == 'android-x64' or '$(RuntimeIdentifier)' == 'android-x86'">true</_IsAndroidLibraryMode>
    <_IsAppleMobileLibraryMode Condition="'$(RuntimeIdentifier)' == 'ios-arm64' or '$(RuntimeIdentifier)' == 'iossimulator-arm64' or '$(RuntimeIdentifier)' == 'iossimulator-x64' or '$(RuntimeIdentifier)' == 'maccatalyst-arm64' or '$(RuntimeIdentifier)' == 'maccatalyst-x64' or '$(RuntimeIdentifier)' == 'tvos-arm64'">true</_IsAppleMobileLibraryMode>
    <_IsiOSLibraryMode Condition="'$(RuntimeIdentifier)' == 'ios-arm64' or '$(RuntimeIdentifier)' == 'iossimulator-arm64' or '$(RuntimeIdentifier)' == 'iossimulator-x64'">true</_IsiOSLibraryMode>
    <_IsMacCatalystLibraryMode Condition="'$(RuntimeIdentifier)' == 'maccatalyst-arm64' or '$(RuntimeIdentifier)' == 'maccatalyst-x64'">true</_IsMacCatalystLibraryMode>
    <_IstvOSLibraryMode Condition="'$(RuntimeIdentifier)' == 'tvos-arm64'">true</_IstvOSLibraryMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'android' or '$(_IsAndroidLibraryMode)' == 'true' or '$(TargetPlatformIdentifier)' == 'macOS' or '$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(TargetPlatformIdentifier)' == 'ios' or '$(TargetPlatformIdentifier)' == 'tvos' or '$(_IsAppleMobileLibraryMode)' == 'true'">
    <UsingMobileWorkload>true</UsingMobileWorkload>
  </PropertyGroup>
  <PropertyGroup Condition="$([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '8.0')) and ('$(UsingMobileWorkload)' == 'true' or '$(RuntimeIdentifier)' == 'browser-wasm' or '$(RuntimeIdentifier)' == 'wasi-wasm')">
    <_MonoWorkloadTargetsMobile>true</_MonoWorkloadTargetsMobile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(_UsingBlazorOrWasmSdk)' == 'true' and '$(UsingBrowserRuntimeWorkload)' == 'true'">
    <WasmGenerateAppBundle>false</WasmGenerateAppBundle>
    <UsingBlazorAOTWorkloadManifest>true</UsingBlazorAOTWorkloadManifest>
  </PropertyGroup>
  <!-- Support for "browser" target platform identifier -->
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'browser' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '8.0'))">
    <TargetPlatformSupported>true</TargetPlatformSupported>
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == ''">1.0</TargetPlatformVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetPlatformIdentifier)' == 'browser' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '8.0'))">
    <SdkSupportedTargetPlatformVersion Include="1.0" />
  </ItemGroup>
  <!-- Support for "wasi" target platform identifier -->
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'wasi' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '8.0'))">
    <TargetPlatformSupported>true</TargetPlatformSupported>
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == ''">1.0</TargetPlatformVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetPlatformIdentifier)' == 'wasi' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '8.0'))">
    <SdkSupportedTargetPlatformVersion Include="1.0" />
  </ItemGroup>
  <!-- we can't condition sdk imports on the item @(NativeFileReference). Instead, explicitly check before the build
  and emit a warning -->
  <Target Name="_CheckBrowserWorkloadNeededButNotAvailable" Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(_BrowserWorkloadDisabled)' != 'true' and '$(WasmNativeWorkloadAvailable)' != 'true'" BeforeTargets="Build">
    <Warning Condition="@(NativeFileReference-&gt;Count()) &gt; 0" Text="%40(NativeFileReference) is not empty, but the native references won't be linked in, because neither %24(WasmBuildNative), nor %24(RunAOTCompilation) are 'true'. NativeFileReference=@(NativeFileReference)" />
  </Target>
  <Target Name="_ErrorWorkloadDisabledForTFMLessThan6" Condition="'$(_BrowserWorkloadNotSupportedForTFM)' == 'true'" BeforeTargets="Build">
    <Error Condition="'$(RunAOTCompilation)' == 'true'" Text="WebAssembly workloads, required for AOT, are only supported for projects targeting net6.0+ . Set %24(RunAOTCompilation)=false to disable it." />
    <Error Condition="@(NativeFileReference-&gt;Count()) &gt; 0" Text="WebAssembly workloads, required for linking native files (from %40(NativeFileReference)), are only supported for projects targeting net6.0+ ." />
    <Error Condition="'$(WasmBuildNative)' == 'true'" Text="WebAssembly workloads, required for native relinking, are only supported for projects targeting net6.0+ . Set %24(WasmBuildNative)=false to disable it." />
  </Target>
  <Target Name="_ErrorDualWasmThreadPropsOn7" Condition="'$(TargetsNet7)' == 'true' and '$(RuntimeIdentifier)' == 'browser-wasm' and&#xA;    '$(BrowserWorkloadDisabled)' != 'true' and '$(WasmEnableThreads)' == 'true' and '$(WasmEnablePerfTrace)' == 'true'" BeforeTargets="Build">
    <Error Text="WebAssembly workloads can only support one active threading mode at a time. Either set WasmEnableThreads to true, but not both." />
  </Target>
  <Target Name="_SuggestWasmWorkloadForBlazor" BeforeTargets="Publish">
    <Message Condition="'$(_UsingBlazorOrWasmSdk)' == 'true' and '$(WasmNativeWorkloadAvailable)' != 'true'" Text="Publishing without optimizations. Although it's optional for Blazor, we strongly recommend using `wasm-tools` workload! You can install it by running `dotnet workload install wasm-tools` from the command line." Importance="High" />
  </Target>
  <!--<Import Project="$(MSBuildThisFileDirectory)WorkloadTelemetry.targets" Condition="'$(_MonoWorkloadTargetsMobile)' == 'true'" />-->
  <!-- end of common logic -->
  <!-- start of TFM specific logic, make sure every node has a TargetsCurrent/TargetsNet* condition -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoAOTCompiler.Task.net10" Condition="'$(TargetsCurrent)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingMobileWorkload)' == 'true' or '$(UsingWasiRuntimeWorkload)' == 'true')" />-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(_IsAndroidLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and ('$(_IsAndroidLibraryMode)' == 'true' or '$(_IsAppleMobileLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.LibraryBuilder.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.LibraryBuilder.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(_IsAndroidLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.android-x86" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.android-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.android-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.android-arm64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and '$(TargetPlatformIdentifier)' == 'macOS'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and ('$(TargetPlatformIdentifier)' == 'ios' or '$(_IsiOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and $([MSBuild]::IsOSPlatform('osx')) and ('$(TargetPlatformIdentifier)' == 'ios' or '$(_IsiOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.ios-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.iossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.iossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and ('$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(_IsMacCatalystLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and $([MSBuild]::IsOSPlatform('osx')) and ('$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(_IsMacCatalystLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.maccatalyst-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.maccatalyst-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and ('$(TargetPlatformIdentifier)' == 'tvos' or '$(_IstvOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and $([MSBuild]::IsOSPlatform('osx')) and ('$(TargetPlatformIdentifier)' == 'tvos' or '$(_IstvOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.tvos-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.tvossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.tvossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net10" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.browser-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and '$(RuntimeIdentifier)' == 'wasi-wasm' and '$(UsingWasiRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.WebAssembly.Wasi.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Wasi.Sdk.net10" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.wasi-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <PropertyGroup Condition="'$(TargetsCurrent)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <_MonoWorkloadRuntimePackPackageVersion>$(_RuntimePackInWorkloadVersionCurrent)</_MonoWorkloadRuntimePackPackageVersion>
    <_KnownWebAssemblySdkPackVersion>$(_RuntimePackInWorkloadVersionCurrent)</_KnownWebAssemblySdkPackVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetsCurrent)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <KnownRuntimePack Update="@(KnownRuntimePack)">
      <!-- FIXMEWASI: workaround for now -->
      <RuntimePackRuntimeIdentifiers Condition="'%(KnownRuntimePack.TargetFramework)' == 'net10.0' and '$(RuntimeIdentifier)' == 'wasi-wasm'">%(RuntimePackRuntimeIdentifiers);wasi-wasm</RuntimePackRuntimeIdentifiers>
      <LatestRuntimeFrameworkVersion Condition="'%(KnownRuntimePack.TargetFramework)' == 'net10.0' and '%(KnownRuntimePack.RuntimePackLabels)' == 'Mono'">$(_MonoWorkloadRuntimePackPackageVersion)</LatestRuntimeFrameworkVersion>
      <!-- Overrides for wasm threading support -->
      <RuntimePackNamePatterns Condition="'%(KnownRuntimePack.TargetFramework)' == 'net10.0' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(WasmEnableThreads)' == 'true'">Microsoft.NETCore.App.Runtime.Mono.multithread.**RID**</RuntimePackNamePatterns>
    </KnownRuntimePack>
    <KnownFrameworkReference Update="Microsoft.NETCore.App">
      <TargetingPackVersion Condition="'%(KnownFrameworkReference.TargetFramework)' == 'net10.0'">$(_MonoWorkloadRuntimePackPackageVersion)</TargetingPackVersion>
    </KnownFrameworkReference>
    <KnownWebAssemblySdkPack Update="@(KnownWebAssemblySdkPack)">
      <WebAssemblySdkPackVersion Condition="'%(KnownWebAssemblySdkPack.TargetFramework)' == 'net10.0'">$(_KnownWebAssemblySdkPackVersion)</WebAssemblySdkPackVersion>
    </KnownWebAssemblySdkPack>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100/microsoft.net.workload.emscripten.current/10.0.100-rc.1.25420.111/WorkloadManifest.targets
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm'">
    <BrowserWorkloadDisabled Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and !$([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '6.0'))">true</BrowserWorkloadDisabled>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(BrowserWorkloadDisabled)' == 'true'">
    <_NativeBuildNeeded Condition="'$(RunAOTCompilation)' == 'true'">true</_NativeBuildNeeded>
    <WorkloadDisabledWithReason Condition="'$(_NativeBuildNeeded)' == 'true'">WebAssembly workloads (required for AOT) are only supported for projects targeting net6.0+</WorkloadDisabledWithReason>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(BrowserWorkloadDisabled)' != 'true'">
    <UsingBrowserRuntimeWorkload Condition="'$(RunAOTCompilation)' == 'true' or !('$(UsingMicrosoftNETSdkBlazorWebAssembly)' == 'true' or '$(UsingMicrosoftNETSdkWebAssembly)' == 'true')">true</UsingBrowserRuntimeWorkload>
    <UsingBrowserRuntimeWorkload Condition="'$(UsingBrowserRuntimeWorkload)' == ''">$(WasmNativeWorkload)</UsingBrowserRuntimeWorkload>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingEmscriptenWorkload)' == 'true'">
    <CurrentEmsdkTarget Condition="'$(TreatPreviousAsCurrent)' == 'true'">9.0</CurrentEmsdkTarget>
    <CurrentEmsdkTarget Condition="'$(TreatPreviousAsCurrent)' != 'true'">10.0</CurrentEmsdkTarget>
  </PropertyGroup>
  <PropertyGroup Condition="'$(BrowserWorkloadDisabled)' == 'true'">
    <UsingBrowserRuntimeWorkload>false</UsingBrowserRuntimeWorkload>
    <WasmNativeWorkload>false</WasmNativeWorkload>
  </PropertyGroup>
  <!--<ImportGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and ('$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingEmscriptenWorkload)' == 'true') and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '$(CurrentEmsdkTarget)'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Python.net10" Condition="!$([MSBuild]::IsOsPlatform('Linux'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Node.net10" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Sdk.net10" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net10" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100/microsoft.net.workload.emscripten.net6/10.0.100-rc.1.25420.111/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '6.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Python.net6" Condition="!$([MSBuild]::IsOsPlatform('Linux'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Node.net6" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100/microsoft.net.workload.emscripten.net7/10.0.100-rc.1.25420.111/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '7.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Python.net7" Condition="!$([MSBuild]::IsOsPlatform('Linux'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Node.net7" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Sdk.net7" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net7" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100/microsoft.net.workload.emscripten.net8/10.0.100-rc.1.25420.111/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '8.0')) and $([MSBuild]::VersionLessThan('$(TargetFrameworkVersion)', '$(CurrentEmsdkTarget)'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Python.net8" Condition="!$([MSBuild]::IsOsPlatform('Linux'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Node.net8" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Sdk.net8" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net8" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100/microsoft.net.workload.emscripten.net9/10.0.100-rc.1.25420.111/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '9.0')) and $([MSBuild]::VersionLessThan('$(TargetFrameworkVersion)', '$(CurrentEmsdkTarget)'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Python.net9" Condition="!$([MSBuild]::IsOsPlatform('Linux'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Node.net9" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Sdk.net9" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net9" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100/microsoft.net.workload.mono.toolchain.net6/10.0.100-rc.1.25420.111/WorkloadManifest.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoAOTCompiler.Task.net6" Condition="'$(TargetsNet6)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingMobileWorkload)' == 'true')" />-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'android'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'android' and '$(RunAOTCompilation)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.android-x86" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.android-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.android-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.android-arm64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'macOS'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <!--
    <ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'macOS' and $([MSBuild]::IsOSPlatform('osx'))">
    <Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.osx-arm64" />
    <Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.osx-x64" />
    </ImportGroup>
  -->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'ios'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'ios' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.ios-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.ios-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.iossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.iossimulator-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.iossimulator-x86" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'maccatalyst'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'maccatalyst' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.maccatalyst-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.maccatalyst-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'tvos'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'tvos' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.tvos-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.tvossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.tvossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net6" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.browser-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <PropertyGroup Condition="'$(TargetsNet6)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(TargetPlatformIdentifier)' == 'macOS' or '$(TargetPlatformIdentifier)' == 'ios' or '$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(TargetPlatformIdentifier)' == 'tvos' or '$(RuntimeIdentifier)' == 'browser-wasm')">
    <_MonoWorkloadTargetsMobile>true</_MonoWorkloadTargetsMobile>
    <_MonoWorkloadRuntimePackPackageVersion>$(_RuntimePackInWorkloadVersion6)</_MonoWorkloadRuntimePackPackageVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetsNet6)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <KnownRuntimePack Update="@(KnownRuntimePack)">
      <LatestRuntimeFrameworkVersion Condition="'%(KnownRuntimePack.TargetFramework)' == 'net6.0' and '%(KnownRuntimePack.RuntimePackLabels)' == 'Mono'">$(_MonoWorkloadRuntimePackPackageVersion)</LatestRuntimeFrameworkVersion>
    </KnownRuntimePack>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100/microsoft.net.workload.mono.toolchain.net7/10.0.100-rc.1.25420.111/WorkloadManifest.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoAOTCompiler.Task.net7" Condition="'$(TargetsNet7)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingMobileWorkload)' == 'true')" />-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'android'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'android' and '$(RunAOTCompilation)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.android-x86" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.android-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.android-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.android-arm64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'macOS'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'ios'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'ios' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.ios-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.ios-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.iossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.iossimulator-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.iossimulator-x86" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'maccatalyst'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'maccatalyst' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.maccatalyst-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.maccatalyst-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'tvos'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'tvos' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.tvos-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.tvossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.tvossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net7" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.browser-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--</ImportGroup>-->
  <PropertyGroup Condition="'$(TargetsNet7)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(TargetPlatformIdentifier)' == 'macOS' or '$(TargetPlatformIdentifier)' == 'ios' or '$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(TargetPlatformIdentifier)' == 'tvos' or '$(RuntimeIdentifier)' == 'browser-wasm')">
    <_MonoWorkloadTargetsMobile>true</_MonoWorkloadTargetsMobile>
    <_MonoWorkloadRuntimePackPackageVersion>$(_RuntimePackInWorkloadVersion7)</_MonoWorkloadRuntimePackPackageVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetsNet7)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <KnownRuntimePack Update="@(KnownRuntimePack)">
      <LatestRuntimeFrameworkVersion Condition="'%(KnownRuntimePack.TargetFramework)' == 'net7.0' and '%(KnownRuntimePack.RuntimePackLabels)' == 'Mono'">$(_MonoWorkloadRuntimePackPackageVersion)</LatestRuntimeFrameworkVersion>
      <!-- Overrides for wasm threads support -->
      <RuntimePackNamePatterns Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(WasmEnablethreads)' == 'true'">Microsoft.NETCore.App.Runtime.Mono.multithread.**RID**</RuntimePackNamePatterns>
    </KnownRuntimePack>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100/microsoft.net.workload.mono.toolchain.net8/10.0.100-rc.1.25420.111/WorkloadManifest.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoAOTCompiler.Task.net8" Condition="'$(TargetsNet8)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingMobileWorkload)' == 'true')" />-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'android'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'android' and '$(RunAOTCompilation)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.android-x86" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.android-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.android-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.android-arm64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'macOS'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'ios'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'ios' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.ios-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.iossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.iossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'maccatalyst'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'maccatalyst' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.maccatalyst-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.maccatalyst-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'tvos'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'tvos' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.tvos-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.tvossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.tvossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net8" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.browser-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--</ImportGroup>-->
  <PropertyGroup Condition="'$(TargetsNet8)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(TargetPlatformIdentifier)' == 'macOS' or '$(TargetPlatformIdentifier)' == 'ios' or '$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(TargetPlatformIdentifier)' == 'tvos' or '$(RuntimeIdentifier)' == 'browser-wasm' or '$(RuntimeIdentifier)' == 'wasi-wasm')">
    <_MonoWorkloadTargetsMobile>true</_MonoWorkloadTargetsMobile>
    <_MonoWorkloadRuntimePackPackageVersion>$(_RuntimePackInWorkloadVersion8)</_MonoWorkloadRuntimePackPackageVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetsNet8)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <KnownRuntimePack Update="@(KnownRuntimePack)">
      <!-- FIXMEWASI: workaround for now -->
      <RuntimePackRuntimeIdentifiers Condition="'$(RuntimeIdentifier)' == 'wasi-wasm'">%(RuntimePackRuntimeIdentifiers);wasi-wasm</RuntimePackRuntimeIdentifiers>
      <LatestRuntimeFrameworkVersion Condition="'%(KnownRuntimePack.TargetFramework)' == 'net8.0' and '%(KnownRuntimePack.RuntimePackLabels)' == 'Mono'">$(_MonoWorkloadRuntimePackPackageVersion)</LatestRuntimeFrameworkVersion>
      <!-- Overrides for wasm threads support -->
      <RuntimePackNamePatterns Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(WasmEnablethreads)' == 'true'">Microsoft.NETCore.App.Runtime.Mono.multithread.**RID**</RuntimePackNamePatterns>
    </KnownRuntimePack>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/usr/share/dotnet/sdk-manifests/10.0.100/microsoft.net.workload.mono.toolchain.net9/10.0.100-rc.1.25420.111/WorkloadManifest.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!-- TFM specific -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoAOTCompiler.Task.net9" Condition="'$(TargetsNet9)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingMobileWorkload)' == 'true' or '$(UsingWasiRuntimeWorkload)' == 'true')" />-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(_IsAndroidLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and ('$(_IsAndroidLibraryMode)' == 'true' or '$(_IsAppleMobileLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.LibraryBuilder.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.LibraryBuilder.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(_IsAndroidLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.android-x86" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.android-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.android-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.android-arm64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and '$(TargetPlatformIdentifier)' == 'macOS'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and ('$(TargetPlatformIdentifier)' == 'ios' or '$(_IsiOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and $([MSBuild]::IsOSPlatform('osx')) and ('$(TargetPlatformIdentifier)' == 'ios' or '$(_IsiOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.ios-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.iossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.iossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and ('$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(_IsMacCatalystLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and $([MSBuild]::IsOSPlatform('osx')) and ('$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(_IsMacCatalystLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.maccatalyst-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.maccatalyst-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and ('$(TargetPlatformIdentifier)' == 'tvos' or '$(_IstvOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and $([MSBuild]::IsOSPlatform('osx')) and ('$(TargetPlatformIdentifier)' == 'tvos' or '$(_IstvOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.tvos-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.tvossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.tvossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net9" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.browser-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and '$(RuntimeIdentifier)' == 'wasi-wasm' and '$(UsingWasiRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.WebAssembly.Wasi.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Wasi.Sdk.net9" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.wasi-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <PropertyGroup Condition="'$(TargetsNet9)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <_MonoWorkloadRuntimePackPackageVersion>$(_RuntimePackInWorkloadVersion9)</_MonoWorkloadRuntimePackPackageVersion>
    <_KnownWebAssemblySdkPackVersion>$(_RuntimePackInWorkloadVersion9)</_KnownWebAssemblySdkPackVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetsNet9)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <KnownRuntimePack Update="@(KnownRuntimePack)">
      <!-- FIXMEWASI: workaround for now -->
      <RuntimePackRuntimeIdentifiers Condition="'%(KnownRuntimePack.TargetFramework)' == 'net9.0' and '$(RuntimeIdentifier)' == 'wasi-wasm'">%(RuntimePackRuntimeIdentifiers);wasi-wasm</RuntimePackRuntimeIdentifiers>
      <LatestRuntimeFrameworkVersion Condition="'%(KnownRuntimePack.TargetFramework)' == 'net9.0' and '%(KnownRuntimePack.RuntimePackLabels)' == 'Mono'">$(_MonoWorkloadRuntimePackPackageVersion)</LatestRuntimeFrameworkVersion>
      <!-- Overrides for wasm threading support -->
      <RuntimePackNamePatterns Condition="'%(KnownRuntimePack.TargetFramework)' == 'net9.0' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(WasmEnableThreads)' == 'true'">Microsoft.NETCore.App.Runtime.Mono.multithread.**RID**</RuntimePackNamePatterns>
    </KnownRuntimePack>
    <KnownFrameworkReference Update="Microsoft.NETCore.App">
      <TargetingPackVersion Condition="'%(KnownFrameworkReference.TargetFramework)' == 'net9.0'">$(_MonoWorkloadRuntimePackPackageVersion)</TargetingPackVersion>
    </KnownFrameworkReference>
    <KnownWebAssemblySdkPack Update="@(KnownWebAssemblySdkPack)">
      <WebAssemblySdkPackVersion Condition="'%(KnownWebAssemblySdkPack.TargetFramework)' == 'net9.0'">$(_KnownWebAssemblySdkPackVersion)</WebAssemblySdkPackVersion>
    </KnownWebAssemblySdkPack>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.ImportWorkloads.targets
============================================================================================================================================
-->
  <UsingTask TaskName="ShowMissingWorkloads" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="GetSuggestedWorkloads" Returns="@(SuggestedWorkload)" Condition="@(MissingWorkloadPack) != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ShowMissingWorkloads MissingWorkloadPacks="@(MissingWorkloadPack)" NetCoreRoot="$(NetCoreRoot)" NETCoreSdkVersion="$(NETCoreSdkVersion)" GenerateErrorsForMissingWorkloads="false">
      <Output TaskParameter="SuggestedWorkloads" ItemName="SuggestedWorkload" />
    </ShowMissingWorkloads>
  </Target>
  <!-- Skip this target for design time builds when there are missing workload packs.
       This will prevent design time builds from failing and therefore allow
       Visual Studio to collect the workloads from the GetSuggestedWorkloads target -->
  <Target Name="_CheckForMissingWorkload" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;_CheckForUnsupportedTargetPlatformIdentifier" Condition="'@(MissingWorkloadPack)' != '' And '$(DesignTimeBuild)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ShowMissingWorkloads MissingWorkloadPacks="@(MissingWorkloadPack)" NetCoreRoot="$(NetCoreRoot)" NETCoreSdkVersion="$(NETCoreSdkVersion)" GenerateErrorsForMissingWorkloads="true" />
  </Target>
  <!--  This target is not part of the build. Only used by dotnet workload restore command. Global property "SkipResolvePackageAssets"
        need to be set to "true" to avoid requiring restore (which would likely fail if the required workloads aren't already installed).
        In addition, since this is a target that is called on potentially-unsupported project types like esproj, we need to not fail
        if the Target is missing. -->
  <Target Name="_GetRequiredWorkloads" DependsOnTargets="GetSuggestedWorkloads;PrepareProjectReferences" Returns="@(_ResolvedSuggestedWorkload)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="_GetRequiredWorkloads" BuildInParallel="$(BuildInParallel)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences);TargetFramework;TargetFrameworks" SkipNonexistentTargets="true">
      <Output TaskParameter="TargetOutputs" ItemName="SuggestedWorkloadFromReference" />
    </MSBuild>
    <ItemGroup>
      <_ResolvedSuggestedWorkload Include="@(SuggestedWorkload)" />
      <_ResolvedSuggestedWorkload Include="@(SuggestedWorkloadFromReference)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!--
    Use RuntimeIdentifier to determine PlatformTarget.
    Also, enforce that RuntimeIdentifier is always specified for .NETFramework executables.
  -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.RuntimeIdentifierInference.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.RuntimeIdentifierInference.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.RuntimeIdentifierInference.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    .NET Framework cannot load native package dependencies dynamically
    based on the current architecture.  We must have a RID to resolve
    and copy native dependencies to the output directory.

    When building a .NET Framework exe on Windows and not given a RID,
    we'll pick either win7-x64 or win7-x86 (based on PlatformTarget)
    if we're not given an explicit RID. However, if after resolving
    NuGet assets we find no copy-local native dependencies, we will
    emit the binary as AnyCPU.

    Note that we must set the RID here early (to be seen during NuGet
    restore) in order for the project.assets.json to include the
    native dependencies that will let us make the final call on
    AnyCPU or platform-specific.

    This allows these common cases to work without requiring mention
    of RuntimeIdentifier in the user project PlatformTarget:

      1. Building an AnyCPU .NET Framework application on any host OS
         with no native NuGet dependencies.

      2. Building an x86 or x64 .NET Framework application on and for
         Windows with native NuGet dependencies that do not require
         greater than win7.

     However, any other combination of host operating system, CPU
     architecture, and minimum Windows version will require some
     manual intervention in the project file to set up the right
     RID. (**)

     (*) Building NET4x from non-Windows is still not fully supported:
         https://github.com/dotnet/sdk/issues/335) The point above is
         that this code would not have to change to make the first
         scenario work on non-Windows hosts.

     (**) https://github.com/dotnet/sdk/issues/840 tracks improving
          the default RID selection here to make more non-AnyCPU scenarios
          work without user intervention. The current static evaluation
          requirement limits us.
   -->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and&#xA;                            '$(HasRuntimeOutput)' == 'true' and&#xA;                            $([MSBuild]::IsOSPlatform(`Windows`)) and&#xA;                            '$(RuntimeIdentifier)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_UsingDefaultRuntimeIdentifier>true</_UsingDefaultRuntimeIdentifier>
    <RuntimeIdentifier Condition="'$(PlatformTarget)' == 'x64'">win7-x64</RuntimeIdentifier>
    <RuntimeIdentifier Condition="'$(PlatformTarget)' == 'x86' or '$(PlatformTarget)' == ''">win7-x86</RuntimeIdentifier>
    <RuntimeIdentifier Condition="'$(PlatformTarget)' == 'x64' and '$(UseRidGraph)' != 'true'">win-x64</RuntimeIdentifier>
    <RuntimeIdentifier Condition="('$(PlatformTarget)' == 'x86' or '$(PlatformTarget)' == '') and '$(UseRidGraph)' != 'true'">win-x86</RuntimeIdentifier>
  </PropertyGroup>
  <!-- Breaking change in .NET 8: Some publish properties used to imply SelfContained or require it at the time of this PR to work. We decided to infer SelfContained still in these situations. -->
  <PropertyGroup Condition="'$(SelfContained)' == '' and&#xA;                             '$(PublishSelfContained)' == '' and&#xA;                             '$(_TargetFrameworkVersionWithoutV)' != '' and&#xA;                             '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and&#xA;                             $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '8.0')) and&#xA;                              (&#xA;                                  '$(PublishTrimmed)' == 'true' or&#xA;                                  '$(PublishSingleFile)' == 'true' or&#xA;                                  '$(PublishAot)' == 'true'&#xA;                              )" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PublishSelfContained>true</PublishSelfContained>
  </PropertyGroup>
  <!-- Packing a tool runs the publish targets, so in that case set _IsPublishing to true -->
  <PropertyGroup Condition="'$(PackAsTool)' == 'true' And '$(_IsPacking)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_IsPublishing>true</_IsPublishing>
  </PropertyGroup>
  <!-- Edit SelfContained to match the value of PublishSelfContained if we are publishing.
       This Won't affect t:/Publish (because of _IsPublishing), and also won't override a global SelfContained property.-->
  <PropertyGroup Condition="'$(_IsPublishing)' == 'true' and ('$(PublishSelfContained)' == 'true' or '$(PublishSelfContained)' == 'false')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <SelfContained>$(PublishSelfContained)</SelfContained>
  </PropertyGroup>
  <!-- Automatically infer the RuntimeIdentifier for properties that require it.
  SelfContained without a RID is a no-op and semantically hints towards the fact that it can change the behavior of build, publish, and friends.
  ... So, we infer the RID for SelfContained regardless of the context.

  The other publish properties are specifically labelled Publish* and don't 'NEED' their RID unless we are doing a publish, so the RID inference
  ... for these properties is limited to publishing only scenarios.

  .NET Tools that build RID-specific packages will also need a primary package without a RuntimeIdentifier, so we disable RID inference for them
  in order to build the primary package

  Finally, library projects and non-executable projects have awkward interactions here so they are excluded.
  -->
  <PropertyGroup Condition="'$(UseCurrentRuntimeIdentifier)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <UseCurrentRuntimeIdentifier Condition="&#xA;                 '$(RuntimeIdentifier)' == '' and&#xA;                 '$(_IsExecutable)' == 'true' and&#xA;                 '$(IsRidAgnostic)' != 'true' and&#xA;                 '$(PackAsTool)' != true and&#xA;                 (&#xA;                   '$(SelfContained)' == 'true' or&#xA;                   ('$(_IsPublishing)' == 'true' and&#xA;                      (&#xA;                        '$(PublishReadyToRun)' == 'true' or&#xA;                        '$(PublishSingleFile)' == 'true' or&#xA;                        '$(PublishAot)' == 'true'&#xA;                      )&#xA;                   )&#xA;                 )">true</UseCurrentRuntimeIdentifier>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseCurrentRuntimeIdentifier)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RuntimeIdentifier>$(NETCoreSdkPortableRuntimeIdentifier)</RuntimeIdentifier>
  </PropertyGroup>
  <PropertyGroup Condition="'$(_IsPublishing)' == 'true' and '$(PublishRuntimeIdentifier)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RuntimeIdentifier>$(PublishRuntimeIdentifier)</RuntimeIdentifier>
  </PropertyGroup>
  <PropertyGroup Condition="'$(PlatformTarget)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_UsingDefaultPlatformTarget>true</_UsingDefaultPlatformTarget>
  </PropertyGroup>
  <!-- Determine PlatformTarget (if not already set) from runtime identifier. -->
  <Choose xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <When Condition="'$(PlatformTarget)' != '' or '$(RuntimeIdentifier)' == ''" />
    <When Condition="$(RuntimeIdentifier.EndsWith('-x86')) or $(RuntimeIdentifier.Contains('-x86-'))">
      <PropertyGroup>
        <PlatformTarget>x86</PlatformTarget>
      </PropertyGroup>
    </When>
    <When Condition="$(RuntimeIdentifier.EndsWith('-x64')) or $(RuntimeIdentifier.Contains('-x64-'))">
      <PropertyGroup>
        <PlatformTarget>x64</PlatformTarget>
      </PropertyGroup>
    </When>
    <When Condition="$(RuntimeIdentifier.EndsWith('-arm')) or $(RuntimeIdentifier.Contains('-arm-'))">
      <PropertyGroup>
        <PlatformTarget>arm</PlatformTarget>
      </PropertyGroup>
    </When>
    <When Condition="$(RuntimeIdentifier.EndsWith('-arm64')) or $(RuntimeIdentifier.Contains('-arm64-'))">
      <PropertyGroup>
        <PlatformTarget>arm64</PlatformTarget>
      </PropertyGroup>
    </When>
    <Otherwise>
      <PropertyGroup>
        <PlatformTarget>AnyCPU</PlatformTarget>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <!--
    SelfContained was not an option in .NET Core SDK 1.0.
    Default SelfContained based on the RuntimeIdentifier, so projects don't have to explicitly set SelfContained.
    This avoids a breaking change from 1.0 behavior.
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Detecting property presence is not harmful and can be done in an unconditioned way -->
    <_SelfContainedWasSpecified Condition="'$(SelfContained)' != ''">true</_SelfContainedWasSpecified>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(HasRuntimeOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Breaking change in .NET 8: Projects with 8.0+ TFMS will no longer have RuntimeIdentifier imply SelfContained. Note that PublishReadyToRun will imply SelfContained in these versions. -->
    <SelfContained Condition="'$(SelfContained)' == '' and&#xA;                              '$(RuntimeIdentifier)' != '' and&#xA;                              '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and&#xA;                              '$(_TargetFrameworkVersionWithoutV)' != '' and&#xA;                              $([MSBuild]::VersionLessThan($(_TargetFrameworkVersionWithoutV), '8.0'))">true</SelfContained>
    <SelfContained Condition="'$(SelfContained)' == ''">false</SelfContained>
    <_RuntimeIdentifierUsesAppHost Condition="$(RuntimeIdentifier.StartsWith('ios')) or $(RuntimeIdentifier.StartsWith('tvos')) or $(RuntimeIdentifier.StartsWith('maccatalyst')) or $(RuntimeIdentifier.StartsWith('android')) or $(RuntimeIdentifier.StartsWith('browser')) or $(RuntimeIdentifier.StartsWith('wasi')) or $(RuntimeIdentifier) == 'any'">false</_RuntimeIdentifierUsesAppHost>
    <_RuntimeIdentifierUsesAppHost Condition="'$(_IsPublishing)' == 'true' and '$(PublishAot)' == 'true'">false</_RuntimeIdentifierUsesAppHost>
    <_RuntimeIdentifierUsesAppHost Condition="'$(_RuntimeIdentifierUsesAppHost)' == ''">true</_RuntimeIdentifierUsesAppHost>
    <UseAppHost Condition="'$(UseAppHost)' == '' and&#xA;                           '$(_RuntimeIdentifierUsesAppHost)' == 'true' and&#xA;                           ('$(SelfContained)' == 'true' or&#xA;                            ('$(RuntimeIdentifier)' != '' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '2.1') or&#xA;                            '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0')">true</UseAppHost>
    <UseAppHost Condition="'$(UseAppHost)' == ''">false</UseAppHost>
  </PropertyGroup>
  <!-- Only use the default apphost if building without a RID and without a deps file path (used by GenerateDeps.proj for CLI tools). -->
  <PropertyGroup Condition="'$(DefaultAppHostRuntimeIdentifier)' == '' and&#xA;                            '$(RuntimeIdentifier)' == '' and&#xA;                            (('$(UseAppHost)' == 'true' and '$(ProjectDepsFilePath)' == '') or&#xA;                            ('$(EnableComHosting)' == 'true' and '$(_IsExecutable)' != 'true') or&#xA;                            '$(UseIJWHost)' == 'true')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DefaultAppHostRuntimeIdentifier>$(NETCoreSdkRuntimeIdentifier)</DefaultAppHostRuntimeIdentifier>
    <DefaultAppHostRuntimeIdentifier Condition="$(DefaultAppHostRuntimeIdentifier.StartsWith('win')) and '$(PlatformTarget)' == 'x64'">win-x64</DefaultAppHostRuntimeIdentifier>
    <DefaultAppHostRuntimeIdentifier Condition="$(DefaultAppHostRuntimeIdentifier.StartsWith('win')) and '$(PlatformTarget)' == 'x86'">win-x86</DefaultAppHostRuntimeIdentifier>
    <DefaultAppHostRuntimeIdentifier Condition="$(DefaultAppHostRuntimeIdentifier.StartsWith('win')) and '$(PlatformTarget)' == 'ARM'">win-arm</DefaultAppHostRuntimeIdentifier>
    <DefaultAppHostRuntimeIdentifier Condition="$(DefaultAppHostRuntimeIdentifier.StartsWith('win')) and '$(PlatformTarget)' == 'ARM64'">win-arm64</DefaultAppHostRuntimeIdentifier>
    <!-- If we are running on an M1 with a native SDK and the TFM is < 6.0, we have to use a x64 apphost since there are no osx-arm64 apphosts previous to .NET 6.0. -->
    <DefaultAppHostRuntimeIdentifier Condition="$(DefaultAppHostRuntimeIdentifier.EndsWith('arm64')) and&#xA;                                  $(DefaultAppHostRuntimeIdentifier.StartsWith('osx')) and&#xA;                                  $([MSBuild]::VersionLessThan('$(_TargetFrameworkVersionWithoutV)', '6.0'))">$(DefaultAppHostRuntimeIdentifier.Replace("arm64", "x64"))</DefaultAppHostRuntimeIdentifier>
    <!-- If we are running on win-arm64 and the TFM is < 5.0, we have to use a x64 apphost since there are no win-arm64 apphosts previous to .NET 5.0. -->
    <DefaultAppHostRuntimeIdentifier Condition="$(DefaultAppHostRuntimeIdentifier.EndsWith('arm64')) and&#xA;                                  $(DefaultAppHostRuntimeIdentifier.StartsWith('win')) and&#xA;                                  $([MSBuild]::VersionLessThan('$(_TargetFrameworkVersionWithoutV)', '5.0'))">$(DefaultAppHostRuntimeIdentifier.Replace("arm64", "x64"))</DefaultAppHostRuntimeIdentifier>
  </PropertyGroup>
  <Target Name="_CheckForUnsupportedAppHostUsage" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(HasRuntimeOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- The following RID errors are asserts, and we don't expect them to ever occur. The error message is added as a safeguard.-->
    <NETSdkError Condition="'$(SelfContained)' == 'true' and '$(RuntimeIdentifier)' == '' and '$(AllowSelfContainedWithoutRuntimeIdentifier)' != 'true'" ResourceName="ImplicitRuntimeIdentifierResolutionForPublishPropertyFailed" FormatArguments="SelfContained" />
    <NETSdkError Condition="'$(PublishReadyToRun)' == 'true' and '$(RuntimeIdentifier)' == '' and '$(_IsPublishing)' == 'true' and '$(AllowReadyToRunWithoutRuntimeIdentifier)' != 'true'" ResourceName="ImplicitRuntimeIdentifierResolutionForPublishPropertyFailed" FormatArguments="PublishReadyToRun" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' and '$(RuntimeIdentifier)' == '' and '$(_IsPublishing)' == 'true' and '$(AllowPublishSingleFileWithoutRuntimeIdentifier)' != 'true'" ResourceName="ImplicitRuntimeIdentifierResolutionForPublishPropertyFailed" FormatArguments="PublishSingleFile" />
    <NETSdkError Condition="'$(PublishAot)' == 'true' and '$(RuntimeIdentifier)' == '' and '$(_IsPublishing)' == 'true' and '$(AllowPublishAotWithoutRuntimeIdentifier)' != 'true'" ResourceName="ImplicitRuntimeIdentifierResolutionForPublishPropertyFailed" FormatArguments="PublishAot" />
    <!-- End of implicit RID resolver checks.-->
    <NETSdkError Condition="'$(PublishSelfContained)' != 'true' and '$(PublishSelfContained)' != 'false' and '$(PublishSelfContained)' != ''" ResourceName="PublishSelfContainedMustBeBool" FormatArguments="$(PublishSelfContained)" />
    <NETSdkError Condition="'$(SelfContained)' == 'true' and '$(UseAppHost)' != 'true' and '$(_RuntimeIdentifierUsesAppHost)' == 'true'" ResourceName="CannotUseSelfContainedWithoutAppHost" />
    <NETSdkError Condition="'$(SelfContained)' != 'true' and '$(UseAppHost)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' &lt; '2.1'" ResourceName="FrameworkDependentAppHostRequiresVersion21" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' &lt; '3.0'" ResourceName="PublishSingleFileRequiresVersion30" />
    <!-- The TFM version checks for PublishReadyToRun PublishTrimmed only generate warnings in .Net core 3.1
         because we do not want the behavior to be a breaking change compared to version 3.0 -->
    <NETSdkWarning Condition="'$(PublishReadyToRun)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' &lt; '3.0'" ResourceName="PublishReadyToRunRequiresVersion30" />
    <!-- Previously, RuntimeIdentifier (RID) implied SelfContained (SC). A breaking change in 8.0 made it so RID did not activate SC by default.
         So we warn older TFM users before they upgrade to TFM 8.0 or above that they need to add <SelfContained>true</SelfContained> now to keep the same behavior.-->
    <NETSdkWarning Condition="'$(RuntimeIdentifier)' != '' and '$(_TargetFrameworkVersionWithoutV)' != '' and $([MSBuild]::VersionLessThan($(_TargetFrameworkVersionWithoutV), '8.0')) and '$(_SelfContainedWasSpecified)' != 'true'" ResourceName="RuntimeIdentifierWillNoLongerImplySelfContained" />
    <!-- Generate Trimming warnings for WinForms and Wpf applications-->
    <NetSdkError Condition="('$(UseWindowsForms)' == 'true') and ('$(PublishTrimmed)' == 'true') and ('$(_SuppressWinFormsTrimError)' != 'true')" ResourceName="TrimmingWindowsFormsIsNotSupported" />
    <NetSdkError Condition="('$(UseWpf)' == 'true') and ('$(PublishTrimmed)' == 'true') and ('$(_SuppressWpfTrimError)' != 'true')" ResourceName="TrimmingWpfIsNotSupported" />
  </Target>
  <Target Name="_CheckForUnsupportedHostingUsage" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning Condition="'$(SelfContained)' == 'true' and '$(EnableComHosting)' == 'true'" ResourceName="NoSupportComSelfContained" />
  </Target>
  <Target Name="_CheckAndUnsetUnsupportedPrefer32Bit" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '7.0'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning Condition="'$(Prefer32Bit)' == 'true'" ResourceName="Prefer32BitIgnoredForNetCoreApp" />
    <PropertyGroup>
      <Prefer32Bit>false</Prefer32Bit>
    </PropertyGroup>
  </Target>
  <Target Name="_CheckAndUnsetUnsupportedPreferNativeArm64" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(PreferNativeArm64)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning ResourceName="PreferNativeArm64IgnoredForNetCoreApp" />
    <PropertyGroup>
      <PreferNativeArm64>false</PreferNativeArm64>
    </PropertyGroup>
  </Target>
  <Target Name="_CheckForMismatchingPlatform" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(RuntimeIdentifier)' != '' and '$(PlatformTarget)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(PlatformTarget)' != 'AnyCPU' and !$(RuntimeIdentifier.ToUpperInvariant().Contains($(PlatformTarget.ToUpperInvariant())))" ResourceName="CannotHaveRuntimeIdentifierPlatformMismatchPlatformTarget" FormatArguments="$(RuntimeIdentifier);$(PlatformTarget)" />
  </Target>
  <Target Name="_CheckForLanguageAndFeatureCombinationSupport" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;ProcessFrameworkReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true') and $(OutputType) != 'library' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" ResourceName="NoSupportCppNonDynamicLibraryDotnetCore" />
    <NETSdkError Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true') and $(EnableComHosting) == 'true'" ResourceName="NoSupportCppEnableComHosting" />
    <NETSdkError Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true') and $(SelfContained) == 'true'" ResourceName="NoSupportCppSelfContained" />
  </Target>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Suppress the .NET Core SDK preview message if the users has tried to express their intent to do so.
         MSBuild doesn't allow Messages to be suppressed by NoWarn, but we've trained users to reach for this,
         so let's bridge their intent a bit. -->
    <SuppressNETCoreSdkPreviewMessage Condition="'$(_NETCoreSdkIsPreview)' == 'true'&#xA;                  AND '$(SuppressNETCoreSdkPreviewMessage)' == ''&#xA;                  AND '$(NoWarn)' != ''&#xA;                  AND $(NoWarn.Contains('NETSDK1057'))">true</SuppressNETCoreSdkPreviewMessage>
  </PropertyGroup>
  <Target Name="_CheckForNETCoreSdkIsPreview" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition=" '$(_NETCoreSdkIsPreview)' == 'true' AND '$(SuppressNETCoreSdkPreviewMessage)' != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ShowPreviewMessage />
  </Target>
  <!-- Projects which don't use Microsoft.NET.Sdk will typically define the OutputPath directly (usually in a
       Configuration-specific PropertyGroup), so in that case we won't append to it by default. -->
  <PropertyGroup Condition="'$(UsingNETSdkDefaults)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Projects can opt out of having the RID appended to the output path by setting this to false. -->
    <AppendRuntimeIdentifierToOutputPath Condition="'$(AppendRuntimeIdentifierToOutputPath)' == ''">true</AppendRuntimeIdentifierToOutputPath>
  </PropertyGroup>
  <!--
    Append $(RuntimeIdentifier) directory to output and intermediate paths to prevent bin clashes between
    targets.

    But do not append the implicit default runtime identifier for .NET Framework apps as that would
    append a RID the user never mentioned in the path and do so even in the AnyCPU case.
   -->
  <PropertyGroup Condition="'$(AppendRuntimeIdentifierToOutputPath)' == 'true' and '$(RuntimeIdentifier)' != '' and '$(_UsingDefaultRuntimeIdentifier)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <IntermediateOutputPath Condition="'$(UseArtifactsIntermediateOutput)' != 'true'">$(IntermediateOutputPath)$(RuntimeIdentifier)\</IntermediateOutputPath>
    <OutputPath Condition="'$(UseArtifactsOutput)' != 'true'">$(OutputPath)$(RuntimeIdentifier)\</OutputPath>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.GetDefaultPlatformTargetForNetFramework" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    Switch our default .NETFramework CPU architecture choice back to AnyCPU before
    compiling the exe if no copy-local native dependencies were resolved from NuGet
  -->
  <Target Name="AdjustDefaultPlatformTargetForNetFrameworkExeWithNoNativeCopyLocalItems" AfterTargets="ResolvePackageAssets" BeforeTargets="CoreCompile" Condition="'$(_UsingDefaultPlatformTarget)' == 'true' and&#xA;                     '$(_UsingDefaultRuntimeIdentifier)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GetDefaultPlatformTargetForNetFramework PackageDependencies="@(PackageDependencies)" NativeCopyLocalItems="@(NativeCopyLocalItems)">
      <Output TaskParameter="DefaultPlatformTarget" PropertyName="PlatformTarget" />
    </GetDefaultPlatformTargetForNetFramework>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!-- Checks for EOL frameworks -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.EolTargetFrameworks.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.EolTargetFrameworks.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.EolTargetFrameworks.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Default the check to true, but allow developers to turn the warning off. -->
    <CheckEolTargetFramework Condition="'$(CheckEolTargetFramework)' == '' and '$(OutputType)' != 'Library'">true</CheckEolTargetFramework>
    <CheckEolWorkloads Condition="'$(CheckEolWorkloads)' == ''">true</CheckEolWorkloads>
  </PropertyGroup>
  <!--
    .NET Core framework versions that are currently considered to be end-of-life (EOL). These versions will not be targeted to
    receive servicing updates and security fixes.
  -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_EolNetCoreTargetFrameworkVersions Include="1.0;1.1;2.0;2.1;2.2;3.0;3.1;5.0;6.0;7.0" />
  </ItemGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_MinimumNonEolSupportedNetCoreTargetFramework>net8.0</_MinimumNonEolSupportedNetCoreTargetFramework>
  </PropertyGroup>
  <Target Name="_CheckForEolTargetFrameworks" AfterTargets="_CheckForUnsupportedNETCoreVersion" Condition="'@(_EolNetCoreTargetFrameworkVersions-&gt;AnyHaveMetadataValue('Identity', '$(_TargetFrameworkVersionWithoutV)'))' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(CheckEolTargetFramework)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning ResourceName="TargetFrameworkIsEol" FormatArguments="$(TargetFramework.ToLowerInvariant());https://aka.ms/dotnet-core-support" />
  </Target>
  <Target Name="_CheckForEolWorkloads" AfterTargets="_CheckForUnsupportedNETCoreVersion" Condition="'@(EolWorkload)' != '' and '$(CheckEolWorkloads)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning ResourceName="WorkloadIsEol" FormatArguments="%(EolWorkload.Identity);$([MSBuild]::ValueOrDefault('%(EolWorkload.Url)', 'https://aka.ms/dotnet-core-support'))" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!-- Checks for deprecated Aspire workload usage -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.AspireWorkloadDeprecation.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.AspireWorkloadDeprecation.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.AspireWorkloadDeprecation.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    This target detects old Aspire applications that still depend on the deprecated Aspire workload.

    Starting with Aspire 9.0.0, Aspire moved from a workload-based distribution model to NuGet packages
    with the Aspire.AppHost.Sdk. Projects using the old workload-based approach need to be upgraded.

    Detection logic:
    - IsAspireHost='true' indicates this is an Aspire host project
    - AspireHostingSDKVersion is set by Aspire.AppHost.Sdk in new projects (9.0.0+)
    - If AspireHostingSDKVersion is missing or < 9.0.0, this is likely an old workload-based project

    This check runs before PrepareForBuild to catch the issue early in the build process.

    Note: This error provides a clear upgrade message for customers. Without it, users would get
    confusing errors about missing workloads that no longer exist, since the Aspire workload has
    been removed from the SDK.
  -->
  <Target Name="_CheckForAspireWorkloadDeprecation" BeforeTargets="PrepareForBuild" Condition="'$(IsAspireHost)' == 'true' and ('$(AspireHostingSDKVersion)' == '' or $([MSBuild]::VersionLessThan('$(AspireHostingSDKVersion)', '9.0.0')))">
    <NetSdkError ResourceName="AspireWorkloadIsDeprecated" FormatArguments="https://aka.ms/aspire/update-to-sdk" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!-- Check if the Target Framework is coreclr based -->
  <PropertyGroup Condition="'$(_IsNETCoreOrNETStandard)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_IsNETCoreOrNETStandard Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'">true</_IsNETCoreOrNETStandard>
    <_IsNETCoreOrNETStandard Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">true</_IsNETCoreOrNETStandard>
  </PropertyGroup>
  <!-- Unification / automatic binding redirect logic -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DesignTimeAutoUnify Condition="'$(DesignTimeAutoUnify)' == ''">true</DesignTimeAutoUnify>
    <AutoUnifyAssemblyReferences Condition="'$(AutoUnifyAssemblyReferences)' == '' and $(OutputType) == 'Library'">true</AutoUnifyAssemblyReferences>
    <AutoUnifyAssemblyReferences Condition="'$(AutoUnifyAssemblyReferences)' == '' and '$(_IsNETCoreOrNETStandard)' == 'true'">true</AutoUnifyAssemblyReferences>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(HasRuntimeOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AutoGenerateBindingRedirects Condition="'$(AutoGenerateBindingRedirects)' == ''">true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <!-- Default settings for .NET Core and .NET Standard build logic -->
  <PropertyGroup Condition="'$(_IsNETCoreOrNETStandard)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateDependencyFile Condition=" '$(GenerateDependencyFile)' == '' ">true</GenerateDependencyFile>
    <!-- Assembly and file versions of runtime assets should be written to the deps.json by default, to support
         runtime minor version roll-forward: https://github.com/dotnet/core-setup/issues/3546 -->
    <IncludeFileVersionsInDependencyFile Condition="'$(IncludeFileVersionsInDependencyFile)' == ''">true</IncludeFileVersionsInDependencyFile>
    <!-- Force .dll extension for .NETCoreApp and .NETStandard projects even if output type is exe. -->
    <TargetExt Condition="'$(TargetExt)' == ''">.dll</TargetExt>
    <!-- Disable the use of FrameworkPathOverride in Microsoft.Common.CurrentVersion.targets which can slow down evaluation.  FrameworkPathOverride
    is not needed for NETStandard or NETCore since references come from NuGet packages-->
    <EnableFrameworkPathOverride Condition="'$(EnableFrameworkPathOverride)' == ''">false</EnableFrameworkPathOverride>
  </PropertyGroup>
  <!-- Regardless of platform, enable dependency file generation if PreserveCompilationContext is set. -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateDependencyFile Condition="'$(GenerateDependencyFile)' == ''">$(PreserveCompilationContext)</GenerateDependencyFile>
  </PropertyGroup>
  <!-- Set PublishDir here, before Microsoft.Common.targets, to avoid a competing default there.
       If using artifacts output path format, PublishDir is already set in Microsoft.NET.DefaultOutputPaths.targets -->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PublishDirName Condition="'$(PublishDirName)' == ''">publish</PublishDirName>
    <!-- ensure the PublishDir is RID specific-->
    <PublishDir Condition="'$(PublishDir)' == '' and&#xA;                           '$(AppendRuntimeIdentifierToOutputPath)' != 'true' and&#xA;                           '$(RuntimeIdentifier)' != '' and&#xA;                           '$(_UsingDefaultRuntimeIdentifier)' != 'true'">$(OutputPath)$(RuntimeIdentifier)\$(PublishDirName)\</PublishDir>
    <PublishDir Condition="'$(PublishDir)' == ''">$(OutputPath)$(PublishDirName)\</PublishDir>
  </PropertyGroup>
  <!--
    Sets RestoreAdditionalProjectSources or RestoreAdditionalProjectFallbackFolders to the SDK Offline Cache based
    on the TargetFramework.
  -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.NuGetOfflineCache.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.NuGetOfflineCache.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.NuGetOfflineCache.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_NugetFallbackFolder>$(MSBuildThisFileDirectory)..\..\..\..\NuGetFallbackFolder</_NugetFallbackFolder>
    <_IsNETCore1x Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &lt; '2.0' ">true</_IsNETCore1x>
    <_WorkloadLibraryPacksFolder Condition="'$(_WorkloadLibraryPacksFolder)' == ''">$([MSBuild]::EnsureTrailingSlash('$(NetCoreRoot)'))library-packs</_WorkloadLibraryPacksFolder>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(DisableImplicitNuGetFallbackFolder)' != 'true' and Exists($(_NugetFallbackFolder)) " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RestoreAdditionalProjectSources Condition=" '$(_IsNETCore1x)' == 'true' and '$(DisableImplicit1xNuGetFallbackFolder)' != 'true' ">$(RestoreAdditionalProjectSources);$(_NugetFallbackFolder)</RestoreAdditionalProjectSources>
    <RestoreAdditionalProjectFallbackFoldersExcludes Condition=" '$(_IsNETCore1x)' == 'true' ">$(RestoreAdditionalProjectFallbackFoldersExcludes);$(_NugetFallbackFolder)</RestoreAdditionalProjectFallbackFoldersExcludes>
    <RestoreAdditionalProjectFallbackFolders Condition=" '$(_IsNETCore1x)' != 'true' ">$(RestoreAdditionalProjectFallbackFolders);$(_NugetFallbackFolder)</RestoreAdditionalProjectFallbackFolders>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(DisableImplicitLibraryPacksFolder)' != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RestoreAdditionalProjectSources Condition="Exists('$(_WorkloadLibraryPacksFolder)')">$(RestoreAdditionalProjectSources);$(_WorkloadLibraryPacksFolder)</RestoreAdditionalProjectSources>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <ItemGroup Condition=" '$(DisableImplicitFrameworkReferences)' != 'true' and '$(TargetFrameworkIdentifier)' == '.NETFramework'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_SDKImplicitReference Include="System" />
    <_SDKImplicitReference Include="System.Data" />
    <_SDKImplicitReference Include="System.Drawing" />
    <_SDKImplicitReference Include="System.Xml" />
    <!-- When doing greater than/less than comparisons between strings, MSBuild will try to parse the strings as Version objects and compare them as
         such if the parse succeeds. -->
    <!-- Framework assemblies introduced in .NET 3.5 -->
    <_SDKImplicitReference Include="System.Core" Condition=" '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.5' " />
    <_SDKImplicitReference Include="System.Runtime.Serialization" Condition=" '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.5' " />
    <_SDKImplicitReference Include="System.Xml.Linq" Condition=" '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.5' " />
    <!-- Framework assemblies introduced in .NET 4.0 -->
    <_SDKImplicitReference Include="System.Numerics" Condition=" '$(_TargetFrameworkVersionWithoutV)' &gt;= '4.0' " />
    <!-- Framework assemblies introduced in .NET 4.5 -->
    <_SDKImplicitReference Include="System.IO.Compression.FileSystem" Condition=" '$(_TargetFrameworkVersionWithoutV)' &gt;= '4.5' " />
    <_SDKImplicitReference Update="@(_SDKImplicitReference)" Pack="false" IsImplicitlyDefined="true" />
    <!-- Don't duplicate any references that are explicit in the project file.  This means that if you do want to include a framework assembly in your
         NuGet package, you can just add the Reference to your project file. -->
    <_SDKImplicitReference Remove="@(Reference)" />
    <!-- Add the implicit references to @(Reference) -->
    <Reference Include="@(_SDKImplicitReference)" />
  </ItemGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Prevent System.Core reference from being added separately (see Microsoft.NETFramework.CurrentVersion.props) -->
    <AddAdditionalExplicitAssemblyReferences>false</AddAdditionalExplicitAssemblyReferences>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DisableImplicitAssetTargetFallback)' != 'true' and '$(_IsNETCoreOrNETStandard)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '2.0'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AssetTargetFallback>$(AssetTargetFallback);net461;net462;net47;net471;net472;net48;net481</AssetTargetFallback>
  </PropertyGroup>
  <!-- Add conditional compilation symbols for the target framework (for example NET461, NETSTANDARD2_0, NETCOREAPP1_0) -->
  <PropertyGroup Condition=" '$(DisableImplicitFrameworkDefines)' != 'true' and '$(TargetFrameworkIdentifier)' != '.NETPortable' and '$(TargetFrameworkIdentifier)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_FrameworkIdentifierForImplicitDefine>$(TargetFrameworkIdentifier.Replace('.', '').ToUpperInvariant())</_FrameworkIdentifierForImplicitDefine>
    <_FrameworkIdentifierForImplicitDefine Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) ">NET</_FrameworkIdentifierForImplicitDefine>
    <VersionlessImplicitFrameworkDefine>$(_FrameworkIdentifierForImplicitDefine)</VersionlessImplicitFrameworkDefine>
    <_FrameworkIdentifierForImplicitDefine Condition=" '$(TargetFrameworkIdentifier)' == '.NETFramework'">NET</_FrameworkIdentifierForImplicitDefine>
    <_FrameworkVersionForImplicitDefine>$(TargetFrameworkVersion.TrimStart('vV'))</_FrameworkVersionForImplicitDefine>
    <_FrameworkVersionForImplicitDefine>$(_FrameworkVersionForImplicitDefine.Replace('.', '_'))</_FrameworkVersionForImplicitDefine>
    <_FrameworkVersionForImplicitDefine Condition=" '$(TargetFrameworkIdentifier)' == '.NETFramework'">$(_FrameworkVersionForImplicitDefine.Replace('_', ''))</_FrameworkVersionForImplicitDefine>
    <ImplicitFrameworkDefine>$(_FrameworkIdentifierForImplicitDefine)$(_FrameworkVersionForImplicitDefine)</ImplicitFrameworkDefine>
    <BackwardsCompatFrameworkDefine Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0))">$(TargetFrameworkIdentifier.Replace('.', '').ToUpperInvariant())</BackwardsCompatFrameworkDefine>
  </PropertyGroup>
  <!-- Add conditional compilation symbols for the target platform (for example ANDROID, IOS, WINDOWS) -->
  <Target Name="GenerateTargetPlatformDefineConstants" Condition=" '$(DisableImplicitFrameworkDefines)' != 'true' and '$(TargetPlatformIdentifier)' != '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_PlatformIdentifierForImplicitDefine>$(TargetPlatformIdentifier.ToUpperInvariant())</_PlatformIdentifierForImplicitDefine>
      <_PlatformVersionForImplicitDefine>$(TargetPlatformVersion.Replace('.', '_'))</_PlatformVersionForImplicitDefine>
    </PropertyGroup>
    <ItemGroup>
      <_ImplicitDefineConstant Include="$(_PlatformIdentifierForImplicitDefine)" />
      <_ImplicitDefineConstant Include="$(_PlatformIdentifierForImplicitDefine)$(_PlatformVersionForImplicitDefine)" />
    </ItemGroup>
  </Target>
  <!-- Add OR_GREATER compilation symbols for target frameworks with .NET Framework, .NET Standard, .NET Core, and .NET -->
  <Target Name="GenerateNETCompatibleDefineConstants" Condition=" '$(DisableImplicitFrameworkDefines)' != 'true' and ('$(TargetFrameworkIdentifier)' == '.NETCoreApp' or '$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == '.NETStandard')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_SupportedFrameworkVersions Include="@(SupportedNETCoreAppTargetFramework-&gt;'%(Identity)'-&gt;TrimStart('.NETCoreApp,Version=v'))" Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' " />
      <_SupportedFrameworkVersions Include="@(SupportedNETFrameworkTargetFramework-&gt;'%(Identity)'-&gt;TrimStart('.NETFramework,Version=v'))" Condition=" '$(TargetFrameworkIdentifier)' == '.NETFramework' " />
      <_SupportedFrameworkVersions Include="@(SupportedNETStandardTargetFramework-&gt;'%(Identity)'-&gt;TrimStart('.NETStandard,Version=v'))" Condition=" '$(TargetFrameworkIdentifier)' == '.NETStandard' " />
      <_CompatibleFrameworkVersions Include="@(_SupportedFrameworkVersions)" Condition=" $([MSBuild]::VersionLessThanOrEquals(%(Identity), $(TargetFrameworkVersion))) " />
      <_FormattedCompatibleFrameworkVersions Include="@(_CompatibleFrameworkVersions)" Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' or '$(TargetFrameworkIdentifier)' == '.NETStandard' " />
      <_FormattedCompatibleFrameworkVersions Include="@(_CompatibleFrameworkVersions-&gt;'%(Identity)'-&gt;Replace('.', ''))" Condition=" '$(TargetFrameworkIdentifier)' == '.NETFramework' " />
      <_ImplicitDefineConstant Include="@(_FormattedCompatibleFrameworkVersions-&gt;'$(_FrameworkIdentifierForImplicitDefine)%(Identity)_OR_GREATER'-&gt;Replace('.', '_'))" Condition=" '$(TargetFrameworkIdentifier)' != '.NETCoreApp' or $([MSBuild]::VersionGreaterThanOrEquals(%(_FormattedCompatibleFrameworkVersions.Identity), 5.0)) " />
      <_ImplicitDefineConstant Include="@(_FormattedCompatibleFrameworkVersions-&gt;'NETCOREAPP%(Identity)_OR_GREATER'-&gt;Replace('.', '_'))" Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionLessThan(%(_FormattedCompatibleFrameworkVersions.Identity), 5.0)) " />
    </ItemGroup>
  </Target>
  <!-- Add OR_GREATER compilation symbols for target platforms. -->
  <Target Name="GeneratePlatformCompatibleDefineConstants" Condition=" '$(DisableImplicitFrameworkDefines)' != 'true' and '$(TargetPlatformIdentifier)' != '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_SupportedPlatformCompatibleVersions Include="@(SdkSupportedTargetPlatformVersion)" Condition=" %(Identity) != '' and $([MSBuild]::VersionLessThanOrEquals(%(Identity), $(TargetPlatformVersion))) " />
      <_ImplicitDefineConstant Include="@(_SupportedPlatformCompatibleVersions-&gt;Distinct()-&gt;'$(TargetPlatformIdentifier.ToUpper())%(Identity)_OR_GREATER'-&gt;Replace('.', '_'))" />
    </ItemGroup>
  </Target>
  <!-- Remove TRACE when DisableDiagnosticTracing is true -->
  <Target Name="_DisableDiagnosticTracing" Condition="'$(DisableDiagnosticTracing)' == 'true'" DependsOnTargets="GenerateTargetPlatformDefineConstants;GenerateNETCompatibleDefineConstants;GeneratePlatformCompatibleDefineConstants" BeforeTargets="CoreCompile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_DefineConstantsWithoutTrace Include="$(DefineConstants)" />
      <_DefineConstantsWithoutTrace Remove="TRACE" />
    </ItemGroup>
    <PropertyGroup>
      <DefineConstants>@(_DefineConstantsWithoutTrace)</DefineConstants>
    </PropertyGroup>
  </Target>
  <!--
    Add implicitly defined preprocessor symbols to DefineConstants. Note: this is intentionally using 'PrepareForBuild' as
    trigger to ensure that it runs before the XamlPreCompile targets. This targets creates the intermediate XAML project
    that is used by some XAML-based UI frameworks (eg. UWP XAML, WinUI 3). If it runs before AddImplicitDefineConstants,
    and the code has any '#ifdefs' on constants generated by this target (eg. 'NET9_0_OR_GREATER'), the intermediate XAML
    project will end up selecting the other code paths instead, which can cause all kinds of build failures or other
    problems. For additional context, see: https://github.com/dotnet/sdk/issues/43908.
  -->
  <Target Name="AddImplicitDefineConstants" Condition=" '$(DisableImplicitFrameworkDefines)' != 'true' " DependsOnTargets="GenerateTargetPlatformDefineConstants;GenerateNETCompatibleDefineConstants;GeneratePlatformCompatibleDefineConstants;_DisableDiagnosticTracing" AfterTargets="PrepareForBuild" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <DefineConstants Condition=" '@(_ImplicitDefineConstant)' != '' ">$(DefineConstants);@(_ImplicitDefineConstant)</DefineConstants>
      <FinalDefineConstants Condition=" '@(_ImplicitDefineConstant)' != '' and '$(Language)' == 'VB' ">$(FinalDefineConstants),@(_ImplicitDefineConstant->'%(Identity)=-1', ',')</FinalDefineConstants>
    </PropertyGroup>
  </Target>
  <!-- Handle XML documentation file settings -->
  <PropertyGroup Condition="'$(GenerateDocumentationFile)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateDocumentationFile Condition="'$(DocumentationFile)' == ''">false</GenerateDocumentationFile>
    <GenerateDocumentationFile Condition="'$(DocumentationFile)' != ''">true</GenerateDocumentationFile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(GenerateDocumentationFile)' == 'true' and '$(DocumentationFile)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DocumentationFile Condition="'$(MSBuildProjectExtension)' == '.vbproj'">$(AssemblyName).xml</DocumentationFile>
    <DocumentationFile Condition="'$(MSBuildProjectExtension)' != '.vbproj'">$(IntermediateOutputPath)$(AssemblyName).xml</DocumentationFile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(GenerateDocumentationFile)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DocumentationFile />
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PublishDocumentationFiles Condition="'$(PublishDocumentationFiles)' == ''">true</PublishDocumentationFiles>
    <PublishDocumentationFile Condition="'$(PublishDocumentationFile)' == '' and '$(PublishDocumentationFiles)' == 'true'">true</PublishDocumentationFile>
    <PublishReferencesDocumentationFiles Condition="'$(PublishReferencesDocumentationFiles)' == '' and '$(PublishDocumentationFiles)' == 'true'">true</PublishReferencesDocumentationFiles>
  </PropertyGroup>
  <!-- Add a project capability so that the project properties in the IDE can show the option to generate an XML documentation file without specifying the filename -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Include="GenerateDocumentationFile" />
  </ItemGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <IsNetCoreAppTargetingLatestTFM Condition="'$(IsNetCoreAppTargetingLatestTFM)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' == '$(NETCoreAppMaximumVersion)'">true</IsNetCoreAppTargetingLatestTFM>
  </PropertyGroup>
  <!--
    Use Roslyn deployed with SDK for builds of SDK-style projects (regardless of whether the initiator is `dotnet` or `msbuild`).
    See https://github.com/dotnet/sdk/blob/main/documentation/general/decouple-vs-and-net-sdk.md.
  -->
  <Choose xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- RoslynCompilerType specified by user, do not overwrite it. -->
    <When Condition="'$(RoslynCompilerType)' != ''" />
    <!-- BuildWithNetFrameworkHostedCompiler specified by user to opt into downloading compiler framework toolset package. -->
    <When Condition="'$(BuildWithNetFrameworkHostedCompiler)' == 'true'">
      <PropertyGroup>
        <RoslynCompilerType>FrameworkPackage</RoslynCompilerType>
      </PropertyGroup>
    </When>
    <!-- On core MSBuild or if we have path to dotnet host, use Core compiler type. -->
    <When Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(DOTNET_HOST_PATH)' != '' or '$(DOTNET_EXPERIMENTAL_HOST_PATH)' != ''">
      <PropertyGroup>
        <RoslynCompilerType>Core</RoslynCompilerType>
      </PropertyGroup>
    </When>
    <!-- Automatically opt users into using the toolset package if they are running an MSBuild other than what this SDK was built against.
          This is to reduce 'tearing'/dependency mismatch, but as always users can override this behavior by disabling the hosted compiler flag. -->
    <When Condition="'$(MSBuildRuntimeType)' == 'Full'&#xA;      and '$(BuildWithNetFrameworkHostedCompiler)' == ''&#xA;      and '$(_IsDisjointMSBuildVersion)' == 'true'&#xA;      and ('$(MSBuildProjectExtension)' == '.csproj'&#xA;      or '$(MSBuildProjectExtension)' == '.vbproj')">
      <PropertyGroup>
        <RoslynCompilerType>FrameworkPackage</RoslynCompilerType>
      </PropertyGroup>
    </When>
    <!-- Otherwise we must be on full MSBuild, so choose Framework compiler type. -->
    <Otherwise>
      <PropertyGroup>
        <RoslynCompilerType>Framework</RoslynCompilerType>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <PropertyGroup Condition="'$(RoslynCompilerType)' == 'Core'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RoslynTargetsPath Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\..\..\Roslyn</RoslynTargetsPath>
    <RoslynTasksAssembly Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\..\..\Roslyn\Microsoft.Build.Tasks.CodeAnalysis.dll</RoslynTasksAssembly>
    <RoslynTargetsPath Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\..\..\Roslyn\binfx</RoslynTargetsPath>
    <RoslynTasksAssembly Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\..\..\Roslyn\binfx\Microsoft.Build.Tasks.CodeAnalysis.Sdk.dll</RoslynTasksAssembly>
    <CSharpCoreTargetsPath>$(MSBuildThisFileDirectory)..\..\..\Roslyn\Microsoft.CSharp.Core.targets</CSharpCoreTargetsPath>
    <VisualBasicCoreTargetsPath>$(MSBuildThisFileDirectory)..\..\..\Roslyn\Microsoft.VisualBasic.Core.targets</VisualBasicCoreTargetsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(LanguageTargets)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <LanguageTargets Condition="'$(MSBuildProjectExtension)' == '.csproj'">$(MSBuildToolsPath)\Microsoft.CSharp.targets</LanguageTargets>
    <LanguageTargets Condition="'$(MSBuildProjectExtension)' == '.vbproj'">$(MSBuildToolsPath)\Microsoft.VisualBasic.targets</LanguageTargets>
    <LanguageTargets Condition="'$(MSBuildProjectExtension)' == '.fsproj'">$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.FSharpTargetsShim.targets</LanguageTargets>
    <!-- If LanguageTargets isn't otherwise set, then just import the common targets.  This should allow the restore target to run,
         which could bring in NuGet packages that set the LanguageTargets to something else.  This means support for different
         languages could either be supplied via an SDK or via a NuGet package. -->
    <LanguageTargets Condition="'$(LanguageTargets)' == ''">$(MSBuildToolsPath)\Microsoft.Common.targets</LanguageTargets>
  </PropertyGroup>
  <!-- REMARK: Dont remove/rename, the LanguageTargets property is used by F# to hook inside the project's sdk
               using Sdk attribute (from .NET Core Sdk 1.0.0-preview4) -->
  <!--
============================================================================================================================================
  <Import Project="$(LanguageTargets)">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.FSharpTargetsShim.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.FSharpTargetsShim.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Microsoft.Managed.Before.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines common build logic for all managed languaged: C#, VisualBasic, F#
It is imported before the common targets have been imported.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
      We are doing a cross-targeting build if there is a non-empty list of target frameworks specified
      and there is no current target framework being built individually. In that case, a multitargeting
      project file like Microsoft.<language>.CrossTargeting.targets gets imported.
  -->
  <PropertyGroup Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''">
    <IsCrossTargetingBuild>true</IsCrossTargetingBuild>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.FSharpTargetsShim.targets
============================================================================================================================================
-->
  <PropertyGroup Condition=" '$(UseBundledFSharpTargets)' == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AppDesignerFolder Condition="'$(AppDesignerFolder)' == ''">Properties</AppDesignerFolder>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(DisableImplicitConfigurationDefines)' != 'true' and '$(UseBundledFSharpTargets)' == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ImplicitConfigurationDefine>$(Configuration.ToUpperInvariant())</ImplicitConfigurationDefine>
    <!-- Replace dashes and periods in the configuration with underscores.  This makes it more likely that
         the resulting compilation constant will be a valid C# conditional compilation symbol.  As the set
         of characters that aren't allowed is essentially open-ended, there's probably not a good way to
         fully sanitize the Configuration in MSBuild evaluation.  If the resulting string still isn't a
         valid conditional combilation symbol, then the compiler will generate the following error and
         the define will be ignored:
            warning MSB3052: The parameter to the compiler is invalid, '/define:0BAD_DEFINE' will be ignored.
         -->
    <ImplicitConfigurationDefine>$(ImplicitConfigurationDefine.Replace('-', '_'))</ImplicitConfigurationDefine>
    <ImplicitConfigurationDefine>$(ImplicitConfigurationDefine.Replace('.', '_'))</ImplicitConfigurationDefine>
    <DefineConstants>$(DefineConstants);$(ImplicitConfigurationDefine)</DefineConstants>
  </PropertyGroup>
  <!-- ***************************************************************************************************************
       Loads the cross-targeting targets if we are doing a cross-targeting build
       Import design time targets for Roslyn Project System. These are only available if Visual Studio is installed.
       Import design time targets before the common crosstargeting targets, which import targets from Nuget.
       *************************************************************************************************************** -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <FSharpDesignTimeTargetsPath Condition="'$(FSharpDesignTimeTargetsPath)' == ''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed\Microsoft.FSharp.DesignTime.targets</FSharpDesignTimeTargetsPath>
  </PropertyGroup>
  <!--<Import Project="$(FSharpDesignTimeTargetsPath)" Condition=" '$(UseBundledFSharpTargets)' == 'true' and '$(FSharpDesignTimeTargetsPath)' != '' and Exists('$(FSharpDesignTimeTargetsPath)') " />-->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.Common.CrossTargeting.targets" Condition=" '$(UseBundledFSharpTargets)' == 'true' and '$(IsCrossTargetingBuild)' == 'true' " />-->
  <!-- ***************************************************************************************************************
       Shim to select the correct Microsoft.NET.Sdk.FSharp.targets file when not running
       under Cross-targeting build and not under FSharp.Sdk
       If running under desktop select Microsoft.FSharp.targets file from VS deployment,
       if running core msbuild select Microsoft.FSharp.targets from dotnet cli deployment
       *************************************************************************************************************** -->
  <PropertyGroup Condition=" '$(IsCrossTargetingBuild)' != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <FSharpTargetsShim Condition=" '$(FSharpTargetsShim)' == '' and Exists('$(MSBuildToolsPath)\FSharp\Microsoft.FSharp.NetSdk.targets') ">$(MSBuildToolsPath)\FSharp\Microsoft.FSharp.NetSdk.targets</FSharpTargetsShim>
    <FSharpTargetsShim Condition=" '$(FSharpTargetsShim)' == '' and Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\FSharp\Microsoft.FSharp.NetSdk.targets') ">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\FSharp\Microsoft.FSharp.NetSdk.targets</FSharpTargetsShim>
  </PropertyGroup>
  <!--<Import Project="$(FSharpTargetsShim)" Condition=" '$(UseBundledFSharpTargets)' == 'true' and  '$(IsCrossTargetingBuild)' != 'true' and Exists('$(FSharpTargetsShim)') " />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.After.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Microsoft.Managed.After.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines common build logic for all managed languaged: C#, VisualBasic, F#
It is imported after the common targets have been imported.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Define crosstargeting for static graph, so it can identify inner and outer build graph nodes -->
  <PropertyGroup>
    <InnerBuildProperty>TargetFramework</InnerBuildProperty>
    <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
    <AddTransitiveProjectReferencesInStaticGraph Condition="'$(AddTransitiveProjectReferencesInStaticGraph)' == '' and '$(UsingMicrosoftNETSdk)' == 'true' and '$(DisableTransitiveProjectReferences)' != 'true'">true</AddTransitiveProjectReferencesInStaticGraph>
  </PropertyGroup>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
    <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.
        Detect WPF, and exclude the generated project from static graph isolation constraint checking.
        Escape the item to avoid eager evaluation of the wildcards.
    -->
    <GraphIsolationExemptReference Condition="'$(UseWPF)' == 'true' or '@(Page)' != '' or '@(ApplicationDefinition)' != '' or '@(XamlPage)' != '' or '@(XamlAppDef)' != ''" Include="$([MSBuild]::Escape('$(MSBuildProjectDirectory)\$(MSBuildProjectName)*_wpftmp$(MSBuildProjectExtension)'))" />
  </ItemGroup>
  <!--
      Properties for extension of ProjectReferenceTargets.
      Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.
  -->
  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' != 'true'">
    <!-- Empty case is for builds which do not import the target files that set BuildProjectReferences -->
    <_MainReferenceTargetForBuild Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>
    <_MainReferenceTargetForBuild Condition="'$(_MainReferenceTargetForBuild)' == ''">GetTargetPath</_MainReferenceTargetForBuild>
    <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
    <!-- Publish has the same logic as Build for the main reference target except it also takes $(NoBuild) into account. -->
    <_MainReferenceTargetForPublish Condition="'$(NoBuild)' == 'true'">GetTargetPath</_MainReferenceTargetForPublish>
    <_MainReferenceTargetForPublish Condition="'$(NoBuild)' != 'true'">$(_MainReferenceTargetForBuild)</_MainReferenceTargetForPublish>
    <ProjectReferenceTargetsForPublish>GetTargetFrameworks;$(_MainReferenceTargetForPublish);GetNativeManifest;GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForPublish>
    <!-- When DeployOnBuild=true, the Publish target is hooked to the Build target -->
    <ProjectReferenceTargetsForBuild Condition="'$(DeployOnBuild)' == 'true'">$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForBuild>
    <ProjectReferenceTargetsForRebuild Condition="'$(DeployOnBuild)' == 'true'">$(ProjectReferenceTargetsForRebuild);$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForRebuild>
    <ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)</ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' == 'true'">
    <ProjectReferenceTargetsForBuild>.default;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
    <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
  </PropertyGroup>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
    <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true" />
    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
    <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true" />
    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForClean)" Condition=" '$(ProjectReferenceTargetsForClean)' != '' " />
    <!--
     Note: SkipNonexistentTargets="true" on the following three items means that an outer build node's call to its existent GetTargetFrameworks target will fail if its inner build nodes don't define GetTargetFrameworksWithPlatformForSingleTargetFrameworks.
     This is necessary since the P2P protocol cannot express the targets called from the outer build to the inner build.
     -->
    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Rebuild" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuild)" Condition=" '$(ProjectReferenceTargetsForRebuild)' != '' " />
    <ProjectReferenceTargets Include="Publish" Targets="$(ProjectReferenceTargetsForPublish)" Condition=" '$(ProjectReferenceTargetsForPublish)' != '' " />
    <ProjectReferenceTargets Include="GetCopyToPublishDirectoryItems" Targets="$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)" Condition=" '$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)' != '' " />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.FSharpTargetsShim.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.CrossTargeting.targets" Condition="'$(IsCrossTargetingBuild)' == 'true'" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.targets" Condition="'$(IsCrossTargetingBuild)' != 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.targets
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.
Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.Common.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- This file is imported by both cross-targeting and inner builds. Set properties that need to be available to both here. -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MicrosoftNETBuildTasksDirectoryRoot>$(MSBuildThisFileDirectory)..\tools\</MicrosoftNETBuildTasksDirectoryRoot>
    <MicrosoftNETBuildTasksTFM Condition=" '$(MSBuildRuntimeType)' == 'Core'">net10.0</MicrosoftNETBuildTasksTFM>
    <MicrosoftNETBuildTasksTFM Condition=" '$(MicrosoftNETBuildTasksTFM)' == ''">net472</MicrosoftNETBuildTasksTFM>
    <MicrosoftNETBuildTasksDirectory>$(MicrosoftNETBuildTasksDirectoryRoot)$(MicrosoftNETBuildTasksTFM)\</MicrosoftNETBuildTasksDirectory>
    <MicrosoftNETBuildTasksAssembly>$(MicrosoftNETBuildTasksDirectory)Microsoft.NET.Build.Tasks.dll</MicrosoftNETBuildTasksAssembly>
    <!--
          Hardcoded list of known implicit packages that are added to project from default SDK targets implicitly.
          Should be re-visited when multiple TFM support is added to Dependencies logic.
    -->
    <DefaultImplicitPackages>Microsoft.NETCore.App;NETStandard.Library</DefaultImplicitPackages>
  </PropertyGroup>
  <!--
     Some versions of Microsoft.NET.Test.Sdk.targets change the OutputType after we've set _IsExecutable and
     HasRuntimeOutput default in Microsoft.NET.Sdk.BeforeCommon.targets. Refresh these value here for backwards
     compatibilty with that.
   -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_IsExecutable Condition="'$(OutputType)' == 'Exe' or '$(OutputType)'=='WinExe'">true</_IsExecutable>
    <HasRuntimeOutput Condition="'$(_UsingDefaultForHasRuntimeOutput)' == 'true'">$(_IsExecutable)</HasRuntimeOutput>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DotnetCliToolTargetFramework)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Maximum supported target framework for DotnetCliProjectTools is .NET Core 2.2 -->
    <DotnetCliToolTargetFramework>netcoreapp2.2</DotnetCliToolTargetFramework>
  </PropertyGroup>
  <PropertyGroup Condition="'$(EnablePreviewFeatures)' == 'true' And '$(IsNetCoreAppTargetingLatestTFM)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <LangVersion>Preview</LangVersion>
  </PropertyGroup>
  <UsingTask TaskName="NETSdkError" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NETSdkWarning" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NETSdkInformation" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="ShowPreviewMessage" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup Condition="'$(RoslynCompilerType)' == 'FrameworkPackage' and '$(OS)' == 'Windows_NT' and '$(MSBuildRuntimeType)' == 'Full'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RoslynTargetsPath>$(NuGetPackageRoot)\microsoft.net.sdk.compilers.toolset\$(NETCoreSdkVersion)</RoslynTargetsPath>
    <RoslynTasksAssembly>$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll</RoslynTasksAssembly>
    <_NeedToDownloadMicrosoftNetSdkCompilersToolsetPackage>true</_NeedToDownloadMicrosoftNetSdkCompilersToolsetPackage>
    <_MicrosoftNetSdkCompilersToolsetPackageRootEmpty Condition="'$(NuGetPackageRoot)' == ''">true</_MicrosoftNetSdkCompilersToolsetPackageRootEmpty>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <EnableDynamicLoading Condition="'$(EnableDynamicLoading)' == '' and '$(EnableComHosting)' == 'true'">true</EnableDynamicLoading>
  </PropertyGroup>
  <!--<ImportGroup>-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.PackageDependencyResolution.targets" Condition="Exists('$(MSBuildThisFileDirectory)Microsoft.PackageDependencyResolution.targets') and ('$(Language)' != 'C++' or '$(_EnablePackageReferencesInVCProjects)' == 'true')">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.PackageDependencyResolution.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.PackageDependencyResolution.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    *************************************
    1. INPUT PROPERTIES
    - That configure the PackageDependency targets
    *************************************
    -->
  <!-- General Properties -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectAssetsFile Condition="'$(ProjectAssetsFile)' == ''">$(MSBuildProjectExtensionsPath)/project.assets.json</ProjectAssetsFile>
    <ProjectAssetsFile>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(ProjectAssetsFile)))</ProjectAssetsFile>
    <!-- Note that the assets.cache file has contents that are unique to the current TFM and configuration and therefore cannot
         be stored in a shared directory next to the assets.json file -->
    <ProjectAssetsCacheFile Condition="'$(ProjectAssetsCacheFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectName).assets.cache</ProjectAssetsCacheFile>
    <ProjectAssetsCacheFile>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(ProjectAssetsCacheFile)))</ProjectAssetsCacheFile>
    <!-- Don't copy local for netstandard projects. -->
    <CopyLocalLockFileAssemblies Condition="'$(CopyLocalLockFileAssemblies)' == '' and&#xA;                                            '$(TargetFrameworkIdentifier)' == '.NETStandard'">false</CopyLocalLockFileAssemblies>
    <!-- Don't copy local for netcoreapp projects before 3.0 or non-exe and non-component projects. -->
    <CopyLocalLockFileAssemblies Condition="'$(CopyLocalLockFileAssemblies)' == '' and&#xA;                                            '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and&#xA;                                            ('$(_TargetFrameworkVersionWithoutV)' &lt; '3.0' or&#xA;                                             ('$(HasRuntimeOutput)' != 'true' and '$(EnableDynamicLoading)' != 'true'))">false</CopyLocalLockFileAssemblies>
    <!-- All other project types should copy local. -->
    <CopyLocalLockFileAssemblies Condition="'$(CopyLocalLockFileAssemblies)' == ''">true</CopyLocalLockFileAssemblies>
    <ContentPreprocessorOutputDirectory Condition="'$(ContentPreprocessorOutputDirectory)' == ''">$(IntermediateOutputPath)NuGet\</ContentPreprocessorOutputDirectory>
    <UseTargetPlatformAsNuGetTargetMoniker Condition="'$(UseTargetPlatformAsNuGetTargetMoniker)' == '' AND '$(TargetFrameworkMoniker)' == '.NETCore,Version=v5.0'">true</UseTargetPlatformAsNuGetTargetMoniker>
    <NuGetTargetMoniker Condition="'$(NuGetTargetMoniker)' == '' AND '$(UseTargetPlatformAsNuGetTargetMoniker)' == 'true'">$(TargetPlatformIdentifier),Version=v$([System.Version]::Parse('$(TargetPlatformMinVersion)').ToString(3))</NuGetTargetMoniker>
    <NuGetTargetMoniker Condition="'$(NuGetTargetMoniker)' == '' AND '$(UseTargetPlatformAsNuGetTargetMoniker)' != 'true'">$(TargetFrameworkMoniker)</NuGetTargetMoniker>
    <EmitAssetsLogMessages Condition="'$(EmitAssetsLogMessages)' == ''">true</EmitAssetsLogMessages>
    <!-- Setting this property to true restores pre-16.7 behaviour of ResolvePackageDependencies to produce
         TargetDefinitions, FileDefinitions and FileDependencies items. -->
    <EmitLegacyAssetsFileItems Condition="'$(EmitLegacyAssetsFileItems)' == ''">false</EmitLegacyAssetsFileItems>
    <!-- A flag that NuGet packages containing multi-targeted analyzers can check to see if the NuGet package needs to do
         its own multi-targeting logic, or if the current SDK targets will pick the assets correctly. -->
    <SupportsRoslynComponentVersioning>true</SupportsRoslynComponentVersioning>
  </PropertyGroup>
  <!-- Target Moniker + RID-->
  <PropertyGroup Condition="'$(_NugetTargetMonikerAndRID)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_NugetTargetMonikerAndRID Condition="'$(RuntimeIdentifier)' == ''">$(NuGetTargetMoniker)</_NugetTargetMonikerAndRID>
    <_NugetTargetMonikerAndRID Condition="'$(RuntimeIdentifier)' != ''">$(NuGetTargetMoniker)/$(RuntimeIdentifier)</_NugetTargetMonikerAndRID>
  </PropertyGroup>
  <!-- Embed all project.assets.json files into the binary log when building with /bl -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <EmbedInBinlog Include="$(ProjectAssetsFile)" Condition="$(EmbedProjectAssetsFile) != false AND Exists('$(ProjectAssetsFile)')" />
  </ItemGroup>
  <!--
    *************************************
    2. EXTERNAL PROPERTIES and ITEMS
    - Override or add to external targets
    *************************************
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ResolveAssemblyReferencesDependsOn>
      $(ResolveAssemblyReferencesDependsOn);
      ResolvePackageDependenciesForBuild;
      _HandlePackageFileConflicts;
    </ResolveAssemblyReferencesDependsOn>
    <PrepareResourcesDependsOn>
      ResolvePackageDependenciesForBuild;
      _HandlePackageFileConflicts;
      $(PrepareResourcesDependsOn)
    </PrepareResourcesDependsOn>
  </PropertyGroup>
  <!-- Common tokens used in preprocessed content files -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PreprocessorValue Include="rootnamespace">
      <Value>$(RootNamespace)</Value>
    </PreprocessorValue>
    <PreprocessorValue Include="assemblyname">
      <Value>$(AssemblyName)</Value>
    </PreprocessorValue>
    <PreprocessorValue Include="fullpath">
      <Value>$(MSBuildProjectDirectory)</Value>
    </PreprocessorValue>
    <PreprocessorValue Include="outputfilename">
      <Value>$(TargetFileName)</Value>
    </PreprocessorValue>
    <PreprocessorValue Include="filename">
      <Value>$(MSBuildProjectFile)</Value>
    </PreprocessorValue>
    <PreprocessorValue Include="@(NuGetPreprocessorValue)" Exclude="@(PreprocessorValue)" />
  </ItemGroup>
  <!--
    This will prevent RAR from spending time locating dependencies and related files for assemblies
    that came from packages. PackageReference should already be promoted to a closure of Reference
    items and we are responsible for adding package relates files to CopyLocal items, not RAR. This
    is only configurable as a compat opt-out in case skipping the slow RAR code breaks something.
  -->
  <PropertyGroup Condition="'$(MarkPackageReferencesAsExternallyResolved)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MarkPackageReferencesAsExternallyResolved>true</MarkPackageReferencesAsExternallyResolved>
  </PropertyGroup>
  <!--
    *************************************
    3. BUILD TARGETS
    - Override the Depends-On properties, or the individual targets
    *************************************
    -->
  <!--
    ============================================================
                     ResolvePackageDependenciesForBuild

    Populate items for build. This is triggered before target
    "AssignProjectConfiguration" to ensure ProjectReference items
    are populated before ResolveProjectReferences is run.
    ============================================================
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ResolvePackageDependenciesForBuildDependsOn>
      ResolveLockFileReferences;
      ResolveLockFileAnalyzers;
      ResolveLockFileCopyLocalFiles;
      ResolveRuntimePackAssets;
      RunProduceContentAssets;
      IncludeTransitiveProjectReferences
    </ResolvePackageDependenciesForBuildDependsOn>
  </PropertyGroup>
  <Target Name="ResolvePackageDependenciesForBuild" Condition=" ('$(DesignTimeBuild)' != 'true' and '$(_CleaningWithoutRebuilding)' != 'true')&#xA;                      Or Exists('$(ProjectAssetsFile)')" BeforeTargets="AssignProjectConfiguration" DependsOnTargets="$(ResolvePackageDependenciesForBuildDependsOn)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    *************************************
    4. Package Dependency TASK and TARGETS
    - Raise the lock file to MSBuild Items and create derived items
    *************************************
    -->
  <!--
    ============================================================
                     RunResolvePackageDependencies

    Generate Definitions and Dependencies based on ResolvePackageDependencies task
    ============================================================
    -->
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.ResolvePackageDependencies" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.CheckForTargetInAssetsFile" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.JoinItems" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.ResolvePackageAssets" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!-- The condition on this target causes it to be skipped during design-time builds if
        the restore operation hasn't run yet.  This is to avoid displaying an error in
        the Visual Studio error list when a project is created before NuGet restore has
        run and created the assets file. -->
  <Target Name="RunResolvePackageDependencies" Condition=" '$(DesignTimeBuild)' != 'true' Or Exists('$(ProjectAssetsFile)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Verify that the assets file has a target for the right framework.  Otherwise, if we restored for the
         wrong framework, we'd end up finding no references to pass to the compiler, and we'd get a ton of
         compile errors. -->
    <CheckForTargetInAssetsFile AssetsFilePath="$(ProjectAssetsFile)" TargetFramework="$(TargetFramework)" RuntimeIdentifier="$(RuntimeIdentifier)" Condition=" '$(DesignTimeBuild)' != 'true'" />
    <!-- Included for backwards compatibility when the EmitLegacyAssetsFileItems property is true. -->
    <ResolvePackageDependencies ProjectPath="$(MSBuildProjectFullPath)" ProjectAssetsFile="$(ProjectAssetsFile)" ProjectLanguage="$(Language)" TargetFramework="$(TargetFramework)" ContinueOnError="ErrorAndContinue" Condition="'$(EmitLegacyAssetsFileItems)' == 'true'">
      <Output TaskParameter="PackageDefinitions" ItemName="PackageDefinitions" />
      <Output TaskParameter="PackageDependencies" ItemName="PackageDependencies" />
      <Output TaskParameter="TargetDefinitions" ItemName="TargetDefinitions" />
      <Output TaskParameter="FileDefinitions" ItemName="FileDefinitions" />
      <Output TaskParameter="FileDependencies" ItemName="FileDependencies" />
    </ResolvePackageDependencies>
  </Target>
  <!-- Reads the version of the compiler APIs that are currently being used in order to pick the correct Roslyn components. -->
  <Target Name="_ResolveCompilerVersion" Condition="'$(CompilerApiVersion)' == '' And&#xA;                     ('$(Language)' == 'C#' Or '$(Language)' == 'VB') And&#xA;                     Exists('$(RoslynTasksAssembly)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GetAssemblyIdentity AssemblyFiles="$(RoslynTasksAssembly)">
      <Output TaskParameter="Assemblies" ItemName="_CodeAnalysisIdentity" />
    </GetAssemblyIdentity>
    <PropertyGroup>
      <_RoslynApiVersion>$([System.Version]::Parse(%(_CodeAnalysisIdentity.Version)).Major).$([System.Version]::Parse(%(_CodeAnalysisIdentity.Version)).Minor)</_RoslynApiVersion>
      <CompilerApiVersion>roslyn$(_RoslynApiVersion)</CompilerApiVersion>
    </PropertyGroup>
  </Target>
  <Target Name="ResolvePackageAssets" Condition="('$(DesignTimeBuild)' != 'true' Or Exists('$(ProjectAssetsFile)')) And '$(SkipResolvePackageAssets)' != 'true'" DependsOnTargets="ProcessFrameworkReferences;_DefaultMicrosoftNETPlatformLibrary;_ComputePackageReferencePublish;_ResolveCompilerVersion" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;                          and '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0'&#xA;                          and '$(UseAppHostFromAssetsFile)' == ''">
      <!-- For .NET Core 3.0 and higher, we'll get the apphost from an apphost pack (via ProcessFrameworkReferences) -->
      <UseAppHostFromAssetsFile>false</UseAppHostFromAssetsFile>
    </PropertyGroup>
    <PropertyGroup Condition="'$(UseAppHostFromAssetsFile)' == ''">
      <UseAppHostFromAssetsFile>true</UseAppHostFromAssetsFile>
    </PropertyGroup>
    <PropertyGroup Condition="'$(EnsureRuntimePackageDependencies)' == ''&#xA;                          and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;                          and '$(_TargetFrameworkVersionWithoutV)' &lt; '3.0'&#xA;                          and '$(EnsureNETCoreAppRuntime)' != 'false'">
      <EnsureRuntimePackageDependencies>true</EnsureRuntimePackageDependencies>
    </PropertyGroup>
    <!-- Only copy local runtime target assets if targeting netcoreapp -->
    <PropertyGroup Condition="'$(CopyLocalRuntimeTargetAssets)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'">
      <CopyLocalRuntimeTargetAssets>true</CopyLocalRuntimeTargetAssets>
    </PropertyGroup>
    <ItemGroup>
      <_PackAsToolShimRuntimeIdentifiers Condition="@(_PackAsToolShimRuntimeIdentifiers) ==''" Include="$(PackAsToolShimRuntimeIdentifiers)" />
      <!-- Pass these packages into the ResolvePackageAssets task to verify that the restored versions of the packages
           match the expected version -->
      <ExpectedPlatformPackages Include="@(PackageReference)" Condition="'%(Identity)' == 'Microsoft.NETCore.App'" />
      <ExpectedPlatformPackages Include="@(PackageReference)" Condition="'%(Identity)' == 'Microsoft.AspNetCore.App'" />
      <ExpectedPlatformPackages Include="@(PackageReference)" Condition="'%(Identity)' == 'Microsoft.AspNetCore.All'" />
    </ItemGroup>
    <ResolvePackageAssets ProjectAssetsFile="$(ProjectAssetsFile)" ProjectAssetsCacheFile="$(ProjectAssetsCacheFile)" ProjectPath="$(MSBuildProjectFullPath)" ProjectLanguage="$(Language)" CompilerApiVersion="$(CompilerApiVersion)" EmitAssetsLogMessages="$(EmitAssetsLogMessages)" TargetFramework="$(TargetFramework)" RuntimeIdentifier="$(RuntimeIdentifier)" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeFrameworks="@(RuntimeFramework)" IsSelfContained="$(SelfContained)" MarkPackageReferencesAsExternallyResolved="$(MarkPackageReferencesAsExternallyResolved)" DisablePackageAssetsCache="$(DisablePackageAssetsCache)" DisableFrameworkAssemblies="$(DisableLockFileFrameworks)" CopyLocalRuntimeTargetAssets="$(CopyLocalRuntimeTargetAssets)" DisableTransitiveProjectReferences="$(DisableTransitiveProjectReferences)" DisableTransitiveFrameworkReferences="$(DisableTransitiveFrameworkReferences)" DotNetAppHostExecutableNameWithoutExtension="$(_DotNetAppHostExecutableNameWithoutExtension)" ShimRuntimeIdentifiers="@(_PackAsToolShimRuntimeIdentifiers)" EnsureRuntimePackageDependencies="$(EnsureRuntimePackageDependencies)" VerifyMatchingImplicitPackageVersion="$(VerifyMatchingImplicitPackageVersion)" ExpectedPlatformPackages="@(ExpectedPlatformPackages)" SatelliteResourceLanguages="$(SatelliteResourceLanguages)" DesignTimeBuild="$(DesignTimeBuild)" ContinueOnError="$(ContinueOnError)" PackageReferences="@(PackageReference)" DefaultImplicitPackages="$(DefaultImplicitPackages)">
      <!-- NOTE: items names here are inconsistent because they match prior implementation
          (that was spread across different tasks/targets) for backwards compatibility.  -->
      <Output TaskParameter="Analyzers" ItemName="ResolvedAnalyzers" />
      <Output TaskParameter="ApphostsForShimRuntimeIdentifiers" ItemName="_ApphostsForShimRuntimeIdentifiersResolvePackageAssets" />
      <Output TaskParameter="ContentFilesToPreprocess" ItemName="_ContentFilesToPreprocess" />
      <Output TaskParameter="DebugSymbolsFiles" ItemName="_DebugSymbolsFiles" />
      <Output TaskParameter="ReferenceDocumentationFiles" ItemName="_ReferenceDocumentationFiles" />
      <Output TaskParameter="FrameworkAssemblies" ItemName="ResolvedFrameworkAssemblies" />
      <Output TaskParameter="FrameworkReferences" ItemName="TransitiveFrameworkReference" />
      <Output TaskParameter="NativeLibraries" ItemName="NativeCopyLocalItems" />
      <Output TaskParameter="ResourceAssemblies" ItemName="ResourceCopyLocalItems" />
      <Output TaskParameter="RuntimeAssemblies" ItemName="RuntimeCopyLocalItems" />
      <Output TaskParameter="RuntimeTargets" ItemName="RuntimeTargetsCopyLocalItems" />
      <Output TaskParameter="CompileTimeAssemblies" ItemName="ResolvedCompileFileDefinitions" />
      <Output TaskParameter="TransitiveProjectReferences" ItemName="_TransitiveProjectReferences" />
      <Output TaskParameter="PackageFolders" ItemName="AssetsFilePackageFolder" />
      <Output TaskParameter="PackageDependencies" ItemName="PackageDependencies" />
      <Output TaskParameter="PackageDependenciesDesignTime" ItemName="_PackageDependenciesDesignTime" />
    </ResolvePackageAssets>
    <ItemGroup Condition="'$(CopyDebugSymbolFilesFromPackages)' == 'true'">
      <ReferenceCopyLocalPaths Include="@(_DebugSymbolsFiles)" />
    </ItemGroup>
    <ItemGroup Condition="'$(CopyDocumentationFilesFromPackages)' == 'true'">
      <ReferenceCopyLocalPaths Include="@(_ReferenceDocumentationFiles)" />
    </ItemGroup>
    <ItemGroup Condition="'$(UseAppHostFromAssetsFile)' == 'true'">
      <_NativeRestoredAppHostNETCore Include="@(NativeCopyLocalItems)" Condition="'%(NativeCopyLocalItems.FileName)%(NativeCopyLocalItems.Extension)' == '$(_DotNetAppHostExecutableName)'" />
    </ItemGroup>
    <ItemGroup Condition="'@(_ApphostsForShimRuntimeIdentifiers)' == ''">
      <_ApphostsForShimRuntimeIdentifiers Include="@(_ApphostsForShimRuntimeIdentifiersResolvePackageAssets)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                     ResolvePackageDependenciesDesignTime

    Aggregate the dependencies produced by ResolvePackageDependencies to a form
    that's consumable by an IDE to display package dependencies.
    ============================================================
    -->
  <Target Name="ResolvePackageDependenciesDesignTime" Returns="@(_PackageDependenciesDesignTime)" DependsOnTargets="ResolvePackageAssets;RunResolvePackageDependencies;ResolveAssemblyReferencesDesignTime" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                     CollectSDKReferencesDesignTime

    Aggregates the sdk specified as project items and implicit
    packages references.
    ============================================================
    -->
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.CollectSDKReferencesDesignTime" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="CollectSDKReferencesDesignTime" Returns="@(_SDKReference)" DependsOnTargets="CollectPackageReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CollectSDKReferencesDesignTime SdkReferences="@(SdkReference)" PackageReferences="@(PackageReference)" DefaultImplicitPackages="$(DefaultImplicitPackages)">
      <Output TaskParameter="SDKReferencesDesignTime" ItemName="_SDKReference" />
    </CollectSDKReferencesDesignTime>
  </Target>
  <!--
    ============================================================
                     CollectResolvedSDKReferencesDesignTime

    Aggregates the sdk specified as project items and implicit
    packages produced by ResolvePackageDependencies.
    ============================================================
    -->
  <Target Name="CollectResolvedSDKReferencesDesignTime" Returns="@(_ResolvedSDKReference)" DependsOnTargets="ResolveSDKReferencesDesignTime;CollectPackageReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CollectSDKReferencesDesignTime SdkReferences="@(ResolvedSdkReference)" PackageReferences="@(PackageReference)" DefaultImplicitPackages="$(DefaultImplicitPackages)">
      <Output TaskParameter="SDKReferencesDesignTime" ItemName="_ResolvedSDKReference" />
    </CollectSDKReferencesDesignTime>
  </Target>
  <!--
    ============================================================
                     RunProduceContentAssets

    Process content assets by handling preprocessing tokens where necessary, and
    produce copy local items, content items grouped by "build action" and file writes
    ============================================================
    -->
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.ProduceContentAssets" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="RunProduceContentAssets" DependsOnTargets="ResolvePackageAssets" Condition="'@(_ContentFilesToPreprocess)' != '' and '$(_CleaningWithoutRebuilding)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProduceContentAssets ContentFileDependencies="@(_ContentFilesToPreprocess)" ContentPreprocessorValues="@(PreprocessorValue)" ContentPreprocessorOutputDirectory="$(ContentPreprocessorOutputDirectory)" ProduceOnlyPreprocessorFiles="true" ProjectLanguage="$(Language)">
      <Output TaskParameter="CopyLocalItems" ItemName="_ContentCopyLocalItems" />
      <Output TaskParameter="ProcessedContentItems" ItemName="_ProcessedContentItems" />
      <Output TaskParameter="ProcessedContentItems" ItemName="FileWrites" />
    </ProduceContentAssets>
    <!-- The items in _ProcessedContentItems need to go into the appropriately-named item group,
         but the names depend upon the items themselves. Split it apart. -->
    <CreateItem Include="@(_ProcessedContentItems)" Condition="'@(_ProcessedContentItems)' != ''">
      <Output TaskParameter="Include" ItemName="%(_ProcessedContentItems.ProcessedItemType)" />
    </CreateItem>
  </Target>
  <!--
    ============================================================
    Reference Targets: For populating References based on lock file
    - ResolveLockFileReferences
    ============================================================
    -->
  <Target Name="ResolveLockFileReferences" DependsOnTargets="ResolvePackageAssets" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(MarkPackageReferencesAsExternallyResolved)' == 'true'">
      <!--
        Update Reference items with NuGetPackageId metadata to set ExternallyResolved appropriately.
        NetStandard.Library adds its assets in targets this way and not in the standard way that
        would get ExternallyResolved set in ResolvePackageAssets.
       -->
      <Reference Condition="'%(Reference.NuGetPackageId)' != ''">
        <ExternallyResolved>true</ExternallyResolved>
      </Reference>
      <!-- Add framework references from NuGet packages here, so that if there is also a matching reference from a NuGet package,
           it will be treated the same as a reference from the project file.  If there is already an explicit Reference from the
           project, use that, in order to preserve metadata (such as aliases). -->
      <Reference Include="@(ResolvedFrameworkAssemblies)" Exclude="@(Reference)" />
    </ItemGroup>
    <!-- If there are any references from a NuGet package that match a simple reference which
         would resolve to a framework assembly, then update the NuGet references to use the
         simple name as the ItemSpec.  This will prevent the VS project system from marking
         a reference with a warning.  See https://github.com/dotnet/sdk/issues/1499 -->
    <JoinItems Left="@(ResolvedCompileFileDefinitions)" LeftKey="FileName" LeftMetadata="*" Right="@(Reference)" RightKey="" RightMetadata="*">
      <Output TaskParameter="JoinResult" ItemName="_JoinedResolvedCompileFileDefinitions" />
    </JoinItems>
    <ItemGroup>
      <Reference Remove="@(_JoinedResolvedCompileFileDefinitions)" />
      <Reference Include="@(_JoinedResolvedCompileFileDefinitions)" />
    </ItemGroup>
    <ItemGroup>
      <ResolvedCompileFileDefinitionsToAdd Include="@(ResolvedCompileFileDefinitions)" />
      <ResolvedCompileFileDefinitionsToAdd Remove="%(_JoinedResolvedCompileFileDefinitions.HintPath)" />
      <!-- Add the references we computed -->
      <Reference Include="@(ResolvedCompileFileDefinitionsToAdd)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    ProjectReference Targets: Include transitive project references before
                              ResolveProjectReferences is called
    - IncludeTransitiveProjectReferences
    ============================================================
    -->
  <Target Name="IncludeTransitiveProjectReferences" DependsOnTargets="ResolvePackageAssets" Condition="'$(DisableTransitiveProjectReferences)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <ProjectReference Include="@(_TransitiveProjectReferences)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    Analyzer Targets: For populating Analyzers based on lock file
    - ResolveLockFileAnalyzers
    ============================================================
    -->
  <Target Name="ResolveLockFileAnalyzers" DependsOnTargets="ResolvePackageAssets" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <Analyzer Include="@(ResolvedAnalyzers)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    ResolveLockFileCopyLocalFiles
    Resolves the files from the assets file to copy for build and publish.
    ============================================================
  -->
  <Target Name="ResolveLockFileCopyLocalFiles" DependsOnTargets="ResolvePackageAssets;RunProduceContentAssets" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ResolvedCopyLocalBuildAssets Include="@(RuntimeCopyLocalItems)" Condition="'%(RuntimeCopyLocalItems.CopyLocal)' == 'true'" />
      <_ResolvedCopyLocalBuildAssets Include="@(ResourceCopyLocalItems)" Condition="'%(ResourceCopyLocalItems.CopyLocal)' == 'true'" />
      <!-- Always exclude the apphost executable from copy local assets; we will copy the generated apphost instead. -->
      <_ResolvedCopyLocalBuildAssets Include="@(NativeCopyLocalItems)" Exclude="@(_NativeRestoredAppHostNETCore)" Condition="'%(NativeCopyLocalItems.CopyLocal)' == 'true'" />
      <_ResolvedCopyLocalBuildAssets Include="@(RuntimeTargetsCopyLocalItems)" Condition="'%(RuntimeTargetsCopyLocalItems.CopyLocal)' == 'true'" />
      <ReferenceCopyLocalPaths Include="@(_ContentCopyLocalItems)" />
      <ReferenceCopyLocalPaths Include="@(_ResolvedCopyLocalBuildAssets)" Condition="'$(CopyLocalLockFileAssemblies)' == 'true'" />
    </ItemGroup>
  </Target>
  <!-- Override EnsureNETCoreAppRuntime target which is included in Microsoft.NETCore.App NuGet package for
       .NET Core 2.x.  It no longer works with the .NET 5.0.100 SDK, as the ParentTarget metadata has changed format
       but the targets in the NuGet package still expect the old format.

       So here we just override that target.  We have logic in the SDK that covers this scenario and generates
       NETSDK1056. -->
  <Target Name="EnsureNETCoreAppRuntime" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.PackageDependencyResolutionStubs.targets" Condition="Exists('$(MSBuildThisFileDirectory)Microsoft.PackageDependencyResolutionStubs.targets') and ('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true')" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.DefaultItems.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.DefaultItems.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.DefaultItems.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Don't get the default item globs by default when the flag is not set. -->
  <PropertyGroup Condition="'$(UsingNETSdkDefaults)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Given DisableDefaultItemsInProjectFolder=true, set EnableDefaultItems=false
         in case there is a solution/project in the current directory. -->
    <EnableDefaultItems Condition="'$(EnableDefaultItems)' == '' And&#xA;      '$(DisableDefaultItemsInProjectFolder)' == 'true' And&#xA;      ('$([System.IO.Directory]::GetFiles($(MSBuildProjectDirectory), &quot;*.sln&quot;).Length)' != '0' Or&#xA;      '$([System.IO.Directory]::GetFiles($(MSBuildProjectDirectory), &quot;*.slnx&quot;).Length)' != '0' Or&#xA;      '$([System.IO.Directory]::GetFiles($(MSBuildProjectDirectory), &quot;*.csproj&quot;).Length)' != '0')">false</EnableDefaultItems>
    <EnableDefaultItems Condition=" '$(EnableDefaultItems)' == '' ">true</EnableDefaultItems>
    <EnableDefaultCompileItems Condition=" '$(EnableDefaultCompileItems)' == '' ">true</EnableDefaultCompileItems>
    <EnableDefaultEmbeddedResourceItems Condition=" '$(EnableDefaultEmbeddedResourceItems)' == '' ">true</EnableDefaultEmbeddedResourceItems>
    <EnableDefaultNoneItems Condition=" '$(EnableDefaultNoneItems)' == '' ">true</EnableDefaultNoneItems>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Set DefaultItemExcludes property for items that should be excluded from the default Compile, etc items.
         This is in the .targets because it needs to come after the final BaseOutputPath has been evaluated. -->
    <!-- bin folder, by default -->
    <DefaultItemExcludes>$(DefaultItemExcludes);$(BaseOutputPath)/**</DefaultItemExcludes>
    <!-- obj folder, by default -->
    <DefaultItemExcludes>$(DefaultItemExcludes);$(BaseIntermediateOutputPath)/**</DefaultItemExcludes>
    <!-- Various files that should generally always be ignored -->
    <DefaultItemExcludes>$(DefaultItemExcludes);**/*.user</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**/*.*proj</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**/*.sln</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**/*.slnx</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**/*.vssscc</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**/.DS_Store</DefaultItemExcludes>
    <!-- WARNING: This pattern is there to ignore folders such as .git and .vs, but it will also match items included with a
         relative path outside the project folder (for example "..\Shared\Shared.cs").  So be sure only to apply it to items
         that are in the project folder. Support both DefaultItemExcludesInProjectFolder and DefaultExcludesInProjectFolder
         properties because of a naming mistake. -->
    <DefaultExcludesInProjectFolder>$(DefaultExcludesInProjectFolder);$(DefaultItemExcludesInProjectFolder);**/.*/**</DefaultExcludesInProjectFolder>
  </PropertyGroup>
  <!-- Set the default versions of the NETStandard.Library or Microsoft.NETCore.App packages to reference.
       The implicit package references themselves are defined in Microsoft.NET.Sdk.props, so that they can be overridden
       in the project file. -->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' And '$(_TargetFrameworkVersionWithoutV)' &lt; '2.1'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- If targeting .NET Standard 1.x, use version 1.6.1 of the package.  This is so that when projects are packed, the dependency on the package produced won't change when
         updating to the 2.0 or higher SDK.  When targeting .NET Standard 2.0 or higher, the NETStandard.Library reference won't show up as a dependency of the package
         produced, so we will roll forward to the latest version. -->
    <NETStandardImplicitPackageVersion Condition="'$(NETStandardImplicitPackageVersion)' =='' And '$(_TargetFrameworkVersionWithoutV)' &lt; '2.0'">1.6.1</NETStandardImplicitPackageVersion>
    <!-- Default to use the latest stable 2.0.x release. -->
    <NETStandardImplicitPackageVersion Condition="'$(NETStandardImplicitPackageVersion)' ==''">2.0.3</NETStandardImplicitPackageVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.DefaultItems.Shared.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.DefaultItems.Shared.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.DefaultItems.Shared.targets:  Properties and targets pulled from Microsoft.NET.Sdk.DefaultItems.targets
                                                to be shared by the WAP project system


WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    Determine the version (including patch) of .NET Core to target.

    When targeting .NET Core, the TargetFramework is used to specify the major and minor version of the runtime to use.  By default,
    the patch version is inferred.  The general logic is that self-contained apps will target the latest patch that the SDK
    knows about, while framework-dependent apps will target the ".0" patch (and roll forward to the latest patch installed at
    runtime).

    When targeting .NET Core 1.0 and 1.1, framework-dependent apps use 1.0.5 and 1.1.2, respectively.  This is done for compatibility
    with previous releases that bumped the self-contained and framework-dependent versions together.

    The TargetLatestRuntimePatch property can be set to true or false to explicitly opt in or out of the logic to roll forward
    to the latest patch, regardless of whether the app is self-contained or framework-dependent.

    The RuntimeFrameworkVersion is where the actual version of the .NET Core runtime to target can be set.  If set, it will be
    used in the implicit PackageReference to Microsoft.NETCore.App.

    The framework version that is written to the runtimeconfig.json file is based on the actual resolved package version
    of Microsoft.NETCore.App.  This is to allow floating the verion number (ie the RuntimeFrameworkVersion could be set to
    "2.0-*".

  -->
  <PropertyGroup Condition="'$(TargetLatestRuntimePatch)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetLatestRuntimePatch Condition="'$(SelfContained)' == 'true' ">true</TargetLatestRuntimePatch>
    <TargetLatestRuntimePatch Condition="'$(SelfContained)' != 'true' ">false</TargetLatestRuntimePatch>
    <_TargetLatestRuntimePatchIsDefault>true</_TargetLatestRuntimePatchIsDefault>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(DisableImplicitFrameworkReferences)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <VerifyMatchingImplicitPackageVersion Condition="'$(VerifyMatchingImplicitPackageVersion)' == ''">true</VerifyMatchingImplicitPackageVersion>
  </PropertyGroup>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Set implicit metadata on ASP.NET package references -->
    <PackageReference Update="Microsoft.AspNetCore.App">
      <PrivateAssets Condition="'%(PackageReference.Version)' == ''">all</PrivateAssets>
      <Publish Condition="'%(PackageReference.Version)' == ''">true</Publish>
    </PackageReference>
    <PackageReference Update="Microsoft.AspNetCore.All">
      <PrivateAssets Condition="'%(PackageReference.Version)' == ''">all</PrivateAssets>
      <Publish Condition="'%(PackageReference.Version)' == ''">true</Publish>
    </PackageReference>
    <!-- Allow RuntimeFrameworkVersion to be used to explicitly specify the version of Microsoft.NETCore.App -->
    <PackageReference Update="Microsoft.NETCore.App" Version="$(RuntimeFrameworkVersion)" Condition="'$(RuntimeFrameworkVersion)' != ''" AllowExplicitVersion="true" />
    <!-- If implicit PackageReferences are disabled, then don't warn about explicit versions at all -->
    <PackageReference Update="@(PackageReference)" Condition="'$(DisableImplicitFrameworkReferences)' == 'true'" AllowExplicitVersion="true" />
  </ItemGroup>
  <UsingTask TaskName="ApplyImplicitVersions" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="CheckIfPackageReferenceShouldBeFrameworkReference" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="UpdateAspNetToFrameworkReference" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CheckIfPackageReferenceShouldBeFrameworkReference PackageReferences="@(PackageReference)" FrameworkReferences="@(FrameworkReference)" PackageReferenceToReplace="Microsoft.AspNetCore.All" FrameworkReferenceToUse="Microsoft.AspNetCore.App">
      <Output TaskParameter="ShouldRemovePackageReference" PropertyName="_ShouldRemoveAspNetCoreAll" />
    </CheckIfPackageReferenceShouldBeFrameworkReference>
    <!-- NETSDK1079: The Microsoft.AspNetCore.All package is not supported when targeting .NET Core 3.0 or higher.
         A FrameworkReference to Microsoft.AspNetCore.App should be used instead, and will be implicitly included by Microsoft.NET.Sdk.Web. -->
    <NETSdkError Condition="'$(_ShouldRemoveAspNetCoreAll)' == 'true'" ResourceName="AspNetCoreAllNotSupported" />
    <CheckIfPackageReferenceShouldBeFrameworkReference PackageReferences="@(PackageReference)" FrameworkReferences="@(FrameworkReference)" PackageReferenceToReplace="Microsoft.AspNetCore.App" FrameworkReferenceToUse="Microsoft.AspNetCore.App">
      <Output TaskParameter="ShouldRemovePackageReference" PropertyName="_ShouldRemoveAspNetCoreApp" />
      <Output TaskParameter="ShouldAddFrameworkReference" PropertyName="_ShouldAddAspNetCoreAppFrameworkReference" />
    </CheckIfPackageReferenceShouldBeFrameworkReference>
    <ItemGroup>
      <PackageReference Remove="Microsoft.AspNetCore.App" Condition="'$(_ShouldRemoveAspNetCoreApp)' == 'true'" />
      <FrameworkReference Include="Microsoft.AspNetCore.App" Condition="'$(_ShouldAddAspNetCoreAppFrameworkReference)' == 'true'" />
    </ItemGroup>
    <!-- NETSDK1080: A PackageReference to Microsoft.AspNetCore.App is not necessary when targeting .NET Core 3.0 or higher.
         If Microsoft.NET.Sdk.Web is used, the shared framework will be referenced automatically. Otherwise, the PackageReference
         should be replaced with a FrameworkReference. -->
    <NETSdkWarning Condition="'$(_ShouldRemoveAspNetCoreApp)' == 'true'" ResourceName="AspNetCoreUsesFrameworkReference" />
  </Target>
  <Target Name="ApplyImplicitVersions" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;CollectPackageReferences;ProcessFrameworkReferences" DependsOnTargets="UpdateAspNetToFrameworkReference;CheckForImplicitPackageReferenceOverrides" Condition="'@(PackageReference)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ApplyImplicitVersions TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)" TargetLatestRuntimePatch="$(TargetLatestRuntimePatch)" PackageReferences="@(PackageReference)" ImplicitPackageReferenceVersions="@(ImplicitPackageReferenceVersion)">
      <Output TaskParameter="PackageReferencesToUpdate" ItemName="PackageReferenceToUpdate" />
      <Output TaskParameter="SdkBuildWarnings" ItemName="SdkBuildWarning" />
    </ApplyImplicitVersions>
    <ItemGroup>
      <PackageReference Remove="@(PackageReferenceToUpdate)" />
      <PackageReference Include="@(PackageReferenceToUpdate)" />
    </ItemGroup>
    <ItemGroup>
      <!-- Support using a patch version in the TargetFramework, ie netcoreapp1.1.1
           Note that this isn't officially supported, but it worked in the past so
           this should prevent breaking it. -->
      <PackageReference Condition="'%(PackageReference.Identity)' == 'Microsoft.NETCore.App'">
        <Version Condition="'%(PackageReference.Version)' == ''">$(_TargetFrameworkVersionWithoutV)</Version>
      </PackageReference>
    </ItemGroup>
  </Target>
  <UsingTask TaskName="CheckForImplicitPackageReferenceOverrides" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!-- Remove package references with metadata IsImplicitlyDefined = true, if there are other PackageReference items with the same identity -->
  <Target Name="CheckForImplicitPackageReferenceOverrides" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;CollectPackageReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <ImplicitPackageReferenceInformationLink>https://aka.ms/sdkimplicitrefs</ImplicitPackageReferenceInformationLink>
    </PropertyGroup>
    <CheckForImplicitPackageReferenceOverrides PackageReferenceItems="@(PackageReference)" MoreInformationLink="$(ImplicitPackageReferenceInformationLink)">
      <Output TaskParameter="ItemsToRemove" ItemName="_PackageReferenceToRemove" />
      <Output TaskParameter="ItemsToAdd" ItemName="_PackageReferenceToAdd" />
    </CheckForImplicitPackageReferenceOverrides>
    <ItemGroup>
      <!-- Remove and add the PackageReference items according to the output from the task -->
      <PackageReference Remove="@(_PackageReferenceToRemove)" />
      <PackageReference Include="@(_PackageReferenceToAdd)" />
      <!-- Clear items for other targets to use -->
      <_PackageReferenceToAdd Remove="@(_PackageReferenceToAdd)" />
    </ItemGroup>
    <!-- If any implicit package references were overridden, then don't check that RuntimeFrameworkVersion matches the package version -->
    <PropertyGroup Condition="'@(_PackageReferenceToRemove)' != ''">
      <VerifyMatchingImplicitPackageVersion>false</VerifyMatchingImplicitPackageVersion>
    </PropertyGroup>
  </Target>
  <UsingTask TaskName="CheckForDuplicateItems" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="CheckForDuplicateItems" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;CoreCompile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <DefaultItemsMoreInformationLink>https://aka.ms/sdkimplicititems</DefaultItemsMoreInformationLink>
    </PropertyGroup>
    <!-- NOTE for design-time builds we continue on errors and remove the duplicate items.
         This is because otherwise there won't be any references to pass to the compiler, leading to design-time
         compilation errors for every API that is used in the project.  Amidst all the compile errors, it would
         be easy to miss the duplicate items error which is the real source of the problem. -->
    <CheckForDuplicateItems Items="@(Compile)" ItemName="Compile" DefaultItemsEnabled="$(EnableDefaultItems)" DefaultItemsOfThisTypeEnabled="$(EnableDefaultCompileItems)" PropertyNameToDisableDefaultItems="EnableDefaultCompileItems" MoreInformationLink="$(DefaultItemsMoreInformationLink)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedCompileItems" />
    </CheckForDuplicateItems>
    <CheckForDuplicateItems Items="@(EmbeddedResource)" ItemName="EmbeddedResource" DefaultItemsEnabled="$(EnableDefaultItems)" DefaultItemsOfThisTypeEnabled="$(EnableDefaultEmbeddedResourceItems)" PropertyNameToDisableDefaultItems="EnableDefaultEmbeddedResourceItems" MoreInformationLink="$(DefaultItemsMoreInformationLink)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedEmbeddedResourceItems" />
    </CheckForDuplicateItems>
    <!-- Default content items are enabled by the Web SDK, not the .NET SDK, but we check it here for simplicity -->
    <CheckForDuplicateItems Items="@(Content)" ItemName="Content" DefaultItemsEnabled="$(EnableDefaultItems)" DefaultItemsOfThisTypeEnabled="$(EnableDefaultContentItems)" PropertyNameToDisableDefaultItems="EnableDefaultContentItems" MoreInformationLink="$(DefaultItemsMoreInformationLink)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedContentItems" />
    </CheckForDuplicateItems>
    <ItemGroup Condition="'$(DesignTimeBuild)' == 'true' And '@(DeduplicatedCompileItems)' != ''">
      <Compile Remove="@(Compile)" />
      <Compile Include="@(DeduplicatedCompileItems)" />
    </ItemGroup>
    <ItemGroup Condition="'$(DesignTimeBuild)' == 'true' And '@(DeduplicatedEmbeddedResourceItems)' != ''">
      <EmbeddedResource Remove="@(EmbeddedResource)" />
      <EmbeddedResource Include="@(DeduplicatedEmbeddedResourceItems)" />
    </ItemGroup>
    <ItemGroup Condition="'$(DesignTimeBuild)' == 'true' And '@(DeduplicatedContentItems)' != ''">
      <Content Remove="@(Content)" />
      <Content Include="@(DeduplicatedContentItems)" />
    </ItemGroup>
  </Target>
  <Target Name="_CheckForTransitiveWindowsDesktopDependencies" AfterTargets="ResolvePackageAssets" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '5.0')) and '$(TargetPlatformIdentifier)' != 'Windows' and '@(TransitiveFrameworkReference)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_WindowsDesktopTransitiveFrameworkReference Include="@(TransitiveFrameworkReference)" Condition="'%(Identity)' == 'Microsoft.WindowsDesktop.App' Or&#xA;                                                              '%(Identity)' == 'Microsoft.WindowsDesktop.App.WPF' Or&#xA;                                                              '%(Identity)' == 'Microsoft.WindowsDesktop.App.WindowsForms'" />
    </ItemGroup>
    <NetSdkError Condition="'@(_WindowsDesktopTransitiveFrameworkReference)' != ''" ResourceName="WindowsDesktopTargetPlatformMustBeWindows" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.DefaultItems.targets
============================================================================================================================================
-->
  <!-- This target runs before build but not before restore, to avoid duplicating these warnings
       if building with an implicit restore. -->
  <Target Name="WarnForExplicitVersions" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" DependsOnTargets="ApplyImplicitVersions" Condition="'@(SdkBuildWarning)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NetSdkWarning FormattedText="%(SdkBuildWarning.Identity)" />
  </Target>
  <!--
    Automatically add Link metadata to items of specific types if they are outside of the project folder and don't already have the Link metadata set.
    This will cause them to be shown in the Solution Explorer.  If an item has LinkBase metadata, the automatic Link will start with that value, and
    the items will appear in the Solution Explorer under the folder specified by LinkBase.
    -->
  <ItemGroup Condition="'$(SetLinkMetadataAutomatically)' != 'false'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Compile Update="@(Compile)">
      <!-- First, add a trailing slash to the LinkBase metadata if necessary.  This allows us to use the same value
           for the Link metadata whether or not LinkBase metadata is set: %(LinkBase)%(RecursiveDir)%(Filename)%(Extension)

           Note that RecursiveDir already includes the trailing slash.
      -->
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <!-- Set the Link metadata if it's not already set, if the item wasn't defined in a shared project,  and the item is outside of the project directory.
           Check whether the item was defined in a shared project by checking whether the extension of the defining project was .projitems.
           Check whether an item is inside the project directory by seeing if the FullPath starts with EnsureTrailingSlash(MSBuildProjectDirectory)
           The FullPath and the MSBuildProjectDirectory will both already be normalized full paths.
           The call to [MSBuild]::ValueOrDefault() is there in order to allow calling StartsWith on the FullPath value, since it's
           not possible to call a string method on a metadata item directly.  The intrinsic ValueOrDefault() will be more
           performant than calling String.Copy(), which has been used for this in other contexts, but actually makes a copy
           of the string data.
      -->
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </Compile>
    <AdditionalFiles Update="@(AdditionalFiles)">
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </AdditionalFiles>
    <None Update="@(None)">
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </None>
    <Content Update="@(Content)">
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </Content>
    <EmbeddedResource Update="@(EmbeddedResource)">
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </EmbeddedResource>
    <Page Update="@(Page)">
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </Page>
    <Resource Update="@(Resource)">
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </Resource>
  </ItemGroup>
  <Target Name="_CheckForFailedSDKResolution" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(SdkResolverHonoredGlobalJson)' == 'false'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NetSdkError ResourceName="GlobalJsonSDKResolutionFailed" FormatArguments="$(SdkResolverGlobalJsonPath)" />
  </Target>
  <Target Name="_WarnWhenUsingNET9AndVSPriorTo1712" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="$([MSBuild]::VersionLessThan($(MSBuildVersion), '17.12.0')) and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '9.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NetSdkWarning ResourceName="Net9NotCompatibleWithDev1711" />
  </Target>
  <Target Name="_CheckForInvalidWindowsDesktopTargetingConfiguration" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '5.0')) and ('$(UseWindowsForms)' == 'true' or '$(UseWPF)' == 'true')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(TargetPlatformIdentifier)' != 'Windows'" ResourceName="WindowsDesktopTargetPlatformMustBeWindows" />
  </Target>
  <Target Name="_CheckForUnnecessaryWindowsDesktopSDK" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '5.0')) and '$(_MicrosoftWindowsDesktopSdkImported)' == 'true' and '$(TargetFrameworks)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning ResourceName="UnnecessaryWindowsDesktopSDK" />
  </Target>
  <!-- Default the value of PublishRelease for 8.0+ TFMs. Note that this is pre-evaluated by the CLI in an evaluation before evaluation (see ReleasePropertyProjectLocator.cs).-->
  <PropertyGroup Condition="'$(PublishRelease)' == '' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '8.0'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PublishRelease>true</PublishRelease>
  </PropertyGroup>
  <!-- This verifies that the configuration between projects in a solution set by PackRelease agree.
  PackRelease only affects the CLI since VS has its own Configuration UI and it's not possible to detect like this in MSBuild.
  _IsPacking will only be set if packing in the CLI, so that's fine here. The pack targets are all outside of the SDK, which is why this is here.-->
  <Target Name="_VerifyPackReleaseConfigurations" BeforeTargets="PrepareForBuild" Condition="'$(_IsPacking)' == 'true' and '$(DOTNET_CLI_DISABLE_PUBLISH_AND_PACK_RELEASE)' != 'true' and '$(DOTNET_CLI_LAZY_PUBLISH_AND_PACK_RELEASE_FOR_SOLUTIONS)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(SolutionExt)' == '.sln' and&#xA;                            '$(_SolutionLevelPackRelease)' != '$(PackRelease)'" ResourceName="SolutionProjectConfigurationsConflict" FormatArguments="PackRelease;$(ProjectName)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.FrameworkReferenceResolution.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.FrameworkReferenceResolution.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.FrameworkReferenceResolution.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <ResolveAssemblyReferencesDependsOn>
      $(ResolveAssemblyReferencesDependsOn);
      ResolveTargetingPackAssets;
    </ResolveAssemblyReferencesDependsOn>
  </PropertyGroup>
  <UsingTask TaskName="CreateWindowsSdkKnownFrameworkReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="GetPackagesToPrune" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="CheckForDuplicateFrameworkReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="ProcessFrameworkReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="ResolveAppHosts" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <!-- Don't add Windows SDK framework reference for C++ by default, as C++ doesn't use it and it would be an unnecessary download for possible
       transitive framework references. -->
  <Target Name="AddWindowsSdkKnownFrameworkReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(TargetPlatformIdentifier)' == 'Windows'&#xA;                     And ('$(Language)' != 'C++' Or '$(IncludeWindowsSDKRefFrameworkReferences)' == 'true')">
    <!-- Remove Windows SDK KnownFrameworkReference items from BundledVersions.props (they will eventually be removed, but that is in a different repo so
         we can't do the change atomically). -->
    <ItemGroup>
      <KnownFrameworkReference Remove="Microsoft.Windows.SDK.NET.Ref" />
    </ItemGroup>
    <!-- Generate KnownFrameworkReference items for the Windows SDK pack -->
    <CreateWindowsSdkKnownFrameworkReferences UseWindowsSDKPreview="$(UseWindowsSDKPreview)" WindowsSdkPackageVersion="$(WindowsSdkPackageVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" WindowsSdkSupportedTargetPlatformVersions="@(WindowsSdkSupportedTargetPlatformVersion)">
      <Output TaskParameter="KnownFrameworkReferences" ItemName="KnownFrameworkReference" />
    </CreateWindowsSdkKnownFrameworkReferences>
  </Target>
  <!-- TODO: https://github.com/dotnet/sdk/issues/49917 Remove the framework based condition when the data for netcoreapp2.1 and below is fixed-->
  <Target Name="AddPrunePackageReferences" BeforeTargets="CollectPrunePackageReferences" DependsOnTargets="ProcessFrameworkReferences" Condition="'$(RestoreEnablePackagePruning)' == 'true'&#xA;          AND (('$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;          AND '$(TargetFrameworkVersion)' != ''&#xA;          AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '3.0')))&#xA;          OR ('$(TargetFrameworkIdentifier)' != '.NETCoreApp'))">
    <PropertyGroup>
      <PrunePackageDataRoot Condition="'$(PrunePackageDataRoot)' == ''">$(NetCoreRoot)\sdk\$(NETCoreSdkVersion)\PrunePackageData\</PrunePackageDataRoot>
      <PrunePackageTargetingPackRoots Condition="'$(PrunePackageTargetingPackRoots)' == ''">$(NetCoreTargetingPackRoot)</PrunePackageTargetingPackRoots>
      <AllowMissingPrunePackageData Condition="'$(AllowMissingPrunePackageData)' == ''">false</AllowMissingPrunePackageData>
    </PropertyGroup>
    <GetPackagesToPrune TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)" FrameworkReferences="@(FrameworkReference)" TargetingPacks="@(TargetingPack)" TargetingPackRoots="$(PrunePackageTargetingPackRoots)" PrunePackageDataRoot="$(PrunePackageDataRoot)" AllowMissingPrunePackageData="$(AllowMissingPrunePackageData)">
      <Output TaskParameter="PackagesToPrune" ItemName="PrunePackageReference" />
    </GetPackagesToPrune>
  </Target>
  <!--
    ============================================================
                                        ProcessFrameworkReferences

    Matches FrameworkReference items with KnownFrameworkReference items to determine the corresponding
    targeting pack and if necessary the runtime pack.  If the packs aren't available in the NetCoreTargetingPackRoot
    folder, then generate PackageDownload items in order to download the packs during restore.

    Also resolves app host packs in a similar fashion, and checks for duplicate FrameworkReference items.
    ============================================================
    -->
  <Target Name="ProcessFrameworkReferences" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;CollectPackageReferences;CollectPackageDownloads" DependsOnTargets="AddWindowsSdkKnownFrameworkReferences" Condition="'@(FrameworkReference)' != '' Or '$(_RequiresILLinkPack)' == 'true'">
    <CheckForDuplicateFrameworkReferences FrameworkReferences="@(FrameworkReference)" MoreInformationLink="https://aka.ms/sdkimplicitrefs">
      <Output TaskParameter="ItemsToRemove" ItemName="_FrameworkReferenceToRemove" />
      <Output TaskParameter="ItemsToAdd" ItemName="_FrameworkReferenceToAdd" />
    </CheckForDuplicateFrameworkReferences>
    <ItemGroup>
      <FrameworkReference Remove="@(_FrameworkReferenceToRemove)" />
      <FrameworkReference Include="@(_FrameworkReferenceToAdd)" />
    </ItemGroup>
    <PropertyGroup>
      <EnableTargetingPackDownload Condition="'$(EnableTargetingPackDownload)' == ''">true</EnableTargetingPackDownload>
      <EnableRuntimePackDownload Condition="'$(EnableRuntimePackDownload)' == ''">true</EnableRuntimePackDownload>
      <RequiresAspNetWebAssets Condition="'$(RequiresAspNetWebAssets)' == ''">false</RequiresAspNetWebAssets>
    </PropertyGroup>
    <PropertyGroup>
      <_NuGetRestoreSupported Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true')">false</_NuGetRestoreSupported>
    </PropertyGroup>
    <ItemGroup>
      <_PackAsToolShimRuntimeIdentifiers Condition="@(_PackAsToolShimRuntimeIdentifiers) ==''" Include="$(PackAsToolShimRuntimeIdentifiers)" />
    </ItemGroup>
    <ProcessFrameworkReferences FrameworkReferences="@(FrameworkReference)" KnownFrameworkReferences="@(KnownFrameworkReference)" KnownRuntimePacks="@(KnownRuntimePack)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetingPackRoot="$(NetCoreTargetingPackRoot)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" SelfContained="$(SelfContained)" ReadyToRunEnabled="$(PublishReadyToRun)" ReadyToRunUseCrossgen2="$(PublishReadyToRunUseCrossgen2)" PublishAot="$(PublishAot)" RequiresILLinkPack="$(_RequiresILLinkPack)" IsAotCompatible="$(IsAotCompatible)" SilenceIsAotCompatibleUnsupportedWarning="$(_SilenceIsAotCompatibleUnsupportedWarning)" MinNonEolTargetFrameworkForAot="$(_MinNonEolTargetFrameworkForAot)" EnableAotAnalyzer="$(EnableAotAnalyzer)" FirstTargetFrameworkVersionToSupportAotAnalyzer="$(_FirstTargetFrameworkVersionToSupportAotAnalyzer)" PublishTrimmed="$(PublishTrimmed)" IsTrimmable="$(IsTrimmable)" FirstTargetFrameworkVersionToSupportTrimAnalyzer="$(_FirstTargetFrameworkVersionToSupportTrimAnalyzer)" SilenceIsTrimmableUnsupportedWarning="$(_SilenceIsTrimmableUnsupportedWarning)" MinNonEolTargetFrameworkForTrimming="$(_MinNonEolTargetFrameworkForTrimming)" EnableTrimAnalyzer="$(EnableTrimAnalyzer)" EnableSingleFileAnalyzer="$(EnableSingleFileAnalyzer)" FirstTargetFrameworkVersionToSupportSingleFileAnalyzer="$(_FirstTargetFrameworkVersionToSupportSingleFileAnalyzer)" SilenceEnableSingleFileAnalyzerUnsupportedWarning="$(_SilenceEnableSingleFileAnalyzerUnsupportedWarning)" MinNonEolTargetFrameworkForSingleFile="$(_MinNonEolTargetFrameworkForSingleFile)" AotUseKnownRuntimePackForTarget="$(PublishAotUsingRuntimePack)" RuntimeIdentifier="$(RuntimeIdentifier)" RuntimeIdentifiers="$(RuntimeIdentifiers)" RuntimeFrameworkVersion="$(RuntimeFrameworkVersion)" TargetLatestRuntimePatch="$(TargetLatestRuntimePatch)" TargetLatestRuntimePatchIsDefault="$(_TargetLatestRuntimePatchIsDefault)" EnableTargetingPackDownload="$(EnableTargetingPackDownload)" EnableRuntimePackDownload="$(EnableRuntimePackDownload)" EnableWindowsTargeting="$(EnableWindowsTargeting)" DisableTransitiveFrameworkReferenceDownloads="$(DisableTransitiveFrameworkReferenceDownloads)" KnownCrossgen2Packs="@(KnownCrossgen2Pack)" KnownILCompilerPacks="@(KnownILCompilerPack)" KnownILLinkPacks="@(KnownILLinkPack)" KnownWebAssemblySdkPacks="@(KnownWebAssemblySdkPack)" KnownAspNetCorePacks="@(KnownAspNetCorePack)" UsingMicrosoftNETSdkWebAssembly="$(UsingMicrosoftNETSdkWebAssembly)" RequiresAspNetWebAssets="$(RequiresAspNetWebAssets)" NETCoreSdkRuntimeIdentifier="$(NETCoreSdkRuntimeIdentifier)" NETCoreSdkPortableRuntimeIdentifier="$(NETCoreSdkPortableRuntimeIdentifier)" NetCoreRoot="$(NetCoreRoot)" NETCoreSdkVersion="$(NETCoreSdkVersion)">
      <Output TaskParameter="PackagesToDownload" ItemName="_PackageToDownload" />
      <Output TaskParameter="RuntimeFrameworks" ItemName="RuntimeFramework" />
      <Output TaskParameter="TargetingPacks" ItemName="TargetingPack" />
      <Output TaskParameter="RuntimePacks" ItemName="RuntimePack" />
      <Output TaskParameter="Crossgen2Packs" ItemName="Crossgen2Pack" />
      <Output TaskParameter="HostILCompilerPacks" ItemName="HostILCompilerPack" />
      <Output TaskParameter="TargetILCompilerPacks" ItemName="TargetILCompilerPack" />
      <Output TaskParameter="UnavailableRuntimePacks" ItemName="UnavailableRuntimePack" />
      <Output TaskParameter="ImplicitPackageReferences" ItemName="_ImplicitPackageReference" />
      <Output TaskParameter="KnownRuntimeIdentifierPlatforms" ItemName="_KnownRuntimeIdentifierPlatformsForTargetFramework" />
    </ProcessFrameworkReferences>
    <PropertyGroup Condition="'$(AppHostRuntimeIdentifier)' == '' And&#xA;                              ('$(UseAppHost)' == 'true' Or '$(EnableComHosting)' == 'true' Or '$(UseIJWHost)' == 'true')">
      <AppHostRuntimeIdentifier>$(RuntimeIdentifier)</AppHostRuntimeIdentifier>
      <AppHostRuntimeIdentifier Condition="'$(AppHostRuntimeIdentifier)' == ''">$(DefaultAppHostRuntimeIdentifier)</AppHostRuntimeIdentifier>
    </PropertyGroup>
    <ResolveAppHosts TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)" TargetingPackRoot="$(NetCoreTargetingPackRoot)" AppHostRuntimeIdentifier="$(AppHostRuntimeIdentifier)" OtherRuntimeIdentifiers="$(RuntimeIdentifiers)" RuntimeFrameworkVersion="$(RuntimeFrameworkVersion)" PackAsToolShimRuntimeIdentifiers="@(_PackAsToolShimRuntimeIdentifiers)" DotNetAppHostExecutableNameWithoutExtension="$(_DotNetAppHostExecutableNameWithoutExtension)" DotNetSingleFileHostExecutableNameWithoutExtension="$(_DotNetSingleFileHostExecutableNameWithoutExtension)" DotNetComHostLibraryNameWithoutExtension="$(_DotNetComHostLibraryNameWithoutExtension)" DotNetIjwHostLibraryNameWithoutExtension="$(_DotNetIjwHostLibraryNameWithoutExtension)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" KnownAppHostPacks="@(KnownAppHostPack)" NuGetRestoreSupported="$(_NuGetRestoreSupported)" EnableAppHostPackDownload="$(EnableAppHostPackDownload)" NetCoreTargetingPackRoot="$(NetCoreTargetingPackRoot)">
      <Output TaskParameter="PackagesToDownload" ItemName="_PackageToDownload" />
      <Output TaskParameter="AppHost" ItemName="AppHostPack" />
      <Output TaskParameter="SingleFileHost" ItemName="SingleFileHostPack" />
      <Output TaskParameter="ComHost" ItemName="ComHostPack" />
      <Output TaskParameter="IjwHost" ItemName="IjwHostPack" />
      <Output TaskParameter="PackAsToolShimAppHostPacks" ItemName="PackAsToolShimAppHostPack" />
    </ResolveAppHosts>
    <PropertyGroup Condition="'$(UsePackageDownload)' == ''">
      <UsePackageDownload Condition="'$(MSBuildRuntimeType)' == 'Core'">true</UsePackageDownload>
      <UsePackageDownload Condition="'$(PackageDownloadSupported)' == 'true'">true</UsePackageDownload>
      <UsePackageDownload Condition="'$(UsePackageDownload)' == ''">false</UsePackageDownload>
    </PropertyGroup>
    <ItemGroup Condition="'$(UsePackageDownload)' == 'true'">
      <PackageDownload Include="@(_PackageToDownload)">
        <Version>[%(_PackageToDownload.Version)]</Version>
      </PackageDownload>
    </ItemGroup>
    <ItemGroup Condition="'$(UsePackageDownload)' != 'true'">
      <PackageReference Include="@(_PackageToDownload)" IsImplicitlyDefined="true" PrivateAssets="all" ExcludeAssets="all" />
    </ItemGroup>
    <!-- Add implicit package references that don't already exist in PackageReference. -->
    <ItemGroup>
      <_ImplicitPackageReference Remove="@(PackageReference)" />
      <PackageReference Include="@(_ImplicitPackageReference)" IsImplicitlyDefined="true" PrivateAssets="all" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        AddTransitiveFrameworkReferences

    Adds FrameworkReference items for shared frameworks which weren't directly referenced,
    but were referenced transitively via a project or package reference.  NuGet writes these
    to the assets file, and the ResolvePackageAssets target adds them to the TransitiveFrameworkReference
    item.  Here, we add them to FrameworkReference if they aren't already referenced.
    We add a transitive attribute to the FrameworkReferences so NuGet can filter them out from CollectFrameworkReferences.
    ============================================================
    -->
  <Target Name="AddTransitiveFrameworkReferences" AfterTargets="ResolvePackageAssets" Condition="'@(TransitiveFrameworkReference)' != ''">
    <ItemGroup>
      <FrameworkReference Include="@(TransitiveFrameworkReference)" Exclude="@(FrameworkReference)" IsTransitiveFrameworkReference="true" />
    </ItemGroup>
  </Target>
  <UsingTask TaskName="ResolveFrameworkReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <!--
    ============================================================
                                        ResolveFrameworkReferences

    Resolves paths to various FrameworkReference-related items (targeting packs, runtime packs,
    app host packs).  Some of these may already have had the path set if they were in the
    NetCoreTargetingPackRoot folder.  Others which were downloaded as NuGet packages will
    need to have the path set here.
    ============================================================
    -->
  <Target Name="ResolveFrameworkReferences" DependsOnTargets="ProcessFrameworkReferences;ResolvePackageAssets" Condition="'@(FrameworkReference)' != ''" Returns="@(ResolvedFrameworkReference)">
    <GetPackageDirectory Items="@(TargetingPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedTargetingPack" />
    </GetPackageDirectory>
    <ItemGroup>
      <ResolvedTargetingPack Condition="'%(ResolvedTargetingPack.Path)' == '' and '%(ResolvedTargetingPack.PackageDirectory)' != ''">
        <Path>%(ResolvedTargetingPack.PackageDirectory)</Path>
      </ResolvedTargetingPack>
    </ItemGroup>
    <GetPackageDirectory Items="@(AppHostPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedAppHostPack" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(SingleFileHostPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedSingleFileHostPack" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(Crossgen2Pack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedCrossgen2Pack" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(HostILCompilerPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedILCompilerPack" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(TargetILCompilerPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedTargetILCompilerPack" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(PackAsToolShimAppHostPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="_ApphostsForShimRuntimeIdentifiersGetPackageDirectory" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(ComHostPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedComHostPack" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(IjwHostPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedIjwHostPack" />
    </GetPackageDirectory>
    <ItemGroup>
      <_ApphostsForShimRuntimeIdentifiers Include="%(_ApphostsForShimRuntimeIdentifiersGetPackageDirectory.PackageDirectory)\%(_ApphostsForShimRuntimeIdentifiersGetPackageDirectory.PathInPackage)">
        <RuntimeIdentifier>%(_ApphostsForShimRuntimeIdentifiersGetPackageDirectory.RuntimeIdentifier)</RuntimeIdentifier>
      </_ApphostsForShimRuntimeIdentifiers>
    </ItemGroup>
    <ItemGroup>
      <ResolvedAppHostPack Condition="'%(ResolvedAppHostPack.Path)' == '' and '%(ResolvedAppHostPack.PackageDirectory)' != ''">
        <Path>%(ResolvedAppHostPack.PackageDirectory)\%(ResolvedAppHostPack.PathInPackage)</Path>
      </ResolvedAppHostPack>
    </ItemGroup>
    <PropertyGroup Condition="'@(ResolvedAppHostPack)' != '' And '$(AppHostSourcePath)' == ''">
      <AppHostSourcePath>@(ResolvedAppHostPack->'%(Path)')</AppHostSourcePath>
    </PropertyGroup>
    <ItemGroup>
      <ResolvedSingleFileHostPack Condition="'%(ResolvedSingleFileHostPack.Path)' == '' and '%(ResolvedSingleFileHostPack.PackageDirectory)' != ''">
        <Path>%(ResolvedSingleFileHostPack.PackageDirectory)\%(ResolvedSingleFileHostPack.PathInPackage)</Path>
      </ResolvedSingleFileHostPack>
    </ItemGroup>
    <PropertyGroup Condition="'@(ResolvedSingleFileHostPack)' != '' And '$(SingleFileHostSourcePath)' == ''">
      <SingleFileHostSourcePath>@(ResolvedSingleFileHostPack->'%(Path)')</SingleFileHostSourcePath>
    </PropertyGroup>
    <ItemGroup>
      <ResolvedComHostPack Condition="'%(ResolvedComHostPack.Path)' == '' and '%(ResolvedComHostPack.PackageDirectory)' != ''">
        <Path>%(ResolvedComHostPack.PackageDirectory)\%(ResolvedComHostPack.PathInPackage)</Path>
      </ResolvedComHostPack>
    </ItemGroup>
    <PropertyGroup Condition="'@(ResolvedComHostPack)' != '' And '$(ComHostSourcePath)' == ''">
      <ComHostSourcePath>@(ResolvedComHostPack->'%(Path)')</ComHostSourcePath>
    </PropertyGroup>
    <ItemGroup>
      <ResolvedIjwHostPack Condition="'%(ResolvedIjwHostPack.Path)' == '' and '%(ResolvedIjwHostPack.PackageDirectory)' != ''">
        <Path>%(ResolvedIjwHostPack.PackageDirectory)\%(ResolvedIjwHostPack.PathInPackage)</Path>
      </ResolvedIjwHostPack>
    </ItemGroup>
    <PropertyGroup Condition="'@(ResolvedIjwHostPack)' != '' And '$(IjwHostSourcePath)' == ''">
      <IjwHostSourcePath>@(ResolvedIjwHostPack->'%(Path)')</IjwHostSourcePath>
    </PropertyGroup>
    <GetPackageDirectory Items="@(RuntimePack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedRuntimePack" />
    </GetPackageDirectory>
    <ResolveFrameworkReferences FrameworkReferences="@(FrameworkReference)" ResolvedTargetingPacks="@(ResolvedTargetingPack)" ResolvedRuntimePacks="@(ResolvedRuntimePack)">
      <Output TaskParameter="ResolvedFrameworkReferences" ItemName="ResolvedFrameworkReference" />
    </ResolveFrameworkReferences>
  </Target>
  <UsingTask TaskName="GetPackageDirectory" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="ResolveTargetingPackAssets" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <!--
    ============================================================
                                        ResolveTargetingPackAssets

    Resolve assets (primarily references) from targeting packs.
    ============================================================
    -->
  <Target Name="ResolveTargetingPackAssets" DependsOnTargets="ResolveFrameworkReferences" Condition="'@(FrameworkReference)' != ''">
    <!-- For design-time builds, don't generate an error if a targeting pack isn't available (ie because it hasn't been restored yet) -->
    <PropertyGroup Condition="'$(GenerateErrorForMissingTargetingPacks)' == ''">
      <GenerateErrorForMissingTargetingPacks>true</GenerateErrorForMissingTargetingPacks>
      <GenerateErrorForMissingTargetingPacks Condition="'$(DesignTimeBuild)' == 'true'">false</GenerateErrorForMissingTargetingPacks>
    </PropertyGroup>
    <ResolveTargetingPackAssets FrameworkReferences="@(FrameworkReference)" ProjectLanguage="$(Language)" ResolvedTargetingPacks="@(ResolvedTargetingPack)" RuntimeFrameworks="@(RuntimeFramework)" GenerateErrorForMissingTargetingPacks="$(GenerateErrorForMissingTargetingPacks)" NuGetRestoreSupported="$(_NuGetRestoreSupported)" DisableTransitiveFrameworkReferenceDownloads="$(DisableTransitiveFrameworkReferenceDownloads)" NetCoreTargetingPackRoot="$(NetCoreTargetingPackRoot)">
      <Output TaskParameter="ReferencesToAdd" ItemName="Reference" />
      <Output TaskParameter="AnalyzersToAdd" ItemName="Analyzer" />
      <Output TaskParameter="PlatformManifests" ItemName="PlatformManifestsFromTargetingPacks" />
      <Output TaskParameter="PackageConflictPreferredPackages" PropertyName="PackageConflictPreferredPackages" />
      <Output TaskParameter="PackageConflictOverrides" ItemName="PackageConflictOverrides" />
      <Output TaskParameter="UsedRuntimeFrameworks" ItemName="_UsedRuntimeFramework" />
    </ResolveTargetingPackAssets>
    <PropertyGroup>
      <!-- Unescape this semicolon-delimited ordered list so that it's passed as a list to targets
           that consume it. -->
      <PackageConflictPreferredPackages>$([MSBuild]::Unescape($(PackageConflictPreferredPackages)))</PackageConflictPreferredPackages>
    </PropertyGroup>
    <ItemGroup Condition="'$(RuntimeIdentifier)' == '' or '$(SelfContained)' != 'true'">
      <PackageConflictPlatformManifests Include="@(PlatformManifestsFromTargetingPacks)" />
    </ItemGroup>
    <ItemGroup>
      <RuntimeFramework Remove="@(RuntimeFramework)" />
      <RuntimeFramework Include="@(_UsedRuntimeFramework)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveOffByDefaultAnalyzers" AfterTargets="ResolveTargetingPackAssets" Condition="'@(FrameworkReference)' != ''">
    <ItemGroup>
      <OffByDefaultAnalyzer Include="Microsoft.AspNetCore.Http.RequestDelegateGenerator.dll" IsEnabled="$(EnableRequestDelegateGenerator)" />
      <OffByDefaultAnalyzer Include="Microsoft.Extensions.Configuration.Binder.SourceGeneration.dll" IsEnabled="$(EnableConfigurationBindingGenerator)" />
    </ItemGroup>
    <ItemGroup>
      <Analyzer Remove="@(OffByDefaultAnalyzer)" Condition="'%(OffByDefaultAnalyzer.IsEnabled)' != 'true'" MatchOnMetadata="FileName" />
    </ItemGroup>
  </Target>
  <UsingTask TaskName="ResolveRuntimePackAssets" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <!--
    ============================================================
                                        IncludeTargetingPackReference

    Add package reference for required targeting pack if necessary
    ============================================================
    -->
  <Target Name="IncludeTargetingPackReference" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;CollectPackageReferences;CheckForImplicitPackageReferenceOverrides" Condition="'$(TargetFrameworkMoniker)' != '' and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(AutomaticallyUseReferenceAssemblyPackages)' == 'true'">
    <GetReferenceAssemblyPaths TargetFrameworkMoniker="$(TargetFrameworkMoniker)" RootPath="$(TargetFrameworkRootPath)" TargetFrameworkFallbackSearchPaths="$(TargetFrameworkFallbackSearchPaths)" BypassFrameworkInstallChecks="true" SuppressNotFoundError="true">
      <Output TaskParameter="FullFrameworkReferenceAssemblyPaths" PropertyName="_FullFrameworkReferenceAssemblyPaths" />
    </GetReferenceAssemblyPaths>
    <ItemGroup>
      <_ExistingReferenceAssembliesPackageReference Include="@(PackageReference)" Condition="'%(PackageReference.Identity)' == 'Microsoft.NETFramework.ReferenceAssemblies'" />
      <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="$(MicrosoftNETFrameworkReferenceAssembliesLatestPackageVersion)" IsImplicitlyDefined="true" PrivateAssets="All" Condition="('$(_FullFrameworkReferenceAssemblyPaths)' == '' or $(_FullFrameworkReferenceAssemblyPaths.Contains('microsoft.netframework.referenceassemblies'))) and '@(_ExistingReferenceAssembliesPackageReference)' == ''" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ResolveRuntimePackAssets

    Resolve assets from runtime packs.
    ============================================================
    -->
  <Target Name="ResolveRuntimePackAssets" DependsOnTargets="ResolveFrameworkReferences" Condition="'@(RuntimePack)' != ''">
    <ResolveRuntimePackAssets FrameworkReferences="@(FrameworkReference)" RuntimeFrameworks="@(RuntimeFramework)" ResolvedRuntimePacks="@(ResolvedRuntimePack)" UnavailableRuntimePacks="@(UnavailableRuntimePack)" SatelliteResourceLanguages="$(SatelliteResourceLanguages)" DesignTimeBuild="$(DesignTimeBuild)" DisableTransitiveFrameworkReferenceDownloads="$(DisableTransitiveFrameworkReferenceDownloads)">
      <Output TaskParameter="RuntimePackAssets" ItemName="RuntimePackAsset" />
    </ResolveRuntimePackAssets>
    <ItemGroup>
      <ReferenceCopyLocalPaths Include="@(RuntimePackAsset)" Condition="'$(CopyLocalLockFileAssemblies)' == 'true' and ('$(SelfContained)' == 'true' or '%(RuntimePackAsset.RuntimePackAlwaysCopyLocal)' == 'true') and '%(RuntimePackAsset.AssetType)' != 'pgodata'" />
    </ItemGroup>
  </Target>
  <!--
    Adds metadata so the SDK will generate the UserSecretsIdAttribute.

    This is associated with ASP.NET Core, but may be used in projects that don't use the Web SDK (especially test projects).
    So it is in the base .NET SDK.  (It used to be in the Microsoft.AspNetCore.App package, but now that that's a targeting
    pack we don't support importing build logic from it directly).

    If GeneratedUserSecretsAttributeFile is set, that means Microsoft.Extensions.Configuration.UserSecrets 2.1
    or earlier was referenced as a package. This didn't use the AssemblyAttribute item group, so we cannot
    avoid duplicate AssemblyAttribute items without skipping this target altogether..
  -->
  <Target Name="_GetUserSecretsAssemblyAttribute" BeforeTargets="GetAssemblyAttributes" Condition=" '$(UserSecretsId)' != '' AND '$(GenerateUserSecretsAttribute)' != 'false' AND '$(GeneratedUserSecretsAttributeFile)' == '' ">
    <!--
      If the Microsoft.Extensions.Configuration.UserSecrets package 2.2 or higher is referenced directly,
      it will also add an AssemblyAttribute item. Since this attribute only allows one per assembly, do not
      duplicate the item.

      Also don't add the attribute if there is neither a Microsoft.AspNetCore.App FrameworkReference nor a
      Microsoft.Extensions.Configuration.UserSecrets PackageReference, in order to preserve 2.x SDK behavior
      where projects would successfully build if they define the UserSecretsId property but don't reference
      the corresponding API.

    -->
    <ItemGroup Condition=" @(AssemblyAttribute-&gt;WithMetadataValue('Identity', 'Microsoft.Extensions.Configuration.UserSecrets.UserSecretsIdAttribute')-&gt;Count()) == 0 And&#xA;                            (@(FrameworkReference-&gt;WithMetadataValue('Identity', 'Microsoft.AspNetCore.App')-&gt;Count()) != 0 Or&#xA;                            @(PackageReference-&gt;WithMetadataValue('Identity', 'Microsoft.Extensions.Configuration.UserSecrets')-&gt;Count()) != 0)">
      <AssemblyAttribute Include="Microsoft.Extensions.Configuration.UserSecrets.UserSecretsIdAttribute">
        <_Parameter1>$(UserSecretsId.Trim())</_Parameter1>
      </AssemblyAttribute>
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <UsingTask TaskName="GenerateDepsFile" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="GenerateRuntimeConfigurationFiles" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="GetAssemblyVersion" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="GenerateSatelliteAssemblies" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DisableStandardFrameworkResolution Condition="'$(DisableStandardFrameworkResolution)' == ''">$(_IsNETCoreOrNETStandard)</DisableStandardFrameworkResolution>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateRuntimeConfigurationFiles Condition=" '$(GenerateRuntimeConfigurationFiles)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and ('$(HasRuntimeOutput)' == 'true' or '$(EnableComHosting)' == 'true' or '$(EnableDynamicLoading)' == 'true') ">true</GenerateRuntimeConfigurationFiles>
    <AlwaysIncludeCoreFrameworkInRuntimeConfig Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionLessThan('$(TargetFrameworkVersion)', '6.0'))">false</AlwaysIncludeCoreFrameworkInRuntimeConfig>
    <AlwaysIncludeCoreFrameworkInRuntimeConfig Condition="'$(AlwaysIncludeCoreFrameworkInRuntimeConfig)' == ''">true</AlwaysIncludeCoreFrameworkInRuntimeConfig>
    <UserRuntimeConfig Condition=" '$(UserRuntimeConfig)' == '' ">$(MSBuildProjectDirectory)/runtimeconfig.template.json</UserRuntimeConfig>
    <GenerateSatelliteAssembliesForCore Condition=" '$(GenerateSatelliteAssembliesForCore)' == '' and '$(MSBuildRuntimeType)' == 'Core' ">true</GenerateSatelliteAssembliesForCore>
    <ComputeNETCoreBuildOutputFiles Condition=" '$(ComputeNETCoreBuildOutputFiles)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'">true</ComputeNETCoreBuildOutputFiles>
    <_GenerateRuntimeConfigurationPropertyInputsCache Condition="'$(_GenerateRuntimeConfigurationPropertyInputsCache)' == ''">$(IntermediateOutputPath)$(MSBuildProjectName).genruntimeconfig.cache</_GenerateRuntimeConfigurationPropertyInputsCache>
    <_GenerateRuntimeConfigurationPropertyInputsCache>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(_GenerateRuntimeConfigurationPropertyInputsCache)))</_GenerateRuntimeConfigurationPropertyInputsCache>
    <_GeneratePublishDependencyFilePropertyInputsCache Condition="'$(_GeneratePublishDependencyFilePropertyInputsCache)' == ''">$(IntermediateOutputPath)$(MSBuildProjectName).genpublishdeps.cache</_GeneratePublishDependencyFilePropertyInputsCache>
    <_GeneratePublishDependencyFilePropertyInputsCache>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(_GeneratePublishDependencyFilePropertyInputsCache)))</_GeneratePublishDependencyFilePropertyInputsCache>
    <_GenerateSingleFileBundlePropertyInputsCache Condition="'$(_GenerateSingleFileBundlePropertyInputsCache)' == ''">$(IntermediateOutputPath)$(MSBuildProjectName).genbundle.cache</_GenerateSingleFileBundlePropertyInputsCache>
    <_GenerateSingleFileBundlePropertyInputsCache>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(_GenerateSingleFileBundlePropertyInputsCache)))</_GenerateSingleFileBundlePropertyInputsCache>
  </PropertyGroup>
  <!-- For .NET 8 and higher, we will by default use a simplified "portable" RID graph -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_UseRidGraphWasSpecified Condition="'$(UseRidGraph)' != ''">true</_UseRidGraphWasSpecified>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseRidGraph)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <UseRidGraph Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '8.0'))">false</UseRidGraph>
    <UseRidGraph Condition="'$(UseRidGraph)' == ''">true</UseRidGraph>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RuntimeIdentifierGraphPath)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RuntimeIdentifierGraphPath Condition="'$(UseRidGraph)' == 'true'">$(BundledRuntimeIdentifierGraphFile)</RuntimeIdentifierGraphPath>
    <!-- The portable RID graph should be in the same directory as the full RID graph -->
    <RuntimeIdentifierGraphPath Condition="'$(UseRidGraph)' != 'true'">$([System.IO.Path]::GetDirectoryName($(BundledRuntimeIdentifierGraphFile)))/PortableRuntimeIdentifierGraph.json</RuntimeIdentifierGraphPath>
  </PropertyGroup>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateRuntimeConfigurationFilesInputs Include="$(ProjectAssetsFile)" />
    <GenerateRuntimeConfigurationFilesInputs Include="$(ProjectAssetsCacheFile)" />
    <GenerateRuntimeConfigurationFilesInputs Include="$(UserRuntimeConfig)" Condition=" Exists($(UserRuntimeConfig)) " />
  </ItemGroup>
  <ItemGroup Condition="'$(TargetFrameworks)' != '' And '$(TargetFramework)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectConfigurationDescription Include="TargetFramework=$(TargetFramework)" />
  </ItemGroup>
  <PropertyGroup Condition="'$(GenerateRuntimeConfigDevFile)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateRuntimeConfigDevFile>true</GenerateRuntimeConfigDevFile>
    <!-- Post-net6.0, stop generating *.runtimeconfig.dev.json files to reduce probing paths. -->
    <!-- https://github.com/dotnet/sdk/issues/16818 -->
    <GenerateRuntimeConfigDevFile Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0'))">false</GenerateRuntimeConfigDevFile>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectDepsFileName Condition="'$(ProjectDepsFileName)' == ''">$(AssemblyName).deps.json</ProjectDepsFileName>
    <ProjectDepsFilePath Condition="'$(ProjectDepsFilePath)' == ''">$(TargetDir)$(ProjectDepsFileName)</ProjectDepsFilePath>
    <ProjectRuntimeConfigFileName Condition="'$(ProjectRuntimeConfigFileName)' == ''">$(AssemblyName).runtimeconfig.json</ProjectRuntimeConfigFileName>
    <ProjectRuntimeConfigFilePath Condition="'$(ProjectRuntimeConfigFilePath)' == ''">$(TargetDir)$(ProjectRuntimeConfigFileName)</ProjectRuntimeConfigFilePath>
    <ProjectRuntimeConfigDevFilePath Condition="'$(ProjectRuntimeConfigDevFilePath)' == '' and $(GenerateRuntimeConfigDevFile) == 'true'">$(TargetDir)$(AssemblyName).runtimeconfig.dev.json</ProjectRuntimeConfigDevFilePath>
    <IncludeMainProjectInDepsFile Condition=" '$(IncludeMainProjectInDepsFile)' == '' ">true</IncludeMainProjectInDepsFile>
    <TrimDepsJsonLibrariesWithoutAssets Condition=" '$(TrimDepsJsonLibrariesWithoutAssets)' == '' ">true</TrimDepsJsonLibrariesWithoutAssets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.Shared.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.Shared.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.Shared.targets:  The properties and targets shared by the WAP project system.

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(UsingNETSdkDefaults)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Skip import of Microsoft.NuGet.props and Microsoft.NuGet.targets -->
    <SkipImportNuGetProps>true</SkipImportNuGetProps>
    <SkipImportNuGetBuildTargets>true</SkipImportNuGetBuildTargets>
  </PropertyGroup>
  <!-- Workaround: https://github.com/Microsoft/msbuild/issues/1293 -->
  <PropertyGroup Condition="'$(MSBuildRuntimeType)' == 'Core' Or '$(TargetFrameworkIdentifier)' != '.NETFramework'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateResourceMSBuildArchitecture Condition=" '$(GenerateResourceMSBuildArchitecture)' == '' ">CurrentArchitecture</GenerateResourceMSBuildArchitecture>
    <GenerateResourceMSBuildRuntime Condition=" '$(GenerateResourceMSBuildRuntime)' == '' ">CurrentRuntime</GenerateResourceMSBuildRuntime>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_NativeLibraryPrefix Condition="'$(_NativeLibraryPrefix)' == '' and !$(RuntimeIdentifier.StartsWith('win'))">lib</_NativeLibraryPrefix>
    <_NativeLibraryExtension Condition="'$(_NativeLibraryExtension)' == '' and $(RuntimeIdentifier.StartsWith('win'))">.dll</_NativeLibraryExtension>
    <_NativeLibraryExtension Condition="'$(_NativeLibraryExtension)' == '' and $(RuntimeIdentifier.StartsWith('osx'))">.dylib</_NativeLibraryExtension>
    <_NativeLibraryExtension Condition="'$(_NativeLibraryExtension)' == ''">.so</_NativeLibraryExtension>
    <_NativeExecutableExtension Condition="'$(_NativeExecutableExtension)' == '' and ($(RuntimeIdentifier.StartsWith('win')) or $(DefaultAppHostRuntimeIdentifier.StartsWith('win')))">.exe</_NativeExecutableExtension>
    <_ComHostLibraryExtension Condition="'$(_ComHostLibraryExtension)' == '' and ($(RuntimeIdentifier.StartsWith('win')) or $(DefaultAppHostRuntimeIdentifier.StartsWith('win')))">.dll</_ComHostLibraryExtension>
    <_IjwHostLibraryExtension Condition="'$(_IjwHostLibraryExtension)' == '' and ($(RuntimeIdentifier.StartsWith('win')) or $(DefaultAppHostRuntimeIdentifier.StartsWith('win')))">.dll</_IjwHostLibraryExtension>
    <_DotNetHostExecutableName>dotnet$(_NativeExecutableExtension)</_DotNetHostExecutableName>
    <_DotNetAppHostExecutableNameWithoutExtension>apphost</_DotNetAppHostExecutableNameWithoutExtension>
    <_DotNetAppHostExecutableName>$(_DotNetAppHostExecutableNameWithoutExtension)$(_NativeExecutableExtension)</_DotNetAppHostExecutableName>
    <_DotNetSingleFileHostExecutableNameWithoutExtension>singlefilehost</_DotNetSingleFileHostExecutableNameWithoutExtension>
    <_DotNetComHostLibraryNameWithoutExtension>comhost</_DotNetComHostLibraryNameWithoutExtension>
    <_DotNetComHostLibraryName>$(_DotNetComHostLibraryNameWithoutExtension)$(_ComHostLibraryExtension)</_DotNetComHostLibraryName>
    <_DotNetIjwHostLibraryNameWithoutExtension>Ijwhost</_DotNetIjwHostLibraryNameWithoutExtension>
    <_DotNetIjwHostLibraryName>$(_DotNetIjwHostLibraryNameWithoutExtension)$(_IjwHostLibraryExtension)</_DotNetIjwHostLibraryName>
    <_DotNetHostPolicyLibraryName>$(_NativeLibraryPrefix)hostpolicy$(_NativeLibraryExtension)</_DotNetHostPolicyLibraryName>
    <_DotNetHostFxrLibraryName>$(_NativeLibraryPrefix)hostfxr$(_NativeLibraryExtension)</_DotNetHostFxrLibraryName>
  </PropertyGroup>
  <Target Name="_ComputePackageReferencePublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- PrivateAssets="All" means exclude from publish, unless Publish metadata is specified separately -->
      <PackageReference Publish="false" Condition="('%(PackageReference.PrivateAssets)' == 'All') And ('%(PackageReference.Publish)' == '')" />
      <_ExcludeFromPublishPackageReference Include="@(PackageReference)" Condition="('%(PackageReference.Publish)' == 'false')" />
    </ItemGroup>
  </Target>
  <!--
  ============================================================
                           _DefaultMicrosoftNETPlatformLibrary

  .NET Core apps can have shared frameworks that are pre-installed on the target machine, thus the app is "portable"
  to any machine that already has the shared framework installed. For .NET Core 1.x and 2.x, a "platform" library
  is declared. The platform library and its dependencies will be excluded from the publish output.

  For .NET Core 3 and up, targeting packs and runtime packs are used for shared framework assets instead of PackageReference
  ============================================================
  -->
  <Target Name="_DefaultMicrosoftNETPlatformLibrary" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Condition="'$(MicrosoftNETPlatformLibrary)' == ''">
      <MicrosoftNETPlatformLibrary Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(_TargetFrameworkVersionWithoutV)' &lt; '3.0'">Microsoft.NETCore.App</MicrosoftNETPlatformLibrary>
    </PropertyGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_DefaultUserProfileRuntimeStorePath>$(HOME)</_DefaultUserProfileRuntimeStorePath>
    <_DefaultUserProfileRuntimeStorePath Condition="$([MSBuild]::IsOSPlatform(`Windows`))">$(USERPROFILE)</_DefaultUserProfileRuntimeStorePath>
    <_DefaultUserProfileRuntimeStorePath>$([System.IO.Path]::Combine($(_DefaultUserProfileRuntimeStorePath), '.dotnet', 'store'))</_DefaultUserProfileRuntimeStorePath>
    <UserProfileRuntimeStorePath Condition="'$(UserProfileRuntimeStorePath)' == ''">$(_DefaultUserProfileRuntimeStorePath)</UserProfileRuntimeStorePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PredefinedCulturesOnly Condition="'$(PredefinedCulturesOnly)' == '' and '$(InvariantGlobalization)' == 'true'">true</PredefinedCulturesOnly>
  </PropertyGroup>
  <PropertyGroup Condition="'$(GenerateResourceWarnOnBinaryFormatterUse)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '8.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateResourceWarnOnBinaryFormatterUse>true</GenerateResourceWarnOnBinaryFormatterUse>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RespectAlreadyAssignedItemCulture)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '9.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RespectAlreadyAssignedItemCulture>true</RespectAlreadyAssignedItemCulture>
  </PropertyGroup>
  <!-- Set the IsRidAgnostic property if this project should NOT accept global RuntimeIdentifier and SelfContained
       property values from referencing projects. -->
  <PropertyGroup Condition="'$(IsRidAgnostic)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- It's preferred to read IsTestingPlatformApplication in an actual MSBuild target and not in evaluation, but it's best we can do here -->
    <!-- NOTE: A VSTest non-MTP test project will have IsTestProject=true AND IsTestingPlatformApplication!=true -->
    <!-- We want to make VSTest non-MTP test project to be rid agnostic because it doesn't really produce a runnable executable -->
    <IsRidAgnostic Condition="('$(_IsExecutable)' == 'true' And ('$(IsTestProject)' != 'true' Or '$(IsTestingPlatformApplication)' == 'true')) Or&#xA;                              '$(RuntimeIdentifier)' != '' Or&#xA;                              '$(RuntimeIdentifiers)' != ''">false</IsRidAgnostic>
    <IsRidAgnostic Condition="'$(IsRidAgnostic)' == ''">true</IsRidAgnostic>
  </PropertyGroup>
  <!-- Opt into .NET Core resource-serialization strategy by default when targeting frameworks
       that support it by default.
       -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateResourceUsePreserializedResources Condition="'$(GenerateResourceUsePreserializedResources)' == '' and&#xA;                 ('$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0')">true</GenerateResourceUsePreserializedResources>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <EmbeddedResourceUseDependentUponConvention Condition="'$(EmbeddedResourceUseDependentUponConvention)' == '' and&#xA;                 (('$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0') or&#xA;                  ('$(TargetFrameworkIdentifier)' == '.NETStandard' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '2.1'))">true</EmbeddedResourceUseDependentUponConvention>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '2.1'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AvailablePlatforms>$(AvailablePlatforms),ARM32</AvailablePlatforms>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '3.1'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AvailablePlatforms>$(AvailablePlatforms),ARM64</AvailablePlatforms>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '4.8.1'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AvailablePlatforms>$(AvailablePlatforms),ARM64</AvailablePlatforms>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Turn off support for metadata updates in non-Debug builds by default. -->
    <MetadataUpdaterSupport Condition="'$(MetadataUpdaterSupport)' == '' and '$(Configuration)' != 'Debug'">false</MetadataUpdaterSupport>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Turn on IncludeProjectsNotInAssetsFileInDepsFile by default. -->
    <IncludeProjectsNotInAssetsFileInDepsFile Condition="'$(IncludeProjectsNotInAssetsFileInDepsFile)' == ''">true</IncludeProjectsNotInAssetsFileInDepsFile>
  </PropertyGroup>
  <!--
    BinaryFormatter Disabling
    ===========================

    The EnableUnsafeBinaryFormatterSerialization setting controls both runtime and compile-time behavior.
    The behavior is slightly different depending on the project type and target runtime.

    If the property is explicitly set to TRUE:
      - The APIs are obsolete as warning, and calls to the APIs will succeed at runtime.

    If the property is explicitly set to FALSE:
      - On .NET 5 & 6, the APIs are obsolete as warning, and calls to the APIs will fail at runtime.
      - On .NET 7+, the APIs are obsolete as error, and calls to the APIs will fail at runtime.

    If the property is not explicitly TRUE or FALSE:
      - On .NET 5 & 6, the APIs are obsolete as warning, and calls to the APIs will succeed at runtime.
      - On .NET 7, the APIs are obsolete as error, but calls to the APIs will succeed at runtime.
      - On .NET 8+, the APIs are obsolete as error, and calls to the APIs will fail at runtime
        unless the SDK has opted in to keeping legacy BinaryFormatter behavior around.

    n.b. The APIs are already marked obsolete (as warning) in .NET 5, so we don't need to special-case
    them unless we want to upgrade them to warn-as-error.
  -->
  <PropertyGroup Condition="'$(EnableUnsafeBinaryFormatterSerialization)' != 'true' AND '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '7.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      Certain project types need to re-enable BinaryFormatter by default; it will still be warn-as-error but will work at runtime.
      WinForms: enabled through 8.0 (but not after)
      WPF: enabled through 8.0 (but not after)
    -->
    <_ProjectTypeRequiresBinaryFormatter Condition="'$(UseWindowsForms)' == 'true' AND $([MSBuild]::VersionLessThanOrEquals($(TargetFrameworkVersion), '8.0'))">true</_ProjectTypeRequiresBinaryFormatter>
    <_ProjectTypeRequiresBinaryFormatter Condition="'$(UseWPF)' == 'true' AND $([MSBuild]::VersionLessThanOrEquals($(TargetFrameworkVersion), '8.0'))">true</_ProjectTypeRequiresBinaryFormatter>
    <!-- controls warn as error -->
    <_BinaryFormatterObsoleteAsError>true</_BinaryFormatterObsoleteAsError>
    <!-- controls runtime behavior (AppContext & trimming) -->
    <EnableUnsafeBinaryFormatterSerialization Condition="$([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '8.0')) AND '$(_ProjectTypeRequiresBinaryFormatter)' != 'true'">false</EnableUnsafeBinaryFormatterSerialization>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CoreBuildDependsOn>
      _CheckForBuildWithNoBuild;
      $(CoreBuildDependsOn);
      GenerateBuildDependencyFile;
      GenerateBuildRuntimeConfigurationFiles
    </CoreBuildDependsOn>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CoreCleanDependsOn>
      _SdkBeforeClean;
      $(CoreCleanDependsOn)
    </CoreCleanDependsOn>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RebuildDependsOn>
      _SdkBeforeRebuild;
      $(RebuildDependsOn)
    </RebuildDependsOn>
  </PropertyGroup>
  <!-- NOTE: Keep in sync with https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.tasks -->
  <!-- `Condition="Exists(...)` is needed because the package might not be yet downloaded during restore in VS
        and we do not want to fail the restore phase because of that. -->
  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly" AssemblyFile="$(RoslynTasksAssembly)" Condition="Exists('$(RoslynTasksAssembly)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Csc" AssemblyFile="$(RoslynTasksAssembly)" Condition="Exists('$(RoslynTasksAssembly)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc" AssemblyFile="$(RoslynTasksAssembly)" Condition="Exists('$(RoslynTasksAssembly)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <ItemGroup Condition="'$(_NeedToDownloadMicrosoftNetSdkCompilersToolsetPackage)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PackageDownload Include="Microsoft.Net.Sdk.Compilers.Toolset" Version="[$(NETCoreSdkVersion)]" />
  </ItemGroup>
  <Target Name="_CheckMicrosoftNetCompilersToolsetFrameworkPackageReference" Condition="'$(MSBuildRuntimeType)' == 'Full'" BeforeTargets="CollectPackageReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Users should not be setting Microsoft.Net.Compilers.Toolset.Framework directly.
         If they do, and BuildWithNetFrameworkHostedCompiler is also set, the former will override the latter.
         This makes it more explicit that that is not supported. -->
    <NETSdkWarning ResourceName="CannotDirectlyReferenceMicrosoftNetCompilersToolsetFramework" Condition="'@(PackageReference-&gt;AnyHaveMetadataValue('Identity', 'Microsoft.Net.Compilers.Toolset.Framework'))' == 'true'" />
  </Target>
  <Target Name="_CheckMicrosoftNetSdkCompilersToolsetPackageExists" Condition="'$(_NeedToDownloadMicrosoftNetSdkCompilersToolsetPackage)' == 'true' and '$(DesignTimeBuild)' != 'true'" BeforeTargets="CoreCompile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- If users did not run restore or it failed to download the Microsoft.Net.Sdk.Compilers.Toolset package
         (but they proceeded to build, e.g., in Visual Studio), display an error with suggestions how to fix the problem. -->
    <NETSdkError ResourceName="MicrosoftNetSdkCompilersToolsetNotFound" Condition="'$(_MicrosoftNetSdkCompilersToolsetPackageRootEmpty)' != 'true' and !Exists('$(RoslynTargetsPath)')" FormatArguments="$(NETCoreSdkVersion)" />
    <!-- Warn if $(NuGetPackageRoot) is empty. See https://github.com/dotnet/sdk/issues/43016.
         WPF temp projects are ignored (it's known their NuGetPackageRoot is empty and user cannot fix that anyway). -->
    <NETSdkWarning ResourceName="MicrosoftNetSdkCompilersToolsetRootEmpty" Condition="'$(_MicrosoftNetSdkCompilersToolsetPackageRootEmpty)' == 'true' and !($(MSBuildProjectFile.EndsWith('_wpftmp.csproj')) or $(MSBuildProjectFile.EndsWith('_wpftmp.vbproj')))" />
  </Target>
  <Target Name="_CheckForBuildWithNoBuild" Condition="'$(NoBuild)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError ResourceName="NoBuildRequested" />
  </Target>
  <!--
    ============================================================
                                        GenerateBuildDependencyFile
    Generates the $(project).deps.json file during Build
    ============================================================
    -->
  <Target Name="GenerateBuildDependencyFile" DependsOnTargets="_DefaultMicrosoftNETPlatformLibrary;&#xA;                            _HandlePackageFileConflicts;&#xA;                            _ComputeReferenceAssemblies;&#xA;                            _ComputeUserRuntimeAssemblies;&#xA;                            ResolveRuntimePackAssets;&#xA;                            _ComputePackageReferencePublish" BeforeTargets="CopyFilesToOutputDirectory" Condition="'$(GenerateDependencyFile)' == 'true'" Inputs="$(ProjectAssetsFile);$(ProjectAssetsCacheFile);$(MSBuildAllProjects)" Outputs="$(ProjectDepsFilePath)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Set a dummy Version if it hasn't been set by DefaultAssemblyInfo.targets -->
    <PropertyGroup Condition="'$(UsingNETSdkDefaults)' != 'true'">
      <Version Condition="'$(Version)' == ''">1.0.0</Version>
    </PropertyGroup>
    <ItemGroup>
      <ResolvedCompileFileDefinitions Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' == 'Reference'" />
      <NativeCopyLocalItems Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <ResourceCopyLocalItems Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <RuntimeCopyLocalItems Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <RuntimeTargetsCopyLocalItems Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <RuntimePackAsset Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
    </ItemGroup>
    <!-- Set valid RID platforms for runtime assets if targeting .NET 8+ and using the RID graph is not enabled. -->
    <ItemGroup Condition="$([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '8.0'))&#xA;        and @(RuntimeHostConfigurationOption-&gt;WithMetadataValue('Identity', 'System.Runtime.Loader.UseRidGraph')-&gt;WithMetadataValue('Value', 'true')-&gt;Count()) == 0&#xA;        and '@(_KnownRuntimeIdentifierPlatformsForTargetFramework)' != ''">
      <!-- Known RID platforms for all target frameworks comes from BundledVersions -->
      <_ValidRuntimeIdentifierPlatformsForAssets Include="@(_KnownRuntimeIdentiferPlatforms)" />
      <!-- Known RID platforms for current target framework comes from ProcessFrameworkReferences output -->
      <_ValidRuntimeIdentifierPlatformsForAssets Include="@(_KnownRuntimeIdentifierPlatformsForTargetFramework)" Exclude="@(_ExcludedKnownRuntimeIdentiferPlatforms)" />
    </ItemGroup>
    <GenerateDepsFile ProjectPath="$(MSBuildProjectFullPath)" AssetsFilePath="$(ProjectAssetsFile)" DepsFilePath="$(ProjectDepsFilePath)" TargetFramework="$(TargetFramework)" AssemblyName="$(AssemblyName)" AssemblyExtension="$(TargetExt)" AssemblyVersion="$(Version)" AssemblySatelliteAssemblies="@(IntermediateSatelliteAssembliesWithTargetPath)" ReferencePaths="@(ReferencePath)" ReferenceDependencyPaths="@(ReferenceDependencyPaths)" ReferenceSatellitePaths="@(ReferenceSatellitePaths)" ReferenceAssemblies="@(_ReferenceAssemblies)" RuntimePackAssets="@(RuntimePackAsset)" IncludeMainProject="$(IncludeMainProjectInDepsFile)" TrimDepsJsonLibrariesWithoutAssets="$(TrimDepsJsonLibrariesWithoutAssets)" RuntimeIdentifier="$(RuntimeIdentifier)" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeFrameworks="@(RuntimeFramework)" CompilerOptions="@(DependencyFileCompilerOptions)" CompileReferences="@(ResolvedCompileFileDefinitions)" ResolvedNuGetFiles="@(NativeCopyLocalItems);@(ResourceCopyLocalItems);@(RuntimeCopyLocalItems)" UserRuntimeAssemblies="@(UserRuntimeAssembly)" ResolvedRuntimeTargetsFiles="@(RuntimeTargetsCopyLocalItems)" IsSelfContained="$(SelfContained)" IncludeRuntimeFileVersions="$(IncludeFileVersionsInDependencyFile)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" IncludeProjectsNotInAssetsFile="$(IncludeProjectsNotInAssetsFileInDepsFile)" ValidRuntimeIdentifierPlatformsForAssets="@(_ValidRuntimeIdentifierPlatformsForAssets)" />
    <ItemGroup>
      <!-- Do this in an ItemGroup instead of as an output parameter of the GenerateDepsFile task so that it still gets added to the item set
           during incremental builds when the task is skipped -->
      <FileWrites Include="$(ProjectDepsFilePath)" Condition="Exists('$(ProjectDepsFilePath)')" />
    </ItemGroup>
  </Target>
  <!-- To achieve incremental build with property change. When any property changes, WriteOnlyWhenDifferent will be triggered to write cache file.
  And the cache file's timestamp will be later, and it then triggers the incremental build.-->
  <Target Name="_GenerateRuntimeConfigurationFilesInputCache" DependsOnTargets="_DefaultMicrosoftNETPlatformLibrary" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <GenerateRuntimeConfigurationFilesInputs Include="$(_GenerateRuntimeConfigurationPropertyInputsCache)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="@(AdditionalProbingPath->'%(Identity)')" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(EnableDynamicLoading)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(RollForward)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="@(RuntimeHostConfigurationOption->'%(Identity)%(Value)')" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(RuntimeIdentifier)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(SelfContained)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(TargetFramework)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(UserRuntimeConfig)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(_WriteIncludedFrameworks)" />
    </ItemGroup>
    <Hash ItemsToHash="@(_GenerateRuntimeConfigurationPropertyInputsCacheToHash)">
      <Output TaskParameter="HashResult" PropertyName="_GenerateRuntimeConfigurationPropertyInputsCacheHash" />
    </Hash>
    <WriteLinesToFile Lines="$(_GenerateRuntimeConfigurationPropertyInputsCacheHash)" File="$(_GenerateRuntimeConfigurationPropertyInputsCache)" Overwrite="True" WriteOnlyWhenDifferent="True" />
    <ItemGroup>
      <FileWrites Include="$(_GenerateRuntimeConfigurationPropertyInputsCache)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateBuildRuntimeConfigurationFiles
    Generates the $(project).runtimeconfig.json and $(project).runtimeconfig.dev.json files during Build
    ============================================================
    -->
  <Target Name="GenerateBuildRuntimeConfigurationFiles" DependsOnTargets="_GenerateRuntimeConfigurationFilesInputCache" BeforeTargets="CopyFilesToOutputDirectory" Condition=" '$(GenerateRuntimeConfigurationFiles)' == 'true'" Inputs="@(GenerateRuntimeConfigurationFilesInputs)" Outputs="$(ProjectRuntimeConfigFilePath);$(ProjectRuntimeConfigDevFilePath)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_IsRollForwardSupported Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0'">true</_IsRollForwardSupported>
      <RollForward Condition="'$(RollForward)' == '' and '$(EnableDynamicLoading)' == 'true' and '$(_IsRollForwardSupported)' == 'true'">LatestMinor</RollForward>
    </PropertyGroup>
    <!-- RollForward is only supported since .NET Core 3.0, but we should allow limited usage when the app is targeting even lower versions
         This is to let 2.* apps specify that they are OK to run on 3.0 and above. So explicitly allow just Major and LatestMajor
         other values should still keep failing as they won't have any effect when run on 2.*. -->
    <NETSdkError Condition="'$(RollForward)' != '' and '$(RollForward)' != 'Major' and '$(RollForward)' != 'LatestMajor' and '$(_IsRollForwardSupported)' != 'true'" ResourceName="RollForwardRequiresVersion30" />
    <PropertyGroup>
      <_WriteIncludedFrameworks Condition="'$(SelfContained)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.1'">true</_WriteIncludedFrameworks>
    </PropertyGroup>
    <GenerateRuntimeConfigurationFiles AssetsFilePath="$(ProjectAssetsFile)" TargetFramework="$(TargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" RuntimeConfigPath="$(ProjectRuntimeConfigFilePath)" RuntimeConfigDevPath="$(ProjectRuntimeConfigDevFilePath)" RuntimeIdentifier="$(RuntimeIdentifier)" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeFrameworks="@(RuntimeFramework)" RollForward="$(RollForward)" UserRuntimeConfig="$(UserRuntimeConfig)" HostConfigurationOptions="@(RuntimeHostConfigurationOption)" AdditionalProbingPaths="@(AdditionalProbingPath)" IsSelfContained="$(SelfContained)" WriteIncludedFrameworks="$(_WriteIncludedFrameworks)" GenerateRuntimeConfigDevFile="$(GenerateRuntimeConfigDevFile)" AlwaysIncludeCoreFramework="$(AlwaysIncludeCoreFrameworkInRuntimeConfig)" />
    <ItemGroup>
      <!-- Do this in an ItemGroup instead of as an output parameter of the GenerateDepsFile task so that it still gets added to the item set
          during incremental builds when the task is skipped -->
      <FileWrites Include="$(ProjectRuntimeConfigFilePath)" Condition="Exists('$(ProjectRuntimeConfigFilePath)')" />
      <FileWrites Include="$(ProjectRuntimeConfigDevFilePath)" Condition="Exists('$(ProjectRuntimeConfigDevFilePath)')" />
    </ItemGroup>
  </Target>
  <!-- Add runtimeconfig.json file to BuiltProjectOutputGroupOutput, so that it will get included in the NuGet package by the Pack target -->
  <Target Name="AddRuntimeConfigFileToBuiltProjectOutputGroupOutput" Condition=" '$(GenerateRuntimeConfigurationFiles)' == 'true'" BeforeTargets="BuiltProjectOutputGroup" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <BuiltProjectOutputGroupOutput Include="$(ProjectRuntimeConfigFilePath)" TargetPath="$(ProjectRuntimeConfigFileName)" FinalOutputPath="$(ProjectRuntimeConfigFilePath)" />
    </ItemGroup>
  </Target>
  <Target Name="AddDepsJsonAndRuntimeConfigToCopyItemsForReferencingProjects" BeforeTargets="GetCopyToOutputDirectoryItems;_GetCopyToOutputDirectoryItemsFromThisProject" Condition="'$(HasRuntimeOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(GenerateDependencyFile)' == 'true'">
      <AllItemsFullPathWithTargetPath Include="$(ProjectDepsFilePath)" TargetPath="$([System.IO.Path]::GetFileName($(ProjectDepsFilePath)))" CopyToOutputDirectory="PreserveNewest" />
    </ItemGroup>
    <ItemGroup Condition=" '$(GenerateRuntimeConfigurationFiles)' == 'true'">
      <AllItemsFullPathWithTargetPath Include="$(ProjectRuntimeConfigFilePath)" TargetPath="$([System.IO.Path]::GetFileName($(ProjectRuntimeConfigFilePath)))" CopyToOutputDirectory="PreserveNewest" />
      <AllItemsFullPathWithTargetPath Include="$(ProjectRuntimeConfigDevFilePath)" TargetPath="$([System.IO.Path]::GetFileName($(ProjectRuntimeConfigDevFilePath)))" CopyToOutputDirectory="PreserveNewest" />
    </ItemGroup>
  </Target>
  <Target Name="AddDepsJsonAndRuntimeConfigToPublishItemsForReferencingProjects" DependsOnTargets="_ComputeUseBuildDependencyFile" BeforeTargets="GetCopyToPublishDirectoryItems" Condition="'$(HasRuntimeOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(GenerateDependencyFile)' == 'true'">
      <AllPublishItemsFullPathWithTargetPath Include="$(ProjectDepsFilePath)" TargetPath="$([System.IO.Path]::GetFileName($(ProjectDepsFilePath)))" CopyToPublishDirectory="PreserveNewest" Condition="'$(_UseBuildDependencyFile)' == 'true'" />
      <AllPublishItemsFullPathWithTargetPath Include="$(PublishDepsFilePath)" TargetPath="$([System.IO.Path]::GetFileName($(PublishDepsFilePath)))" CopyToPublishDirectory="PreserveNewest" Condition="'$(PublishDepsFilePath)' != '' and '$(_UseBuildDependencyFile)' != 'true'" />
    </ItemGroup>
    <ItemGroup Condition=" '$(GenerateRuntimeConfigurationFiles)' == 'true'">
      <AllPublishItemsFullPathWithTargetPath Include="$(ProjectRuntimeConfigFilePath)" TargetPath="$([System.IO.Path]::GetFileName($(ProjectRuntimeConfigFilePath)))" CopyToPublishDirectory="PreserveNewest" />
    </ItemGroup>
  </Target>
  <Target Name="_SdkBeforeClean" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Condition="'$(_CleaningWithoutRebuilding)' == ''">
      <_CleaningWithoutRebuilding>true</_CleaningWithoutRebuilding>
      <EmitAssetsLogMessages>false</EmitAssetsLogMessages>
    </PropertyGroup>
  </Target>
  <Target Name="_SdkBeforeRebuild" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_CleaningWithoutRebuilding>false</_CleaningWithoutRebuilding>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        DefaultRuntimeHostConfigurationOptions
    Defaults @(RuntimeHostConfigurationOption) items based on MSBuild properties.
    ============================================================
    -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RuntimeHostConfigurationOption Include="Microsoft.Extensions.DependencyInjection.VerifyOpenGenericServiceTrimmability" Condition="'$(VerifyDependencyInjectionOpenGenericServiceTrimmability)' != ''" Value="$(VerifyDependencyInjectionOpenGenericServiceTrimmability)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.AggressiveAttributeTrimming" Condition="'$(_AggressiveAttributeTrimming)' != ''" Value="$(_AggressiveAttributeTrimming)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.ComponentModel.DefaultValueAttribute.IsSupported" Condition="'$(_DefaultValueAttributeSupport)' != ''" Value="$(_DefaultValueAttributeSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.ComponentModel.Design.IDesignerHost.IsSupported" Condition="'$(_DesignerHostSupport)' != ''" Value="$(_DesignerHostSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.ComponentModel.TypeConverter.EnableUnsafeBinaryFormatterInDesigntimeLicenseContextSerialization" Condition="'$(EnableUnsafeBinaryFormatterInDesigntimeLicenseContextSerialization)' != ''" Value="$(EnableUnsafeBinaryFormatterInDesigntimeLicenseContextSerialization)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.ComponentModel.TypeDescriptor.IsComObjectDescriptorSupported" Condition="'$(_ComObjectDescriptorSupport)' != ''" Value="$(_ComObjectDescriptorSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Data.DataSet.XmlSerializationIsSupported" Condition="'$(_DataSetXmlSerializationSupport)' != ''" Value="$(_DataSetXmlSerializationSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Diagnostics.Debugger.IsSupported" Condition="'$(DebuggerSupport)' != ''" Value="$(DebuggerSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Diagnostics.Metrics.Meter.IsSupported" Condition="'$(MetricsSupport)' != ''" Value="$(MetricsSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Diagnostics.StackTrace.IsSupported" Condition="'$(StackTraceSupport)' != ''" Value="$(StackTraceSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Diagnostics.Tracing.EventSource.IsSupported" Condition="'$(EventSourceSupport)' != ''" Value="$(EventSourceSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Drawing.Design.UITypeEditor.IsSupported" Condition="'$(_WinFormsUITypeEditorSupport)' != ''" Value="$(_WinFormsUITypeEditorSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.GC.Concurrent" Condition="'$(ConcurrentGarbageCollection)' != ''" Value="$(ConcurrentGarbageCollection)" />
    <RuntimeHostConfigurationOption Include="System.GC.Server" Condition="'$(ServerGarbageCollection)' != ''" Value="$(ServerGarbageCollection)" />
    <RuntimeHostConfigurationOption Include="System.GC.DynamicAdaptationMode" Condition="'$(GarbageCollectionAdaptationMode)' != ''" Value="$(GarbageCollectionAdaptationMode)" />
    <RuntimeHostConfigurationOption Include="System.GC.RetainVM" Condition="'$(RetainVMGarbageCollection)' != ''" Value="$(RetainVMGarbageCollection)" />
    <RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Condition="'$(InvariantGlobalization)' != ''" Value="$(InvariantGlobalization)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.TimeZoneInfo.Invariant" Condition="'$(InvariantTimezone)' != ''" Value="$(InvariantTimezone)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Globalization.Hybrid" Condition="'$(HybridGlobalization)' != ''" Value="$(HybridGlobalization)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Globalization.PredefinedCulturesOnly" Condition="'$(PredefinedCulturesOnly)' != ''" Value="$(PredefinedCulturesOnly)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Linq.Enumerable.IsSizeOptimized" Condition="'$(UseSizeOptimizedLinq)' != ''" Value="$(UseSizeOptimizedLinq)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Net.Http.EnableActivityPropagation" Condition="'$(HttpActivityPropagationSupport)' != ''" Value="$(HttpActivityPropagationSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Net.Http.UseNativeHttpHandler" Condition="'$(UseNativeHttpHandler)' != ''" Value="$(UseNativeHttpHandler)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Net.Http.WasmEnableStreamingResponse" Condition="'$(WasmEnableStreamingResponse)' != ''" Value="$(WasmEnableStreamingResponse)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Net.Security.UseManagedNtlm" Condition="'$(_UseManagedNtlm)' != ''" Value="$(_UseManagedNtlm)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Net.SocketsHttpHandler.Http3Support" Condition="'$(Http3Support)' != ''" Value="$(Http3Support)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Reflection.Metadata.MetadataUpdater.IsSupported" Condition="'$(MetadataUpdaterSupport)' != ''" Value="$(MetadataUpdaterSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Reflection.NullabilityInfoContext.IsSupported" Condition="'$(NullabilityInfoContextSupport)' != ''" Value="$(NullabilityInfoContextSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Resources.ResourceManager.AllowCustomResourceTypes" Condition="'$(CustomResourceTypesSupport)' != ''" Value="$(CustomResourceTypesSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Resources.UseSystemResourceKeys" Condition="'$(UseSystemResourceKeys)' != ''" Value="$(UseSystemResourceKeys)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.CompilerServices.RuntimeFeature.IsDynamicCodeSupported" Condition="'$(DynamicCodeSupport)' != ''" Value="$(DynamicCodeSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.InteropServices.BuiltInComInterop.IsSupported" Condition="'$(BuiltInComInteropSupport)' != ''" Value="$(BuiltInComInteropSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.InteropServices.EnableConsumingManagedCodeFromNativeHosting" Condition="'$(_EnableConsumingManagedCodeFromNativeHosting)' != ''" Value="$(_EnableConsumingManagedCodeFromNativeHosting)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.InteropServices.EnableCppCLIHostActivation" Condition="'$(EnableCppCLIHostActivation)' != ''" Value="$(EnableCppCLIHostActivation)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.InteropServices.Marshalling.EnableGeneratedComInterfaceComImportInterop" Condition="'$(EnableGeneratedComInterfaceComImportInterop)' != ''" Value="$(EnableGeneratedComInterfaceComImportInterop)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization" Condition="'$(EnableUnsafeBinaryFormatterSerialization)' != ''" Value="$(EnableUnsafeBinaryFormatterSerialization)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.TieredCompilation" Condition="'$(TieredCompilation)' != ''" Value="$(TieredCompilation)" />
    <RuntimeHostConfigurationOption Include="System.Runtime.TieredCompilation.QuickJit" Condition="'$(TieredCompilationQuickJit)' != ''" Value="$(TieredCompilationQuickJit)" />
    <RuntimeHostConfigurationOption Include="System.Runtime.TieredCompilation.QuickJitForLoops" Condition="'$(TieredCompilationQuickJitForLoops)' != ''" Value="$(TieredCompilationQuickJitForLoops)" />
    <RuntimeHostConfigurationOption Include="System.Runtime.TieredPGO" Condition="'$(TieredPGO)' != ''" Value="$(TieredPGO)" />
    <RuntimeHostConfigurationOption Include="System.Runtime.Loader.UseRidGraph" Condition="'$(_UseRidGraphWasSpecified)' == 'true'" Value="$(UseRidGraph)" />
    <RuntimeHostConfigurationOption Include="System.StartupHookProvider.IsSupported" Condition="'$(StartupHookSupport)' != ''" Value="$(StartupHookSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Text.Encoding.EnableUnsafeUTF7Encoding" Condition="'$(EnableUnsafeUTF7Encoding)' != ''" Value="$(EnableUnsafeUTF7Encoding)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Text.Json.JsonSerializer.IsReflectionEnabledByDefault" Condition="'$(JsonSerializerIsReflectionEnabledByDefault)' != ''" Value="$(JsonSerializerIsReflectionEnabledByDefault)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Threading.Thread.EnableAutoreleasePool" Condition="'$(AutoreleasePoolSupport)' != ''" Value="$(AutoreleasePoolSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Threading.ThreadPool.MinThreads" Condition="'$(ThreadPoolMinThreads)' != ''" Value="$(ThreadPoolMinThreads)" />
    <RuntimeHostConfigurationOption Include="System.Threading.ThreadPool.MaxThreads" Condition="'$(ThreadPoolMaxThreads)' != ''" Value="$(ThreadPoolMaxThreads)" />
    <RuntimeHostConfigurationOption Include="System.Threading.ThreadPool.UnfairSemaphoreSpinLimit" Condition="'$(ThreadPoolSpinCount)' != ''" Value="$(ThreadPoolSpinCount)" />
    <RuntimeHostConfigurationOption Include="System.Threading.ThreadPool.UseWindowsThreadPool" Condition="'$(UseWindowsThreadPool)' != ''" Value="$(UseWindowsThreadPool)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.ActiveXImpl.IsSupported" Condition="'$(_ActiveXImplSupport)' != ''" Value="$(_ActiveXImplSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.Binding.IsSupported" Condition="'$(_WinFormsBindingSupport)' != ''" Value="$(_WinFormsBindingSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.Control.AreDesignTimeFeaturesSupported" Condition="'$(_WinFormsDesignTimeFeaturesSupport)' != ''" Value="$(_WinFormsDesignTimeFeaturesSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.Control.UseComponentModelRegisteredTypes" Condition="'$(_UseComponentModelRegisteredTypes)' != ''" Value="$(_UseComponentModelRegisteredTypes)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.ImageIndexConverter.IsSupported" Condition="'$(_WinFormsImageIndexConverterSupport)' != ''" Value="$(_WinFormsImageIndexConverterSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.MdiWindowDialog.IsSupported" Condition="'$(_MdiWindowDialogSupport)' != ''" Value="$(_MdiWindowDialogSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.Primitives.TypeConverterHelper.UseComponentModelRegisteredTypes" Condition="'$(_UseComponentModelRegisteredTypes)' != ''" Value="$(_UseComponentModelRegisteredTypes)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Xml.XmlResolver.IsNetworkingEnabledByDefault" Condition="'$(XmlResolverIsNetworkingEnabledByDefault)' != ''" Value="$(XmlResolverIsNetworkingEnabledByDefault)" Trim="true" />
  </ItemGroup>
  <!--
    ============================================================
                                        DefaultAdditionalProbingPaths
    Adds the default @(AdditionalProbingPath) items.
    ============================================================
    -->
  <ItemGroup Condition="'$(GenerateRuntimeConfigurationFiles)' == 'true' and '$(SkipDefaultAdditionalProbingPaths)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Note: can't use Path.Combine here since `|` is an illegal path character -->
    <AdditionalProbingPath Include="$(UserProfileRuntimeStorePath)$([System.IO.Path]::DirectorySeparatorChar)|arch|$([System.IO.Path]::DirectorySeparatorChar)|tfm|" />
  </ItemGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CompileDependsOn>
      $(CompileDependsOn);
      _CreateAppHost;
      _CreateComHost;
      _GetIjwHostPaths;
    </CompileDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                _GetAppHostCreationConfiguration
    Computes the properties for configuration of apphost creation
    during either build or publish
    ============================================================
     -->
  <Target Name="_GetAppHostCreationConfiguration" Condition="'$(UseAppHost)' == 'true' and '$(_IsExecutable)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_UseWindowsGraphicalUserInterface Condition="($(RuntimeIdentifier.StartsWith('win')) or $(DefaultAppHostRuntimeIdentifier.StartsWith('win'))) and '$(OutputType)'=='WinExe'">true</_UseWindowsGraphicalUserInterface>
      <_EnableMacOSCodeSign Condition="'$(_EnableMacOSCodeSign)' == '' and&#xA;                                      ($(RuntimeIdentifier.StartsWith('osx')) or $(AppHostRuntimeIdentifier.StartsWith('osx')))">true</_EnableMacOSCodeSign>
      <_UseSingleFileHostForPublish Condition="'$(PublishSingleFile)' == 'true' and&#xA;                                               '$(SelfContained)' == 'true' and&#xA;                                               '$(SingleFileHostSourcePath)' != '' and&#xA;                                               '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and&#xA;                                               $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0))">true</_UseSingleFileHostForPublish>
      <_DisableCetCompat Condition="'$(CetCompat)' == 'false'">true</_DisableCetCompat>
      <!-- Default to AppHostDotNetSearch=AppRelative if AppHostRelativeDotNet is set -->
      <AppHostDotNetSearch Condition="'$(AppHostRelativeDotNet)' != '' and '$(AppHostDotNetSearch)' == ''">AppRelative</AppHostDotNetSearch>
      <_UpdateAppHostForPublish Condition="'$(_UseSingleFileHostForPublish)' != 'true' and&#xA;                                          ('$(AppHostRelativeDotNet)' != '' or '$(AppHostDotNetSearch)' != '')">true</_UpdateAppHostForPublish>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _CreateAppHost
    If we found a restored apphost, create the modified destination apphost
    with options from the project.
    ============================================================
     -->
  <UsingTask TaskName="CreateAppHost" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_CreateAppHost" Inputs="@(IntermediateAssembly);$(AppHostSourcePath)" Outputs="$(AppHostIntermediatePath)" DependsOnTargets="_GetAppHostPaths;_GetAppHostCreationConfiguration;CoreCompile" Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true' and&#xA;                     '$(AppHostSourcePath)' != '' and&#xA;                     Exists('@(IntermediateAssembly)') and&#xA;                     Exists('$(AppHostSourcePath)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CreateAppHost AppHostSourcePath="$(AppHostSourcePath)" AppHostDestinationPath="$(AppHostIntermediatePath)" AppBinaryName="$(AssemblyName)$(TargetExt)" IntermediateAssembly="@(IntermediateAssembly->'%(FullPath)')" WindowsGraphicalUserInterface="$(_UseWindowsGraphicalUserInterface)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" EnableMacOSCodeSign="$(_EnableMacOSCodeSign)" DisableCetCompat="$(_DisableCetCompat)" />
  </Target>
  <!--
    ============================================================
                                        _GetAppHostPaths
    Gets the path to apphost (restored via packages or in an apphost pack),
    and computes the path for the destination apphost.
    ============================================================
     -->
  <Target Name="_GetAppHostPaths" DependsOnTargets="ResolvePackageAssets;ResolveFrameworkReferences" Condition="'$(UseAppHost)' == 'true' and '$(_IsExecutable)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'@(_NativeRestoredAppHostNETCore-&gt;Count())' &gt; 1" ResourceName="MultipleFilesResolved" FormatArguments="$(_DotNetAppHostExecutableName)" />
    <PropertyGroup>
      <!-- AppHostSourcePath will be set from ProcessFrameworkReferences if not using the apphost from the assets file -->
      <AppHostSourcePath Condition="'$(UseAppHostFromAssetsFile)' == 'true'">@(_NativeRestoredAppHostNETCore)</AppHostSourcePath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(UseAppHostFromAssetsFile)' == 'false' Or '@(_NativeRestoredAppHostNETCore)' != ''">
      <AppHostIntermediatePath>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)apphost$(_NativeExecutableExtension)'))</AppHostIntermediatePath>
      <AppHostForPublishIntermediatePath>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)apphost_publish$(_NativeExecutableExtension)'))</AppHostForPublishIntermediatePath>
      <SingleFileHostIntermediatePath>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)singlefilehost$(_NativeExecutableExtension)'))</SingleFileHostIntermediatePath>
    </PropertyGroup>
  </Target>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ClsidMap Include="$(IntermediateOutputPath)$(AssemblyName).clsidmap" />
    <RegFreeComManifest Include="$(IntermediateOutputPath)$(AssemblyName).X.manifest" />
  </ItemGroup>
  <!--
      ============================================================
                                        _GenerateClsidMap
    Generates a *.clsidmap file from the built assembly.
    ============================================================
  -->
  <UsingTask TaskName="GenerateClsidMap" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_GenerateClsidMap" Inputs="@(IntermediateAssembly)" Outputs="@(ClsidMap)" DependsOnTargets="CoreCompile" Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true' and&#xA;                     '$(EnableComHosting)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateClsidMap IntermediateAssembly="@(IntermediateAssembly->'%(FullPath)')" CLsidMapDestinationPath="@(ClsidMap->'%(FullPath)')" />
  </Target>
  <UsingTask TaskName="CreateComHost" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        _CreateComHost
    If we found a restored comhost, create the modified destination apphost
    with options from the project.
    ============================================================
     -->
  <Target Name="_CreateComHost" Inputs="@(IntermediateAssembly);$(ComHostSourcePath)" Outputs="$(ComHostIntermediatePath)" DependsOnTargets="_GetComHostPaths;CoreCompile;_GenerateClsidMap;_GenerateRegFreeComManifest" Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true' and&#xA;                     '$(ComHostIntermediatePath)' != '' and&#xA;                     Exists('@(IntermediateAssembly)') and&#xA;                     Exists('$(ComHostSourcePath)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CreateComHost ComHostSourcePath="$(ComHostSourcePath)" ComHostDestinationPath="$(ComHostIntermediatePath)" ClsidMapPath="@(ClsidMap)" TypeLibraries="@(ComHostTypeLibrary)" />
  </Target>
  <UsingTask TaskName="GenerateRegFreeComManifest" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        _GenerateRegFreeComManifest
    Gets the path to the restored comhost, and if the restored comhost
    was present, computes the path for the destination comhost.
    ============================================================
  -->
  <Target Name="_GenerateRegFreeComManifest" DependsOnTargets="_GenerateClsidMap;_GetComHostPaths" Inputs="@(ClsidMap);@(IntermediateAssembly)" Outputs="@(RegFreeComManifest)" Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true' and&#xA;                     '$(EnableComHosting)' == 'true' and&#xA;                     '$(EnableRegFreeCom)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateRegFreeComManifest IntermediateAssembly="@(IntermediateAssembly)" ComHostName="$(ComHostFileName)" ClsidMapPath="@(ClsidMap)" TypeLibraries="@(ComHostTypeLibrary)" ComManifestPath="@(RegFreeComManifest)" />
  </Target>
  <!--
    ============================================================
                                        _GetComHostPaths
    Gets the path to the restored comhost, and if the restored comhost
    was present, computes the path for the destination comhost.
    ============================================================
     -->
  <Target Name="_GetComHostPaths" DependsOnTargets="ResolvePackageAssets;ResolveFrameworkReferences" Condition="'$(EnableComHosting)' == 'true' and '$(_IsExecutable)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <ComHostFileName>$(AssemblyName).comhost$(_ComHostLibraryExtension)</ComHostFileName>
      <ComHostIntermediatePath>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)$(ComHostFileName)'))</ComHostIntermediatePath>
    </PropertyGroup>
    <NETSdkError Condition="'$(ComHostSourcePath)' == '' or !Exists('$(ComHostSourcePath)')" ResourceName="CannotFindComhost" />
  </Target>
  <!--
    ============================================================
                                        _GetIjwHostPaths
    Gets the path to the restored Ijwhost, and if the restored Ijwhost
    was present, Computes the path for the destination Ijwhost.
    ============================================================
     -->
  <Target Name="_GetIjwHostPaths" DependsOnTargets="ResolvePackageAssets;ResolveFrameworkReferences" Condition="'$(UseIJWHost)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(IjwHostSourcePath)' == '' or !Exists('$(IjwHostSourcePath)')" ResourceName="CannotFindIjwhost" />
  </Target>
  <!--
    ============================================================
                                        _ComputeNETCoreBuildOutputFiles
    Computes any files that need to be copied to the build output folder for .NET Core.
    ============================================================
    -->
  <Target Name="_ComputeNETCoreBuildOutputFiles" DependsOnTargets="_GetAppHostPaths;_GetAppHostCreationConfiguration;_GetComHostPaths;_GetIjwHostPaths" BeforeTargets="AssignTargetPaths" Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Fallback to renaming the dotnet host if there is no apphost for self-contained builds. -->
    <PropertyGroup Condition="'$(AppHostIntermediatePath)' == '' and '$(SelfContained)' == 'true'">
      <_CopyAndRenameDotnetHost Condition="'$(_CopyAndRenameDotnetHost)' == ''">true</_CopyAndRenameDotnetHost>
    </PropertyGroup>
    <ItemGroup Condition="'$(_CopyAndRenameDotnetHost)' == 'true'">
      <None Include="@(NativeCopyLocalItems)" Condition="'%(NativeCopyLocalItems.FileName)%(NativeCopyLocalItems.Extension)' == '$(_DotNetHostExecutableName)'">
        <Link>$(AssemblyName)$(_NativeExecutableExtension)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </None>
    </ItemGroup>
    <ItemGroup Condition="'$(AppHostIntermediatePath)' != '' or '$(_CopyAndRenameDotnetHost)' == 'true'">
      <!--
        If not copying local lock file assemblies, copy the host policy and host fxr libraries for self-contained builds.
        This is required to allow the host to activate in self-contained mode.
      -->
      <None Include="@(NativeCopyLocalItems)" Condition="'$(SelfContained)' == 'true' and&#xA;                       '$(CopyLocalLockFileAssemblies)' != 'true' and&#xA;                       ('%(NativeCopyLocalItems.FileName)%(NativeCopyLocalItems.Extension)' == '$(_DotNetHostPolicyLibraryName)' or&#xA;                        '%(NativeCopyLocalItems.FileName)%(NativeCopyLocalItems.Extension)' == '$(_DotNetHostFxrLibraryName)')">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>Never</CopyToPublishDirectory>
      </None>
    </ItemGroup>
    <ItemGroup Condition="'$(AppHostIntermediatePath)' != ''">
      <None Include="$(AppHostIntermediatePath)">
        <Link>$(AssemblyName)$(_NativeExecutableExtension)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <!-- Always copy the AppHost because the contents of the apphost binary can change during the publish step (due to single-file bundling).
             Always copying the apphost ensures that that the sequence
                 dotnet publish /p:PublishSingleFile=true
                 dotnet publish /p:PublishSingleFile=false
             places the correct unbundled apphost in the publish directory. -->
        <CopyToPublishDirectory>Always</CopyToPublishDirectory>
      </None>
    </ItemGroup>
    <ItemGroup Condition="'$(ComHostIntermediatePath)' != ''">
      <None Include="$(ComHostIntermediatePath)">
        <Link>$(AssemblyName).$(_DotNetComHostLibraryName)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </None>
      <None Include="@(RegFreeComManifest)" Condition="'$(EnableRegFreeCom)' == 'true'">
        <Link>%(FileName)%(Extension)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </None>
    </ItemGroup>
    <ItemGroup Condition="'$(IjwHostSourcePath)' != '' and '$(UseIJWHost)' == 'true'">
      <None Include="$(IjwHostSourcePath)">
        <Link>$(_DotNetIjwHostLibraryName)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </None>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _ComputeReferenceAssemblies
    Computes references that are only used at compile-time.
    ============================================================
    -->
  <Target Name="_ComputeReferenceAssemblies" DependsOnTargets="ResolveAssemblyReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_FrameworkReferenceAssemblies Include="@(ReferencePath)" Condition="(%(ReferencePath.FrameworkFile) == 'true' or&#xA;                                                %(ReferencePath.ResolvedFrom) == 'ImplicitlyExpandDesignTimeFacades')&#xA;                                            and ('%(ReferencePath.NuGetSourceType)' == ''  or&#xA;                                                 '%(ReferencePath.NuGetIsFrameworkReference)' == 'true')" />
      <!--
      "ReferenceOnly" assemblies are assemblies that are only used at compile-time, and they can't be resolved
      by the normal compile-assembly resolvers at runtime:
      1. App local
      2. NuGet/Package layout
      3. ProgramFiles\Reference Assemblies
      These assemblies need to be copied to the 'refs' folder for both build and publish.
      -->
      <_ReferenceOnlyAssemblies Include="@(ReferencePath)" Exclude="@(_FrameworkReferenceAssemblies)" Condition="%(ReferencePath.CopyLocal) != 'true' and&#xA;                                           %(ReferencePath.NuGetSourceType) == ''" />
      <_ReferenceAssemblies Include="@(_FrameworkReferenceAssemblies)" />
      <_ReferenceAssemblies Include="@(_ReferenceOnlyAssemblies)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _ComputeUserRuntimeAssemblies
    Computes references or reference dependencies that are copy local.
     NOTE: NuGet and framework references are never copy local so those are not included here.
           These will be project references and direct references and their copy local dependencies.
    ============================================================
    -->
  <Target Name="_ComputeUserRuntimeAssemblies" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- IncludeRuntimeDependency=true metadata is escape hatch to include a non-copy local reference in deps file as a runtime dependency -->
      <ReferencePath>
        <IncludeRuntimeDependency Condition="'%(ReferencePath.IncludeRuntimeDependency)' == '' and '%(ReferencePath.CopyLocal)' == 'true'">true</IncludeRuntimeDependency>
      </ReferencePath>
      <ReferenceDependencyPaths>
        <IncludeRuntimeDependency Condition="'%(ReferenceDependencyPaths.IncludeRuntimeDependency)' == '' and '%(ReferenceDependencyPaths.CopyLocal)' == 'true'">true</IncludeRuntimeDependency>
      </ReferenceDependencyPaths>
      <UserRuntimeAssembly Include="@(ReferencePath-&gt;WithMetadataValue('IncludeRuntimeDependency', 'true'))" />
      <UserRuntimeAssembly Include="@(ReferenceDependencyPaths-&gt;WithMetadataValue('IncludeRuntimeDependency', 'true'))" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                    CoreGenerateSatelliteAssemblies
    ============================================================
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CreateSatelliteAssembliesDependsOn>
      $(CreateSatelliteAssembliesDependsOn);
      CoreGenerateSatelliteAssemblies
    </CreateSatelliteAssembliesDependsOn>
  </PropertyGroup>
  <UsingTask TaskName="GetAssemblyAttributes" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="CoreGenerateSatelliteAssemblies" DependsOnTargets="ResolveAssemblyReferences;_GetAssemblyInfoFromTemplateFile" Inputs="$(MSBuildAllProjects);@(_SatelliteAssemblyResourceInputs);$(IntermediateOutputPath)$(TargetName)$(TargetExt)" Outputs="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll" Condition="'@(_SatelliteAssemblyResourceInputs)' != ''  and '$(GenerateSatelliteAssembliesForCore)' == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MakeDir Directories="@(_SatelliteAssemblyResourceInputs->'$(IntermediateOutputPath)%(Culture)')" />
    <PropertyGroup>
      <_AssemblyInfoFile>$(IntermediateOutputPath)%(_SatelliteAssemblyResourceInputs.Culture)\$(TargetName).resources.cs</_AssemblyInfoFile>
      <_OutputAssembly>$(IntermediateOutputPath)%(_SatelliteAssemblyResourceInputs.Culture)\$(TargetName).resources.dll</_OutputAssembly>
    </PropertyGroup>
    <ItemGroup>
      <SatelliteAssemblyAttribute Include="System.Reflection.AssemblyCultureAttribute" Condition="'%(_SatelliteAssemblyResourceInputs.Culture)' != ''">
        <_Parameter1>%(_SatelliteAssemblyResourceInputs.Culture)</_Parameter1>
      </SatelliteAssemblyAttribute>
    </ItemGroup>
    <WriteCodeFragment AssemblyAttributes="@(SatelliteAssemblyAttribute)" Language="C#" OutputFile="$(_AssemblyInfoFile)">
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </WriteCodeFragment>
    <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
      <UseSharedCompilation>true</UseSharedCompilation>
    </PropertyGroup>
    <ItemGroup>
      <_SatelliteAssemblyReferences Remove="@(_SatelliteAssemblyReferences)" />
      <_SatelliteAssemblyReferences Include="@(ReferencePath)" Condition="'%(Filename)' == 'mscorlib' or '%(Filename)' == 'netstandard' or '%(Filename)' == 'System.Runtime' " />
    </ItemGroup>
    <Csc Resources="@(_SatelliteAssemblyResourceInputs)" Sources="$(_AssemblyInfoFile)" OutputAssembly="$(_OutputAssembly)" References="@(_SatelliteAssemblyReferences)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" NoConfig="true" NoLogo="$(NoLogo)" NoStandardLib="$(NoCompilerStandardLib)" Optimize="$(Optimize)" PublicSign="$(PublicSign)" PathMap="$(PathMap)" Features="$(Features)" DelaySign="$(DelaySign)" Deterministic="$(Deterministic)" DisabledWarnings="$(DisabledWarnings)" WarningLevel="$(WarningLevel)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" TargetType="Library" ToolExe="$(CscToolExe)" ToolPath="$(CscToolPath)" UseSharedCompilation="$(UseSharedCompilation)">
      <Output TaskParameter="OutputAssembly" ItemName="FileWrites" />
    </Csc>
  </Target>
  <Target Name="_GetAssemblyInfoFromTemplateFile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GetAssemblyAttributes PathToTemplateFile="$(IntermediateOutputPath)$(TargetName)$(TargetExt)">
      <Output TaskParameter="AssemblyAttributes" ItemName="_AssemblyAttributesFromTemplateFile" />
    </GetAssemblyAttributes>
    <ItemGroup>
      <SatelliteAssemblyAttribute Include="@(_AssemblyAttributesFromTemplateFile)" />
    </ItemGroup>
  </Target>
  <!--
  ============================================================
                                      GetAllRuntimeIdentifiers
  ============================================================
  -->
  <Target Name="GetAllRuntimeIdentifiers" Returns="$(RuntimeIdentifiers);$(RuntimeIdentifier)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
  ============================================================
               _BlockWinMDsOnUnsupportedTFMs
  Block referencing or producing
  Windows Metadata files (.winmd) for target frameworks
  that do not support loading winmds directly
  into the runtime as assemblies
  ============================================================
  -->
  <UsingTask TaskName="CheckForUnsupportedWinMDReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_BlockWinMDsOnUnsupportedTFMs" AfterTargets="PreBuildEvent" DependsOnTargets="ResolveReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '5.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CheckForUnsupportedWinMDReferences TargetFrameworkMoniker="$(TargetFrameworkMoniker)" ReferencePaths="@(ReferencePath)" />
    <NETSdkError Condition="'$(OutputType)' == 'winmdobj'" ResourceName="WinMDObjNotSupportedOnTargetFramework" FormatArguments="$(TargetFrameworkMoniker)" />
  </Target>
  <!--
  ============================================================
                                      InjectTargetPathMetadata
  Update TargetPathWithTargetPlatformMoniker with target framework
  identifier and version metadata.  This is so that the
  ImplicitlyExpandNETStandardFacades target can determine if a
  referenced project needs the .NET Standard facades even if
  the project hasn't been compiled to disk yet.
  See https://github.com/dotnet/sdk/issues/1403 for more context
  ============================================================
  -->
  <ItemDefinitionGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetPathWithTargetPlatformMoniker>
      <TargetFrameworkIdentifier>$(TargetFrameworkIdentifier)</TargetFrameworkIdentifier>
      <TargetFrameworkVersion>$(_TargetFrameworkVersionWithoutV)</TargetFrameworkVersion>
    </TargetPathWithTargetPlatformMoniker>
  </ItemDefinitionGroup>
  <!--
    ============================================================
                            GenerateSupportedTargetFrameworkAlias
    Generate a list of valid TargetFramework aliases for the project
    system to consume for the target framework properties page drop down
    ============================================================
  -->
  <UsingTask TaskName="GenerateSupportedTargetFrameworkAlias" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="GenerateSupportedTargetFrameworkAlias" Returns="@(SupportedTargetFrameworkAlias)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateSupportedTargetFrameworkAlias SupportedTargetFramework="@(SupportedTargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetPlatformMoniker="$(TargetPlatformMoniker)" UseWpf="$(UseWpf)" UseWindowsForms="$(UseWindowsForms)">
      <Output TaskParameter="SupportedTargetFrameworkAlias" ItemName="SupportedTargetFrameworkAlias" />
    </GenerateSupportedTargetFrameworkAlias>
  </Target>
  <!--
  ============================================================
  ValidateExecutableReferences
  ============================================================
  -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AdditionalTargetFrameworkInfoProperty Include="SelfContained" />
    <AdditionalTargetFrameworkInfoProperty Include="_IsExecutable" />
    <AdditionalTargetFrameworkInfoProperty Include="IsRidAgnostic" />
    <AdditionalTargetFrameworkInfoProperty Include="ShouldBeValidatedAsExecutableReference" />
    <AdditionalTargetFrameworkInfoProperty Include="_SelfContainedWasSpecified" />
  </ItemGroup>
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Don't generate a NETSDK1151 error if a non self-contained Exe references a Blazor wasm Exe -->
    <ShouldBeValidatedAsExecutableReference>false</ShouldBeValidatedAsExecutableReference>
  </PropertyGroup>
  <UsingTask TaskName="ValidateExecutableReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_UseAttributeForTargetFrameworkInfoPropertyNames Condition="$([MSBuild]::VersionGreaterThanOrEquals($(MSBuildVersion), '17.0'))">true</_UseAttributeForTargetFrameworkInfoPropertyNames>
  </PropertyGroup>
  <!-- GetTargetFrameworksWithPlatformForSingleTargetFramework uses AdditionalTargetFrameworkInfoProperty to populate _AdditionalTargetFrameworkInfoPropertyWithValue -->
  <!-- As we are modifying the value of ShouldBeValidatedAsExecutableReference here (which is part of AdditionalTargetFrameworkInfoProperty), we must run before GetTargetFrameworksWithPlatformForSingleTargetFramework -->
  <Target Name="_CalculateIsVSTestTestProject" BeforeTargets="GetTargetFrameworksWithPlatformForSingleTargetFramework" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_IsVSTestTestProject Condition="'$(IsTestProject)' == 'true' and '$(IsTestingPlatformApplication)' != 'true'">true</_IsVSTestTestProject>
      <_IsVSTestTestProject Condition="'$(_IsVSTestTestProject)' == ''">false</_IsVSTestTestProject>
      <!-- Don't generate an error if an Exe project references a test project. -->
      <ShouldBeValidatedAsExecutableReference Condition="'$(_IsVSTestTestProject)' == 'true'">false</ShouldBeValidatedAsExecutableReference>
      <!-- Don't generate an error if a test project references a self-contained Exe.  Test projects
            use an OutputType of Exe but will usually call APIs in a referenced Exe rather than try
            to run it. -->
      <ValidateExecutableReferencesMatchSelfContained Condition="'$(_IsVSTestTestProject)' == 'true' And '$(ValidateExecutableReferencesMatchSelfContained)' == ''">false</ValidateExecutableReferencesMatchSelfContained>
    </PropertyGroup>
  </Target>
  <Target Name="ValidateExecutableReferences" DependsOnTargets="_CalculateIsVSTestTestProject" AfterTargets="_GetProjectReferenceTargetFrameworkProperties" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ValidateExecutableReferences Condition="'$(ValidateExecutableReferencesMatchSelfContained)' != 'false'" SelfContained="$(SelfContained)" IsExecutable="$(_IsExecutable)" ReferencedProjects="@(_MSBuildProjectReferenceExistent)" UseAttributeForTargetFrameworkInfoPropertyNames="$(_UseAttributeForTargetFrameworkInfoPropertyNames)" />
  </Target>
  <!--
  ============================================================
  Command Line Configuration Validation
  ============================================================
  -->
  <Target Name="ValidateCommandLineProperties" AfterTargets="_CheckForInvalidConfigurationAndPlatform" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Currently a no-op, but we could put things here in the future, so keeping it. -->
  </Target>
  <!--
  ============================================================
                                         Project Capabilities
  ============================================================
  -->
  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_IsExecutable)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Include="CrossPlatformExecutable" />
  </ItemGroup>
  <!-- Native AOT compilation -->
  <!-- Native AOT properties should be shown by default for projects targeting .NET 8 or higher, except for WPF and WinForms projects -->
  <ItemGroup Condition="'$(UseWPF)' != 'true'&#xA;             and '$(UseWindowsForms)' != 'true'&#xA;             and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;             and $([MSBuild]::VersionGreaterThanOrEquals('$(_TargetFrameworkVersionWithoutV)', '8.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Include="NativeAOT" />
  </ItemGroup>
  <!-- Reference Manager capabilities -->
  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Remove="ReferenceManagerAssemblies" />
  </ItemGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.SourceLink.targets" Condition="'$(SuppressImplicitGitSourceLink)' != 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.SourceLink.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- C++ projects currently do not import Microsoft.NET.Sdk.props. -->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.SourceLink.props" Condition="'$(_SourceLinkPropsImported)' != 'true'" />-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Workaround for https://github.com/Microsoft/msbuild/issues/3294. -->
    <_SourceLinkSdkSubDir>build</_SourceLinkSdkSubDir>
    <_SourceLinkSdkSubDir Condition="'$(IsCrossTargetingBuild)' == 'true'">buildMultiTargeting</_SourceLinkSdkSubDir>
    <!-- Workaround for https://github.com/dotnet/sdk/issues/36585 (Desktop XAML targets do not produce correct #line directives) -->
    <EmbedUntrackedSources Condition="'$(EmbedUntrackedSources)' == '' and '$(ImportFrameworkWinFXTargets)' != 'true'">true</EmbedUntrackedSources>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.Build.Tasks.Git\build\Microsoft.Build.Tasks.Git.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.Build.Tasks.Git/build/Microsoft.Build.Tasks.Git.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <UsingTask TaskName="Microsoft.Build.Tasks.Git.LocateRepository" AssemblyFile="$(MicrosoftBuildTasksGitAssemblyFile)" />
  <UsingTask TaskName="Microsoft.Build.Tasks.Git.GetUntrackedFiles" AssemblyFile="$(MicrosoftBuildTasksGitAssemblyFile)" />
  <PropertyGroup>
    <!--
      Sets the scope of git repository configuration. By default (no scope specified) configuration is read from environment variables
      and system and global user git/ssh configuration files. 
      
      If "local" is specified the configuration is only read from the configuration files local to the repository (or work tree).
      In addition, any use of home relative paths in these configuration files (paths that start with '~/') is disallowed.
      
      By default, the scope is restricted to "local" when building in CI (ContinuousIntegrationBuild is true) to avoid introducing 
      dependencies on CI machine state into the build.
    -->
    <GitRepositoryConfigurationScope Condition="'$(GitRepositoryConfigurationScope)' == '' and '$(ContinuousIntegrationBuild)' == 'true'">local</GitRepositoryConfigurationScope>
  </PropertyGroup>
  <Target Name="InitializeSourceControlInformationFromSourceControlManager">
    <!--
      Reports a warning if the given project doesn't belong to a repository under source control,
      unless the targets were implicily imported from an SDK without a package reference.
    -->
    <Microsoft.Build.Tasks.Git.LocateRepository Path="$(MSBuildProjectDirectory)" RemoteName="$(GitRepositoryRemoteName)" ConfigurationScope="$(GitRepositoryConfigurationScope)" NoWarnOnMissingInfo="$(PkgMicrosoft_Build_Tasks_Git.Equals(''))">
      <Output TaskParameter="RepositoryId" PropertyName="_GitRepositoryId" />
      <Output TaskParameter="Url" PropertyName="ScmRepositoryUrl" />
      <Output TaskParameter="Roots" ItemName="SourceRoot" />
      <Output TaskParameter="RevisionId" PropertyName="SourceRevisionId" Condition="'$(SourceRevisionId)' == ''" />
      <Output TaskParameter="BranchName" PropertyName="SourceBranchName" />
    </Microsoft.Build.Tasks.Git.LocateRepository>
    <PropertyGroup>
      <RepositoryType Condition="'$(RepositoryType)' == ''">git</RepositoryType>
    </PropertyGroup>
  </Target>
  <!--
    Embed files to the PDB that either do not belong to any of the SourceRoot directories
    or belong to the source repository, but are explicitly ignored (excluded) from source control.
  -->
  <Target Name="SetEmbeddedFilesFromSourceControlManagerUntrackedFiles" DependsOnTargets="InitializeSourceControlInformationFromSourceControlManager">
    <Microsoft.Build.Tasks.Git.GetUntrackedFiles RepositoryId="$(_GitRepositoryId)" ConfigurationScope="$(GitRepositoryConfigurationScope)" ProjectDirectory="$(MSBuildProjectDirectory)" Files="@(Compile)" Condition="'$(_GitRepositoryId)' != ''">
      <Output TaskParameter="UntrackedFiles" ItemName="EmbeddedFiles" />
    </Microsoft.Build.Tasks.Git.GetUntrackedFiles>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.Common\$(_SourceLinkSdkSubDir)\Microsoft.SourceLink.Common.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.SourceLink.Common/build/Microsoft.SourceLink.Common.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <!--
============================================================================================================================================
  <Import Project="InitializeSourceControlInformation.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.SourceLink.Common/build/InitializeSourceControlInformation.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <UsingTask TaskName="Microsoft.SourceLink.Common.SourceLinkHasSingleProvider" AssemblyFile="$(_MicrosoftSourceLinkCommonAssemblyFile)" />
  <Target Name="_SourceLinkHasSingleProvider">
    <!--
      If there is a single SourceLink provider we can use Repository URL to infer repository host.
      If the project references multiple SourceLink providers the user needs to specify hosts explicitly (ImplicitHost will be empty)
      as we do not know which providers should be used to produce SourceLink URL for the repository.
      
      Reports an error if there is no SourceLinkUrlInitializerTargets is empty (no SourceLink provider is referenced).
    -->
    <Microsoft.SourceLink.Common.SourceLinkHasSingleProvider ProviderTargets="$(SourceLinkUrlInitializerTargets)">
      <Output TaskParameter="HasSingleProvider" PropertyName="SourceLinkHasSingleProvider" />
    </Microsoft.SourceLink.Common.SourceLinkHasSingleProvider>
  </Target>
  <!--
    Triggers InitializeSourceControlInformationFromSourceControlManager target defined by a source control package Microsoft.Build.Tasks.{Git|Tfvc|...}.
    
    Notes: No error is reported if InitializeSourceControlInformation is not defined.
  -->
  <Target Name="_InitializeSourceControlInformationFromSourceControlManager" DependsOnTargets="InitializeSourceControlInformationFromSourceControlManager;_SourceLinkHasSingleProvider;$(SourceControlManagerUrlTranslationTargets);SourceControlManagerPublishTranslatedUrls" BeforeTargets="InitializeSourceControlInformation" Condition="'$(EnableSourceControlManagerQueries)' == 'true'" />
  <Target Name="SourceControlManagerPublishTranslatedUrls">
    <PropertyGroup>
      <!--
        If the project already sets RepositoryUrl use it. Such URL is considered final and translations are not applied.
      -->
      <PrivateRepositoryUrl Condition="'$(PrivateRepositoryUrl)' == ''">$(RepositoryUrl)</PrivateRepositoryUrl>
      <PrivateRepositoryUrl Condition="'$(PrivateRepositoryUrl)' == ''">$(ScmRepositoryUrl)</PrivateRepositoryUrl>
    </PropertyGroup>
    <ItemGroup>
      <SourceRoot Update="@(SourceRoot)">
        <RepositoryUrl Condition="'%(SourceRoot.RepositoryUrl)' == ''">%(SourceRoot.ScmRepositoryUrl)</RepositoryUrl>
      </SourceRoot>
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.SourceLink.Common/build/Microsoft.SourceLink.Common.targets
============================================================================================================================================
-->
  <UsingTask TaskName="Microsoft.SourceLink.Common.GenerateSourceLinkFile" AssemblyFile="$(_MicrosoftSourceLinkCommonAssemblyFile)" />
  <Target Name="_SetSourceLinkFilePath">
    <PropertyGroup>
      <_SourceLinkFilePath>$(IntermediateOutputPath)$(MSBuildProjectName).sourcelink.json</_SourceLinkFilePath>
    </PropertyGroup>
  </Target>
  <!--
    Triggers SetEmbeddedFilesFromSourceControlManagerUntrackedFiles target defined by a source control package Microsoft.Build.Tasks.{Git|Tfvc|...}.
    Assumes that all targets that generate source files and add them to Compile items run before BeforeCompile target.
    This is a convention established by common targets.
    
    Disabled for design-time build since calculating untracked files is non-trivial operation
    and embedding them only affects the content of the generated PDB, which has no impact on design-time build.
  -->
  <Target Name="_SetEmbeddedFilesFromSourceControlManagerUntrackedFiles" DependsOnTargets="BeforeCompile;SetEmbeddedFilesFromSourceControlManagerUntrackedFiles" BeforeTargets="CoreCompile" Condition="'$(EmbedUntrackedSources)' == 'true' and '$(EmbedAllSources)' != 'true' and '$(DebugType)' != 'none' and '$(EnableSourceControlManagerQueries)' == 'true' and '$(DesignTimeBuild)' != 'true'" />
  <!--
    If defined populates MappedPath metadata of SourceRoot items.
  -->
  <Target Name="_InitializeSourceRootMappedPathsOpt" DependsOnTargets="InitializeSourceRootMappedPaths" Condition="'$(SourceRootMappedPathsFeatureSupported)' == 'true'" />
  <!-- 
    Add compiler targets: C++ generates PDB with SourceLink in Link phase.
  -->
  <PropertyGroup Condition="'$(Language)' == 'C++'">
    <_GenerateSourceLinkFileBeforeTargets>Link</_GenerateSourceLinkFileBeforeTargets>
    <_GenerateSourceLinkFileDependsOnTargets>ComputeLinkSwitches</_GenerateSourceLinkFileDependsOnTargets>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Language)' != 'C++'">
    <_GenerateSourceLinkFileBeforeTargets>CoreCompile</_GenerateSourceLinkFileBeforeTargets>
    <_GenerateSourceLinkFileDependsOnTargets />
  </PropertyGroup>
  <!--
    Each source control provider package adds its SourceLinkUrl initialization target to SourceLinkUrlInitializerTargets.
    This target shall initialize SourceLinkUrl of all items that don't have it initialized yet and belong to the source control provider.
  -->
  <Target Name="_GenerateSourceLinkFile" DependsOnTargets="_SetSourceLinkFilePath;$(_GenerateSourceLinkFileDependsOnTargets);_InitializeSourceRootMappedPathsOpt;$(SourceLinkUrlInitializerTargets)" Condition="'$(EnableSourceLink)' == 'true' and '$(DebugType)' != 'none'" Outputs="$(_SourceLinkFilePath)">
    <!--- Suppress warning if targets are imported from an SDK without a package reference. -->
    <Microsoft.SourceLink.Common.GenerateSourceLinkFile SourceRoots="@(SourceRoot)" NoWarnOnMissingSourceControlInformation="$(PkgMicrosoft_SourceLink_Common.Equals(''))" OutputFile="$(_SourceLinkFilePath)">
      <!-- Set SourceLink property passed to compilers -->
      <Output TaskParameter="SourceLink" PropertyName="SourceLink" />
    </Microsoft.SourceLink.Common.GenerateSourceLinkFile>
    <!--
      Include the output file whenever it exists, even if it hasn't been written to (it was up-to-date).
      This is needed so that incremental clean doesn't delete the file.
    -->
    <ItemGroup Condition="'$(SourceLink)' != ''">
      <FileWrites Include="$(SourceLink)" />
    </ItemGroup>
    <!-- C++ Link task currently doesn't recognize SourceLink property -->
    <ItemGroup Condition="'$(Language)' == 'C++' and '$(SourceLink)' != ''">
      <Link Update="@(Link)">
        <AdditionalOptions>%(Link.AdditionalOptions) /sourcelink:"$(SourceLink)"</AdditionalOptions>
      </Link>
    </ItemGroup>
  </Target>
  <Target Name="GenerateSourceLinkFile" DependsOnTargets="InitializeSourceControlInformation;_GenerateSourceLinkFile" Condition="'$(SourceControlInformationFeatureSupported)' == 'true'" BeforeTargets="$(_GenerateSourceLinkFileBeforeTargets)" />
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.GitHub\build\Microsoft.SourceLink.GitHub.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.SourceLink.GitHub/build/Microsoft.SourceLink.GitHub.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <PropertyGroup>
    <_SourceLinkGitHubAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\Microsoft.SourceLink.GitHub.dll</_SourceLinkGitHubAssemblyFile>
    <_SourceLinkGitHubAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\Microsoft.SourceLink.GitHub.dll</_SourceLinkGitHubAssemblyFile>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.SourceLink.GitHub.GetSourceLinkUrl" AssemblyFile="$(_SourceLinkGitHubAssemblyFile)" />
  <UsingTask TaskName="Microsoft.SourceLink.GitHub.TranslateRepositoryUrls" AssemblyFile="$(_SourceLinkGitHubAssemblyFile)" />
  <PropertyGroup>
    <SourceLinkUrlInitializerTargets>$(SourceLinkUrlInitializerTargets);_InitializeGitHubSourceLinkUrl</SourceLinkUrlInitializerTargets>
    <SourceControlManagerUrlTranslationTargets>$(SourceControlManagerUrlTranslationTargets);TranslateGitHubUrlsInSourceControlInformation</SourceControlManagerUrlTranslationTargets>
  </PropertyGroup>
  <Target Name="_InitializeGitHubSourceLinkUrl" Outputs="%(SourceRoot.Identity)">
    <!--
      The task calculates SourceLink URL for a given SourceRoot.

      If the SourceRoot is associated with a git repository with a recognized domain the <see cref="SourceLinkUrl"/>
      output property is set to the content URL corresponding to the domain, otherwise it is set to string "N/A".

      Recognized domains are specified via Hosts (initialized from SourceLinkGitHubHost item group).
      In addition, if SourceLinkHasSingleProvider is true an implicit host is parsed from RepositoryUrl.

      Example of SourceLinkGitHubHost items:

      <ItemGroup>
        <SourceLinkGitHubHost Include="github.com" ContentUrl="https://raw.githubusercontent.com"/>
        <SourceLinkGitHubHost Include="mygithub1.com" />           ContentUrl defaults to https://mygithub1.com/raw
        <SourceLinkGitHubHost Include="mygithub2.com:8080" />      ContentUrl defaults to https://mygithub2.com:8080/raw
      </ItemGroup>

      ContentUrl is optional. If not specified it defaults to "https://{domain}/raw".
    -->
    <Microsoft.SourceLink.GitHub.GetSourceLinkUrl RepositoryUrl="$(PrivateRepositoryUrl)" SourceRoot="@(SourceRoot)" Hosts="@(SourceLinkGitHubHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="SourceLinkUrl" PropertyName="_SourceLinkUrlToUpdate" />
    </Microsoft.SourceLink.GitHub.GetSourceLinkUrl>
    <ItemGroup>
      <!-- Only update the SourceLinkUrl metadata if the SourceRoot belongs to this source control -->
      <SourceRoot Update="%(Identity)" SourceLinkUrl="$(_SourceLinkUrlToUpdate)" Condition="'$(_SourceLinkUrlToUpdate)' != 'N/A'" />
    </ItemGroup>
  </Target>
  <!-- 
    We need to translate ssh URLs to https.
  -->
  <Target Name="TranslateGitHubUrlsInSourceControlInformation">
    <ItemGroup>
      <_TranslatedSourceRoot Remove="@(_TranslatedSourceRoot)" />
    </ItemGroup>
    <Microsoft.SourceLink.GitHub.TranslateRepositoryUrls RepositoryUrl="$(ScmRepositoryUrl)" SourceRoots="@(SourceRoot)" Hosts="@(SourceLinkGitHubHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="TranslatedRepositoryUrl" PropertyName="ScmRepositoryUrl" />
      <Output TaskParameter="TranslatedSourceRoots" ItemName="_TranslatedSourceRoot" />
    </Microsoft.SourceLink.GitHub.TranslateRepositoryUrls>
    <ItemGroup>
      <SourceRoot Remove="@(SourceRoot)" />
      <SourceRoot Include="@(_TranslatedSourceRoot)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.GitLab\build\Microsoft.SourceLink.GitLab.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.SourceLink.GitLab/build/Microsoft.SourceLink.GitLab.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <PropertyGroup>
    <_SourceLinkGitLabAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\Microsoft.SourceLink.GitLab.dll</_SourceLinkGitLabAssemblyFile>
    <_SourceLinkGitLabAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\Microsoft.SourceLink.GitLab.dll</_SourceLinkGitLabAssemblyFile>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.SourceLink.GitLab.GetSourceLinkUrl" AssemblyFile="$(_SourceLinkGitLabAssemblyFile)" />
  <UsingTask TaskName="Microsoft.SourceLink.GitLab.TranslateRepositoryUrls" AssemblyFile="$(_SourceLinkGitLabAssemblyFile)" />
  <PropertyGroup>
    <SourceLinkUrlInitializerTargets>$(SourceLinkUrlInitializerTargets);_InitializeGitLabSourceLinkUrl</SourceLinkUrlInitializerTargets>
    <SourceControlManagerUrlTranslationTargets>$(SourceControlManagerUrlTranslationTargets);TranslateGitLabUrlsInSourceControlInformation</SourceControlManagerUrlTranslationTargets>
  </PropertyGroup>
  <Target Name="_InitializeGitLabSourceLinkUrl" Outputs="%(SourceRoot.Identity)">
    <!--
      The task calculates SourceLink URL for a given SourceRoot.

      If the SourceRoot is associated with a git repository with a recognized domain the <see cref="SourceLinkUrl"/>
      output property is set to the content URL corresponding to the domain, otherwise it is set to string "N/A".

      Recognized domains are specified via Hosts (initialized from SourceLinkGitLabHost item group).
      In addition, if SourceLinkHasSingleProvider is true an implicit host is parsed from RepositoryUrl.

      Example of SourceLinkGitLabHost items:

      <ItemGroup>
        <SourceLinkGitLabHost Include="mygitlab1.com" ContentUrl="http://mygitlab1.com"/>
        <SourceLinkGitLabHost Include="mygitlab2.com" />           ContentUrl defaults to https://mygitlab2.com
        <SourceLinkGitLabHost Include="mygitlab3.com:8080" />      ContentUrl defaults to https://mygitlab3.com:8080
      </ItemGroup>

      ContentUrl is optional. If not specified it defaults to "https://{domain}" or "http://{domain}", based on the scheme of SourceRoot.RepositoryUrl.
    -->
    <Microsoft.SourceLink.GitLab.GetSourceLinkUrl RepositoryUrl="$(PrivateRepositoryUrl)" SourceRoot="@(SourceRoot)" Hosts="@(SourceLinkGitLabHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="SourceLinkUrl" PropertyName="_SourceLinkUrlToUpdate" />
    </Microsoft.SourceLink.GitLab.GetSourceLinkUrl>
    <ItemGroup>
      <!-- Only update the SourceLinkUrl metadata if the SourceRoot belongs to this source control -->
      <SourceRoot Update="%(Identity)" SourceLinkUrl="$(_SourceLinkUrlToUpdate)" Condition="'$(_SourceLinkUrlToUpdate)' != 'N/A'" />
    </ItemGroup>
  </Target>
  <!-- 
    We need to translate ssh URLs to https.
  -->
  <Target Name="TranslateGitLabUrlsInSourceControlInformation">
    <ItemGroup>
      <_TranslatedSourceRoot Remove="@(_TranslatedSourceRoot)" />
    </ItemGroup>
    <Microsoft.SourceLink.GitLab.TranslateRepositoryUrls RepositoryUrl="$(ScmRepositoryUrl)" SourceRoots="@(SourceRoot)" Hosts="@(SourceLinkGitLabHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="TranslatedRepositoryUrl" PropertyName="ScmRepositoryUrl" />
      <Output TaskParameter="TranslatedSourceRoots" ItemName="_TranslatedSourceRoot" />
    </Microsoft.SourceLink.GitLab.TranslateRepositoryUrls>
    <ItemGroup>
      <SourceRoot Remove="@(SourceRoot)" />
      <SourceRoot Include="@(_TranslatedSourceRoot)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.AzureRepos.Git\build\Microsoft.SourceLink.AzureRepos.Git.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.SourceLink.AzureRepos.Git/build/Microsoft.SourceLink.AzureRepos.Git.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <PropertyGroup>
    <_SourceLinkAzureReposGitAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\Microsoft.SourceLink.AzureRepos.Git.dll</_SourceLinkAzureReposGitAssemblyFile>
    <_SourceLinkAzureReposGitAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\Microsoft.SourceLink.AzureRepos.Git.dll</_SourceLinkAzureReposGitAssemblyFile>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.SourceLink.AzureRepos.Git.GetSourceLinkUrl" AssemblyFile="$(_SourceLinkAzureReposGitAssemblyFile)" />
  <UsingTask TaskName="Microsoft.SourceLink.AzureRepos.Git.TranslateRepositoryUrls" AssemblyFile="$(_SourceLinkAzureReposGitAssemblyFile)" />
  <PropertyGroup>
    <SourceLinkUrlInitializerTargets>$(SourceLinkUrlInitializerTargets);_InitializeAzureReposGitSourceLinkUrl</SourceLinkUrlInitializerTargets>
    <SourceControlManagerUrlTranslationTargets>$(SourceControlManagerUrlTranslationTargets);TranslateAzureReposGitUrlsInSourceControlInformation</SourceControlManagerUrlTranslationTargets>
  </PropertyGroup>
  <Target Name="_InitializeAzureReposGitSourceLinkUrl" Outputs="%(SourceRoot.Identity)">
    <!--
      The task calculates SourceLink URL for a given SourceRoot.

      If the SourceRoot is associated with a git repository with a recognized domain the <see cref="SourceLinkUrl"/>
      output property is set to the content URL corresponding to the domain, otherwise it is set to string "N/A".

      Recognized domains are specified via Hosts (initialized from SourceLinkAzureReposGitHost item group).
      In addition, if SourceLinkHasSingleProvider is true an implicit host is parsed from RepositoryUrl.

      ContentUrl is optional. If not specified it defaults to "https://{domain}" or "http://{domain}", based on the scheme of SourceRoot.RepositoryUrl.
    -->
    <Microsoft.SourceLink.AzureRepos.Git.GetSourceLinkUrl RepositoryUrl="$(PrivateRepositoryUrl)" SourceRoot="@(SourceRoot)" Hosts="@(SourceLinkAzureReposGitHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="SourceLinkUrl" PropertyName="_SourceLinkUrlToUpdate" />
    </Microsoft.SourceLink.AzureRepos.Git.GetSourceLinkUrl>
    <ItemGroup>
      <!-- Only update the SourceLinkUrl metadata if the SourceRoot belongs to this source control -->
      <SourceRoot Update="%(Identity)" SourceLinkUrl="$(_SourceLinkUrlToUpdate)" Condition="'$(_SourceLinkUrlToUpdate)' != 'N/A'" />
    </ItemGroup>
  </Target>
  <!-- 
    We need to translate ssh URLs to https.
  -->
  <Target Name="TranslateAzureReposGitUrlsInSourceControlInformation">
    <ItemGroup>
      <_TranslatedSourceRoot Remove="@(_TranslatedSourceRoot)" />
    </ItemGroup>
    <Microsoft.SourceLink.AzureRepos.Git.TranslateRepositoryUrls RepositoryUrl="$(ScmRepositoryUrl)" SourceRoots="@(SourceRoot)" Hosts="@(SourceLinkAzureReposGitHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="TranslatedRepositoryUrl" PropertyName="ScmRepositoryUrl" />
      <Output TaskParameter="TranslatedSourceRoots" ItemName="_TranslatedSourceRoot" />
    </Microsoft.SourceLink.AzureRepos.Git.TranslateRepositoryUrls>
    <ItemGroup>
      <SourceRoot Remove="@(SourceRoot)" />
      <SourceRoot Include="@(_TranslatedSourceRoot)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.Bitbucket.Git\build\Microsoft.SourceLink.Bitbucket.Git.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.SourceLink.Bitbucket.Git/build/Microsoft.SourceLink.Bitbucket.Git.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <PropertyGroup>
    <_SourceLinkBitbucketAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\Microsoft.SourceLink.Bitbucket.Git.dll</_SourceLinkBitbucketAssemblyFile>
    <_SourceLinkBitbucketAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\Microsoft.SourceLink.Bitbucket.Git.dll</_SourceLinkBitbucketAssemblyFile>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.SourceLink.Bitbucket.Git.GetSourceLinkUrl" AssemblyFile="$(_SourceLinkBitbucketAssemblyFile)" />
  <UsingTask TaskName="Microsoft.SourceLink.Bitbucket.Git.TranslateRepositoryUrls" AssemblyFile="$(_SourceLinkBitbucketAssemblyFile)" />
  <PropertyGroup>
    <SourceLinkUrlInitializerTargets>$(SourceLinkUrlInitializerTargets);_InitializeBitbucketGitSourceLinkUrl</SourceLinkUrlInitializerTargets>
    <SourceControlManagerUrlTranslationTargets>$(SourceControlManagerUrlTranslationTargets);TranslateBitbucketGitUrlsInSourceControlInformation</SourceControlManagerUrlTranslationTargets>
  </PropertyGroup>
  <Target Name="_InitializeBitbucketGitSourceLinkUrl" Outputs="%(SourceRoot.Identity)">
    <!--
      The task calculates SourceLink URL for a given SourceRoot.

      If the SourceRoot is associated with a git repository with a recognized domain the <see cref="SourceLinkUrl"/>
      output property is set to the content URL corresponding to the domain, otherwise it is set to string "N/A".

      Recognized domains are specified via Hosts (initialized from SourceLinkBitbucketGitHost item group).
      In addition, if SourceLinkHasSingleProvider is true an implicit host is parsed from RepositoryUrl.

      Example of SourceLinkBitbucketGitHost items:

      <ItemGroup>
        <SourceLinkBitbucketGitHost Include="bitbucket1.com" ContentUrl="http://bitbucket1.com"/>
        <SourceLinkBitbucketGitHost Include="bitbucket2.com" />           ContentUrl defaults to https://bitbucket2.com
        <SourceLinkBitbucketGitHost Include="bitbucket3.com:8080" />      ContentUrl defaults to https://bitbucket3.com:8080
      </ItemGroup>

      ContentUrl is optional. If not specified it defaults to "https://{domain}" or "http://{domain}", based on the scheme of SourceRoot.RepositoryUrl.
    -->
    <Microsoft.SourceLink.Bitbucket.Git.GetSourceLinkUrl RepositoryUrl="$(PrivateRepositoryUrl)" SourceRoot="@(SourceRoot)" Hosts="@(SourceLinkBitbucketGitHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="SourceLinkUrl" PropertyName="_SourceLinkUrlToUpdate" />
    </Microsoft.SourceLink.Bitbucket.Git.GetSourceLinkUrl>
    <ItemGroup>
      <!-- Only update the SourceLinkUrl metadata if the SourceRoot belongs to this source control -->
      <SourceRoot Update="%(Identity)" SourceLinkUrl="$(_SourceLinkUrlToUpdate)" Condition="'$(_SourceLinkUrlToUpdate)' != 'N/A'" />
    </ItemGroup>
  </Target>
  <!-- 
    We need to translate ssh URLs to https.
  -->
  <Target Name="TranslateBitbucketGitUrlsInSourceControlInformation">
    <ItemGroup>
      <_TranslatedSourceRoot Remove="@(_TranslatedSourceRoot)" />
    </ItemGroup>
    <Microsoft.SourceLink.Bitbucket.Git.TranslateRepositoryUrls RepositoryUrl="$(ScmRepositoryUrl)" SourceRoots="@(SourceRoot)" Hosts="@(SourceLinkBitbucketGitHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="TranslatedRepositoryUrl" PropertyName="ScmRepositoryUrl" />
      <Output TaskParameter="TranslatedSourceRoots" ItemName="_TranslatedSourceRoot" />
    </Microsoft.SourceLink.Bitbucket.Git.TranslateRepositoryUrls>
    <ItemGroup>
      <SourceRoot Remove="@(SourceRoot)" />
      <SourceRoot Include="@(_TranslatedSourceRoot)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.DisableStandardFrameworkResolution.targets" Condition="'$(DisableStandardFrameworkResolution)' == 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DisableStandardFrameworkResolution.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DisableStandardFrameworkResolution.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <Target Name="GetReferenceAssemblyPaths" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="GetFrameworkPaths" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetFrameworkMonikerDisplayName Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 1.0)) and $([MSBuild]::VersionLessThanOrEquals($(TargetFrameworkVersion), 2.1))">.NET Standard $(_TargetFrameworkVersionWithoutV)</TargetFrameworkMonikerDisplayName>
    <TargetFrameworkMonikerDisplayName Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 1.0)) and $([MSBuild]::VersionLessThanOrEquals($(TargetFrameworkVersion), 3.1))">.NET Core $(_TargetFrameworkVersionWithoutV)</TargetFrameworkMonikerDisplayName>
    <TargetFrameworkMonikerDisplayName Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0))">.NET $(_TargetFrameworkVersionWithoutV)</TargetFrameworkMonikerDisplayName>
    <_TargetFrameworkDirectories />
    <FrameworkPathOverride />
    <TargetFrameworkDirectory />
    <!-- all references (even the StdLib) come from packages -->
    <NoStdLib>true</NoStdLib>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.DesignerSupport.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DesignerSupport.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DesignerSupport.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(DesignerRuntimeImplementationProjectOutputGroupDependsOn)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DesignerRuntimeImplementationProjectOutputGroupDependsOn>
      $(CommonOutputGroupsDependsOn);
    </DesignerRuntimeImplementationProjectOutputGroupDependsOn>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DesignerRuntimeImplementationProjectOutputGroupDependsOn>
      $(DesignerRuntimeImplementationProjectOutputGroupDependsOn);
      _GenerateDesignerDepsFile;
      _GenerateDesignerRuntimeConfigFile;
      GetCopyToOutputDirectoryItems;
      _GatherDesignerShadowCopyFiles;
    </DesignerRuntimeImplementationProjectOutputGroupDependsOn>
    <_DesignerDepsFileName>$(AssemblyName).designer.deps.json</_DesignerDepsFileName>
    <_DesignerRuntimeConfigFileName>$(AssemblyName).designer.runtimeconfig.json</_DesignerRuntimeConfigFileName>
    <_DesignerDepsFilePath>$(IntermediateOutputPath)$(_DesignerDepsFileName)</_DesignerDepsFilePath>
    <_DesignerRuntimeConfigFilePath>$(IntermediateOutputPath)$(_DesignerRuntimeConfigFileName)</_DesignerRuntimeConfigFilePath>
  </PropertyGroup>
  <Target Name="DesignerRuntimeImplementationProjectOutputGroup" DependsOnTargets="$(DesignerRuntimeImplementationProjectOutputGroupDependsOn)" Returns="@(DesignerRuntimeImplementationProjectOutputGroupOutput)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_GenerateDesignerDepsFile" Inputs="$(MSBuildAllProjects);$(ProjectAssetsFile)" Outputs="$(_DesignerDepsFilePath)" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      NOTE: We do not include the main assembly info or non-NuGet dependencies
      in designer deps file as these files may not be built yet at design time.
      Instead, we rely on SetAppPaths in runtimeconfig to allow loading of
      non-NuGet assets from shadow copied app base directory. This further
      allows loading of designer dll(s) that are not seen by the build.
    -->
    <GenerateDepsFile AssemblyName="_" AssemblyExtension="_" AssemblyVersion="_" AssetsFilePath="$(ProjectAssetsFile)" DepsFilePath="$(_DesignerDepsFilePath)" IncludeMainProject="false" TrimDepsJsonLibrariesWithoutAssets="$(TrimDepsJsonLibrariesWithoutAssets)" IncludeRuntimeFileVersions="$(IncludeFileVersionsInDependencyFile)" IsSelfContained="false" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" ProjectPath="$(MSBuildProjectFullPath)" RuntimeFrameworks="@(RuntimeFramework)" CompileReferences="@(ResolvedCompileFileDefinitions)" ResolvedNuGetFiles="@(NativeCopyLocalItems);@(ResourceCopyLocalItems);@(RuntimeCopyLocalItems)" ResolvedRuntimeTargetsFiles="@(RuntimeTargetsCopyLocalItems)" TargetFramework="$(TargetFramework)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" IncludeProjectsNotInAssetsFile="$(IncludeProjectsNotInAssetsFileInDepsFile)" />
    <ItemGroup>
      <!-- Designer will rename to <surface process name>.deps.json -->
      <DesignerRuntimeImplementationProjectOutputGroupOutput Include="$([MSBuild]::NormalizePath($(_DesignerDepsFilePath)))" TargetPath="$(_DesignerDepsFileName)" />
      <FileWrites Include="$(_DesignerDepsFilePath)" />
    </ItemGroup>
  </Target>
  <Target Name="_GenerateDesignerRuntimeConfigFile" Inputs="$(MSBuildAllProjects);$(ProjectAssetsFile)" Outputs="$(_DesignerRuntimeConfigFilePath)" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_DesignerHostConfigurationOption Include="Microsoft.NETCore.DotNetHostPolicy.SetAppPaths" Value="true" />
    </ItemGroup>
    <GenerateRuntimeConfigurationFiles AdditionalProbingPaths="@(AdditionalProbingPath)" AssetsFilePath="$(ProjectAssetsFile)" HostConfigurationOptions="@(RuntimeHostConfigurationOption);@(_DesignerHostConfigurationOption)" IsSelfContained="false" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeConfigPath="$(_DesignerRuntimeConfigFilePath)" RuntimeFrameworks="@(RuntimeFramework)" TargetFramework="$(TargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" UserRuntimeConfig="$(UserRuntimeConfig)" WriteAdditionalProbingPathsToMainConfig="true" AlwaysIncludeCoreFramework="$(AlwaysIncludeCoreFrameworkInRuntimeConfig)" />
    <ItemGroup>
      <!-- Designer will rename to <surface process name>.runtimeconfig.json -->
      <DesignerRuntimeImplementationProjectOutputGroupOutput Include="$([MSBuild]::NormalizePath($(_DesignerRuntimeConfigFilePath)))" TargetPath="$(_DesignerRuntimeConfigFileName)" />
      <FileWrites Include="$(_DesignerRuntimeConfigFilePath)" />
    </ItemGroup>
  </Target>
  <Target Name="_GatherDesignerShadowCopyFiles" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_DesignerShadowCopy Include="@(ReferenceCopyLocalPaths)" />
      <!-- For .NET Core, we do not include NuGet package assets, as the designer will load these from the NuGet cache. -->
      <_DesignerShadowCopy Remove="@(_ResolvedCopyLocalBuildAssets)" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'" />
      <!-- For .NET Core runtime pack assets, we do not include them regardless of whether the app is
              self-contained, as they will be loaded from the shared framework.  However, for runtime pack
              assets where RuntimePackAlwaysCopyLocal is true, there is no shared framework, so we still
              include those.  -->
      <_DesignerShadowCopy Remove="@(RuntimePackAsset)" Condition="'%(RuntimePackAsset.RuntimePackAlwaysCopyLocal)' != 'true'" />
      <DesignerRuntimeImplementationProjectOutputGroupOutput Include="@(_DesignerShadowCopy->'%(FullPath)')" TargetPath="%(_DesignerShadowCopy.DestinationSubDirectory)%(_DesignerShadowCopy.Filename)%(_DesignerShadowCopy.Extension)" />
      <!-- Include ijwhost.dll for projects that use it -->
      <DesignerRuntimeImplementationProjectOutputGroupOutput Include="@(AllItemsFullPathWithTargetPath-&gt;WithMetadataValue('Filename', '$(_DotNetIjwHostLibraryNameWithoutExtension)')-&gt;WithMetadataValue('Extension', '$(_IjwHostLibraryExtension)'))" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.GenerateAssemblyInfo.targets" Condition="'$(UsingNETSdkDefaults)' == 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.GenerateAssemblyInfo.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.GenerateAssemblyInfo.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    ============================================================
                                     GenerateAssemblyInfo

    Generates assembly info source to intermediate directory
    ============================================================
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GeneratedAssemblyInfoFile Condition="'$(GeneratedAssemblyInfoFile)' ==''">$(IntermediateOutputPath)$(MSBuildProjectName).AssemblyInfo$(DefaultLanguageSourceExtension)</GeneratedAssemblyInfoFile>
    <GenerateAssemblyInfo Condition="'$(GenerateAssemblyInfo)' == ''">true</GenerateAssemblyInfo>
  </PropertyGroup>
  <PropertyGroup Condition="'$(GenerateAssemblyInfo)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateAssemblyCompanyAttribute Condition="'$(GenerateAssemblyCompanyAttribute)' == ''">true</GenerateAssemblyCompanyAttribute>
    <GenerateAssemblyConfigurationAttribute Condition="'$(GenerateAssemblyConfigurationAttribute)' == ''">true</GenerateAssemblyConfigurationAttribute>
    <GenerateAssemblyCopyrightAttribute Condition="'$(GenerateAssemblyCopyrightAttribute)' == ''">true</GenerateAssemblyCopyrightAttribute>
    <GenerateAssemblyDescriptionAttribute Condition="'$(GenerateAssemblyDescriptionAttribute)' == ''">true</GenerateAssemblyDescriptionAttribute>
    <GenerateAssemblyFileVersionAttribute Condition="'$(GenerateAssemblyFileVersionAttribute)' == ''">true</GenerateAssemblyFileVersionAttribute>
    <GenerateAssemblyInformationalVersionAttribute Condition="'$(GenerateAssemblyInformationalVersionAttribute)' == ''">true</GenerateAssemblyInformationalVersionAttribute>
    <GenerateAssemblyTrademarkAttribute Condition="'$(GenerateAssemblyTrademarkAttribute)' == ''">true</GenerateAssemblyTrademarkAttribute>
    <GenerateAssemblyProductAttribute Condition="'$(GenerateAssemblyProductAttribute)' == ''">true</GenerateAssemblyProductAttribute>
    <GenerateAssemblyTitleAttribute Condition="'$(GenerateAssemblyTitleAttribute)' == ''">true</GenerateAssemblyTitleAttribute>
    <GenerateAssemblyVersionAttribute Condition="'$(GenerateAssemblyVersionAttribute)' == ''">true</GenerateAssemblyVersionAttribute>
    <GenerateRepositoryUrlAttribute Condition="'$(GenerateRepositoryUrlAttribute)' == '' and !('$(TargetFrameworkIdentifier)' == '.NETFramework' and $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), 4.5)))">true</GenerateRepositoryUrlAttribute>
    <GenerateNeutralResourcesLanguageAttribute Condition="'$(GenerateNeutralResourcesLanguageAttribute)' == ''">true</GenerateNeutralResourcesLanguageAttribute>
    <GenerateAssemblyMetadataAttributes Condition="'$(GenerateAssemblyMetadataAttributes)' == ''">true</GenerateAssemblyMetadataAttributes>
    <IncludeSourceRevisionInInformationalVersion Condition="'$(IncludeSourceRevisionInInformationalVersion)' == ''">true</IncludeSourceRevisionInInformationalVersion>
    <GenerateInternalsVisibleToAttributes Condition="'$(GenerateInternalsVisibleToAttributes)' == ''">true</GenerateInternalsVisibleToAttributes>
    <GenerateRequiresPreviewFeaturesAttribute Condition="'$(GenerateRequiresPreviewFeaturesAttribute)' == '' and '$(IsNetCoreAppTargetingLatestTFM)' == 'true'">true</GenerateRequiresPreviewFeaturesAttribute>
    <GenerateTargetPlatformAttribute Condition="'$(GenerateTargetPlatformAttribute)' == ''">true</GenerateTargetPlatformAttribute>
    <GenerateSupportedOSPlatformAttribute Condition="'$(GenerateSupportedOSPlatformAttribute)' == ''">true</GenerateSupportedOSPlatformAttribute>
    <GenerateDisableRuntimeMarshallingAttribute Condition="'$(GenerateDisableRuntimeMarshallingAttribute)' == ''">true</GenerateDisableRuntimeMarshallingAttribute>
  </PropertyGroup>
  <!--
    Note that this must run before every invocation of CoreCompile to ensure that all compiler
    runs see the generated assembly info. There is at least one scenario involving Xaml
    where CoreCompile is invoked without other potential hooks such as Compile or CoreBuild,
    etc., so we hook directly on to CoreCompile. Furthermore, we  must run *after*
    PrepareForBuild to ensure that the intermediate directory has been created.

    Targets that generate Compile items are also expected to run before
    BeforeCompile targets (common targets convention).
   -->
  <Target Name="GenerateAssemblyInfo" BeforeTargets="BeforeCompile;CoreCompile" DependsOnTargets="PrepareForBuild;CoreGenerateAssemblyInfo" Condition="'$(GenerateAssemblyInfo)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="AddSourceRevisionToInformationalVersion" DependsOnTargets="GetAssemblyVersion;InitializeSourceControlInformation" Condition="'$(SourceControlInformationFeatureSupported)' == 'true' and '$(IncludeSourceRevisionInInformationalVersion)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Condition="'$(SourceRevisionId)' != ''">
      <!-- Follow SemVer 2.0 rules -->
      <_InformationalVersionContainsPlus>false</_InformationalVersionContainsPlus>
      <_InformationalVersionContainsPlus Condition="$(InformationalVersion.Contains('+'))">true</_InformationalVersionContainsPlus>
      <InformationalVersion Condition="!$(_InformationalVersionContainsPlus)">$(InformationalVersion)+$(SourceRevisionId)</InformationalVersion>
      <InformationalVersion Condition="$(_InformationalVersionContainsPlus)">$(InformationalVersion).$(SourceRevisionId)</InformationalVersion>
    </PropertyGroup>
  </Target>
  <Target Name="GetAssemblyAttributes" DependsOnTargets="GetAssemblyVersion;InitializeSourceControlInformation;AddSourceRevisionToInformationalVersion" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <AssemblyAttribute Include="System.Reflection.AssemblyCompanyAttribute" Condition="'$(Company)' != '' and '$(GenerateAssemblyCompanyAttribute)' == 'true'">
        <_Parameter1>$(Company)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyConfigurationAttribute" Condition="'$(Configuration)' != '' and '$(GenerateAssemblyConfigurationAttribute)' == 'true'">
        <_Parameter1>$(Configuration)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyCopyrightAttribute" Condition="'$(Copyright)' != '' and '$(GenerateAssemblyCopyrightAttribute)' == 'true'">
        <_Parameter1>$(Copyright)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyDescriptionAttribute" Condition="'$(Description)' != '' and '$(GenerateAssemblyDescriptionAttribute)' == 'true'">
        <_Parameter1>$(Description)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyFileVersionAttribute" Condition="'$(FileVersion)' != '' and '$(GenerateAssemblyFileVersionAttribute)' == 'true'">
        <_Parameter1>$(FileVersion)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyInformationalVersionAttribute" Condition="'$(InformationalVersion)' != '' and '$(GenerateAssemblyInformationalVersionAttribute)' == 'true'">
        <_Parameter1>$(InformationalVersion)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyProductAttribute" Condition="'$(Product)' != '' and '$(GenerateAssemblyProductAttribute)' == 'true'">
        <_Parameter1>$(Product)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyTrademarkAttribute" Condition="'$(Trademark)' != '' and '$(GenerateAssemblyTrademarkAttribute)' == 'true'">
        <_Parameter1>$(Trademark)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyTitleAttribute" Condition="'$(AssemblyTitle)' != '' and '$(GenerateAssemblyTitleAttribute)' == 'true'">
        <_Parameter1>$(AssemblyTitle)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyVersionAttribute" Condition="'$(AssemblyVersion)' != '' and '$(GenerateAssemblyVersionAttribute)' == 'true'">
        <_Parameter1>$(AssemblyVersion)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyMetadataAttribute" Condition="'$(GenerateRepositoryUrlAttribute)' == 'true' and ('$(RepositoryUrl)' != '' or '$(PublishRepositoryUrl)' == 'true')">
        <_Parameter1>RepositoryUrl</_Parameter1>
        <_Parameter2 Condition="'$(RepositoryUrl)' != ''">$(RepositoryUrl)</_Parameter2>
        <_Parameter2 Condition="'$(RepositoryUrl)' == ''">$(PrivateRepositoryUrl)</_Parameter2>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Resources.NeutralResourcesLanguageAttribute" Condition="'$(NeutralLanguage)' != '' and '$(GenerateNeutralResourcesLanguageAttribute)' == 'true'">
        <_Parameter1>$(NeutralLanguage)</_Parameter1>
      </AssemblyAttribute>
      <InternalsVisibleTo Condition="'%(InternalsVisibleTo.PublicKey)' != ''">
        <Key>%(InternalsVisibleTo.PublicKey)</Key>
      </InternalsVisibleTo>
      <AssemblyAttribute Include="System.Runtime.CompilerServices.InternalsVisibleTo" Condition="%(InternalsVisibleTo.Identity) != '' and '$(GenerateInternalsVisibleToAttributes)' == 'true'">
        <_Parameter1 Condition="'%(InternalsVisibleTo.Key)' != ''">%(InternalsVisibleTo.Identity), PublicKey=%(InternalsVisibleTo.Key)</_Parameter1>
        <_Parameter1 Condition="'%(InternalsVisibleTo.Key)' == '' and '$(PublicKey)' != ''">%(InternalsVisibleTo.Identity), PublicKey=$(PublicKey)</_Parameter1>
        <_Parameter1 Condition="'%(InternalsVisibleTo.Key)' == '' and '$(PublicKey)' == ''">%(InternalsVisibleTo.Identity)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyMetadata" Condition="%(AssemblyMetadata.Identity) != '' and '$(GenerateAssemblyMetadataAttributes)' == 'true'">
        <_Parameter1>%(AssemblyMetadata.Identity)</_Parameter1>
        <_Parameter2>%(AssemblyMetadata.Value)</_Parameter2>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Runtime.Versioning.RequiresPreviewFeaturesAttribute" Condition="'$(EnablePreviewFeatures)' == 'true' and '$(GenerateRequiresPreviewFeaturesAttribute)' == 'true'" />
    </ItemGroup>
    <ItemGroup Condition="'$(GenerateTargetPlatformAttribute)' == 'true'&#xA;                         and '$(TargetPlatformIdentifier)' != ''&#xA;                         and '$(TargetPlatformVersion)' != ''&#xA;                         and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;                         and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '5.0'))">
      <AssemblyAttribute Include="System.Runtime.Versioning.TargetPlatformAttribute">
        <_Parameter1>$(TargetPlatformIdentifier)$(TargetPlatformVersion)</_Parameter1>
      </AssemblyAttribute>
    </ItemGroup>
    <ItemGroup Condition="'$(GenerateSupportedOSPlatformAttribute)' == 'true'&#xA;                         and '$(TargetPlatformIdentifier)' != ''&#xA;                         and '$(SupportedOSPlatformVersion)' != ''&#xA;                         and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;                         and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '5.0'))">
      <AssemblyAttribute Include="System.Runtime.Versioning.SupportedOSPlatformAttribute" Condition="!$([MSBuild]::VersionEquals($(SupportedOSPlatformVersion), '0.0'))">
        <_Parameter1>$(TargetPlatformIdentifier)$(SupportedOSPlatformVersion)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Runtime.Versioning.SupportedOSPlatformAttribute" Condition="$([MSBuild]::VersionEquals($(SupportedOSPlatformVersion), '0.0'))">
        <_Parameter1>$(TargetPlatformIdentifier)</_Parameter1>
      </AssemblyAttribute>
    </ItemGroup>
    <ItemGroup Condition="'$(GenerateDisableRuntimeMarshallingAttribute)' == 'true'&#xA;                         and '$(DisableRuntimeMarshalling)' == 'true'&#xA;                         and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;                         and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '7.0'))">
      <AssemblyAttribute Include="System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute" />
    </ItemGroup>
  </Target>
  <!--
    To allow version changes to be respected on incremental builds (e.g. through CLI parameters),
    create a hash of all assembly attributes so that the cache file will change with the calculated
    assembly attribute values and msbuild will then execute CoreGenerateAssembly to generate a new file.
  -->
  <Target Name="CreateGeneratedAssemblyInfoInputsCacheFile" DependsOnTargets="GetAssemblyAttributes" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <GeneratedAssemblyInfoInputsCacheFile>$(IntermediateOutputPath)$(MSBuildProjectName).AssemblyInfoInputs.cache</GeneratedAssemblyInfoInputsCacheFile>
    </PropertyGroup>
    <!-- We only use up to _Parameter1 for most attributes, but other targets may add additional assembly attributes with multiple parameters. -->
    <Hash ItemsToHash="@(AssemblyAttribute->'%(Identity)%(_Parameter1)%(_Parameter2)%(_Parameter3)%(_Parameter4)%(_Parameter5)%(_Parameter6)%(_Parameter7)%(_Parameter8)')">
      <Output TaskParameter="HashResult" PropertyName="_AssemblyAttributesHash" />
    </Hash>
    <WriteLinesToFile Lines="$(_AssemblyAttributesHash)" File="$(GeneratedAssemblyInfoInputsCacheFile)" Overwrite="True" WriteOnlyWhenDifferent="True" />
    <ItemGroup>
      <FileWrites Include="$(GeneratedAssemblyInfoInputsCacheFile)" />
    </ItemGroup>
  </Target>
  <Target Name="CoreGenerateAssemblyInfo" Condition="'$(Language)'=='VB' or '$(Language)'=='C#'" DependsOnTargets="CreateGeneratedAssemblyInfoInputsCacheFile" Inputs="$(GeneratedAssemblyInfoInputsCacheFile)" Outputs="$(GeneratedAssemblyInfoFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- Ensure the generated assemblyinfo file is not already part of the Compile sources, as a workaround for https://github.com/dotnet/sdk/issues/114 -->
      <Compile Remove="$(GeneratedAssemblyInfoFile)" />
    </ItemGroup>
    <WriteCodeFragment AssemblyAttributes="@(AssemblyAttribute)" Language="$(Language)" OutputFile="$(GeneratedAssemblyInfoFile)">
      <Output TaskParameter="OutputFile" ItemName="Compile" />
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </WriteCodeFragment>
  </Target>
  <!--
    ==================================================================
                                            GetAssemblyVersion

    Parses the nuget package version set in $(Version) and returns
    the implied $(AssemblyVersion) and $(FileVersion).

    e.g.:
        <Version>1.2.3-beta.4</Version>

    implies:
        <AssemblyVersion>1.2.3</AssemblyVersion>
        <FileVersion>1.2.3</FileVersion>

    Note that if $(AssemblyVersion) or $(FileVersion) are are already set, it
    is considered an override of the default inference from $(Version) and they
    are left unchanged by this target.
    ==================================================================
  -->
  <Target Name="GetAssemblyVersion" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GetAssemblyVersion Condition="'$(AssemblyVersion)' == ''" NuGetVersion="$(Version)">
      <Output TaskParameter="AssemblyVersion" PropertyName="AssemblyVersion" />
    </GetAssemblyVersion>
    <PropertyGroup>
      <FileVersion Condition="'$(FileVersion)' == ''">$(AssemblyVersion)</FileVersion>
      <InformationalVersion Condition="'$(InformationalVersion)' == ''">$(Version)</InformationalVersion>
    </PropertyGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.GenerateGlobalUsings.targets" Condition="'$(Language)' == 'C#'" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.GenerateSupportedRuntime.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.GenerateSupportedRuntime.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.GenerateSupportedRuntime.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="WriteAppConfigWithSupportedRuntime" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="SetGeneratedAppConfigMetadata" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_GenerateSupportedRuntimeIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).withSupportedRuntime.config</_GenerateSupportedRuntimeIntermediateAppConfig>
  </PropertyGroup>
  <Target Name="GenerateSupportedRuntime" Condition="'$(GenerateSupportedRuntime)' != 'false' and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(HasRuntimeOutput)' == 'true'" DependsOnTargets="_WriteAppConfigWithSupportedRuntime" BeforeTargets="GenerateBindingRedirects" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <SetGeneratedAppConfigMetadata AppConfigFile="@(AppConfigWithTargetPath)" TargetName="$(TargetFileName).config" GeneratedAppConfigFile="$(_GenerateSupportedRuntimeIntermediateAppConfig)">
      <Output TaskParameter="OutputAppConfigFileWithMetadata" ItemName="_GenerateSupportedRuntimeAppConfigWithTargetPath" />
    </SetGeneratedAppConfigMetadata>
    <!--Override the AppConfigWithTargetPath for downstream target-->
    <ItemGroup>
      <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
      <AppConfigWithTargetPath Include="@(_GenerateSupportedRuntimeAppConfigWithTargetPath)" />
    </ItemGroup>
  </Target>
  <Target Name="_WriteAppConfigWithSupportedRuntime" Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath)" Outputs="$(_GenerateSupportedRuntimeIntermediateAppConfig)" DependsOnTargets="PrepareForBuild" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <WriteAppConfigWithSupportedRuntime AppConfigFile="@(AppConfigWithTargetPath)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkProfile="$(TargetFrameworkProfile)" OutputAppConfigFile="$(_GenerateSupportedRuntimeIntermediateAppConfig)" />
    <ItemGroup>
      <FileWrites Include="@(_GenerateSupportedRuntimeAppConfigWithTargetPath)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.ComposeStore.targets" Condition="'$(UsingNETSdkDefaults)' == 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ComposeStore.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ComposeStore.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    ============================================================
                                        ComposeStore

    The main store entry point.
    ============================================================
    -->
  <Target Name="ComposeStore" DependsOnTargets="PrepareForComposeStore;&#xA;                            PrepOptimizer;&#xA;                            StoreWorkerMain;&#xA;                            _CopyResolvedUnOptimizedFiles;&#xA;                            StoreFinalizer;" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        StoreWorkerMain

   Processes the store project files
    ============================================================
    -->
  <Target Name="StoreWorkerMain" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_AllProjects Include="$(AdditionalProjects.Split('%3B'))" />
      <_AllProjects Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>
    <MSBuild Projects="%(_AllProjects.Identity)" Targets="StoreWorkerMapper" BuildinParallel="$(BuildinParallel)" Properties="ComposeWorkingDir=$(ComposeWorkingDir);&#xA;                             PublishDir=$(PublishDir);&#xA;                             StoreStagingDir=$(StoreStagingDir);&#xA;                             TargetFramework=$(_TFM);&#xA;                             JitPath=$(JitPath);&#xA;                             Crossgen=$(Crossgen);&#xA;                             DisableImplicitFrameworkReferences=true;&#xA;                             SkipUnchangedFiles=$(SkipUnchangedFiles);&#xA;                             PreserveStoreLayout=$(PreserveStoreLayout);&#xA;                             CreateProfilingSymbols=$(CreateProfilingSymbols);&#xA;                             StoreSymbolsStagingDir=$(StoreSymbolsStagingDir)">
      <Output ItemName="AllResolvedPackagesPublished" TaskParameter="TargetOutputs" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
                                        StoreWorkerMapper

   Processes each package specified in a store project file
    ============================================================
    -->
  <Target Name="StoreWorkerMapper" Returns="@(ResolvedPackagesFromMapper)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <PackageReferencesToStore Include="$(MSBuildProjectFullPath)">
        <PackageName>%(PackageReference.Identity)</PackageName>
        <PackageVersion>%(PackageReference.Version)</PackageVersion>
        <AdditionalProperties>
          StorePackageName=%(PackageReference.Identity);
          StorePackageVersion=%(PackageReference.Version);
          ComposeWorkingDir=$(ComposeWorkingDir);
          PublishDir=$(PublishDir);
          StoreStagingDir=$(StoreStagingDir);
          TargetFramework=$(TargetFramework);
          RuntimeIdentifier=$(RuntimeIdentifier);
          JitPath=$(JitPath);
          Crossgen=$(Crossgen);
          SkipUnchangedFiles=$(SkipUnchangedFiles);
          PreserveStoreLayout=$(PreserveStoreLayout);
          CreateProfilingSymbols=$(CreateProfilingSymbols);
          StoreSymbolsStagingDir=$(StoreSymbolsStagingDir);
          DisableImplicitFrameworkReferences=false;
        </AdditionalProperties>
      </PackageReferencesToStore>
    </ItemGroup>
    <!-- Restore phase -->
    <MSBuild Projects="@(PackageReferencesToStore)" Targets="RestoreForComposeStore" BuildInParallel="$(BuildInParallel)" />
    <!-- Resolve phase-->
    <MSBuild Projects="@(PackageReferencesToStore)" Targets="StoreResolver" Properties="SelfContained=false;UseAppHost=false;MSBuildProjectExtensionsPath=$(ComposeWorkingDir)\%(PackageReferencesToStore.PackageName)_$([System.String]::Copy('%(PackageReferencesToStore.PackageVersion)').Replace('*','-'))\;" BuildInParallel="$(BuildInParallel)">
      <Output ItemName="ResolvedPackagesFromMapper" TaskParameter="TargetOutputs" />
    </MSBuild>
  </Target>
  <Target Name="StoreResolver" Returns="@(ResolvedPackagesPublished)" DependsOnTargets="PrepforRestoreForComposeStore;&#xA;                            StoreWorkerPerformWork" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="StoreWorkerPerformWork" DependsOnTargets="ComputeAndCopyFilesToStoreDirectory;" Condition="Exists($(StoreWorkerWorkingDir))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        StoreFinalizer

   Cleans up and produces artifacts after completion of store
    ============================================================
    -->
  <UsingTask TaskName="RemoveDuplicatePackageReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="StoreFinalizer" DependsOnTargets="StoreWorkerMain;&#xA;                            _CopyResolvedOptimizedFiles" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RemoveDuplicatePackageReferences InputPackageReferences="@(AllResolvedPackagesPublished)">
      <Output TaskParameter="UniquePackageReferences" ItemName="AllResolvedPackagesPublishedAfterFilter" />
    </RemoveDuplicatePackageReferences>
    <ItemGroup>
      <ListOfPackageReference Include="@(AllResolvedPackagesPublishedAfterFilter -> '%20%20&lt;Package Id=&quot;%(Identity)&quot; Version=&quot;%(Version)&quot; /&gt;')" />
    </ItemGroup>
    <PropertyGroup>
      <_StoreArtifactContent><![CDATA[
<StoreArtifacts>
@(ListOfPackageReference)
</StoreArtifacts>
]]></_StoreArtifactContent>
    </PropertyGroup>
    <WriteLinesToFile File="$(StoreArtifactXml)" Lines="$(_StoreArtifactContent)" Overwrite="true" />
    <Message Text="Files were composed in $(PublishDir)" Importance="high" />
    <Message Text="The list of packages stored is in $(StoreArtifactXml) " Importance="high" />
    <RemoveDir Condition="'$(PreserveComposeWorkingDir)' != 'true'" Directories="$(ComposeWorkingDir)" />
  </Target>
  <!--
    ============================================================
                                        _CopyResolvedUnOptimizedFiles

    Copy OptimizedResolvedFileToPublish items to the publish directory.
    ============================================================
    -->
  <Target Name="_CopyResolvedOptimizedFiles" DependsOnTargets="StoreWorkerMain;" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_OptimizedResolvedFileToPublish Include="$(StoreStagingDir)\**\*.*" />
      <_OptimizedSymbolFileToPublish Include="$(StoreSymbolsStagingDir)\**\*.*" />
    </ItemGroup>
    <Copy SourceFiles="@(_OptimizedResolvedFileToPublish)" DestinationFolder="$(PublishDir)%(_OptimizedResolvedFileToPublish.RecursiveDir)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" Condition="'@(_OptimizedResolvedFileToPublish)' != ''" SkipUnchangedFiles="$(SkipUnchangedFiles)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <Copy SourceFiles="@(_OptimizedSymbolFileToPublish)" DestinationFolder="$(ProfilingSymbolsDir)%(_OptimizedSymbolFileToPublish.RecursiveDir)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" Condition="'@(_OptimizedSymbolFileToPublish)' != ''" SkipUnchangedFiles="$(SkipUnchangedFiles)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        PrepareForComposeStore

    Prepare the prerequisites for ComposeStore.
    ============================================================
    -->
  <Target Name="PrepareForComposeStore" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <PreserveStoreLayout Condition="'$(PreserveStoreLayout)' == ''">true</PreserveStoreLayout>
      <SkipOptimization Condition="'$(RuntimeIdentifier)' == ''">true</SkipOptimization>
      <_TFM Condition="'$(_TFM)' == ''">$(TargetFramework)</_TFM>
      <SkipUnchangedFiles Condition="'$(SkipUnchangedFiles)' == ''">true</SkipUnchangedFiles>
    </PropertyGroup>
    <NETSdkError Condition="'2.0' &gt; '$(_TargetFrameworkVersionWithoutV)'" ResourceName="UnuspportedFramework" FormatArguments="$(TargetFrameworkMoniker)" />
    <NETSdkError Condition="'$(RuntimeIdentifier)' =='' and '$(_PureManagedAssets)' == ''" ResourceName="RuntimeIdentifierWasNotSpecified" />
    <NETSdkError Condition="'$(_TFM)' ==''" ResourceName="AtLeastOneTargetFrameworkMustBeSpecified" />
    <PropertyGroup>
      <DefaultComposeDir>$(UserProfileRuntimeStorePath)</DefaultComposeDir>
      <_ProfilingSymbolsDirectoryName>symbols</_ProfilingSymbolsDirectoryName>
      <DefaultProfilingSymbolsDir>$([System.IO.Path]::Combine($(DefaultComposeDir), $(_ProfilingSymbolsDirectoryName)))</DefaultProfilingSymbolsDir>
      <ProfilingSymbolsDir Condition="'$(ProfilingSymbolsDir)' == '' and '$(ComposeDir)' != ''">$([System.IO.Path]::Combine($(ComposeDir), $(_ProfilingSymbolsDirectoryName)))</ProfilingSymbolsDir>
      <ProfilingSymbolsDir Condition="'$(ProfilingSymbolsDir)' != '' and '$(DoNotDecorateComposeDir)' != 'true'">$([System.IO.Path]::Combine($(ProfilingSymbolsDir), $(PlatformTarget)))</ProfilingSymbolsDir>
      <ProfilingSymbolsDir Condition="'$(ProfilingSymbolsDir)' == ''">$(DefaultProfilingSymbolsDir)</ProfilingSymbolsDir>
      <ProfilingSymbolsDir Condition="'$(DoNotDecorateComposeDir)' != 'true'">$([System.IO.Path]::Combine($(ProfilingSymbolsDir), $(_TFM)))</ProfilingSymbolsDir>
      <ProfilingSymbolsDir Condition="!HasTrailingSlash('$(ProfilingSymbolsDir)')">$(ProfilingSymbolsDir)\</ProfilingSymbolsDir>
      <ComposeDir Condition="'$(ComposeDir)' == ''">$(DefaultComposeDir)</ComposeDir>
      <ComposeDir Condition="'$(DoNotDecorateComposeDir)' != 'true'">$([System.IO.Path]::Combine($(ComposeDir), $(PlatformTarget)))</ComposeDir>
      <ComposeDir Condition="'$(DoNotDecorateComposeDir)' != 'true'">$([System.IO.Path]::Combine($(ComposeDir), $(_TFM)))</ComposeDir>
      <StoreArtifactXml>$([System.IO.Path]::Combine($(ComposeDir),"artifact.xml"))</StoreArtifactXml>
      <PublishDir>$([System.IO.Path]::GetFullPath($(ComposeDir)))</PublishDir>
      <_RandomFileName>$([System.IO.Path]::GetRandomFileName())</_RandomFileName>
      <TEMP Condition="'$(TEMP)' == ''">$([System.IO.Path]::GetTempPath())</TEMP>
      <ComposeWorkingDir Condition="'$(ComposeWorkingDir)' == ''">$([System.IO.Path]::Combine($(TEMP), $(_RandomFileName)))</ComposeWorkingDir>
      <ComposeWorkingDir>$([System.IO.Path]::GetFullPath($(ComposeWorkingDir)))</ComposeWorkingDir>
      <StoreStagingDir>$([System.IO.Path]::Combine($(ComposeWorkingDir),"StagingDir"))</StoreStagingDir>
      <!-- Will contain optimized managed assemblies in nuget cache layout -->
      <StoreSymbolsStagingDir>$([System.IO.Path]::Combine($(ComposeWorkingDir),"SymbolsStagingDir"))</StoreSymbolsStagingDir>
      <!-- Ensure any PublishDir has a trailing slash, so it can be concatenated -->
      <PublishDir Condition="!HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(CreateProfilingSymbols)' == ''">
      <!-- There is no support for profiling symbols on OSX -->
      <CreateProfilingSymbols Condition="$(RuntimeIdentifier.StartsWith('osx'))">false</CreateProfilingSymbols>
      <CreateProfilingSymbols Condition="'$(CreateProfilingSymbols)' == ''">true</CreateProfilingSymbols>
    </PropertyGroup>
    <NETSdkError Condition="Exists($(ComposeWorkingDir))" ResourceName="FolderAlreadyExists" FormatArguments="$(ComposeWorkingDir)" />
    <MakeDir Directories="$(PublishDir)" />
    <MakeDir Directories="$(StoreStagingDir)" />
  </Target>
  <Target Name="PrepforRestoreForComposeStore" DependsOnTargets="_DefaultMicrosoftNETPlatformLibrary" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <StorePackageVersionForFolderName>$(StorePackageVersion.Replace('*','-'))</StorePackageVersionForFolderName>
      <StoreWorkerWorkingDir>$([System.IO.Path]::Combine($(ComposeWorkingDir),"$(StorePackageName)_$(StorePackageVersionForFolderName)"))</StoreWorkerWorkingDir>
      <_PackageProjFile>$([System.IO.Path]::Combine($(StoreWorkerWorkingDir), "Restore.csproj"))</_PackageProjFile>
      <BaseIntermediateOutputPath>$(StoreWorkerWorkingDir)\</BaseIntermediateOutputPath>
      <ProjectAssetsFile>$(BaseIntermediateOutputPath)\project.assets.json</ProjectAssetsFile>
    </PropertyGroup>
    <PropertyGroup>
      <PackagesToPrune>$(MicrosoftNETPlatformLibrary)</PackagesToPrune>
      <SelfContained Condition="'$(SelfContained)' == ''">true</SelfContained>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        RestoreForComposeStore

    Restores the package
    ============================================================
    -->
  <Target Name="RestoreForComposeStore" DependsOnTargets="PrepforRestoreForComposeStore;" Condition="!Exists($(StoreWorkerWorkingDir))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MakeDir Directories="$(StoreWorkerWorkingDir)" />
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="Restore" Properties="RestoreGraphProjectInput=$(MSBuildProjectFullPath);&#xA;                             RestoreOutputPath=$(BaseIntermediateOutputPath);&#xA;                             StorePackageName=$(StorePackageName);&#xA;                             StorePackageVersion=$(StorePackageVersion);&#xA;                             RuntimeIdentifier=$(RuntimeIdentifier);&#xA;                             TargetFramework=$(TargetFramework);" />
  </Target>
  <!--
    ============================================================
                                        ComputeAndCopyFilesToStoreDirectory

    Computes the list of all files to copy to the publish directory and then publishes them.
    ============================================================
    -->
  <Target Name="ComputeAndCopyFilesToStoreDirectory" DependsOnTargets="ComputeFilesToStore;&#xA;                            CopyFilesToStoreDirectory" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        CopyFilesToStoreDirectory

    Copy all build outputs, satellites and other necessary files to the publish directory.
    ============================================================
    -->
  <Target Name="CopyFilesToStoreDirectory" DependsOnTargets="_CopyResolvedUnOptimizedFiles" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        _CopyResolvedUnOptimizedFiles

    Copy _UnOptimizedResolvedFileToPublish items to the publish directory.
    ============================================================
    -->
  <Target Name="_CopyResolvedUnOptimizedFiles" DependsOnTargets="_ComputeResolvedFilesToStoreTypes;&#xA;                            _RunOptimizer" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Copy SourceFiles="@(_UnOptimizedResolvedFileToPublish)" DestinationFiles="$(PublishDir)%(_UnOptimizedResolvedFileToPublish.DestinationSubPath)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" SkipUnchangedFiles="$(SkipUnchangedFiles)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _ComputeResolvedFilesToStoreTypes
    ============================================================
    -->
  <Target Name="_ComputeResolvedFilesToStoreTypes" DependsOnTargets="_GetResolvedFilesToStore;_SplitResolvedFiles;" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        _SplitResolvedFiles

    Splits ResolvedFileToPublish items into 'managed' and 'unmanaged' buckets.
    ============================================================
    -->
  <Target Name="_SplitResolvedFiles" Condition="$(SkipOptimization) !='true' " DependsOnTargets="_GetResolvedFilesToStore" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ManagedResolvedFileToPublishCandidates Include="@(ResolvedFileToPublish)" Condition="'%(ResolvedFileToPublish.AssetType)'=='runtime'" />
      <_UnOptimizedResolvedFileToPublish Include="@(ResolvedFileToPublish)" Condition="'%(ResolvedFileToPublish.AssetType)'!='runtime'" />
    </ItemGroup>
    <PropertyGroup>
      <SkipOptimization Condition="'@(_ManagedResolvedFileToPublishCandidates)'==''">true</SkipOptimization>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _GetResolvedFilesToStore
    ============================================================
    -->
  <Target Name="_GetResolvedFilesToStore" Condition="$(SkipOptimization) == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_UnOptimizedResolvedFileToPublish Include="@(ResolvedFileToPublish)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ComputeFilesToStore

    Gathers all the files that need to be copied to the publish directory.
    ============================================================
    -->
  <UsingTask TaskName="FilterResolvedFiles" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="ComputeFilesToStore" DependsOnTargets="_ComputeResolvedCopyLocalPublishAssets;&#xA;                            _ComputeCopyToPublishDirectoryItems" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <CopyBuildOutputToPublishDirectory Condition="'$(CopyBuildOutputToPublishDirectory)'==''">true</CopyBuildOutputToPublishDirectory>
      <CopyOutputSymbolsToPublishDirectory Condition="'$(CopyOutputSymbolsToPublishDirectory)'==''">true</CopyOutputSymbolsToPublishDirectory>
    </PropertyGroup>
    <FilterResolvedFiles AssetsFilePath="$(ProjectAssetsFile)" ResolvedFiles="@(_ResolvedCopyLocalPublishAssets)" PackagesToPrune="$(PackagesToPrune)" TargetFramework="$(TargetFramework)" RuntimeIdentifier="$(RuntimeIdentifier)" IsSelfContained="$(SelfContained)">
      <Output TaskParameter="AssembliesToPublish" ItemName="ResolvedFileToPublish" />
      <Output TaskParameter="PublishedPackages" ItemName="PackagesThatWereResolved" />
    </FilterResolvedFiles>
    <ItemGroup>
      <ResolvedPackagesPublished Include="@(PackagesThatWereResolved)" Condition="$(DoNotTrackPackageAsResolved) !='true'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                       PrepRestoreForStoreProjects

    Removes specified PackageReference for store and inserts the specified StorePackageName
    ============================================================
    -->
  <Target Name="PrepRestoreForStoreProjects" BeforeTargets="_GenerateProjectRestoreGraphPerFramework;" Condition="'$(StorePackageName)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <PackageReference Remove="@(PackageReference)" Condition="'%(PackageReference.IsImplicitlyDefined)' != 'true'" />
      <PackageReference Include="$(StorePackageName)" Version="$(StorePackageVersion)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.CrossGen.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.CrossGen.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.CrossGen.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    For ReadyToRun compilation, default to Crossgen for .NET Core 3.x and .NET 5. If PublishReadyToRunUseCrossgen2
    is set to true in the project or on the command line, use Crossgen2 and default to composite mode. For .NET 6
    and higher, always use Crossgen2 and default to non-composite mode.
  -->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PublishReadyToRunUseCrossgen2 Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '6.0'">true</PublishReadyToRunUseCrossgen2>
    <PublishReadyToRunComposite Condition="'$(PublishReadyToRunComposite)' == '' and '$(PublishSingleFile)' == 'true'  and '$(PublishReadyToRun)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '7.0'">true</PublishReadyToRunComposite>
    <PublishReadyToRunComposite Condition="'$(PublishReadyToRunComposite)' == '' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '6.0'">false</PublishReadyToRunComposite>
    <PublishReadyToRunComposite Condition="'$(PublishReadyToRunComposite)' == ''">true</PublishReadyToRunComposite>
    <PublishReadyToRunComposite Condition="'$(PublishReadyToRunUseCrossgen2)' != 'true' or '$(SelfContained)' != 'true'">false</PublishReadyToRunComposite>
    <PublishReadyToRunUseRuntimePackOptimizationData Condition="'$(PublishReadyToRunUseRuntimePackOptimizationData)' == ''">true</PublishReadyToRunUseRuntimePackOptimizationData>
    <PublishReadyToRunPerfmapFormatVersion Condition="'$(PublishReadyToRunPerfmapFormatVersion)' == ''">1</PublishReadyToRunPerfmapFormatVersion>
  </PropertyGroup>
  <!--
    ============================================================
                                        PrepOptimizer

    Sets up the common infrastructure for the optimization phase
    Outputs:
        JitPath
        Crossgen
    ============================================================
    -->
  <Target Name="PrepOptimizer" DependsOnTargets="_RestoreCrossgen;" Condition="$(SkipOptimization) != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Get the coreclr path -->
    <ItemGroup>
      <_CoreclrResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)" Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='coreclr'" />
      <_CoreclrResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)" Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='libcoreclr'" />
      <_JitResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)" Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='clrjit'" />
      <_JitResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)" Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='libclrjit'" />
    </ItemGroup>
    <NETSdkError Condition="'@(_CoreclrResolvedPath-&gt;Count())' &gt; 1" ResourceName="MultipleFilesResolved" FormatArguments="coreclr" />
    <NETSdkError Condition="'@(_CoreclrResolvedPath)'== ''" ResourceName="UnableToFindResolvedPath" FormatArguments="coreclr" />
    <NETSdkError Condition="'@(_JitResolvedPath-&gt;Count())' &gt; 1" ResourceName="MultipleFilesResolved" FormatArguments="jit" />
    <NETSdkError Condition="'@(_JitResolvedPath)'== ''" ResourceName="UnableToFindResolvedPath" FormatArguments="jit" />
    <!-- Get the crossgen and jit path-->
    <PropertyGroup>
      <_CoreclrPath>@(_CoreclrResolvedPath)</_CoreclrPath>
      <JitPath>@(_JitResolvedPath)</JitPath>
      <_CoreclrDir>$([System.IO.Path]::GetDirectoryName($(_CoreclrPath)))</_CoreclrDir>
      <_CoreclrPkgDir>$([System.IO.Path]::Combine($(_CoreclrDir),"..\..\..\"))</_CoreclrPkgDir>
      <CrossgenDir>$([System.IO.Path]::Combine($(_CoreclrPkgDir),"tools"))</CrossgenDir>
      <!-- TODO override with rid specific tools path for x-arch -->
      <Crossgen>$([System.IO.Path]::Combine($(CrossgenDir),"crossgen"))</Crossgen>
      <Crossgen Condition="$([MSBuild]::IsOSPlatform(`Windows`))">$([System.IO.Path]::Combine($(CrossgenDir),"crossgen.exe"))</Crossgen>
    </PropertyGroup>
    <NETSdkError Condition="!Exists($(Crossgen))" ResourceName="UnableToFindResolvedPath" FormatArguments="$(Crossgen)" />
    <!-- Copy crossgen into the netcoreapp folder to ensure it can load Microsoft.DiaSymReader.Native when creating PDBs -->
    <Copy SourceFiles="$(Crossgen)" DestinationFolder="$(_NetCoreRefDir)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <PropertyGroup>
      <Crossgen>$([System.IO.Path]::GetFullPath($([System.IO.Path]::Combine($(_NetCoreRefDir), $([System.IO.Path]::GetFileName($(Crossgen)))))))</Crossgen>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _RunOptimizer

    Start the optimization phase
    ============================================================
    -->
  <Target Name="_RunOptimizer" DependsOnTargets="_InitializeBasicProps;&#xA;                            _ComputeResolvedFilesToStoreTypes;&#xA;                            _SetupStageForCrossgen" Condition="$(SkipOptimization) != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <AssembliestoCrossgen Include="$(MSBuildProjectFullPath)">
        <Properties>
          CrossgenExe=$(Crossgen);
          CrossgenJit=$(JitPath);
          CrossgenInputAssembly=%(_ManagedResolvedFilesToOptimize.Fullpath);
          CrossgenOutputAssembly=$(_RuntimeOptimizedDir)$(DirectorySeparatorChar)%(_ManagedResolvedFilesToOptimize.FileName)%(_ManagedResolvedFilesToOptimize.Extension);
          CrossgenSubOutputPath=%(_ManagedResolvedFilesToOptimize.DestinationSubPath);
          _RuntimeOptimizedDir=$(_RuntimeOptimizedDir);
          PublishDir=$(StoreStagingDir);
          CrossgenPlatformAssembliesPath=$(_RuntimeRefDir)$(PathSeparator)$(_NetCoreRefDir);
          CreateProfilingSymbols=$(CreateProfilingSymbols);
          StoreSymbolsStagingDir=$(StoreSymbolsStagingDir);
          _RuntimeSymbolsDir=$(_RuntimeSymbolsDir)
        </Properties>
      </AssembliestoCrossgen>
    </ItemGroup>
    <!-- CrossGen the assemblies  -->
    <MSBuild Projects="@(AssembliestoCrossgen)" Targets="RunCrossGen" BuildInParallel="$(BuildInParallel)" Condition="'@(_ManagedResolvedFilesToOptimize)' != ''" />
  </Target>
  <!--
    ============================================================
                                        RunCrossGen
    Target Encapsulating the crossgen command
    ============================================================
    -->
  <Target Name="RunCrossGen" DependsOnTargets="_InitializeBasicProps;" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <CrossgenProfilingSymbolsOutputDirectory>$([System.IO.Path]::GetDirectoryName($(_RuntimeSymbolsDir)\$(CrossgenSubOutputPath)))</CrossgenProfilingSymbolsOutputDirectory>
      <CrossgenSymbolsStagingDirectory>$([System.IO.Path]::GetDirectoryName($(StoreSymbolsStagingDir)\$(CrossgenSubOutputPath)))</CrossgenSymbolsStagingDirectory>
      <CrossgenCommandline>$(CrossgenExe) -nologo -readytorun -in "$(CrossgenInputAssembly)" -out "$(CrossgenOutputAssembly)" -jitpath "$(CrossgenJit)" -platform_assemblies_paths "$(CrossgenPlatformAssembliesPath)"</CrossgenCommandline>
      <CreateProfilingSymbolsOptionName Condition="$([MSBuild]::IsOSPlatform(`Windows`))">CreatePDB</CreateProfilingSymbolsOptionName>
      <CreateProfilingSymbolsOptionName Condition="'$(CreateProfilingSymbolsOptionName)' == ''">CreatePerfMap</CreateProfilingSymbolsOptionName>
    </PropertyGroup>
    <Message Text="CrossgenCommandline: $(CrossgenCommandline)" />
    <!--Optimization skip if the assembly is already present in the final output directory-->
    <Exec Command="$(CrossgenCommandline)" Condition="!Exists($([System.IO.Path]::Combine($(PublishDir),$(CrossgenSubOutputPath))))" IgnoreStandardErrorWarningFormat="true" />
    <Copy SourceFiles="$(CrossgenOutputAssembly)" DestinationFiles="$(PublishDir)\$(CrossgenSubOutputPath)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" Condition="!Exists($([System.IO.Path]::Combine($(PublishDir),$(CrossgenSubOutputPath))))">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Create profiling symbols if requested -->
    <MakeDir Directories="$(CrossgenProfilingSymbolsOutputDirectory)" Condition="'$(CreateProfilingSymbols)' == 'true' and Exists($(CrossgenOutputAssembly))" />
    <Exec Command="$(CrossgenExe) -nologo -readytorun -platform_assemblies_paths $(CrossgenPlatformAssembliesPath) -$(CreateProfilingSymbolsOptionName) $(CrossgenProfilingSymbolsOutputDirectory) $(CrossgenOutputAssembly)" Condition="'$(CreateProfilingSymbols)' == 'true' and Exists($(CrossgenOutputAssembly))" IgnoreStandardErrorWarningFormat="true" />
    <ItemGroup>
      <_ProfilingSymbols Include="$(CrossgenProfilingSymbolsOutputDirectory)\*" Condition="'$(CreateProfilingSymbols)' == 'true'" />
    </ItemGroup>
    <Copy SourceFiles="@(_ProfilingSymbols)" DestinationFolder="$(CrossgenSymbolsStagingDirectory)" Condition="'$(CreateProfilingSymbols)' == 'true'" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <Target Name="_InitializeBasicProps" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <PathSeparator>$([System.IO.Path]::PathSeparator)</PathSeparator>
      <DirectorySeparatorChar>$([System.IO.Path]::DirectorySeparatorChar)</DirectorySeparatorChar>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                       _GetCrossgenProps
    Generates props used by Crossgen
    ============================================================
    -->
  <Target Name="_GetCrossgenProps" Condition="$(SkipOptimization) != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_CrossProjFileDir>$([System.IO.Path]::Combine($(ComposeWorkingDir),"Optimize"))</_CrossProjFileDir>
      <_NetCoreRefDir>$([System.IO.Path]::Combine($(_CrossProjFileDir), "netcoreapp"))</_NetCoreRefDir>
      <!-- flat netcore app assemblies-->
    </PropertyGroup>
    <MakeDir Directories="$(_CrossProjFileDir)" />
    <PropertyGroup>
      <_CrossProjAssetsFile>$([System.IO.Path]::Combine($(_CrossProjFileDir),  project.assets.json))</_CrossProjAssetsFile>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _SetupStageForCrossgen
    ============================================================
    -->
  <Target Name="_SetupStageForCrossgen" DependsOnTargets="_GetCrossgenProps;" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_RuntimeRefDir>$([System.IO.Path]::Combine($(StoreWorkerWorkingDir), "runtimeref"))</_RuntimeRefDir>
      <!-- flat app managed assemblies -->
      <_RuntimeOptimizedDir>$([System.IO.Path]::Combine($(StoreWorkerWorkingDir), "runtimopt"))</_RuntimeOptimizedDir>
      <!-- optimized app managed assemblies in nuget cache layout -->
      <_RuntimeSymbolsDir>$([System.IO.Path]::Combine($(StoreWorkerWorkingDir), "runtimesymbols"))</_RuntimeSymbolsDir>
    </PropertyGroup>
    <ItemGroup>
      <_ManagedResolvedFilesToOptimize Include="@(_ManagedResolvedFileToPublishCandidates)" />
    </ItemGroup>
    <MakeDir Directories="$(_RuntimeOptimizedDir)" />
    <MakeDir Directories="$(_RuntimeSymbolsDir)" Condition="'$(CreateProfilingSymbols)' == 'true'" />
    <!-- Copy managed files to  a flat temp directory for passing it as ref -->
    <Copy SourceFiles="@(_ManagedResolvedFilesToOptimize)" DestinationFolder="$(_RuntimeRefDir)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _RestoreCrossgen
    Restores netcoreapp and publishes it to a temp directory
    ============================================================
    -->
  <Target Name="_RestoreCrossgen" DependsOnTargets="PrepforRestoreForComposeStore;&#xA;                           _SetupStageForCrossgen;&#xA;                           ProcessFrameworkReferences;&#xA;                           ApplyImplicitVersions;&#xA;                           _ComputePackageReferencePublish" Condition="$(SkipOptimization) != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- Filter package references to the one for the platform library, in order to find the right version -->
      <PackageReferenceForCrossGen Include="@(PackageReference)" Condition="'%(Identity)' == '$(MicrosoftNETPlatformLibrary)'" />
    </ItemGroup>
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="Restore" Properties="RuntimeIdentifiers=$(RuntimeIdentifier);&#xA;                             RestoreGraphProjectInput=$(MSBuildProjectFullPath);&#xA;                             RestoreOutputPath=$(_CrossProjFileDir);&#xA;                             StorePackageName=$(MicrosoftNETPlatformLibrary);&#xA;                             StorePackageVersion=%(PackageReferenceForCrossGen.Version);" />
    <!-- For future: Use ResolvePackageAssets instead of ResolveCopyLocalAssets, delete ResolveCopyLocalAssets task -->
    <ResolveCopyLocalAssets Condition="'$(_TargetFrameworkVersionWithoutV)' &lt; '3.0'" AssetsFilePath="$(_CrossProjAssetsFile)" TargetFramework="$(_TFM)" RuntimeIdentifier="$(RuntimeIdentifier)" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeFrameworks="@(RuntimeFramework)" ExcludedPackageReferences="@(_ExcludeFromPublishPackageReference)" IsSelfContained="$(SelfContained)" PreserveStoreLayout="false">
      <Output TaskParameter="ResolvedAssets" ItemName="CrossgenResolvedAssembliesToPublish" />
    </ResolveCopyLocalAssets>
    <GetPackageDirectory Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0'" Items="@(RuntimePack)" AssetsFileWithAdditionalPackageFolders="$(_CrossProjAssetsFile)">
      <Output TaskParameter="Output" ItemName="_CrossgenRuntimePack" />
    </GetPackageDirectory>
    <ResolveRuntimePackAssets Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0'" FrameworkReferences="@(FrameworkReference)" ResolvedRuntimePacks="@(_CrossgenRuntimePack)" DisableTransitiveFrameworkReferenceDownloads="$(DisableTransitiveFrameworkReferenceDownloads)">
      <Output TaskParameter="RuntimePackAssets" ItemName="CrossgenResolvedAssembliesToPublish" />
    </ResolveRuntimePackAssets>
    <!-- Copy managed files to  a flat temp directory for passing it as ref for crossgen -->
    <Copy SourceFiles="@(CrossgenResolvedAssembliesToPublish)" DestinationFolder="$(_NetCoreRefDir)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        CreateReadyToRunImages

    Create ReadyToRun images for managed assemblies in _ResolvedFileToPublishAlways and _ResolvedFileToPublishPreserveNewest.
    ============================================================
    -->
  <Target Name="CreateReadyToRunImages" Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0' And '$(PublishReadyToRun)' == 'true' And '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" DependsOnTargets="_PrepareForReadyToRunCompilation;&#xA;                            _CreateR2RImages;&#xA;                            _CreateR2RSymbols" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <R2RTelemetry Include="PublishReadyToRunUseCrossgen2" Value="$(PublishReadyToRunUseCrossgen2)" />
      <R2RTelemetry Include="Crossgen2PackVersion" Value="%(ResolvedCrossgen2Pack.NuGetPackageVersion)" />
      <R2RTelemetry Include="CompileListCount" Value="@(_ReadyToRunCompileList-&gt;Count())" />
      <R2RTelemetry Include="FailedCount" Value="@(_ReadyToRunCompilationFailures-&gt;Count())" />
    </ItemGroup>
    <AllowEmptyTelemetry EventName="ReadyToRun" EventData="@(R2RTelemetry)" />
    <NETSdkError Condition="'@(_ReadyToRunCompilationFailures)' != ''" ResourceName="ReadyToRunCompilationFailed" />
    <NETSdkInformation Condition="'$(_ReadyToRunCompilerHasWarnings)' != ''" ResourceName="ReadyToRunCompilationHasWarnings_Info" />
    <ItemGroup>
      <!--
      Note: we only remove the entries for the IL images and replace them with the entries for the R2R images.
      We do not do the same for PDBs, because the native PDBs created by the R2R compiler complement the IL PDBs
      and do not replace them. IL PDBs are still required for debugging. Native PDBs emitted by the R2R compiler are
      only used for profiling purposes.
      -->
      <ResolvedFileToPublish Remove="@(_ReadyToRunCompositeBuildInput)" />
      <ResolvedFileToPublish Remove="@(_ReadyToRunCompileList)" />
      <ResolvedFileToPublish Include="@(_ReadyToRunFilesToPublish)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _PrepareForReadyToRunCompilation

    Prepare build for ReadyToRun compilations. Builds list of assemblies to compile, and computes paths to ReadyToRun compiler bits
    ============================================================
    -->
  <UsingTask Condition="'$(Crossgen2TasksOverriden)' != 'true'" TaskName="PrepareForReadyToRunCompilation" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_PrepareForReadyToRunCompilation" DependsOnTargets="ResolveReadyToRunCompilers;_ComputeManagedRuntimePackAssemblies;_ComputeAssembliesToPostprocessOnPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_ReadyToRunOutputPath>$(IntermediateOutputPath)R2R</_ReadyToRunOutputPath>
    </PropertyGroup>
    <MakeDir Directories="$(_ReadyToRunOutputPath)" />
    <ItemGroup>
      <_ReadyToRunImplementationAssemblies Include="@(ResolvedFileToPublish-&gt;WithMetadataValue('PostprocessAssembly', 'true'))" />
    </ItemGroup>
    <!-- Even if app is not self-contained, crossgen requires closure of implementation assemblies. Resolve conflicts
         of the runtime pack assets as though we were copying them locally, and add them to the R2R implementation
         assembly list. -->
    <ItemGroup Condition="'$(SelfContained)' != 'true'">
      <_ReadyToRunImplementationAssemblies Include="@(_ManagedRuntimePackAssembly)" ReferenceOnly="true" />
    </ItemGroup>
    <ResolvePackageFileConflicts Condition="'$(SelfContained)' != 'true'" ReferenceCopyLocalPaths="@(_ReadyToRunImplementationAssemblies)">
      <Output TaskParameter="ReferenceCopyLocalPathsWithoutConflicts" ItemName="_ReadyToRunImplementationAssembliesWithoutConflicts" />
    </ResolvePackageFileConflicts>
    <ItemGroup Condition="'$(SelfContained)' != 'true'">
      <_ReadyToRunImplementationAssemblies Remove="@(_ReadyToRunImplementationAssemblies)" />
      <_ReadyToRunImplementationAssemblies Include="@(_ReadyToRunImplementationAssembliesWithoutConflicts)" />
    </ItemGroup>
    <ItemGroup>
      <_ReadyToRunPgoFiles Include="@(PublishReadyToRunPgoFiles)" />
      <_ReadyToRunPgoFiles Include="@(RuntimePackAsset)" Condition="'%(RuntimePackAsset.AssetType)' == 'pgodata' and '%(RuntimePackAsset.Extension)' == '.mibc' and '$(PublishReadyToRunUseRuntimePackOptimizationData)' == 'true'" />
    </ItemGroup>
    <PrepareForReadyToRunCompilation CrossgenTool="@(CrossgenTool)" Crossgen2Tool="@(Crossgen2Tool)" OutputPath="$(_ReadyToRunOutputPath)" MainAssembly="@(IntermediateAssembly)" Assemblies="@(_ReadyToRunImplementationAssemblies)" ExcludeList="@(PublishReadyToRunExclude)" EmitSymbols="$(PublishReadyToRunEmitSymbols)" IncludeSymbolsInSingleFile="$(IncludeSymbolsInSingleFile)" ReadyToRunUseCrossgen2="$(PublishReadyToRunUseCrossgen2)" Crossgen2Composite="$(PublishReadyToRunComposite)" PublishReadyToRunCompositeExclusions="@(PublishReadyToRunCompositeExclusions)" PublishReadyToRunCompositeRoots="@(PublishReadyToRunCompositeRoots)">
      <Output TaskParameter="ReadyToRunCompileList" ItemName="_ReadyToRunCompileList" />
      <Output TaskParameter="ReadyToRunSymbolsCompileList" ItemName="_ReadyToRunSymbolsCompileList" />
      <Output TaskParameter="ReadyToRunFilesToPublish" ItemName="_ReadyToRunFilesToPublish" />
      <Output TaskParameter="ReadyToRunAssembliesToReference" ItemName="_ReadyToRunAssembliesToReference" />
      <Output TaskParameter="ReadyToRunCompositeBuildReferences" ItemName="_ReadyToRunCompositeBuildReferences" />
      <Output TaskParameter="ReadyToRunCompositeBuildInput" ItemName="_ReadyToRunCompositeBuildInput" />
      <Output TaskParameter="ReadyToRunCompositeUnrootedBuildInput" ItemName="_ReadyToRunCompositeUnrootedBuildInput" />
    </PrepareForReadyToRunCompilation>
  </Target>
  <UsingTask Condition="'$(Crossgen2TasksOverriden)' != 'true'" TaskName="ResolveReadyToRunCompilers" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="ResolveReadyToRunCompilers" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ResolveReadyToRunCompilers RuntimePacks="@(ResolvedRuntimePack)" Crossgen2Packs="@(ResolvedCrossgen2Pack)" TargetingPacks="@(ResolvedTargetingPack)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" NETCoreSdkRuntimeIdentifier="$(NETCoreSdkRuntimeIdentifier)" EmitSymbols="$(PublishReadyToRunEmitSymbols)" ReadyToRunUseCrossgen2="$(PublishReadyToRunUseCrossgen2)" PerfmapFormatVersion="$(PublishReadyToRunPerfmapFormatVersion)">
      <Output TaskParameter="CrossgenTool" ItemName="CrossgenTool" />
      <Output TaskParameter="Crossgen2Tool" ItemName="Crossgen2Tool" />
    </ResolveReadyToRunCompilers>
  </Target>
  <!--
    ============================================================
                                        _CreateR2RImages

    Compiles assemblies in the _ReadyToRunCompileList list into ReadyToRun images
    ============================================================
    -->
  <UsingTask Condition="'$(Crossgen2TasksOverriden)' != 'true'" TaskName="RunReadyToRunCompiler" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_CreateR2RImages" Inputs="$(MSBuildAllProjects);@(_ReadyToRunCompileList);@(_ReadyToRunCompositeBuildInput);@(_ReadyToRunPgoFiles)" Outputs="%(_ReadyToRunCompileList.OutputR2RImage);%(_ReadyToRunCompileList.OutputPDBImage)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RunReadyToRunCompiler CrossgenTool="@(CrossgenTool)" Crossgen2Tool="@(Crossgen2Tool)" UseCrossgen2="$(PublishReadyToRunUseCrossgen2)" Crossgen2PgoFiles="@(_ReadyToRunPgoFiles)" Crossgen2ExtraCommandLineArgs="$(PublishReadyToRunCrossgen2ExtraArgs)" ImplementationAssemblyReferences="@(_ReadyToRunAssembliesToReference)" ShowCompilerWarnings="$(PublishReadyToRunShowWarnings)" CompilationEntry="@(_ReadyToRunCompileList)" ContinueOnError="ErrorAndContinue" ReadyToRunCompositeBuildReferences="@(_ReadyToRunCompositeBuildReferences)" ReadyToRunCompositeBuildInput="@(_ReadyToRunCompositeBuildInput)" ReadyToRunCompositeUnrootedBuildInput="@(_ReadyToRunCompositeUnrootedBuildInput)">
      <Output TaskParameter="ExitCode" PropertyName="_ReadyToRunCompilerExitCode" />
      <Output TaskParameter="WarningsDetected" PropertyName="_ReadyToRunWarningsDetected" />
    </RunReadyToRunCompiler>
    <PropertyGroup>
      <!-- Use distinct property here as any of the invocations can set it -->
      <_ReadyToRunCompilerHasWarnings Condition="'$(_ReadyToRunWarningsDetected)' == 'true'">true</_ReadyToRunCompilerHasWarnings>
    </PropertyGroup>
    <ItemGroup>
      <_ReadyToRunCompilationFailures Condition="'$(_ReadyToRunCompilerExitCode)' != '' And $(_ReadyToRunCompilerExitCode) != 0" Include="@(_ReadyToRunCompileList)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CreateR2RSymbols

    Emit native symbols for ReadyToRun images in the _ReadyToRunSymbolsCompileList list
    ============================================================
    -->
  <Target Name="_CreateR2RSymbols" Inputs="$(MSBuildAllProjects);@(_ReadyToRunSymbolsCompileList)" Outputs="%(_ReadyToRunSymbolsCompileList.OutputPDBImage)" Condition="'$(PublishReadyToRunUseCrossgen2)' != 'true' or '@(Crossgen2Tool -> '%(IsVersion5)')' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RunReadyToRunCompiler CrossgenTool="@(CrossgenTool)" Crossgen2Tool="@(Crossgen2Tool)" UseCrossgen2="$(PublishReadyToRunUseCrossgen2)" Crossgen2ExtraCommandLineArgs="$(PublishReadyToRunCrossgen2ExtraArgs)" ImplementationAssemblyReferences="@(_ReadyToRunAssembliesToReference)" ShowCompilerWarnings="$(PublishReadyToRunShowWarnings)" CompilationEntry="@(_ReadyToRunSymbolsCompileList)" ContinueOnError="ErrorAndContinue">
      <Output TaskParameter="ExitCode" PropertyName="_ReadyToRunCompilerExitCode" />
      <Output TaskParameter="WarningsDetected" PropertyName="_ReadyToRunWarningsDetected" />
    </RunReadyToRunCompiler>
    <PropertyGroup>
      <!-- Use distinct property here as any of the invocations can set it -->
      <_ReadyToRunCompilerHasWarnings Condition="'$(_ReadyToRunWarningsDetected)' == 'true'">true</_ReadyToRunCompilerHasWarnings>
    </PropertyGroup>
    <ItemGroup>
      <_ReadyToRunCompilationFailures Condition="'$(_ReadyToRunCompilerExitCode)' != '' And $(_ReadyToRunCompilerExitCode) != 0" Include="@(_ReadyToRunSymbolsCompileList)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.ObsoleteReferences.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ObsoleteReferences.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ObsoleteReferences.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(NETCoreSdkBundledCliToolsProps)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETCoreSdkBundledCliToolsProps>$(MSBuildThisFileDirectory)..\..\..\Microsoft.NETCoreSdk.BundledCliTools.props</NETCoreSdkBundledCliToolsProps>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NETCoreSdkBundledCliToolsProps)" Condition="Exists('$(NETCoreSdkBundledCliToolsProps)')">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Microsoft.NETCoreSdk.BundledCliTools.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NETCoreSdk.BundledCliTools.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <ItemGroup />
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ObsoleteReferences.targets
============================================================================================================================================
-->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_ReferenceToObsoleteDotNetCliTool Include="@(DotNetCliToolReference)" />
    <DotNetCliToolReference Remove="@(BundledDotNetCliToolReference)" />
    <_ReferenceToObsoleteDotNetCliTool Remove="@(DotNetCliToolReference)" />
  </ItemGroup>
  <Target Name="_CheckForObsoleteDotNetCliToolReferences" BeforeTargets="CollectPackageReferences" Condition=" '$(SuppressObsoleteDotNetCliToolWarning)' != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning Condition=" '%(_ReferenceToObsoleteDotNetCliTool.Identity)' != '' " ResourceName="ProjectContainsObsoleteDotNetCliTool" FormatArguments="%(_ReferenceToObsoleteDotNetCliTool.Identity)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Publish.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Publish.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Publish.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DefaultCopyToPublishDirectoryMetadata Condition="'$(DefaultCopyToPublishDirectoryMetadata)' == ''">true</DefaultCopyToPublishDirectoryMetadata>
    <_GetChildProjectCopyToPublishDirectoryItems Condition="'$(_GetChildProjectCopyToPublishDirectoryItems)' == ''">true</_GetChildProjectCopyToPublishDirectoryItems>
    <IsPublishable Condition="'$(IsPublishable)' == ''">true</IsPublishable>
  </PropertyGroup>
  <!-- Trimming/AOT/publish* property configuration -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- PublishAot depends on PublishTrimmed. This must be set early enough for the KnownILLinkPack to be restored. -->
    <PublishTrimmed Condition="'$(PublishTrimmed)' == '' And '$(PublishAot)' == 'true'">true</PublishTrimmed>
    <IsTrimmable Condition="'$(IsTrimmable)' == '' and '$(IsAotCompatible)' == 'true'">true</IsTrimmable>
    <_FirstTargetFrameworkToSupportTrimming>net6.0</_FirstTargetFrameworkToSupportTrimming>
    <_FirstTargetFrameworkToSupportAot>net7.0</_FirstTargetFrameworkToSupportAot>
    <_FirstTargetFrameworkToSupportSingleFile>net6.0</_FirstTargetFrameworkToSupportSingleFile>
    <_FirstTargetFrameworkVersionToSupportTrimAnalyzer>$([MSBuild]::GetTargetFrameworkVersion('$(_FirstTargetFrameworkToSupportTrimming)'))</_FirstTargetFrameworkVersionToSupportTrimAnalyzer>
    <_FirstTargetFrameworkVersionToSupportAotAnalyzer>$([MSBuild]::GetTargetFrameworkVersion('$(_FirstTargetFrameworkToSupportAot)'))</_FirstTargetFrameworkVersionToSupportAotAnalyzer>
    <_FirstTargetFrameworkVersionToSupportSingleFileAnalyzer>$([MSBuild]::GetTargetFrameworkVersion('$(_FirstTargetFrameworkToSupportSingleFile)'))</_FirstTargetFrameworkVersionToSupportSingleFileAnalyzer>
  </PropertyGroup>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Condition="'$(IsAotCompatible)' == 'true'" Include="IsAotCompatible" />
    <ProjectCapability Condition="'$(IsTrimmable)' == 'true'" Include="IsTrimmable" />
    <ProjectCapability Condition="'$(PublishAot)' == 'true'" Include="PublishAot" />
    <ProjectCapability Condition="'$(PublishReadyToRun)' == 'true'" Include="PublishReadyToRun" />
    <ProjectCapability Condition="'$(PublishSingleFile)' == 'true'" Include="PublishSingleFile" />
    <ProjectCapability Condition="'$(PublishTrimmed)' == 'true'" Include="PublishTrimmed" />
  </ItemGroup>
  <ItemDefinitionGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ResolvedFileToPublish>
      <CopyToPublishDirectory>Always</CopyToPublishDirectory>
    </ResolvedFileToPublish>
  </ItemDefinitionGroup>
  <Target Name="_ComputeToolPackInputsToProcessFrameworkReferences" BeforeTargets="ProcessFrameworkReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Keep this in sync with the warnings produced for RequiresILLinkPack in ProcessFrameworkReferences.cs.
         Must be set late enough to see the inferred value of EnableSingleFileAnalyzer. -->
    <PropertyGroup>
      <_RequiresILLinkPack Condition="'$(_RequiresILLinkPack)' == '' And (&#xA;          '$(PublishAot)' == 'true' Or&#xA;          '$(IsAotCompatible)' == 'true' Or '$(EnableAotAnalyzer)' == 'true' Or&#xA;          '$(PublishTrimmed)' == 'true' Or&#xA;          '$(IsTrimmable)' == 'true' Or '$(EnableTrimAnalyzer)' == 'true' Or&#xA;          '$(EnableSingleFileAnalyzer)' == 'true')">true</_RequiresILLinkPack>
      <_RequiresILLinkPack Condition="'$(_RequiresILLinkPack)' == ''">false</_RequiresILLinkPack>
    </PropertyGroup>
    <!-- ProcessFrameworkReferences warns when the project settings introduce a dependency on a
         tool pack that's not available for the target framework. For trimming, AOT, and single-file, the recommendation
         is to multitarget the project to include a more recent TargetFramework. For correctly multitargeted
         projects, the warning is usually just noise, so we silence it.

         Correctly multitargeted projects include a TargetFramework that is compatible with the requested
         functionality (trimming/AOT/single-file), and doesn't leave a "gap" where the incompatible TargetFramework's
         assembly could be consumed from an app that uses the functionality. In other words, correctly multitargeted
         projects should include at least one TFM that:
         - supports the given functionality, and
         - is no larger than the minimum non-EOL TargetFramework that supports this functionality.

         The following logic determines whether the project is correctly multi-targeted based on its TargetFrameworks,
         and silences the warning if it is. -->
    <PropertyGroup>
      <!-- The min non-EOL TFM has already caught up with the first TFM to support trimming/singlefile. No need to compare against it. -->
      <_MinNonEolTargetFrameworkForTrimming>$(_MinimumNonEolSupportedNetCoreTargetFramework)</_MinNonEolTargetFrameworkForTrimming>
      <_MinNonEolTargetFrameworkForSingleFile>$(_MinimumNonEolSupportedNetCoreTargetFramework)</_MinNonEolTargetFrameworkForSingleFile>
      <!-- Get the min non-EOL TFM that supports AOT. -->
      <_MinNonEolTargetFrameworkForAot>$(_MinimumNonEolSupportedNetCoreTargetFramework)</_MinNonEolTargetFrameworkForAot>
      <_MinNonEolTargetFrameworkForAot Condition="$([MSBuild]::IsTargetFrameworkCompatible('$(_FirstTargetFrameworkToSupportAot)', '$(_MinimumNonEolSupportedNetCoreTargetFramework)'))">$(_FirstTargetFrameworkToSupportAot)</_MinNonEolTargetFrameworkForAot>
    </PropertyGroup>
    <ItemGroup>
      <_TargetFramework Include="$(TargetFrameworks)" />
      <_DecomposedTargetFramework Include="@(_TargetFramework)">
        <SupportsTrimming>$([MSBuild]::IsTargetFrameworkCompatible('%(Identity)', '$(_FirstTargetFrameworkToSupportTrimming)'))</SupportsTrimming>
        <SupportedByMinNonEolTargetFrameworkForTrimming>$([MSBuild]::IsTargetFrameworkCompatible('$(_MinNonEolTargetFrameworkForTrimming)', '%(Identity)'))</SupportedByMinNonEolTargetFrameworkForTrimming>
        <SupportsAot>$([MSBuild]::IsTargetFrameworkCompatible('%(Identity)', '$(_FirstTargetFrameworkToSupportAot)'))</SupportsAot>
        <SupportedByMinNonEolTargetFrameworkForAot>$([MSBuild]::IsTargetFrameworkCompatible('$(_MinNonEolTargetFrameworkForAot)', '%(Identity)'))</SupportedByMinNonEolTargetFrameworkForAot>
        <SupportsSingleFile>$([MSBuild]::IsTargetFrameworkCompatible('%(Identity)', '$(_FirstTargetFrameworkToSupportSingleFile)'))</SupportsSingleFile>
        <SupportedByMinNonEolTargetFrameworkForSingleFile>$([MSBuild]::IsTargetFrameworkCompatible('$(_MinNonEolTargetFrameworkForSingleFile)', '%(Identity)'))</SupportedByMinNonEolTargetFrameworkForSingleFile>
      </_DecomposedTargetFramework>
      <_TargetFrameworkToSilenceIsTrimmableUnsupportedWarning Include="@(_DecomposedTargetFramework)" Condition="'%(SupportsTrimming)' == 'true' And '%(SupportedByMinNonEolTargetFrameworkForTrimming)' == 'true'" />
      <_TargetFrameworkToSilenceIsAotCompatibleUnsupportedWarning Include="@(_DecomposedTargetFramework->'%(Identity)')" Condition="'%(SupportsAot)' == 'true' And '%(SupportedByMinNonEolTargetFrameworkForAot)' == 'true'" />
      <_TargetFrameworkToSilenceEnableSingleFileAnalyzerUnsupportedWarning Include="@(_DecomposedTargetFramework)" Condition="'%(SupportsSingleFile)' == 'true' And '%(SupportedByMinNonEolTargetFrameworkForSingleFile)' == 'true'" />
    </ItemGroup>
    <PropertyGroup>
      <!-- Don't warn if the library multitargets and includes TFM that's supported by trimming/AOT and is supported by the min non-EOL TFM that supports trimming/AOT. -->
      <_SilenceIsTrimmableUnsupportedWarning Condition="'$(_SilenceIsTrimmableUnsupportedWarning)' == '' And&#xA;                                                        @(_TargetFrameworkToSilenceIsTrimmableUnsupportedWarning-&gt;Count()) &gt; 0">true</_SilenceIsTrimmableUnsupportedWarning>
      <_SilenceIsAotCompatibleUnsupportedWarning Condition="'$(_SilenceIsAotCompatibleUnsupportedWarning)' == '' And&#xA;                                                            @(_TargetFrameworkToSilenceIsAotCompatibleUnsupportedWarning-&gt;Count()) &gt; 0">true</_SilenceIsAotCompatibleUnsupportedWarning>
      <_SilenceEnableSingleFileAnalyzerUnsupportedWarning Condition="'$(_SilenceEnableSingleFileAnalyzerUnsupportedWarning)' == '' And&#xA;                                                          @(_TargetFrameworkToSilenceEnableSingleFileAnalyzerUnsupportedWarning-&gt;Count()) &gt; 0">true</_SilenceEnableSingleFileAnalyzerUnsupportedWarning>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        Publish

    The main publish entry point.
    ============================================================
    -->
  <!--<Import Project="Microsoft.NET.ClickOnce.targets" Condition="'$(PublishProtocol)' == 'ClickOnce'" />-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- We still need to resolve references even if we are not building during publish. -->
    <!-- BuildOnlySettings are required for RAR to find satellites and dependencies -->
    <_BeforePublishNoBuildTargets>
      BuildOnlySettings;
      _PreventProjectReferencesFromBuilding;
      ResolveReferences;
      PrepareResourceNames;
      ComputeIntermediateSatelliteAssemblies;
      ComputeEmbeddedApphostPaths;
    </_BeforePublishNoBuildTargets>
    <_CorePublishTargets>
      PrepareForPublish;
      ComputeAndCopyFilesToPublishDirectory;
      $(PublishProtocolProviderTargets);
      PublishItemsOutputGroup;
    </_CorePublishTargets>
    <_PublishNoBuildAlternativeDependsOn>$(_BeforePublishNoBuildTargets);$(_CorePublishTargets)</_PublishNoBuildAlternativeDependsOn>
  </PropertyGroup>
  <Target Name="_PublishBuildAlternative" Condition="'$(NoBuild)' != 'true'" DependsOnTargets="Build;$(_CorePublishTargets)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_PublishNoBuildAlternative" Condition="'$(NoBuild)' == 'true'" DependsOnTargets="$(_PublishNoBuildAlternativeDependsOn)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="Publish" Condition="$(IsPublishable) == 'true'" DependsOnTargets="_PublishBuildAlternative;_PublishNoBuildAlternative" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Ensure there is minimal verbosity output pointing to the publish directory and not just the
         build step's minimal output. Otherwise there is no indication at minimal verbosity of where
         the published assets were copied. -->
    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; $([System.IO.Path]::GetFullPath('$(PublishDir)'))" />
    <ItemGroup>
      <PublishTelemetry Include="PublishReadyToRun" Value="$(PublishReadyToRun)" />
      <PublishTelemetry Include="PublishTrimmed" Value="$(PublishTrimmed)" />
      <PublishTelemetry Include="PublishSingleFile" Value="$(PublishSingleFile)" />
      <PublishTelemetry Include="PublishAot" Value="$(PublishAot)" />
      <PublishTelemetry Include="PublishProtocol" Value="$(PublishProtocol)" />
    </ItemGroup>
    <AllowEmptyTelemetry EventName="PublishProperties" EventData="@(PublishTelemetry)" />
  </Target>
  <!-- Don't let project reference resolution build project references in NoBuild case. -->
  <Target Name="_PreventProjectReferencesFromBuilding" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <BuildProjectReferences>false</BuildProjectReferences>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        PrepareForPublish

    Prepare the prerequisites for publishing.
    ============================================================
    -->
  <Target Name="PrepareForPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' And '$(_IsExecutable)' != 'true'" ResourceName="CannotHaveSingleFileWithoutExecutable" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' And '$(_IsExecutable)' == 'true' And '$(TargetFrameworkIdentifier)' != '.NETCoreApp'" ResourceName="CanOnlyHaveSingleFileWithNetCoreApp" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' And&#xA;                            '$(IncludeSymbolsInSingleFile)' == 'true' And&#xA;                            '$(_TargetFrameworkVersionWithoutV)' &gt;= '5.0' And '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" ResourceName="CannotIncludeSymbolsInSingleFile" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' and '$(RuntimeIdentifier)' == ''" ResourceName="CannotHaveSingleFileWithoutRuntimeIdentifier" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' and '$(UseAppHost)' != 'true' and '$(PublishAot)' != 'true'" ResourceName="CannotHaveSingleFileWithoutAppHost" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' And&#xA;                            '$(EnableCompressionInSingleFile)' == 'true' And&#xA;                            '$(_TargetFrameworkVersionWithoutV)' &lt; '6.0'" ResourceName="CompressionInSingleFileRequires60" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' And&#xA;                            '$(EnableCompressionInSingleFile)' == 'true' And&#xA;                            '$(SelfContained)' != 'true'" ResourceName="CompressionInSingleFileRequiresSelfContained" />
    <NETSdkWarning Condition="'$(PublishProfileImported)' != 'true' and '$(PublishProfile)' != ''" ResourceName="PublishProfileNotPresent" FormatArguments="$(PublishProfile)" />
    <!-- Projects in a solution cannot have conflicting configurations. This checks if PublishRelease conflicted at runtime to avoid extra project evaluations.
    SolutionExt is used to check if we are publishing a solution. Will be undefined if not.-->
    <NETSdkError Condition="'$(_IsPublishing)' == 'true' and&#xA;                            '$(DOTNET_CLI_DISABLE_PUBLISH_AND_PACK_RELEASE)' != 'true' and&#xA;                            '$(DOTNET_CLI_LAZY_PUBLISH_AND_PACK_RELEASE_FOR_SOLUTIONS)' == 'true' and&#xA;                            '$(SolutionExt)' == '.sln' and&#xA;                            '$(_SolutionLevelPublishRelease)' != '$(PublishRelease)'" ResourceName="SolutionProjectConfigurationsConflict" FormatArguments="PublishRelease;$(ProjectName)" />
    <NETSdkError Condition="'$(PublishAot)' == 'true' and&#xA;                            '$(_IsPublishing)' != 'true' and&#xA;                            '$(PublishAotUsingRuntimePack)' == 'true' and&#xA;                            '$(NativeCompilationDuringPublish)' != 'false' and&#xA;                            '$(_TargetFrameworkVersionWithoutV)' &gt;= '10.0'" ResourceName="NativeCompilationRequiresPublishing" />
    <PropertyGroup>
      <!-- Ensure any PublishDir has a trailing slash, so it can be concatenated -->
      <PublishDir Condition="!HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
    </PropertyGroup>
    <MakeDir Directories="$(PublishDir)" />
  </Target>
  <!--
    ============================================================
                                        ComputeAndCopyFilesToPublishDirectory

    Computes the list of all files to copy to the publish directory and then publishes them.
    ============================================================
    -->
  <Target Name="ComputeAndCopyFilesToPublishDirectory" DependsOnTargets="ComputeFilesToPublish;&#xA;                            CopyFilesToPublishDirectory" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        CopyFilesToPublishDirectory

    Copy all build outputs, satellites and other necessary files to the publish directory.
    When publishing to a single file, only those files that are not bundled are copied.
    The remaining files are directly written to the bundle file.
    ============================================================
    -->
  <Target Name="CopyFilesToPublishDirectory" DependsOnTargets="_IncrementalCleanPublishDirectory;&#xA;                            _CopyResolvedFilesToPublishPreserveNewest;&#xA;                            _CopyResolvedFilesToPublishAlways;&#xA;                            _HandleFileConflictsForPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        _IncrementalCleanPublishDirectory

    Remove files that were produced in a prior publish but weren't produced in the current publish.
    ============================================================
    -->
  <Target Name="_IncrementalCleanPublishDirectory" DependsOnTargets="_GetCurrentAndPriorPublishFileWrites" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Subtract list of files produced in the prior publish from list of files produced in this publish. -->
    <ItemGroup>
      <_OrphanPublishFileWrites Include="@(_PriorPublishFileWrites)" Exclude="@(_CurrentPublishFileWrites)" />
    </ItemGroup>
    <!-- Delete the orphaned files. -->
    <Delete Files="@(_OrphanPublishFileWrites)" TreatErrorsAsWarnings="true">
      <Output TaskParameter="DeletedFiles" ItemName="_OrphanFilesDeleted" />
    </Delete>
    <!-- Write new list of current files back to clean file. -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(_PublishCleanFile)" Lines="@(_CurrentPublishFileWrites)" Overwrite="true" />
  </Target>
  <!--
    ============================================================
                                        _GetCurrentAndPriorPublishFileWrites
    Get the list of files written in the previous publish and the list of files to be written in this publish.
    ============================================================
    -->
  <Target Name="_GetCurrentAndPriorPublishFileWrites" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_NormalizedPublishDir>$([MSBuild]::NormalizeDirectory($(PublishDir)))</_NormalizedPublishDir>
    </PropertyGroup>
    <Hash ItemstoHash="$(_NormalizedPublishDir)">
      <Output TaskParameter="HashResult" PropertyName="_NormalizedPublishDirHash" />
    </Hash>
    <PropertyGroup>
      <_PublishCleanFile Condition="'$(PublishCleanFile)'==''">PublishOutputs.$(_NormalizedPublishDirHash.Substring(0, 10)).txt</_PublishCleanFile>
    </PropertyGroup>
    <!-- Read in writes made by prior publish. -->
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(_PublishCleanFile)">
      <Output TaskParameter="Lines" ItemName="_UnfilteredPriorPublishFileWrites" />
    </ReadLinesFromFile>
    <ConvertToAbsolutePath Paths="@(_UnfilteredPriorPublishFileWrites)">
      <Output TaskParameter="AbsolutePaths" ItemName="_UnfilteredAbsolutePriorPublishFileWrites" />
    </ConvertToAbsolutePath>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(_NormalizedPublishDir)" Files="@(_UnfilteredAbsolutePriorPublishFileWrites)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="_PriorPublishFileWritesInOutput" />
    </FindUnderPath>
    <!-- Remove duplicates from files produced in the previous publish. -->
    <RemoveDuplicates Inputs="@(_PriorPublishFileWritesInOutput)">
      <Output TaskParameter="Filtered" ItemName="_PriorPublishFileWrites" />
    </RemoveDuplicates>
    <ItemGroup>
      <_CurrentPublishFileWritesUnfiltered Include="@(ResolvedFileToPublish->'$(_NormalizedPublishDir)%(RelativePath)')" />
      <_CurrentPublishFileWritesUnfiltered Include="$(_NormalizedPublishDir)$(AssemblyName)$(_NativeExecutableExtension)" Condition="'$(UseAppHost)' == 'true'" />
    </ItemGroup>
    <ConvertToAbsolutePath Paths="@(_CurrentPublishFileWritesUnfiltered)">
      <Output TaskParameter="AbsolutePaths" ItemName="_CurrentAbsolutePublishFileWritesUnfiltered" />
    </ConvertToAbsolutePath>
    <!-- Remove duplicates from the files produced in this publish-->
    <RemoveDuplicates Inputs="@(_CurrentAbsolutePublishFileWritesUnfiltered)">
      <Output TaskParameter="Filtered" ItemName="_CurrentPublishFileWrites" />
    </RemoveDuplicates>
  </Target>
  <!--
    ============================================================
                                        _CopyResolvedFilesToPublishPreserveNewest

    Copy _ResolvedFileToPublishPreserveNewest items to the publish directory
    ============================================================
    -->
  <Target Name="_CopyResolvedFilesToPublishPreserveNewest" DependsOnTargets="_ComputeResolvedFilesToPublishTypes" Inputs="@(_ResolvedFileToPublishPreserveNewest)" Outputs="@(_ResolvedFileToPublishPreserveNewest->'$(PublishDir)%(RelativePath)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      PreserveNewest means that we will only copy the source to the destination if the source is newer.
      SkipUnchangedFiles is not used for that purpose because it will copy if the source and destination
      differ by size too.  Instead, this target uses inputs and outputs to only copy when the source is newer.
      -->
    <Copy SourceFiles="@(_ResolvedFileToPublishPreserveNewest)" DestinationFiles="@(_ResolvedFileToPublishPreserveNewest->'$(PublishDir)%(RelativePath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyResolvedFilesToPublishAlways

    Copy _ResolvedFileToPublishAlways items to the publish directory
    ============================================================
    -->
  <Target Name="_CopyResolvedFilesToPublishAlways" DependsOnTargets="_ComputeResolvedFilesToPublishTypes" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      Use SkipUnchangedFiles to prevent unnecessary file copies. The copy will occur if the
      destination doesn't exist, the source is newer than the destination, or if the source and
      destination differ by file size.
      -->
    <Copy SourceFiles="@(_ResolvedFileToPublishAlways)" DestinationFiles="@(_ResolvedFileToPublishAlways->'$(PublishDir)%(RelativePath)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <UsingTask TaskName="ResolveReadyToRunCompilers" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="ResolveReadyToRunCompilers" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ResolveReadyToRunCompilers RuntimePacks="@(ResolvedRuntimePack)" Crossgen2Packs="@(ResolvedCrossgen2Pack)" TargetingPacks="@(ResolvedTargetingPack)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" NETCoreSdkRuntimeIdentifier="$(NETCoreSdkRuntimeIdentifier)" EmitSymbols="$(PublishReadyToRunEmitSymbols)" ReadyToRunUseCrossgen2="$(PublishReadyToRunUseCrossgen2)" PerfmapFormatVersion="$(PublishReadyToRunPerfmapFormatVersion)">
      <Output TaskParameter="CrossgenTool" ItemName="CrossgenTool" />
      <Output TaskParameter="Crossgen2Tool" ItemName="Crossgen2Tool" />
    </ResolveReadyToRunCompilers>
  </Target>
  <!--
    ============================================================
                                        _ComputeResolvedFilesToPublishTypes

    Splits ResolvedFileToPublish items into 'PreserveNewest' and 'Always' buckets.
    Then further splits those into 'Unbundled' buckets based on the single file setting.
    ============================================================
    -->
  <Target Name="_ComputeResolvedFilesToPublishTypes" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ResolvedFileToPublishPreserveNewest Include="@(ResolvedFileToPublish)" Condition="'%(ResolvedFileToPublish.CopyToPublishDirectory)'=='PreserveNewest'" />
      <_ResolvedFileToPublishAlways Include="@(ResolvedFileToPublish)" Condition="'%(ResolvedFileToPublish.CopyToPublishDirectory)'=='Always'" />
    </ItemGroup>
    <ItemGroup>
      <_ResolvedUnbundledFileToPublishPreserveNewest Include="@(_ResolvedFileToPublishPreserveNewest)" Condition="'$(PublishSingleFile)' != 'true' or&#xA;                               '%(_ResolvedFileToPublishPreserveNewest.ExcludeFromSingleFile)'=='true'" />
      <_ResolvedUnbundledFileToPublishAlways Include="@(_ResolvedFileToPublishAlways)" Condition="'$(PublishSingleFile)' != 'true' or&#xA;                         '%(_ResolvedFileToPublishAlways.ExcludeFromSingleFile)'=='true'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ComputeFilesToPublish

    Gathers all the files that need to be copied to the publish directory, including R2R and ILLinker transformations
    ============================================================
    -->
  <Target Name="ComputeFilesToPublish" DependsOnTargets="PrepareForPublish;&#xA;                            ComputeResolvedFilesToPublishList;&#xA;                            ILLink;&#xA;                            CreateReadyToRunImages;&#xA;                            GeneratePublishDependencyFile;&#xA;                            GenerateSingleFileBundle" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        ILLink

    Initially an empty placeholder target. When trimming, this
    will be redefined to invoke ILLink to perform IL trimming.
    The placeholder exists to allow other targets to depend on it for ordering purposes.
    ============================================================
    -->
  <Target Name="ILLink" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CopyBuildOutputToPublishDirectory Condition="'$(CopyBuildOutputToPublishDirectory)'==''">true</CopyBuildOutputToPublishDirectory>
    <CopyOutputSymbolsToPublishDirectory Condition="'$(CopyOutputSymbolsToPublishDirectory)'==''">true</CopyOutputSymbolsToPublishDirectory>
    <IncludeSymbolsInSingleFile Condition="'$(IncludeSymbolsInSingleFile)' == ''">false</IncludeSymbolsInSingleFile>
  </PropertyGroup>
  <UsingTask TaskName="ResolveOverlappingItemGroupConflicts" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        ComputeResolvedFilesToPublishList

    Gathers all the files that need to be copied to the publish directory.
    ============================================================
    -->
  <Target Name="ComputeResolvedFilesToPublishList" DependsOnTargets="_ComputeResolvedCopyLocalPublishAssets;&#xA;                            _ComputeCopyToPublishDirectoryItems;&#xA;                            ComputeRefAssembliesToPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- Copy the build product (.dll or .exe). -->
      <ResolvedFileToPublish Include="@(IntermediateAssembly)" Condition="'$(CopyBuildOutputToPublishDirectory)' == 'true'">
        <RelativePath>@(IntermediateAssembly->'%(Filename)%(Extension)')</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy the deps file if using the build deps file. -->
      <ResolvedFileToPublish Include="$(ProjectDepsFilePath)" Condition="'$(GenerateDependencyFile)' == 'true' and '$(_UseBuildDependencyFile)' == 'true'">
        <RelativePath>$(ProjectDepsFileName)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy the runtime config file. -->
      <ResolvedFileToPublish Include="$(ProjectRuntimeConfigFilePath)" Condition="'$(GenerateRuntimeConfigurationFiles)' == 'true'  and '$(PublishAot)' != 'true'">
        <RelativePath>$(ProjectRuntimeConfigFileName)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy the app.config (if any) -->
      <ResolvedFileToPublish Include="@(AppConfigWithTargetPath)" Condition="'$(CopyBuildOutputToPublishDirectory)' == 'true'">
        <RelativePath>@(AppConfigWithTargetPath->'%(TargetPath)')</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy the debug information file (.pdb), if any -->
      <ResolvedFileToPublish Include="@(_DebugSymbolsIntermediatePath)" Condition="'$(_DebugSymbolsProduced)'=='true' and '$(CopyOutputSymbolsToPublishDirectory)'=='true'">
        <RelativePath>@(_DebugSymbolsIntermediatePath->'%(Filename)%(Extension)')</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
        <ExcludeFromSingleFile Condition="'$(IncludeSymbolsInSingleFile)'!='true'">true</ExcludeFromSingleFile>
      </ResolvedFileToPublish>
      <!-- Copy satellite assemblies. -->
      <ResolvedFileToPublish Include="@(IntermediateSatelliteAssembliesWithTargetPath)">
        <RelativePath>%(IntermediateSatelliteAssembliesWithTargetPath.Culture)\%(Filename)%(Extension)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy generated COM References. -->
      <ResolvedFileToPublish Include="@(ReferenceComWrappersToCopyLocal)">
        <RelativePath>%(Filename)%(Extension)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
    </ItemGroup>
    <!-- Remove conflicting items that appear in both _ResolvedCopyLocalPublishAssets and ResolvedFileToPublish
         to ensure that we don't get duplicate files in the publish output. -->
    <ResolveOverlappingItemGroupConflicts ItemGroup1="@(_ResolvedCopyLocalPublishAssets-&gt;Distinct())" ItemGroup2="@(ResolvedFileToPublish-&gt;Distinct())" PreferredPackages="$(PackageConflictPreferredPackages)">
      <Output TaskParameter="RemovedItemGroup1" ItemName="_ResolvedCopyLocalPublishAssetsRemoved" />
      <Output TaskParameter="RemovedItemGroup2" ItemName="ResolvedFileToPublishRemoved" />
    </ResolveOverlappingItemGroupConflicts>
    <ItemGroup>
      <_ResolvedCopyLocalPublishAssets Remove="@(_ResolvedCopyLocalPublishAssetsRemoved)" />
      <ResolvedFileToPublish Remove="@(ResolvedFileToPublishRemoved)" />
      <!-- Copy the resolved copy local publish assets. -->
      <ResolvedFileToPublish Include="@(_ResolvedCopyLocalPublishAssets)">
        <RelativePath>%(_ResolvedCopyLocalPublishAssets.DestinationSubDirectory)%(Filename)%(Extension)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy the xml documentation (if enabled) -->
      <ResolvedFileToPublish Include="@(FinalDocFile)" Condition="'$(PublishDocumentationFile)' == 'true'">
        <RelativePath>@(FinalDocFile->'%(Filename)%(Extension)')</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy all PackAsTool shims (if any) -->
      <ResolvedFileToPublish Include="@(_EmbeddedApphostPaths-&gt;Distinct())">
        <RelativePath>shims/%(_EmbeddedApphostPaths.ShimRuntimeIdentifier)/%(_EmbeddedApphostPaths.Filename)%(_EmbeddedApphostPaths.Extension)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Filter files for PublishSingleFiles scenario -->
      <_FilesToDrop Include="@(ResolvedFileToPublish)" Condition="'$(PublishSingleFile)' == 'true' and&#xA;                               '%(ResolvedFileToPublish.DropFromSingleFile)' == 'true'" />
      <ResolvedFileToPublish Remove="@(_FilesToDrop)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _ResolveCopyLocalAssetsForPublish
    Resolves the assets from packages to copy locally for publish.
    We can just use the build's copy local assets if we can reuse the build deps file.
    ============================================================
  -->
  <UsingTask TaskName="ResolveCopyLocalAssets" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_ResolveCopyLocalAssetsForPublish" DependsOnTargets="ResolveLockFileCopyLocalFiles;&#xA;                            _ComputeUseBuildDependencyFile;&#xA;                            _DefaultMicrosoftNETPlatformLibrary;&#xA;                            ResolveRuntimePackAssets;&#xA;                            _ComputePackageReferencePublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- For future: Delete ResolveCopyLocalAssets task.  Need to figure out how to get correct DestinationSubPath for
           PreserveStoreLayout without this task, and how to handle RuntimeStorePackages. -->
    <ResolveCopyLocalAssets AssetsFilePath="$(ProjectAssetsFile)" TargetFramework="$(TargetFramework)" RuntimeIdentifier="$(RuntimeIdentifier)" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeFrameworks="@(RuntimeFramework)" ExcludedPackageReferences="@(_ExcludeFromPublishPackageReference)" RuntimeStorePackages="@(RuntimeStorePackages)" PreserveStoreLayout="$(PreserveStoreLayout)" ResolveRuntimeTargets="$(CopyLocalRuntimeTargetAssets)" IsSelfContained="$(SelfContained)" Condition="'$(PreserveStoreLayout)' == 'true' Or '@(RuntimeStorePackages)' != ''">
      <Output TaskParameter="ResolvedAssets" ItemName="_ResolvedCopyLocalPublishAssets" />
    </ResolveCopyLocalAssets>
    <ItemGroup>
      <_ResolvedCopyLocalPublishAssets Include="@(RuntimePackAsset)" Condition="('$(SelfContained)' == 'true' Or '%(RuntimePackAsset.RuntimePackAlwaysCopyLocal)' == 'true') and '%(RuntimePackAsset.AssetType)' != 'pgodata'" />
    </ItemGroup>
    <ItemGroup Condition="'$(_UseBuildDependencyFile)' != 'true'">
      <!-- Remove the apphost executable from publish copy local assets; we will copy the generated apphost instead -->
      <_ResolvedCopyLocalPublishAssets Remove="@(_NativeRestoredAppHostNETCore)" />
    </ItemGroup>
    <ItemGroup Condition="'$(PreserveStoreLayout)' != 'true' And '@(RuntimeStorePackages)' == ''">
      <_ResolvedCopyLocalPublishAssets Include="@(_ResolvedCopyLocalBuildAssets)" Condition="'%(_ResolvedCopyLocalBuildAssets.CopyToPublishDirectory)' != 'false' " />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _ParseTargetManifestFiles
    Parses the $(TargetManifestFiles) which contains a list of files into @(RuntimeStorePackages) items
    which describes which packages should be excluded from publish since they are contained in the runtime store.
    ============================================================
    -->
  <UsingTask TaskName="ParseTargetManifests" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_ParseTargetManifestFiles" Condition="'$(TargetManifestFiles)' != ''" Returns="@(RuntimeStorePackages)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ParseTargetManifests TargetManifestFiles="$(TargetManifestFiles)">
      <Output TaskParameter="RuntimeStorePackages" ItemName="RuntimeStorePackages" />
    </ParseTargetManifests>
  </Target>
  <!--
    ============================================================
    _FilterSatelliteResourcesForPublish
    Filters the resolved resource assets for build to the given resource languages.
    ============================================================
  -->
  <Target Name="_FilterSatelliteResourcesForPublish" Condition="'$(SatelliteResourceLanguages)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_PublishSatelliteResources Include="@(_ResolvedCopyLocalPublishAssets)" Condition="'%(_ResolvedCopyLocalPublishAssets.AssetType)' == 'resources'" />
    </ItemGroup>
    <JoinItems Left="@(_PublishSatelliteResources)" LeftKey="Culture" LeftMetadata="*" Right="$(SatelliteResourceLanguages)" RightKey="" RightMetadata="" ItemSpecToUse="Left">
      <Output TaskParameter="JoinResult" ItemName="_FilteredPublishSatelliteResources" />
    </JoinItems>
    <ItemGroup Condition="'@(_PublishSatelliteResources)' != ''">
      <_ResolvedCopyLocalPublishAssets Remove="@(_PublishSatelliteResources)" />
      <_ResolvedCopyLocalPublishAssets Include="@(_FilteredPublishSatelliteResources)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _ComputeResolvedCopyLocalPublishAssets
    Computes the files from both project and package references.
    ============================================================
  -->
  <Target Name="_ComputeResolvedCopyLocalPublishAssets" DependsOnTargets="_ResolveCopyLocalAssetsForPublish;&#xA;                            _FilterSatelliteResourcesForPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ResolvedCopyLocalPublishAssets Include="@(ReferenceCopyLocalPaths)" Exclude="@(_ResolvedCopyLocalBuildAssets);@(RuntimePackAsset)" Condition="('$(PublishReferencesDocumentationFiles)' == 'true' or '%(ReferenceCopyLocalPaths.Extension)' != '.xml') and '%(ReferenceCopyLocalPaths.Private)' != 'false'">
        <DestinationSubPath>%(ReferenceCopyLocalPaths.DestinationSubDirectory)%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)</DestinationSubPath>
      </_ResolvedCopyLocalPublishAssets>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CreateSingleFileHost
      Create the single-file host for the publish scenario if app is being published as a self-contained single-file .net5+ app
    ============================================================
     -->
  <Target Name="_CreateSingleFileHost" Inputs="@(IntermediateAssembly);$(SingleFileHostSourcePath)" Outputs="$(SingleFileHostIntermediatePath)" DependsOnTargets="_GetAppHostPaths;_GetAppHostCreationConfiguration" Condition="'$(_UseSingleFileHostForPublish)' == 'true' and&#xA;                     Exists('@(IntermediateAssembly)') and&#xA;                     Exists('$(SingleFileHostSourcePath)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CreateAppHost AppHostSourcePath="$(SingleFileHostSourcePath)" AppHostDestinationPath="$(SingleFileHostIntermediatePath)" AppBinaryName="$(AssemblyName)$(TargetExt)" IntermediateAssembly="@(IntermediateAssembly->'%(FullPath)')" WindowsGraphicalUserInterface="$(_UseWindowsGraphicalUserInterface)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" EnableMacOSCodeSign="$(_EnableMacOSCodeSign)" DisableCetCompat="$(_DisableCetCompat)" />
  </Target>
  <!--
    ============================================================
    _CreateAppHostForPublish
    Create the apphost for the publish scenario if app is configuring .NET install search behaviour
    Because there is no SDK support yet for output with a layout conforming to the configuration,
    only do this on publish, such that the inner dev loop is unaffected.
    ============================================================
     -->
  <Target Name="_CreateAppHostForPublish" Inputs="@(IntermediateAssembly);$(AppHostSourcePath)" Outputs="$(AppHostForPublishIntermediatePath)" DependsOnTargets="_GetAppHostPaths;_GetAppHostCreationConfiguration" Condition="'$(_UpdateAppHostForPublish)' == 'true' and&#xA;                     Exists('@(IntermediateAssembly)') and&#xA;                     Exists('$(AppHostSourcePath)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CreateAppHost AppHostSourcePath="$(AppHostSourcePath)" AppHostDestinationPath="$(AppHostForPublishIntermediatePath)" AppBinaryName="$(AssemblyName)$(TargetExt)" IntermediateAssembly="@(IntermediateAssembly->'%(FullPath)')" WindowsGraphicalUserInterface="$(_UseWindowsGraphicalUserInterface)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" EnableMacOSCodeSign="$(_EnableMacOSCodeSign)" DisableCetCompat="$(_DisableCetCompat)" DotNetSearchLocations="$(AppHostDotNetSearch)" AppRelativeDotNet="$(AppHostRelativeDotNet)" />
  </Target>
  <!--
    ============================================================
                                        _ComputeCopyToPublishDirectoryItems
    ============================================================
    -->
  <Target Name="_ComputeCopyToPublishDirectoryItems" DependsOnTargets="GetCopyToPublishDirectoryItems" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <ResolvedFileToPublish Include="@(_SourceItemsToCopyToPublishDirectoryAlways)">
        <RelativePath>%(_SourceItemsToCopyToPublishDirectoryAlways.TargetPath)</RelativePath>
        <CopyToPublishDirectory>Always</CopyToPublishDirectory>
        <IsKeyOutput Condition="'%(_SourceItemsToCopyToPublishDirectoryAlways.FullPath)' == '$(AppHostIntermediatePath)'">True</IsKeyOutput>
      </ResolvedFileToPublish>
      <ResolvedFileToPublish Include="@(_SourceItemsToCopyToPublishDirectory)">
        <RelativePath>%(_SourceItemsToCopyToPublishDirectory.TargetPath)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
        <IsKeyOutput Condition="'%(_SourceItemsToCopyToPublishDirectory.FullPath)' == '$(AppHostIntermediatePath)'">True</IsKeyOutput>
      </ResolvedFileToPublish>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GetCopyToPublishDirectoryItems

    Get all project items that may need to be transferred to the publish directory.
    This includes baggage items from transitively referenced projects. It would appear
    that this target computes full transitive closure of content items for all referenced
    projects; however that is not the case. It only collects the content items from its
    immediate children and not children of children.

    See comment on GetCopyToOutputDirectoryItems, from which this logic was taken.
    ============================================================
    -->
  <Target Name="GetCopyToPublishDirectoryItems" Returns="@(AllPublishItemsFullPathWithTargetPath)" KeepDuplicateOutputs=" '$(MSBuildDisableGetCopyToPublishDirectoryItemsOptimization)' == '' " DependsOnTargets="AssignTargetPaths;&#xA;                            DefaultCopyToPublishDirectoryMetadata;&#xA;                            _CreateSingleFileHost;&#xA;                            _CreateAppHostForPublish;&#xA;                            _SplitProjectReferencesByFileExistence;&#xA;                            _GetProjectReferenceTargetFrameworkProperties" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- In the general case, clients need very little of the metadata which is generated by invoking this target on this project and its children.  For those
         cases, we can immediately discard the unwanted metadata, reducing memory usage, particularly in very large and interconnected systems of projects.
         However, if some client does require the original functionality, it is sufficient to set MSBuildDisableGetCopyToPublishDirectoryItemsOptimization to
         a non-empty value and the original behavior will be restored. -->
    <PropertyGroup Condition=" '$(MSBuildDisableGetCopyToPublishDirectoryItemsOptimization)' == '' ">
      <_GCTPDIKeepDuplicates>false</_GCTPDIKeepDuplicates>
      <_GCTPDIKeepMetadata>CopyToPublishDirectory;ExcludeFromSingleFile;TargetPath</_GCTPDIKeepMetadata>
    </PropertyGroup>
    <!-- Get items from child projects first. -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetCopyToPublishDirectoryItems" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'@(_MSBuildProjectReferenceExistent)' != '' and '$(_GetChildProjectCopyToPublishDirectoryItems)' == 'true' and '%(_MSBuildProjectReferenceExistent.Private)' != 'false'" ContinueOnError="$(ContinueOnError)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_AllChildProjectPublishItemsWithTargetPath" />
    </MSBuild>
    <!-- Target outputs must be full paths because they will be consumed by a different project. -->
    <ItemGroup>
      <_SourceItemsToCopyToPublishDirectoryAlways KeepDuplicates=" '$(_GCTPDIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(_AllChildProjectPublishItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectPublishItemsWithTargetPath.CopyToPublishDirectory)'=='Always'" />
      <_SourceItemsToCopyToPublishDirectory KeepDuplicates=" '$(_GCTPDIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(_AllChildProjectPublishItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectPublishItemsWithTargetPath.CopyToPublishDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <!-- Remove items which we will never again use - they just sit around taking up memory otherwise -->
    <ItemGroup>
      <_AllChildProjectPublishItemsWithTargetPath Remove="@(_AllChildProjectPublishItemsWithTargetPath)" />
    </ItemGroup>
    <!-- Get items from this project last so that they will be copied last. -->
    <ItemGroup>
      <_SourceItemsToCopyToPublishDirectoryAlways KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToPublishDirectory)'=='Always'" />
      <_SourceItemsToCopyToPublishDirectory KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToPublishDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <ItemGroup>
      <_SourceItemsToCopyToPublishDirectoryAlways KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToPublishDirectory)'=='Always'" />
      <_SourceItemsToCopyToPublishDirectory KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToPublishDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <ItemGroup>
      <_CompileItemsToPublish Include="@(Compile->'%(FullPath)')" Condition="'%(Compile.CopyToPublishDirectory)'=='Always' or '%(Compile.CopyToPublishDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <AssignTargetPath Files="@(_CompileItemsToPublish)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileItemsToPublishWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <_SourceItemsToCopyToPublishDirectoryAlways KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(_CompileItemsToPublishWithTargetPath)" Condition="'%(_CompileItemsToPublishWithTargetPath.CopyToPublishDirectory)'=='Always'" />
      <_SourceItemsToCopyToPublishDirectory KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(_CompileItemsToPublishWithTargetPath)" Condition="'%(_CompileItemsToPublishWithTargetPath.CopyToPublishDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <ItemGroup>
      <_SourceItemsToCopyToPublishDirectoryAlways KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToPublishDirectory)'=='Always'" />
      <_SourceItemsToCopyToPublishDirectory KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToPublishDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <ItemGroup Condition="'$(_UseSingleFileHostForPublish)' == 'true' and Exists('$(SingleFileHostIntermediatePath)')">
      <!-- Remove non-single-file apphost from items to publish -->
      <_SourceItemsToCopyToPublishDirectoryAlways Remove="$(AppHostIntermediatePath)" />
      <_SourceItemsToCopyToPublishDirectory Remove="$(AppHostIntermediatePath)" />
      <!-- Add the single-file host created as part of publish -->
      <_SourceItemsToCopyToPublishDirectoryAlways Include="$(SingleFileHostIntermediatePath)" CopyToOutputDirectory="Always" TargetPath="$(AssemblyName)$(_NativeExecutableExtension)" />
    </ItemGroup>
    <ItemGroup Condition="'$(_UpdateAppHostForPublish)' == 'true' and Exists('$(AppHostForPublishIntermediatePath)')">
      <!-- Remove apphost from build from items to publish -->
      <_SourceItemsToCopyToPublishDirectoryAlways Remove="$(AppHostIntermediatePath)" />
      <_SourceItemsToCopyToPublishDirectory Remove="$(AppHostIntermediatePath)" />
      <!-- Add the apphost created as part of publish -->
      <_SourceItemsToCopyToPublishDirectoryAlways Include="$(AppHostForPublishIntermediatePath)" CopyToOutputDirectory="Always" TargetPath="$(AssemblyName)$(_NativeExecutableExtension)" />
    </ItemGroup>
    <ItemGroup>
      <AllPublishItemsFullPathWithTargetPath Include="@(_SourceItemsToCopyToPublishDirectoryAlways->'%(FullPath)');@(_SourceItemsToCopyToPublishDirectory->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DefaultCopyToPublishDirectoryMetadata

    If CopyToPublishDirectory isn't set on these items, the value should be taken from CopyToOutputDirectory.
    This way, projects can just set "CopyToOutputDirectory = Always/PreserveNewest" and by default the item will be copied
    to both the build output and publish directories.
    ============================================================
    -->
  <Target Name="DefaultCopyToPublishDirectoryMetadata" DependsOnTargets="AssignTargetPaths" Condition=" '$(DefaultCopyToPublishDirectoryMetadata)' == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <ContentWithTargetPath Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' and '%(ContentWithTargetPath.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>Always</CopyToPublishDirectory>
      </ContentWithTargetPath>
      <ContentWithTargetPath Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' and '%(ContentWithTargetPath.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ContentWithTargetPath>
      <EmbeddedResource Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' and '%(EmbeddedResource.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>Always</CopyToPublishDirectory>
      </EmbeddedResource>
      <EmbeddedResource Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' and '%(EmbeddedResource.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </EmbeddedResource>
      <Compile Condition="'%(Compile.CopyToOutputDirectory)'=='Always' and '%(Compile.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>Always</CopyToPublishDirectory>
      </Compile>
      <Compile Condition="'%(Compile.CopyToOutputDirectory)'=='PreserveNewest' and '%(Compile.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </Compile>
      <_NoneWithTargetPath Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' and '%(_NoneWithTargetPath.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>Always</CopyToPublishDirectory>
      </_NoneWithTargetPath>
      <_NoneWithTargetPath Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' and '%(_NoneWithTargetPath.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </_NoneWithTargetPath>
    </ItemGroup>
  </Target>
  <PropertyGroup Condition="'$(SelfContained)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_ComputeManagedRuntimePackAssembliesIfSelfContained>_ComputeManagedRuntimePackAssemblies</_ComputeManagedRuntimePackAssembliesIfSelfContained>
  </PropertyGroup>
  <!-- Determine the managed assembly subset of ResolvedFileToPublish that should be post-processed by linker, and ready to run compilation -->
  <Target Name="_ComputeAssembliesToPostprocessOnPublish" DependsOnTargets="_ComputeUserRuntimeAssemblies;$(_ComputeManagedRuntimePackAssembliesIfSelfContained)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      Default set of files to post-process correspond to the items that would be designated
      as managed runtime assemblies in .deps.json, and published to root of the application.
      RuntimeTargets and satellite assemblies are excluded. Currently, both linker and ready
      to run require a RID, so there will not be RuntimeTargets. Linker could conceptually
      operate without a RID, but would not know how to handle multiple assemblies with same
      identity.
    -->
    <ItemGroup>
      <!-- Assemblies from packages -->
      <_ManagedRuntimeAssembly Include="@(RuntimeCopyLocalItems)" />
      <!-- Assemblies from other references -->
      <_ManagedRuntimeAssembly Include="@(UserRuntimeAssembly)" />
      <!-- Assembly produced by this project -->
      <_ManagedRuntimeAssembly Include="@(IntermediateAssembly)" />
    </ItemGroup>
    <!-- Assemblies from runtime packs for self-contained apps -->
    <ItemGroup Condition="'$(SelfContained)' == 'true'">
      <_ManagedRuntimeAssembly Include="@(_ManagedRuntimePackAssembly)" />
    </ItemGroup>
    <!--
      Match above with ResolvedFileToPublish. Some of above would have been excluded from publish in
      various ways and should be excluded from the list of files to postprocess as well. Furthermore,
      the metadata must match ResolvedFileToPublish as the tools modify or remove these items in that
      list to implement their post-processing.
    -->
    <JoinItems Left="@(_ManagedRuntimeAssembly)" Right="@(ResolvedFileToPublish)" RightMetadata="*">
      <Output TaskParameter="JoinResult" ItemName="_AssemblyToPostprocessOnPublish" />
    </JoinItems>
    <!--
      Set PostprocessAssembly=true metadata on ResolvedFileToPublish, which will be honored by linker
      and crossgen.

      Assemblies injected into ResolvedFileToPublish outside the set above (such as razor views) are
      responsible for setting this metadata to opt in to post-processing.
    -->
    <ItemGroup>
      <ResolvedFileToPublish Remove="@(_AssemblyToPostprocessOnPublish)" />
      <ResolvedFileToPublish Include="@(_AssemblyToPostprocessOnPublish)" PostprocessAssembly="true" />
    </ItemGroup>
  </Target>
  <Target Name="_ComputeManagedRuntimePackAssemblies" Returns="@(_ManagedRuntimePackAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- Special case for System.Private.Corelib due to https://github.com/dotnet/core-setup/issues/7728 -->
      <_ManagedRuntimePackAssembly Include="@(RuntimePackAsset)" Condition="'%(RuntimePackAsset.AssetType)' == 'runtime'&#xA;                                                or '%(RuntimePackAsset.Filename)' == 'System.Private.Corelib'" />
    </ItemGroup>
  </Target>
  <Target Name="_ComputeUseBuildDependencyFile" DependsOnTargets="_ComputePackageReferencePublish;&#xA;                            _ParseTargetManifestFiles" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Check to see whether we can re-use the .deps.json file from the build for publish, or whether we have to
         generate a different one. -->
    <PropertyGroup>
      <_TrimRuntimeAssets Condition="'$(PublishSingleFile)' == 'true' and '$(SelfContained)' == 'true'">true</_TrimRuntimeAssets>
      <_UseBuildDependencyFile Condition="'@(_ExcludeFromPublishPackageReference)' == '' and&#xA;                                          '@(RuntimeStorePackages)' == '' and&#xA;                                          '$(PreserveStoreLayout)' != 'true' and&#xA;                                          '$(PublishTrimmed)' != 'true' and&#xA;                                          '$(_TrimRuntimeAssets)' != 'true'">true</_UseBuildDependencyFile>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateSingleFileBundle

    Bundle the ResolvedFileToPublish items into one file in PublishDir
    (except those marked ExcludeFromSingleFile)
    ============================================================
    -->
  <Target Name="_ComputeFilesToBundle" DependsOnTargets="_HandleFileConflictsForPublish" Condition="'$(PublishSingleFile)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_FilesToBundle Include="@(ResolvedFileToPublish)" Condition="'%(ResolvedFileToPublish.ExcludeFromSingleFile)' != 'true'" />
      <ResolvedFileToPublish Remove="@(_FilesToBundle)" />
    </ItemGroup>
    <PropertyGroup>
      <PublishedSingleFileName>$(AssemblyName)$(_NativeExecutableExtension)</PublishedSingleFileName>
      <PublishedSingleFilePath>$(PublishDir)$(PublishedSingleFileName)</PublishedSingleFilePath>
    </PropertyGroup>
  </Target>
  <Target Name="PrepareForBundle" DependsOnTargets="_ComputeFilesToBundle" Condition="'$(PublishSingleFile)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <FilesToBundle Include="@(_FilesToBundle)" />
    </ItemGroup>
    <PropertyGroup>
      <AppHostFile>$(PublishedSingleFileName)</AppHostFile>
    </PropertyGroup>
  </Target>
  <Target Name="_GenerateSingleFileBundleInputCache" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(PublishedSingleFilePath)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(TraceSingleFileBundler)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(IncludeSymbolsInSingleFile)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(IncludeAllContentForSelfExtract)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(IncludeNativeLibrariesForSelfExtract)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(EnableCompressionInSingleFile)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(PublishedSingleFileName)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(RuntimeIdentifier)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(PublishDir)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(_TargetFrameworkVersionWithoutV)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="@(FilesToBundle)" />
    </ItemGroup>
    <Hash ItemsToHash="@(_GenerateSingleFileBundlePropertyInputsCacheToHash)">
      <Output TaskParameter="HashResult" PropertyName="_GenerateSingleFileBundlePropertyInputsCacheHash" />
    </Hash>
    <WriteLinesToFile Lines="$(_GenerateSingleFileBundlePropertyInputsCacheHash)" File="$(_GenerateSingleFileBundlePropertyInputsCache)" Overwrite="true" WriteOnlyWhenDifferent="true" />
  </Target>
  <UsingTask TaskName="GenerateBundle" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="GenerateSingleFileBundle" Condition="'$(PublishSingleFile)' == 'true' and '$(PublishAot)' != 'true'" DependsOnTargets="_ComputeFilesToBundle;PrepareForBundle;_GenerateSingleFileBundleInputCache" Inputs="@(FilesToBundle);$(_GenerateSingleFileBundlePropertyInputsCache)" Outputs="$(PublishedSingleFilePath)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <TraceSingleFileBundler Condition="'$(TraceSingleFileBundler)' == ''">false</TraceSingleFileBundler>
      <IncludeSymbolsInSingleFile Condition="'$(IncludeSymbolsInSingleFile)' == ''">false</IncludeSymbolsInSingleFile>
      <IncludeAllContentForSelfExtract Condition="'$(IncludeAllContentForSelfExtract)' == ''">false</IncludeAllContentForSelfExtract>
      <IncludeNativeLibrariesForSelfExtract Condition="'$(IncludeNativeLibrariesForSelfExtract)' == ''">$(IncludeAllContentForSelfExtract)</IncludeNativeLibrariesForSelfExtract>
      <EnableCompressionInSingleFile Condition="'$(EnableCompressionInSingleFile)' == ''">false</EnableCompressionInSingleFile>
    </PropertyGroup>
    <NETSdkError Condition="'$(IncludeAllContentForSelfExtract)' == 'true' And '$(IncludeNativeLibrariesForSelfExtract)' != 'true'" ResourceName="CannotIncludeAllContentButNotNativeLibrariesInSingleFile" />
    <GenerateBundle FilesToBundle="@(FilesToBundle)" AppHostName="$(PublishedSingleFileName)" IncludeSymbols="$(IncludeSymbolsInSingleFile)" EnableCompressionInSingleFile="$(EnableCompressionInSingleFile)" IncludeNativeLibraries="$(IncludeNativeLibrariesForSelfExtract)" IncludeAllContent="$(IncludeAllContentForSelfExtract)" TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)" RuntimeIdentifier="$(RuntimeIdentifier)" OutputDir="$(PublishDir)" ShowDiagnosticOutput="$(TraceSingleFileBundler)" EnableMacOSCodeSign="$(_EnableMacOSCodeSign)">
      <Output TaskParameter="ExcludedFiles" ItemName="_FilesExcludedFromBundle" />
    </GenerateBundle>
    <ItemGroup>
      <ResolvedFileToPublish Include="@(_FilesExcludedFromBundle)" />
      <!-- ResolvedFileToPublish shouldn't include PublishedSingleFilePath, since the single-file bundle is written directly to the publish directory -->
    </ItemGroup>
  </Target>
  <Target Name="_ComputeIntermediateDepsFilePath" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <!-- IntermediateDepsFilePath is the location where the deps.json file is originally created -->
      <IntermediateDepsFilePath Condition=" '$(PublishDepsFilePath)' != ''">$(PublishDepsFilePath)</IntermediateDepsFilePath>
      <IntermediateDepsFilePath Condition=" '$(PublishDepsFilePath)' == ''">$(IntermediateOutputPath)$(ProjectDepsFileName)</IntermediateDepsFilePath>
    </PropertyGroup>
  </Target>
  <Target Name="_GeneratePublishDependencyFileInputCache" DependsOnTargets="_ComputeIntermediateDepsFilePath" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(PublishDepsFilePath)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(PublishSingleFile)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(MSBuildProjectFullPath)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(ProjectAssetsFile)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(IntermediateDepsFilePath)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(TargetFramework)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(AssemblyName)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(TargetExt)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(Version)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(IncludeMainProjectInDepsFile)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(RuntimeIdentifier)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(MicrosoftNETPlatformLibrary)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(SelfContained)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(IncludeFileVersionsInDependencyFile)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(RuntimeIdentifierGraphPath)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(IncludeProjectsNotInAssetsFileInDepsFile)" />
    </ItemGroup>
    <Hash ItemsToHash="@(_GeneratePublishDependencyFilePropertyInputsCacheToHash)">
      <Output TaskParameter="HashResult" PropertyName="_GeneratePublishDependencyFilePropertyInputsCacheHash" />
    </Hash>
    <WriteLinesToFile Lines="$(_GeneratePublishDependencyFilePropertyInputsCacheHash)" File="$(_GeneratePublishDependencyFilePropertyInputsCache)" Overwrite="True" WriteOnlyWhenDifferent="True" />
    <ItemGroup>
      <FileWrites Include="$(_GeneratePublishDependencyFilePropertyInputsCache)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GeneratePublishDependencyFile
    Generates the $(project).deps.json file for a published app
    ============================================================
    -->
  <Target Name="GeneratePublishDependencyFile" DependsOnTargets="_ComputeUseBuildDependencyFile;&#xA;                            _ComputeIntermediateDepsFilePath;&#xA;                            _DefaultMicrosoftNETPlatformLibrary;&#xA;                            _HandlePackageFileConflicts;&#xA;                            _HandlePackageFileConflictsForPublish;&#xA;                            _ComputeReferenceAssemblies;&#xA;                            _ComputeUserRuntimeAssemblies;&#xA;                            ResolveRuntimePackAssets;&#xA;                            _ComputePackageReferencePublish;&#xA;                            _GeneratePublishDependencyFileInputCache" Condition="'$(GenerateDependencyFile)' == 'true' and '$(_UseBuildDependencyFile)' != 'true' and '$(PublishAot)' != 'true'" Inputs="$(ProjectAssetsFile);$(ProjectAssetsCacheFile);$(MSBuildAllProjects);$(_GeneratePublishDependencyFilePropertyInputsCache)" Outputs="$(IntermediateDepsFilePath)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <!-- PublishDepsFilePath is the location where the deps.json resides when published
           PublishDepsFilePath is empty (by default) for PublishSingleFile, since the deps.json file is embedded within the single-file bundle -->
      <PublishDepsFilePath Condition=" '$(PublishDepsFilePath)' == '' And '$(PublishSingleFile)' != 'true'">$(PublishDir)$(ProjectDepsFileName)</PublishDepsFilePath>
      <_IsSingleFilePublish Condition="'$(PublishSingleFile)' == ''">false</_IsSingleFilePublish>
      <_IsSingleFilePublish Condition="'$(PublishSingleFile)' != ''">$(PublishSingleFile)</_IsSingleFilePublish>
    </PropertyGroup>
    <ItemGroup>
      <ResolvedCompileFileDefinitions Remove="@(_PublishConflictPackageFiles)" Condition="'%(_PublishConflictPackageFiles.ConflictItemType)' == 'Reference'" />
      <RuntimeTargetsCopyLocalItems Remove="@(_PublishConflictPackageFiles)" Condition="'%(_PublishConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <RuntimePackAsset Remove="@(_PublishConflictPackageFiles)" Condition="'%(_PublishConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <_ResolvedNuGetFilesForPublish Include="@(NativeCopyLocalItems)" Condition="'%(NativeCopyLocalItems.CopyToPublishDirectory)' != 'false'" />
      <_ResolvedNuGetFilesForPublish Include="@(ResourceCopyLocalItems)" Condition="'%(ResourceCopyLocalItems.CopyToPublishDirectory)' != 'false'" />
      <_ResolvedNuGetFilesForPublish Include="@(RuntimeCopyLocalItems)" Condition="'%(RuntimeCopyLocalItems.CopyToPublishDirectory)' != 'false'" />
      <_ResolvedNuGetFilesForPublish Remove="@(_PublishConflictPackageFiles)" Condition="'%(_PublishConflictPackageFiles.ConflictItemType)' != 'Reference'" />
    </ItemGroup>
    <GenerateDepsFile ProjectPath="$(MSBuildProjectFullPath)" AssetsFilePath="$(ProjectAssetsFile)" DepsFilePath="$(IntermediateDepsFilePath)" TargetFramework="$(TargetFramework)" AssemblyName="$(AssemblyName)" AssemblyExtension="$(TargetExt)" AssemblyVersion="$(Version)" AssemblySatelliteAssemblies="@(IntermediateSatelliteAssembliesWithTargetPath)" ReferencePaths="@(ReferencePath)" ReferenceDependencyPaths="@(ReferenceDependencyPaths)" ReferenceSatellitePaths="@(ReferenceSatellitePaths)" ReferenceAssemblies="@(_ReferenceAssemblies)" RuntimePackAssets="@(RuntimePackAsset)" IncludeMainProject="$(IncludeMainProjectInDepsFile)" TrimDepsJsonLibrariesWithoutAssets="$(TrimDepsJsonLibrariesWithoutAssets)" RuntimeIdentifier="$(RuntimeIdentifier)" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeFrameworks="@(RuntimeFramework)" CompilerOptions="@(DependencyFileCompilerOptions)" RuntimeStorePackages="@(RuntimeStorePackages)" CompileReferences="@(ResolvedCompileFileDefinitions)" ResolvedNuGetFiles="@(_ResolvedNuGetFilesForPublish)" ResolvedRuntimeTargetsFiles="@(RuntimeTargetsCopyLocalItems)" UserRuntimeAssemblies="@(UserRuntimeAssembly)" IsSelfContained="$(SelfContained)" IsSingleFile="$(_IsSingleFilePublish)" IncludeRuntimeFileVersions="$(IncludeFileVersionsInDependencyFile)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" IncludeProjectsNotInAssetsFile="$(IncludeProjectsNotInAssetsFileInDepsFile)" />
    <ItemGroup>
      <ResolvedFileToPublish Include="$(IntermediateDepsFilePath)">
        <RelativePath>$(ProjectDepsFileName)</RelativePath>
      </ResolvedFileToPublish>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ComputeEmbeddedApphostPaths

    When no build flag is set, EmbeddedApphostPaths is not available. Compute EmbeddedApphostPaths is required to find build asset.
    ============================================================
    -->
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.GetEmbeddedApphostPaths" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="ComputeEmbeddedApphostPaths" Condition="'$(PackAsTool)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_PackAsToolShimRuntimeIdentifiers Condition="@(_PackAsToolShimRuntimeIdentifiers) ==''" Include="$(PackAsToolShimRuntimeIdentifiers)" />
    </ItemGroup>
    <GetEmbeddedApphostPaths PackagedShimOutputDirectory="$([MSBuild]::NormalizeDirectory($(PackagedShimOutputRootDirectory), 'shims', $(TargetFramework)))" ShimRuntimeIdentifiers="@(_PackAsToolShimRuntimeIdentifiers)" ToolCommandName="$(ToolCommandName)">
      <Output TaskParameter="EmbeddedApphostPaths" ItemName="_EmbeddedApphostPaths" />
    </GetEmbeddedApphostPaths>
  </Target>
  <!--
    ============================================================
                                            ComputeFilesCopiedToPublishDir

    Gathers all the files that will be copied to the publish directory.  This is used by wapproj and is required for back compat.
    ============================================================
    -->
  <Target Name="ComputeFilesCopiedToPublishDir" DependsOnTargets="ComputeResolvedFilesToPublishList;&#xA;                            _ComputeFilesToBundle" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <FilesCopiedToPublishDir Include="@(ResolvedFileToPublish)" />
      <FilesCopiedToPublishDir Include="$(PublishedSingleFilePath)" RelativePath="$(PublishedSingleFileName)" IsKeyOutput="true" Condition="'$(PublishSingleFile)' == 'true'" />
      <!-- Wapproj handles adding the correct deps.json file, so remove it here to avoid duplicates. -->
      <FilesCopiedToPublishDir Remove="@(FilesCopiedToPublishDir)" Condition="'%(FilesCopiedToPublishDir.Filename)%(FilesCopiedToPublishDir.Extension)' == '$(ProjectDepsFileName)'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                            PublishItemsOutputGroup

    Emit an output group containing all files that get published.  This will be consumed by VS installer projects.
    ============================================================
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PublishItemsOutputGroupDependsOn>
      $(PublishItemsOutputGroupDependsOn);
      ResolveReferences;
      ComputeResolvedFilesToPublishList;
      _ComputeFilesToBundle;
    </PublishItemsOutputGroupDependsOn>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.GetPublishItemsOutputGroupOutputs" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="PublishItemsOutputGroup" DependsOnTargets="$(PublishItemsOutputGroupDependsOn)" Returns="@(PublishItemsOutputGroupOutputs)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GetPublishItemsOutputGroupOutputs ResolvedFileToPublish="@(ResolvedFileToPublish)" PublishDir="$(PublishDir)">
      <Output TaskParameter="PublishItemsOutputGroupOutputs" ItemName="PublishItemsOutputGroupOutputs" />
    </GetPublishItemsOutputGroupOutputs>
    <ItemGroup>
      <PublishItemsOutputGroupOutputs Include="$(PublishedSingleFilePath)" TargetPath="$(PublishedSingleFileName)" IsKeyOutput="true" Condition="'$(PublishSingleFile)' == 'true'" OutputPath="$(PublishedSingleFilePath)" OutputGroup="PublishItemsOutputGroup" />
    </ItemGroup>
  </Target>
  <!--
    This target exists for back-compat with Azure Functions SDK: https://github.com/dotnet/cli/issues/10363
    Because build copy-local now behaves the same as publish with respect to package dependency resolution,
    the Azure Functions SDK doesn't need to resolve publish assets for build.
    TODO: Remove this target when no longer needed as a workaround.
    -->
  <Target Name="RunResolvePublishAssemblies" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
    _CheckForLanguageAndPublishFeatureCombinationSupport

    Block unsupported language and feature combination.
    ============================================================
    -->
  <Target Name="_CheckForLanguageAndPublishFeatureCombinationSupport" Condition="$(IsPublishable) == 'true'" BeforeTargets="Publish;PrepareForPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true') and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" ResourceName="NoSupportCppPublishDotnetCore" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PackStubs.targets" Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true')" />-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PackTool.targets" Condition="'$(PackAsTool)' == 'true'" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PackProjectTool.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.PackProjectTool.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.PackProjectTool.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <Target Name="_PackProjectToolValidation" Condition=" '$(PackageType)' == 'DotnetCliTool'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &gt; '2.2' " ResourceName="ProjectToolOnlySupportTFMLowerThanNetcoreapp22" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PreserveCompilationContext.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.PreserveCompilationContext.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.PreserveCompilationContext.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RefAssembliesFolderName Condition="'$(RefAssembliesFolderName)' == ''">refs</RefAssembliesFolderName>
    <PreserveCompilationReferences Condition=" '$(PreserveCompilationReferences)' == ''">$(PreserveCompilationContext)</PreserveCompilationReferences>
  </PropertyGroup>
  <Target Name="ComputeDependencyFileCompilerOptions" Condition="'$(PreserveCompilationContext)' == 'true'" BeforeTargets="GenerateBuildDependencyFile;&#xA;                         GeneratePublishDependencyFile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <DependencyFileCompilerOptions Include="CompilerOptions">
        <DefineConstants>$(DefineConstants)</DefineConstants>
        <LangVersion>$(LangVersion)</LangVersion>
        <PlatformTarget>$(PlatformTarget)</PlatformTarget>
        <AllowUnsafeBlocks>$(AllowUnsafeBlocks)</AllowUnsafeBlocks>
        <TreatWarningsAsErrors>$(TreatWarningsAsErrors)</TreatWarningsAsErrors>
        <Optimize>$(Optimize)</Optimize>
        <AssemblyOriginatorKeyFile>$(AssemblyOriginatorKeyFile)</AssemblyOriginatorKeyFile>
        <DelaySign>$(DelaySign)</DelaySign>
        <PublicSign>$(PublicSign)</PublicSign>
        <DebugType>$(DebugType)</DebugType>
        <OutputType>$(OutputType)</OutputType>
        <GenerateDocumentationFile>$(GenerateDocumentationFile)</GenerateDocumentationFile>
      </DependencyFileCompilerOptions>
    </ItemGroup>
  </Target>
  <UsingTask TaskName="FindItemsFromPackages" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="ComputeRefAssembliesToPublish" Condition="'$(PreserveCompilationReferences)' == 'true'" DependsOnTargets="ResolvePackageAssets;&#xA;                            _ParseTargetManifestFiles" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <FindItemsFromPackages Items="@(RuntimeCopyLocalItems)" Packages="@(RuntimeStorePackages)">
      <Output TaskParameter="ItemsFromPackages" ItemName="_RuntimeItemsInRuntimeStore" />
    </FindItemsFromPackages>
    <ItemGroup>
      <!--
      Don't copy a compilation assembly if it's also a runtime assembly. There is no need to copy the same
      assembly to the 'refs' folder, if it is already in the publish directory.
      -->
      <_RefAssembliesToExclude Include="@(_ResolvedCopyLocalPublishAssets->'%(FullPath)')" />
      <!--
      Similarly, don't copy a compilation assembly if it's also a runtime assembly that is in a runtime store.
      It will be resolved from the runtime store directory at runtime.
      -->
      <_RefAssembliesToExclude Include="@(_RuntimeItemsInRuntimeStore)" />
      <ResolvedFileToPublish Include="@(ReferencePath)" Exclude="@(_RefAssembliesToExclude)">
        <RelativePath>$(RefAssembliesFolderName)\%(Filename)%(Extension)</RelativePath>
      </ResolvedFileToPublish>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CopyReferenceOnlyAssembliesForBuild

    Copies reference assemblies that normally can't be resolved at runtime to the 'refs' folder in the build output.
    This is necessary in order for the running app to resolve these reference assemblies.
    ============================================================
    -->
  <Target Name="_CopyReferenceOnlyAssembliesForBuild" Condition="'$(PreserveCompilationReferences)' == 'true'" DependsOnTargets="_ComputeReferenceAssemblies" AfterTargets="CopyFilesToOutputDirectory" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Copy SourceFiles="@(_ReferenceOnlyAssemblies)" DestinationFolder="$(OutDir)$(RefAssembliesFolderName)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.ConflictResolution.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ConflictResolution.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ConflictResolution.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.DefaultPackageConflictOverrides.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DefaultPackageConflictOverrides.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DefaultPackageConflictOverrides.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <ItemGroup Condition="'$(DisableDefaultPackageConflictOverrides)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PackageConflictOverrides Include="Microsoft.NETCore.App" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And ('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &lt; '3.0')">
      <OverriddenPackages>
        Microsoft.CSharp|4.4.0;
        Microsoft.Win32.Primitives|4.3.0;
        Microsoft.Win32.Registry|4.4.0;
        runtime.debian.8-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.fedora.23-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.fedora.24-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.opensuse.13.2-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.opensuse.42.1-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.osx.10.10-x64.runtime.native.System.Security.Cryptography.Apple|4.3.0;
        runtime.osx.10.10-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.rhel.7-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.ubuntu.14.04-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.ubuntu.16.04-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.ubuntu.16.10-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        System.AppContext|4.3.0;
        System.Buffers|4.4.0;
        System.Collections|4.3.0;
        System.Collections.Concurrent|4.3.0;
        System.Collections.Immutable|1.4.0;
        System.Collections.NonGeneric|4.3.0;
        System.Collections.Specialized|4.3.0;
        System.ComponentModel|4.3.0;
        System.ComponentModel.EventBasedAsync|4.3.0;
        System.ComponentModel.Primitives|4.3.0;
        System.ComponentModel.TypeConverter|4.3.0;
        System.Console|4.3.0;
        System.Data.Common|4.3.0;
        System.Diagnostics.Contracts|4.3.0;
        System.Diagnostics.Debug|4.3.0;
        System.Diagnostics.DiagnosticSource|4.4.0;
        System.Diagnostics.FileVersionInfo|4.3.0;
        System.Diagnostics.Process|4.3.0;
        System.Diagnostics.StackTrace|4.3.0;
        System.Diagnostics.TextWriterTraceListener|4.3.0;
        System.Diagnostics.Tools|4.3.0;
        System.Diagnostics.TraceSource|4.3.0;
        System.Diagnostics.Tracing|4.3.0;
        System.Dynamic.Runtime|4.3.0;
        System.Globalization|4.3.0;
        System.Globalization.Calendars|4.3.0;
        System.Globalization.Extensions|4.3.0;
        System.IO|4.3.0;
        System.IO.Compression|4.3.0;
        System.IO.Compression.ZipFile|4.3.0;
        System.IO.FileSystem|4.3.0;
        System.IO.FileSystem.AccessControl|4.4.0;
        System.IO.FileSystem.DriveInfo|4.3.0;
        System.IO.FileSystem.Primitives|4.3.0;
        System.IO.FileSystem.Watcher|4.3.0;
        System.IO.IsolatedStorage|4.3.0;
        System.IO.MemoryMappedFiles|4.3.0;
        System.IO.Pipes|4.3.0;
        System.IO.UnmanagedMemoryStream|4.3.0;
        System.Linq|4.3.0;
        System.Linq.Expressions|4.3.0;
        System.Linq.Queryable|4.3.0;
        System.Net.Http|4.3.0;
        System.Net.NameResolution|4.3.0;
        System.Net.Primitives|4.3.0;
        System.Net.Requests|4.3.0;
        System.Net.Security|4.3.0;
        System.Net.Sockets|4.3.0;
        System.Net.WebHeaderCollection|4.3.0;
        System.ObjectModel|4.3.0;
        System.Private.DataContractSerialization|4.3.0;
        System.Reflection|4.3.0;
        System.Reflection.Emit|4.3.0;
        System.Reflection.Emit.ILGeneration|4.3.0;
        System.Reflection.Emit.Lightweight|4.3.0;
        System.Reflection.Extensions|4.3.0;
        System.Reflection.Metadata|1.5.0;
        System.Reflection.Primitives|4.3.0;
        System.Reflection.TypeExtensions|4.3.0;
        System.Resources.ResourceManager|4.3.0;
        System.Runtime|4.3.0;
        System.Runtime.Extensions|4.3.0;
        System.Runtime.Handles|4.3.0;
        System.Runtime.InteropServices|4.3.0;
        System.Runtime.InteropServices.RuntimeInformation|4.3.0;
        System.Runtime.Loader|4.3.0;
        System.Runtime.Numerics|4.3.0;
        System.Runtime.Serialization.Formatters|4.3.0;
        System.Runtime.Serialization.Json|4.3.0;
        System.Runtime.Serialization.Primitives|4.3.0;
        System.Security.AccessControl|4.4.0;
        System.Security.Claims|4.3.0;
        System.Security.Cryptography.Algorithms|4.3.0;
        System.Security.Cryptography.Cng|4.4.0;
        System.Security.Cryptography.Csp|4.3.0;
        System.Security.Cryptography.Encoding|4.3.0;
        System.Security.Cryptography.OpenSsl|4.4.0;
        System.Security.Cryptography.Primitives|4.3.0;
        System.Security.Cryptography.X509Certificates|4.3.0;
        System.Security.Cryptography.Xml|4.4.0;
        System.Security.Principal|4.3.0;
        System.Security.Principal.Windows|4.4.0;
        System.Text.Encoding|4.3.0;
        System.Text.Encoding.Extensions|4.3.0;
        System.Text.RegularExpressions|4.3.0;
        System.Threading|4.3.0;
        System.Threading.Overlapped|4.3.0;
        System.Threading.Tasks|4.3.0;
        System.Threading.Tasks.Extensions|4.3.0;
        System.Threading.Tasks.Parallel|4.3.0;
        System.Threading.Thread|4.3.0;
        System.Threading.ThreadPool|4.3.0;
        System.Threading.Timer|4.3.0;
        System.ValueTuple|4.3.0;
        System.Xml.ReaderWriter|4.3.0;
        System.Xml.XDocument|4.3.0;
        System.Xml.XmlDocument|4.3.0;
        System.Xml.XmlSerializer|4.3.0;
        System.Xml.XPath|4.3.0;
        System.Xml.XPath.XDocument|4.3.0;
      </OverriddenPackages>
    </PackageConflictOverrides>
    <PackageConflictOverrides Include="NETStandard.Library">
      <OverriddenPackages>
        Microsoft.Win32.Primitives|4.3.0;
        System.AppContext|4.3.0;
        System.Collections|4.3.0;
        System.Collections.Concurrent|4.3.0;
        System.Collections.Immutable|1.4.0;
        System.Collections.NonGeneric|4.3.0;
        System.Collections.Specialized|4.3.0;
        System.ComponentModel|4.3.0;
        System.ComponentModel.EventBasedAsync|4.3.0;
        System.ComponentModel.Primitives|4.3.0;
        System.ComponentModel.TypeConverter|4.3.0;
        System.Console|4.3.0;
        System.Data.Common|4.3.0;
        System.Diagnostics.Contracts|4.3.0;
        System.Diagnostics.Debug|4.3.0;
        System.Diagnostics.FileVersionInfo|4.3.0;
        System.Diagnostics.Process|4.3.0;
        System.Diagnostics.StackTrace|4.3.0;
        System.Diagnostics.TextWriterTraceListener|4.3.0;
        System.Diagnostics.Tools|4.3.0;
        System.Diagnostics.TraceSource|4.3.0;
        System.Diagnostics.Tracing|4.3.0;
        System.Dynamic.Runtime|4.3.0;
        System.Globalization|4.3.0;
        System.Globalization.Calendars|4.3.0;
        System.Globalization.Extensions|4.3.0;
        System.IO|4.3.0;
        System.IO.Compression|4.3.0;
        System.IO.Compression.ZipFile|4.3.0;
        System.IO.FileSystem|4.3.0;
        System.IO.FileSystem.DriveInfo|4.3.0;
        System.IO.FileSystem.Primitives|4.3.0;
        System.IO.FileSystem.Watcher|4.3.0;
        System.IO.IsolatedStorage|4.3.0;
        System.IO.MemoryMappedFiles|4.3.0;
        System.IO.Pipes|4.3.0;
        System.IO.UnmanagedMemoryStream|4.3.0;
        System.Linq|4.3.0;
        System.Linq.Expressions|4.3.0;
        System.Linq.Queryable|4.3.0;
        System.Net.Http|4.3.0;
        System.Net.NameResolution|4.3.0;
        System.Net.Primitives|4.3.0;
        System.Net.Requests|4.3.0;
        System.Net.Security|4.3.0;
        System.Net.Sockets|4.3.0;
        System.Net.WebHeaderCollection|4.3.0;
        System.ObjectModel|4.3.0;
        System.Private.DataContractSerialization|4.3.0;
        System.Reflection|4.3.0;
        System.Reflection.Emit|4.3.0;
        System.Reflection.Emit.ILGeneration|4.3.0;
        System.Reflection.Emit.Lightweight|4.3.0;
        System.Reflection.Extensions|4.3.0;
        System.Reflection.Primitives|4.3.0;
        System.Reflection.TypeExtensions|4.3.0;
        System.Resources.ResourceManager|4.3.0;
        System.Runtime|4.3.0;
        System.Runtime.Extensions|4.3.0;
        System.Runtime.Handles|4.3.0;
        System.Runtime.InteropServices|4.3.0;
        System.Runtime.InteropServices.RuntimeInformation|4.3.0;
        System.Runtime.Loader|4.3.0;
        System.Runtime.Numerics|4.3.0;
        System.Runtime.Serialization.Formatters|4.3.0;
        System.Runtime.Serialization.Json|4.3.0;
        System.Runtime.Serialization.Primitives|4.3.0;
        System.Security.AccessControl|4.4.0;
        System.Security.Claims|4.3.0;
        System.Security.Cryptography.Algorithms|4.3.0;
        System.Security.Cryptography.Csp|4.3.0;
        System.Security.Cryptography.Encoding|4.3.0;
        System.Security.Cryptography.Primitives|4.3.0;
        System.Security.Cryptography.X509Certificates|4.3.0;
        System.Security.Cryptography.Xml|4.4.0;
        System.Security.Principal|4.3.0;
        System.Security.Principal.Windows|4.4.0;
        System.Text.Encoding|4.3.0;
        System.Text.Encoding.Extensions|4.3.0;
        System.Text.RegularExpressions|4.3.0;
        System.Threading|4.3.0;
        System.Threading.Overlapped|4.3.0;
        System.Threading.Tasks|4.3.0;
        System.Threading.Tasks.Extensions|4.3.0;
        System.Threading.Tasks.Parallel|4.3.0;
        System.Threading.Thread|4.3.0;
        System.Threading.ThreadPool|4.3.0;
        System.Threading.Timer|4.3.0;
        System.ValueTuple|4.3.0;
        System.Xml.ReaderWriter|4.3.0;
        System.Xml.XDocument|4.3.0;
        System.Xml.XmlDocument|4.3.0;
        System.Xml.XmlSerializer|4.3.0;
        System.Xml.XPath|4.3.0;
        System.Xml.XPath.XDocument|4.3.0;
      </OverriddenPackages>
    </PackageConflictOverrides>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ConflictResolution.targets
============================================================================================================================================
-->
  <UsingTask TaskName="ResolvePackageFileConflicts" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="CheckForDuplicateItemMetadata" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    _HandlePackageFileConflicts
    Handles package file conflict resolution for build.
    This will differ from the conflict resolution at publish time if the publish assets differ from build.
  -->
  <Target Name="_HandlePackageFileConflicts" DependsOnTargets="GetFrameworkPaths;GetReferenceAssemblyPaths;ResolveTargetingPackAssets" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!--
        All runtime assets for conflict resolution.
        Exclude the copy-local items since those are passed in separately.
      -->
      <_RuntimeAssetsForConflictResolution Include="@(RuntimeCopyLocalItems);&#xA;                 @(NativeCopyLocalItems);&#xA;                 @(ResourceCopyLocalItems);&#xA;                 @(RuntimeTargetsCopyLocalItems)" Exclude="@(ReferenceCopyLocalPaths)" />
    </ItemGroup>
    <ResolvePackageFileConflicts References="@(Reference)" Analyzers="@(Analyzer)" ReferenceCopyLocalPaths="@(ReferenceCopyLocalPaths)" OtherRuntimeItems="@(_RuntimeAssetsForConflictResolution)" PlatformManifests="@(PackageConflictPlatformManifests)" TargetFrameworkDirectories="$(TargetFrameworkDirectory)" PackageOverrides="@(PackageConflictOverrides)" PreferredPackages="$(PackageConflictPreferredPackages)">
      <Output TaskParameter="ReferencesWithoutConflicts" ItemName="_ReferencesWithoutConflicts" />
      <Output TaskParameter="AnalyzersWithoutConflicts" ItemName="_AnalyzersWithoutConflicts" />
      <Output TaskParameter="ReferenceCopyLocalPathsWithoutConflicts" ItemName="_ReferenceCopyLocalPathsWithoutConflicts" />
      <Output TaskParameter="Conflicts" ItemName="_ConflictPackageFiles" />
    </ResolvePackageFileConflicts>
    <!-- Replace Reference / ReferenceCopyLocalPaths with the filtered lists.
         We must remove all and include rather than just remove since removal is based
         only on ItemSpec and duplicate ItemSpecs may exist with different metadata
         (eg: HintPath) -->
    <ItemGroup>
      <Reference Remove="@(Reference)" />
      <Reference Include="@(_ReferencesWithoutConflicts)" />
      <Analyzer Remove="@(Analyzer)" />
      <Analyzer Include="@(_AnalyzersWithoutConflicts)" />
      <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" />
      <ReferenceCopyLocalPaths Include="@(_ReferenceCopyLocalPathsWithoutConflicts)" />
    </ItemGroup>
  </Target>
  <!--
    _HandlePackageFileConflictsForPublish
    Handles package file conflict resolution for publish.
    Currently, publish assets may differ due to the following reasons:
      * A package was marked as excluded from publishing (including PrivateAssets="all").
      * There are runtime store packages to publish against.
      * If we're preserving store layout, which alters the destination paths of files.
    When none of these things are true, then we can rely on the conflict resolution from build.
  -->
  <Target Name="_HandlePackageFileConflictsForPublish" AfterTargets="_ResolveCopyLocalAssetsForPublish;&#xA;                        _FilterSatelliteResourcesForPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ResolvePackageFileConflicts ReferenceCopyLocalPaths="@(_ResolvedCopyLocalPublishAssets)" PlatformManifests="@(PackageConflictPlatformManifests)" TargetFrameworkDirectories="$(TargetFrameworkDirectory)" PreferredPackages="$(PackageConflictPreferredPackages)">
      <Output TaskParameter="ReferenceCopyLocalPathsWithoutConflicts" ItemName="_ResolvedCopyLocalPublishAssetsWithoutConflicts" />
      <Output TaskParameter="Conflicts" ItemName="_PublishConflictPackageFiles" />
    </ResolvePackageFileConflicts>
    <ItemGroup>
      <_ResolvedCopyLocalPublishAssets Remove="@(_ResolvedCopyLocalPublishAssets)" />
      <_ResolvedCopyLocalPublishAssets Include="@(_ResolvedCopyLocalPublishAssetsWithoutConflicts)" />
    </ItemGroup>
  </Target>
  <!--
  _HandleFileConflictsForPublish
  Ensures there are no duplicate files being written to the publish output.
  -->
  <Target Name="_HandleFileConflictsForPublish" AfterTargets="ComputeFilesToPublish" Condition="'$(ErrorOnDuplicatePublishOutputFiles)' != 'false'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CheckForDuplicateItemMetadata Items="@(ResolvedFileToPublish-&gt;Distinct())" MetadataName="RelativePath">
      <Output TaskParameter="DuplicatesExist" PropertyName="_ResolvedFileToPublishContainsDuplicates" />
      <Output TaskParameter="DuplicateItems" ItemName="_ResolvedFileToPublishDuplicatedItems" />
    </CheckForDuplicateItemMetadata>
    <NETSdkError Condition="'$(_ResolvedFileToPublishContainsDuplicates)' == 'true'" ResourceName="DuplicatePublishOutputFiles" FormatArguments="@(_ResolvedFileToPublishDuplicatedItems, ', ')" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.CSharp.targets" Condition="'$(Language)' == 'C#'" />-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.VisualBasic.targets" Condition="'$(Language)' == 'VB'" />-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.FSharp.targets" Condition="'$(Language)' == 'F#'" />-->
  <!--<Import Project="$(ILCompilerTargetsPath)" Condition="'$(ILCompilerTargetsPath)' != '' and '$(PublishAot)' == 'true'" />-->
  <!--<Import Project="$(ILLinkTargetsPath)" Condition="'$(ILLinkTargetsPath)' != '' and '$(Language)' != 'C++'" />-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.Analyzers.targets" Condition="'$(Language)' == 'C#' or '$(Language)' == 'VB'" />-->
  <!--
    ============================================================
                                        Run Information
    The ProcessStart information that can be used to run this project.
    ============================================================
    -->
  <!-- TODO: can we now move all of this into the ComputeRunArguments target, or must this be kept for compat? -->
  <!-- NOTE: the targets above may change UseAppHost and other relevant properties, and so all of this pre-computation needs to come after it.
             I checked this when I moved it and none of those targets _used_ the Run* properties.
             This is yet another case where precomputing data during evaluation _is bad_ and should be moved to a Target. -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RunWorkingDirectory Condition="'$(RunWorkingDirectory)' == ''">$(StartWorkingDirectory)</RunWorkingDirectory>
  </PropertyGroup>
  <Choose xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <When Condition="'$(StartAction)' == 'Program'">
      <PropertyGroup>
        <RunCommand Condition="'$(RunCommand)' == ''">$(StartProgram)</RunCommand>
        <RunArguments Condition="'$(RunArguments)' == ''">$(StartArguments)</RunArguments>
      </PropertyGroup>
    </When>
    <When Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_IsExecutable)' == 'true'">
      <PropertyGroup Condition="'$(UseAppHost)' != 'true'">
        <!-- TODO: https://github.com/dotnet/sdk/issues/20 Need to get the DotNetHost path from MSBuild -->
        <RunCommand Condition="'$(RunCommand)' == ''">dotnet</RunCommand>
        <_NetCoreRunArguments>exec "$(TargetPath)"</_NetCoreRunArguments>
        <RunArguments Condition="'$(RunArguments)' == '' and '$(StartArguments)' != ''">$(_NetCoreRunArguments) $(StartArguments)</RunArguments>
        <RunArguments Condition="'$(RunArguments)' == ''">$(_NetCoreRunArguments)</RunArguments>
      </PropertyGroup>
      <PropertyGroup Condition="'$(UseAppHost)' == 'true'">
        <RunCommand Condition="'$(RunCommand)' == ''">$(TargetDir)$(AssemblyName)$(_NativeExecutableExtension)</RunCommand>
        <RunArguments Condition="'$(RunArguments)' == ''">$(StartArguments)</RunArguments>
      </PropertyGroup>
    </When>
    <When Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(_IsExecutable)' == 'true'">
      <PropertyGroup Condition="$([MSBuild]::IsOSPlatform(`Windows`))">
        <RunCommand Condition="'$(RunCommand)' == ''">$(TargetPath)</RunCommand>
        <RunArguments Condition="'$(RunArguments)' == ''">$(StartArguments)</RunArguments>
      </PropertyGroup>
      <PropertyGroup Condition="$([MSBuild]::IsOSUnixLike())">
        <RunCommand Condition="'$(RunCommand)' == ''">mono</RunCommand>
        <RunArguments Condition="'$(RunArguments)' == ''">"$(TargetPath)" $(StartArguments)</RunArguments>
      </PropertyGroup>
    </When>
  </Choose>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Ensure $(RunWorkingDirectory) is a full path -->
    <RunWorkingDirectory Condition="'$(RunWorkingDirectory)' != '' and '$([System.IO.Path]::IsPathRooted($(RunWorkingDirectory)))' != 'true'">$([System.IO.Path]::GetFullPath($([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(RunWorkingDirectory)'))))</RunWorkingDirectory>
  </PropertyGroup>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Signals that this project supports the target-based run invocation protocol powered by the ComputeRunArguments target. -->
    <ProjectCapability Include="SupportsComputeRunCommand" />
  </ItemGroup>
  <!-- Placeholder target for tools to override RunCommand/RunArguments/RunWorkingDirectory.
       This allows tools to run validation or logic required to compute any required data,
       which cannot be done during evaluation.  -->
  <Target Name="ComputeRunArguments" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!-- Override MSBuild Run Target -->
  <Target Name="Run" DependsOnTargets="ComputeRunArguments" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Exec Command="$(RunCommand) $(RunArguments)" WorkingDirectory="$(RunWorkingDirectory)" />
  </Target>
  <!-- Import WindowsDesktop targets if necessary -->
  <PropertyGroup Condition=" '$(ImportWindowsDesktopTargets)' == ''&#xA;                            and ('$(UseWpf)' == 'true' Or '$(UseWindowsForms)' == 'true') " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ImportWindowsDesktopTargets Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;                                           and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '3.0'))&#xA;                                           and '$(TargetPlatformIdentifier)' == 'Windows' ">true</ImportWindowsDesktopTargets>
    <ImportWindowsDesktopTargets Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">true</ImportWindowsDesktopTargets>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(ImportWindowsDesktopTargets)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AfterMicrosoftNETSdkTargets>$(AfterMicrosoftNETSdkTargets);$(MSBuildThisFileDirectory)../../Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.targets</AfterMicrosoftNETSdkTargets>
  </PropertyGroup>
  <!-- Note: Once WindowsDesktop is a workload this will be moved to WorkloadManifest.targets -->
  <ItemGroup Condition="'$(MicrosoftNETWindowsWorkloadInstalled)' == 'true' and&#xA;                        '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and&#xA;                        $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '5.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <SdkSupportedTargetPlatformIdentifier Include="windows" DisplayName="Windows" />
  </ItemGroup>
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Windows.targets" Condition="'$(TargetPlatformIdentifier)' == 'Windows'" />-->
  <!-- TargetPlatformMoniker and TargetPlatformDisplayName would normally be set in Microsoft.Common.CurrentVersion.targets.  However, the
       TargetPlatformVersion may have been set later than that in evaluation by platform-specific targets or Directory.Build.targets.  So fix up those properties here -->
  <PropertyGroup Condition="'$(TargetPlatformMoniker)' == '' and '$(TargetPlatformIdentifier)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Set TargetPlatformVersion if it isn't set.  This is so that we have a valid TargetPlatformMoniker for Restore.
         This avoids an issue where projects with multitargeted unknown platforms would fail to restore because the platforms
         weren't included in the TargetPlatformMoniker for restore, obscuring the errors about unknown platforms or missing
         workloads. -->
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == ''">0.0</TargetPlatformVersion>
    <TargetPlatformMoniker>$(TargetPlatformIdentifier),Version=$(TargetPlatformVersion)</TargetPlatformMoniker>
    <TargetPlatformDisplayName>$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKDisplayName($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformDisplayName>
  </PropertyGroup>
  <!-- Default SupportedOSPlatformVersion to TargetPlatformVersion -->
  <PropertyGroup Condition="'$(SupportedOSPlatformVersion)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <SupportedOSPlatformVersion>$(TargetPlatformVersion)</SupportedOSPlatformVersion>
  </PropertyGroup>
  <!--<Import Project="$(AfterMicrosoftNETSdkTargets)" Condition="'$(AfterMicrosoftNETSdkTargets)' != ''" />-->
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.ApiCompat.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ApiCompat.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ApiCompat.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(UseApiCompatPackage)' != 'true'">
    <DotNetApiCompatTaskAssembly Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\net472\Microsoft.DotNet.ApiCompat.Task.dll</DotNetApiCompatTaskAssembly>
    <DotNetApiCompatTaskAssembly Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net10.0\Microsoft.DotNet.ApiCompat.Task.dll</DotNetApiCompatTaskAssembly>
  </PropertyGroup>
  <ItemGroup Condition="'$(EnablePackageValidation)' == 'true' and&#xA;                        '$(IsPackable)' == 'true' and&#xA;                        '$(DisablePackageBaselineValidation)' != 'true' and&#xA;                        '$(PackageValidationBaselinePath)' == '' and&#xA;                        '$(PackageValidationBaselineVersion)' != ''">
    <PackageDownload Include="$([MSBuild]::ValueOrDefault('$(PackageValidationBaselineName)', '$(PackageId)'))" Version="[$(PackageValidationBaselineVersion)]" />
  </ItemGroup>
  <!--<ImportGroup Condition="'$(UseApiCompatPackage)' != 'true'">-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.ApiCompat.Common.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ApiCompat.Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ApiCompat.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Expose the tasks for SDK consumption and for external use cases. -->
  <UsingTask TaskName="Microsoft.DotNet.ApiCompat.Task.ValidateAssembliesTask" AssemblyFile="$(DotNetApiCompatTaskAssembly)" />
  <UsingTask TaskName="Microsoft.DotNet.ApiCompat.Task.ValidatePackageTask" AssemblyFile="$(DotNetApiCompatTaskAssembly)" />
  <Target Name="CollectApiCompatInputs">
    <PropertyGroup Condition="'$(RoslynAssembliesPath)' == ''">
      <!-- If a custom roslyn assemblies path isn't provided, the opt-in switch 'ApiCompatUseRoslynToolsetPackagePath' is set to true and
           the roslyn toolset package is referenced, use the assemblies from that package. -->
      <_UseRoslynToolsetPackage Condition="'$(ApiCompatUseRoslynToolsetPackagePath)' == 'true' and '@(PackageReference-&gt;AnyHaveMetadataValue('Identity', 'Microsoft.Net.Compilers.Toolset'))' == 'true'">true</_UseRoslynToolsetPackage>
      <!-- CSharpCoreTargetsPath and VisualBasicCoreTargetsPath point to the same location, Microsoft.CodeAnalysis.CSharp and Microsoft.CodeAnalysis.VisualBasic
           are on the same directory as Microsoft.CodeAnalysis. So there is no need to distinguish between csproj or vbproj. -->
      <RoslynAssembliesPath Condition="'$(_UseRoslynToolsetPackage)' == 'true'">$([System.IO.Path]::GetDirectoryName('$(CSharpCoreTargetsPath)'))</RoslynAssembliesPath>
      <!-- Otherwise, default to the roslyn compiler provided by the SDK / Visual Studio. -->
      <RoslynAssembliesPath Condition="'$(_UseRoslynToolsetPackage)' != 'true'">$(RoslynTargetsPath)</RoslynAssembliesPath>
      <!-- The SDK stores the roslyn assemblies in the 'bincore' subdirectory. -->
      <RoslynAssembliesPath Condition="'$(MSBuildRuntimeType)' == 'Core'">$([System.IO.Path]::Combine('$(RoslynAssembliesPath)', 'bincore'))</RoslynAssembliesPath>
    </PropertyGroup>
    <!-- Respect legacy property and item names. -->
    <PropertyGroup>
      <ApiCompatGenerateSuppressionFile Condition="'$(ApiCompatGenerateSuppressionFile)' == ''">$(GenerateCompatibilitySuppressionFile)</ApiCompatGenerateSuppressionFile>
    </PropertyGroup>
    <ItemGroup>
      <ApiCompatSuppressionFile Include="$(CompatibilitySuppressionFilePath)" Condition="'@(ApiCompatSuppressionFile)' == '' and '$(CompatibilitySuppressionFilePath)' != ''" />
    </ItemGroup>
    <!-- END: Respect legacy property and item names. -->
    <PropertyGroup>
      <_apiCompatDefaultProjectSuppressionFile>$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', 'CompatibilitySuppressions.xml'))</_apiCompatDefaultProjectSuppressionFile>
      <!-- Pass in a default suppression output file if non is supplied, and ApiCompatGenerateSuppressionFile is true. -->
      <ApiCompatSuppressionOutputFile Condition="'$(ApiCompatSuppressionOutputFile)' == '' and '$(ApiCompatGenerateSuppressionFile)' == 'true'">$(_apiCompatDefaultProjectSuppressionFile)</ApiCompatSuppressionOutputFile>
    </PropertyGroup>
    <!-- Pass in a default suppression file, if it exists. -->
    <ItemGroup Condition="'@(ApiCompatSuppressionFile)' == ''">
      <ApiCompatSuppressionFile Include="$(_apiCompatDefaultProjectSuppressionFile)" Condition="Exists($(_apiCompatDefaultProjectSuppressionFile))" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ApiCompat.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.ApiCompat.ValidatePackage.targets">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ApiCompat.ValidatePackage.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ApiCompat.ValidatePackage.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_ApiCompatValidatePackageSemaphoreFile>$(IntermediateOutputPath)$(MSBuildThisFileName).semaphore</_ApiCompatValidatePackageSemaphoreFile>
    <!-- Add any custom targets that need to run before package validation to the following property. -->
    <RunPackageValidationDependsOn>CollectApiCompatInputs;_GetReferencePathFromInnerProjects;$(RunPackageValidationDependsOn)</RunPackageValidationDependsOn>
  </PropertyGroup>
  <Target Name="RunPackageValidation" DependsOnTargets="$(RunPackageValidationDependsOn)" AfterTargets="Pack" Inputs="@(NuGetPackInput);&#xA;                  @(ApiCompatSuppressionFile);&#xA;                  $(ApiCompatSuppressionOutputFile)" Outputs="$(_ApiCompatValidatePackageSemaphoreFile)" Condition="'$(EnablePackageValidation)' == 'true' and '$(IsPackable)' == 'true'">
    <PropertyGroup>
      <PackageValidationBaselineName Condition="'$(PackageValidationBaselineName)' == ''">$(PackageId)</PackageValidationBaselineName>
      <PackageValidationBaselinePath Condition="'$(PackageValidationBaselinePath)' == '' and '$(PackageValidationBaselineVersion)' != ''">$([MSBuild]::NormalizePath('$(NuGetPackageRoot)', '$(PackageValidationBaselineName.ToLower())', '$(PackageValidationBaselineVersion)', '$(PackageValidationBaselineName.ToLower()).$(PackageValidationBaselineVersion).nupkg'))</PackageValidationBaselinePath>
      <_packageValidationBaselinePath Condition="'$(DisablePackageBaselineValidation)' != 'true'">$(PackageValidationBaselinePath)</_packageValidationBaselinePath>
    </PropertyGroup>
    <ItemGroup>
      <_PackageTargetPath Include="@(NuGetPackOutput-&gt;WithMetadataValue('Extension', '.nupkg'))" Condition="!$([System.String]::new('%(Identity)').EndsWith('.symbols.nupkg'))" />
    </ItemGroup>
    <!-- PackageTargetPath isn't exposed by NuGet: https://github.com/NuGet/Home/issues/6671. -->
    <Microsoft.DotNet.ApiCompat.Task.ValidatePackageTask PackageTargetPath="@(_PackageTargetPath)" RuntimeGraph="$(RuntimeIdentifierGraphPath)" NoWarn="$(NoWarn)" RespectInternals="$(ApiCompatRespectInternals)" EnableRuleAttributesMustMatch="$(ApiCompatEnableRuleAttributesMustMatch)" ExcludeAttributesFiles="@(ApiCompatExcludeAttributesFile)" EnableRuleCannotChangeParameterName="$(ApiCompatEnableRuleCannotChangeParameterName)" RunApiCompat="$(RunApiCompat)" EnableStrictModeForCompatibleTfms="$(EnableStrictModeForCompatibleTfms)" EnableStrictModeForCompatibleFrameworksInPackage="$(EnableStrictModeForCompatibleFrameworksInPackage)" EnableStrictModeForBaselineValidation="$(EnableStrictModeForBaselineValidation)" GenerateSuppressionFile="$(ApiCompatGenerateSuppressionFile)" PreserveUnnecessarySuppressions="$(ApiCompatPreserveUnnecessarySuppressions)" PermitUnnecessarySuppressions="$(ApiCompatPermitUnnecessarySuppressions)" SuppressionFiles="@(ApiCompatSuppressionFile)" SuppressionOutputFile="$(ApiCompatSuppressionOutputFile)" BaselinePackageTargetPath="$(_packageValidationBaselinePath)" RoslynAssembliesPath="$(RoslynAssembliesPath)" PackageAssemblyReferences="@(PackageValidationReferencePath)" BaselinePackageFrameworksToIgnore="@(PackageValidationBaselineFrameworkToIgnore)" />
    <MakeDir Directories="$([System.IO.Path]::GetDirectoryName('$(_ApiCompatValidatePackageSemaphoreFile)'))" />
    <Touch Files="$(_ApiCompatValidatePackageSemaphoreFile)" AlwaysCreate="true" />
  </Target>
  <Target Name="GetReferencesForApiCompatValidatePackage" DependsOnTargets="FindReferenceAssembliesForReferences" Returns="@(ApiCompatAssemblyReferencesWithTargetFramework)">
    <ItemGroup>
      <ApiCompatAssemblyReferencesWithTargetFramework Include="$(TargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" ReferencePath="@(ReferencePathWithRefAssemblies, ',')">
        <TargetPlatformMoniker Condition="'$(ApiCompatIgnoreTargetPlatformMoniker)' != 'true'">$(TargetPlatformMoniker)</TargetPlatformMoniker>
      </ApiCompatAssemblyReferencesWithTargetFramework>
    </ItemGroup>
  </Target>
  <!-- Depends on NuGet's _GetTargetFrameworksOutput target to calculate inner target frameworks. -->
  <Target Name="_GetReferencePathFromInnerProjects" DependsOnTargets="_GetTargetFrameworksOutput" Condition="'$(RunPackageValidationWithoutReferences)' != 'true'">
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="GetReferencesForApiCompatValidatePackage" Properties="TargetFramework=%(_TargetFrameworks.Identity);&#xA;                         BuildProjectReferences=false">
      <Output ItemName="PackageValidationReferencePath" TaskParameter="TargetOutputs" />
    </MSBuild>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ApiCompat.targets
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!-- Import targets from NuGet.Build.Tasks.Pack package/Sdk -->
  <PropertyGroup Condition="'$(NuGetBuildTasksPackTargets)' == '' AND '$(ImportNuGetBuildTasksPackTargetsFromSdk)' != 'false'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NuGetBuildTasksPackTargets Condition="'$(IsCrossTargetingBuild)' == 'true'">$(MSBuildThisFileDirectory)..\..\NuGet.Build.Tasks.Pack\buildCrossTargeting\NuGet.Build.Tasks.Pack.targets</NuGetBuildTasksPackTargets>
    <NuGetBuildTasksPackTargets Condition="'$(IsCrossTargetingBuild)' != 'true'">$(MSBuildThisFileDirectory)..\..\NuGet.Build.Tasks.Pack\build\NuGet.Build.Tasks.Pack.targets</NuGetBuildTasksPackTargets>
    <ImportNuGetBuildTasksPackTargetsFromSdk>true</ImportNuGetBuildTasksPackTargetsFromSdk>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetBuildTasksPackTargets)" Condition="Exists('$(NuGetBuildTasksPackTargets)') AND '$(ImportNuGetBuildTasksPackTargetsFromSdk)' == 'true'">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/NuGet.Build.Tasks.Pack/build/NuGet.Build.Tasks.Pack.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
NuGet.Build.Tasks.Pack.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Load NuGet.Build.Tasks.Pack.dll, this can be overridden to use a different version with $(NuGetPackTaskAssemblyFile) -->
  <PropertyGroup Condition="$(NuGetPackTaskAssemblyFile) == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NuGetPackTaskAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">..\CoreCLR\NuGet.Build.Tasks.Pack.dll</NuGetPackTaskAssemblyFile>
    <NuGetPackTaskAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">..\Desktop\NuGet.Build.Tasks.Pack.dll</NuGetPackTaskAssemblyFile>
  </PropertyGroup>
  <!-- Tasks -->
  <UsingTask TaskName="NuGet.Build.Tasks.Pack.PackTask" AssemblyFile="$(NuGetPackTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.Pack.GetPackOutputItemsTask" AssemblyFile="$(NuGetPackTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetProjectTargetFrameworksTask" AssemblyFile="$(NuGetPackTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.Pack.GetProjectReferencesFromAssetsFileTask" AssemblyFile="$(NuGetPackTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.Pack.IsPackableFalseWarningTask" AssemblyFile="$(NuGetPackTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PackageId Condition=" '$(PackageId)' == '' ">$(AssemblyName)</PackageId>
    <PackageVersion Condition=" '$(PackageVersion)' == '' ">$(Version)</PackageVersion>
    <IncludeContentInPack Condition="'$(IncludeContentInPack)'==''">true</IncludeContentInPack>
    <GenerateNuspecDependsOn>_LoadPackInputItems; _GetTargetFrameworksOutput; _WalkEachTargetPerFramework; _GetPackageFiles; $(GenerateNuspecDependsOn)</GenerateNuspecDependsOn>
    <PackageDescription Condition="'$(PackageDescription)'==''">$(Description)</PackageDescription>
    <PackageDescription Condition="'$(PackageDescription)'==''">Package Description</PackageDescription>
    <IsPackable Condition="'$(IsPackable)'=='' AND ('$(IsTestProject)'=='true' OR '$(IsTestingPlatformApplication)'=='true')">false</IsPackable>
    <IsPackable Condition="'$(IsPackable)'==''">true</IsPackable>
    <IncludeBuildOutput Condition="'$(IncludeBuildOutput)'==''">true</IncludeBuildOutput>
    <BuildOutputTargetFolder Condition="'$(BuildOutputTargetFolder)' == '' AND '$(IsTool)' == 'true'">tools</BuildOutputTargetFolder>
    <BuildOutputTargetFolder Condition="'$(BuildOutputTargetFolder)' == ''">lib</BuildOutputTargetFolder>
    <ContentTargetFolders Condition="'$(ContentTargetFolders)' == ''">content;contentFiles</ContentTargetFolders>
    <PackDependsOn>$(BeforePack); _IntermediatePack; GenerateNuspec; $(PackDependsOn)</PackDependsOn>
    <IsInnerBuild Condition="'$(TargetFramework)' != '' AND '$(TargetFrameworks)' != ''">true</IsInnerBuild>
    <SymbolPackageFormat Condition="'$(SymbolPackageFormat)' == ''">symbols.nupkg</SymbolPackageFormat>
    <AddPriFileDependsOn Condition="'$(MicrosoftPortableCurrentVersionPropsHasBeenImported)' == 'true'">DeterminePortableBuildCapabilities</AddPriFileDependsOn>
    <WarnOnPackingNonPackableProject Condition="'$(WarnOnPackingNonPackableProject)' == ''">false</WarnOnPackingNonPackableProject>
    <ImportNuGetBuildTasksPackTargetsFromSdk Condition="'$(ImportNuGetBuildTasksPackTargetsFromSdk)' == ''">false</ImportNuGetBuildTasksPackTargetsFromSdk>
    <DefaultAllowedOutputExtensionsInPackageBuildOutputFolder Condition="'$(DefaultAllowedOutputExtensionsInPackageBuildOutputFolder)' == ''">.dll; .exe; .winmd; .json; .pri; .xml</DefaultAllowedOutputExtensionsInPackageBuildOutputFolder>
    <AllowedOutputExtensionsInPackageBuildOutputFolder>$(DefaultAllowedOutputExtensionsInPackageBuildOutputFolder) ;$(AllowedOutputExtensionsInPackageBuildOutputFolder)</AllowedOutputExtensionsInPackageBuildOutputFolder>
    <AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder Condition="'$(SymbolPackageFormat)' != 'snupkg'">.pdb; .mdb; $(AllowedOutputExtensionsInPackageBuildOutputFolder); $(AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder)</AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder>
    <AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder Condition="'$(SymbolPackageFormat)' == 'snupkg'">.pdb</AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder>
    <SuppressDependenciesWhenPacking Condition="'$(SuppressDependenciesWhenPacking)' == ''">false</SuppressDependenciesWhenPacking>
  </PropertyGroup>
  <PropertyGroup Condition="'$(NoBuild)' == 'true' or '$(GeneratePackageOnBuild)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateNuspecDependsOn>$(GenerateNuspecDependsOn)</GenerateNuspecDependsOn>
  </PropertyGroup>
  <PropertyGroup Condition="'$(NoBuild)' != 'true' and '$(GeneratePackageOnBuild)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateNuspecDependsOn>Build;$(GenerateNuspecDependsOn)</GenerateNuspecDependsOn>
  </PropertyGroup>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Include="Pack" />
  </ItemGroup>
  <ItemDefinitionGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <BuildOutputInPackage>
      <TargetFramework>$(TargetFramework)</TargetFramework>
    </BuildOutputInPackage>
  </ItemDefinitionGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RestoreOutputPath Condition="'$(RestoreOutputPath)' == ''">$(MSBuildProjectExtensionsPath)</RestoreOutputPath>
    <PackageOutputPath Condition="'$(PackageOutputPath)' == ''">$(BaseOutputPath)$(Configuration)\</PackageOutputPath>
    <NuspecOutputPath Condition="'$(NuspecOutputPath)' == ''">$(BaseIntermediateOutputPath)$(Configuration)\</NuspecOutputPath>
  </PropertyGroup>
  <!--
    ============================================================
    _GetAbsoluteOutputPathsForPack
    Gets the absolute output paths for Pack.
    ============================================================
  -->
  <Target Name="_GetAbsoluteOutputPathsForPack" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ConvertToAbsolutePath Paths="$(RestoreOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="RestoreOutputAbsolutePath" />
    </ConvertToAbsolutePath>
    <ConvertToAbsolutePath Paths="$(PackageOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="PackageOutputAbsolutePath" />
    </ConvertToAbsolutePath>
    <ConvertToAbsolutePath Paths="$(NuspecOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="NuspecOutputAbsolutePath" />
    </ConvertToAbsolutePath>
  </Target>
  <!--
    ============================================================
    _GetOutputItemsFromPack
    Gets the output '.nupkg' and '.nuspec' absolute file paths.
    ============================================================
  -->
  <Target Name="_GetOutputItemsFromPack" DependsOnTargets="_GetAbsoluteOutputPathsForPack" Returns="@(_OutputPackItems)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- 'PackageOutputAbsolutePath' and 'NuspecOutputAbsolutePath' will be provided by '_GetAbsoluteOutputPathsForPack' target -->
    <GetPackOutputItemsTask PackageOutputPath="$(PackageOutputAbsolutePath)" NuspecOutputPath="$(NuspecOutputAbsolutePath)" PackageId="$(PackageId)" PackageVersion="$(PackageVersion)" IncludeSymbols="$(IncludeSymbols)" IncludeSource="$(IncludeSource)" SymbolPackageFormat="$(SymbolPackageFormat)">
      <Output TaskParameter="OutputPackItems" ItemName="_OutputPackItems" />
    </GetPackOutputItemsTask>
  </Target>
  <!--
    ============================================================
    _GetTargetFrameworksOutput
    Read target frameworks from the project.
    ============================================================
  -->
  <Target Name="_GetTargetFrameworksOutput" Returns="@(_TargetFrameworks)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_ProjectFrameworks />
    </PropertyGroup>
    <GetProjectTargetFrameworksTask ProjectPath="$(MSBuildProjectFullPath)" TargetFrameworks="$(TargetFrameworks)" TargetFramework="$(TargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)">
      <Output TaskParameter="ProjectTargetFrameworks" PropertyName="_ProjectFrameworks" />
    </GetProjectTargetFrameworksTask>
    <ItemGroup Condition=" '$(_ProjectFrameworks)' != '' ">
      <_TargetFrameworks Include="$(_ProjectFrameworks.Split(';'))" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    Pack
    Post Build Target
    ============================================================
  -->
  <Target Name="_PackAsBuildAfterTarget" AfterTargets="Build" Condition="'$(GeneratePackageOnBuild)' == 'true' AND '$(IsInnerBuild)' != 'true'" DependsOnTargets="Pack" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_CleanPackageFiles" DependsOnTargets="_GetOutputItemsFromPack" AfterTargets="Clean" Condition="'$(GeneratePackageOnBuild)' == 'true' AND '$(IsInnerBuild)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_PackageFilesToDelete Include="@(_OutputPackItems)" />
    </ItemGroup>
    <Delete Files="@(_PackageFilesToDelete)" />
  </Target>
  <Target Name="_CalculateInputsOutputsForPack" DependsOnTargets="_GetOutputItemsFromPack" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Condition="$(ContinuePackingAfterGeneratingNuspec) == '' ">
      <ContinuePackingAfterGeneratingNuspec>false</ContinuePackingAfterGeneratingNuspec>
    </PropertyGroup>
    <ItemGroup>
      <!--This catches changes to properties-->
      <NuGetPackInput Include="$(MSBuildAllProjects)" />
      <NuGetPackInput Include="@(_PackageFiles)" />
      <NuGetPackInput Include="@(_PackageFilesToExclude)" />
      <NuGetPackInput Include="@(_BuildOutputInPackage->'%(FinalOutputPath)')" />
      <NuGetPackInput Include="@(_TargetPathsToSymbols->'%(FinalOutputPath)')" />
      <NuGetPackInput Include="@(_SourceFiles)" />
      <NuGetPackInput Include="@(_References)" />
      <NuGetPackOutput Include="@(_OutputPackItems)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    Pack
    Main entry point for packing packages
    ============================================================
  -->
  <Target Name="Pack" DependsOnTargets="$(PackDependsOn)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <IsPackableFalseWarningTask Condition="'$(IsPackable)' == 'false' AND '$(WarnOnPackingNonPackableProject)' == 'true'" />
  </Target>
  <Target Name="_IntermediatePack" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <ContinuePackingAfterGeneratingNuspec>true</ContinuePackingAfterGeneratingNuspec>
    </PropertyGroup>
  </Target>
  <Target Name="GenerateNuspec" Condition="'$(IsPackable)' == 'true'" Inputs="@(NuGetPackInput)" Outputs="@(NuGetPackOutput)" DependsOnTargets="$(GenerateNuspecDependsOn);_CalculateInputsOutputsForPack;_GetProjectReferenceVersions;_InitializeNuspecRepositoryInformationProperties" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ConvertToAbsolutePath Condition="$(NuspecFile) != ''" Paths="$(NuspecFile)">
      <Output TaskParameter="AbsolutePaths" PropertyName="NuspecFileAbsolutePath" />
    </ConvertToAbsolutePath>
    <!-- Call Pack -->
    <PackTask PackItem="$(PackProjectInputFile)" PackageFiles="@(_PackageFiles)" PackageFilesToExclude="@(_PackageFilesToExclude)" PackageVersion="$(PackageVersion)" PackageId="$(PackageId)" Title="$(Title)" Authors="$(Authors)" Description="$(PackageDescription)" Copyright="$(Copyright)" RequireLicenseAcceptance="$(PackageRequireLicenseAcceptance)" LicenseUrl="$(PackageLicenseUrl)" ProjectUrl="$(PackageProjectUrl)" IconUrl="$(PackageIconUrl)" ReleaseNotes="$(PackageReleaseNotes)" Tags="$(PackageTags)" DevelopmentDependency="$(DevelopmentDependency)" BuildOutputInPackage="@(_BuildOutputInPackage)" ProjectReferencesWithVersions="@(_ProjectReferencesWithVersions)" TargetPathsToSymbols="@(_TargetPathsToSymbols)" TargetFrameworks="@(_TargetFrameworks)" FrameworksWithSuppressedDependencies="@(_FrameworksWithSuppressedDependencies)" AssemblyName="$(AssemblyName)" PackageOutputPath="$(PackageOutputAbsolutePath)" IncludeSymbols="$(IncludeSymbols)" IncludeSource="$(IncludeSource)" PackageTypes="$(PackageType)" IsTool="$(IsTool)" RepositoryUrl="$(RepositoryUrl)" RepositoryType="$(RepositoryType)" RepositoryBranch="$(RepositoryBranch)" RepositoryCommit="$(RepositoryCommit)" SourceFiles="@(_SourceFiles-&gt;Distinct())" NoPackageAnalysis="$(NoPackageAnalysis)" NoDefaultExcludes="$(NoDefaultExcludes)" MinClientVersion="$(MinClientVersion)" Serviceable="$(Serviceable)" FrameworkAssemblyReferences="@(_FrameworkAssemblyReferences)" ContinuePackingAfterGeneratingNuspec="$(ContinuePackingAfterGeneratingNuspec)" NuspecOutputPath="$(NuspecOutputAbsolutePath)" IncludeBuildOutput="$(IncludeBuildOutput)" BuildOutputFolders="$(BuildOutputTargetFolder)" ContentTargetFolders="$(ContentTargetFolders)" RestoreOutputPath="$(RestoreOutputAbsolutePath)" NuspecFile="$(NuspecFileAbsolutePath)" NuspecBasePath="$(NuspecBasePath)" NuspecProperties="$(NuspecProperties)" AllowedOutputExtensionsInPackageBuildOutputFolder="$(AllowedOutputExtensionsInPackageBuildOutputFolder)" AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder="$(AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder)" NoWarn="$(NoWarn)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" OutputFileNamesWithoutVersion="$(OutputFileNamesWithoutVersion)" InstallPackageToOutputPath="$(InstallPackageToOutputPath)" SymbolPackageFormat="$(SymbolPackageFormat)" PackageLicenseFile="$(PackageLicenseFile)" PackageLicenseExpression="$(PackageLicenseExpression)" PackageLicenseExpressionVersion="$(PackageLicenseExpressionVersion)" Readme="$(PackageReadmeFile)" Deterministic="$(Deterministic)" PackageIcon="$(PackageIcon)" />
  </Target>
  <!--
    Initialize Repository* properties from properties set by a source control package, if available in the project.
  -->
  <Target Name="_InitializeNuspecRepositoryInformationProperties" DependsOnTargets="InitializeSourceControlInformation" Condition="'$(SourceControlInformationFeatureSupported)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <!-- The project must specify PublishRepositoryUrl=true in order to publish the URL or branch, in order to prevent inadvertent leak of internal data. -->
      <RepositoryUrl Condition="'$(RepositoryUrl)' == '' and '$(PublishRepositoryUrl)' == 'true'">$(PrivateRepositoryUrl)</RepositoryUrl>
      <RepositoryCommit Condition="'$(RepositoryCommit)' == ''">$(SourceRevisionId)</RepositoryCommit>
      <RepositoryBranch Condition="'$(RepositoryBranch)' == '' and '$(PublishRepositoryUrl)' == 'true' and '$(SourceBranchName)' != ''">$(SourceBranchName)</RepositoryBranch>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _LoadPackGraphEntryPoints
    Find project entry point and load them into items.
    ============================================================
  -->
  <Target Name="_LoadPackInputItems" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Allow overriding items with PackProjectInputFile -->
    <PropertyGroup Condition="'$(PackProjectInputFile)' == ''">
      <PackProjectInputFile>$(MSBuildProjectFullPath)</PackProjectInputFile>
    </PropertyGroup>
  </Target>
  <Target Name="_GetProjectReferenceVersions" Condition="'$(NuspecFile)' == ''" DependsOnTargets="_GetAbsoluteOutputPathsForPack;$(GetPackageVersionDependsOn)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- 'RestoreOutputAbsolutePath' will be provided by '_GetAbsoluteOutputPathsForPack' target -->
    <ConvertToAbsolutePath Condition="'$(ProjectAssetsFile)' != ''" Paths="$(ProjectAssetsFile)">
      <Output TaskParameter="AbsolutePaths" PropertyName="ProjectAssetsFileAbsolutePath" />
    </ConvertToAbsolutePath>
    <GetProjectReferencesFromAssetsFileTask RestoreOutputAbsolutePath="$(RestoreOutputAbsolutePath)" ProjectAssetsFileAbsolutePath="$(ProjectAssetsFileAbsolutePath)">
      <Output TaskParameter="ProjectReferences" ItemName="_ProjectReferencesFromAssetsFile" />
    </GetProjectReferencesFromAssetsFileTask>
    <MSBuild Projects="@(_ProjectReferencesFromAssetsFile)" Targets="_GetProjectVersion" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="BuildProjectReferences=false;">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferencesWithVersions" />
    </MSBuild>
  </Target>
  <Target Name="_GetProjectVersion" DependsOnTargets="$(GetPackageVersionDependsOn)" Returns="@(_ProjectPathWithVersion)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ProjectPathWithVersion Include="$(MSBuildProjectFullPath)">
        <ProjectVersion Condition="'$(PackageVersion)' != ''">$(PackageVersion)</ProjectVersion>
        <ProjectVersion Condition="'$(PackageVersion)' == ''">1.0.0</ProjectVersion>
      </_ProjectPathWithVersion>
    </ItemGroup>
  </Target>
  <Target Name="_WalkEachTargetPerFramework" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ProjectsWithTFM Include="$(MSBuildProjectFullPath)" AdditionalProperties="TargetFramework=%(_TargetFrameworks.Identity)" />
      <_ProjectsWithTFMNoBuild Include="$(MSBuildProjectFullPath)" AdditionalProperties="TargetFramework=%(_TargetFrameworks.Identity);BuildProjectReferences=false" />
    </ItemGroup>
    <MSBuild Condition="'$(IncludeBuildOutput)' == 'true'" Projects="@(_ProjectsWithTFM)" Targets="_GetBuildOutputFilesWithTfm" BuildInParallel="$(BuildInParallel)">
      <Output TaskParameter="TargetOutputs" ItemName="_BuildOutputInPackage" />
    </MSBuild>
    <MSBuild Condition="'$(TargetsForTfmSpecificContentInPackage)' != ''" Projects="@(_ProjectsWithTFM)" Targets="_GetTfmSpecificContentForPackage" BuildInParallel="$(BuildInParallel)">
      <Output TaskParameter="TargetOutputs" ItemName="_PackageFiles" />
    </MSBuild>
    <MSBuild Condition="'$(IncludeBuildOutput)' == 'true'" Projects="@(_ProjectsWithTFM)" Targets="_GetDebugSymbolsWithTfm" BuildInParallel="$(BuildInParallel)">
      <Output TaskParameter="TargetOutputs" ItemName="_TargetPathsToSymbols" />
    </MSBuild>
    <MSBuild Condition="'$(IncludeSource)' == 'true'" Projects="@(_ProjectsWithTFMNoBuild)" Targets="SourceFilesProjectOutputGroup" BuildInParallel="$(BuildInParallel)">
      <Output TaskParameter="TargetOutputs" ItemName="_SourceFiles" />
    </MSBuild>
    <MSBuild Projects="@(_ProjectsWithTFMNoBuild)" Targets="_GetFrameworkAssemblyReferences" BuildInParallel="$(BuildInParallel)">
      <Output TaskParameter="TargetOutputs" ItemName="_FrameworkAssemblyReferences" />
    </MSBuild>
    <MSBuild Projects="@(_ProjectsWithTFMNoBuild)" Targets="_GetFrameworksWithSuppressedDependencies" BuildInParallel="$(BuildInParallel)">
      <Output TaskParameter="TargetOutputs" ItemName="_FrameworksWithSuppressedDependencies" />
    </MSBuild>
  </Target>
  <Target Name="_GetFrameworksWithSuppressedDependencies" Returns="@(_TfmWithDependenciesSuppressed)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_TfmWithDependenciesSuppressed Include="$(TargetFramework)" Condition="'$(SuppressDependenciesWhenPacking)' == 'true'" />
    </ItemGroup>
  </Target>
  <Target Name="_GetFrameworkAssemblyReferences" DependsOnTargets="ResolveReferences" Returns="@(TfmSpecificFrameworkAssemblyReferences)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <TfmSpecificFrameworkAssemblyReferences Include="@(ReferencePath->'%(OriginalItemSpec)')" Condition="'%(ReferencePath.Pack)' != 'false' AND '%(ReferencePath.ResolvedFrom)' == '{TargetFrameworkDirectory}'">
        <TargetFramework>$(TargetFramework)</TargetFramework>
      </TfmSpecificFrameworkAssemblyReferences>
    </ItemGroup>
  </Target>
  <Target Name="_GetBuildOutputFilesWithTfm" DependsOnTargets="BuiltProjectOutputGroup;DocumentationProjectOutputGroup;SatelliteDllsProjectOutputGroup;_AddPriFileToPackBuildOutput;$(TargetsForTfmSpecificBuildOutput)" Returns="@(BuildOutputInPackage)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(IncludeBuildOutput)' == 'true'">
      <BuildOutputInPackage Include="@(SatelliteDllsProjectOutputGroupOutput);&#xD;&#xA;                            @(BuiltProjectOutputGroupOutput);&#xD;&#xA;                            @(DocumentationProjectOutputGroupOutput);&#xD;&#xA;                            @(_PathToPriFile)" />
    </ItemGroup>
  </Target>
  <Target Name="_GetTfmSpecificContentForPackage" DependsOnTargets="$(TargetsForTfmSpecificContentInPackage)" Returns="@(TfmSpecificPackageFileWithRecursiveDir)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- The below workaround needs to be done due to msbuild bug https://github.com/Microsoft/msbuild/issues/3121 -->
    <ItemGroup>
      <TfmSpecificPackageFileWithRecursiveDir Include="@(TfmSpecificPackageFile)">
        <NuGetRecursiveDir>%(TfmSpecificPackageFile.RecursiveDir)</NuGetRecursiveDir>
        <BuildAction>%(TfmSpecificPackageFile.BuildAction)</BuildAction>
      </TfmSpecificPackageFileWithRecursiveDir>
    </ItemGroup>
  </Target>
  <Target Name="_GetDebugSymbolsWithTfm" DependsOnTargets="DebugSymbolsProjectOutputGroup;$(TargetsForTfmSpecificDebugSymbolsInPackage)" Returns="@(_TargetPathsToSymbolsWithTfm)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(IncludeBuildOutput)' == 'true'">
      <_TargetPathsToSymbolsWithTfm Include="@(DebugSymbolsProjectOutputGroupOutput)">
        <TargetFramework>$(TargetFramework)</TargetFramework>
      </_TargetPathsToSymbolsWithTfm>
    </ItemGroup>
    <ItemGroup>
      <_TargetPathsToSymbolsWithTfm Include="@(TfmSpecificDebugSymbolsFile)" />
    </ItemGroup>
  </Target>
  <!--Projects with target framework like UWP, Win8, wpa81 produce a Pri file
    in their bin dir. This Pri file is not included in the BuiltProjectGroupOutput, and
    has to be added manually here.-->
  <Target Name="_AddPriFileToPackBuildOutput" Returns="@(_PathToPriFile)" DependsOnTargets="$(AddPriFileDependsOn)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(IncludeProjectPriFile)' == 'true'">
      <_PathToPriFile Include="$(ProjectPriFullPath)">
        <FinalOutputPath>$(ProjectPriFullPath)</FinalOutputPath>
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </_PathToPriFile>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GetPackageFiles
    Entry point for generating the project to project references.
    ============================================================
  -->
  <Target Name="_GetPackageFiles" Condition="$(IncludeContentInPack) == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_PackageFilesToExclude Include="@(Content)" Condition="'%(Content.Pack)' == 'false'" />
    </ItemGroup>
    <!-- Include PackageFiles and Content of the project being packed -->
    <ItemGroup>
      <_PackageFiles Include="@(Content)" Condition=" %(Content.Pack) != 'false' ">
        <BuildAction Condition="'%(Content.BuildAction)' == ''">Content</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(Compile)" Condition=" %(Compile.Pack) == 'true' ">
        <BuildAction Condition="'%(Compile.BuildAction)' == ''">Compile</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(None)" Condition=" %(None.Pack) == 'true' ">
        <BuildAction Condition="'%(None.BuildAction)' == ''">None</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(EmbeddedResource)" Condition=" %(EmbeddedResource.Pack) == 'true' ">
        <BuildAction Condition="'%(EmbeddedResource.BuildAction)' == ''">EmbeddedResource</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(ApplicationDefinition)" Condition=" %(ApplicationDefinition.Pack) == 'true' ">
        <BuildAction Condition="'%(ApplicationDefinition.BuildAction)' == ''">ApplicationDefinition</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(Page)" Condition=" %(Page.Pack) == 'true' ">
        <BuildAction Condition="'%(Page.BuildAction)' == ''">Page</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(Resource)" Condition=" %(Resource.Pack) == 'true' ">
        <BuildAction Condition="'%(Resource.BuildAction)' == ''">Resource</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(SplashScreen)" Condition=" %(SplashScreen.Pack) == 'true' ">
        <BuildAction Condition="'%(SplashScreen.BuildAction)' == ''">SplashScreen</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(DesignData)" Condition=" %(DesignData.Pack) == 'true' ">
        <BuildAction Condition="'%(DesignData.BuildAction)' == ''">DesignData</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(DesignDataWithDesignTimeCreatableTypes)" Condition=" %(DesignDataWithDesignTimeCreatableTypes.Pack) == 'true' ">
        <BuildAction Condition="'%(DesignDataWithDesignTimeCreatableTypes.BuildAction)' == ''">DesignDataWithDesignTimeCreatableTypes</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(CodeAnalysisDictionary)" Condition=" %(CodeAnalysisDictionary.Pack) == 'true' ">
        <BuildAction Condition="'%(CodeAnalysisDictionary.BuildAction)' == ''">CodeAnalysisDictionary</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(AndroidAsset)" Condition=" %(AndroidAsset.Pack) == 'true' ">
        <BuildAction Condition="'%(AndroidAsset.BuildAction)' == ''">AndroidAsset</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(AndroidResource)" Condition=" %(AndroidResource.Pack) == 'true' ">
        <BuildAction Condition="'%(AndroidResource.BuildAction)' == ''">AndroidResource</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(BundleResource)" Condition=" %(BundleResource.Pack) == 'true' ">
        <BuildAction Condition="'%(BundleResource.BuildAction)' == ''">BundleResource</BuildAction>
      </_PackageFiles>
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!-- Import targets from Microsoft.NET.Build.Container.targets -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_IsNotSetContainersTargetsDir>false</_IsNotSetContainersTargetsDir>
    <_IsNotSetContainersTargetsDir Condition=" '$(_ContainersTargetsDir)'=='' ">true</_IsNotSetContainersTargetsDir>
    <_ContainersTargetsDir Condition="$(_IsNotSetContainersTargetsDir)">$(MSBuildThisFileDirectory)..\..\..\Containers\build\</_ContainersTargetsDir>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\..\Containers\build\Microsoft.NET.Build.Containers.props" Condition="Exists('$(MSBuildThisFileDirectory)..\..\..\Containers\build\Microsoft.NET.Build.Containers.props')">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Containers/build/Microsoft.NET.Build.Containers.props
============================================================================================================================================
-->
  <PropertyGroup>
    <!-- A flag representing this package existing in a project.  -->
    <SDKContainerSupportEnabled>true</SDKContainerSupportEnabled>
    <ContainerTaskFolderName>tasks</ContainerTaskFolderName>
    <ContainerTaskFramework Condition="'$(MSBuildRuntimeType)' == 'Core'">net10.0</ContainerTaskFramework>
    <ContainerTaskFramework Condition="'$(MSBuildRuntimeType)' == 'Full'">net472</ContainerTaskFramework>
    <ContainerizeFolderName>containerize</ContainerizeFolderName>
    <!--The folder where the custom task will be present. It points to inside the nuget package. -->
    <ContainerCustomTasksFolder>$(MSBuildThisFileDirectory)..\$(ContainerTaskFolderName)\$(ContainerTaskFramework)\</ContainerCustomTasksFolder>
    <ContainerizeFolder>$(MSBuildThisFileDirectory)..\$(ContainerizeFolderName)\</ContainerizeFolder>
    <!--Reference to the assembly which contains the MSBuild Task-->
    <ContainerCustomTasksAssembly Condition="'$(ContainerCustomTasksAssembly)' == ''">$(ContainerCustomTasksFolder)$(MSBuildThisFileName).dll</ContainerCustomTasksAssembly>
  </PropertyGroup>
  <!--Register our custom task-->
  <UsingTask TaskName="$(MSBuildThisFileName).Tasks.CreateNewImage" AssemblyFile="$(ContainerCustomTasksAssembly)" />
  <UsingTask TaskName="$(MSBuildThisFileName).Tasks.CreateImageIndex" AssemblyFile="$(ContainerCustomTasksAssembly)" />
  <UsingTask TaskName="$(MSBuildThisFileName).Tasks.ParseContainerProperties" AssemblyFile="$(ContainerCustomTasksAssembly)" />
  <UsingTask TaskName="$(MSBuildThisFileName).Tasks.ComputeDotnetBaseImageAndTag" AssemblyFile="$(ContainerCustomTasksAssembly)" />
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(_ContainersTargetsDir)Microsoft.NET.Build.Containers.targets" Condition="$(_IsNotSetContainersTargetsDir) AND Exists('$(_ContainersTargetsDir)Microsoft.NET.Build.Containers.targets')">

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Containers/build/Microsoft.NET.Build.Containers.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <_IsSDKContainerAllowedVersion>false</_IsSDKContainerAllowedVersion>
    <!-- Anything newer than 7.0.100-preview.7 is supported -->
    <_IsSDKContainerAllowedVersion Condition="$([MSBuild]::VersionGreaterThan($(NetCoreSdkVersion), 7.0.100))&#xA;                       OR ( $([MSBuild]::VersionEquals($(NetCoreSdkVersion), 7.0.100))&#xA;                            AND (&#xA;                                 $(NETCoreSdkVersion.Contains('-preview.7'))&#xA;                                 OR $(NETCoreSdkVersion.Contains('-rc'))&#xA;                                 OR $(NETCoreSdkVersion.Contains('-')) == false&#xA;                                )&#xA;                          )">true</_IsSDKContainerAllowedVersion>
    <_ContainerIsTargetingNet8TFM>false</_ContainerIsTargetingNet8TFM>
    <_ContainerIsTargetingNet8TFM Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '8.0'))">true</_ContainerIsTargetingNet8TFM>
    <_ContainerIsSelfContained>false</_ContainerIsSelfContained>
    <_ContainerIsSelfContained Condition="'$(SelfContained)' == 'true' or '$(PublishSelfContained)' == 'true'">true</_ContainerIsSelfContained>
    <EnableSdkContainerSupport Condition="'$(EnableSdkContainerSupport)' == '' and '$(OutputType)' != 'Library'">true</EnableSdkContainerSupport>
  </PropertyGroup>
  <ItemGroup>
    <ProjectCapability Include="NetSdkOCIImageBuild" />
  </ItemGroup>
  <Target Name="_ContainerVerifySDKVersion" Condition="'$(WebPublishMethod)' == 'Container' or '$(PublishProfile)' == 'DefaultContainer'" BeforeTargets="AfterPublish">
    <!-- If the user has opted into container publishing via their own profile (WebPublishMethod = Container) or
            via the default Profile (PublishProfile = DefaultContainer), make sure they're on a supported SDK version.
            We do the explicit profile name check here because for preview6 for example the profile didn't exist, so we
            can't rely only on the WebPublishMethod. -->
    <Error Condition="'$(_IsSDKContainerAllowedVersion)' != 'true'" Code="CONTAINER002" Text="The current .NET SDK ($(NETCoreSdkVersion)) doesn't support containerization. Please use version 7.0.100 or higher to enable containerization." />
  </Target>
  <Target Name="ComputeContainerBaseImage" Returns="$(ContainerBaseImage)">
    <PropertyGroup>
      <!-- The Container RID should default to the RID used for the entire build (to ensure things run on the platform they are built for), but the user knows best and so should be able to set it explicitly.
           For builds that have a RID, we default to that RID. Otherwise, we default to the Linux RID matching the architecture of the currently-executing SDK. -->
      <ContainerRuntimeIdentifier Condition="'$(ContainerRuntimeIdentifier)' == '' and '$(RuntimeIdentifier)' != ''">$(RuntimeIdentifier)</ContainerRuntimeIdentifier>
      <ContainerRuntimeIdentifiers Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(ContainerRuntimeIdentifiers)' == '' and '$(IsRidAgnostic)' != 'true'">$(RuntimeIdentifiers)</ContainerRuntimeIdentifiers>
      <ContainerRuntimeIdentifier Condition="'$(ContainerRuntimeIdentifier)' == '' and '$(ContainerRuntimeIdentifiers)' == ''">linux-$(NETCoreSdkPortableRuntimeIdentifier.Split('-')[1])</ContainerRuntimeIdentifier>
      <!-- We want to save customer provided ContainerBaseImage to later set ContainerUser. -->
      <_InitialContainerBaseImage>$(ContainerBaseImage)</_InitialContainerBaseImage>
    </PropertyGroup>
    <ItemGroup>
      <_TargetRuntimeIdentifiers Include="$(ContainerRuntimeIdentifier)" Condition="'$(ContainerRuntimeIdentifier)' != ''" />
      <_TargetRuntimeIdentifiers Include="$(ContainerRuntimeIdentifiers)" Condition="@(_TargetRuntimeIdentifiers-&gt;Count()) == 0" />
    </ItemGroup>
    <ComputeDotnetBaseImageAndTag UserBaseImage="$(ContainerBaseImage)" SdkVersion="$(NetCoreSdkVersion)" TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV).0" FrameworkReferences="@(FrameworkReference)" IsSelfContained="$(_ContainerIsSelfContained)" IsAotPublished="$(PublishAot)" IsTrimmed="$(PublishTrimmed)" UsesInvariantGlobalization="$(InvariantGlobalization)" TargetRuntimeIdentifiers="@(_TargetRuntimeIdentifiers)" ContainerFamily="$(ContainerFamily)">
      <Output TaskParameter="ComputedContainerBaseImage" PropertyName="ContainerBaseImage" />
    </ComputeDotnetBaseImageAndTag>
    <ItemGroup>
      <_TargetRuntimeIdentifiers Remove="$(_TargetRuntimeIdentifiers)" />
    </ItemGroup>
  </Target>
  <!-- This Target is called early on in the chain for both single-RID and multi-RID containers - but for single-RID it's important
       that we ensure all of the data necessary to create a single-RID container is computed after we exit this target. -->
  <Target Name="ComputeContainerConfig" DependsOnTargets="ComputeContainerBaseImage;_ContainerEstablishRIDNess;_ComputeContainerExecutionArgs">
    <PropertyGroup Label="VS defaults">
      <!-- RegistryUrl is used by existing VS targets for Docker builds - this lets us fill that void -->
      <ContainerRegistry Condition="'$(RegistryUrl)' != ''">$(RegistryUrl)</ContainerRegistry>
      <!-- PublishImageTag is used by existing VS targets for Docker builds - this lets us fill that void -->
      <ContainerImageTag Condition="'$(PublishImageTag)' != ''">$(PublishImageTag)</ContainerImageTag>
      <!-- This line is a compatibility shim for VS support - the VS container targets define a container tag using this property and format. This lets us be a drop-in replacement for them. -->
      <ContainerImageTag Condition="'$(AutoGenerateImageTag)' == 'true'">$([System.DateTime]::UtcNow.ToString('yyyyMMddhhmmss'))</ContainerImageTag>
    </PropertyGroup>
    <!-- Compatibility: previous versions used ImageName, but the proper term is Repository. Keep using that if explicitly set. -->
    <Warning Condition="'$(ContainerImageName)' != ''" Code="CONTAINER003" Text="The property 'ContainerImageName' was set but is obsolete - please use 'ContainerRepository' instead." />
    <!-- Container Defaults -->
    <PropertyGroup>
      <!-- An empty ContainerRegistry implies pushing to the local registry, putting this here for documentation purposes -->
      <!-- <ContainerRegistry></ContainerRegistry> -->
      <!-- An empty LocalRegistry implies detecting the local registry. LocalRegistry can be set explicity to Docker/Podman. -->
      <!-- <LocalRegistry></LocalRegistry> -->
      <!-- Compatibility: previous versions used ImageName, but the proper term is Repository. Keep using that if explicitly set. -->
      <ContainerRepository Condition="'$(ContainerImageName)' != ''">$(ContainerImageName)</ContainerRepository>
      <!-- Note: spaces will be replaced with '-' in ContainerRepository and ContainerImageTag -->
      <ContainerRepository Condition="'$(ContainerRepository)' == ''">$(AssemblyName)</ContainerRepository>
      <!-- Only default a tag name if no tag names at all are provided -->
      <ContainerImageTag Condition="'$(ContainerImageTag)' == '' and '$(ContainerImageTags)' == ''">latest</ContainerImageTag>
      <ContainerImageTag Condition="'$(AutoGenerateImageTag)' == 'true' and '$(ContainerImageTags)' == ''">$([System.DateTime]::UtcNow.ToString('yyyyMMddhhmmss'))</ContainerImageTag>
    </PropertyGroup>
    <ParseContainerProperties FullyQualifiedBaseImageName="$(ContainerBaseImage)" ContainerRegistry="$(ContainerRegistry)" ContainerRepository="$(ContainerRepository)" ContainerImageTag="$(ContainerImageTag)" ContainerImageTags="$(ContainerImageTags)" ContainerEnvironmentVariables="@(ContainerEnvironmentVariable)">
      <Output TaskParameter="ParsedContainerRegistry" PropertyName="ContainerBaseRegistry" />
      <Output TaskParameter="ParsedContainerImage" PropertyName="ContainerBaseName" />
      <Output TaskParameter="ParsedContainerTag" PropertyName="ContainerBaseTag" />
      <Output TaskParameter="ParsedContainerDigest" PropertyName="ContainerBaseDigest" />
      <Output TaskParameter="NewContainerRegistry" PropertyName="ContainerRegistry" />
      <Output TaskParameter="NewContainerRepository" PropertyName="ContainerRepository" />
      <Output TaskParameter="NewContainerTags" ItemName="ContainerImageTags" />
      <Output TaskParameter="NewContainerEnvironmentVariables" ItemName="ContainerEnvironmentVariables" />
    </ParseContainerProperties>
    <PropertyGroup>
      <ContainerGenerateLabels Condition="'$(ContainerGenerateLabels)' == ''">true</ContainerGenerateLabels>
      <ContainerGenerateLabelsImageCreated Condition="'$(ContainerGenerateLabelsImageCreated)' == ''">true</ContainerGenerateLabelsImageCreated>
      <ContainerGenerateLabelsImageDescription Condition="'$(ContainerGenerateLabelsImageDescription)' == ''">true</ContainerGenerateLabelsImageDescription>
      <ContainerGenerateLabelsImageAuthors Condition="'$(ContainerGenerateLabelsImageAuthors)' == ''">true</ContainerGenerateLabelsImageAuthors>
      <ContainerGenerateLabelsImageUrl Condition="'$(ContainerGenerateLabelsImageUrl)' == ''">true</ContainerGenerateLabelsImageUrl>
      <ContainerGenerateLabelsImageDocumentation Condition="'$(ContainerGenerateLabelsImageDocumentation)' == ''">true</ContainerGenerateLabelsImageDocumentation>
      <ContainerGenerateLabelsImageSource Condition="'$(ContainerGenerateLabelsImageSource)' == ''">true</ContainerGenerateLabelsImageSource>
      <ContainerGenerateLabelsImageVersion Condition="'$(ContainerGenerateLabelsImageVersion)' == ''">true</ContainerGenerateLabelsImageVersion>
      <ContainerGenerateLabelsImageRevision Condition="'$(ContainerGenerateLabelsImageRevision)' == ''">true</ContainerGenerateLabelsImageRevision>
      <ContainerGenerateLabelsImageVendor Condition="'$(ContainerGenerateLabelsImageVendor)' == ''">true</ContainerGenerateLabelsImageVendor>
      <ContainerGenerateLabelsImageLicenses Condition="'$(ContainerGenerateLabelsImageLicenses)' == ''">true</ContainerGenerateLabelsImageLicenses>
      <ContainerGenerateLabelsImageTitle Condition="'$(ContainerGenerateLabelsImageTitle)' == ''">true</ContainerGenerateLabelsImageTitle>
      <ContainerGenerateLabelsImageBaseDigest Condition="'$(ContainerGenerateLabelsImageBaseDigest)' == ''">true</ContainerGenerateLabelsImageBaseDigest>
      <ContainerGenerateLabelsImageBaseName Condition="'$(ContainerGenerateLabelsImageBaseName)' == ''">true</ContainerGenerateLabelsImageBaseName>
      <ContainerGenerateLabelsDotnetToolset Condition="'$(ContainerGenerateLabelsDotnetToolset)' == ''">true</ContainerGenerateLabelsDotnetToolset>
    </PropertyGroup>
    <PropertyGroup Label="Defaults for Container Labels">
      <ContainerDescription Condition="'$(ContainerDescription)' == '' and '$(Description)' != ''">$(Description)</ContainerDescription>
      <ContainerAuthors Condition="'$(ContainerAuthors)' == '' and '$(Authors)' != ''">$(Authors)</ContainerAuthors>
      <ContainerInformationUrl Condition="'$(ContainerInformationUrl)' == '' and '$(PackageProjectUrl)' != ''">$(PackageProjectUrl)</ContainerInformationUrl>
      <ContainerDocumentationUrl Condition="'$(ContainerDocumentationUrl)' == '' and '$(PackageProjectUrl)' != ''">$(PackageProjectUrl)</ContainerDocumentationUrl>
      <ContainerVersion Condition="'$(ContainerVersion)' == '' and '$(PackageVersion)' != ''">$(PackageVersion)</ContainerVersion>
      <ContainerLicenseExpression Condition="'$(ContainerLicenseExpression)' == '' and '$(PackageLicenseExpression)' != ''">$(PackageLicenseExpression)</ContainerLicenseExpression>
      <ContainerTitle Condition="'$(ContainerTitle)' == '' and '$(Title)' != ''">$(Title)</ContainerTitle>
    </PropertyGroup>
    <!-- Labels generated from descriptions from the spec at https://github.com/opencontainers/image-spec/blob/main/annotations.md#pre-defined-annotation-keys -->
    <ItemGroup Label="Conventional Label assignment" Condition="'$(ContainerGenerateLabels)' == 'true'">
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageCreated)' == 'true'" Include="org.opencontainers.image.created;org.opencontainers.artifact.created" Value="$([System.DateTime]::UtcNow.ToString('o'))" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageDescription)' == 'true' and '$(ContainerDescription)' != ''" Include="org.opencontainers.artifact.description;org.opencontainers.image.description" Value="$(ContainerDescription)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageAuthors)' == 'true' and '$(ContainerAuthors)' != ''" Include="org.opencontainers.image.authors" Value="$(ContainerAuthors)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageUrl)' == 'true' and '$(ContainerInformationUrl)' != ''" Include="org.opencontainers.image.url" Value="$(ContainerInformationUrl)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageDocumentation)' == 'true' and '$(ContainerDocumentationUrl)' != ''" Include="org.opencontainers.image.documentation" Value="$(ContainerDocumentationUrl)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageVersion)' == 'true' and '$(ContainerVersion)' != ''" Include="org.opencontainers.image.version" Value="$(ContainerVersion)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageVendor)' == 'true' and '$(ContainerVendor)' != ''" Include="org.opencontainers.image.vendor" Value="$(ContainerVendor)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageLicenses)' == 'true' and '$(ContainerLicenseExpression)' != ''" Include="org.opencontainers.image.licenses" Value="$(ContainerLicenseExpression)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageTitle)' == 'true' and '$(ContainerTitle)' != ''" Include="org.opencontainers.image.title" Value="$(ContainerTitle)" />
      <!-- Need to compute digests, not just names, before we can light this up. This suggests we need a task where all of the 'read' steps are done. -->
      <!-- <ContainerLabel Condition="'$(ContainerGenerateLabelsImageBaseDigest)' == 'true' and '$(ContainerBaseImageDigest)' != ''" Include="org.opencontainers.image.base.digest" Value="$(ContainerBaseImageDigest)" /> -->
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageBaseName)' == 'true' and '$(ContainerBaseImage)' != ''" Include="org.opencontainers.image.base.name" Value="$(ContainerBaseImage)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsDotnetToolset)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" Include="net.dot.runtime.majorminor" Value="$(_TargetFrameworkVersionWithoutV)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsDotnetToolset)' == 'true'" Include="net.dot.sdk.version" Value="$(NETCoreSdkVersion)" />
    </ItemGroup>
    <!-- These sourcelink-derived properties are only allowed to flow to generated artifacts if `PublishRepositoryUrl` is set as a user signal for opt-in.
             In addition, the 'nice' property names are currently set by NuGet Pack targets and so we have to use the private/generic names here. -->
    <PropertyGroup Label="Source control label assignment" Condition="'$(ContainerGenerateLabels)' == 'true' and '$(PublishRepositoryUrl)' == 'true'">
      <!-- Sourcelink gives us the .git suffix, but scanning tools aren't looking for that so we trim it off here. -->
      <_TrimmedRepositoryUrl Condition="'$(RepositoryType)' == 'git' and '$(PrivateRepositoryUrl)' != '' and $(PrivateRepositoryUrl.EndsWith('.git'))">$(PrivateRepositoryUrl.Substring(0, $(PrivateRepositoryUrl.LastIndexOf('.git'))))</_TrimmedRepositoryUrl>
      <_TrimmedRepositoryUrl Condition="'$(_TrimmedRepositoryUrl)' == '' and '$(PrivateRepositoryUrl)' != ''">$(PrivateRepositoryUrl)</_TrimmedRepositoryUrl>
    </PropertyGroup>
    <ItemGroup Label="Source control label assignment" Condition="'$(ContainerGenerateLabels)' == 'true' and '$(PublishRepositoryUrl)' == 'true'">
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageSource)' == 'true' and '$(_TrimmedRepositoryUrl)' != ''" Include="org.opencontainers.image.source" Value="$(_TrimmedRepositoryUrl)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageRevision)' == 'true' and '$(SourceRevisionId)' != ''" Include="org.opencontainers.image.revision" Value="$(SourceRevisionId)" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <PublishContainerDependsOn>
      _ContainerVerifySDKVersion;
      ComputeContainerConfig;
      _CheckContainersPackage;
    </PublishContainerDependsOn>
  </PropertyGroup>
  <!-- These args are relevant to container execution and are per-RID by nature. Therefore they're a direct dependency of the _PublishSingleContainer
       target and not computed at the outer, multi-RID build layer. -->
  <Target Name="_ComputeContainerExecutionArgs" DependsOnTargets="_ContainerEstablishRIDNess" Condition="'$(_IsSingleRIDBuild)' == 'true'">
    <PropertyGroup>
      <!-- The Container RID should default to the RID used for the entire build (to ensure things run on the platform they are built for), but the user knows best and so should be able to set it explicitly.
           For builds that have a RID, we default to that RID. Otherwise, we default to the Linux RID matching the architecture of the currently-executing SDK. -->
      <_ContainerIsTargetingWindows>false</_ContainerIsTargetingWindows>
      <_ContainerIsTargetingWindows Condition="$(ContainerRuntimeIdentifier.StartsWith('win'))">true</_ContainerIsTargetingWindows>
      <!-- Set the WorkingDirectory depending on the RID -->
      <ContainerWorkingDirectory Condition="'$(ContainerWorkingDirectory)' == '' and !$(_ContainerIsTargetingWindows)">/app/</ContainerWorkingDirectory>
      <ContainerWorkingDirectory Condition="'$(ContainerWorkingDirectory)' == '' and $(_ContainerIsTargetingWindows)">C:\app\</ContainerWorkingDirectory>
      <_ContainerIsUsingMicrosoftDefaultImages Condition="'$(_InitialContainerBaseImage)' == ''">true</_ContainerIsUsingMicrosoftDefaultImages>
      <_ContainerIsUsingMicrosoftDefaultImages Condition="'$(_InitialContainerBaseImage)' != ''">false</_ContainerIsUsingMicrosoftDefaultImages>
    </PropertyGroup>
    <!-- We only set a default user when the base image is Microsoft-authored, and we're targeting a version of those images that supports a nonroot user -->
    <PropertyGroup Label="ContainerUser Assignment" Condition="$(_ContainerIsUsingMicrosoftDefaultImages) and $(_ContainerIsTargetingNet8TFM) and '$(ContainerUser)' == ''">
      <ContainerUser Condition="$(_ContainerIsTargetingWindows)">ContainerUser</ContainerUser>
    </PropertyGroup>
    <ItemGroup Label="AppCommand Assignment" Condition="'$(ContainerAppCommandInstruction)' != 'None'">
      <!-- For self-contained, invoke the native executable as a single arg -->
      <ContainerAppCommand Condition="@(ContainerAppCommand-&gt;Count()) == 0 and $(_ContainerIsSelfContained)" Include="$(ContainerWorkingDirectory)$(AssemblyName)$(_NativeExecutableExtension)" />
      <!-- For non self-contained, invoke `dotnet` `app.dll` as separate args -->
      <ContainerAppCommand Condition="@(ContainerAppCommand-&gt;Count()) == 0 and !$(_ContainerIsSelfContained)" Include="dotnet;$(ContainerWorkingDirectory)$(TargetFileName)" />
    </ItemGroup>
  </Target>
  <Target Name="_CheckContainersPackage" AfterTargets="Build">
    <PropertyGroup>
      <!-- facts to base on comparisons on -->
      <_ContainersPackageIdentity>Microsoft.NET.Build.Containers</_ContainersPackageIdentity>
      <_WebDefaultSdkVersion>7.0.300</_WebDefaultSdkVersion>
      <_WorkerDefaultSdkVersion>8.0.100</_WorkerDefaultSdkVersion>
      <_ConsoleDefaultSdkVersion>8.0.200</_ConsoleDefaultSdkVersion>
      <!-- capability detection for the executing SDK -->
      <_SdkCanPublishWeb>$([MSBuild]::VersionGreaterThanOrEquals('$(NETCoreSdkVersion)', '$(_WebDefaultSdkVersion)'))</_SdkCanPublishWeb>
      <_SdkCanPublishWorker>$([MSBuild]::VersionGreaterThanOrEquals('$(NETCoreSdkVersion)', '$(_WorkerDefaultSdkVersion)'))</_SdkCanPublishWorker>
      <_SdkCanPublishConsole>$([MSBuild]::VersionGreaterThanOrEquals('$(NETCoreSdkVersion)', '$(_ConsoleDefaultSdkVersion)'))</_SdkCanPublishConsole>
      <!-- capability detection for the executing project -->
      <_ContainerPackageIsPresent>false</_ContainerPackageIsPresent>
      <_ContainerPackageIsPresent Condition="@(PackageReference-&gt;AnyHaveMetadataValue('Identity', '$(_ContainersPackageIdentity)'))">true</_ContainerPackageIsPresent>
      <_IsWebProject>false</_IsWebProject>
      <_IsWebProject Condition="@(ProjectCapability-&gt;AnyHaveMetadataValue('Identity', 'DotNetCoreWeb'))">true</_IsWebProject>
      <_IsWorkerProject>false</_IsWorkerProject>
      <_IsWorkerProject Condition="@(ProjectCapability-&gt;AnyHaveMetadataValue('Identity', 'DotNetCoreWorker'))">true</_IsWorkerProject>
    </PropertyGroup>
    <Warning Condition="$(_ContainerPackageIsPresent)&#xA;        and (&#xA;          ($(_SdkCanPublishWeb) and $(_IsWebProject)) or&#xA;          ($(_SdkCanPublishWorker) and $(_IsWorkerProject)) or&#xA;          ($(_SdkCanPublishConsole) and '$(EnableSdkContainerSupport)' == 'true')&#xA;        )" Code="CONTAINER005" Text="The $(_ContainersPackageIdentity) NuGet package is explicitly referenced but the current SDK can natively publish the project as a container. Consider removing the package reference to $(_ContainersPackageIdentity) because it is no longer needed." />
  </Target>
  <!-- There is an implicit dependency here in that both of ComputeContainerConfig and _ComputeContainerExecutionArgs must have been run, but because we call this Target
       in a few different ways we can't express that dependency directly here. -->
  <Target Name="_PublishSingleContainer" Returns="@(GeneratedContainer)">
    <PropertyGroup Condition="'$(DOTNET_HOST_PATH)' == ''">
      <DotNetHostDirectory>$(NetCoreRoot)</DotNetHostDirectory>
      <DotNetHostFileName>dotnet</DotNetHostFileName>
      <DotNetHostFileName Condition="'$(OS)' == 'Windows_NT'">dotnet.exe</DotNetHostFileName>
    </PropertyGroup>
    <CreateNewImage ContainerizeDirectory="$(ContainerizeFolder)" ToolPath="$(DotNetHostDirectory)" ToolExe="$(DotNetHostFileName)" BaseRegistry="$(ContainerBaseRegistry)" BaseImageName="$(ContainerBaseName)" BaseImageTag="$(ContainerBaseTag)" BaseImageDigest="$(ContainerBaseDigest)" ImageFormat="$(ContainerImageFormat)" LocalRegistry="$(LocalRegistry)" OutputRegistry="$(ContainerRegistry)" ArchiveOutputPath="$(ContainerArchiveOutputPath)" Repository="$(ContainerRepository)" ImageTags="@(ContainerImageTags)" PublishDirectory="$(PublishDir)" WorkingDirectory="$(ContainerWorkingDirectory)" Entrypoint="@(ContainerEntrypoint)" EntrypointArgs="@(ContainerEntrypointArgs)" AppCommand="@(ContainerAppCommand)" AppCommandArgs="@(ContainerAppCommandArgs)" AppCommandInstruction="$(ContainerAppCommandInstruction)" DefaultArgs="@(ContainerDefaultArgs)" Labels="@(ContainerLabel)" ExposedPorts="@(ContainerPort)" ContainerEnvironmentVariables="@(ContainerEnvironmentVariables)" ContainerRuntimeIdentifier="$(ContainerRuntimeIdentifier)" ContainerUser="$(ContainerUser)" RuntimeIdentifierGraphPath="$(RuntimeIdentifierGraphPath)" SkipPublishing="$(_SkipContainerPublishing)" GenerateLabels="$(ContainerGenerateLabels)" GenerateDigestLabel="$(ContainerGenerateLabelsImageBaseDigest)">
      <!-- The RID graph path is provided as a property by the SDK. -->
      <Output TaskParameter="GeneratedContainerManifest" PropertyName="GeneratedContainerManifest" />
      <Output TaskParameter="GeneratedContainerConfiguration" PropertyName="GeneratedContainerConfiguration" />
      <Output TaskParameter="GeneratedContainerDigest" PropertyName="GeneratedContainerDigest" />
      <Output TaskParameter="GeneratedArchiveOutputPath" PropertyName="GeneratedArchiveOutputPath" />
      <Output TaskParameter="GeneratedContainerMediaType" PropertyName="GeneratedContainerMediaType" />
      <Output TaskParameter="GeneratedContainerNames" ItemName="GeneratedContainerName" />
      <Output TaskParameter="GeneratedDigestLabel" ItemName="ContainerLabel" />
    </CreateNewImage>
    <ItemGroup>
      <GeneratedContainer Include="GeneratedContainer">
        <Manifest>$(GeneratedContainerManifest)</Manifest>
        <Configuration>$(GeneratedContainerConfiguration)</Configuration>
        <ManifestDigest>$(GeneratedContainerDigest)</ManifestDigest>
        <ManifestMediaType>$(GeneratedContainerMediaType)</ManifestMediaType>
      </GeneratedContainer>
    </ItemGroup>
  </Target>
  <Target Name="_PublishMultiArchContainers" DependsOnTargets="$(PublishContainerDependsOn)" Returns="@(GeneratedContainer)">
    <PropertyGroup>
      <!--We want to skip publishing individual images in case of multi-arch tarball publishing or local daemon (only docker) publishing because all images are published in one tarball.-->
      <!--We don't want to skip publishing individual images in case of remote registry because the individual images should be available in the registry before image index is pushed.-->
      <!--We don't want to skip publishing individual images in case of local daemon podman because podman loads multi-arch tarball differently - only individual image for the current platform.-->
      <_SkipContainerPublishing>false</_SkipContainerPublishing>
      <_SkipContainerPublishing Condition="$(ContainerArchiveOutputPath) != '' or ( $(ContainerRegistry) == '' and ( $(LocalRegistry) == '' or $(LocalRegistry) == 'Docker' ) )">true</_SkipContainerPublishing>
      <!--We want to skip CreateImageIndex task in case of local daemon podman because it is not supported.-->
      <_SkipCreateImageIndex>false</_SkipCreateImageIndex>
      <_SkipCreateImageIndex Condition="$(ContainerArchiveOutputPath) == '' and $(ContainerRegistry) == '' and $(LocalRegistry) == 'Podman'">true</_SkipCreateImageIndex>
      <!-- Figure out what format the inner images should be coerced to -->
      <!-- If a user had an opinion, use that -->
      <_SingleImageContainerFormat Condition="'$(ContainerImageFormat)' != ''">$(ContainerImageFormat)</_SingleImageContainerFormat>
      <!-- If we are publishing to local tarball or to local Docker, force OCI to prevent mismatches between inner images and the outer manifest -->
      <_SingleImageContainerFormat Condition="$(_SkipContainerPublishing) == 'true' ">OCI</_SingleImageContainerFormat>
    </PropertyGroup>
    <ItemGroup>
      <_rids Include="$(ContainerRuntimeIdentifiers)" Condition="'$(ContainerRuntimeIdentifiers)' != ''" />
      <_rids Include="$(RuntimeIdentifiers)" Condition="'$(ContainerRuntimeIdentifiers)' == '' and '$(RuntimeIdentifiers)' != ''" />
      <_InnerBuild Include="$(MSBuildProjectFullPath)" AdditionalProperties="&#xA;          ContainerRuntimeIdentifier=%(_rids.Identity);&#xA;          RuntimeIdentifier=%(_rids.Identity);&#xA;          ContainerBaseRegistry=$(ContainerBaseRegistry);&#xA;          ContainerBaseName=$(ContainerBaseName);&#xA;          ContainerBaseTag=$(ContainerBaseTag);&#xA;          ContainerBaseDigest=$(ContainerBaseDigest);&#xA;          ContainerRegistry=$(ContainerRegistry);&#xA;          _ContainerImageTags=@(ContainerImageTags, ';');&#xA;          ContainerRepository=$(ContainerRepository);&#xA;          _ContainerLabel=@(ContainerLabel->'%(Identity):%(Value)');&#xA;          _ContainerPort=@(ContainerPort->'%(Identity):%(Type)');&#xA;          _ContainerEnvironmentVariables=@(ContainerEnvironmentVariable->'%(Identity):%(Value)');&#xA;          ContainerGenerateLabels=$(ContainerGenerateLabels);&#xA;          ContainerGenerateLabelsImageBaseDigest=$(ContainerGenerateLabelsImageBaseDigest);&#xA;          _SkipContainerPublishing=$(_SkipContainerPublishing);&#xA;          ContainerImageFormat=$(_SingleImageContainerFormat);&#xA;          _IsMultiRIDBuild=false;&#xA;          _IsSingleRIDBuild=true;&#xA;          _InitialContainerBaseImage=$(_InitialContainerBaseImage)&#xA;        " />
      <_rids Remove="$(_rids)" />
    </ItemGroup>
    <MSBuild Projects="@(_InnerBuild)" Targets="Publish;_ParseItemsForPublishingSingleContainer;_ComputeContainerExecutionArgs;_PublishSingleContainer" BuildInParallel="$([MSBuild]::ValueOrDefault('$(ContainerPublishInParallel)', 'true'))">
      <Output TaskParameter="TargetOutputs" ItemName="GeneratedContainer" />
    </MSBuild>
    <CreateImageIndex Condition="'$(_SkipCreateImageIndex)' == 'false' " GeneratedContainers="@(GeneratedContainer)" LocalRegistry="$(LocalRegistry)" OutputRegistry="$(ContainerRegistry)" ArchiveOutputPath="$(ContainerArchiveOutputPath)" Repository="$(ContainerRepository)" ImageTags="@(ContainerImageTags)" BaseRegistry="$(ContainerBaseRegistry)" BaseImageName="$(ContainerBaseName)" BaseImageTag="$(ContainerBaseTag)" BaseImageDigest="$(ContainerBaseDigest)">
      <Output TaskParameter="GeneratedImageIndex" PropertyName="GeneratedImageIndex" />
      <Output TaskParameter="GeneratedArchiveOutputPath" PropertyName="GeneratedArchiveOutputPath" />
    </CreateImageIndex>
  </Target>
  <Target Name="_ParseItemsForPublishingSingleContainer">
    <ItemGroup>
      <OriginalImageTags Include="$(_ContainerImageTags)" />
      <ContainerImageTags Include="@(OriginalImageTags->'%(Identity)-$(ContainerRuntimeIdentifier)')" />
      <_ParsedContainerLabel Condition="'$(_ContainerLabel)' != ':'" Include="$(_ContainerLabel)" />
      <ContainerLabel Condition="@(_ParsedContainerLabel-&gt;Count()) &gt; 0 " Include="$([System.String]::Copy('%(_ParsedContainerLabel.Identity)').Split(':')[0])" Value="$([System.String]::Copy('%(_ParsedContainerLabel.Identity)').Split(':')[1])" />
      <_ParsedContainerPort Condition="'$(_ContainerPort)' != ':'" Include="$(_ContainerPort)" />
      <ContainerPort Condition="@(_ParsedContainerPort-&gt;Count()) &gt; 0 " Include="$([System.String]::Copy('%(_ParsedContainerPort.Identity)').Split(':')[0])" Type="$([System.String]::Copy('%(_ParsedContainerPort.Identity)').Split(':')[1])" />
      <_ParsedContainerEnvironmentVariables Condition="'$(_ContainerEnvironmentVariables)' != ':'" Include="$(_ContainerEnvironmentVariables)" />
      <ContainerEnvironmentVariables Condition="@(_ParsedContainerEnvironmentVariables-&gt;Count()) &gt; 0 " Include="$([System.String]::Copy('%(_ParsedContainerEnvironmentVariables.Identity)').Split(':')[0])" Value="$([System.String]::Copy('%(_ParsedContainerEnvironmentVariables.Identity)').Split(':')[1])" />
    </ItemGroup>
  </Target>
  <Target Name="_ContainerEstablishRIDNess">
    <PropertyGroup>
      <_IsMultiTFMBuild Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''">true</_IsMultiTFMBuild>
      <!-- we are multi-RID if:
          * we have CRIDs and no CRID
          * we have RIDs and no (CRIDs or CRID or RID)
      -->
      <_HasCRIDsAndNoCRID Condition="'$(ContainerRuntimeIdentifiers)' != '' and '$(ContainerRuntimeIdentifier)' == ''">true</_HasCRIDsAndNoCRID>
      <_HasRIDs Condition="'$(RuntimeIdentifiers)' != ''">true</_HasRIDs>
      <_NoCRIDsOrCRIDorRID Condition="'$(ContainerRuntimeIdentifiers)' == '' and '$(ContainerRuntimeIdentifier)' == '' and '$(RuntimeIdentifier)' == ''">true</_NoCRIDsOrCRIDorRID>
      <!-- these two are load-bearing for other comparisons - see _ComputeContainerExecutionArgs -->
      <_IsMultiRIDBuild Condition="'$(BuildingInsideVisualStudio)' != 'true' and ('$(_HasCRIDsAndNoCRID)' == true or ('$(_HasRIDs)' == 'true' and '$(_NoCRIDsOrCRIDorRID)' == 'true'))">true</_IsMultiRIDBuild>
      <_IsSingleRIDBuild Condition="'$(_IsMultiRIDBuild)' == ''">true</_IsSingleRIDBuild>
    </PropertyGroup>
  </Target>
  <Target Name="PublishContainer" DependsOnTargets="$(PublishContainerDependsOn)" Condition="'$(IsPublishable)' == 'true' AND '$(EnableSdkContainerSupport)' == 'true'" Returns="@(GeneratedContainer)">
    <!-- Call _PublishMultiArchContainers if we are in a multi-rid build, and call _PublishSingleContainer if we are in a single-RID build -->
    <CallTarget Condition="'$(_IsMultiRIDBuild)' == 'true' " Targets="_PublishMultiArchContainers">
      <Output TaskParameter="TargetOutputs" ItemName="GeneratedContainer" />
    </CallTarget>
    <CallTarget Condition="'$(_IsSingleRIDBuild)' == 'true' " Targets="_PublishSingleContainer">
      <Output TaskParameter="TargetOutputs" ItemName="GeneratedContainer" />
    </CallTarget>
    <Error Condition="'$(_IsMultiTFMBuild)' == 'true'" Code="CONTAINERS0666" Text="Containers cannot be published for multiple TargetFrameworks at this time. Please specify a TargetFramework." />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/usr/share/dotnet/sdk/10.0.100-rc.1.25420.111/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/fsharp/fsharp/tests/EndToEndBuildTests/DesignTimeProviderPackaging/Provider/Provider.fsproj
============================================================================================================================================
-->
</Project>