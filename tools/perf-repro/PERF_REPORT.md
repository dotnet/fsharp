# F# Compiler Performance Analysis - xUnit Assert.Equal Issue #18807

*This is a sample/template report showing the expected output format*

*Generated: 2025-11-11 13:21:15*

## Test Configuration
- **Total Assert.Equal calls**: 1500
- **Test methods**: 10
- **Type variants**: int, string, float, bool, int64, decimal, byte, char

## Compilation Times

### Untyped Version (Slow Path)
- **Total compilation time**: 150.23 seconds
- **Time per Assert.Equal**: 100.15 ms

### Typed Version (Fast Path)
- **Total compilation time**: 4.87 seconds
- **Time per Assert.Equal**: 3.25 ms

### Performance Difference
- **Slowdown factor**: 30.85x
- **Time difference**: 145.36 seconds

## Hot Path Analysis

### Trace Analysis

*Note: Detailed trace analysis not available. Install dotnet-trace for detailed profiling.*
*For detailed profiling, ensure dotnet-trace is installed and has proper permissions.*

## Key Findings

### Performance Impact of Untyped Assert.Equal

⚠️ **Critical**: Each untyped `Assert.Equal` call adds approximately **100.15 ms** to compilation time.
In contrast, typed calls add only **3.25 ms** each.

⚠️ **Severe Slowdown**: The untyped version is **30.8x slower** than the typed version.

### Likely Root Causes (Based on Issue Analysis)

Based on the issue discussion and F# compiler architecture:

1. **Overload Resolution Complexity**
   - xUnit's `Assert.Equal` has many overloads
   - F# compiler tries each overload during type inference
   - Each attempt typechecks the full overload signature
   - Location: `src/Compiler/Checking/ConstraintSolver.fs` around line 3486

2. **Type Inference Without Explicit Types**
   - Untyped calls force the compiler to infer types from usage
   - This requires constraint solving for each Assert.Equal call
   - Typed calls bypass most of this overhead

3. **Lack of Caching**
   - Overload resolution results may not be cached
   - Each Assert.Equal call repeats the same expensive analysis

## Optimization Opportunities

### 1. Overload Resolution Caching (High Impact)
- **Location**: `src/Compiler/Checking/ConstraintSolver.fs`
- **Opportunity**: Cache overload resolution results for identical call patterns
- **Expected Impact**: Could reduce compilation time by 50-80% for repetitive patterns
- **Rationale**: Many Assert.Equal calls have identical type patterns

### 2. Early Overload Pruning (Medium Impact)
- **Location**: `src/Compiler/Checking/MethodCalls.fs`
- **Opportunity**: Filter incompatible overloads before full type checking
- **Expected Impact**: Could reduce time by 30-50%
- **Rationale**: Many overloads can be ruled out based on argument count/types

### 3. Incremental Type Inference (Medium Impact)
- **Location**: `src/Compiler/Checking/TypeChecker.fs`
- **Opportunity**: Reuse partial type information across similar calls
- **Expected Impact**: Could reduce time by 20-40%

## Recommendations

### For Users (Immediate Workarounds)

1. **Add Type Annotations**
   ```fsharp
   Assert.Equal<int>(expected, actual)  // Explicit type
   ```

2. **Use Wrapper Functions**
   ```fsharp
   let assertEqual (x: 'T) (y: 'T) = Assert.Equal<'T>(x, y)
   assertEqual expected actual  // Type inferred once
   ```

### For Compiler Developers

1. **Profile with Real Traces**: Use PerfView or dotnet-trace to identify exact bottlenecks
2. **Focus on ConstraintSolver.fs**: This is the likely hot path
3. **Consider Overload Resolution Cache**: Biggest potential impact
4. **Benchmark Improvements**: Use this test suite to validate optimizations

## Trace File Locations

- Untyped version: Not generated
- Typed version: Not generated

## Raw Data

| Metric | Untyped (Slow) | Typed (Fast) | Difference |
|--------|----------------|--------------|------------|
| Total Time | 150.23s | 4.87s | 145.36s |
| Time/Assert | 100.15ms | 3.25ms | 96.91ms |
| Slowdown | 30.85x | 1.0x | - |

---

*This report was automatically generated by the F# compiler performance profiling suite.*
*For more information, see issue [#18807](https://github.com/dotnet/fsharp/issues/18807).*
