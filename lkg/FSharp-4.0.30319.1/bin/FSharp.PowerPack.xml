<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.PowerPack</name></assembly>
<members>
<member name="T:Microsoft.FSharp.AssemblyAttributes">

</member>
<member name="P:Microsoft.FSharp.Collections.HashMultiMap`2.Item(`0,`1)">
<summary>
 Lookup or set the given element in the table. Set replaces all existing bindings for a value with a single
 bindings. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the element is not found.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.HashMultiMap`2.Item(`0)">
<summary>
 Lookup or set the given element in the table. Set replaces all existing bindings for a value with a single
 bindings. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the element is not found.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.HashMultiMap`2.Count">
<summary>
 The total number of keys in the hash table
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.TryFind(`0)">
<summary>
 Lookup the given element in the table, returning the result as an Option
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Replace(`0,`1)">
<summary>
 Replace the latest binding (if any) for the given element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Remove(`0)">
<summary>
 Remove the latest binding (if any) for the given element from the table
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Iterate(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}}},``0)">
<summary>
 Apply the given function to each element in the collection threading the accumulating parameter
 through the sequence of function applications
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.FindAll(`0)">
<summary>
 Find all bindings for the given element in the table, if any
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Copy">
<summary>
 Make a shallow copy of the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.ContainsKey(`0)">
<summary>
 Test if the collection contains any bindings for the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Clear">
<summary>
 Clear all elements from the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Add(`0,`1)">
<summary>
 Add a binding for the element to the table
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple`2{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Create a new empty mutable HashMultiMap with an internal bucket array of the given approximate size
 and with the given key hash/equality functions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Create a new empty mutable HashMultiMap with the given key hash/equality functions
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.HashMultiMap`2">
<summary>
 Hash tables, by default based on F# structural &quot;hash&quot; and (=) functions. 
 The table may map a single key to multiple bindings.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.HashSet`1.Count">
<summary>
 The total number of elements in the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Remove(`0)">
<summary>
 Remove the given element from the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Iterate(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.Unit})">
<summary>
 Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Fold``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0)">
<summary>
 Apply the given function to the set threading the accumulating parameter
 through the sequence of function applications
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Copy">
<summary>
 Make a shallow copy of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Contains(`0)">
<summary>
 Test if the set contains the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Clear">
<summary>
 Clear all elements from the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Add(`0)">
<summary>
 Add an element to the collection
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Create a new mutable hash set with the given elements and using the given key hash/equality functions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Create a new empty mutable hash set with an internal bucket array of the given approximate size
 and with the given key hash/equality functions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Create a new empty mutable hash set using the given key hash/equality functions 
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.HashSet`1">
<summary>
 Mutable hash sets based by default on F# structural &quot;hash&quot; and (=) functions. Implemented via a hash table and/or Dictionary.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.LazyList`1">
<summary>
 LazyLists are possibly-infinite, cached sequences.  See also IEnumerable/Seq for
 uncached sequences. LazyLists normally involve delayed computations without 
 side-effects.  The results of these computations are cached and evaluations will be 
 performed only once for each element of the lazy list.  In contrast, for sequences 
 (IEnumerable) recomputation happens each time an enumerator is created and the sequence 
 traversed.

 LazyLists can represent cached, potentially-infinite computations.  Because they are 
 cached they may cause memory leaks if some active code or data structure maintains a 
 live reference to the head of an infinite or very large lazy list while iterating it, 
 or if a reference is maintained after the list is no longer required.

 Lazy lists may be matched using the LazyList.Cons and LazyList.Nil active patterns. 
 These may force the computation of elements of the list.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.toSeq``1(Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.toList``1(Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Build a non-lazy list from the given collection. This function will eagerly evaluate all of the 
 list (and thus may not terminate). 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Build a collection from the given list. This function will eagerly evaluate all of the 
 list (and thus may not terminate). 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.toArray``1(Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Build an array from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.ofArray``1(``0[])">
<summary>
 Build a collection from the given array. This function will eagerly evaluate all of the 
 list (and thus may not terminate). 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.map2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Collections.LazyList{``0},Microsoft.FSharp.Collections.LazyList{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.LazyList{``1})">
<summary>
 Return a new list consisting of the results of applying the given accumulating function
 to successive elements of the list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.iter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Apply the given function to each element of the collection. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Return a new collection which on consumption will consist of only the elements of the collection
 for which the given predicate returns &quot;true&quot;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.concat``1(Microsoft.FSharp.Collections.LazyList{Microsoft.FSharp.Collections.LazyList{``0}})">
<summary>
 Return the list which contains on demand the list of elements of the list of lazy lists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.zip``2(Microsoft.FSharp.Collections.LazyList{``0},Microsoft.FSharp.Collections.LazyList{``1})">
<summary>
 Return the list which contains on demand the pair of elements of the first and second list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.append``1(Microsoft.FSharp.Collections.LazyList{``0},Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Return the list which contains on demand the elements of the first list followed
 by the elements of the second list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.unfold``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple`2{``1,``0}}},``0)">
<summary>
 Return a list that contains the elements returned by the given computation.
 The given computation is not executed until the first element on the list is
 consumed.  The given argument is passed to the computation.  Subsequent elements
 in the list are generated by again applying the residual &apos;b to the computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.delayed``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.LazyList{``0}})">
<summary>
 Return a list that is in effect the list returned by the given computation.
 The given computation is not executed until the first element on the list is
 consumed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.repeat``1(``0)">
<summary>
 Return the list which on consumption will consist of an infinite sequence of 
 the given item
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.consDelayed``1(``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.LazyList{``0}})">
<summary>
 Return a new list which on consumption contains the given item 
 followed by the list returned by the given computation.  The 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.cons``1(``0,Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Return a new list which contains the given item followed by the
 given list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.length``1(Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Return the length of the list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.empty``1">
<summary>
 Evaluates to the list that contains no items
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.find``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
 Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.tryFind``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Apply the given function to successive elements of the list, returning the first
 result where function returns &lt;c&gt;Some(x)&lt;/c&gt; for some x. If the function never returns
 true, &apos;None&apos; is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.skip``1(System.Int32,Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Return the list which on consumption will skip the first &apos;n&apos; elements of 
 the input list.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.take``1(System.Int32,Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Return the list which on consumption will consist of at most &apos;n&apos; elements of 
 the input list.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.get``1(Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Get the first cell of the list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.tail``1(Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Return the list corresponding to the remaining items in the sequence.  
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.head``1(Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Return the first element of the list.  Forces the evaluation of
 the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyListModule.isEmpty``1(Microsoft.FSharp.Collections.LazyList{``0})">
<summary>
 Test if a list is empty.  Forces the evaluation of
 the first element of the stream if it is not already evaluated.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.LazyListModule">

</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.unzip``2(System.Collections.Generic.List{System.Tuple`2{``0,``1}})">
<summary>
 Split an array of pairs into two arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.zip``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Combine the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised..
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.tryFindIndexi``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.tryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.singleton``1(``0)">
<summary>
 Return an array containing the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.scanBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Like &lt;c&gt;foldBack&lt;/c&gt;, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Like &lt;c&gt;fold&lt;/c&gt;, but return the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.mapi2``3(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.iteri2``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.isEmpty``1(System.Collections.Generic.List{``0})">
<summary>
 Return true if the given array is empty, otherwise false
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.forall2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if all pairs of elements satisfy the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.foldBack2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1},``2)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.fold2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``0}}},``0,System.Collections.Generic.List{``1},System.Collections.Generic.List{``2})">
<summary>
 Apply a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.reduceBack``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f i0 (...(f iN-1 iN))&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.reduce``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f i0 i1)...) iN&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.findIndexi``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.findIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.exists2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if any pair of element satisfies the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.toSeq``1(System.Collections.Generic.List{``0})">
<summary>
 Return a view of the array as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.ofArray``1(``0[])">
<summary>
 Build a ResizeArray from the given elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.toArray``1(System.Collections.Generic.List{``0})">
<summary>
 Return a fixed-length array containing the elements of the input ResizeArray
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.sortBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the key extractor and generic comparison on the keys
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.sort``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the given comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.rev``1(System.Collections.Generic.List{``0})">
<summary>
Return a new array with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.split``2(System.Collections.Generic.List{System.Tuple`2{``0,``1}})">
<summary>
Split a list of pairs into two lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.combine``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Combine the two arrays into an array of pairs. The two arrays must have equal lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.tryPick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to successive elements, returning the first
result where function returns &quot;Some(x)&quot; for some x.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.tryFind``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
Return None if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.find``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.choose``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. Return
the array comprised of the results &quot;x&quot; for each element where
the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.partition``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Split the collection into two collections, containing the 
elements for which the given predicate returns &lt;c&gt;true&lt;/c&gt; and &lt;c&gt;false&lt;/c&gt;
respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns &lt;c&gt;true&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.forall``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if all elements of the array satisfy the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &quot;j0...jN&quot;
 then computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if any element of the array satisfies the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.mapi``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.iteri``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array.  The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.map2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.  The two input
arrays must have the same lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.iter2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Apply the given function to two arrays simultaneously. The
two arrays must have the same lengths, otherwise an Invalid_argument exception is
raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.iter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f s i0)...) iN&lt;/c&gt;
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
Build an array from the given list
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.toList``1(System.Collections.Generic.List{``0})">
<summary>
Build a list from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.blit``1(System.Collections.Generic.List{``0},System.Int32,System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.fill``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,``0)">
<summary>
Fill a range of the collection with the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.copy``1(System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.sub``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Build a new array that contains the given subrange specified by
starting index and length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.concat``1(Microsoft.FSharp.Collections.FSharpList{System.Collections.Generic.List{``0}})">
<summary>
Build a new array that contains the elements of each of the given list of arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.append``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the first array followed by the elements of the second array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">
<summary>
 Create an array by calling the given generator on each index.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.set``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
 Set the value of an element in the collection. You can also use the syntax &lt;c&gt;arr.[idx] &lt;- e&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.get``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
 Fetch an element from the collection.  You can also use the syntax &lt;c&gt;arr.[idx]&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArrayModule.length``1(System.Collections.Generic.List{``0})">
<summary>
 Return the length of the collection.  You can also use property &lt;c&gt;arr.Length&lt;/c&gt;.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArrayModule">
<summary>
 Generic operations on the type System.Collections.Generic.List, which is called ResizeArray in the F# libraries.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Item(`0,`1)">
<summary>
 Lookup or set the given element in the table.  Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the element is not found.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Item(`0)">
<summary>
 Lookup or set the given element in the table.  Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the element is not found.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Count">
<summary>
 The number of bindings in the hash table
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.TryFind(`0)">
<summary>
 Lookup the given element in the table, returning the result as an Option
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Replace(`0,`1)">
<summary>
 Replace the latest binding (if any) for the given element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Remove(`0)">
<summary>
 Remove the latest binding (if any) for the given element from the table
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Iterate(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Fold``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}}},``0)">
<summary>
 Apply the given function to each element in the collection threading the accumulating parameter
 through the sequence of function applications
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.FindAll(`0)">
<summary>
 Find all bindings for the given element in the table, if any
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Create(`2,System.Int32)">
<summary>
 Create a new empty mutable hash table with an internal bucket array of the given approximate size
 and with the given key hash/equality functions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Copy">
<summary>
 Make a shallow copy of the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.ContainsKey(`0)">
<summary>
 Test if the collection contains any bindings for the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Contains(`0)">
<summary>
 Test if the collection contains any bindings for the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Clear">
<summary>
 Clear all elements from the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Add(`0,`1)">
<summary>
 Add a binding for the element to the table
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3">
<summary>
 HashMultiMap, but where a constraint tag tracks information about the hash/equality functions used
 for the hashing. When the tag is Tags.StructuralHash this is identical to HashMultiMap.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.HashSet`2.Count">
<summary>
 The number of elements in the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Remove(`0)">
<summary>
 Remove the given element from the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Iterate(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.Unit})">
<summary>
 Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0)">
<summary>
 Apply the given function to the set threading the accumulating parameter
 through the sequence of function applications
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Create(`1,System.Int32)">
<summary>
 Create a new empty mutable hash set with an internal bucket array of the given approximate size
 and with the given key hash/equality functions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Copy">
<summary>
 Make a shallow copy of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Contains(`0)">
<summary>
 Test if the set contains the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Clear">
<summary>
 Clear all elements from the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Add(`0)">
<summary>
 Add an element to the collection
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.HashSet`2">
<summary>
 Mutable hash sets where a constraint tag tracks information about the hash/equality functions used
 for the hashing. When the tag is Tags.StructuralHash this is identical to HashSet.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Map`3.Item(`0)">
<summary>
 Lookup an element in the map. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no binding
 exists in the map.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Map`3.IsEmpty">
<summary>
 Return true if there are no bindings in the map.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Map`3.Count">
<summary>
 The number of bindings in the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.TryFind(`0)">
<summary>
 Lookup an element in the map, returning a &lt;c&gt;Some&lt;/c&gt; value if the element is in the domain 
 of the map and &lt;c&gt;None&lt;/c&gt; if not.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.ToList">
<summary>
 The elements of the set as a list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.ToArray">
<summary>
 The elements of the set as an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Remove(`0)">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Partition(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,System.Boolean}})">
<summary>
 Build two new maps, one containing the bindings for which the given predicate returns &apos;true&apos;,
 and the other the remaining bindings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.MapRange``1(Microsoft.FSharp.Core.FSharpFunc`2{`1,``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Map``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,``0}})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Iterate(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Apply the given function to each binding in the dictionary
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.ForAll(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,System.Boolean}})">
<summary>
 Return true if the given predicate returns true for all of the
 bindings in the map. Always returns true if the map is empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.FoldSection``1(`0,`0,Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}}},``0)">
<summary>
 Given the start and end points of a key range,
 Fold over the bindings in the map that are in the range,
 and the end points are included if present (the range is considered a closed interval).
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.FoldAndMap``2(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Tuple`2{``1,``0}}}},``0)">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Fold``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}}},``0)">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.First``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpOption{``0}}})">
<summary>
 Search the map looking for the first element where the given function returns a &lt;c&gt;Some&lt;/c&gt; value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Filter(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,System.Boolean}})">
<summary>
 Build a new map containing the bindings for which the given predicate returns &apos;true&apos;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Exists(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,System.Boolean}})">
<summary>
 Return true if the given predicate returns true for one of the
 bindings in the map. Always returns false if the map is empty.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Empty(`2)">
<summary>
 The empty map, and use the given comparer comparison function for all operations associated
 with any maps built from this map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Create(`2,System.Collections.Generic.IEnumerable{System.Tuple`2{`0,`1}})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
 and where comparison of elements is based on the given comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.ContainsKey(`0)">
<summary>
 Test is an element is in the domain of the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Add(`0,`1)">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.Map`3">
<summary>
 Immutable maps.  Keys are ordered by construction function specified
 when creating empty maps or by F# structural comparison if no
 construction function is specified.

 &lt;performance&gt; 
   Maps based on structural comparison are  
   efficient for small keys. They are not a suitable choice if keys are recursive data structures 
   or require non-structural comparison semantics.
 &lt;/performance&gt;
 Immutable maps.  A constraint tag carries information about the class of key-comparers being used.  
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.op_Subtraction(Microsoft.FSharp.Collections.Tagged.Set{`0,`1},Microsoft.FSharp.Collections.Tagged.Set{`0,`1})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.op_Addition(Microsoft.FSharp.Collections.Tagged.Set{`0,`1},Microsoft.FSharp.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Set`2.MinimumElement">
<summary>
 Returns the lowest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Set`2.MaximumElement">
<summary>
 Returns the highest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Set`2.IsEmpty">
<summary>
 A useful shortcut for Set.isEmpty.  See the Set module for further operations on sets.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Set`2.Count">
<summary>
 Return the number of elements in the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Set`2.Choose">
<summary>
 The number of elements in the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Union(Microsoft.FSharp.Collections.Tagged.Set{`0,`1},Microsoft.FSharp.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.ToList">
<summary>
 The elements of the set as a list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.ToArray">
<summary>
 The elements of the set as an array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Singleton(`1,`0)">
<summary>
 A singleton set based on the given comparison operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Remove(`0)">
<summary>
 A useful shortcut for Set.remove.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Partition(Microsoft.FSharp.Core.FSharpFunc`2{`0,System.Boolean})">
<summary>
 Build two new sets, one containing the elements for which the given predicate returns &apos;true&apos;,
 and the other the remaining elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Iterate(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.Unit})">
<summary>
 Apply the given function to each binding in the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.IsSupersetOf(Microsoft.FSharp.Collections.Tagged.Set{`0,`1})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.IsSubsetOf(Microsoft.FSharp.Collections.Tagged.Set{`0,`1})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Intersection(Microsoft.FSharp.Collections.Tagged.Set{`0,`1},Microsoft.FSharp.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the intersection of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.ForAll(Microsoft.FSharp.Core.FSharpFunc`2{`0,System.Boolean})">
<summary>
 Test if all elements of the collection satisfy the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &lt;c&gt;j0...jN&lt;/c&gt; then 
 computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0)">
<summary>
 Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Filter(Microsoft.FSharp.Core.FSharpFunc`2{`0,System.Boolean})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns &quot;true&quot;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Exists(Microsoft.FSharp.Core.FSharpFunc`2{`0,System.Boolean})">
<summary>
 Test if any element of the collection satisfies the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then computes 
 &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Equality(Microsoft.FSharp.Collections.Tagged.Set{`0,`1},Microsoft.FSharp.Collections.Tagged.Set{`0,`1})">
<summary>
 Compares two sets and returns true if they are equal or false otherwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Empty(`1)">
<summary>
 The empty set based on the given comparer
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Difference(Microsoft.FSharp.Collections.Tagged.Set{`0,`1},Microsoft.FSharp.Collections.Tagged.Set{`0,`1})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Create(`1,System.Collections.Generic.IEnumerable{`0})">
<summary>
 A set based on the given comparer containing the given initial elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Contains(`0)">
<summary>
 A useful shortcut for Set.contains.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Compare(Microsoft.FSharp.Collections.Tagged.Set{`0,`1},Microsoft.FSharp.Collections.Tagged.Set{`0,`1})">
<summary>
 Compares a and b and returns 1 if a &gt; b, -1 if b &lt; a and 0 if a = b        
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Add(`0)">
<summary>
 A useful shortcut for Set.add.  Note this operation prodcues a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.Set`2">
<summary>
 Immutable sets based on binary trees, default tag
 Immutable sets where a constraint tag carries information about the class of key-comparer being used.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.Arg.spec">
<summary>
 The spec value describes the action of the argument,
 and whether it expects a following parameter.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Arg.usage(Microsoft.FSharp.Collections.FSharpList{System.Tuple`3{System.String,Microsoft.FSharp.Compatibility.Arg.spec,System.String}},System.String)">
<summary>
 &quot;usage specs use&quot; prints the help for each argument.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.Arg.parse(Microsoft.FSharp.Collections.FSharpList{System.Tuple`3{System.String,Microsoft.FSharp.Compatibility.Arg.spec,System.String}},Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.Unit},System.String)">
<summary>
 &quot;parse specs f use&quot; parses the arguments given by Sys.argv
 according to the argument processing specifications &quot;specs&quot;.
 Arguments begin with &quot;-&quot;. Non-arguments are passed to &quot;f&quot; in
 order.  &quot;use&quot; is printed as part of the usage line if an error occurs.

 Permitted arguments are specified using triples: (arg, action, help).
 Actions are:
   Unit(f): call f, no subseq. arg
   Set(br): set ref to &apos;true&apos;, no subseq. arg.
   Clear(br): set ref to &apos;false, no subseq. arg.
   String(f): pass the subseq. arg to f
   Int(f): pass the subseq. arg to f
   Float(f): pass the subseq. arg to f
   Rest(f): pass all subseq. args to f in order
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.Arg">
<summary>
 A simple command-line argument processor.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.Array.fold_right``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},``0[],``1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.Array.create_matrix``1(System.Int32,System.Int32,``0)">
<summary>
 Create a jagged 2 dimensional array.  Synonym for createJaggedMatrix.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Array.pinUnscoped``1(``0[])">
<summary>
 As for Array.pin, except that the caller is responsible for calling Free on the returned GCHandle in order
 to release the pin.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Array.pin``2(``0[],Microsoft.FSharp.Core.FSharpFunc`2{``0*,``1})">
<summary>
 Pin the given array for the duration of a single call to the given function.  A native pointer to
 the first element in the array is passed to the given function.  Cleanup the GCHandle associated with the 
 pin when the function completes, even if an exception is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Array.scanReduceBack``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0[])">
<summary>
 Like reduceBack, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Array.scanReduce``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0[])">
<summary>
 Like reduce, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Array.contains``1(``0,``0[])">
<summary>
 Is an element in the array, uses (=) equality.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Array.createJaggedMatrix``1(System.Int32,System.Int32,``0)">
<summary>
 Create a jagged 2 dimensional array.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.Array">
<summary>
 Compatibility operations on arrays.  
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.Array2D.pinUnscoped``1(``0[0:,0:])">
<summary>
 As for Array2D.pin, except that the caller is responsible for calling Free on the returned GCHandle in order
 to release the pin.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Array2D.pin``2(``0[0:,0:],Microsoft.FSharp.Core.FSharpFunc`2{``0*,``1})">
<summary>
 Pin the given array for the duration of a single call to the given function.  A native pointer to
 the first element in the array is passed to the given function.  Cleanup the GCHandle associated with the 
 pin when the function completes, even if an exception is raised.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.Array2D">

</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.to_string(System.Byte)">
<summary>
 Converts a byte to a string
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.of_string(System.String)">
<summary>
 Converts a string to a byte
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.to_uint32(System.Byte)">
<summary>
 Converts a byte to an unsigned 32-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.of_uint32(System.UInt32)">
<summary>
 Converts an unsigned 32-bit integer to a byte
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.to_uint16(System.Byte)">
<summary>
 Converts a byte to a 16-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.of_uint16(System.UInt16)">
<summary>
 Converts a 16-bit integer to a byte
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.to_int32(System.Byte)">
<summary>
 Converts a byte to a 32-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.of_int32(System.Int32)">
<summary>
 Converts a 32-bit integer to a byte
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.to_int(System.Byte)">
<summary>
 Converts a byte to a 32-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.of_int(System.Int32)">
<summary>
 Converts a 32-bit integer to a byte
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.to_char(System.Byte)">
<summary>
 Converts a byte to a char 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.of_char(System.Char)">
<summary>
 Converts a char to a byte
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.shift_right(System.Byte,System.Int32)">
<summary>
 Shifts the binary representation a by n bits to the right
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.shift_left(System.Byte,System.Int32)">
<summary>
 Shifts the binary representation a by n bits to the left
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.logxor(System.Byte,System.Byte)">
<summary>
 Combines the binary representation of a and b by bitwise xor
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.logor(System.Byte,System.Byte)">
<summary>
 Combines the binary representation of a and b by bitwise or
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.lognot(System.Byte)">
<summary>
 Returns the bitwise logical negation of a
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.logand(System.Byte,System.Byte)">
<summary>
 Combines the binary representation of a and b by bitwise and
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.compare(System.Byte,System.Byte)">
<summary>
 Compares a and b and returns 1 if a &gt; b, -1 if b &lt; a and 0 if a = b
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.rem(System.Byte,System.Byte)">
<summary>
 Returns the remainder of a divided by b
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.sub(System.Byte,System.Byte)">
<summary>
 Returns a minus b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.mul(System.Byte,System.Byte)">
<summary>
 Returns a multiplied by b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.div(System.Byte,System.Byte)">
<summary>
 Returns a divided by b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.add(System.Byte,System.Byte)">
<summary>
 Returns the sum of a and b
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.pred(System.Byte)">
<summary>
 Returns the predeccessor of the argument wrapped around 0uy
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.ByteModule.succ(System.Byte)">
<summary>
 Returns the successor of the argument wrapped around 255uy
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.ByteModule.one">
<summary>
 The value one as a System.Byte
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.ByteModule.zero">
<summary>
 The value zero as a System.Byte
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.ByteModule">
<summary>
 Byte (8-bit) operations.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.Bytearray.to_list(System.Byte[])">
<summary>
Build a list from the given collection
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.Bytearray.of_list(Microsoft.FSharp.Collections.FSharpList{System.Byte})">
<summary>
Build a collection from the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Bytearray.mapi(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Byte,System.Byte}},System.Byte[])">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Bytearray.map(Microsoft.FSharp.Core.FSharpFunc`2{System.Byte,System.Byte},System.Byte[])">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.Bytearray.iteri(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Byte,Microsoft.FSharp.Core.Unit}},System.Byte[])">
<summary>
 Apply the given function to each element of the collection. The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Bytearray.iter(Microsoft.FSharp.Core.FSharpFunc`2{System.Byte,Microsoft.FSharp.Core.Unit},System.Byte[])">
<summary>
 Apply the given function to each element of the collection. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.Bytearray.fold_right``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Byte,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},System.Byte[],``0)">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Bytearray.fold_left``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{System.Byte,``0}},``0,System.Byte[])">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f s i0)...) iN&lt;/c&gt;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.Bytearray">
<summary>
 Byte arrays. Arrays of bytes type-compatible with the C# byte[] type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CharModule.uppercase(System.Char)">
<summary>
 Converts the value of a Unicode character to its uppercase equivalent
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CharModule.lowercase(System.Char)">
<summary>
 Converts the value of a Unicode character to its lowercase equivalent
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CharModule.compare(System.Char,System.Char)">
<summary>
 Compares a and b and returns 1 if a &gt; b, -1 if b &lt; a and 0 if a = b
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CharModule.code(System.Char)">
<summary>
 Converts the value of the specified Unicode character to the equivalent 32-bit signed integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CharModule.chr(System.Int32)">
<summary>
 Converts the value of the specified 32-bit signed integer to its equivalent Unicode character
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.CharModule">
<summary>
 Unicode characters, i.e. the &lt;c&gt;System.Char&lt;/c&gt; type.  see also the operations
 in &lt;c&gt;System.Char&lt;/c&gt; and the &lt;c&gt;System.Text.Encoding&lt;/c&gt; interfaces if necessary.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.EnumModule.test``1(``0,``0)">
<summary>
 Test if an enumeration value has a particular flag set, using &apos;logical and&apos;. 
 The relevant enumeration type is inferred from context.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.EnumModule.combine``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Combine enum values using &apos;logical or&apos;. The relevant enumeration type is inferred from context.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.EnumModule.of_int``1(System.Int32)">
<summary>
 Convert an integer to an enumeration value.  The result type is inferred from context.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.EnumModule.to_int``1(``0)">
<summary>
 Convert an enumeration value to an integer.  The argument type is inferred from context.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.EnumModule">
<summary>
 Simple operations to convert between .NET enuemration types and integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.to_bits(System.Single)">
<summary>
 Converts a 32-bit float to raw 32-bit representation 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.of_bits(System.Int32)">
<summary>
 Converts a raw 32-bit representation to a 32-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.to_string(System.Single)">
<summary>
 Converts a 32-bit float to a string
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.of_string(System.String)">
<summary>
 Converts a string to a 32-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.to_float(System.Single)">
<summary>
 Converts a 32-bit float to a 64-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.of_float(System.Double)">
<summary>
 Converts a 64-bit float to a 32-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.to_int64(System.Single)">
<summary>
 Converts a 32-bit float to a 64-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.of_int64(System.Int64)">
<summary>
 Converts a 64-bit integer to a 32-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.to_int32(System.Single)">
<summary>
 Converts a 32-bit float to a 32-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.of_int32(System.Int32)">
<summary>
 Converts a 32-bit integer to a 32-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.to_int(System.Single)">
<summary>
 Converts a 32-bit float to a 32-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.of_int(System.Int32)">
<summary>
 Converts a 32-bit integer to a 32-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.compare(System.Single,System.Single)">
<summary>
 Compares a and b and returns 1 if a &gt; b, -1 if b &lt; a and 0 if a = b
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.sub(System.Single,System.Single)">
<summary>
 Returns a minus b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.neg(System.Single)">
<summary>
 Returns -a
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.mul(System.Single,System.Single)">
<summary>
 Returns a multiplied by b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.div(System.Single,System.Single)">
<summary>
 Returns a divided by b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Float32Module.add(System.Single,System.Single)">
<summary>
 Returns the sum of a and b
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.Float32Module">
<summary>
 ML-like operations on 32-bit System.Single floating point numbers.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.to_bits(System.Double)">
<summary>
 Converts a 64-bit float to raw 64-bit representation 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.of_bits(System.Int64)">
<summary>
 Converts a raw 64-bit representation to a 64-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.to_string(System.Double)">
<summary>
 Converts a 64-bit float to a string
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.of_string(System.String)">
<summary>
 Converts a string to a 64-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.to_float32(System.Double)">
<summary>
 Converts a 64-bit float to a 32-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.of_float32(System.Single)">
<summary>
 Converts a 32-bit float to a 64-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.to_int64(System.Double)">
<summary>
 Converts a 64-bit float to a 64-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.of_int64(System.Int64)">
<summary>
 Converts a 64-bit integer to a 64-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.to_int32(System.Double)">
<summary>
 Converts a 64-bit float to a 32-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.of_int32(System.Int32)">
<summary>
 Converts a 32-bit integer to a 64-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.to_int(System.Double)">
<summary>
 Converts a 64-bit float to a 32-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.of_int(System.Int32)">
<summary>
 Converts a 32-bit integer to a 64-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.compare(System.Double,System.Double)">
<summary>
 Compares a and b and returns 1 if a &gt; b, -1 if b &lt; a and 0 if a = b
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.sub(System.Double,System.Double)">
<summary>
 Returns a minus b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.neg(System.Double)">
<summary>
 Returns -a
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.mul(System.Double,System.Double)">
<summary>
 Returns a multiplied by b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.div(System.Double,System.Double)">
<summary>
 Returns a divided by b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.FloatModule.add(System.Double,System.Double)">
<summary>
 Returns the sum of a and b
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.FloatModule">
<summary>
 ML-like operations on 64-bit System.Double floating point numbers.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.Int16Module">

</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.bits_of_float32(System.Single)">
<summary>
 Converts a 32-bit float to a raw 32-bit representation 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.float32_of_bits(System.Int32)">
<summary>
 Converts a raw 32-bit representation to a 32-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.bits_of_float(System.Double)">
<summary>
 Converts a 64-bit float to a raw 32-bit representation 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.float_of_bits(System.Int32)">
<summary>
 Converts a raw 32-bit representation to a 64-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.to_string(System.Int32)">
<summary>
 Converts a 32-bit integer to a string 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.of_string(System.String)">
<summary>
 Converts a string to a 32-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.to_nativeint(System.Int32)">
<summary>
 Converts a 32-bit unsigned integer to a 32-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.of_nativeint(System.IntPtr)">
<summary>
 Converts a 32-bit unsigned integer to a 32-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.to_int64(System.Int32)">
<summary>
 Converts a 32-bit unsigned integer to a 64-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.of_int64(System.Int64)">
<summary>
 Converts a 64-bit unsigned integer to a 32-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.to_uint32(System.Int32)">
<summary>
 Converts a 32-bit integer to a 32-bit unsigned integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.of_uint32(System.UInt32)">
<summary>
 Converts a 32-bit unsigned integer to a 32-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.to_int(System.Int32)">
<summary>
 Converts a 32-bit integer to a 32-bit integer (included for ML compatability)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.of_int(System.Int32)">
<summary>
 Converts a 32-bit integer to a 32-bit integer (included for ML compatability)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.to_float32(System.Int32)">
<summary>
 Converts a 32-bit integer to a 32-bit float 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.of_float32(System.Single)">
<summary>
 Converts a 32-bit float to a 32-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.to_float(System.Int32)">
<summary>
 Converts a 32-bit integer to a 64-bit float 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.of_float(System.Double)">
<summary>
 Converts a 64-bit float to a 32-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.shift_right_logical(System.Int32,System.Int32)">
<summary>
 Shifts the binary representation a by n bits to the right; high-order bits are zero-filled
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.shift_right(System.Int32,System.Int32)">
<summary>
 Shifts the binary representation a by n bits to the right; high-order empty bits are set to the sign bit
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.shift_left(System.Int32,System.Int32)">
<summary>
 Shifts the binary representation a by n bits to the left
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.logxor(System.Int32,System.Int32)">
<summary>
 Combines the binary representation of a and b by bitwise xor
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.logor(System.Int32,System.Int32)">
<summary>
 Combines the binary representation of a and b by bitwise or
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.lognot(System.Int32)">
<summary>
 Returns the bitwise logical negation of a
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.logand(System.Int32,System.Int32)">
<summary>
 Combines the binary representation of a and b by bitwise and
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.compare(System.Int32,System.Int32)">
<summary>
 Compares a and b and returns 1 if a &gt; b, -1 if b &lt; a and 0 if a = b
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.sub(System.Int32,System.Int32)">
<summary>
 Returns a minus b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.rem(System.Int32,System.Int32)">
<summary>
 Returns the remainder of a divided by b
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.neg(System.Int32)">
<summary>
 Returns -a
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.mul(System.Int32,System.Int32)">
<summary>
 Returns a multiplied by b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.div(System.Int32,System.Int32)">
<summary>
 Returns a divided by b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.add(System.Int32,System.Int32)">
<summary>
 Returns the sum of a and b
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.abs(System.Int32)">
<summary>
 Returns the absolute value of the argument
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.succ(System.Int32)">
<summary>
 Returns the successor of the argument 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.Int32Module.min_int">
<summary>
 Returns the smallest 32-bit signed integer
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.Int32Module.max_int">
<summary>
 Returns the largest 32-bit signed integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int32Module.pred(System.Int32)">
<summary>
 Returns the predeccessor of the argument 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.Int32Module.minus_one">
<summary>
 The value minus one as a System.Int32
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.Int32Module.one">
<summary>
 The value one as a System.Int32
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.Int32Module.zero">
<summary>
 The value zero as a System.Int32
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.Int32Module">
<summary>
 Basic operations on 32-bit integers. The type int32 is identical to &lt;c&gt;System.Int32&lt;/c&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.bits_of_float(System.Double)">
<summary>
 Converts a 64-bit float to a raw 64-bit representation 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.float_of_bits(System.Int64)">
<summary>
 Converts a raw 64-bit representation to a 64-bit float
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.to_string(System.Int64)">
<summary>
 Converts a 64-bit integer to a string
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.of_string(System.String)">
<summary>
 Converts a string to a 64-bit integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.to_nativeint(System.Int64)">
<summary>
 Converts a 64-bit integer to a native integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.of_nativeint(System.IntPtr)">
<summary>
 Converts a native integer to a 64-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.to_uint64(System.Int64)">
<summary>
 Converts a 64-bit integer to an unsigned 64-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.of_uint64(System.UInt64)">
<summary>
 Converts an unsigned 64-bit integer to a 64-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.to_int32(System.Int64)">
<summary>
 Converts a 64-bit integer to a 32-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.of_int32(System.Int32)">
<summary>
 Converts a 32-bit integer to a 64-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.to_int(System.Int64)">
<summary>
 Converts a 64-bit integer to a 32-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.of_int(System.Int32)">
<summary>
 Converts a 32-bit integer to a 64-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.to_float(System.Int64)">
<summary>
 Converts a 64-bit integer to a 64-bit float 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.of_float(System.Double)">
<summary>
 Converts a 64-bit float to a 64-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.to_float32(System.Int64)">
<summary>
 Converts a 64-bit integer to a 32-bit float 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.of_float32(System.Single)">
<summary>
 Converts a 32-bit float to a 64-bit integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.shift_right_logical(System.Int64,System.Int32)">
<summary>
 Shifts the binary representation a by n bits to the right; high-order bits are zero-filled
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.shift_right(System.Int64,System.Int32)">
<summary>
 Shifts the binary representation a by n bits to the right; high-order empty bits are set to the sign bit
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.shift_left(System.Int64,System.Int32)">
<summary>
 Shifts the binary representation a by n bits to the left
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.logxor(System.Int64,System.Int64)">
<summary>
 Combines the binary representation of a and b by bitwise xor
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.logor(System.Int64,System.Int64)">
<summary>
 Combines the binary representation of a and b by bitwise or
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.lognot(System.Int64)">
<summary>
 Returns the bitwise logical negation of a
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.logand(System.Int64,System.Int64)">
<summary>
 Combines the binary representation of a and b by bitwise and
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.compare(System.Int64,System.Int64)">
<summary>
 Compares a and b and returns 1 if a &gt; b, -1 if b &lt; a and 0 if a = b
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.sub(System.Int64,System.Int64)">
<summary>
 Returns a minus b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.rem(System.Int64,System.Int64)">
<summary>
 Returns the remainder of a divided by b
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.neg(System.Int64)">
<summary>
 Returns -a
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.mul(System.Int64,System.Int64)">
<summary>
 Returns a multiplied by b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.div(System.Int64,System.Int64)">
<summary>
 Returns a divided by b 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.add(System.Int64,System.Int64)">
<summary>
 Returns the sum of a and b
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.abs(System.Int64)">
<summary>
 Returns the absolute value of the argument
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.Int64Module.minus_one">
<summary>
 The value minus one as a System.Int64
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.Int64Module.min_int">
<summary>
 Returns the smallest 64-bit signed integer
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.Int64Module.max_int">
<summary>
 Returns the largest 64-bit signed integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.succ(System.Int64)">
<summary>
 Returns the successor of the argument 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Int64Module.pred(System.Int64)">
<summary>
 Returns the predeccessor of the argument 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.Int64Module.one">
<summary>
 The value one as a System.Int64
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.Int64Module.zero">
<summary>
 The value zero as a System.Int64
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.Int64Module">
<summary>
 Basic operations on 64-bit integers. The type int64 is identical to &lt;c&gt;System.Int64&lt;/c&gt;. 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.Lazy.create``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Build a lazy (delayed) value from the given computation
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Lazy.force_without_lock``1(System.Lazy{``0})">
<summary>
 See Lazy.UnsynchronizedForce
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Lazy.force_with_lock``1(System.Lazy{``0})">
<summary>
 See Lazy.SynchronizedForce.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Lazy.lazy_is_val``1(System.Lazy{``0})">
<summary>
 Check if a lazy (delayed) value has already been computed
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Lazy.lazy_from_val``1(``0)">
<summary>
 Build a lazy (delayed) value from the given pre-computed value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Lazy.lazy_from_fun``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Build a lazy (delayed) value from the given computation
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Lazy.force_val``1(System.Lazy{``0})">
<summary>
 See Lazy.Force.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Lazy.force``1(System.Lazy{``0})">
<summary>
 See Lazy.Force
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.Lazy">

</member>
<member name="M:Microsoft.FSharp.Compatibility.List.tl``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the tail of the list.  

 Raises &lt;c&gt;System.ArgumentException&lt;/c&gt; if &lt;c&gt;list&lt;/c&gt; is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.hd``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the first element of the list.

 Raises &lt;c&gt;System.ArgumentException&lt;/c&gt; if &lt;c&gt;list&lt;/c&gt; is empty
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.List.rev_append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 &quot;rev_append l1 l2&quot; evaluates to &quot;append (rev l1) l2&quot;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.rev_map2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 &quot;rev_map2 f l1 l2&quot; evaluates to &quot;map2 f (rev l1) (rev l2)&quot;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.rev_map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 &quot;rev_map f l1&quot; evaluates to &quot;map f (rev l1)&quot;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.nonempty``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return true if the list is not empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.memq``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 See &lt;c&gt;mem&lt;/c&gt;, but uses the physical equality operator (==) for equality tests.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.remove_assq``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
<summary>
 See &lt;c&gt;remove_assoc&lt;/c&gt;, but uses the physical equality operator (==) for equality tests.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.mem_assq``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
<summary>
 See &lt;c&gt;mem_assoc&lt;/c&gt;, but uses the physical equality operator (==) for equality tests.      
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.try_assq``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
<summary>
 See &lt;c&gt;try_assoc&lt;/c&gt;, but uses the physical equality operator (==) for equality tests.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.assq``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
<summary>
 See &lt;c&gt;assoc&lt;/c&gt;, but uses the physical equality operator (==) for equality tests
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.remove_assoc``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
<summary>
 Remove pair for key from the association list (if it&apos;s there).
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.mem_assoc``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
<summary>
 Does the key have pair in the association list?
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.try_assoc``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
<summary>
 Lookup key&apos;s data in association list, uses (=) equality,
 returning &quot;Some data&quot; or &quot;None&quot;.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.assoc``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
<summary>
 Lookup key&apos;s data in association list, uses (=) equality.
 Raise &lt;c&gt;System.IndexOutOfRangeException&lt;/c&gt; exception if key not found, in which case you should typically use &lt;c&gt;try_assoc&lt;/c&gt; instead.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.mem``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Is an element in the list. Elements are compared using generic equality.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.contains``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Is an element in the list. Elements are compared using generic equality.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.scanReduceBack``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Like reduceBack, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.List.scanReduce``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Like reduce, but return both the intermediary and final results
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.List">
<summary>
 Compatibility operations on lists.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.Map.Provider`3">
<summary>
 A provider for creating and using maps based on a particular comparison function.
 The &apos;Tag type parameter is used to track information about the comparison function.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Map.MakeTagged``3(``0)">
<summary>
 A functor to build a collection of operations for creating and using 
 maps based on the given comparison function. This returns a record that 
 contains the functions you use to create and manipulate maps of
 this kind.  The returned value is much like an ML module. 

 Language restrictions related to polymorphism may mean you
 have to create a new instantiation of for each toplevel
 key/value type pair.

 To use this function you need to define a new named class that implements IComparer and
 pass an instance of that class as the first argument. For example:
      type MyComparer = 
          new() = { }
          interface IComparer&lt;string&gt; with 
            member self.Compare(x,y) = ...

 let MyStringMapProvider : Map.Provider &lt; string,int &gt; = Map.MakeTagged(new MyComparer())
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.Map">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Big_int">
<summary>
 Big_int compatability module for arbitrary sized integers.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.add_channel(System.Text.StringBuilder,System.IO.TextReader,System.Int32)">
<summary>
 Read the given number of bytes as ASCII and add the resulting string 
 to the buffer.  Warning: this assumes an ASCII encoding for the I/O channel, i.e. it uses 
 Pervasives.really_input and then use ascii_to_string to produce the string 
 to add.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.reset(System.Text.StringBuilder)">
<summary>
 Clears the buffer (same as Buffer.clear).
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.length(System.Text.StringBuilder)">
<summary>
 Number of characters in the buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.create(System.Int32)">
<summary>
 Create a buffer with suggested size.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.contents(System.Text.StringBuilder)">
<summary>
 Gets the string built from the buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.clear(System.Text.StringBuilder)">
<summary>
 Clears the buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.add_substring(System.Text.StringBuilder,System.String,System.Int32,System.Int32)">
<summary>
 Given a string, start position and length add that substring to the buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.add_string(System.Text.StringBuilder,System.String)">
<summary>
 Add string to the buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.add_char(System.Text.StringBuilder,System.Char)">
<summary>
 Add character to the buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.add_buffer(System.Text.StringBuilder,System.Text.StringBuilder)">
<summary>
 Add second buffer to the first.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Buffer">
<summary>
 Imperative buffers for building strings, a shallow interface to &lt;c&gt;System.Text.StringBuilder&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.temp_file(System.String,System.String)">
<summary>
 &quot;temp_file f s&quot; returns a hitherto unused new file name.  &quot;f&quot; and &quot;s&quot;
 are hints as to a suitable file name and suffix for the file.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.quote(System.String)">
<summary>
 &quot;quote s&quot; is designed for use to quote a filename when using it
 for a system command.  It returns (&quot;\&apos;&quot; ^ s ^ &quot;\&apos;&quot;).  
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.is_implicit(System.String)">
<summary>
 Returns true if the path is relative to the current directory but does not begin with 
 an explicit &quot;.&quot; or &quot;..&quot;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.is_relative(System.String)">
<summary>
 Is the path is relative to the current directory or absolute.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.has_extension(System.String)">
<summary>
 Return true if the filename has a &quot;.&quot; extension
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Filename.parent_dir_name">
<summary>
 &quot;parent_dir_name&quot; returns the name for the directory above the current directory on
 this OS.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Filename.current_dir_name">
<summary>
 The name used for the current directory on this OS. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.basename(System.String)">
<summary>
 &quot;dirname&quot; and &quot;basename&quot; decompose a filename into a directory name
 and a filename, i.e. &quot;concat (dirname s) (basename s) = s&quot;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.dirname(System.String)">
<summary>
 &quot;dirname&quot; and &quot;basename&quot; decompose a filename into a directory name
 and a filename, i.e. &quot;concat (dirname s) (basename s) = s&quot;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.concat(System.String,System.String)">
<summary>
 &quot;concat a b&quot; returns System.IO.Path.Combine(a,b), i.e. the
 two names conjoined by the appropriate directory separator character
 for this architecture.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.chop_suffix(System.String,System.String)">
<summary>
 Assuming &quot;check_suffix f s&quot; holds, &quot;chop_suffix f s&quot; returns the
 filename &quot;f&quot; with the suffix &quot;s&quot; removed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.chop_extension(System.String)">
<summary>
 &quot;chop_extension f&quot; removes the extension from the given
 filename. Raises ArgumentException if no extension is present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.check_suffix(System.String,System.String)">
<summary>
 &quot;check_suffix f s&quot; returns true if filename &quot;f&quot; ends in suffix &quot;s&quot;,
 e.g. check_suffix &quot;abc.fs&quot; &quot;.fs&quot; returns true.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Filename">
<summary>
 Common filename operations.  This module is included to make it possible to cross-compile 
 code with other ML compilers.  See also &lt;c&gt;System.IO.Path&lt;/c&gt;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.Provider`3">
<summary>
A collection of operations for creating and using hash tables based on particular type-tracked hash/equality functions.
Generated by the Hashtbl.Make and Hashtbl.MakeTagged functors. This type is for use when you wish to
specify a comparison function once and carry around an object that is a provider of (i.e. a factory for) hashtables 
that utilize that comparison function.

The &apos;Tag&apos; type parameter is used to track information about the comparison function, which helps ensure 
that you don&apos;t mixup maps created with different comparison functions
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.t`2">
<summary>
 OCaml compatible type name, for use when not opening module, e.g. Hashtbl.t
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.Make``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean}})">
<summary>
 Build a collection of operations for creating and using 
 hashtables based on the given hash/equality functions. This returns a record
 that contains the functions you use to create and manipulate tables of
 this kind.  The returned value is much like an ML module. You should call Make once for 
 each new pair of key/value types.  You may need to constrain the result 
 to be an instantiation of Provider.

 let MyStringHashProvider : Provider&lt;string,int&gt; = Hashtbl.Make(myStringHash,myStringEq)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.MakeTagged``3(``0)">
<summary>
 Same as Make, except track the comparison function being used through an additional type parameter.

 To use this function accurately you need to define a new named class that implements IEqualityComparer and
 pass an instance of that class as the first argument. For example:
      type MyHasher = 
        class
          new() = { }
          interface IEqualityComparer&lt;string&gt; with 
            member self.GetHashCode(x) = ...
            member self.Equals(x,y) = ...
          end
        end

 let MyStringHashProvider : Hashtbl.Provider&lt;string,int&gt; = Hashtbl.MakeTagged(new MyStringHasher())
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.hashq``1(``0)">
<summary>
 Hash on the identity of an object. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.hash``1(``0)">
<summary>
 Hash on the structure of a value according to the F# structural hashing
 conventions
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.tryfind``2(Microsoft.FSharp.Collections.HashMultiMap{``0,``1},``0)">
<summary>
 Lookup the key&apos;s data in the table
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.replace``2(Microsoft.FSharp.Collections.HashMultiMap{``0,``1},``0,``1)">
<summary>
 Replace the latest binding for the given key
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.remove``2(Microsoft.FSharp.Collections.HashMultiMap{``0,``1},``0)">
<summary>
 Remove the latest binding for the given key
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.mem``2(Microsoft.FSharp.Collections.HashMultiMap{``0,``1},``0)">
<summary>
 Test for the existence of any bindings for the given key
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.iter``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.HashMultiMap{``0,``1})">
<summary>
Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.fold``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``2}}},Microsoft.FSharp.Collections.HashMultiMap{``0,``1},``2)">
<summary>
 Fold over all bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.find_all``2(Microsoft.FSharp.Collections.HashMultiMap{``0,``1},``0)">
<summary>
 Return all bindings for the given key
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.find``2(Microsoft.FSharp.Collections.HashMultiMap{``0,``1},``0)">
<summary>
 Lookup key&apos;s data in the table.
 Raises exception is key not in table, if this could happen you should be using tryFind.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.copy``2(Microsoft.FSharp.Collections.HashMultiMap{``0,``1})">
<summary>
 Create a copy of the table. Remember they are imperative and get mutated. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.clear``2(Microsoft.FSharp.Collections.HashMultiMap{``0,``1})">
<summary>
 Empty the table.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.of_seq``2(System.Collections.Generic.IEnumerable{System.Tuple`2{``0,``1}})">
<summary>
 Create hash table using the given data
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.of_list``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
<summary>
 Create a hash table using the given data
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.add``2(Microsoft.FSharp.Collections.HashMultiMap{``0,``1},``0,``1)">
<summary>
 Add key and data to the table.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.create``2(System.Int32)">
<summary>
 Create a hash table with the suggested initial size.  

 Inlined to enable generation of efficient hash routines for the key type in the common case.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Hashtbl">
<summary>
 Multi-entry hash tables using the structural &quot;hash&quot; and &quot;equals&quot; functions.  

These tables can be used with keys of any type, but you should check that
structural hashing and equality are correct for your key type.  
Structural hashing is efficient but not a suitable choice in all circumstances, 
e.g. may not hash efficiently on non-reference types and deeply-structured types.
Better efficiency is typically achieved if key types are F#-generated
types.

These hash tables may map items to multiple keys (see find_all).

The implementations are not safe for concurrent reading/writing,
and so users of these tables should take an appropriate lock
before reading/writing if used in a concurrent setting.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexbuf">
<summary>
 ASCII LexBuffers 

 The type &quot;lexbuf&quot; is opaque, but has an internal position information field 
 that can be updated by setting &quot;lexbuf.EndPos&quot;, for example if you wish 
 to update the other fields in that position data before or during 
 lexing.  You will need to do this if you wish to maintain accurate 
 line-count information.  If you do this and wish to maintain strict 
 cross-compiling compatibility with OCamlLex and other tools you may need code 
 to conditionally use lexbuf_set_curr_p when compiling F# code.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_end(Microsoft.FSharp.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return absolute positions into the entire stream of characters
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_start(Microsoft.FSharp.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return absolute positions into the entire stream of characters
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexbuf_curr_p(Microsoft.FSharp.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 same as lexeme_end_p 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_end_p(Microsoft.FSharp.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return the positions stored in the lexbuf for the matched string 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_start_p(Microsoft.FSharp.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return the positions stored in the lexbuf for the matched string 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_char(Microsoft.FSharp.Text.Lexing.LexBuffer{System.Byte},System.Int32)">
<summary>
 Return a character from the matched string, innterpreting the bytes using an ASCII encoding
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_bytes(Microsoft.FSharp.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return the bytes for the matched string 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_utf8(Microsoft.FSharp.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return the matched string interpreting the bytes using the given Unicode text encoding
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme(Microsoft.FSharp.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return the matched string 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_function(Microsoft.FSharp.Core.FSharpFunc`2{System.Byte[],Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32}})">
<summary>
 Fuel a lexer from function that fills an array of bytes up to the given length, returning the
 number of bytes filled.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_bytearray(System.Byte[])">
<summary>
 Fuel a lexer from an array of bytes
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_string(System.String)">
<summary>
 Fuel a lexer from a string, converted to ascii using &lt;c&gt;System.Text.Encoding.ASCII.GetBytes&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_binary_reader(System.IO.BinaryReader)">
<summary>
 Fuel a lexer using the given BinaryReader.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_text_reader(System.Text.Encoding,System.IO.TextReader)">
<summary>
 Fuel a lexer using the given TextReader or StreamReader.
 The characters read are decoded to bytes using the given encoding (e.g. System.Text.Encoding.ASCII)
 and the bytes presented to the lexer.  The encoding used to decode the characters
 is associated with the expectations of the lexer (e.g. a lexer may be constructed to accept only 
 ASCII or pseudo-UTF8 bytes) and will typically be different to 
 the encoding used to decode the file.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_channel(System.IO.TextReader)">
<summary>
 Fuel a lexer using the given in_channel.  The bytes are read using Pervasives.input.
 If the in_channel is a textual channel the bytes are 
 presented to the lexer by decoding the characters using System.Text.Encoding.ASCII.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.flush_input(Microsoft.FSharp.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Remove all input, though don&apos;t discard the  except the current lexeme 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Lexing">
<summary>
 Lexing: ML-like lexing support

 This file maintains rough compatibility for lexbuffers used by some ML
 laxer generators.  The lexbuf carries an associated pair of positions.
 Beware that only the &quot;cnum&quot; (absolute character number) field is automatically 
 updated as each lexeme is matched.  Upon each successful match the prior end
 position is transferred to be the start position and a new start position
 is allocated with an updated pos_cnum field.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Obj.not_eq``1(``0,``0)">
<summary>
 Negation of Obj.eq (i.e. reference/physical inequality)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Obj.eq``1(``0,``0)">
<summary>
 See Microsoft.FSharp.Core.LanguagePrimitives.PhysicalEquality
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Obj.repr``1(``0)">
<summary>
 See Microsoft.FSharp.Core.Operators.box
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Obj.obj``1(System.Object)">
<summary>
 See Microsoft.FSharp.Core.Operators.unbox
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Obj">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Parsing.Parse_error">
<summary>
 You can initialize error recovery by raising the Parse_error exception. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Parsing">
<summary>
 Parsing: parser support for parsers produced by fsyacc.

 Parsers generated by fsyacc provide location information within parser
 actions.  However that information is not available globally, but
 rather is accessed via the functions available on the following local
 variable which is available in all parser actions:

    parseState : &apos;a Microsoft.FSharp.Text.Parsing.IParseState

 However, this is not compatible with the parser specifications used
 with ocamlyacc and similar tools, which make a single parser state available
 globally.  If you wish to use a global parser state (e.g. so your code will
 cross-compile with OCaml) then you can use the functions in this file.
 You will need to either generate the parser with &apos;--ml-compatibility&apos; option 
 or add the code

       Parsing.set_parse_state parseState;

 at the start of each action of your grammar.  The functions below
 simply report the results of corresponding calls to the latest object
 specified by a call to set_parse_state.

 Note that there could be unprotected multi-threaded concurrent access for the
 parser information, so you should not in general use these
 functions if there may be more than one parser active, and
 should instead use the functions directly available from the parseState
 object.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.out_channel">
<summary>
 An pseudo-abstraction over binary and textual output channels.
 OCaml-compatible channels conflate binary and text IO, and for this reasons their
 use from F# is somewhat deprecated The direct use of System.IO StreamWriter, TextWriter and 
 BinaryWriter objects is preferred, e.g. see System.IO.File.CreateText). Well-written OCaml code 
 that simply opens either a channel in text or binary mode and then does text 
 or binary I/O using the OCaml functions will work, though care must 
 be taken with regard to end-of-line characters (see output_char below).

 This library pretends that an out_channel is just a System.IO.TextWriter. Channels
 created using open_out_bin maintain a private System.IO.BinaryWriter, which will be used whenever
 do I/O using this channel. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.in_channel">
<summary>
 A pseudo-abstraction over binary and textual input channels.
 OCaml-compatible channels conflate binary and text IO, and for this reasons their
 use from F# is somewhat deprecated (direct use of System.IO StreamReader, TextReader and 
 BinaryReader objects is preferred, e.g. see System.IO.File.OpenText). 
 Well-written OCaml-compatible code that simply opens either a channel in text or binary 
 mode and then does text or binary I/O using the OCaml-compatible functions below
 will work, though care must be taken with regard to end-of-line characters (see 
 input_char below).

 This library pretends that an in_channel is just a System.IO.TextReader. Channel values
 created using open_in_bin maintain a private System.IO.BinaryReader, which will be used whenever
 you do I/O using this channel. 

 InChannel.of_BinaryReader and InChannel.of_StreamReader allow you to build input 
 channels out of the corresponding .NET abstractions.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_flag">
<summary>
 This type is present primarily for compatibility with other versions of ML. When
 not cross-compiling we recommend using the .NET I/O libraries
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.not_found``1">
<summary>
 Throw an &lt;c&gt;KeyNotFoundException&lt;/c&gt; exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.invalid_arg``1(System.String)">
<summary>
 Throw an ArgumentException
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.read_line">
<summary>
Read a line from the console, without the end-of-line character.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.read_int">
<summary>
Read an integer from the console.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.read_float">
<summary>
Read a floating point number from the console.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.prerr_char(System.Char)">
<summary>
 Print a character to the stderr stream
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.flush(System.IO.TextWriter)">
<summary>
 Flush all pending output on the channel to the physical
 output device.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.set_binary_mode_out(System.IO.TextWriter,System.Boolean)">
<summary>
 Set the binary mode. If the binary mode is changed from &quot;true&quot; to 
 &quot;false&quot; then a StreamWriter is created to write the binary stream. The StreamWriter uses 
 the default text encoding System.Text.Encoding.Default.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.seek_out(System.IO.TextWriter,System.Int32)">
<summary>
 Set the current position in the output channel, measured from the
 start of the channel.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.pos_out(System.IO.TextWriter)">
<summary>
 Return the current position in the output channel, measured from the
 start of the channel. Not valid on all channels.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output_value``1(System.IO.TextWriter,``0)">
<summary>
 Serialize the given value to the output channel.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output_string(System.IO.TextWriter,System.String)">
<summary>
 Write the given Unicode string to the output channel. See output_char for the treatment of
 &apos;\n&apos; characters within the string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output_char(System.IO.TextWriter,System.Char)">
<summary>
 Write the given Unicode character to the output channel. 

 If the output channel is a binary stream and the UTF-16 value of the Unicode character is greater
 than 255 then ArgumentException is thrown.

 No CRLF translation is done on output. That is, if the output character is
 &apos;\n&apos; (LF) characters they will not be written as &apos;\r\n&apos; (CRLF) characters, regardless
 of whether the underlying operating system or output stream uses CRLF as the default
 line-feed character.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output_bytearray(System.IO.TextWriter,System.Byte[])">
<summary>
 Write all the given bytes to the output channel. No CRLF translation is
 performed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output_byte(System.IO.TextWriter,System.Int32)">
<summary>
 Write the given byte to the output channel. No CRLF translation is
 performed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output_binary_int(System.IO.TextWriter,System.Int32)">
<summary>
 Write the given integer to the output channel in binary format.
 Only valid on binary channels.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output(System.IO.TextWriter,System.Byte[],System.Int32,System.Int32)">
<summary>
 Write the given range of bytes to the output channel. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.out_channel_length(System.IO.TextWriter)">
<summary>
 Return the length of the output channel. 
 Raise an exception if not an app
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.close_out(System.IO.TextWriter)">
<summary>
 Close the given output channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_out_gen(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_flag},System.Int32,System.String)">
<summary>
 Open the given file to write in the mode according to the specified flags
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_out_bin(System.String)">
<summary>
 Open the given file to write in binary-mode 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_out_utf8(System.String)">
<summary>
 Open the given file to write in text-mode using the UTF8 encoding
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_out_encoded(System.Text.Encoding,System.String)">
<summary>
 Open the given file to write in text-mode using the given encoding
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_out(System.String)">
<summary>
 Open the given file to write in text-mode using the
 System.Text.Encoding.Default encoding

 See output_char for a description of CR-LF translation
 done on output.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.set_binary_mode_in(System.IO.TextReader,System.Boolean)">
<summary>
 Set the binary mode to true or false. If the binary mode is changed from &quot;true&quot; to 
 &quot;false&quot; then a StreamReader is created to read the binary stream. The StreamReader uses 
 the default text encoding System.Text.Encoding.Default
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.seek_in(System.IO.TextReader,System.Int32)">
<summary>
 Reads bytes from the channel. Blocks if the bytes are not available.
 For text channels this only accepts UTF-16 bytes with an encoding less than 256.
 Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.really_input(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
<summary>
 Reads bytes from the channel. Blocks if the bytes are not available.
 See &apos;input&apos; for treatment of text channels.
 Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.pos_in(System.IO.TextReader)">
<summary>
 Report the current position in the input channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input_value``1(System.IO.TextReader)">
<summary>
 Input a single serialized value from a binary stream. Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input_line(System.IO.TextReader)">
<summary>
 Input a single line. Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input_char(System.IO.TextReader)">
<summary>
 Input a single character. Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input_byte(System.IO.TextReader)">
<summary>
 Input a single byte. 
 For text channels this only accepts characters with a UTF16 encoding that fits in a byte, e.g. ASCII.
 Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input_binary_int(System.IO.TextReader)">
<summary>
 Input a binary integer from a binary channel. Compatible with output_binary_int.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input_chars(System.IO.TextReader,System.Char[],System.Int32,System.Int32)">
<summary>
 Attempt to input characters from a channel. Does not block if inpout is not available.
 Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.

 No CRLF translation is done on input, even in text mode. That is, if an input file
 has &apos;\r\n&apos; (CRLF) line terminators both characters will be seen in the input.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
<summary>
 Attempt to input the given number of bytes from the channel, writing them into the
 buffer at the given start position. Does not block if the bytes are not available.

 The use of this function with a channel performing byte-to-character translation (e.g. one
 created with open_in, open_in_utf8 or open_in_encoded, or one 
 or built from a StreamReader or TextReader) is not recommended.
 Instead, open the channel using open_in_bin or InChannel.of_BinaryReader.

 If used with a StreamReader channel, i.e. one created using 
 open_in, open_in_utf8 or open_in_encoded, or one 
 or built from a StreamReader, this function reads bytes directly from the underlying
 BaseStream. This may not be appropriate if any other input techniques are being
 used on the channel.

 If used with a TextReader channel (e.g. stdin), this function reads characters from the
 stream and then fills some of the byte array with the decoding of these into 
 bytes, where the decoding is performed using the System.Text.Encoding.Default encoding

 Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.in_channel_length(System.IO.TextReader)">
<summary>
 Return the length of the input channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.close_in(System.IO.TextReader)">
<summary>
 Close the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_in_gen(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_flag},System.Int32,System.String)">
<summary>
 Open the given file in the mode specified by the given flags
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_in_bin(System.String)">
<summary>
 Open the given file to read in binary-mode 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_in_utf8(System.String)">
<summary>
 Open the given file to read in text-mode using the UTF8 encoding
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_in(System.String)">
<summary>
 Open the given file to read. 

In the absence of an explicit encoding (e.g. using Open_encoding) open_in
uses the default text encoding (System.Text.Encoding.Default). If you want to read a file
regardless of encoding then you should use binary modes. Note that .NET&apos;s 
&quot;new StreamReader&quot; function defaults to use a utf8 encoding, and also attempts
to determine an automatic encoding by looking for &quot;byteorder-marks&quot; at the head
of a text file. This function does not do this.

 No CR-LF translation is done on input.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.neg_infinity">
<summary>
 This value is present primarily for compatibility with other versions of ML
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.modf(System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.mod_float(System.Double,System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.epsilon_float">
<summary>
 This value is present primarily for compatibility with other versions of ML
 The smallest value that when added to 1.0 gives a different value to 1.0
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.min_float">
<summary>
 This value is present primarily for compatibility with other versions of ML
 The lowest non-denormalized positive IEEE64 float
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.max_float">
<summary>
 This value is present primarily for compatibility with other versions of ML
 The highest representable positive value in the &apos;float&apos; type
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_DivideDot(System.Double,System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML. In F#
 the overloaded operators may be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_TwiddlePlusDot(System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML. In F#
 the overloaded operators may be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_TwiddleMinusDot(System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML. In F#
 the overloaded operators may be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_MinusDot(System.Double,System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML. In F#
 the overloaded operators may be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_PlusDot(System.Double,System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML. In F#
 the overloaded operators may be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_MultiplyDot(System.Double,System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Invalid_argument(System.String)">
<summary>
 The exception thrown by &lt;c&gt;invalid_arg&lt;/c&gt; and misues of F# library functions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.int_neg(System.Int32)">
<summary>
 Negation on integers of the &apos;int&apos; type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.max_int">
<summary>
 The highest representable value in the &apos;int&apos; type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.min_int">
<summary>
 The lowest representable value in the &apos;int&apos; type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.succ(System.Int32)">
<summary>
 n+1 (no overflow checking)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.pred(System.Int32)">
<summary>
 n-1 (no overflow checking)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_ArrayAssign``1(``0[],System.Int32,``0)">
<summary>
 1D Array element set-accessor (&apos;setter&apos;)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_ArrayLookup``1(``0[],System.Int32)">
<summary>
 1D Array element get-accessor (&apos;getter&apos;)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_BangEquals``1(``0,``0)">
<summary>
 Negation of the &apos;==&apos; operator, see also Obj.eq
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_EqualsEquals``1(``0,``0)">
<summary>
Reference/physical equality. 
True if boxed versions of the inputs are reference-equal, OR if
both are value types and the implementation of Object.Equals for the type
of the first argument returns true on the boxed versions of the inputs. 

In normal use on reference types or non-mutable value types this function 
has the following properties:
   - returns &apos;true&apos; for two F# values where mutation of data
     in mutable fields of one affects mutation of data in the other
   - will return &apos;true&apos; if (=) returns true
   - hashq will return equal hashes if (==) returns &apos;true&apos;

The use on mutable value types is not recommended.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Assert_failure">
<summary>
 The exception thrown by &apos;assert&apos; failures.
 A future release of F# may map this exception to a corresponding .NET exception.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Match_failure">
<summary>
  Non-exhaustive match failures will raise Match failures
 A future release of F# may map this exception to a corresponding .NET exception.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.list`1">
<summary>
The type of simple immutable lists 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.option`1">
<summary>
The type of None/Some options
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.ref`1">
<summary>
The type of pointers to mutable reference cells
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Concatenate two lists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Concatenate(System.String,System.String)">
<summary>
 Concatenate two strings. The overlaoded operator &apos;+&apos; may also be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.exit``1(System.Int32)">
<summary>
Exit the current hardware isolated process, if security settings permit,
otherwise raise an exception. Calls System.Environment.Exit.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.incr(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
<summary>
Increment a mutable reference cell containing an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.decr(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
<summary>
Decrement a mutable reference cell containing an integer
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.raise``1(System.Exception)">
<summary>
 Throw an exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.failwith``1(System.String)">
<summary>
 Throw a &apos;Failure&apos; exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.ref``1(``0)">
<summary>
Create a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_ColonEquals``1(Microsoft.FSharp.Core.FSharpRef{``0},``0)">
<summary>
Assign to a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Dereference``1(Microsoft.FSharp.Core.FSharpRef{``0})">
<summary>
Dereference a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.abs(System.Int32)">
<summary>
Absolute value of the given integer
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.hash``1(``0)">
<summary>
The &quot;hash&quot; function is a structural hash function. It is 
designed to return equal hash values for items that are 
equal according to the polymorphic equality 
function Pervasives.(=) (i.e. the standard &quot;=&quot; operator).
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.min``1(``0,``0)">
<summary>
Minimum based on structural comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.max``1(``0,``0)">
<summary>
Maximum based on structural comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.compare``1(``0,``0)">
<summary>
Structural comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_GreaterThanOrEqual``1(``0,``0)">
<summary>
Structural greater-than-or-equal
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_GreaterThan``1(``0,``0)">
<summary>
Structural greater-than
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Equality``1(``0,``0)">
<summary>
Structural equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Inequality``1(``0,``0)">
<summary>
Structural inequality
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_LessThanOrEqual``1(``0,``0)">
<summary>
Structural less-than-or-equal comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_LessThan``1(``0,``0)">
<summary>
Structural less-than comparison
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.to_BinaryWriter(System.IO.TextWriter)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.to_StreamWriter(System.IO.TextWriter)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.to_TextWriter(System.IO.TextWriter)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.to_Stream(System.IO.TextWriter)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.of_Stream(System.Text.Encoding,System.IO.Stream)">
<summary>
 Wrap a stream by creating a StreamWriter for the 
 stream and then wrapping is as an output channel.
 A text encoding must be given, e.g. System.Text.Encoding.UTF8
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.of_TextWriter(System.IO.TextWriter)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.of_StreamWriter(System.IO.StreamWriter)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.of_BinaryWriter(System.IO.BinaryWriter)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.of_Stream(System.Text.Encoding,System.IO.Stream)">
<summary>
 Wrap a stream by creating a StreamReader for the 
 stream and then wrapping is as an input channel.
 A text encoding must be given, e.g. System.Text.Encoding.UTF8
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.of_TextReader(System.IO.TextReader)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.of_StreamReader(System.IO.StreamReader)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.of_BinaryReader(System.IO.BinaryReader)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.to_BinaryReader(System.IO.TextReader)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.to_StreamReader(System.IO.TextReader)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.to_TextReader(System.IO.TextReader)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.to_Stream(System.IO.TextReader)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives">
<summary>
Pervasives: Additional OCaml-compatible bindings 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Printexc">
<summary>
 Compatibility module to display data about exceptions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.time">
<summary>
 Time consumed by the main thread. (for approximate timings).
 Generally returns only the processor time used by the main 
 thread of the application.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Sys.word_size">
<summary>
 The number of bits in the &quot;int&quot; type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Sys.executable_name">
<summary>
 Path of the current executable, using
 &lt;c&gt;System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory,System.AppDomain.CurrentDomain.FriendlyName)&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.command(System.String)">
<summary>
 Run the command and return it&apos;s exit code.

 Warning: &apos;command&apos; currently attempts to execute the string using 
 the &apos;cmd.exe&apos; shell processor.  If it is not present on the system 
 then the operation will fail.  Use System.Diagnostics.Process 
 directly to run commands in a portable way, which involves specifying 
 the program to run and the arguments independently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.getcwd">
<summary>
 Returns the current working directory for the process using &lt;c&gt;System.IO.Directory.GetCurrentDirectory&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.chdir(System.String)">
<summary>
 Sets the current working directory for the process using &lt;c&gt;System.IO.Directory.SetCurrentDirectory&lt;/c&gt; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.rename(System.String,System.String)">
<summary>
 Rename a file on disk using System.IO.File.Move  
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.remove(System.String)">
<summary>
 Deletes a file using &lt;c&gt;System.IO.File.Delete&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.getenv(System.String)">
<summary>
 Call System.Environment.GetEnvironmentVariable. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the variable is not defined.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.file_exists(System.String)">
<summary>
 Returns true if a file currently exists, using System.IO.File.Exists(s).
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Sys.argv">
<summary>
 The array of command line options. Gives the command line arguments
 as returned by &lt;c&gt;System.Environment.GetCommandLineArgs&lt;/c&gt;.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Sys">
<summary>
 Sys: Basic system operations (for ML compatibility)

 This module is only included to make it possible to cross-compile 
 code with other ML compilers.  It may be deprecated and/or removed in 
 a future release. You may wish to use .NET functions directly instead. 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compatibility.Permutation.identity">
<summary>
 The identity permutation over any size
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Permutation.rotation(System.Int32,System.Int32)">
<summary>
 Return a permutation that rotates right by the given distance. If the distance
 is negative then a left rotation results.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Permutation.reversal(System.Int32)">
<summary>
 Return a permutation that, when applied, maps index 0 to size-1, size-1 to 0 etc.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Permutation.swap(System.Int32,System.Int32)">
<summary>
 Return a swaps the given two elements over any size
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.Permutation.ofPairs(System.Collections.Generic.IEnumerable{System.Tuple`2{System.Int32,System.Int32}})">
<summary>
 Create a permutation by specifying (source,destination) index pairs. For example,
 Permutation(3,[ (0,2);(1,0); (2,1) ]) specifies a permutation that rotates 
 all elements left one place. Not all elements need be given, e.g. 
 Permutation(5,[ (1,2);(2,1) |]) specifies a permutation that swaps elements at indexes
 1 and 2.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compatibility.Permutation.ofArray(System.Int32[])">
<summary>
 Create a permutation by specifying the result of permuting [| 0 .. n-1 |]. For example, 
 Permutation.ofArray [| 1;2;0 |]  specifies a permutation that rotates all elements right one place.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.Permutation">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.SByteModule">
<summary>
 Simple operations on signed bytes
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Seq.nonempty``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return true if the IEnumerable is not empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Seq.combine``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 A synonym for Seq.zip
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Seq.cons``1(``0,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return an IEnumerable that when iterated yields
 the given item followed by the items in the given sequence
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.Seq">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.Set.Provider`2">
<summary>
A collection of operations for creating and using sets based on a particular comparison function.
The &apos;Tag&apos; type parameter is used to track information about the comparison function.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Set.MakeTagged``2(``0)">
<summary>
A functor to build a collection of operations for creating and using 
 sets based on the given comparison function. This returns a record that 
 contains the functions you use to create and manipulate maps of
 this kind.  The returned value is much like an ML module. 

 To use this function you need to define a new named class that implements IComparer and
 pass an instance of that class as the first argument. For example:
      type MyComparer() = 
          interface IComparer&lt;string&gt; with 
            member self.Compare(x,y) = ...

 let MyStringSetProvider = Set.MakeTagged(new MyComparer())
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.Set.Make``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}})">
<summary>
 Build a collection of operations for creating and using 
 maps based on a single consistent comparison function. This returns a record
 that contains the functions you use to create and manipulate maps all of which 
 use this comparison function.  The returned value is much like an ML module. 

 Use MakeTagged if you want additional type safety that guarantees that two sets
 based on different comparison functions can never be combined in inconsistent ways.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.Set">
<summary>
 Immutable sets implemented via binary trees
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.uppercase(System.String)">
<summary>
 Return a string with all characters converted to uppercase.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.rindex_from(System.String,System.Int32,System.Char)">
<summary>
 Return the index of the first occurrence of the given character 
 starting from the given index proceeding backwards.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.rindex(System.String,System.Char)">
<summary>
 Return the index of the first occurrence of the given character 
 from the end of the string proceeding backwards
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.rcontains_from(System.String,System.Int32,System.Char)">
<summary>
 Return true if the string contains the given character prior to the given index
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.index_from(System.String,System.Int32,System.Char)">
<summary>
 Return the first index of the given character in the
 range from the given start position to the end of the string.  
 Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if
 the string does not contain the given character.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.index(System.String,System.Char)">
<summary>
 Return the first index of the given character in the
 string.  Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if
 the string does not contain the given character.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.contains_from(System.String,System.Int32,System.Char)">
<summary>
 Return true is the given string contains the given character in the
 range from the given start index to the end of the string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.contains_between(System.String,System.Int32,System.Int32,System.Char)">
<summary>
 Return true is the given string contains the given character in the
 range specified by the given start index and the given length
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.contains(System.String,System.Char)">
<summary>
 Return true is the given string contains the given character
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.of_char(System.Char)">
<summary>
 Return s string of length 1 containing the given character
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.make(System.Int32,System.Char)">
<summary>
 Return a string of the given length containing repetitions of the given character
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.lowercase(System.String)">
<summary>
 Return a new string with all characters converted to lowercase
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.sub(System.String,System.Int32,System.Int32)">
<summary>
 Return a substring of length &apos;length&apos; starting index &apos;start&apos;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.get(System.String,System.Int32)">
<summary>
 Returns the character at the specified position in the string
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.compare(System.String,System.String)">
<summary>
 Compare the given strings using ordinal comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.trim(Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Removes all occurrences of a set of characters specified in a
 list from the beginning and end of this instance.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.split(Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Split the string using the given list of separator characters.
 Trimming is also performed at both ends of the string and any empty
 strings that result from the split are discarded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.uncapitalize(System.String)">
<summary>
 Return a string with the first character converted to lowercase.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.String.capitalize(System.String)">
<summary>
 Return a string with the first character converted to uppercase.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.String">
<summary>
 Compatibility module for string processing.  Richer string operations
 are available via the member functions on strings and other functionality in
 the &lt;c&gt;System.String&lt;/c&gt; type
 and the &lt;c&gt;System.Text.RegularExpressions&lt;/c&gt; namespace.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.UInt16Module">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.UInt32Module">
<summary>
 UInt32: ML-like operations on 32-bit System.UInt32 numbers.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compatibility.UInt64Module">
<summary>
 UInt64: basic operations on 64-bit System.UInt64 numbers.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.AsyncResultCell`1.AsyncResult">
<summary>
 Wait for the result and commit it
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncResultCell`1.RegisterResult(Microsoft.FSharp.Control.AsyncResult{`0})">
<summary>
 Record the result in the AsyncResultCell. Subsequent sets of the result are ignored. 

 This may result in the scheduled resumption of a waiting asynchronous operation  
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncResultCell`1.#ctor">
<summary>
 Create a new result cell
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncResultCell`1">
<summary>
 A helper type to store a single result from an asynchronous computation and asynchronously
 access its result.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncResult`1.Commit(Microsoft.FSharp.Control.AsyncResult{`0})">
<summary>
 Create an async whose result depends on the value of an AsyncResult.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncResult`1">
<summary>
 Represents the reified result of an asynchronous computation
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Control.FileExtensions">

</member>
<member name="T:Microsoft.FSharp.Control.StreamReaderExtensions">

</member>
<member name="T:Microsoft.FSharp.Control.WebClientExtensions">

</member>
<member name="T:Microsoft.FSharp.Control.WebRequestExtensions">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.matrix">
<summary>
 The type of floating-point matrices. See Microsoft.FSharp.Math
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.rowvec">
<summary>
 The type of floating-point row vectors. See Microsoft.FSharp.Math
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.vector">
<summary>
 The type of floating-point vectors. See Microsoft.FSharp.Math
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.MatrixTopLevelOperators.rowvec(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Builds a (row) vector from a sequence of floats.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.MatrixTopLevelOperators.vector(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Builds a (column) vector from a sequence of floats.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.MatrixTopLevelOperators.matrix``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Builds a matrix from a sequence of sequence of floats.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.MatrixTopLevelOperators">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.NumericLiteralN">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_UnaryPlus(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the given rational number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_UnaryNegation(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the negation of a rational number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Subtraction(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the difference of two rational numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Multiply(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the product of two rational numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_LessThanOrEqual(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_LessThan(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Inequality(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_GreaterThanOrEqual(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_GreaterThan(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Explicit(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the result of converting the given rational number to an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Explicit(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the result of converting the given rational number to a big integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Explicit(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the result of converting the given rational number to a floating point number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Equality(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Division(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the ratio of two rational numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Addition(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the sum of two rational numbers
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.Zero">
<summary>
 Get zero as a rational number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.Sign">
<summary>
 Return the sign of a rational number; 0, +1 or -1
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.One">
<summary>
 Get one as a rational number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.Numerator">
<summary>
 Return the numerator of the normalized rational number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.IsPositive">
<summary>
 Return a boolean indicating if this rational number is strictly positive
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.IsNegative">
<summary>
 Return a boolean indicating if this rational number is strictly negative
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.Denominator">
<summary>
 Return the denominator of the normalized rational number
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.ToInt32(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the result of converting the given rational number to an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.ToDouble(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the result of converting the given rational number to a floating point number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.ToBigInt(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the result of converting the given rational number to a big integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.PowN(Microsoft.FSharp.Math.BigNum,System.Int32)">
<summary>
 Return the result of raising the given rational number to the given power
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.Parse(System.String)">
<summary>
 Return the result of converting the string to a rational number 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.FromInt(System.Int32)">
<summary>
 Return the result of converting the given integer to a rational number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.FromBigInt(System.Numerics.BigInteger)">
<summary>
 Return the result of converting the given big integer to a rational number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.Abs(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the absolute value of a rational number 
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.BigNum">
<summary>
 The type of arbitrary-sized rational numbers
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_UnaryNegation(Microsoft.FSharp.Math.Complex)">
<summary>
 Unary negation of a complex number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_Subtraction(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Subtract one complex number from another
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_Multiply(Microsoft.FSharp.Math.Complex,System.Double)">
<summary>
 Multiply a complex number by a scalar
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_Multiply(System.Double,Microsoft.FSharp.Math.Complex)">
<summary>
 Multiply a scalar by a complex number 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_Multiply(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Multiply two complex numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_Division(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Complex division of two complex numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_Addition(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Add two complex numbers
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.r">
<summary>
 The real part of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.i">
<summary>
 The imaginary part of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.Zero">
<summary>
 The complex number 0+0i
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.RealPart">
<summary>
 The real part of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.Phase">
<summary>
 The polar-coordinate phase of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.OneI">
<summary>
 The complex number 0+1i
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.One">
<summary>
 The complex number 1+0i
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.Magnitude">
<summary>
 The polar-coordinate magnitude of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.ImaginaryPart">
<summary>
 The imaginary part of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.Conjugate">
<summary>
 The conjugate of a complex number, i.e. x-yi
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.Complex.CreatePolar(System.Double,System.Double)">
<summary>
 Create a complex number using magnitude/phase polar coordinates
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.Create(System.Double,System.Double)">
<summary>
 Create a complex number x+ij using rectangular coordinates
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.Complex.Abs(Microsoft.FSharp.Math.Complex)">
<summary>
 Computes the absolute value of a complex number: e.g. Abs x+iy = sqrt(x**2.0 + y**2.0.)
 Note: Complex.Abs(z) is the same as z.Magnitude
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Complex">
<summary>
 The type of complex numbers stored as pairs of 64-bit floating point numbers in rectangular coordinates
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.Item(System.Int32,System.Int32,`0)">
<summary>
 Get the item at the given position in a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_UnaryPlus(Microsoft.FSharp.Math.Matrix{`0})">
<summary>
 Prefix &apos;+&apos; operator. A nop.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_UnaryNegation(Microsoft.FSharp.Math.Matrix{`0})">
<summary>
 Matrix negation. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_Subtraction(Microsoft.FSharp.Math.Matrix{`0},Microsoft.FSharp.Math.Matrix{`0})">
<summary>
 Point-wise subtraction of two matrices. An InvalidArgument exception will be
 raised if the dimensions do not match.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_Multiply(`0,Microsoft.FSharp.Math.Matrix{`0})">
<summary>
 Multiply each element of a matrix by a scalar value
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_Multiply(Microsoft.FSharp.Math.Matrix{`0},`0)">
<summary>
 Multiply each element of a matrix by the given scalar value
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_Multiply(Microsoft.FSharp.Math.Matrix{`0},Microsoft.FSharp.Math.Vector{`0})">
<summary>
 Matrix-vector multiplication. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_Multiply(Microsoft.FSharp.Math.Matrix{`0},Microsoft.FSharp.Math.Matrix{`0})">
<summary>
 Matrix multiplication. An InvalidArgument exception will be
 raised if the dimensions do not match.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_DotMultiply(Microsoft.FSharp.Math.Matrix{`0},Microsoft.FSharp.Math.Matrix{`0})">
<summary>
 Point-wise matrix multiplication. An InvalidArgument exception will be
 raised if the dimensions do not match.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_Addition(Microsoft.FSharp.Math.Matrix{`0},Microsoft.FSharp.Math.Matrix{`0})">
<summary>
 Point-wise addition of two matrices. An InvalidArgument exception will be
 raised if the dimensions do not match.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.Transpose">
<summary>
 Get the transpose of a matrix.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.NumRows">
<summary>
 Get the number of rows in a matrix
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.NumCols">
<summary>
 Get the number of columns in a matrix
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.Norm">
<summary>
 Returns sqrt(sum(norm(x)*(norm(x))) of all the elements of a matrix.
 The element type of a matrix must have an associated instance of INormFloat&lt;&apos;T&gt; (see &lt;c&gt;GlobalAssociations&lt;/c&gt;) ((else NotSupportedException)).
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.NonZeroEntries">
<summary>
 Return the non-zero entries of a sparse or dense matrix
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.Item(System.Int32,System.Int32)">
<summary>
 Get the item at the given position in a matrix
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.IsSparse">
<summary>
 Indicates if a matrix uses the sparse representation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.IsDense">
<summary>
 Indicates if a matrix uses the dense representation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.InternalSparseValues">
<summary>
 Get the internal array of values for a sparse matrix. This property 
 should only be used when interoperating with other matrix libraries.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.InternalSparseRowOffsets">
<summary>
 Get the internal array of row offsets for a sparse matrix. This property 
 should only be used when interoperating with other matrix libraries.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.InternalSparseColumnValues">
<summary>
 Get the internal array of column values for a sparse matrix. This property 
 should only be used when interoperating with other matrix libraries.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.InternalDenseValues">
<summary>
 Get the internal array of values for a dense matrix. This property 
 should only be used when interoperating with other matrix libraries.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.ElementOps">
<summary>
 Retrieve the dictionary of numeric operations associated with the element
 type of this matrix. Accessing the property may raise an NotSupportedException if the element
 type doesn&apos;t support any numeric operations. The object returned
 may support additional numeric operations such as IFractional: 
 this can be determined by a dynamic type test against the object
 returned.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.Dimensions">
<summary>
 Get the number of (rows,columns) in a matrix
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.Diagonal">
<summary>
 Get the main diagonal of a matrix, as a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.ToVector">
<summary>
 Convert a matrix to a column vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.ToRowVector">
<summary>
 Convert a matrix to a row vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.ToArray2D">
<summary>
 Return a new array containing the elements of a matrix
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.SetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Math.Matrix{`0})">
<summary>
 Supports the slicing syntax &apos;A.[idx1..idx2,idx1..idx2] &lt;- B&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.Rows(System.Int32,System.Int32)">
<summary>
 Select a range of rows from a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.Row(System.Int32)">
<summary>
 Select a row from a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.Region(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Select a region from a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.PermuteRows(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32})">
<summary>
 Permutes the rows of a matrix.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.PermuteColumns(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32})">
<summary>
 Permutes the columns of a matrix.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.GetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Supports the slicing syntax &apos;A.[idx1..idx2,idx1..idx2]&apos;
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.GetDiagonal(System.Int32)">
<summary>
 Return the nth diagonal of a matrix, as a vector. Diagonal 0 is the primary
 diagonal, positive diagonals are further to the upper-right of a matrix.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.Copy">
<summary>
 Create a new matrix that is a copy of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.Columns(System.Int32,System.Int32)">
<summary>
 Select a range of columns from a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.Column(System.Int32)">
<summary>
 Select a column from a matrix
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Matrix`1">
<summary>
 The type of matrices. The arithmetic operations on the element type are determined by inspection on the element type itself.
 Two representations are supported: sparse and dense. 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_UnaryPlus(Microsoft.FSharp.Math.RowVector{`0})">
<summary>
 Return a row vector, unchanged
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_UnaryNegation(Microsoft.FSharp.Math.RowVector{`0})">
<summary>
 Point-wise negation of a row vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_Subtraction(Microsoft.FSharp.Math.RowVector{`0},Microsoft.FSharp.Math.RowVector{`0})">
<summary>
 Point-wise subtraction of two row vectors
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_Multiply(`0,Microsoft.FSharp.Math.RowVector{`0})">
<summary>
 Multiply a scalar by a row vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_Multiply(Microsoft.FSharp.Math.RowVector{`0},`0)">
<summary>
 Multiply a row vector by a scalar
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_Multiply(Microsoft.FSharp.Math.RowVector{`0},Microsoft.FSharp.Math.Matrix{`0})">
<summary>
 Multiply a row vector by a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_Multiply(Microsoft.FSharp.Math.RowVector{`0},Microsoft.FSharp.Math.Vector{`0})">
<summary>
 Multiply a row vector by a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_DotMultiply(Microsoft.FSharp.Math.RowVector{`0},Microsoft.FSharp.Math.RowVector{`0})">
<summary>
 Point-wise multiplication of two row vectors
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_Addition(Microsoft.FSharp.Math.RowVector{`0},Microsoft.FSharp.Math.RowVector{`0})">
<summary>
 Point-wise addition of two row vectors
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.RowVector`1.Transpose">
<summary>
 Get the transpose of the row vector.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Math.RowVector`1.InternalValues">
<summary>
 Get the underlying internal array of values for a vector. This property 
 should only be used when interoperating with other matrix libraries.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.ToArray">
<summary>
 Return a new array containing a copy of the elements of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.SetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Math.RowVector{`0})">
<summary>
 Supports the slicing syntax &apos;rv.[idx1..idx2] &lt;- rv2&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.Permute(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32})">
<summary>
 Permute the elements of the row vector.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.GetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Supports the slicing syntax &apos;rv.[idx1..idx2]&apos;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.Copy">
<summary>
 Create a new matrix that is a copy of a array
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.RowVector`1">
<summary>
 The type of row vectors. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.Item(System.Int32,`0)">
<summary>
 Gets an item from a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_UnaryPlus(Microsoft.FSharp.Math.Vector{`0})">
<summary>
 Return the input vector 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_UnaryNegation(Microsoft.FSharp.Math.Vector{`0})">
<summary>
 Negate a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_Subtraction(Microsoft.FSharp.Math.Vector{`0},Microsoft.FSharp.Math.Vector{`0})">
<summary>
 Subtract two vectors, pointwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_Multiply(Microsoft.FSharp.Math.Vector{`0},`0)">
<summary>
 Multiply a vector by a scalar
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_Multiply(Microsoft.FSharp.Math.Vector{`0},Microsoft.FSharp.Math.RowVector{`0})">
<summary>
 Multiply a column vector and a row vector to produce a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_Multiply(`0,Microsoft.FSharp.Math.Vector{`0})">
<summary>
 Multiply each element of a vector by a scalar value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_DotMultiply(Microsoft.FSharp.Math.Vector{`0},Microsoft.FSharp.Math.Vector{`0})">
<summary>
 Point-wise multiplication of two vectors.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_Addition(Microsoft.FSharp.Math.Vector{`0},Microsoft.FSharp.Math.Vector{`0})">
<summary>
 Add two vectors, pointwise
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.Transpose">
<summary>
 Get the transpose of a vector.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.NumRows">
<summary>
 Gets the number of rows in a vector
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.Norm">
<summary>
 Computes the 2-norm of a vector: sqrt(x.Transpose*x).
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.Length">
<summary>
 Gets the number of entries in a vector
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.Item(System.Int32)">
<summary>
 Gets an item from a vector
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.InternalValues">
<summary>
 Get the underlying internal array of values for a vector. This property 
 should only be used when interoperating with other matrix libraries.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.ElementOps">
<summary>
 Gets the element operations for the element type of a vector, if any
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.ToArray">
<summary>
 Return a new array containing a copy of the elements of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.SetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Math.Vector{`0})">
<summary>
 Supports the slicing syntax &apos;v.[idx1..idx2] &lt;- v2&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.Permute(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32})">
<summary>
 Permute the elements of a vector.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.GetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Supports the slicing syntax &apos;v.[idx1..idx2]&apos;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.Copy">
<summary>
 Create a new matrix that is a copy of a array
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Vector`1">
<summary>
 The type of column vectors. The arithmetic operations on the element type are determined by inspection 
 on the element type itself
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Math.complex">
<summary>
 The type of complex numbers 
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.matrix">
<summary>
 The type of floating point matrices
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.rowvec">
<summary>
 The type of floating point row vectors
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.vector">
<summary>
 The type of floating point column vectors
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.tan(Microsoft.FSharp.Math.Complex)">
<summary>
 Tagent
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.cos(Microsoft.FSharp.Math.Complex)">
<summary>
 Cosine
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.sin(Microsoft.FSharp.Math.Complex)">
<summary>
 Sine
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.sqrt(Microsoft.FSharp.Math.Complex)">
<summary>
 sqrt(x) and 0 &lt;= phase(x) &lt; pi
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.log(Microsoft.FSharp.Math.Complex)">
<summary>
 log(x) is natural log (base e)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.exp(Microsoft.FSharp.Math.Complex)">
<summary>
 exp(x) = e^x
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.ComplexModule.pi">
<summary>
 pi
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.muls(Microsoft.FSharp.Math.Complex,System.Double)">
<summary>
 Multiply a complex number by a scalar
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.smul(System.Double,Microsoft.FSharp.Math.Complex)">
<summary>
 Multiply a scalar by a complex number 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.neg(Microsoft.FSharp.Math.Complex)">
<summary>
 Unary negation of a complex number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.div(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Complex division of two complex numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.mul(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Multiply two complex numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.sub(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Subtract one complex number from another
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.add(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Add two complex numbers
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.ComplexModule.onei">
<summary>
 The complex number 0+1i
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.ComplexModule.one">
<summary>
 The complex number 1+0i
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.ComplexModule.zero">
<summary>
 The complex number 0+0i
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.conjugate(Microsoft.FSharp.Math.Complex)">
<summary>
 The conjugate of a complex number, i.e. x-yi
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.cis(System.Double)">
<summary>
 A complex of magnitude 1 and the given phase and , i.e. cis x = mkPolar 1.0 x
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.mkPolar(System.Double,System.Double)">
<summary>
 Create a complex number using magnitude/phase polar coordinates
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.imagPart(Microsoft.FSharp.Math.Complex)">
<summary>
 The imaginary part of a complex number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.realPart(Microsoft.FSharp.Math.Complex)">
<summary>
 The real part of a complex number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.phase(Microsoft.FSharp.Math.Complex)">
<summary>
 The polar-coordinate phase of a complex number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.ComplexModule.magnitude(Microsoft.FSharp.Math.Complex)">
<summary>
 The polar-coordinate magnitude of a complex number
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Math.ComplexModule">

</member>
<member name="M:Microsoft.FSharp.Math.ComplexTopLevelOperators.complex(System.Double,System.Double)">
<summary>
 Constructs a complex number from both the real and imaginary part.
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.ComplexTopLevelOperators">

</member>
<member name="M:Microsoft.FSharp.Math.GlobalAssociations.RegisterNumericAssociation``1(Microsoft.FSharp.Math.INumeric{``0})">
<summary>
 Record an AppDomain-wide association between the given type and the given dictionary of
 numeric operations.  Raise an error if an existing association already exists. 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.GlobalAssociations.GetNumericAssociation``1">
<summary>
 Attempt to determine a numeric association for the given type, i.e. a registered dictionary of
 numeric operations.  The interface can be queried dynamically for additional functionality in the numerics
 hierarchy.
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.GlobalAssociations">
<summary>
 Associations are a way of associating dictionaries of
 operations with given types at runtime.  Associations are global to a 
 .NET application domain.  Once specified an association may not be deleted
 or modified.

 In this release the system of associations is simply 
 limited to a registry of types that support dictionaries (i.e. interface objects)
 of numeric operations.  The following types are pre-registered with associated numeric
 operations: float, int32, int64, bigint, float32, Complex, bignum.  Other types must be
 registered explicitly by user code.

</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Math.Instances">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.inplaceSub(Microsoft.FSharp.Math.Matrix{System.Double},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 In-place subtraction, mutating the first matrix argument. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.inplaceAdd(Microsoft.FSharp.Math.Matrix{System.Double},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 In-place addition, mutating the first matrix argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.copy(Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Create a new matrix that is a copy of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.mapi(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,System.Double}}},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Map the given indexed function over each element of a matrix, producing a new matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.map(Microsoft.FSharp.Core.FSharpFunc`2{System.Double,System.Double},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Map a function over each element of a matrix, producing a new matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.foldRow``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,``0}},``0,Microsoft.FSharp.Math.Matrix{System.Double},System.Int32)">
<summary>
 Fold a function down a particular row of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.foldCol``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,``0}},``0,Microsoft.FSharp.Math.Matrix{System.Double},System.Int32)">
<summary>
 Fold a function along a particular column of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.foldByRow``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,``0}},Microsoft.FSharp.Math.Vector{``0},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Fold a function along each row of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.foldByCol``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,``0}},Microsoft.FSharp.Math.RowVector{``0},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Fold a function down each column of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.foldi``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,``0}}}},``0,Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Fold an indexed function over all elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.fold``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,``0}},``0,Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Fold a function over all elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.existsi(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,System.Boolean}}},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Check if a predicate holds for at least one element of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.foralli(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,System.Boolean}}},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Check if a predicate holds for all elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.exists(Microsoft.FSharp.Core.FSharpFunc`2{System.Double,System.Boolean},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Check if a predicate holds for at least one element of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.forall(Microsoft.FSharp.Core.FSharpFunc`2{System.Double,System.Boolean},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Check if a predicate holds for all elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.norm(Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
sqrt(sum(x*x)) of all the elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.prod(Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
Multiply all the elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.sum(Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Sum all the elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.randomize(Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Generate a new matrix of the same size as the input with random entries 
 drawn from the range 0..aij. Random numbers are generated using a globally 
 shared System.Random instance with the initial seed 99.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.trace(Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Sum of the diagonal elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.transpose(Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Transpose of a matrix. Use also m.Transpose
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.cptPow(Microsoft.FSharp.Math.Matrix{System.Double},System.Double)">
<summary>
 Point-wise exponential of a matrix.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.dot(Microsoft.FSharp.Math.Matrix{System.Double},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Dot product
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.add(Microsoft.FSharp.Math.Matrix{System.Double},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Add two matrices (operator +)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.cptMin(Microsoft.FSharp.Math.Matrix{System.Double},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Point-wise minimum element of two matrices
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.cptMax(Microsoft.FSharp.Math.Matrix{System.Double},Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Point-wise maximum element of two matrices
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.toDense(Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Ensure that a matrix uses dense representation
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.toVector(Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Return the first column of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.toRowVector(Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Return the first row of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.toScalar(Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Return the element at row 0, column 0 of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.ofVector(Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Create a matrix with one column from the given vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.ofRowVector(Microsoft.FSharp.Math.RowVector{System.Double})">
<summary>
 Create a matrix with one row from the given row vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.ofScalar(System.Double)">
<summary>
 Create a 1x1 matrix containing the given value 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.toArray2D(Microsoft.FSharp.Math.Matrix{System.Double})">
<summary>
 Return a new array containing the elements of the given matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.ofArray2D(System.Double[0:,0:])">
<summary>
 Create a matrix from the given data
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create a matrix from the given data
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.ofList(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{System.Double}})">
<summary>
 Create a matrix from the given data
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.initDiagonal(Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Create a square matrix with a vector lying on diagonal
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.identity(System.Int32)">
<summary>
 Create a square matrix with the constant 1.0 lying on diagonal
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.zero(System.Int32,System.Int32)">
<summary>
 Create a matrix with all entries zero
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.initSparse(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple`3{System.Int32,System.Int32,System.Double}})">
<summary>
 Create a sparse representation matrix with the given entries. Not all 
 operations are available for sparse matrices, and mutation is not permitted.
 If an operation on sparse matrices raises a runtime exception then consider 
 converting to a dense matrix using to_dense.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.initDense(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple`3{System.Int32,System.Int32,System.Double}})">
<summary>
 Create a dense representation matrix with the given entries. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.create(System.Int32,System.Int32,System.Double)">
<summary>
 Create a matrix with all entries the given constant
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.set(Microsoft.FSharp.Math.Matrix{System.Double},System.Int32,System.Int32,System.Double)">
<summary>
 Set an element of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.get(Microsoft.FSharp.Math.Matrix{System.Double},System.Int32,System.Int32)">
<summary>
 Get an element of a matrix
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.inplaceSub``1(Microsoft.FSharp.Math.Matrix{``0},Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Subtract the second matrix from the first, by mutating the first
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.inplaceAdd``1(Microsoft.FSharp.Math.Matrix{``0},Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Add the second matrix to the first by, mutating the first
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.mapi``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}}},Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Map the given position-indexed function over a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.map``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,``0},Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Map a function over a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.copy``1(Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Create a new matrix that is a copy of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.existsi``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean}}},Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Return true if an indexed predicate returns true for some value in a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.foralli``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean}}},Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Return true if an indexed predicate returns true for all values in a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Return true if a predicate returns true for some value in a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.forall``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Return true if a predicate returns true for all values in a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.foldi``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}}}},``0,Microsoft.FSharp.Math.Matrix{``1})">
<summary>
 Fold an indexed function over all elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Math.Matrix{``1})">
<summary>
 Fold a function over all elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.norm``1(Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Returns sqrt(sum(norm(x)*(norm(x))) of all the elements of a matrix.
 The element type of a matrix must have an associated instance of INormFloat&lt;&apos;T&gt; (see &lt;c&gt;GlobalAssociations&lt;/c&gt;) ((else NotSupportedException)).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.prod``1(Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Compute the product of the elements in a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.sum``1(Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Compute the sum of the elements in a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.trace``1(Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Compute the sum of the diagonal of a square matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.transpose``1(Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Return a new matrix which is the transpose of the input matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.dot``1(Microsoft.FSharp.Math.Matrix{``0},Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Sum of the point-wise multiple of the two matrices.
 The element type of a matrix must have an associated instance of INumeric&lt;&apos;T&gt; (see &lt;c&gt;GlobalAssociations&lt;/c&gt;) ((else NotSupportedException)).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.cptMin``1(Microsoft.FSharp.Math.Matrix{``0},Microsoft.FSharp.Math.Matrix{``0})">
<summary>
Take the pointwise maximum of two matrices
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.cptMax``1(Microsoft.FSharp.Math.Matrix{``0},Microsoft.FSharp.Math.Matrix{``0})">
<summary>
Take the pointwise maximum of two matrices
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.initDiagonal``1(Microsoft.FSharp.Math.Vector{``0})">
<summary>
 Create a matrix containing the given vector along the diagonal.
 The element type of a matrix must have an associated instance of INumeric&lt;&apos;T&gt; (see &lt;c&gt;GlobalAssociations&lt;/c&gt;) ((else NotSupportedException)).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.identity``1(System.Int32)">
<summary>
 Create a square matrix with the one for the element type lying on diagonal
 The element type of a matrix must have an associated instance of INumeric&lt;&apos;T&gt; (see &lt;c&gt;GlobalAssociations&lt;/c&gt;) ((else NotSupportedException)).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.zero``1(System.Int32,System.Int32)">
<summary>
 Create a matrix containing the zero element at each index.
 The element type of a matrix must have an associated instance of INumeric&lt;&apos;T&gt; (see &lt;c&gt;GlobalAssociations&lt;/c&gt;) ((else NotSupportedException)).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.initNumeric``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Math.INumeric{``0},Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0}}})">
<summary>
 Create a matrix using a function to compute the item at each index.
 The element type of a matrix must have an associated instance of INumeric&lt;&apos;T&gt; (see &lt;c&gt;GlobalAssociations&lt;/c&gt;) ((else NotSupportedException)).
 The function is passed the dictionary of associated operations in addition to the index pair.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.init``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0}})">
<summary>
 Create a matrix using a function to compute the item at each index.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.toVector``1(Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Extract the first column of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.toRowVector``1(Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Extract the first row of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.toScalar``1(Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Get the element at column zero, row zero
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.ofVector``1(Microsoft.FSharp.Math.Vector{``0})">
<summary>
 Create a matrix from a column vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.ofRowVector``1(Microsoft.FSharp.Math.RowVector{``0})">
<summary>
 Create a matrix from a row vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.of_scalar``1(``0)">
<summary>
 Create a 1x1 matrix containing the given value 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.initSparse``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple`3{System.Int32,System.Int32,``0}})">
<summary>
 Create a sparse matrix from the given sequence of elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.initDense``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple`3{System.Int32,System.Int32,``0}})">
<summary>
 Create a dense matrix from the given sequence of elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.create``1(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix containing the given value at every element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.toArray2D``1(Microsoft.FSharp.Math.Matrix{``0})">
<summary>
 Return a new array containing the elements of the given matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.ofArray2D``1(``0[0:,0:])">
<summary>
 Create a matrix from the given data  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.ofSeq``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create a matrix from the given data  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.ofList``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Create a matrix from the given data  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.set``1(Microsoft.FSharp.Math.Matrix{``0},System.Int32,System.Int32,``0)">
<summary>
 Set an element in a matrix. The indexes are given in row/column order.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.MatrixModule.Generic.get``1(Microsoft.FSharp.Math.Matrix{``0},System.Int32,System.Int32)">
<summary>
 Get an element from a matrix. The indexes are given in row/column order.
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.MatrixModule.Generic">
<summary>
 Operations to manipulate matrix types carrying
 arbitrary element types. The names and types of the operations match those
 in the containing module Math.Matrix. 

 The numeric operations on the element type (add, zero etc.) are inferred from the type
 argument itself. That is, for some operations 
 the element type of a matrix must have an associated instance of INumeric&lt;&apos;T&gt; 
 or some more specific numeric association (see &lt;c&gt;GlobalAssociations&lt;/c&gt;) ((else NotSupportedException)).
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.MatrixModule">
<summary>
 Operations to manipulate floating
 point matrices. The submodule &lt;c&gt;Matrix.Generic&lt;/c&gt; contains a 
 matching set of operations to manipulate matrix types carrying
 arbitrary element types.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Math.Measure">

</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.u">
<summary>
 Unified atomic mass unit
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.eV">
<summary>
 Electron volt
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.sigma">
<summary>
 Stefan-Boltzmann constant
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.k">
<summary>
 Boltzmann constant R/N_A
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.R">
<summary>
 Molar gas constant
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.F">
<summary>
 Faraday constant
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.N_A">
<summary>
 Avogadro constant
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.R_inf">
<summary>
 Rydberg constant
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.alpha">
<summary>
 Fine-structure constant
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.m_p">
<summary>
 Proton mass
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.m_e">
<summary>
 Electron mass
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.G0">
<summary>
 Conductance quantum 2e^2/h
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.Phi0">
<summary>
 Magnetic flux quantum h/2e
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.e">
<summary>
 Elementary charge
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.hbar">
<summary>
 Dirac constant, also known as the reduced Planck constant = h/2pi
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.h">
<summary>
 Planck constant
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.G">
<summary>
 Newtonian constant of gravitation
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.epsilon0">
<summary>
 electric constant = 1/(mu0 c^2)
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.mu0">
<summary>
 magnetic constant
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.PhysicalConstants.c">
<summary>
 speed of light in vacuum
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.PhysicalConstants">
<summary>
 Fundamental physical constants, with units-of-measure
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.toArray(Microsoft.FSharp.Math.RowVector{System.Double})">
<summary>
 Return a new array containing a copy of the elements of the given vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.ofArray(System.Double[])">
<summary>
 Create a vector from an array of double precision floats
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.ofSeq(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Create a vector from a sequence of numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.ofList(Microsoft.FSharp.Collections.FSharpList{System.Double})">
<summary>
 Create a vector from a list of numbers
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.zero(System.Int32)">
<summary>
 Return a vector of the given length where every entry is zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.init(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Double})">
<summary>
 Create by comprehension
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.create(System.Int32,System.Double)">
<summary>
 Create by constant initialization
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.length(Microsoft.FSharp.Math.RowVector{System.Double})">
<summary>
 Get the dimensions (number of rows) of a column rowvec. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.set(Microsoft.FSharp.Math.RowVector{System.Double},System.Int32,System.Double)">
<summary>
 Set an element of a column rowvec
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.get(Microsoft.FSharp.Math.RowVector{System.Double},System.Int32)">
<summary>
 Get an element of a column vector
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.Generic.toArray``1(Microsoft.FSharp.Math.RowVector{``0})">
<summary>
 Return a new array containing a copy of the elements of the given vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.Generic.ofArray``1(``0[])">
<summary>
 Create a row vector from an array of elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.Generic.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create a row vector from a sequence of elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.Generic.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Create a row vector from a list of elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.Generic.zero``1(System.Int32)">
<summary>
 Return a vector of the given length where every entry is zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.Generic.create``1(System.Int32,``0)">
<summary>
 Create by constant initialization
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.Generic.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">
<summary>
 Create by comprehension
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.Generic.transpose``1(Microsoft.FSharp.Math.RowVector{``0})">
<summary>
 Transpose the row vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.Generic.length``1(Microsoft.FSharp.Math.RowVector{``0})">
<summary>
 Get the number of rows in a column vector. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.Generic.set``1(Microsoft.FSharp.Math.RowVector{``0},System.Int32,``0)">
<summary>
 Set an element in a column vector. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVectorModule.Generic.get``1(Microsoft.FSharp.Math.RowVector{``0},System.Int32)">
<summary>
 Get an element from a column vector. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.RowVectorModule.Generic">
<summary>
 Operations to manipulate row vectors types carrying
 arbitrary element types. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.RowVectorModule">
<summary>
 Operations to manipulate floating
 point row vectors. These are included for completeness and are
 nearly always transposed to column vectors.
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.kat">
<summary>
 katal, SI unit of catalytic activity
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.Sv">
<summary>
 sievert, SI unit of does equivalent
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.Gy">
<summary>
 gray, SI unit of absorbed dose
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.Bq">
<summary>
 becquerel, SI unit of activity referred to a radionuclide
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.lx">
<summary>
 lux, SI unit of illuminance
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.lm">
<summary>
 lumen, SI unit of luminous flux
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.H">
<summary>
 henry, SI unit of inductance
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.T">
<summary>
 tesla, SI unit of magnetic flux density
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.Wb">
<summary>
 weber, SI unit of magnetic flux
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.S">
<summary>
 siemens, SI unit of electric conductance
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.ohm">
<summary>
 ohm, SI unit of electric resistance
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.F">
<summary>
 farad, SI unit of capacitance
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.V">
<summary>
 volt, SI unit of electric potential difference, electromotive force
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.C">
<summary>
 coulomb, SI unit of electric charge, amount of electricity
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.W">
<summary>
 watt, SI unit of power, radiant flux
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.J">
<summary>
 joule, SI unit of energy, work, amount of heat
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.Pa">
<summary>
 pascal, SI unit of pressure, stress
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.N">
<summary>
 newton, SI unit of force
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.Hz">
<summary>
 hertz, SI unit of frequency
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.cd">
<summary>
 candela, SI unit of luminous intensity
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.mol">
<summary>
 mole, SI unit of amount of substance
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.K">
<summary>
 kelvin, SI unit of thermodynamic temperature
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.A">
<summary>
 ampere, SI unit of electric current
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.s">
<summary>
 second, SI unit of time
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.kg">
<summary>
 kilogram, SI unit of mass
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI.m">
<summary>
 metre (or meter), SI unit of length
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SI">
<summary>
 The International System of Units (SI)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.mapi(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,System.Double}},Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Map an indexed function over each element of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.map(Microsoft.FSharp.Core.FSharpFunc`2{System.Double,System.Double},Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Map a function over each element of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.copy(Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Copy a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.foldi``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,``0}}},``0,Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Fold an indexed function over all elements of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.fold``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,``0}},``0,Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Fold a function over all elements of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.existsi(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,System.Boolean}},Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Return true if an indexed predicate returns true for some value in a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.foralli(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Double,System.Boolean}},Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Return true if an indexed predicate returns true for all values in a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.exists(Microsoft.FSharp.Core.FSharpFunc`2{System.Double,System.Boolean},Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Return true if a predicate returns true for some value in a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.forall(Microsoft.FSharp.Core.FSharpFunc`2{System.Double,System.Boolean},Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Return true if a predicate returns true for all values in a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.norm(Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Computes the 2-norm of a vector: sqrt(x.Transpose*x).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.prod(Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
Multiply all the elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.sum(Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
Sum all the elements of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.transpose(Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
Transpose of a matrix. Use also m.Transpose
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.cptPow(Microsoft.FSharp.Math.Vector{System.Double},System.Double)">
<summary>
Point-wise exponential of a vector.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.dot(Microsoft.FSharp.Math.Vector{System.Double},Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
Dot product
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.range(System.Int32,System.Int32)">
<summary>
 Create a vector that represents a integral mesh over the given range
 e.g. range 1 5 = vector [ 1.;2.;3.;4.;5. ]
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.rangef(System.Double,System.Double,System.Double)">
<summary>
 Create a vector that represents a mesh over the given range
 e.g. rangef (-1.0) 0.5 1.0 = vector [ -1.0; -0.5; 0.0; 0.5; 1.0]
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.zero(System.Int32)">
<summary>
 Return a vector of the given length where every entry is zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.create(System.Int32,System.Double)">
<summary>
 Generate a vector of the given length where each entry contains the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.ofScalar(System.Double)">
<summary>
 Create a 1-element vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.toArray(Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Return a new array containing a copy of the elements of the given vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.ofArray(System.Double[])">
<summary>
 Create a vector from an array of double precision floats
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.ofSeq(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Create a vector from a sequence of numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.ofList(Microsoft.FSharp.Collections.FSharpList{System.Double})">
<summary>
 Create a vector from a list of numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.init(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Double})">
<summary>
 Create a vector of a fixed length using a function to compute the initial element values
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.length(Microsoft.FSharp.Math.Vector{System.Double})">
<summary>
 Get the dimensions (number of rows) of a column vector. Identical to &lt;c&gt;nrows&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.set(Microsoft.FSharp.Math.Vector{System.Double},System.Int32,System.Double)">
<summary>
 Set an element of a column vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.get(Microsoft.FSharp.Math.Vector{System.Double},System.Int32)">
<summary>
 Get an element of a column vector
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.mapi``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Math.Vector{``0})">
<summary>
 Map an indexed function over each element of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.map``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,``0},Microsoft.FSharp.Math.Vector{``0})">
<summary>
 Map a function over each element of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.copy``1(Microsoft.FSharp.Math.Vector{``0})">
<summary>
 Copy the vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.foldi``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}}},``0,Microsoft.FSharp.Math.Vector{``1})">
<summary>
 Fold an indexed function over all elements of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Math.Vector{``1})">
<summary>
 Fold a function over all elements of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.existsi``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean}},Microsoft.FSharp.Math.Vector{``0})">
<summary>
 Return true if an indexed predicate returns true for some value in a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.foralli``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean}},Microsoft.FSharp.Math.Vector{``0})">
<summary>
 Return true if an indexed predicate returns true for all values in a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Math.Vector{``0})">
<summary>
 Return true if a predicate returns true for some value in a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.forall``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Math.Vector{``0})">
<summary>
 Return true if a predicate returns true for all values in a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.norm``1(Microsoft.FSharp.Math.Vector{``0})">
<summary>
 Computes the 2-norm of a vector: sqrt(x.Transpose*x).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.prod``1(Microsoft.FSharp.Math.Vector{``0})">
<summary>
Multiply all the elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.sum``1(Microsoft.FSharp.Math.Vector{``0})">
<summary>
Sum all the elements of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.dot``1(Microsoft.FSharp.Math.Vector{``0},Microsoft.FSharp.Math.Vector{``0})">
<summary>
Dot product
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.cptMin``1(Microsoft.FSharp.Math.Vector{``0},Microsoft.FSharp.Math.Vector{``0})">
<summary>
Take the pointwise minimum of two vectors
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.cptMax``1(Microsoft.FSharp.Math.Vector{``0},Microsoft.FSharp.Math.Vector{``0})">
<summary>
Take the pointwise maximum of two vectors
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.zero``1(System.Int32)">
<summary>
 Return a vector of the given length where every entry is zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.create``1(System.Int32,``0)">
<summary>
 Generate a vector of the given length where each entry contains the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.toArray``1(Microsoft.FSharp.Math.Vector{``0})">
<summary>
 Return a new array containing a copy of the elements of the given vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.ofArray``1(``0[])">
<summary>
 Create a vector from an array of elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.ofScalar``1(``0)">
<summary>
 Create a 1-element vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create a vector from a sequence of numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Create a vector from a list of numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.initNumeric``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Math.INumeric{``0},Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0}})">
<summary>
 Creation: useful when the element type has associated operations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">
<summary>
 Creation: general
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.length``1(Microsoft.FSharp.Math.Vector{``0})">
<summary>
 Get the dimensions (number of rows) of a column vector. Identical to &lt;c&gt;nrows&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.set``1(Microsoft.FSharp.Math.Vector{``0},System.Int32,``0)">
<summary>
 Set an element of a column vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.VectorModule.Generic.get``1(Microsoft.FSharp.Math.Vector{``0},System.Int32)">
<summary>
 Get an element of a column vector
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.VectorModule.Generic">
<summary>
 Operations to manipulate column vectors carrying
 arbitrary element types. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.VectorModule">
<summary>
 Operations to manipulate floating
 point column vectors. The submodule VectorOps.Generic contains a 
 matching set of operations to manipulate column vectors carrying
 arbitrary element types.
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.CMatrix`1">
<summary>
 See NativeArray2
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.FortranMatrix`1.Item(System.Int32,System.Int32,`0)">
<summary>
 Get or set an entry in the array
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.FortranMatrix`1.NativeTranspose">
<summary>
 View a FortranMatrix as a CMatrix.  Doesn&apos;t actually allocate
 a new matirx - just gives a different label to the same bits, and swaps the
 row/column count information associated with the bits.
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.FortranMatrix`1.Item(System.Int32,System.Int32)">
<summary>
 Get or set an entry in the array
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.NativeInterop.FortranMatrix`1">
<summary>
 This type wraps a pointer to a blob of unmanaged memory assumed to contain
 a Fortran-style column major two-dimensional matrix of items compatible with the (presumably blittable) 
 type &apos;T. The blob of memory must be allocated and managed externally, 
 e.g. by a computation routine written in C.

 All operations on this type are marked inlined
 because the code used to implement the operations is not verifiable.  

 Any code that uses these operations will be unverifiable and may 
 cause memory corruption if not used with extreme care.
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray2`1.Item(System.Int32,System.Int32,`0)">
<summary>
 Get or set an entry in the array
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray2`1.Ptr">
<summary>
 Pointer to the C-style row major two-dimensional array 
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray2`1.NumRows">
<summary>
 Get the number of rows of the native array
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray2`1.NumCols">
<summary>
 Get the number of columns of the native array
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray2`1.NativeTranspose">
<summary>
 View a CMatrix as a FortranMatrix.  Doesn&apos;t actually allocate
 a new matirx - just gives a different label to the same bits, and swaps the
 row/column count information associated with the bits.
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray2`1.Item(System.Int32,System.Int32)">
<summary>
 Get or set an entry in the array
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativeArray2`1.#ctor(`0*,System.Int32,System.Int32)">
<summary>
 Creates a C-style row major two-dimensional array from a native pointer, the number of rows and the number of columns.  
 Nothing is actually copied.
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.NativeArray2`1">
<summary>
 This type wraps a pointer to a blob of unmanaged memory assumed to contain
 a C-style row major two-dimensional matrix of items compatible with the (presumably blittable) 
 type &apos;T. The blob of memory must be allocated and managed externally, 
 e.g. by a computation routine written in C.

 All operations on this type are marked inlined
 because the code used to implement the operations is not verifiable.  

 Any code that uses these operations will be unverifiable and may 
 cause memory corruption if not used with extreme care.
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray`1.Item(System.Int32,`0)">
<summary>
 Get or set an entry in the array
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray`1.Ptr">
<summary>
 Pointer to the C-style one-dimensional array
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray`1.Length">
<summary>
 Length of the C-style one-dimensional array
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray`1.Item(System.Int32)">
<summary>
 Get or set an entry in the array
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativeArray`1.#ctor(`0*,System.Int32)">
<summary>
 Creates a C-style one dimensional array from a native pointer and the length of the array
 Nothing is actually copied.
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.NativeArray`1">
<summary>
 This type wraps a pointer to a blob of unmanaged memory assumed to contain
 a C-style one-dimensional array of items compatible with the (presumably blittable) 
 type &apos;T.  The blob of memory must be allocated and managed externally, 
 e.g. by a computation routine written in C.

 All operations on this type are marked inlined
 because the code used to implement the operations is not verifiable.  

 Any code that uses these operations will be unverifiable and may 
 cause memory corruption if not used with extreme care.
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.PinnedArray2`1.of_array2D(`0[0:,0:])">
<summary>
 For native interop. Pin the given object
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.PinnedArray2`1.of_array2(`0[0:,0:])">
<summary>
 For native interop. Pin the given object
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.NativeInterop.PinnedArray2`1">
<summary>
 Represents a pinned handle to a structure with an underlying 2D array, i.e. an underlying NativeArray2.
 Used when interfacing with native code math libraries such as LAPACK.
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.PinnedArray`1.of_array(`0[])">
<summary>
 For native interop. Pin the given object
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.NativeInterop.PinnedArray`1">
<summary>
 Represents a pinned handle to a structure with an underlying 1D array, i.e. an underlying NativeArray.
 Used when interfacing with native code math libraries such as LAPACK.
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.NativArrayExtensionsForMatrix">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.Ref.pin``2(Microsoft.FSharp.Core.FSharpRef{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0*,``1})">
<summary>
 Pin the given ref for the duration of a single call to the given function.  A native pointer to
 the contents of the ref is passed to the given function.  Cleanup the GCHandle associated with the 
 pin when the function completes, even if an exception is raised.
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.Ref">

</member>
<member name="M:Microsoft.FSharp.Text.Lexing.UnicodeTables.Interpret(System.Int32,Microsoft.FSharp.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Interpret tables for a unicode lexer generated by fslex. 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Text.Lexing.UnicodeTables.AsyncInterpret(System.Int32,Microsoft.FSharp.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Interpret tables for a unicode lexer generated by fslex, processing input asynchronously
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Lexing.UnicodeTables">
<summary>
 The type of tables for an unicode lexer generated by fslex. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Lexing.AsciiTables.Interpret(System.Int32,Microsoft.FSharp.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Interpret tables for an ascii lexer generated by fslex. 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Text.Lexing.AsciiTables.AsyncInterpret(System.Int32,Microsoft.FSharp.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Interpret tables for an ascii lexer generated by fslex, processing input asynchronously
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Lexing.AsciiTables">
<summary>
 The type of tables for an ascii lexer generated by fslex. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.LexBuffer`1.StartPos(Microsoft.FSharp.Text.Lexing.Position)">
<summary>
 The start position for the lexeme
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.LexBuffer`1.IsPastEndOfStream(System.Boolean)">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to true.
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.LexBuffer`1.EndPos(Microsoft.FSharp.Text.Lexing.Position)">
<summary>
 The end position for the lexeme
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.LexBuffer`1.StartPos">
<summary>
 The start position for the lexeme
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.LexBuffer`1.LexemeLength">
<summary>
 The length of the matched string 
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.LexBuffer`1.Lexeme">
<summary>
 The matched string 
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.LexBuffer`1.IsPastEndOfStream">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to true.
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.LexBuffer`1.EndPos">
<summary>
 The end position for the lexeme
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.LexBuffer`1.BufferLocalStore">
<summary>
 Dynamically typed, non-lexically scoped parameter table
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Lexing.LexBuffer`1.LexemeString(Microsoft.FSharp.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Fast helper to turn the matched characters into a string, avoiding an intermediate array
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Lexing.LexBuffer`1.LexemeChar(System.Int32)">
<summary>
 Fetch a particular character in the matched string 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Lexing.LexBuffer`1.FromTextReader(System.IO.TextReader)">
<summary>
 Create a lex buffer suitable for use with a Unicode lexer that reads character inputs from the given text reader
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Lexing.LexBuffer`1.FromString(System.String)">
<summary>
 Create a lex buffer suitable for Unicode lexing that reads characters from the given string
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Lexing.LexBuffer`1.FromFunction(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`3{`0[],System.Int32,System.Int32},System.Int32})">
<summary>
 Create a lex buffer that reads character or byte inputs by using the given function
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Lexing.LexBuffer`1.FromChars(System.Char[])">
<summary>
 Create a lex buffer suitable for Unicode lexing that reads characters from the given array
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Text.Lexing.LexBuffer`1.FromBytes(System.Byte[])">
<summary>
 Create a lex buffer suitable for byte lexing that reads characters from the given array
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Text.Lexing.LexBuffer`1.FromBinaryReader(System.IO.BinaryReader)">
<summary>
 Create a lex buffer suitable for use with ASCII byte lexing that reads byte inputs from the given binary reader
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Lexing.LexBuffer`1.FromAsyncFunction(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`3{`0[],System.Int32,System.Int32},Microsoft.FSharp.Control.FSharpAsync{System.Int32}})">
<summary>
 Create a lex buffer that asynchronously reads character or byte inputs by using the given function
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Lexing.LexBuffer`1.DiscardInput">
<summary>
 Remove all input, though don&apos;t discard the current lexeme 
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Lexing.LexBuffer`1">
<summary>
 Input buffers consumed by lexers generated by &lt;c&gt;fslex.exe &lt;/c&gt;
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Lexing.Microsoft.FSharp.Text.Lexing.Position.pos_cnum">
<summary>
 The absolute offset of the column for the position
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Lexing.Microsoft.FSharp.Text.Lexing.Position.pos_bol">
<summary>
 The absolute offset of the beginning of the line
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Lexing.Microsoft.FSharp.Text.Lexing.Position.pos_lnum">
<summary>
 The line number for the position
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Lexing.Microsoft.FSharp.Text.Lexing.Position.pos_fname">
<summary>
 The file name for the position
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.Position.StartOfLineAbsoluteOffset">
<summary>
 Return absolute offset of the start of the line marked by the position
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Text.Lexing.Position.Line">
<summary>
 The line number in the input stream, assuming fresh positions have been updated 
 using AsNewLinePos() and by modifying the EndPos property of the LexBuffer.
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.Position.FileName">
<summary>
 The file name associated with the input stream.
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.Position.Empty">
<summary>
 Get an arbitrary position, with the empty string as filename, and  
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Lexing.Position.Column">
<summary>
 Return the column number marked by the position, i.e. the difference between the AbsoluteOffset and the StartOfLineAbsoluteOffset
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Text.Lexing.Position.AbsoluteOffset">
<summary>
 The character number in the input stream
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Lexing.Position.ShiftColumnBy(System.Int32)">
<summary>
 Gives a position shifted by specified number of characters
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Lexing.Position.FirstLine(System.String)">
<summary>
 Get a position corresponding to the first line (line number 1) in a given file
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Lexing.Position.EndOfToken(System.Int32)">
<summary>
 Given a position at the start of a token of length n, return a position just beyond the end of the token
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Text.Lexing.Position">
<summary>
 Position information stored for lexing tokens
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.tagOfErrorTerminal">
<summary>
 The tag of the error terminal
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.numTerminals">
<summary>
 The total number of terminals 
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.parseError">
<summary>
 This function is used to hold the user specified &quot;parse_error&quot; or &quot;parse_error_rich&quot; functions
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.productionToNonTerminalTable">
<summary>
 This table is logically part of the Goto table
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.stateToProdIdxsTableRowOffsets">
<summary>
 The sparse table offsets for the productions active for each state
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.stateToProdIdxsTableElements">
<summary>
 The sparse table for the productions active for each state
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.sparseGotoTableRowOffsets">
<summary>
 The sparse goto table row offsets
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.gotos">
<summary>
 The sparse goto table
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.immediateActions">
<summary>
 The immediate action table
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.reductionSymbolCounts">
<summary>
 The number of symbols for each reduction
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.actionTableRowOffsets">
<summary>
 The sparse action table row offsets
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.actionTableElements">
<summary>
 The sparse action table elements
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.dataOfToken">
<summary>
 A function to compute the data carried by a token
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.tagOfToken">
<summary>
 A function to compute the tag of a token
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.endOfInputTag">
<summary>
 The token number indicating the end of input
</summary>
</member>
<member name="F:Microsoft.FSharp.Text.Parsing.Microsoft.FSharp.Text.Parsing.Tables`1.reductions">
<summary>
 The reduction table
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Parsing.Tables`1.Interpret``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Text.Lexing.LexBuffer{``0},`0},Microsoft.FSharp.Text.Lexing.LexBuffer{``0},System.Int32)">
<summary>
 Interpret the parser table taking input from the given lexer, using the given lex buffer, and the given start state.
 Returns an object indicating the final synthesized value for the parse.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Parsing.Tables`1">
<summary>
 Tables generated by fsyacc
 The type of the tables contained in a file produced by the fsyacc.exe parser generator.
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Parsing.ParseErrorContext`1.StateStack">
<summary>
 The stack of state indexes active at the parse error 
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Parsing.ParseErrorContext`1.ShiftTokens">
<summary>
 The token that would cause a shift at the parse error
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Parsing.ParseErrorContext`1.ReducibleProductions">
<summary>
 The stack of productions that would be reduced at the parse error 
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Parsing.ParseErrorContext`1.ReduceTokens">
<summary>
 The tokens that would cause a reduction at the parse error 
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Parsing.ParseErrorContext`1.ParseState">
<summary>
 The state active at the parse error 
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Parsing.ParseErrorContext`1.Message">
<summary>
 The message associated with the parse error
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Parsing.ParseErrorContext`1.CurrentToken">
<summary>
 The token that caused the parse error
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Parsing.ParseErrorContext`1">
<summary>
 The context provided when a parse error occurs
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Parsing.IParseState.ResultRange">
<summary>
 Get the full range of positions matched by the production
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.Parsing.IParseState.ParserLocalStore">
<summary>
 Get the store of local values associated with this parser
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Parsing.IParseState.RaiseError``1">
<summary>
 Raise an error in this parse context
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Parsing.IParseState.InputStartPosition(System.Int32)">
<summary>
 Get the start position for the terminal or non-terminal at a given index matched by the production
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Parsing.IParseState.InputRange(System.Int32)">
<summary>
 Get the start and end position for the terminal or non-terminal at a given index matched by the production
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Parsing.IParseState.InputEndPosition(System.Int32)">
<summary>
 Get the end position for the terminal or non-terminal at a given index matched by the production
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Parsing.IParseState.GetInput(System.Int32)">
<summary>
 Get the value produced by the terminal or non-terminal at the given position
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Parsing.IParseState">
<summary>
 The information accessible via the &lt;c&gt;parseState&lt;/c&gt; value within parser actions.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Parsing.RecoverableParseError">
<summary>
 Indicates a parse error has occured and parse recovery is in progress
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Text.Parsing.Accept">
<summary>
 Indicates an accept action has occured
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Parsing.ParseHelpers.parse_error(System.String)">
<summary>
 The default implementation of the parse_error function
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Parsing.ParseHelpers.parse_error_rich``1">
<summary>
 The default implementation of the parse_error_rich function
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Parsing.ParseHelpers">
<summary>
 Helpers used by generated parsers.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the &apos;fsi&apos;
 value.
 
 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.  

 The ShowIEnumerable is set the printing process will force the evalution of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.

 &lt;example&gt;
 From F# Interactive the default settings can be adjusted using, for example, 
 &lt;pre&gt;
   open Microsoft.FSharp.Compiler.Interactive.Settings;;
   setPrintWidth 120;;
 &lt;/pre&gt;
 &lt;/example&gt;
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredFormat.IEnvironment.MaxRows">
<summary>
 The maximum number of rows for which to generate layout for table-like 
 structures.  -1 if no maximum.
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredFormat.IEnvironment.MaxColumns">
<summary>
 The maximum number of elements for which to generate layout for 
 list-like structures, or columns in table-like 
 structures.  -1 if no maximum.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.IEnvironment.GetLayout(System.Object)">
<summary>
 Return to the layout-generation 
 environment to layout any otherwise uninterpreted object
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.Layout">
<summary>
 Data representing structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.Joint">
<summary>
 Data representing structured layouts of terms.  
 Data representing joints in structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.layout_to_string(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the LayoutOps module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.output_any``1(System.IO.TextWriter,``0)">
<summary>
 Ouput any value to a channel using the same set of formatting rules
 as any_to_string
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.any_to_string``1(``0)">
<summary>
 Convert any value to a string using a standard formatter
 Data is typically formatted in a structured format, e.g.
 lists are formatted using the &quot;[1;2]&quot; notation.
 The details of the format are not specified and may change
 from version to version and according to the flags given
 to the F# compiler.  The format is intended to be human-readable,
 not machine readable.  If alternative generic formats are required
 you should develop your own formatter, using the code in the
 implementation of this file as a starting point.

 Data from other .NET languages is formatted using a virtual
 call to Object.ToString() on the boxed version of the input.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.Display">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.unfoldL``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Text.StructuredFormat.Layout},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple`2{``0,``1}}},``1,System.Int32)">
<summary>
 For limitting layout of list-like sequences (lists,arrays,etc).
 unfold a list of items using (project and z) making layout list via itemL.
 If reach maxLength (before exhausting) then truncate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.tagAttrL(System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{System.String,System.String}},Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 See tagL
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.listL``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Text.StructuredFormat.Layout},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Layout like an F# list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.optionL``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Text.StructuredFormat.Layout},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Layout like an F# option.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.aboveListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Layout list vertically.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.aboveL(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Layout two vertically.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.tupleL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Form tuple of layouts.            
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.braceL(Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Wrap braces around layout.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.squareBracketL(Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Wrap square brackets around layout.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.bracketL(Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Wrap round brackets around Layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.sepListL(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Join layouts into a list separated using the given Layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.semiListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Join layouts into a semi-colon separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.spaceListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Join layouts into a space separated list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.commaListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Join layouts into a comma separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_AtAtMinusMinus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join broken with ident=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_AtAtMinus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join broken with ident=1 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_AtAt(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join broken with ident=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_MinusMinusMinus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_MinusMinus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=1
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_PlusPlus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_HatHat(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join, unbreakable. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.leftL(System.String)">
<summary>
 An string which is left  parenthesis (no space on the right).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.rightL(System.String)">
<summary>
 An string which is right parenthesis (no space on the left).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.sepL(System.String)">
<summary>
 An string which requires no spaces either side.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.wordL(System.String)">
<summary>
 An string leaf 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.objL(System.Object)">
<summary>
 An uninterpreted leaf, to be interpreted into a string
 by the layout engine. This allows leaf layouts for numbers, strings and
 other atoms to be customized according to culture.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.isEmptyL(Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Is it the empty layout?
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.emptyL">
<summary>
 The empty layout
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.LayoutOps">
<summary>
 A layout is a sequence of strings which have been joined together.
 The strings are classified as words, separators and left and right parenthesis.
 This classification determines where spaces are inserted.
 A joint is either unbreakable, breakable or broken.
 If a joint is broken the RHS layout occurs on the next line with optional indentation.
 A layout can be squashed to for given width which forces breaks as required.
</summary>
</member>
</members>
</doc>
