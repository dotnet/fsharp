Original:
{"overview": "Implement OverloadResolutionPriorityAttribute support using TDD: tests first, then
    infrastructure (LanguageFeature, attribute reading), then the pre-filter algorithm in
   ConstraintSolver that groups candidates by declaring type and keeps only highest-priority per
   group. Each sprint produces a buildable, testable increment.", "subtasks": [{"id": 1, "name":
   "Foundation: Feature + Tests", "description": "SPRINT 1: Add
   LanguageFeature.OverloadResolutionPriority and write comprehensive failing tests.\n\n1. Add
   `LanguageFeature.OverloadResolutionPriority` to LanguageFeatures.fs (both .fs and .fsi if
   needed)\n2. Map it to F# 10.0 (languageVersion100) in the features dictionary\n3. Add feature
   string to FSComp.txt: `featureOverloadResolutionPriority,\"Support
   OverloadResolutionPriorityAttribute for explicit overload prioritization.\"`\n4. Add
   GetFeatureString mapping in LanguageFeatures.fs\n5. Create new test file `tests/FSharp.Compiler.
   ComponentTests/Conformance/Tiebreakers/OverloadResolutionPriorityTests.fs`\n6. Write failing
   tests covering: basic priority selection (higher wins), negative priority (deprecation pattern),
    interaction with concreteness (priority overrides concreteness), extension method grouping,
   error on override\n\nFollow existing TiebreakerTests.fs patterns. Tests should fail because
   attribute isn't recognized yet. Build must succeed.", "dod": ["Build succeeds with 0 errors",
   "New LanguageFeature.OverloadResolutionPriority exists and maps to F# 10.0", "New test file
   compiles with at least 8 test cases covering RFC examples", "Tests are discoverable by test
   runner (run `dotnet test --list-tests` to verify)", "No code duplication - reuse
   shouldCompile/shouldFailWithAmbiguity helpers from TiebreakerTests"]}, {"id": 2, "name":
   "Attribute Reading", "description": "SPRINT 2: Add GetOverloadResolutionPriority() method to
   MethInfo type.\n\n1. In `src/Compiler/Checking/infos.fs`, add member to MethInfo:\n   - `member
   GetOverloadResolutionPriority: unit -> int`\n   - For ILMeth: scan CustomAttrs for
   OverloadResolutionPriorityAttribute, extract Int32 argument\n   - For FSMeth: scan Attribs for
   the attribute (if F#-defined)\n   - Return 0 for all other cases or when attribute not found\n
    - Handle MethInfoWithModifiedReturnType by delegating\n\n2. Add signature to
   `src/Compiler/Checking/infos.fsi`\n\n3. Write unit test in OverloadResolutionPriorityTests.fs
   that verifies attribute reading works:\n   - Create C# assembly reference with attributed
   methods (or IL-based test)\n   - Verify priority values are correctly extracted\n\nThe
   pre-filter isn't added yet - just attribute reading infrastructure.", "dod": ["Build succeeds
   with 0 errors", "MethInfo.GetOverloadResolutionPriority() returns correct priority values from
   IL methods", "Returns 0 for methods without the attribute", "Returns 0 for F#-defined methods
   (attribute not commonly used in F#)", "Test verifies attribute reading works with BCL or test
   assembly"]}, {"id": 3, "name": "Pre-Filter Algorithm", "description": "SPRINT 3: Implement the
   priority pre-filter in ConstraintSolver.fs.\n\nIn `GetMostApplicableOverload` function (line
   ~3646):\n\n1. After `applicableMeths` is defined, add priority filtering:\n

Fixed:
{"overview": "Implement OverloadResolutionPriorityAttribute support using TDD: tests first, then\n    infrastructure (LanguageFeature, attribute reading), then the pre-filter algorithm in\n   ConstraintSolver that groups candidates by declaring type and keeps only highest-priority per\n   group. Each sprint produces a buildable, testable increment.", "subtasks": [{"id": 1, "name":    "Foundation: Feature + Tests", "description": "SPRINT 1: Add\n   LanguageFeature.OverloadResolutionPriority and write comprehensive failing tests.\n\n1. Add\n   `LanguageFeature.OverloadResolutionPriority` to LanguageFeatures.fs (both .fs and .fsi if\n   needed)\n2. Map it to F# 10.0 (languageVersion100) in the features dictionary\n3. Add feature\n   string to FSComp.txt: `featureOverloadResolutionPriority,\"Support\n   OverloadResolutionPriorityAttribute for explicit overload prioritization.\"`\n4. Add\n   GetFeatureString mapping in LanguageFeatures.fs\n5. Create new test file `tests/FSharp.Compiler.\n   ComponentTests/Conformance/Tiebreakers/OverloadResolutionPriorityTests.fs`\n6. Write failing\n   tests covering: basic priority selection (higher wins), negative priority (deprecation pattern),\n    interaction with concreteness (priority overrides concreteness), extension method grouping,\n   error on override\n\nFollow existing TiebreakerTests.fs patterns. Tests should fail because\n   attribute isn't recognized yet. Build must succeed.", "dod": ["Build succeeds with 0 errors",    "New LanguageFeature.OverloadResolutionPriority exists and maps to F# 10.0", "New test file\n   compiles with at least 8 test cases covering RFC examples", "Tests are discoverable by test\n   runner (run `dotnet test --list-tests` to verify)", "No code duplication - reuse\n   shouldCompile/shouldFailWithAmbiguity helpers from TiebreakerTests"]}, {"id": 2, "name":    "Attribute Reading", "description": "SPRINT 2: Add GetOverloadResolutionPriority() method to\n   MethInfo type.\n\n1. In `src/Compiler/Checking/infos.fs`, add member to MethInfo:\n   - `member\n   GetOverloadResolutionPriority: unit -> int`\n   - For ILMeth: scan CustomAttrs for\n   OverloadResolutionPriorityAttribute, extract Int32 argument\n   - For FSMeth: scan Attribs for\n   the attribute (if F#-defined)\n   - Return 0 for all other cases or when attribute not found\n\n    - Handle MethInfoWithModifiedReturnType by delegating\n\n2. Add signature to\n   `src/Compiler/Checking/infos.fsi`\n\n3. Write unit test in OverloadResolutionPriorityTests.fs\n   that verifies attribute reading works:\n   - Create C# assembly reference with attributed\n   methods (or IL-based test)\n   - Verify priority values are correctly extracted\n\nThe\n   pre-filter isn't added yet - just attribute reading infrastructure.", "dod": ["Build succeeds\n   with 0 errors", "MethInfo.GetOverloadResolutionPriority() returns correct priority values from\n   IL methods", "Returns 0 for methods without the attribute", "Returns 0 for F#-defined methods\n   (attribute not commonly used in F#)", "Test verifies attribute reading works with BCL or test\n   assembly"]}, {"id": 3, "name": "Pre-Filter Algorithm", "description": "SPRINT 3: Implement the\n   priority pre-filter in ConstraintSolver.fs.\n\nIn `GetMostApplicableOverload` function (line\n   ~3646):\n\n1. After `applicableMeths` is defined, add priority filtering:\n

Trimmed:
{"overview": "Implement OverloadResolutionPriorityAttribute support using TDD: tests first, then\n    infrastructure (LanguageFeature, attribute reading), then the pre-filter algorithm in\n   ConstraintSolver that groups candidates by declaring type and keeps only highest-priority per\n   group. Each sprint produces a buildable, testable increment.", "subtasks": [{"id": 1, "name":    "Foundation: Feature + Tests", "description": "SPRINT 1: Add\n   LanguageFeature.OverloadResolutionPriority and write comprehensive failing tests.\n\n1. Add\n   `LanguageFeature.OverloadResolutionPriority` to LanguageFeatures.fs (both .fs and .fsi if\n   needed)\n2. Map it to F# 10.0 (languageVersion100) in the features dictionary\n3. Add feature\n   string to FSComp.txt: `featureOverloadResolutionPriority,\"Support\n   OverloadResolutionPriorityAttribute for explicit overload prioritization.\"`\n4. Add\n   GetFeatureString mapping in LanguageFeatures.fs\n5. Create new test file `tests/FSharp.Compiler.\n   ComponentTests/Conformance/Tiebreakers/OverloadResolutionPriorityTests.fs`\n6. Write failing\n   tests covering: basic priority selection (higher wins), negative priority (deprecation pattern),\n    interaction with concreteness (priority overrides concreteness), extension method grouping,\n   error on override\n\nFollow existing TiebreakerTests.fs patterns. Tests should fail because\n   attribute isn't recognized yet. Build must succeed.", "dod": ["Build succeeds with 0 errors",    "New LanguageFeature.OverloadResolutionPriority exists and maps to F# 10.0", "New test file\n   compiles with at least 8 test cases covering RFC examples", "Tests are discoverable by test\n   runner (run `dotnet test --list-tests` to verify)", "No code duplication - reuse\n   shouldCompile/shouldFailWithAmbiguity helpers from TiebreakerTests"]}, {"id": 2, "name":    "Attribute Reading", "description": "SPRINT 2: Add GetOverloadResolutionPriority() method to\n   MethInfo type.\n\n1. In `src/Compiler/Checking/infos.fs`, add member to MethInfo:\n   - `member\n   GetOverloadResolutionPriority: unit -> int`\n   - For ILMeth: scan CustomAttrs for\n   OverloadResolutionPriorityAttribute, extract Int32 argument\n   - For FSMeth: scan Attribs for\n   the attribute (if F#-defined)\n   - Return 0 for all other cases or when attribute not found\n\n    - Handle MethInfoWithModifiedReturnType by delegating\n\n2. Add signature to\n   `src/Compiler/Checking/infos.fsi`\n\n3. Write unit test in OverloadResolutionPriorityTests.fs\n   that verifies attribute reading works:\n   - Create C# assembly reference with attributed\n   methods (or IL-based test)\n   - Verify priority values are correctly extracted\n\nThe\n   pre-filter isn't added yet - just attribute reading infrastructure.", "dod": ["Build succeeds\n   with 0 errors", "MethInfo.GetOverloadResolutionPriority() returns correct priority values from\n   IL methods", "Returns 0 for methods without the attribute", "Returns 0 for F#-defined methods\n   (attribute not commonly used in F#)", "Test verifies attribute reading works with BCL or test\n   assembly"]}, {"id": 3, "name": "Pre-Filter Algorithm", "description": "SPRINT 3: Implement the\n   priority pre-filter in ConstraintSolver.fs.\n\nIn `GetMostApplicableOverload` function (line\n   ~3646):\n\n1. After `applicableMeths` is defined, add priority filtering:\n"}}]