<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema 

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple 
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="undefinedNameNamespace" xml:space="preserve">
    <value>The namespace '{0}' is not defined.</value>
  </data>
  <data name="undefinedNameNamespaceOrModule" xml:space="preserve">
    <value>The namespace or module '{0}' is not defined.</value>
  </data>
  <data name="undefinedNameFieldConstructorOrMember" xml:space="preserve">
    <value>The field, constructor or member '{0}' is not defined.</value>
  </data>
  <data name="undefinedNameValueConstructorNamespaceOrType" xml:space="preserve">
    <value>The value, constructor, namespace or type '{0}' is not defined.</value>
  </data>
  <data name="undefinedNameValueOfConstructor" xml:space="preserve">
    <value>The value or constructor '{0}' is not defined.</value>
  </data>
  <data name="undefinedNameValueNamespaceTypeOrModule" xml:space="preserve">
    <value>The value, namespace, type or module '{0}' is not defined.</value>
  </data>
  <data name="undefinedNameConstructorModuleOrNamespace" xml:space="preserve">
    <value>The constructor, module or namespace '{0}' is not defined.</value>
  </data>
  <data name="undefinedNameType" xml:space="preserve">
    <value>The type '{0}' is not defined.</value>
  </data>
  <data name="undefinedNameTypeIn" xml:space="preserve">
    <value>The type '{0}' is not defined in '{1}'.</value>
  </data>
  <data name="undefinedNameRecordLabelOrNamespace" xml:space="preserve">
    <value>The record label or namespace '{0}' is not defined.</value>
  </data>
  <data name="undefinedNameRecordLabel" xml:space="preserve">
    <value>The record label '{0}' is not defined.</value>
  </data>
  <data name="undefinedNameSuggestionsIntro" xml:space="preserve">
    <value>Maybe you want one of the following:</value>
  </data>
  <data name="undefinedNameTypeParameter" xml:space="preserve">
    <value>The type parameter {0} is not defined.</value>
  </data>
  <data name="undefinedNamePatternDiscriminator" xml:space="preserve">
    <value>The pattern discriminator '{0}' is not defined.</value>
  </data>
  <data name="replaceWithSuggestion" xml:space="preserve">
    <value>Replace with '{0}'</value>
  </data>
  <data name="addIndexerDot" xml:space="preserve">
    <value>Add . for indexer access.</value>
  </data>
  <data name="listElementHasWrongType" xml:space="preserve">
    <value>All elements of a list constructor expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</value>
  </data>
  <data name="arrayElementHasWrongType" xml:space="preserve">
    <value>All elements of an array constructor expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</value>
  </data>
  <data name="missingElseBranch" xml:space="preserve">
    <value>The 'if' expression is missing an 'else' branch. The 'then' branch has type '{0}'. Because 'if' is an expression, and not a statement, add an 'else' branch which returns a value of the same type.</value>
  </data>
  <data name="ifExpression" xml:space="preserve">
    <value>The 'if' expression needs to have type '{0}' to satisfy context type requirements. It currently has type '{1}'.</value>
  </data>
  <data name="elseBranchHasWrongType" xml:space="preserve">
    <value>All branches of an 'if' expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</value>
  </data>
  <data name="followingPatternMatchClauseHasWrongType" xml:space="preserve">
    <value>All branches of a pattern match expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</value>
  </data>
  <data name="patternMatchGuardIsNotBool" xml:space="preserve">
    <value>A pattern match guard must be of type 'bool', but this 'when' expression is of type '{0}'.</value>
  </data>
  <data name="commaInsteadOfSemicolonInRecord" xml:space="preserve">
    <value>A ';' is used to separate field values in records. Consider replacing ',' with ';'.</value>
  </data>
  <data name="derefInsteadOfNot" xml:space="preserve">
    <value>The '!' operator is used to dereference a ref cell. Consider using 'not expr' here.</value>
  </data>
  <data name="buildUnexpectedTypeArgs" xml:space="preserve">
    <value>The non-generic type '{0}' does not expect any type arguments, but here is given {1} type argument(s)</value>
  </data>
  <data name="returnUsedInsteadOfReturnBang" xml:space="preserve">
    <value>Consider using 'return!' instead of 'return'.</value>
  </data>
  <data name="yieldUsedInsteadOfYieldBang" xml:space="preserve">
    <value>Consider using 'yield!' instead of 'yield'.</value>
  </data>
  <data name="tupleRequiredInAbstractMethod" xml:space="preserve">
    <value>\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.</value>
  </data>
  <data name="buildInvalidWarningNumber" xml:space="preserve">
    <value>Invalid warning number '{0}'</value>
  </data>
  <data name="buildInvalidVersionString" xml:space="preserve">
    <value>Invalid version string '{0}'</value>
  </data>
  <data name="buildInvalidVersionFile" xml:space="preserve">
    <value>Invalid version file '{0}'</value>
  </data>
  <data name="buildProductName" xml:space="preserve">
    <value>Microsoft (R) F# Compiler version {0}</value>
  </data>
  <data name="buildProductNameCommunity" xml:space="preserve">
    <value>F# Compiler for F# {0}</value>
  </data>
  <data name="buildProblemWithFilename" xml:space="preserve">
    <value>Problem with filename '{0}': {1}</value>
  </data>
  <data name="buildNoInputsSpecified" xml:space="preserve">
    <value>No inputs specified</value>
  </data>
  <data name="buildPdbRequiresDebug" xml:space="preserve">
    <value>The '--pdb' option requires the '--debug' option to be used</value>
  </data>
  <data name="buildInvalidSearchDirectory" xml:space="preserve">
    <value>The search directory '{0}' is invalid</value>
  </data>
  <data name="buildSearchDirectoryNotFound" xml:space="preserve">
    <value>The search directory '{0}' could not be found</value>
  </data>
  <data name="buildInvalidFilename" xml:space="preserve">
    <value>'{0}' is not a valid filename</value>
  </data>
  <data name="buildInvalidAssemblyName" xml:space="preserve">
    <value>'{0}' is not a valid assembly name</value>
  </data>
  <data name="buildInvalidPrivacy" xml:space="preserve">
    <value>Unrecognized privacy setting '{0}' for managed resource, valid options are 'public' and 'private'</value>
  </data>
  <data name="buildMultipleReferencesNotAllowed" xml:space="preserve">
    <value>Multiple references to '{0}.dll' are not permitted</value>
  </data>
  <data name="buildCouldNotReadVersionInfoFromMscorlib" xml:space="preserve">
    <value>Could not read version from mscorlib.dll</value>
  </data>
  <data name="buildCannotReadAssembly" xml:space="preserve">
    <value>Unable to read assembly '{0}'</value>
  </data>
  <data name="buildAssemblyResolutionFailed" xml:space="preserve">
    <value>Assembly resolution failure at or near this location</value>
  </data>
  <data name="buildImplicitModuleIsNotLegalIdentifier" xml:space="preserve">
    <value>The declarations in this file will be placed in an implicit module '{0}' based on the file name '{1}'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file.</value>
  </data>
  <data name="buildMultiFileRequiresNamespaceOrModule" xml:space="preserve">
    <value>Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration.</value>
  </data>
  <data name="noEqualSignAfterModule" xml:space="preserve">
    <value>Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.</value>
  </data>
  <data name="buildMultipleToplevelModules" xml:space="preserve">
    <value>This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules.</value>
  </data>
  <data name="buildOptionRequiresParameter" xml:space="preserve">
    <value>Option requires parameter: {0}</value>
  </data>
  <data name="buildCouldNotFindSourceFile" xml:space="preserve">
    <value>Source file '{0}' could not be found</value>
  </data>
  <data name="buildInvalidSourceFileExtension" xml:space="preserve">
    <value>The file extension of '{0}' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.</value>
  </data>
  <data name="buildCouldNotResolveAssembly" xml:space="preserve">
    <value>Could not resolve assembly '{0}'</value>
  </data>
  <data name="buildCouldNotResolveAssemblyRequiredByFile" xml:space="preserve">
    <value>Could not resolve assembly '{0}' required by '{1}'</value>
  </data>
  <data name="buildErrorOpeningBinaryFile" xml:space="preserve">
    <value>Error opening binary file '{0}': {1}</value>
  </data>
  <data name="buildDifferentVersionMustRecompile" xml:space="preserve">
    <value>The F#-compiled DLL '{0}' needs to be recompiled to be used with this version of F#</value>
  </data>
  <data name="buildInvalidHashIDirective" xml:space="preserve">
    <value>Invalid directive. Expected '#I \"&lt;path&gt;\"'.</value>
  </data>
  <data name="buildInvalidHashrDirective" xml:space="preserve">
    <value>Invalid directive. Expected '#r \"&lt;file-or-assembly&gt;\"'.</value>
  </data>
  <data name="buildInvalidHashloadDirective" xml:space="preserve">
    <value>Invalid directive. Expected '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</value>
  </data>
  <data name="buildInvalidHashtimeDirective" xml:space="preserve">
    <value>Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'.</value>
  </data>
  <data name="buildDirectivesInModulesAreIgnored" xml:space="preserve">
    <value>Directives inside modules are ignored</value>
  </data>
  <data name="buildSignatureAlreadySpecified" xml:space="preserve">
    <value>A signature for the file or module '{0}' has already been specified</value>
  </data>
  <data name="buildImplementationAlreadyGivenDetail" xml:space="preserve">
    <value>An implementation of file or module '{0}' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.</value>
  </data>
  <data name="buildImplementationAlreadyGiven" xml:space="preserve">
    <value>An implementation of the file or module '{0}' has already been given</value>
  </data>
  <data name="buildSignatureWithoutImplementation" xml:space="preserve">
    <value>The signature file '{0}' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match.</value>
  </data>
  <data name="buildArgInvalidInt" xml:space="preserve">
    <value>'{0}' is not a valid integer argument</value>
  </data>
  <data name="buildArgInvalidFloat" xml:space="preserve">
    <value>'{0}' is not a valid floating point argument</value>
  </data>
  <data name="buildUnrecognizedOption" xml:space="preserve">
    <value>Unrecognized option: '{0}'</value>
  </data>
  <data name="buildInvalidModuleOrNamespaceName" xml:space="preserve">
    <value>Invalid module or namespace name</value>
  </data>
  <data name="pickleErrorReadingWritingMetadata" xml:space="preserve">
    <value>Error reading/writing metadata for the F# compiled DLL '{0}'. Was the DLL compiled with an earlier version of the F# compiler? (error: '{1}').</value>
  </data>
  <data name="tastTypeOrModuleNotConcrete" xml:space="preserve">
    <value>The type/module '{0}' is not a concrete module or type</value>
  </data>
  <data name="tastTypeHasAssemblyCodeRepresentation" xml:space="preserve">
    <value>The type '{0}' has an inline assembly code representation</value>
  </data>
  <data name="tastNamespaceAndModuleWithSameNameInAssembly" xml:space="preserve">
    <value>A namespace and a module named '{0}' both occur in two parts of this assembly</value>
  </data>
  <data name="tastTwoModulesWithSameNameInAssembly" xml:space="preserve">
    <value>Two modules named '{0}' occur in two parts of this assembly</value>
  </data>
  <data name="tastDuplicateTypeDefinitionInAssembly" xml:space="preserve">
    <value>Two type definitions named '{0}' occur in namespace '{1}' in two parts of this assembly</value>
  </data>
  <data name="tastConflictingModuleAndTypeDefinitionInAssembly" xml:space="preserve">
    <value>A module and a type definition named '{0}' occur in namespace '{1}' in two parts of this assembly</value>
  </data>
  <data name="tastInvalidMemberSignature" xml:space="preserve">
    <value>Invalid member signature encountered because of an earlier error</value>
  </data>
  <data name="tastValueDoesNotHaveSetterType" xml:space="preserve">
    <value>This value does not have a valid property setter type</value>
  </data>
  <data name="tastInvalidFormForPropertyGetter" xml:space="preserve">
    <value>Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax.</value>
  </data>
  <data name="tastInvalidFormForPropertySetter" xml:space="preserve">
    <value>Invalid form for a property setter. At least one argument is required.</value>
  </data>
  <data name="tastUnexpectedByRef" xml:space="preserve">
    <value>Unexpected use of a byref-typed variable</value>
  </data>
  <data name="tastValueMustBeMutable" xml:space="preserve">
    <value>A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'</value>
  </data>
  <data name="tastInvalidMutationOfConstant" xml:space="preserve">
    <value>Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'.</value>
  </data>
  <data name="tastValueHasBeenCopied" xml:space="preserve">
    <value>The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeInConstructionOfTuple" xml:space="preserve">
    <value>Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding</value>
  </data>
  <data name="tastRecursiveValuesMayNotAppearInConstructionOfType" xml:space="preserve">
    <value>Recursive values cannot appear directly as a construction of the type '{0}' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeAssignedToNonMutableField" xml:space="preserve">
    <value>Recursive values cannot be directly assigned to the non-mutable field '{0}' of the type '{1}' within a recursive binding. Consider using a mutable field instead.</value>
  </data>
  <data name="tastUnexpectedDecodeOfAutoOpenAttribute" xml:space="preserve">
    <value>Unexpected decode of AutoOpenAttribute</value>
  </data>
  <data name="tastUnexpectedDecodeOfInternalsVisibleToAttribute" xml:space="preserve">
    <value>Unexpected decode of InternalsVisibleToAttribute</value>
  </data>
  <data name="tastUnexpectedDecodeOfInterfaceDataVersionAttribute" xml:space="preserve">
    <value>Unexpected decode of InterfaceDataVersionAttribute</value>
  </data>
  <data name="tastActivePatternsLimitedToSeven" xml:space="preserve">
    <value>Active patterns cannot return more than 7 possibilities</value>
  </data>
  <data name="tastNotAConstantExpression" xml:space="preserve">
    <value>This is not a valid constant expression or custom attribute value</value>
  </data>
  <data name="ValueNotContainedMutabilityAttributesDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe mutability attributes differ</value>
  </data>
  <data name="ValueNotContainedMutabilityNamesDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe names differ</value>
  </data>
  <data name="ValueNotContainedMutabilityCompiledNamesDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled names differ</value>
  </data>
  <data name="ValueNotContainedMutabilityDisplayNamesDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe display names differ</value>
  </data>
  <data name="ValueNotContainedMutabilityAccessibilityMore" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe accessibility specified in the signature is more than that specified in the implementation</value>
  </data>
  <data name="ValueNotContainedMutabilityInlineFlagsDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe inline flags differ</value>
  </data>
  <data name="ValueNotContainedMutabilityLiteralConstantValuesDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe literal constant values and/or attributes differ</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsTypeFunction" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.</value>
  </data>
  <data name="ValueNotContainedMutabilityParameterCountsDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe respective type parameter counts differ</value>
  </data>
  <data name="ValueNotContainedMutabilityTypesDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe types differ</value>
  </data>
  <data name="ValueNotContainedMutabilityExtensionsDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is an extension member and the other is not</value>
  </data>
  <data name="ValueNotContainedMutabilityArityNotInferred" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nAn arity was not inferred for this value</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe number of generic parameters in the signature and implementation differ (the signature declares {3} but the implementation declares {4}</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersAreDifferentKinds" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.</value>
  </data>
  <data name="ValueNotContainedMutabilityAritiesDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe arities in the signature and implementation differ. The signature specifies that '{3}' is function definition or lambda expression accepting at least {4} argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int.</value>
  </data>
  <data name="ValueNotContainedMutabilityDotNetNamesDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe CLI member names differ</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticsDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is static and the other isn't</value>
  </data>
  <data name="ValueNotContainedMutabilityVirtualsDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is virtual and the other isn't</value>
  </data>
  <data name="ValueNotContainedMutabilityAbstractsDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is abstract and the other isn't</value>
  </data>
  <data name="ValueNotContainedMutabilityFinalsDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is final and the other isn't</value>
  </data>
  <data name="ValueNotContainedMutabilityOverridesDiffer" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is marked as an override and the other isn't</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsConstructor" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a constructor/property and the other is not</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticButInstance" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member</value>
  </data>
  <data name="ValueNotContainedMutabilityInstanceButStatic" xml:space="preserve">
    <value>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNamesDiffer" xml:space="preserve">
    <value>The {0} definitions in the signature and implementation are not compatible because the names differ. The type is called '{1}' in the signature file but '{2}' in implementation.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the respective type parameter counts differ</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleMissingInterface" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature requires that the type supports the interface {2} but the interface has not been implemented</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSealed" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types have different base types</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNumbersDiffer" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the number of {2}s differ</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature defines the {2} '{3}' but the implementation does not (or does, but not in the same order)</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines the {2} '{3}' but the signature does not (or does, but not in the same order)</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsHidden" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a type representation is being hidden by a signature</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types are of different kinds</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleILDiffer" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the IL representations differ</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the representations differ</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldWasPresent" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was present in the implementation but not in the signature</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was required by the signature but was not specified by the implementation</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field '{2}' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was required by the signature but was not specified by the implementation</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was present in the implementation but not in the signature</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature declares a {2} while the implementation declares a {3}</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abbreviations differ: {2} versus {3}</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation" xml:space="preserve">
    <value>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not</value>
  </data>
  <data name="ModuleContainsConstructorButNamesDiffer" xml:space="preserve">
    <value>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</value>
  </data>
  <data name="ModuleContainsConstructorButDataFieldsDiffer" xml:space="preserve">
    <value>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe respective number of data fields differ</value>
  </data>
  <data name="ModuleContainsConstructorButTypesOfFieldsDiffer" xml:space="preserve">
    <value>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe types of the fields differ</value>
  </data>
  <data name="ModuleContainsConstructorButAccessibilityDiffers" xml:space="preserve">
    <value>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</value>
  </data>
  <data name="FieldNotContainedNamesDiffer" xml:space="preserve">
    <value>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</value>
  </data>
  <data name="FieldNotContainedAccessibilitiesDiffer" xml:space="preserve">
    <value>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</value>
  </data>
  <data name="FieldNotContainedStaticsDiffer" xml:space="preserve">
    <value>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'static' modifiers differ</value>
  </data>
  <data name="FieldNotContainedMutablesDiffer" xml:space="preserve">
    <value>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'mutable' modifiers differ</value>
  </data>
  <data name="FieldNotContainedLiteralsDiffer" xml:space="preserve">
    <value>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'literal' modifiers differ</value>
  </data>
  <data name="FieldNotContainedTypesDiffer" xml:space="preserve">
    <value>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe types differ</value>
  </data>
  <data name="typrelCannotResolveImplicitGenericInstantiation" xml:space="preserve">
    <value>The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '{0}' and '{1}'. Consider using type annotations to resolve the ambiguity</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInPrintf" xml:space="preserve">
    <value>Could not resolve the ambiguity inherent in the use of a 'printf'-style format string</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInEnum" xml:space="preserve">
    <value>Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInDelegate" xml:space="preserve">
    <value>Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position</value>
  </data>
  <data name="typrelInvalidValue" xml:space="preserve">
    <value>Invalid value</value>
  </data>
  <data name="typrelSigImplNotCompatibleParamCountsDiffer" xml:space="preserve">
    <value>The signature and implementation are not compatible because the respective type parameter counts differ</value>
  </data>
  <data name="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer" xml:space="preserve">
    <value>The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDiffer" xml:space="preserve">
    <value>The signature and implementation are not compatible because the declaration of the type parameter '{0}' requires a constraint of the form {1}</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDifferRemove" xml:space="preserve">
    <value>The signature and implementation are not compatible because the type parameter '{0}' has a constraint of the form {1} but the implementation does not. Either remove this constraint from the signature or add it to the implementation.</value>
  </data>
  <data name="typrelTypeImplementsIComparableShouldOverrideObjectEquals" xml:space="preserve">
    <value>The type '{0}' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'</value>
  </data>
  <data name="typrelTypeImplementsIComparableDefaultObjectEqualsProvided" xml:space="preserve">
    <value>The type '{0}' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCodeOrEquals" xml:space="preserve">
    <value>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCode" xml:space="preserve">
    <value>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'</value>
  </data>
  <data name="typrelExplicitImplementationOfEquals" xml:space="preserve">
    <value>The struct, record or union type '{0}' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'</value>
  </data>
  <data name="ExceptionDefsNotCompatibleHiddenBySignature" xml:space="preserve">
    <value>The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</value>
  </data>
  <data name="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer" xml:space="preserve">
    <value>The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</value>
  </data>
  <data name="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature" xml:space="preserve">
    <value>The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleSignaturesDiffer" xml:space="preserve">
    <value>The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer" xml:space="preserve">
    <value>The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInSigButNotImpl" xml:space="preserve">
    <value>The exception definitions are not compatible because the field '{0}' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInImplButNotSig" xml:space="preserve">
    <value>The exception definitions are not compatible because the field '{0}' was present in the implementation but not in the signature. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldOrderDiffers" xml:space="preserve">
    <value>The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</value>
  </data>
  <data name="typrelModuleNamespaceAttributesDifferInSigAndImpl" xml:space="preserve">
    <value>The namespace or module attributes differ between signature and implementation</value>
  </data>
  <data name="typrelMethodIsOverconstrained" xml:space="preserve">
    <value>This method is over-constrained in its type parameters</value>
  </data>
  <data name="typrelOverloadNotFound" xml:space="preserve">
    <value>No implementations of '{0}' had the correct number of arguments and type parameters. The required signature is '{1}'.</value>
  </data>
  <data name="typrelOverrideWasAmbiguous" xml:space="preserve">
    <value>The override for '{0}' was ambiguous</value>
  </data>
  <data name="typrelMoreThenOneOverride" xml:space="preserve">
    <value>More than one override implements '{0}'</value>
  </data>
  <data name="typrelMethodIsSealed" xml:space="preserve">
    <value>The method '{0}' is sealed and cannot be overridden</value>
  </data>
  <data name="typrelOverrideImplementsMoreThenOneSlot" xml:space="preserve">
    <value>The override '{0}' implements more than one abstract slot, e.g. '{1}' and '{2}'</value>
  </data>
  <data name="typrelDuplicateInterface" xml:space="preserve">
    <value>Duplicate or redundant interface</value>
  </data>
  <data name="typrelNeedExplicitImplementation" xml:space="preserve">
    <value>The interface '{0}' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.</value>
  </data>
  <data name="typrelNamedArgumentHasBeenAssignedMoreThenOnce" xml:space="preserve">
    <value>A named argument has been assigned more than one value</value>
  </data>
  <data name="typrelNoImplementationGiven" xml:space="preserve">
    <value>No implementation was given for '{0}'</value>
  </data>
  <data name="typrelNoImplementationGivenWithSuggestion" xml:space="preserve">
    <value>No implementation was given for '{0}'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfArguments" xml:space="preserve">
    <value>The member '{0}' does not have the correct number of arguments. The required signature is '{1}'.</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters" xml:space="preserve">
    <value>The member '{0}' does not have the correct number of method type parameters. The required signature is '{1}'.</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters" xml:space="preserve">
    <value>The member '{0}' does not have the correct kinds of generic parameters. The required signature is '{1}'.</value>
  </data>
  <data name="typrelMemberCannotImplement" xml:space="preserve">
    <value>The member '{0}' cannot be used to implement '{1}'. The required signature is '{2}'.</value>
  </data>
  <data name="astParseEmbeddedILError" xml:space="preserve">
    <value>Error while parsing embedded IL</value>
  </data>
  <data name="astParseEmbeddedILTypeError" xml:space="preserve">
    <value>Error while parsing embedded IL type</value>
  </data>
  <data name="astDeprecatedIndexerNotation" xml:space="preserve">
    <value>This indexer notation has been removed from the F# language</value>
  </data>
  <data name="astInvalidExprLeftHandOfAssignment" xml:space="preserve">
    <value>Invalid expression on left of assignment</value>
  </data>
  <data name="augNoRefEqualsOnStruct" xml:space="preserve">
    <value>The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'.</value>
  </data>
  <data name="augInvalidAttrs" xml:space="preserve">
    <value>This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'</value>
  </data>
  <data name="augNoEqualityNeedsNoComparison" xml:space="preserve">
    <value>The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute</value>
  </data>
  <data name="augStructCompNeedsStructEquality" xml:space="preserve">
    <value>The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute</value>
  </data>
  <data name="augStructEqNeedsNoCompOrStructComp" xml:space="preserve">
    <value>The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes</value>
  </data>
  <data name="augTypeCantHaveRefEqAndStructAttrs" xml:space="preserve">
    <value>A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes</value>
  </data>
  <data name="augOnlyCertainTypesCanHaveAttrs" xml:space="preserve">
    <value>Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes</value>
  </data>
  <data name="augRefEqCantHaveObjEquals" xml:space="preserve">
    <value>A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</value>
  </data>
  <data name="augCustomEqNeedsObjEquals" xml:space="preserve">
    <value>A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</value>
  </data>
  <data name="augCustomCompareNeedsIComp" xml:space="preserve">
    <value>A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'</value>
  </data>
  <data name="augNoEqNeedsNoObjEquals" xml:space="preserve">
    <value>A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes</value>
  </data>
  <data name="augNoCompCantImpIComp" xml:space="preserve">
    <value>A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable&lt;_&gt;' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes</value>
  </data>
  <data name="augCustomEqNeedsNoCompOrCustomComp" xml:space="preserve">
    <value>The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes</value>
  </data>
  <data name="forPositionalSpecifiersNotPermitted" xml:space="preserve">
    <value>Positional specifiers are not permitted in format strings</value>
  </data>
  <data name="forMissingFormatSpecifier" xml:space="preserve">
    <value>Missing format specifier</value>
  </data>
  <data name="forFlagSetTwice" xml:space="preserve">
    <value>'{0}' flag set twice</value>
  </data>
  <data name="forPrefixFlagSpacePlusSetTwice" xml:space="preserve">
    <value>Prefix flag (' ' or '+') set twice</value>
  </data>
  <data name="forHashSpecifierIsInvalid" xml:space="preserve">
    <value>The # formatting modifier is invalid in F#</value>
  </data>
  <data name="forBadPrecision" xml:space="preserve">
    <value>Bad precision in format specifier</value>
  </data>
  <data name="forBadWidth" xml:space="preserve">
    <value>Bad width in format specifier</value>
  </data>
  <data name="forDoesNotSupportZeroFlag" xml:space="preserve">
    <value>'{0}' format does not support '0' flag</value>
  </data>
  <data name="forPrecisionMissingAfterDot" xml:space="preserve">
    <value>Precision missing after the '.'</value>
  </data>
  <data name="forFormatDoesntSupportPrecision" xml:space="preserve">
    <value>'{0}' format does not support precision</value>
  </data>
  <data name="forBadFormatSpecifier" xml:space="preserve">
    <value>Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</value>
  </data>
  <data name="forLIsUnnecessary" xml:space="preserve">
    <value>The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</value>
  </data>
  <data name="forHIsUnnecessary" xml:space="preserve">
    <value>The 'h' or 'H' in this format specifier is unnecessary. You can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</value>
  </data>
  <data name="forDoesNotSupportPrefixFlag" xml:space="preserve">
    <value>'{0}' does not support prefix '{1}' flag</value>
  </data>
  <data name="forBadFormatSpecifierGeneral" xml:space="preserve">
    <value>Bad format specifier: '{0}'</value>
  </data>
  <data name="elSysEnvExitDidntExit" xml:space="preserve">
    <value>System.Environment.Exit did not exit</value>
  </data>
  <data name="elDeprecatedOperator" xml:space="preserve">
    <value>The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined</value>
  </data>
  <data name="chkProtectedOrBaseCalled" xml:space="preserve">
    <value>A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope.</value>
  </data>
  <data name="chkByrefUsedInInvalidWay" xml:space="preserve">
    <value>The byref-typed variable '{0}' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.</value>
  </data>
  <data name="chkBaseUsedInInvalidWay" xml:space="preserve">
    <value>The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.</value>
  </data>
  <data name="chkVariableUsedInInvalidWay" xml:space="preserve">
    <value>The variable '{0}' is used in an invalid way</value>
  </data>
  <data name="chkTypeLessAccessibleThanType" xml:space="preserve">
    <value>The type '{0}' is less accessible than the value, member or type '{1}' it is used in.</value>
  </data>
  <data name="chkSystemVoidOnlyInTypeof" xml:space="preserve">
    <value>'System.Void' can only be used as 'typeof&lt;System.Void&gt;' in F#</value>
  </data>
  <data name="chkErrorUseOfByref" xml:space="preserve">
    <value>A type instantiation involves a byref type. This is not permitted by the rules of Common IL.</value>
  </data>
  <data name="chkErrorContainsCallToRethrow" xml:space="preserve">
    <value>Calls to 'reraise' may only occur directly in a handler of a try-with</value>
  </data>
  <data name="chkSplicingOnlyInQuotations" xml:space="preserve">
    <value>Expression-splicing operators may only be used within quotations</value>
  </data>
  <data name="chkNoFirstClassSplicing" xml:space="preserve">
    <value>First-class uses of the expression-splicing operator are not permitted</value>
  </data>
  <data name="chkNoFirstClassAddressOf" xml:space="preserve">
    <value>First-class uses of the address-of operators are not permitted</value>
  </data>
  <data name="chkNoFirstClassRethrow" xml:space="preserve">
    <value>First-class uses of the 'reraise' function is not permitted</value>
  </data>
  <data name="chkNoByrefAtThisPoint" xml:space="preserve">
    <value>The byref typed value '{0}' cannot be used at this point</value>
  </data>
  <data name="chkLimitationsOfBaseKeyword" xml:space="preserve">
    <value>'base' values may only be used to make direct calls to the base implementations of overridden members</value>
  </data>
  <data name="chkObjCtorsCantUseExceptionHandling" xml:space="preserve">
    <value>Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.</value>
  </data>
  <data name="chkNoAddressOfAtThisPoint" xml:space="preserve">
    <value>The address of the variable '{0}' cannot be used at this point</value>
  </data>
  <data name="chkNoAddressStaticFieldAtThisPoint" xml:space="preserve">
    <value>The address of the static field '{0}' cannot be used at this point</value>
  </data>
  <data name="chkNoAddressFieldAtThisPoint" xml:space="preserve">
    <value>The address of the field '{0}' cannot be used at this point</value>
  </data>
  <data name="chkNoAddressOfArrayElementAtThisPoint" xml:space="preserve">
    <value>The address of an array element cannot be used at this point</value>
  </data>
  <data name="chkFirstClassFuncNoByref" xml:space="preserve">
    <value>The type of a first-class function cannot contain byrefs</value>
  </data>
  <data name="chkReturnTypeNoByref" xml:space="preserve">
    <value>A method return type would contain byrefs which is not permitted</value>
  </data>
  <data name="chkInvalidCustAttrVal" xml:space="preserve">
    <value>Invalid custom attribute value (not a constant or literal)</value>
  </data>
  <data name="chkAttrHasAllowMultiFalse" xml:space="preserve">
    <value>The attribute type '{0}' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element.</value>
  </data>
  <data name="chkMemberUsedInInvalidWay" xml:space="preserve">
    <value>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to its definition at or near '{2}'. This is an invalid forward reference.</value>
  </data>
  <data name="chkNoByrefAsTopValue" xml:space="preserve">
    <value>A byref typed value would be stored here. Top-level let-bound byref values are not permitted.</value>
  </data>
  <data name="chkReflectedDefCantSplice" xml:space="preserve">
    <value>[&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator '%'</value>
  </data>
  <data name="chkEntryPointUsage" xml:space="preserve">
    <value>A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence.</value>
  </data>
  <data name="chkUnionCaseCompiledForm" xml:space="preserve">
    <value>compiled form of the union case</value>
  </data>
  <data name="chkUnionCaseDefaultAugmentation" xml:space="preserve">
    <value>default augmentation of the union case</value>
  </data>
  <data name="chkPropertySameNameMethod" xml:space="preserve">
    <value>The property '{0}' has the same name as a method in type '{1}'.</value>
  </data>
  <data name="chkGetterSetterDoNotMatchAbstract" xml:space="preserve">
    <value>The property '{0}' of type '{1}' has a getter and a setter that do not match. If one is abstract then the other must be as well.</value>
  </data>
  <data name="chkPropertySameNameIndexer" xml:space="preserve">
    <value>The property '{0}' has the same name as another property in type '{1}', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.</value>
  </data>
  <data name="chkCantStoreByrefValue" xml:space="preserve">
    <value>A type would store a byref typed value. This is not permitted by Common IL.</value>
  </data>
  <data name="chkDuplicateMethod" xml:space="preserve">
    <value>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}'.</value>
  </data>
  <data name="chkDuplicateMethodWithSuffix" xml:space="preserve">
    <value>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</value>
  </data>
  <data name="chkDuplicateMethodCurried" xml:space="preserve">
    <value>The method '{0}' has curried arguments but has the same name as another method in type '{1}'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.</value>
  </data>
  <data name="chkCurriedMethodsCantHaveOutParams" xml:space="preserve">
    <value>Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments</value>
  </data>
  <data name="chkDuplicateProperty" xml:space="preserve">
    <value>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}'.</value>
  </data>
  <data name="chkDuplicatePropertyWithSuffix" xml:space="preserve">
    <value>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</value>
  </data>
  <data name="chkDuplicateMethodInheritedType" xml:space="preserve">
    <value>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type.</value>
  </data>
  <data name="chkDuplicateMethodInheritedTypeWithSuffix" xml:space="preserve">
    <value>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.</value>
  </data>
  <data name="chkMultipleGenericInterfaceInstantiations" xml:space="preserve">
    <value>This type implements the same interface at different generic instantiations '{0}' and '{1}'. This is not permitted in this version of F#.</value>
  </data>
  <data name="chkValueWithDefaultValueMustHaveDefaultValue" xml:space="preserve">
    <value>The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check</value>
  </data>
  <data name="chkNoByrefInTypeAbbrev" xml:space="preserve">
    <value>The type abbreviation contains byrefs. This is not permitted by F#.</value>
  </data>
  <data name="crefBoundVarUsedInSplice" xml:space="preserve">
    <value>The variable '{0}' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.</value>
  </data>
  <data name="crefQuotationsCantContainGenericExprs" xml:space="preserve">
    <value>Quotations cannot contain uses of generic expressions</value>
  </data>
  <data name="crefQuotationsCantContainGenericFunctions" xml:space="preserve">
    <value>Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.</value>
  </data>
  <data name="crefQuotationsCantContainObjExprs" xml:space="preserve">
    <value>Quotations cannot contain object expressions</value>
  </data>
  <data name="crefQuotationsCantContainAddressOf" xml:space="preserve">
    <value>Quotations cannot contain expressions that take the address of a field</value>
  </data>
  <data name="crefQuotationsCantContainStaticFieldRef" xml:space="preserve">
    <value>Quotations cannot contain expressions that fetch static fields</value>
  </data>
  <data name="crefQuotationsCantContainInlineIL" xml:space="preserve">
    <value>Quotations cannot contain inline assembly code or pattern matching on arrays</value>
  </data>
  <data name="crefQuotationsCantContainDescendingForLoops" xml:space="preserve">
    <value>Quotations cannot contain descending for loops</value>
  </data>
  <data name="crefQuotationsCantFetchUnionIndexes" xml:space="preserve">
    <value>Quotations cannot contain expressions that fetch union case indexes</value>
  </data>
  <data name="crefQuotationsCantSetUnionFields" xml:space="preserve">
    <value>Quotations cannot contain expressions that set union case fields</value>
  </data>
  <data name="crefQuotationsCantSetExceptionFields" xml:space="preserve">
    <value>Quotations cannot contain expressions that set fields in exception values</value>
  </data>
  <data name="crefQuotationsCantRequireByref" xml:space="preserve">
    <value>Quotations cannot contain expressions that require byref pointers</value>
  </data>
  <data name="crefQuotationsCantCallTraitMembers" xml:space="preserve">
    <value>Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call</value>
  </data>
  <data name="crefQuotationsCantContainThisConstant" xml:space="preserve">
    <value>Quotations cannot contain this kind of constant</value>
  </data>
  <data name="crefQuotationsCantContainThisPatternMatch" xml:space="preserve">
    <value>Quotations cannot contain this kind of pattern match</value>
  </data>
  <data name="crefQuotationsCantContainArrayPatternMatching" xml:space="preserve">
    <value>Quotations cannot contain array pattern matching</value>
  </data>
  <data name="crefQuotationsCantContainThisType" xml:space="preserve">
    <value>Quotations cannot contain this kind of type</value>
  </data>
  <data name="csTypeCannotBeResolvedAtCompileTime" xml:space="preserve">
    <value>The declared type parameter '{0}' cannot be used here since the type parameter cannot be resolved at compile time</value>
  </data>
  <data name="csCodeLessGeneric" xml:space="preserve">
    <value>This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'.</value>
  </data>
  <data name="csTypeInferenceMaxDepth" xml:space="preserve">
    <value>Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.</value>
  </data>
  <data name="csExpectedArguments" xml:space="preserve">
    <value>Expected arguments to an instance member</value>
  </data>
  <data name="csIndexArgumentMismatch" xml:space="preserve">
    <value>This indexer expects {0} arguments but is here given {1}</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenFunction" xml:space="preserve">
    <value>Expecting a type supporting the operator '{0}' but given a function type. You may be missing an argument to a function.</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenTuple" xml:space="preserve">
    <value>Expecting a type supporting the operator '{0}' but given a tuple type</value>
  </data>
  <data name="csTypesDoNotSupportOperator" xml:space="preserve">
    <value>None of the types '{0}' support the operator '{1}'</value>
  </data>
  <data name="csTypeDoesNotSupportOperator" xml:space="preserve">
    <value>The type '{0}' does not support the operator '{1}'</value>
  </data>
  <data name="csTypesDoNotSupportOperatorNullable" xml:space="preserve">
    <value>None of the types '{0}' support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="csTypeDoesNotSupportOperatorNullable" xml:space="preserve">
    <value>The type '{0}' does not support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="csTypeDoesNotSupportConversion" xml:space="preserve">
    <value>The type '{0}' does not support a conversion to the type '{1}'</value>
  </data>
  <data name="csMethodFoundButIsStatic" xml:space="preserve">
    <value>The type '{0}' has a method '{1}' (full name '{2}'), but the method is static</value>
  </data>
  <data name="csMethodFoundButIsNotStatic" xml:space="preserve">
    <value>The type '{0}' has a method '{1}' (full name '{2}'), but the method is not static</value>
  </data>
  <data name="csStructConstraintInconsistent" xml:space="preserve">
    <value>The constraints 'struct' and 'not struct' are inconsistent</value>
  </data>
  <data name="csTypeDoesNotHaveNull" xml:space="preserve">
    <value>The type '{0}' does not have 'null' as a proper value</value>
  </data>
  <data name="csNullableTypeDoesNotHaveNull" xml:space="preserve">
    <value>The type '{0}' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'.</value>
  </data>
  <data name="csTypeDoesNotSupportComparison1" xml:space="preserve">
    <value>The type '{0}' does not support the 'comparison' constraint because it has the 'NoComparison' attribute</value>
  </data>
  <data name="csTypeDoesNotSupportComparison2" xml:space="preserve">
    <value>The type '{0}' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface</value>
  </data>
  <data name="csTypeDoesNotSupportComparison3" xml:space="preserve">
    <value>The type '{0}' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison</value>
  </data>
  <data name="csTypeDoesNotSupportEquality1" xml:space="preserve">
    <value>The type '{0}' does not support the 'equality' constraint because it has the 'NoEquality' attribute</value>
  </data>
  <data name="csTypeDoesNotSupportEquality2" xml:space="preserve">
    <value>The type '{0}' does not support the 'equality' constraint because it is a function type</value>
  </data>
  <data name="csTypeDoesNotSupportEquality3" xml:space="preserve">
    <value>The type '{0}' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality</value>
  </data>
  <data name="csTypeIsNotEnumType" xml:space="preserve">
    <value>The type '{0}' is not a CLI enum type</value>
  </data>
  <data name="csTypeHasNonStandardDelegateType" xml:space="preserve">
    <value>The type '{0}' has a non-standard delegate type</value>
  </data>
  <data name="csTypeIsNotDelegateType" xml:space="preserve">
    <value>The type '{0}' is not a CLI delegate type</value>
  </data>
  <data name="csTypeParameterCannotBeNullable" xml:space="preserve">
    <value>This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values.</value>
  </data>
  <data name="csGenericConstructRequiresStructType" xml:space="preserve">
    <value>A generic construct requires that the type '{0}' is a CLI or F# struct type</value>
  </data>
  <data name="csGenericConstructRequiresUnmanagedType" xml:space="preserve">
    <value>A generic construct requires that the type '{0}' is an unmanaged type</value>
  </data>
  <data name="csTypeNotCompatibleBecauseOfPrintf" xml:space="preserve">
    <value>The type '{0}' is not compatible with any of the types {1}, arising from the use of a printf-style format string</value>
  </data>
  <data name="csGenericConstructRequiresReferenceSemantics" xml:space="preserve">
    <value>A generic construct requires that the type '{0}' have reference semantics, but it does not, i.e. it is a struct</value>
  </data>
  <data name="csGenericConstructRequiresNonAbstract" xml:space="preserve">
    <value>A generic construct requires that the type '{0}' be non-abstract</value>
  </data>
  <data name="csGenericConstructRequiresPublicDefaultConstructor" xml:space="preserve">
    <value>A generic construct requires that the type '{0}' have a public default constructor</value>
  </data>
  <data name="csTypeInstantiationLengthMismatch" xml:space="preserve">
    <value>Type instantiation length mismatch</value>
  </data>
  <data name="csOptionalArgumentNotPermittedHere" xml:space="preserve">
    <value>Optional arguments not permitted here</value>
  </data>
  <data name="csMemberIsNotStatic" xml:space="preserve">
    <value>{0} is not a static member</value>
  </data>
  <data name="csMemberIsNotInstance" xml:space="preserve">
    <value>{0} is not an instance member</value>
  </data>
  <data name="csArgumentLengthMismatch" xml:space="preserve">
    <value>Argument length mismatch</value>
  </data>
  <data name="csArgumentTypesDoNotMatch" xml:space="preserve">
    <value>The argument types don't match</value>
  </data>
  <data name="csMethodExpectsParams" xml:space="preserve">
    <value>This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument</value>
  </data>
  <data name="csMemberIsNotAccessible" xml:space="preserve">
    <value>The member or object constructor '{0}' is not {1}</value>
  </data>
  <data name="csMemberIsNotAccessible2" xml:space="preserve">
    <value>The member or object constructor '{0}' is not {1}. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.</value>
  </data>
  <data name="csMethodIsNotAStaticMethod" xml:space="preserve">
    <value>{0} is not a static method</value>
  </data>
  <data name="csMethodIsNotAnInstanceMethod" xml:space="preserve">
    <value>{0} is not an instance method</value>
  </data>
  <data name="csMemberHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>The member or object constructor '{0}' has no argument or settable return property '{1}'. {2}.</value>
  </data>
  <data name="csCtorHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>The object constructor '{0}' has no argument or settable return property '{1}'. {2}.</value>
  </data>
  <data name="csRequiredSignatureIs" xml:space="preserve">
    <value>The required signature is {0}</value>
  </data>
  <data name="csMemberSignatureMismatch" xml:space="preserve">
    <value>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'.</value>
  </data>
  <data name="csMemberSignatureMismatch2" xml:space="preserve">
    <value>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'.</value>
  </data>
  <data name="csMemberSignatureMismatch3" xml:space="preserve">
    <value>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch4" xml:space="preserve">
    <value>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</value>
  </data>
  <data name="csMemberSignatureMismatchArityNamed" xml:space="preserve">
    <value>The member or object constructor '{0}' requires {1} argument(s) but is here given {2} unnamed and {3} named argument(s). The required signature is '{4}'.</value>
  </data>
  <data name="csMemberSignatureMismatchArity" xml:space="preserve">
    <value>The member or object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</value>
  </data>
  <data name="csCtorSignatureMismatchArity" xml:space="preserve">
    <value>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</value>
  </data>
  <data name="csCtorSignatureMismatchArityProp" xml:space="preserve">
    <value>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',').</value>
  </data>
  <data name="csMemberSignatureMismatchArityType" xml:space="preserve">
    <value>The member or object constructor '{0}' takes {1} type argument(s) but is here given {2}. The required signature is '{3}'.</value>
  </data>
  <data name="csMemberNotAccessible" xml:space="preserve">
    <value>A member or object constructor '{0}' taking {1} arguments is not accessible from this code location. All accessible versions of method '{2}' take {3} arguments.</value>
  </data>
  <data name="csIncorrectGenericInstantiation" xml:space="preserve">
    <value>Incorrect generic instantiation. No {0} member named '{1}' takes {2} generic arguments.</value>
  </data>
  <data name="csMemberOverloadArityMismatch" xml:space="preserve">
    <value>The member or object constructor '{0}' does not take {1} argument(s). An overload was found taking {2} arguments.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments" xml:space="preserve">
    <value>No {0} member or object constructor named '{1}' takes {2} arguments</value>
  </data>
  <data name="csNoMemberTakesTheseArguments2" xml:space="preserve">
    <value>No {0} member or object constructor named '{1}' takes {2} arguments. Note the call to this member also provides {3} named arguments.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments3" xml:space="preserve">
    <value>No {0} member or object constructor named '{1}' takes {2} arguments. The named argument '{3}' doesn't correspond to any argument or settable return property for any overload.</value>
  </data>
  <data name="csMethodNotFound" xml:space="preserve">
    <value>Method or object constructor '{0}' not found</value>
  </data>
  <data name="csNoOverloadsFound" xml:space="preserve">
    <value>No overloads match for method '{0}'.</value>
  </data>
  <data name="csMethodIsOverloaded" xml:space="preserve">
    <value>A unique overload for method '{0}' could not be determined based on type information prior to this program point. A type annotation may be needed.</value>
  </data>
  <data name="csCandidates" xml:space="preserve">
    <value>Candidates: {0}</value>
  </data>
  <data name="csSeeAvailableOverloads" xml:space="preserve">
    <value>The available overloads are shown below.</value>
  </data>
  <data name="parsDoCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Accessibility modifiers are not permitted on 'do' bindings, but '{0}' was given.</value>
  </data>
  <data name="parsEofInHashIf" xml:space="preserve">
    <value>End of file in #if section begun at or after here</value>
  </data>
  <data name="parsEofInString" xml:space="preserve">
    <value>End of file in string begun at or before here</value>
  </data>
  <data name="parsEofInVerbatimString" xml:space="preserve">
    <value>End of file in verbatim string begun at or before here</value>
  </data>
  <data name="parsEofInComment" xml:space="preserve">
    <value>End of file in comment begun at or before here</value>
  </data>
  <data name="parsEofInStringInComment" xml:space="preserve">
    <value>End of file in string embedded in comment begun at or before here</value>
  </data>
  <data name="parsEofInVerbatimStringInComment" xml:space="preserve">
    <value>End of file in verbatim string embedded in comment begun at or before here</value>
  </data>
  <data name="parsEofInIfOcaml" xml:space="preserve">
    <value>End of file in IF-OCAML section begun at or before here</value>
  </data>
  <data name="parsEofInDirective" xml:space="preserve">
    <value>End of file in directive begun at or before here</value>
  </data>
  <data name="parsNoHashEndIfFound" xml:space="preserve">
    <value>No #endif found for #if or #else</value>
  </data>
  <data name="parsAttributesIgnored" xml:space="preserve">
    <value>Attributes have been ignored in this construct</value>
  </data>
  <data name="parsUseBindingsIllegalInImplicitClassConstructors" xml:space="preserve">
    <value>'use' bindings are not permitted in primary constructors</value>
  </data>
  <data name="parsUseBindingsIllegalInModules" xml:space="preserve">
    <value>'use' bindings are not permitted in modules and are treated as 'let' bindings</value>
  </data>
  <data name="parsIntegerForLoopRequiresSimpleIdentifier" xml:space="preserve">
    <value>An integer for loop must use a simple identifier</value>
  </data>
  <data name="parsOnlyOneWithAugmentationAllowed" xml:space="preserve">
    <value>At most one 'with' augmentation is permitted</value>
  </data>
  <data name="parsUnexpectedSemicolon" xml:space="preserve">
    <value>A semicolon is not expected at this point</value>
  </data>
  <data name="parsUnexpectedEndOfFile" xml:space="preserve">
    <value>Unexpected end of input</value>
  </data>
  <data name="parsUnexpectedVisibilityDeclaration" xml:space="preserve">
    <value>Accessibility modifiers are not permitted here, but '{0}' was given.</value>
  </data>
  <data name="parsOnlyHashDirectivesAllowed" xml:space="preserve">
    <value>Only '#' compiler directives may occur prior to the first 'namespace' declaration</value>
  </data>
  <data name="parsVisibilityDeclarationsShouldComePriorToIdentifier" xml:space="preserve">
    <value>Accessibility modifiers should come immediately prior to the identifier naming a construct</value>
  </data>
  <data name="parsNamespaceOrModuleNotBoth" xml:space="preserve">
    <value>Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'</value>
  </data>
  <data name="parsModuleAbbreviationMustBeSimpleName" xml:space="preserve">
    <value>A module abbreviation must be a simple name, not a path</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviation" xml:space="preserve">
    <value>Ignoring attributes on module abbreviation</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>The '{0}' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</value>
  </data>
  <data name="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>The '{0}' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</value>
  </data>
  <data name="parsUnClosedBlockInHashLight" xml:space="preserve">
    <value>Unclosed block</value>
  </data>
  <data name="parsUnmatchedBeginOrStruct" xml:space="preserve">
    <value>Unmatched 'begin' or 'struct'</value>
  </data>
  <data name="parsModuleDefnMustBeSimpleName" xml:space="preserve">
    <value>A module name must be a simple name, not a path</value>
  </data>
  <data name="parsUnexpectedEmptyModuleDefn" xml:space="preserve">
    <value>Unexpected empty type moduleDefn list</value>
  </data>
  <data name="parsAttributesMustComeBeforeVal" xml:space="preserve">
    <value>Attributes should be placed before 'val'</value>
  </data>
  <data name="parsAttributesAreNotPermittedOnInterfaceImplementations" xml:space="preserve">
    <value>Attributes are not permitted on interface implementations</value>
  </data>
  <data name="parsSyntaxError" xml:space="preserve">
    <value>Syntax error</value>
  </data>
  <data name="parsAugmentationsIllegalOnDelegateType" xml:space="preserve">
    <value>Augmentations are not permitted on delegate type moduleDefns</value>
  </data>
  <data name="parsUnmatchedClassInterfaceOrStruct" xml:space="preserve">
    <value>Unmatched 'class', 'interface' or 'struct'</value>
  </data>
  <data name="parsEmptyTypeDefinition" xml:space="preserve">
    <value>A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'.</value>
  </data>
  <data name="parsUnmatchedWith" xml:space="preserve">
    <value>Unmatched 'with' or badly formatted 'with' block</value>
  </data>
  <data name="parsGetOrSetRequired" xml:space="preserve">
    <value>'get', 'set' or 'get,set' required</value>
  </data>
  <data name="parsOnlyClassCanTakeValueArguments" xml:space="preserve">
    <value>Only class types may take value arguments</value>
  </data>
  <data name="parsUnmatchedBegin" xml:space="preserve">
    <value>Unmatched 'begin'</value>
  </data>
  <data name="parsInvalidDeclarationSyntax" xml:space="preserve">
    <value>Invalid declaration syntax</value>
  </data>
  <data name="parsGetAndOrSetRequired" xml:space="preserve">
    <value>'get' and/or 'set' required</value>
  </data>
  <data name="parsTypeAnnotationsOnGetSet" xml:space="preserve">
    <value>Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'</value>
  </data>
  <data name="parsGetterMustHaveAtLeastOneArgument" xml:space="preserve">
    <value>A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'</value>
  </data>
  <data name="parsMultipleAccessibilitiesForGetSet" xml:space="preserve">
    <value>Multiple accessibilities given for property getter or setter</value>
  </data>
  <data name="parsSetSyntax" xml:space="preserve">
    <value>Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '</value>
  </data>
  <data name="parsInterfacesHaveSameVisibilityAsEnclosingType" xml:space="preserve">
    <value>Interfaces always have the same visibility as the enclosing type</value>
  </data>
  <data name="parsAccessibilityModsIllegalForAbstract" xml:space="preserve">
    <value>Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.</value>
  </data>
  <data name="parsAttributesIllegalOnInherit" xml:space="preserve">
    <value>Attributes are not permitted on 'inherit' declarations</value>
  </data>
  <data name="parsVisibilityIllegalOnInherit" xml:space="preserve">
    <value>Accessibility modifiers are not permitted on an 'inherits' declaration</value>
  </data>
  <data name="parsInheritDeclarationsCannotHaveAsBindings" xml:space="preserve">
    <value>'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding.</value>
  </data>
  <data name="parsAttributesIllegalHere" xml:space="preserve">
    <value>Attributes are not allowed here</value>
  </data>
  <data name="parsTypeAbbreviationsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Accessibility modifiers are not permitted in this position for type abbreviations</value>
  </data>
  <data name="parsEnumTypesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Accessibility modifiers are not permitted in this position for enum types</value>
  </data>
  <data name="parsAllEnumFieldsRequireValues" xml:space="preserve">
    <value>All enum fields must be given values</value>
  </data>
  <data name="parsInlineAssemblyCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Accessibility modifiers are not permitted on inline assembly code types</value>
  </data>
  <data name="parsUnexpectedIdentifier" xml:space="preserve">
    <value>Unexpected identifier: '{0}'</value>
  </data>
  <data name="parsUnionCasesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation.</value>
  </data>
  <data name="parsEnumFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Accessibility modifiers are not permitted on enumeration fields</value>
  </data>
  <data name="parsConsiderUsingSeparateRecordType" xml:space="preserve">
    <value>Consider using a separate record type instead</value>
  </data>
  <data name="parsRecordFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation.</value>
  </data>
  <data name="parsLetAndForNonRecBindings" xml:space="preserve">
    <value>The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings</value>
  </data>
  <data name="parsUnmatchedParen" xml:space="preserve">
    <value>Unmatched '('</value>
  </data>
  <data name="parsSuccessivePatternsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Successive patterns should be separated by spaces or tupled</value>
  </data>
  <data name="parsNoMatchingInForLet" xml:space="preserve">
    <value>No matching 'in' found for this 'let'</value>
  </data>
  <data name="parsErrorInReturnForLetIncorrectIndentation" xml:space="preserve">
    <value>Error in the return expression for this 'let'. Possible incorrect indentation.</value>
  </data>
  <data name="parsExpectedExpressionAfterLet" xml:space="preserve">
    <value>The block following this '{0}' is unfinished. Every code block is an expression and must have a result. '{1}' cannot be the final code element in a block. Consider giving this block an explicit result.</value>
  </data>
  <data name="parsIncompleteIf" xml:space="preserve">
    <value>Incomplete conditional. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</value>
  </data>
  <data name="parsAssertIsNotFirstClassValue" xml:space="preserve">
    <value>'assert' may not be used as a first class value. Use 'assert &lt;expr&gt;' instead.</value>
  </data>
  <data name="parsIdentifierExpected" xml:space="preserve">
    <value>Identifier expected</value>
  </data>
  <data name="parsInOrEqualExpected" xml:space="preserve">
    <value>'in' or '=' expected</value>
  </data>
  <data name="parsArrowUseIsLimited" xml:space="preserve">
    <value>The use of '-&gt;' in sequence and computation expressions is limited to the form 'for pat in expr -&gt; expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions.</value>
  </data>
  <data name="parsSuccessiveArgsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized</value>
  </data>
  <data name="parsUnmatchedBracket" xml:space="preserve">
    <value>Unmatched '['</value>
  </data>
  <data name="parsMissingQualificationAfterDot" xml:space="preserve">
    <value>Missing qualification after '.'</value>
  </data>
  <data name="parsParenFormIsForML" xml:space="preserve">
    <value>In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array</value>
  </data>
  <data name="parsMismatchedQuote" xml:space="preserve">
    <value>Mismatched quotation, beginning with '{0}'</value>
  </data>
  <data name="parsUnmatched" xml:space="preserve">
    <value>Unmatched '{0}'</value>
  </data>
  <data name="parsUnmatchedBracketBar" xml:space="preserve">
    <value>Unmatched '[|'</value>
  </data>
  <data name="parsUnmatchedBrace" xml:space="preserve">
    <value>Unmatched '{{'</value>
  </data>
  <data name="parsFieldBinding" xml:space="preserve">
    <value>Field bindings must have the form 'id = expr;'</value>
  </data>
  <data name="parsMemberIllegalInObjectImplementation" xml:space="preserve">
    <value>This member is not permitted in an object implementation</value>
  </data>
  <data name="parsMissingFunctionBody" xml:space="preserve">
    <value>Missing function body</value>
  </data>
  <data name="parsSyntaxErrorInLabeledType" xml:space="preserve">
    <value>Syntax error in labelled type argument</value>
  </data>
  <data name="parsUnexpectedInfixOperator" xml:space="preserve">
    <value>Unexpected infix operator in type expression</value>
  </data>
  <data name="parsMultiArgumentGenericTypeFormDeprecated" xml:space="preserve">
    <value>The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident&lt;typ,...,typ&gt;' instead</value>
  </data>
  <data name="parsInvalidLiteralInType" xml:space="preserve">
    <value>Invalid literal in type</value>
  </data>
  <data name="parsUnexpectedOperatorForUnitOfMeasure" xml:space="preserve">
    <value>Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'.</value>
  </data>
  <data name="parsUnexpectedIntegerLiteralForUnitOfMeasure" xml:space="preserve">
    <value>Unexpected integer literal in unit-of-measure expression</value>
  </data>
  <data name="parsUnexpectedTypeParameter" xml:space="preserve">
    <value>Syntax error: unexpected type parameter specification</value>
  </data>
  <data name="parsMismatchedQuotationName" xml:space="preserve">
    <value>Mismatched quotation operator name, beginning with '{0}'</value>
  </data>
  <data name="parsActivePatternCaseMustBeginWithUpperCase" xml:space="preserve">
    <value>Active pattern case identifiers must begin with an uppercase letter</value>
  </data>
  <data name="parsActivePatternCaseContainsPipe" xml:space="preserve">
    <value>The '|' character is not permitted in active pattern case identifiers</value>
  </data>
  <data name="parsIllegalDenominatorForMeasureExponent" xml:space="preserve">
    <value>Denominator must not be 0 in unit-of-measure exponent</value>
  </data>
  <data name="parsNoEqualShouldFollowNamespace" xml:space="preserve">
    <value>No '=' symbol should follow a 'namespace' declaration</value>
  </data>
  <data name="parsSyntaxModuleStructEndDeprecated" xml:space="preserve">
    <value>The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'</value>
  </data>
  <data name="parsSyntaxModuleSigEndDeprecated" xml:space="preserve">
    <value>The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'</value>
  </data>
  <data name="tcStaticFieldUsedWhenInstanceFieldExpected" xml:space="preserve">
    <value>A static field was used where an instance field is expected</value>
  </data>
  <data name="tcMethodNotAccessible" xml:space="preserve">
    <value>Method '{0}' is not accessible from this code location</value>
  </data>
  <data name="tcImplicitMeasureFollowingSlash" xml:space="preserve">
    <value>Implicit product of measures following /</value>
  </data>
  <data name="tcUnexpectedMeasureAnon" xml:space="preserve">
    <value>Unexpected SynMeasure.Anon</value>
  </data>
  <data name="tcNonZeroConstantCannotHaveGenericUnit" xml:space="preserve">
    <value>Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.</value>
  </data>
  <data name="tcSeqResultsUseYield" xml:space="preserve">
    <value>In sequence expressions, results are generated using 'yield'</value>
  </data>
  <data name="tcUnexpectedBigRationalConstant" xml:space="preserve">
    <value>Unexpected big rational constant</value>
  </data>
  <data name="tcInvalidTypeForUnitsOfMeasure" xml:space="preserve">
    <value>Units-of-measure supported only on float, float32, decimal and signed integer types</value>
  </data>
  <data name="tcUnexpectedConstUint16Array" xml:space="preserve">
    <value>Unexpected Const_uint16array</value>
  </data>
  <data name="tcUnexpectedConstByteArray" xml:space="preserve">
    <value>Unexpected Const_bytearray</value>
  </data>
  <data name="tcParameterRequiresName" xml:space="preserve">
    <value>A parameter with attributes must also be given a name, e.g. '[&lt;Attribute&gt;] Name : Type'</value>
  </data>
  <data name="tcReturnValuesCannotHaveNames" xml:space="preserve">
    <value>Return values cannot have names</value>
  </data>
  <data name="tcMemberKindPropertyGetSetNotExpected" xml:space="preserve">
    <value>MemberKind.PropertyGetSet only expected in parse trees</value>
  </data>
  <data name="tcNamespaceCannotContainValues" xml:space="preserve">
    <value>Namespaces cannot contain values. Consider using a module to hold your value declarations.</value>
  </data>
  <data name="tcNamespaceCannotContainExtensionMembers" xml:space="preserve">
    <value>Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.</value>
  </data>
  <data name="tcMultipleVisibilityAttributes" xml:space="preserve">
    <value>Multiple visibility attributes have been specified for this identifier</value>
  </data>
  <data name="tcMultipleVisibilityAttributesWithLet" xml:space="preserve">
    <value>Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions.</value>
  </data>
  <data name="tcInvalidMethodNameForRelationalOperator" xml:space="preserve">
    <value>The name '({0})' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '{1}' instead.</value>
  </data>
  <data name="tcInvalidMethodNameForEquality" xml:space="preserve">
    <value>The name '({0})' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '{1}' instead.</value>
  </data>
  <data name="tcInvalidMemberName" xml:space="preserve">
    <value>The name '({0})' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '{1}' instead.</value>
  </data>
  <data name="tcInvalidMemberNameFixedTypes" xml:space="preserve">
    <value>The name '({0})' should not be used as a member name because it is given a standard definition in the F# library over fixed types</value>
  </data>
  <data name="tcInvalidOperatorDefinitionRelational" xml:space="preserve">
    <value>The '{0}' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionEquality" xml:space="preserve">
    <value>The '{0}' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type.</value>
  </data>
  <data name="tcInvalidOperatorDefinition" xml:space="preserve">
    <value>The '{0}' operator should not normally be redefined. Consider using a different operator name</value>
  </data>
  <data name="tcInvalidIndexOperatorDefinition" xml:space="preserve">
    <value>The '{0}' operator cannot be redefined. Consider using a different operator name</value>
  </data>
  <data name="tcExpectModuleOrNamespaceParent" xml:space="preserve">
    <value>Expected module or namespace parent {0}</value>
  </data>
  <data name="tcImplementsIComparableExplicitly" xml:space="preserve">
    <value>The struct, record or union type '{0}' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type.</value>
  </data>
  <data name="tcImplementsGenericIComparableExplicitly" xml:space="preserve">
    <value>The struct, record or union type '{0}' implements the interface 'System.IComparable&lt;_&gt;' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.</value>
  </data>
  <data name="tcImplementsIStructuralComparableExplicitly" xml:space="preserve">
    <value>The struct, record or union type '{0}' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type.</value>
  </data>
  <data name="tcRecordFieldInconsistentTypes" xml:space="preserve">
    <value>This record contains fields from inconsistent types</value>
  </data>
  <data name="tcDllImportStubsCannotBeInlined" xml:space="preserve">
    <value>DLLImport stubs cannot be inlined</value>
  </data>
  <data name="tcStructsCanOnlyBindThisAtMemberDeclaration" xml:space="preserve">
    <value>Structs may only bind a 'this' parameter at member declarations</value>
  </data>
  <data name="tcUnexpectedExprAtRecInfPoint" xml:space="preserve">
    <value>Unexpected expression at recursive inference point</value>
  </data>
  <data name="tcLessGenericBecauseOfAnnotation" xml:space="preserve">
    <value>This code is less generic than required by its annotations because the explicit type variable '{0}' could not be generalized. It was constrained to be '{1}'.</value>
  </data>
  <data name="tcConstrainedTypeVariableCannotBeGeneralized" xml:space="preserve">
    <value>One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types</value>
  </data>
  <data name="tcGenericParameterHasBeenConstrained" xml:space="preserve">
    <value>A generic type parameter has been used in a way that constrains it to always be '{0}'</value>
  </data>
  <data name="tcTypeParameterHasBeenConstrained" xml:space="preserve">
    <value>This type parameter has been used in a way that constrains it to always be '{0}'</value>
  </data>
  <data name="tcTypeParametersInferredAreNotStable" xml:space="preserve">
    <value>The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</value>
  </data>
  <data name="tcExplicitTypeParameterInvalid" xml:space="preserve">
    <value>Explicit type parameters may only be used on module or member bindings</value>
  </data>
  <data name="tcOverridingMethodRequiresAllOrNoTypeParameters" xml:space="preserve">
    <value>You must explicitly declare either all or no type parameters when overriding a generic abstract method</value>
  </data>
  <data name="tcFieldsDoNotDetermineUniqueRecordType" xml:space="preserve">
    <value>The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type</value>
  </data>
  <data name="tcFieldAppearsTwiceInRecord" xml:space="preserve">
    <value>The field '{0}' appears twice in this record expression or pattern</value>
  </data>
  <data name="tcUnknownUnion" xml:space="preserve">
    <value>Unknown union case</value>
  </data>
  <data name="tcNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>This code is not sufficiently generic. The type variable {0} could not be generalized because it would escape its scope.</value>
  </data>
  <data name="tcPropertyRequiresExplicitTypeParameters" xml:space="preserve">
    <value>A property cannot have explicit type parameters. Consider using a method instead.</value>
  </data>
  <data name="tcConstructorCannotHaveTypeParameters" xml:space="preserve">
    <value>A constructor cannot have explicit type parameters. Consider using a static construction method instead.</value>
  </data>
  <data name="tcInstanceMemberRequiresTarget" xml:space="preserve">
    <value>This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'.</value>
  </data>
  <data name="tcUnexpectedPropertyInSyntaxTree" xml:space="preserve">
    <value>Unexpected source-level property specification in syntax tree</value>
  </data>
  <data name="tcStaticInitializerRequiresArgument" xml:space="preserve">
    <value>A static initializer requires an argument</value>
  </data>
  <data name="tcObjectConstructorRequiresArgument" xml:space="preserve">
    <value>An object constructor requires an argument</value>
  </data>
  <data name="tcStaticMemberShouldNotHaveThis" xml:space="preserve">
    <value>This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'.</value>
  </data>
  <data name="tcExplicitStaticInitializerSyntax" xml:space="preserve">
    <value>An explicit static initializer should use the syntax 'static new(args) = expr'</value>
  </data>
  <data name="tcExplicitObjectConstructorSyntax" xml:space="preserve">
    <value>An explicit object constructor should use the syntax 'new(args) = expr'</value>
  </data>
  <data name="tcUnexpectedPropertySpec" xml:space="preserve">
    <value>Unexpected source-level property specification</value>
  </data>
  <data name="tcObjectExpressionFormDeprecated" xml:space="preserve">
    <value>This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions.</value>
  </data>
  <data name="tcInvalidDeclaration" xml:space="preserve">
    <value>Invalid declaration</value>
  </data>
  <data name="tcAttributesInvalidInPatterns" xml:space="preserve">
    <value>Attributes are not allowed within patterns</value>
  </data>
  <data name="tcFunctionRequiresExplicitTypeArguments" xml:space="preserve">
    <value>The generic function '{0}' must be given explicit type argument(s)</value>
  </data>
  <data name="tcDoesNotAllowExplicitTypeArguments" xml:space="preserve">
    <value>The method or function '{0}' should not be given explicit type argument(s) because it does not declare its type parameters explicitly</value>
  </data>
  <data name="tcTypeParameterArityMismatch" xml:space="preserve">
    <value>This value, type or method expects {0} type parameter(s) but was given {1}</value>
  </data>
  <data name="tcDefaultStructConstructorCall" xml:space="preserve">
    <value>The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization</value>
  </data>
  <data name="tcCouldNotFindIDisposable" xml:space="preserve">
    <value>Couldn't find Dispose on IDisposable, or it was overloaded</value>
  </data>
  <data name="tcNonLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>This value is not a literal and cannot be used in a pattern</value>
  </data>
  <data name="tcFieldIsReadonly" xml:space="preserve">
    <value>This field is readonly</value>
  </data>
  <data name="tcNameArgumentsMustAppearLast" xml:space="preserve">
    <value>Named arguments must appear after all other arguments</value>
  </data>
  <data name="tcFunctionRequiresExplicitLambda" xml:space="preserve">
    <value>This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking {0} arguments.</value>
  </data>
  <data name="tcTypeCannotBeEnumerated" xml:space="preserve">
    <value>The type '{0}' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method</value>
  </data>
  <data name="tcInvalidMixtureOfRecursiveForms" xml:space="preserve">
    <value>This recursive binding uses an invalid mixture of recursive forms</value>
  </data>
  <data name="tcInvalidObjectConstructionExpression" xml:space="preserve">
    <value>This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.</value>
  </data>
  <data name="tcInvalidConstraint" xml:space="preserve">
    <value>Invalid constraint</value>
  </data>
  <data name="tcInvalidConstraintTypeSealed" xml:space="preserve">
    <value>Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution</value>
  </data>
  <data name="tcInvalidEnumConstraint" xml:space="preserve">
    <value>An 'enum' constraint must be of the form 'enum&lt;type&gt;'</value>
  </data>
  <data name="tcInvalidNewConstraint" xml:space="preserve">
    <value>'new' constraints must take one argument of type 'unit' and return the constructed type</value>
  </data>
  <data name="tcInvalidPropertyType" xml:space="preserve">
    <value>This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -&gt; ty3'. Properties returning functions should have types of the form '(ty1 -&gt; ty2)'.</value>
  </data>
  <data name="tcExpectedUnitOfMeasureMarkWithAttribute" xml:space="preserve">
    <value>Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.</value>
  </data>
  <data name="tcExpectedTypeParameter" xml:space="preserve">
    <value>Expected type parameter, not unit-of-measure parameter</value>
  </data>
  <data name="tcExpectedTypeNotUnitOfMeasure" xml:space="preserve">
    <value>Expected type, not unit-of-measure</value>
  </data>
  <data name="tcExpectedUnitOfMeasureNotType" xml:space="preserve">
    <value>Expected unit-of-measure, not type</value>
  </data>
  <data name="tcInvalidUnitsOfMeasurePrefix" xml:space="preserve">
    <value>Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.</value>
  </data>
  <data name="tcUnitsOfMeasureInvalidInTypeConstructor" xml:space="preserve">
    <value>Unit-of-measure cannot be used in type constructor application</value>
  </data>
  <data name="tcRequireBuilderMethod" xml:space="preserve">
    <value>This control construct may only be used if the computation expression builder defines a '{0}' method</value>
  </data>
  <data name="tcTypeHasNoNestedTypes" xml:space="preserve">
    <value>This type has no nested types</value>
  </data>
  <data name="tcUnexpectedSymbolInTypeExpression" xml:space="preserve">
    <value>Unexpected {0} in type expression</value>
  </data>
  <data name="tcTypeParameterInvalidAsTypeConstructor" xml:space="preserve">
    <value>Type parameter cannot be used as type constructor</value>
  </data>
  <data name="tcIllegalSyntaxInTypeExpression" xml:space="preserve">
    <value>Illegal syntax in type expression</value>
  </data>
  <data name="tcAnonymousUnitsOfMeasureCannotBeNested" xml:space="preserve">
    <value>Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression</value>
  </data>
  <data name="tcAnonymousTypeInvalidInDeclaration" xml:space="preserve">
    <value>Anonymous type variables are not permitted in this declaration</value>
  </data>
  <data name="tcUnexpectedSlashInType" xml:space="preserve">
    <value>Unexpected / in type</value>
  </data>
  <data name="tcUnexpectedTypeArguments" xml:space="preserve">
    <value>Unexpected type arguments</value>
  </data>
  <data name="tcOptionalArgsOnlyOnMembers" xml:space="preserve">
    <value>Optional arguments are only permitted on type members</value>
  </data>
  <data name="tcNameNotBoundInPattern" xml:space="preserve">
    <value>Name '{0}' not bound in pattern context</value>
  </data>
  <data name="tcInvalidNonPrimitiveLiteralInPatternMatch" xml:space="preserve">
    <value>Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when &lt;variable&gt; = &lt;constant&gt;' at the end of the match clause.</value>
  </data>
  <data name="tcInvalidTypeArgumentUsage" xml:space="preserve">
    <value>Type arguments cannot be specified here</value>
  </data>
  <data name="tcRequireActivePatternWithOneResult" xml:space="preserve">
    <value>Only active patterns returning exactly one result may accept arguments</value>
  </data>
  <data name="tcInvalidArgForParameterizedPattern" xml:space="preserve">
    <value>Invalid argument to parameterized pattern label</value>
  </data>
  <data name="tcInvalidIndexIntoActivePatternArray" xml:space="preserve">
    <value>Internal error. Invalid index into active pattern array</value>
  </data>
  <data name="tcUnionCaseDoesNotTakeArguments" xml:space="preserve">
    <value>This union case does not take arguments</value>
  </data>
  <data name="tcUnionCaseRequiresOneArgument" xml:space="preserve">
    <value>This union case takes one argument</value>
  </data>
  <data name="tcUnionCaseExpectsTupledArguments" xml:space="preserve">
    <value>This union case expects {0} arguments in tupled form</value>
  </data>
  <data name="tcFieldIsNotStatic" xml:space="preserve">
    <value>Field '{0}' is not static</value>
  </data>
  <data name="tcFieldNotLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>This field is not a literal and cannot be used in a pattern</value>
  </data>
  <data name="tcRequireVarConstRecogOrLiteral" xml:space="preserve">
    <value>This is not a variable, constant, active recognizer or literal</value>
  </data>
  <data name="tcInvalidPattern" xml:space="preserve">
    <value>This is not a valid pattern</value>
  </data>
  <data name="tcUseWhenPatternGuard" xml:space="preserve">
    <value>Character range matches have been removed in F#. Consider using a 'when' pattern guard instead.</value>
  </data>
  <data name="tcIllegalPattern" xml:space="preserve">
    <value>Illegal pattern</value>
  </data>
  <data name="tcSyntaxErrorUnexpectedQMark" xml:space="preserve">
    <value>Syntax error - unexpected '?' symbol</value>
  </data>
  <data name="tcExpressionCountMisMatch" xml:space="preserve">
    <value>Expected {0} expressions, got {1}</value>
  </data>
  <data name="tcExprUndelayed" xml:space="preserve">
    <value>TcExprUndelayed: delayed</value>
  </data>
  <data name="tcExpressionRequiresSequence" xml:space="preserve">
    <value>This expression form may only be used in sequence and computation expressions</value>
  </data>
  <data name="tcInvalidObjectExpressionSyntaxForm" xml:space="preserve">
    <value>Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.</value>
  </data>
  <data name="tcInvalidObjectSequenceOrRecordExpression" xml:space="preserve">
    <value>Invalid object, sequence or record expression</value>
  </data>
  <data name="tcInvalidSequenceExpressionSyntaxForm" xml:space="preserve">
    <value>Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq {{ ... }}'</value>
  </data>
  <data name="tcExpressionWithIfRequiresParenthesis" xml:space="preserve">
    <value>This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression</value>
  </data>
  <data name="tcUnableToParseFormatString" xml:space="preserve">
    <value>Unable to parse format string '{0}'</value>
  </data>
  <data name="tcListLiteralMaxSize" xml:space="preserve">
    <value>This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.</value>
  </data>
  <data name="tcExpressionFormRequiresObjectConstructor" xml:space="preserve">
    <value>The expression form 'expr then expr' may only be used as part of an explicit object constructor</value>
  </data>
  <data name="tcNamedArgumentsCannotBeUsedInMemberTraits" xml:space="preserve">
    <value>Named arguments cannot be given to member trait calls</value>
  </data>
  <data name="tcNotValidEnumCaseName" xml:space="preserve">
    <value>This is not a valid name for an enumeration case</value>
  </data>
  <data name="tcFieldIsNotMutable" xml:space="preserve">
    <value>This field is not mutable</value>
  </data>
  <data name="tcConstructRequiresListArrayOrSequence" xml:space="preserve">
    <value>This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq {{ ... }}', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements</value>
  </data>
  <data name="tcConstructRequiresComputationExpressions" xml:space="preserve">
    <value>This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'.</value>
  </data>
  <data name="tcConstructRequiresSequenceOrComputations" xml:space="preserve">
    <value>This construct may only be used within sequence or computation expressions</value>
  </data>
  <data name="tcConstructRequiresComputationExpression" xml:space="preserve">
    <value>This construct may only be used within computation expressions</value>
  </data>
  <data name="tcInvalidIndexerExpression" xml:space="preserve">
    <value>Invalid indexer expression</value>
  </data>
  <data name="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint" xml:space="preserve">
    <value>The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints</value>
  </data>
  <data name="tcCannotInheritFromVariableType" xml:space="preserve">
    <value>Cannot inherit from a variable type</value>
  </data>
  <data name="tcObjectConstructorsOnTypeParametersCannotTakeArguments" xml:space="preserve">
    <value>Calls to object constructors on type parameters cannot be given arguments</value>
  </data>
  <data name="tcCompiledNameAttributeMisused" xml:space="preserve">
    <value>The 'CompiledName' attribute cannot be used with this language element</value>
  </data>
  <data name="tcNamedTypeRequired" xml:space="preserve">
    <value>'{0}' may only be used with named types</value>
  </data>
  <data name="tcInheritCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead.</value>
  </data>
  <data name="tcNewCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>'new' cannot be used on interface types. Consider using an object expression '{{ new ... with ... }}' instead.</value>
  </data>
  <data name="tcAbstractTypeCannotBeInstantiated" xml:space="preserve">
    <value>Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{{ new ... with ... }}' instead.</value>
  </data>
  <data name="tcIDisposableTypeShouldUseNew" xml:space="preserve">
    <value>It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value</value>
  </data>
  <data name="tcSyntaxCanOnlyBeUsedToCreateObjectTypes" xml:space="preserve">
    <value>'{0}' may only be used to construct object types</value>
  </data>
  <data name="tcConstructorRequiresCall" xml:space="preserve">
    <value>Constructors for the type '{0}' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.</value>
  </data>
  <data name="tcUndefinedField" xml:space="preserve">
    <value>The field '{0}' has been given a value, but is not present in the type '{1}'</value>
  </data>
  <data name="tcFieldRequiresAssignment" xml:space="preserve">
    <value>No assignment given for field '{0}' of type '{1}'</value>
  </data>
  <data name="tcExtraneousFieldsGivenValues" xml:space="preserve">
    <value>Extraneous fields have been given values</value>
  </data>
  <data name="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual" xml:space="preserve">
    <value>Only overrides of abstract and virtual members may be specified in object expressions</value>
  </data>
  <data name="tcNoAbstractOrVirtualMemberFound" xml:space="preserve">
    <value>The member '{0}' does not correspond to any abstract or virtual method available to override or implement.</value>
  </data>
  <data name="tcMemberFoundIsNotAbstractOrVirtual" xml:space="preserve">
    <value>The type {0} contains the member '{1}' but it is not a virtual or abstract method that is available to override or implement.</value>
  </data>
  <data name="tcArgumentArityMismatch" xml:space="preserve">
    <value>The member '{0}' does not accept the correct number of arguments. {1} argument(s) are expected, but {2} were given. The required signature is '{3}'.{4}</value>
  </data>
  <data name="tcArgumentArityMismatchOneOverload" xml:space="preserve">
    <value>The member '{0}' does not accept the correct number of arguments. One overload accepts {1} arguments, but {2} were given. The required signature is '{3}'.{4}</value>
  </data>
  <data name="tcSimpleMethodNameRequired" xml:space="preserve">
    <value>A simple method name is required here</value>
  </data>
  <data name="tcPredefinedTypeCannotBeUsedAsSuperType" xml:space="preserve">
    <value>The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class</value>
  </data>
  <data name="tcNewMustBeUsedWithNamedType" xml:space="preserve">
    <value>'new' must be used with a named type</value>
  </data>
  <data name="tcCannotCreateExtensionOfSealedType" xml:space="preserve">
    <value>Cannot create an extension of a sealed type</value>
  </data>
  <data name="tcNoArgumentsForRecordValue" xml:space="preserve">
    <value>No arguments may be given when constructing a record value</value>
  </data>
  <data name="tcNoInterfaceImplementationForConstructionExpression" xml:space="preserve">
    <value>Interface implementations cannot be given on construction expressions</value>
  </data>
  <data name="tcObjectConstructionCanOnlyBeUsedInClassTypes" xml:space="preserve">
    <value>Object construction expressions may only be used to implement constructors in class types</value>
  </data>
  <data name="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions" xml:space="preserve">
    <value>Only simple bindings of the form 'id = expr' can be used in construction expressions</value>
  </data>
  <data name="tcObjectsMustBeInitializedWithObjectExpression" xml:space="preserve">
    <value>Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field</value>
  </data>
  <data name="tcExpectedInterfaceType" xml:space="preserve">
    <value>Expected an interface type</value>
  </data>
  <data name="tcConstructorForInterfacesDoNotTakeArguments" xml:space="preserve">
    <value>Constructor expressions for interfaces do not take arguments</value>
  </data>
  <data name="tcConstructorRequiresArguments" xml:space="preserve">
    <value>This object constructor requires arguments</value>
  </data>
  <data name="tcNewRequiresObjectConstructor" xml:space="preserve">
    <value>'new' may only be used with object constructors</value>
  </data>
  <data name="tcAtLeastOneOverrideIsInvalid" xml:space="preserve">
    <value>At least one override did not correctly implement its corresponding abstract member</value>
  </data>
  <data name="tcNumericLiteralRequiresModule" xml:space="preserve">
    <value>This numeric literal requires that a module '{0}' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope</value>
  </data>
  <data name="tcInvalidRecordConstruction" xml:space="preserve">
    <value>Invalid record construction</value>
  </data>
  <data name="tcExpressionFormRequiresRecordTypes" xml:space="preserve">
    <value>The expression form {{ expr with ... }} may only be used with record types. To build object types use {{ new Type(...) with ... }}</value>
  </data>
  <data name="tcInheritedTypeIsNotObjectModelType" xml:space="preserve">
    <value>The inherited type is not an object model type</value>
  </data>
  <data name="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes" xml:space="preserve">
    <value>Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors</value>
  </data>
  <data name="tcEmptyRecordInvalid" xml:space="preserve">
    <value>'{{ }}' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.</value>
  </data>
  <data name="tcTypeIsNotARecordTypeNeedConstructor" xml:space="preserve">
    <value>This type is not a record type. Values of class and struct types must be created using calls to object constructors.</value>
  </data>
  <data name="tcTypeIsNotARecordType" xml:space="preserve">
    <value>This type is not a record type</value>
  </data>
  <data name="tcConstructIsAmbiguousInComputationExpression" xml:space="preserve">
    <value>This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder {{ ... }}'.</value>
  </data>
  <data name="tcConstructIsAmbiguousInSequenceExpression" xml:space="preserve">
    <value>This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {{... }}'.</value>
  </data>
  <data name="tcDoBangIllegalInSequenceExpression" xml:space="preserve">
    <value>'do!' cannot be used within sequence expressions</value>
  </data>
  <data name="tcUseForInSequenceExpression" xml:space="preserve">
    <value>The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead.</value>
  </data>
  <data name="tcTryIllegalInSequenceExpression" xml:space="preserve">
    <value>'try'/'with' cannot be used within sequence expressions</value>
  </data>
  <data name="tcUseYieldBangForMultipleResults" xml:space="preserve">
    <value>In sequence expressions, multiple results are generated using 'yield!'</value>
  </data>
  <data name="tcInvalidAssignment" xml:space="preserve">
    <value>Invalid assignment</value>
  </data>
  <data name="tcInvalidUseOfTypeName" xml:space="preserve">
    <value>Invalid use of a type name</value>
  </data>
  <data name="tcTypeHasNoAccessibleConstructor" xml:space="preserve">
    <value>This type has no accessible object constructors</value>
  </data>
  <data name="tcInvalidUseOfInterfaceType" xml:space="preserve">
    <value>Invalid use of an interface type</value>
  </data>
  <data name="tcInvalidUseOfDelegate" xml:space="preserve">
    <value>Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'.</value>
  </data>
  <data name="tcPropertyIsNotStatic" xml:space="preserve">
    <value>Property '{0}' is not static</value>
  </data>
  <data name="tcPropertyIsNotReadable" xml:space="preserve">
    <value>Property '{0}' is not readable</value>
  </data>
  <data name="tcLookupMayNotBeUsedHere" xml:space="preserve">
    <value>This lookup cannot be used here</value>
  </data>
  <data name="tcPropertyIsStatic" xml:space="preserve">
    <value>Property '{0}' is static</value>
  </data>
  <data name="tcPropertyCannotBeSet1" xml:space="preserve">
    <value>Property '{0}' cannot be set</value>
  </data>
  <data name="tcConstructorsCannotBeFirstClassValues" xml:space="preserve">
    <value>Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</value>
  </data>
  <data name="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields" xml:space="preserve">
    <value>The syntax 'expr.id' may only be used with record labels, properties and fields</value>
  </data>
  <data name="tcEventIsStatic" xml:space="preserve">
    <value>Event '{0}' is static</value>
  </data>
  <data name="tcEventIsNotStatic" xml:space="preserve">
    <value>Event '{0}' is not static</value>
  </data>
  <data name="tcNamedArgumentDidNotMatch" xml:space="preserve">
    <value>The named argument '{0}' did not match any argument or mutable property</value>
  </data>
  <data name="tcOverloadsCannotHaveCurriedArguments" xml:space="preserve">
    <value>One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.</value>
  </data>
  <data name="tcUnnamedArgumentsDoNotFormPrefix" xml:space="preserve">
    <value>The unnamed arguments do not form a prefix of the arguments of the method called</value>
  </data>
  <data name="tcStaticOptimizationConditionalsOnlyForFSharpLibrary" xml:space="preserve">
    <value>Static optimization conditionals are only for use within the F# library</value>
  </data>
  <data name="tcFormalArgumentIsNotOptional" xml:space="preserve">
    <value>The corresponding formal argument is not optional</value>
  </data>
  <data name="tcInvalidOptionalAssignmentToPropertyOrField" xml:space="preserve">
    <value>Invalid optional assignment to a property or field</value>
  </data>
  <data name="tcDelegateConstructorMustBePassed" xml:space="preserve">
    <value>A delegate constructor must be passed a single function value</value>
  </data>
  <data name="tcBindingCannotBeUseAndRec" xml:space="preserve">
    <value>A binding cannot be marked both 'use' and 'rec'</value>
  </data>
  <data name="tcVolatileOnlyOnClassLetBindings" xml:space="preserve">
    <value>The 'VolatileField' attribute may only be used on 'let' bindings in classes</value>
  </data>
  <data name="tcAttributesAreNotPermittedOnLetBindings" xml:space="preserve">
    <value>Attributes are not permitted on 'let' bindings in expressions</value>
  </data>
  <data name="tcDefaultValueAttributeRequiresVal" xml:space="preserve">
    <value>The 'DefaultValue' attribute may only be used on 'val' declarations</value>
  </data>
  <data name="tcConditionalAttributeRequiresMembers" xml:space="preserve">
    <value>The 'ConditionalAttribute' attribute may only be used on members</value>
  </data>
  <data name="tcInvalidActivePatternName" xml:space="preserve">
    <value>This is not a valid name for an active pattern</value>
  </data>
  <data name="tcEntryPointAttributeRequiresFunctionInModule" xml:space="preserve">
    <value>The 'EntryPointAttribute' attribute may only be used on function definitions in modules</value>
  </data>
  <data name="tcMutableValuesCannotBeInline" xml:space="preserve">
    <value>Mutable values cannot be marked 'inline'</value>
  </data>
  <data name="tcMutableValuesMayNotHaveGenericParameters" xml:space="preserve">
    <value>Mutable values cannot have generic parameters</value>
  </data>
  <data name="tcMutableValuesSyntax" xml:space="preserve">
    <value>Mutable function values should be written 'let mutable f = (fun args -&gt; ...)'</value>
  </data>
  <data name="tcOnlyFunctionsCanBeInline" xml:space="preserve">
    <value>Only functions may be marked 'inline'</value>
  </data>
  <data name="tcIllegalAttributesForLiteral" xml:space="preserve">
    <value>A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes</value>
  </data>
  <data name="tcLiteralCannotBeMutable" xml:space="preserve">
    <value>A literal value cannot be marked 'mutable'</value>
  </data>
  <data name="tcLiteralCannotBeInline" xml:space="preserve">
    <value>A literal value cannot be marked 'inline'</value>
  </data>
  <data name="tcLiteralCannotHaveGenericParameters" xml:space="preserve">
    <value>Literal values cannot have generic parameters</value>
  </data>
  <data name="tcInvalidConstantExpression" xml:space="preserve">
    <value>This is not a valid constant expression</value>
  </data>
  <data name="tcTypeIsInaccessible" xml:space="preserve">
    <value>This type is not accessible from this code location</value>
  </data>
  <data name="tcUnexpectedConditionInImportedAssembly" xml:space="preserve">
    <value>Unexpected condition in imported assembly: failed to decode AttributeUsage attribute</value>
  </data>
  <data name="tcUnrecognizedAttributeTarget" xml:space="preserve">
    <value>Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElementUseDo" xml:space="preserve">
    <value>This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module.</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElement" xml:space="preserve">
    <value>This attribute is not valid for use on this language element</value>
  </data>
  <data name="tcOptionalArgumentsCannotBeUsedInCustomAttribute" xml:space="preserve">
    <value>Optional arguments cannot be used in custom attributes</value>
  </data>
  <data name="tcPropertyCannotBeSet0" xml:space="preserve">
    <value>This property cannot be set</value>
  </data>
  <data name="tcPropertyOrFieldNotFoundInAttribute" xml:space="preserve">
    <value>This property or field was not found on this custom attribute type</value>
  </data>
  <data name="tcCustomAttributeMustBeReferenceType" xml:space="preserve">
    <value>A custom attribute must be a reference type</value>
  </data>
  <data name="tcCustomAttributeArgumentMismatch" xml:space="preserve">
    <value>The number of args for a custom attribute does not match the expected number of args for the attribute constructor</value>
  </data>
  <data name="tcCustomAttributeMustInvokeConstructor" xml:space="preserve">
    <value>A custom attribute must invoke an object constructor</value>
  </data>
  <data name="tcAttributeExpressionsMustBeConstructorCalls" xml:space="preserve">
    <value>Attribute expressions must be calls to object constructors</value>
  </data>
  <data name="tcUnsupportedAttribute" xml:space="preserve">
    <value>This attribute cannot be used in this version of F#</value>
  </data>
  <data name="tcInvalidInlineSpecification" xml:space="preserve">
    <value>Invalid inline specification</value>
  </data>
  <data name="tcInvalidUseBinding" xml:space="preserve">
    <value>'use' bindings must be of the form 'use &lt;var&gt; = &lt;expr&gt;'</value>
  </data>
  <data name="tcAbstractMembersIllegalInAugmentation" xml:space="preserve">
    <value>Abstract members are not permitted in an augmentation - they must be defined as part of the type itself</value>
  </data>
  <data name="tcMethodOverridesIllegalHere" xml:space="preserve">
    <value>Method overrides and interface implementations are not permitted here</value>
  </data>
  <data name="tcNoMemberFoundForOverride" xml:space="preserve">
    <value>No abstract or interface member was found that corresponds to this override</value>
  </data>
  <data name="tcOverrideArityMismatch" xml:space="preserve">
    <value>This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:{0}</value>
  </data>
  <data name="tcDefaultImplementationAlreadyExists" xml:space="preserve">
    <value>This method already has a default implementation</value>
  </data>
  <data name="tcDefaultAmbiguous" xml:space="preserve">
    <value>The method implemented by this default is ambiguous</value>
  </data>
  <data name="tcNoPropertyFoundForOverride" xml:space="preserve">
    <value>No abstract property was found that corresponds to this override</value>
  </data>
  <data name="tcAbstractPropertyMissingGetOrSet" xml:space="preserve">
    <value>This property overrides or implements an abstract property but the abstract property doesn't have a corresponding {0}</value>
  </data>
  <data name="tcInvalidSignatureForSet" xml:space="preserve">
    <value>Invalid signature for set member</value>
  </data>
  <data name="tcNewMemberHidesAbstractMember" xml:space="preserve">
    <value>This new member hides the abstract member '{0}'. Rename the member or use 'override' instead.</value>
  </data>
  <data name="tcNewMemberHidesAbstractMemberWithSuffix" xml:space="preserve">
    <value>This new member hides the abstract member '{0}' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead.</value>
  </data>
  <data name="tcStaticInitializersIllegalInInterface" xml:space="preserve">
    <value>Interfaces cannot contain definitions of static initializers</value>
  </data>
  <data name="tcObjectConstructorsIllegalInInterface" xml:space="preserve">
    <value>Interfaces cannot contain definitions of object constructors</value>
  </data>
  <data name="tcMemberOverridesIllegalInInterface" xml:space="preserve">
    <value>Interfaces cannot contain definitions of member overrides</value>
  </data>
  <data name="tcConcreteMembersIllegalInInterface" xml:space="preserve">
    <value>Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.</value>
  </data>
  <data name="tcConstructorsDisallowedInExceptionAugmentation" xml:space="preserve">
    <value>Constructors cannot be specified in exception augmentations</value>
  </data>
  <data name="tcStructsCannotHaveConstructorWithNoArguments" xml:space="preserve">
    <value>Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.</value>
  </data>
  <data name="tcConstructorsIllegalForThisType" xml:space="preserve">
    <value>Constructors cannot be defined for this type</value>
  </data>
  <data name="tcRecursiveBindingsWithMembersMustBeDirectAugmentation" xml:space="preserve">
    <value>Recursive bindings that include member specifications can only occur as a direct augmentation of a type</value>
  </data>
  <data name="tcOnlySimplePatternsInLetRec" xml:space="preserve">
    <value>Only simple variable patterns can be bound in 'let rec' constructs</value>
  </data>
  <data name="tcOnlyRecordFieldsAndSimpleLetCanBeMutable" xml:space="preserve">
    <value>Only record fields and simple, non-recursive 'let' bindings may be marked mutable</value>
  </data>
  <data name="tcMemberIsNotSufficientlyGeneric" xml:space="preserve">
    <value>This member is not sufficiently generic</value>
  </data>
  <data name="tcLiteralAttributeRequiresConstantValue" xml:space="preserve">
    <value>A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. 'val x : int = 1'</value>
  </data>
  <data name="tcValueInSignatureRequiresLiteralAttribute" xml:space="preserve">
    <value>A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute</value>
  </data>
  <data name="tcThreadStaticAndContextStaticMustBeStatic" xml:space="preserve">
    <value>Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread</value>
  </data>
  <data name="tcVolatileFieldsMustBeMutable" xml:space="preserve">
    <value>Volatile fields must be marked 'mutable' and cannot be thread-static</value>
  </data>
  <data name="tcUninitializedValFieldsMustBeMutable" xml:space="preserve">
    <value>Uninitialized 'val' fields must be mutable and marked with the '[&lt;DefaultValue&gt;]' attribute. Consider using a 'let' binding instead of a 'val' field.</value>
  </data>
  <data name="tcStaticValFieldsMustBeMutableAndPrivate" xml:space="preserve">
    <value>Static 'val' fields in types must be mutable, private and marked with the '[&lt;DefaultValue&gt;]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type.</value>
  </data>
  <data name="tcFieldRequiresName" xml:space="preserve">
    <value>This field requires a name</value>
  </data>
  <data name="tcInvalidNamespaceModuleTypeUnionName" xml:space="preserve">
    <value>Invalid namespace, module, type or union case name</value>
  </data>
  <data name="tcIllegalFormForExplicitTypeDeclaration" xml:space="preserve">
    <value>Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -&gt; resTy'. Parentheses may be required around 'resTy'</value>
  </data>
  <data name="tcReturnTypesForUnionMustBeSameAsType" xml:space="preserve">
    <value>Return types of union cases must be identical to the type being defined, up to abbreviations</value>
  </data>
  <data name="tcInvalidEnumerationLiteral" xml:space="preserve">
    <value>This is not a valid value for an enumeration literal</value>
  </data>
  <data name="tcTypeIsNotInterfaceType1" xml:space="preserve">
    <value>The type '{0}' is not an interface type</value>
  </data>
  <data name="tcDuplicateSpecOfInterface" xml:space="preserve">
    <value>Duplicate specification of an interface</value>
  </data>
  <data name="tcFieldValIllegalHere" xml:space="preserve">
    <value>A field/val declaration is not permitted here</value>
  </data>
  <data name="tcInheritIllegalHere" xml:space="preserve">
    <value>A inheritance declaration is not permitted here</value>
  </data>
  <data name="tcModuleRequiresQualifiedAccess" xml:space="preserve">
    <value>This declaration opens the module '{0}', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.</value>
  </data>
  <data name="tcOpenUsedWithPartiallyQualifiedPath" xml:space="preserve">
    <value>This declaration opens the namespace or module '{0}' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.</value>
  </data>
  <data name="tcLocalClassBindingsCannotBeInline" xml:space="preserve">
    <value>Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.</value>
  </data>
  <data name="tcTypeAbbreviationsMayNotHaveMembers" xml:space="preserve">
    <value>Type abbreviations cannot have members</value>
  </data>
  <data name="tcTypeAbbreviationsCheckedAtCompileTime" xml:space="preserve">
    <value>As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.</value>
  </data>
  <data name="tcEnumerationsMayNotHaveMembers" xml:space="preserve">
    <value>Enumerations cannot have members</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembers" xml:space="preserve">
    <value>Measure declarations may have only static members</value>
  </data>
  <data name="tcStructsMayNotContainDoBindings" xml:space="preserve">
    <value>Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings</value>
  </data>
  <data name="tcStructsMayNotContainLetBindings" xml:space="preserve">
    <value>Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.</value>
  </data>
  <data name="tcStaticLetBindingsRequireClassesWithImplicitConstructors" xml:space="preserve">
    <value>Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembersNotConstructors" xml:space="preserve">
    <value>Measure declarations may have only static members: constructors are not available</value>
  </data>
  <data name="tcMemberAndLocalClassBindingHaveSameName" xml:space="preserve">
    <value>A member and a local class binding both have the name '{0}'</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Type abbreviations cannot have interface declarations</value>
  </data>
  <data name="tcEnumerationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Enumerations cannot have interface declarations</value>
  </data>
  <data name="tcTypeIsNotInterfaceType0" xml:space="preserve">
    <value>This type is not an interface type</value>
  </data>
  <data name="tcAllImplementedInterfacesShouldBeDeclared" xml:space="preserve">
    <value>All implemented interfaces should be declared on the initial declaration of the type</value>
  </data>
  <data name="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded" xml:space="preserve">
    <value>A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type</value>
  </data>
  <data name="tcMemberNotPermittedInInterfaceImplementation" xml:space="preserve">
    <value>This member is not permitted in an interface implementation</value>
  </data>
  <data name="tcDeclarationElementNotPermittedInAugmentation" xml:space="preserve">
    <value>This declaration element is not permitted in an augmentation</value>
  </data>
  <data name="tcTypesCannotContainNestedTypes" xml:space="preserve">
    <value>Types cannot contain nested type definitions</value>
  </data>
  <data name="tcTypeExceptionOrModule" xml:space="preserve">
    <value>type, exception or module</value>
  </data>
  <data name="tcTypeOrModule" xml:space="preserve">
    <value>type or module</value>
  </data>
  <data name="tcImplementsIStructuralEquatableExplicitly" xml:space="preserve">
    <value>The struct, record or union type '{0}' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type.</value>
  </data>
  <data name="tcImplementsIEquatableExplicitly" xml:space="preserve">
    <value>The struct, record or union type '{0}' implements the interface 'System.IEquatable&lt;_&gt;' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'.</value>
  </data>
  <data name="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors" xml:space="preserve">
    <value>Explicit type specifications cannot be used for exception constructors</value>
  </data>
  <data name="tcExceptionAbbreviationsShouldNotHaveArgumentList" xml:space="preserve">
    <value>Exception abbreviations should not have argument lists</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsCannotTakeArguments" xml:space="preserve">
    <value>Abbreviations for Common IL exceptions cannot take arguments</value>
  </data>
  <data name="tcExceptionAbbreviationsMustReferToValidExceptions" xml:space="preserve">
    <value>Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor" xml:space="preserve">
    <value>Abbreviations for Common IL exception types must have a matching object constructor</value>
  </data>
  <data name="tcNotAnException" xml:space="preserve">
    <value>Not an exception</value>
  </data>
  <data name="tcInvalidModuleName" xml:space="preserve">
    <value>Invalid module name</value>
  </data>
  <data name="tcInvalidTypeExtension" xml:space="preserve">
    <value>Invalid type extension</value>
  </data>
  <data name="tcAttributesOfTypeSpecifyMultipleKindsForType" xml:space="preserve">
    <value>The attributes of this type specify multiple kinds for the type</value>
  </data>
  <data name="tcKindOfTypeSpecifiedDoesNotMatchDefinition" xml:space="preserve">
    <value>The kind of the type specified by its attributes does not match the kind implied by its definition</value>
  </data>
  <data name="tcMeasureDefinitionsCannotHaveTypeParameters" xml:space="preserve">
    <value>Measure definitions cannot have type parameters</value>
  </data>
  <data name="tcTypeRequiresDefinition" xml:space="preserve">
    <value>This type requires a definition</value>
  </data>
  <data name="tcTypeAbbreviationHasTypeParametersMissingOnType" xml:space="preserve">
    <value>This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C&lt;'a&gt; = C of ...'.</value>
  </data>
  <data name="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes" xml:space="preserve">
    <value>Structs, interfaces, enums and delegates cannot inherit from other types</value>
  </data>
  <data name="tcTypesCannotInheritFromMultipleConcreteTypes" xml:space="preserve">
    <value>Types cannot inherit from multiple concrete types</value>
  </data>
  <data name="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute" xml:space="preserve">
    <value>Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute</value>
  </data>
  <data name="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes" xml:space="preserve">
    <value>Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal</value>
  </data>
  <data name="tcGenericTypesCannotHaveStructLayout" xml:space="preserve">
    <value>Generic types cannot be given the 'StructLayout' attribute</value>
  </data>
  <data name="tcOnlyStructsCanHaveStructLayout" xml:space="preserve">
    <value>Only structs and classes without primary constructors may be given the 'StructLayout' attribute</value>
  </data>
  <data name="tcRepresentationOfTypeHiddenBySignature" xml:space="preserve">
    <value>The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.</value>
  </data>
  <data name="tcOnlyClassesCanHaveAbstract" xml:space="preserve">
    <value>Only classes may be given the 'AbstractClass' attribute</value>
  </data>
  <data name="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure" xml:space="preserve">
    <value>Only types representing units-of-measure may be given the 'Measure' attribute</value>
  </data>
  <data name="tcOverridesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Accessibility modifiers are not permitted on overrides or interface implementations</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDU" xml:space="preserve">
    <value>Discriminated union types are always sealed</value>
  </data>
  <data name="tcTypesAreAlwaysSealedRecord" xml:space="preserve">
    <value>Record types are always sealed</value>
  </data>
  <data name="tcTypesAreAlwaysSealedAssemblyCode" xml:space="preserve">
    <value>Assembly code types are always sealed</value>
  </data>
  <data name="tcTypesAreAlwaysSealedStruct" xml:space="preserve">
    <value>Struct types are always sealed</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDelegate" xml:space="preserve">
    <value>Delegate types are always sealed</value>
  </data>
  <data name="tcTypesAreAlwaysSealedEnum" xml:space="preserve">
    <value>Enum types are always sealed</value>
  </data>
  <data name="tcInterfaceTypesAndDelegatesCannotContainFields" xml:space="preserve">
    <value>Interface types and delegate types cannot contain fields</value>
  </data>
  <data name="tcAbbreviatedTypesCannotBeSealed" xml:space="preserve">
    <value>Abbreviated types cannot be given the 'Sealed' attribute</value>
  </data>
  <data name="tcCannotInheritFromSealedType" xml:space="preserve">
    <value>Cannot inherit a sealed type</value>
  </data>
  <data name="tcCannotInheritFromInterfaceType" xml:space="preserve">
    <value>Cannot inherit from interface type. Use interface ... with instead.</value>
  </data>
  <data name="tcStructTypesCannotContainAbstractMembers" xml:space="preserve">
    <value>Struct types cannot contain abstract members</value>
  </data>
  <data name="tcInterfaceTypesCannotBeSealed" xml:space="preserve">
    <value>Interface types cannot be sealed</value>
  </data>
  <data name="tcInvalidDelegateSpecification" xml:space="preserve">
    <value>Delegate specifications must be of the form 'typ -&gt; typ'</value>
  </data>
  <data name="tcDelegatesCannotBeCurried" xml:space="preserve">
    <value>Delegate specifications must not be curried types. Use 'typ * ... * typ -&gt; typ' for multi-argument delegates, and 'typ -&gt; (typ -&gt; typ)' for delegates returning function values.</value>
  </data>
  <data name="tcInvalidTypeForLiteralEnumeration" xml:space="preserve">
    <value>Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char</value>
  </data>
  <data name="tcTypeDefinitionIsCyclic" xml:space="preserve">
    <value>This type definition involves an immediate cyclic reference through an abbreviation</value>
  </data>
  <data name="tcTypeDefinitionIsCyclicThroughInheritance" xml:space="preserve">
    <value>This type definition involves an immediate cyclic reference through a struct field or inheritance relation</value>
  </data>
  <data name="tcReservedSyntaxForAugmentation" xml:space="preserve">
    <value>The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[&lt;Sealed&gt;] attribute to the type definition in the signature</value>
  </data>
  <data name="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule" xml:space="preserve">
    <value>Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.</value>
  </data>
  <data name="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal" xml:space="preserve">
    <value>One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '{0}'</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit" xml:space="preserve">
    <value>Type definitions may only have one 'inherit' specification and it must be the first declaration</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers" xml:space="preserve">
    <value>'let' and 'do' bindings must come before member and interface definitions in type definitions</value>
  </data>
  <data name="tcInheritDeclarationMissingArguments" xml:space="preserve">
    <value>This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'.</value>
  </data>
  <data name="tcInheritConstructionCallNotPartOfImplicitSequence" xml:space="preserve">
    <value>This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</value>
  </data>
  <data name="tcLetAndDoRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveAugmentations" xml:space="preserve">
    <value>Type abbreviations cannot have augmentations</value>
  </data>
  <data name="tcModuleAbbreviationForNamespace" xml:space="preserve">
    <value>The path '{0}' is a namespace. A module abbreviation may not abbreviate a namespace.</value>
  </data>
  <data name="tcTypeUsedInInvalidWay" xml:space="preserve">
    <value>The type '{0}' is used in an invalid way. A value prior to '{1}' has an inferred type involving '{2}', which is an invalid forward reference.</value>
  </data>
  <data name="tcMemberUsedInInvalidWay" xml:space="preserve">
    <value>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to the definition of '{2}', which is an invalid forward reference.</value>
  </data>
  <data name="tcAttributeAutoOpenWasIgnored" xml:space="preserve">
    <value>The attribute 'AutoOpen(\"{0}\")' in the assembly '{1}' did not refer to a valid module or namespace in that assembly and has been ignored</value>
  </data>
  <data name="ilUndefinedValue" xml:space="preserve">
    <value>Undefined value '{0}'</value>
  </data>
  <data name="ilLabelNotFound" xml:space="preserve">
    <value>Label {0} not found</value>
  </data>
  <data name="ilIncorrectNumberOfTypeArguments" xml:space="preserve">
    <value>Incorrect number of type arguments to local call</value>
  </data>
  <data name="ilDynamicInvocationNotSupported" xml:space="preserve">
    <value>Dynamic invocation of {0} is not supported</value>
  </data>
  <data name="ilAddressOfLiteralFieldIsInvalid" xml:space="preserve">
    <value>Taking the address of a literal field is invalid</value>
  </data>
  <data name="ilAddressOfValueHereIsInvalid" xml:space="preserve">
    <value>This operation involves taking the address of a value '{0}' represented using a local variable or other special representation. This is invalid.</value>
  </data>
  <data name="ilCustomMarshallersCannotBeUsedInFSharp" xml:space="preserve">
    <value>Custom marshallers cannot be specified in F# code. Consider using a C# helper function.</value>
  </data>
  <data name="ilMarshalAsAttributeCannotBeDecoded" xml:space="preserve">
    <value>The MarshalAs attribute could not be decoded</value>
  </data>
  <data name="ilSignatureForExternalFunctionContainsTypeParameters" xml:space="preserve">
    <value>The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.</value>
  </data>
  <data name="ilDllImportAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>The DllImport attribute could not be decoded</value>
  </data>
  <data name="ilLiteralFieldsCannotBeSet" xml:space="preserve">
    <value>Literal fields cannot be set</value>
  </data>
  <data name="ilStaticMethodIsNotLambda" xml:space="preserve">
    <value>GenSetStorage: {0} was represented as a static method but was not an appropriate lambda expression</value>
  </data>
  <data name="ilMutableVariablesCannotEscapeMethod" xml:space="preserve">
    <value>Mutable variables cannot escape their method</value>
  </data>
  <data name="ilUnexpectedUnrealizedValue" xml:space="preserve">
    <value>Compiler error: unexpected unrealized value</value>
  </data>
  <data name="ilMainModuleEmpty" xml:space="preserve">
    <value>Main module of program is empty: nothing will happen when it is run</value>
  </data>
  <data name="ilTypeCannotBeUsedForLiteralField" xml:space="preserve">
    <value>This type cannot be used for a literal field</value>
  </data>
  <data name="ilUnexpectedGetSetAnnotation" xml:space="preserve">
    <value>Unexpected GetSet annotation on a property</value>
  </data>
  <data name="ilFieldOffsetAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>The FieldOffset attribute could not be decoded</value>
  </data>
  <data name="ilStructLayoutAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>The StructLayout attribute could not be decoded</value>
  </data>
  <data name="ilDefaultAugmentationAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>The DefaultAugmentation attribute could not be decoded</value>
  </data>
  <data name="ilReflectedDefinitionsCannotUseSliceOperator" xml:space="preserve">
    <value>Reflected definitions cannot contain uses of the prefix splice operator '%'</value>
  </data>
  <data name="optsProblemWithCodepage" xml:space="preserve">
    <value>Problem with codepage '{0}': {1}</value>
  </data>
  <data name="optsCopyright" xml:space="preserve">
    <value>Copyright (c) Microsoft Corporation. All Rights Reserved.</value>
  </data>
  <data name="optsCopyrightCommunity" xml:space="preserve">
    <value>Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</value>
  </data>
  <data name="optsNameOfOutputFile" xml:space="preserve">
    <value>Name of the output file (Short form: -o)</value>
  </data>
  <data name="optsBuildConsole" xml:space="preserve">
    <value>Build a console executable</value>
  </data>
  <data name="optsBuildWindows" xml:space="preserve">
    <value>Build a Windows executable</value>
  </data>
  <data name="optsBuildLibrary" xml:space="preserve">
    <value>Build a library (Short form: -a)</value>
  </data>
  <data name="optsBuildModule" xml:space="preserve">
    <value>Build a module that can be added to another assembly</value>
  </data>
  <data name="optsDelaySign" xml:space="preserve">
    <value>Delay-sign the assembly using only the public portion of the strong name key</value>
  </data>
  <data name="optsPublicSign" xml:space="preserve">
    <value>Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed</value>
  </data>
  <data name="optsWriteXml" xml:space="preserve">
    <value>Write the xmldoc of the assembly to the given file</value>
  </data>
  <data name="optsStrongKeyFile" xml:space="preserve">
    <value>Specify a strong name key file</value>
  </data>
  <data name="optsStrongKeyContainer" xml:space="preserve">
    <value>Specify a strong name key container</value>
  </data>
  <data name="optsPlatform" xml:space="preserve">
    <value>Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.</value>
  </data>
  <data name="optsNoOpt" xml:space="preserve">
    <value>Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.</value>
  </data>
  <data name="optsNoInterface" xml:space="preserve">
    <value>Don't add a resource to the generated assembly containing F#-specific metadata</value>
  </data>
  <data name="optsSig" xml:space="preserve">
    <value>Print the inferred interface of the assembly to a file</value>
  </data>
  <data name="optsReference" xml:space="preserve">
    <value>Reference an assembly (Short form: -r)</value>
  </data>
  <data name="optsWin32res" xml:space="preserve">
    <value>Specify a Win32 resource file (.res)</value>
  </data>
  <data name="optsWin32manifest" xml:space="preserve">
    <value>Specify a Win32 manifest file</value>
  </data>
  <data name="optsNowin32manifest" xml:space="preserve">
    <value>Do not include the default Win32 manifest</value>
  </data>
  <data name="optsEmbedAllSource" xml:space="preserve">
    <value>Embed all source files in the portable PDB file</value>
  </data>
  <data name="optsEmbedSource" xml:space="preserve">
    <value>Embed specific source files in the portable PDB file</value>
  </data>
  <data name="optsSourceLink" xml:space="preserve">
    <value>Source link information file to embed in the portable PDB file</value>
  </data>
  <data name="optsEmbeddedSourceRequirePortablePDBs" xml:space="preserve">
    <value>--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</value>
  </data>
  <data name="optsSourceLinkRequirePortablePDBs" xml:space="preserve">
    <value>--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</value>
  </data>
  <data name="srcFileTooLarge" xml:space="preserve">
    <value>Source file is too large to embed in a portable PDB</value>
  </data>
  <data name="optsResource" xml:space="preserve">
    <value>Embed the specified managed resource</value>
  </data>
  <data name="optsLinkresource" xml:space="preserve">
    <value>Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]</value>
  </data>
  <data name="optsDebugPM" xml:space="preserve">
    <value>Emit debug information (Short form: -g)</value>
  </data>
  <data name="optsDebug" xml:space="preserve">
    <value>Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file).</value>
  </data>
  <data name="optsOptimize" xml:space="preserve">
    <value>Enable optimizations (Short form: -O)</value>
  </data>
  <data name="optsTailcalls" xml:space="preserve">
    <value>Enable or disable tailcalls</value>
  </data>
  <data name="optsDeterministic" xml:space="preserve">
    <value>Produce a deterministic assembly (including module version GUID and timestamp)</value>
  </data>
  <data name="optsCrossoptimize" xml:space="preserve">
    <value>Enable or disable cross-module optimizations</value>
  </data>
  <data name="optsWarnaserrorPM" xml:space="preserve">
    <value>Report all warnings as errors</value>
  </data>
  <data name="optsWarnaserror" xml:space="preserve">
    <value>Report specific warnings as errors</value>
  </data>
  <data name="optsWarn" xml:space="preserve">
    <value>Set a warning level (0-5)</value>
  </data>
  <data name="optsNowarn" xml:space="preserve">
    <value>Disable specific warning messages</value>
  </data>
  <data name="optsWarnOn" xml:space="preserve">
    <value>Enable specific warnings that may be off by default</value>
  </data>
  <data name="optsChecked" xml:space="preserve">
    <value>Generate overflow checks</value>
  </data>
  <data name="optsDefine" xml:space="preserve">
    <value>Define conditional compilation symbols (Short form: -d)</value>
  </data>
  <data name="optsMlcompatibility" xml:space="preserve">
    <value>Ignore ML compatibility warnings</value>
  </data>
  <data name="optsNologo" xml:space="preserve">
    <value>Suppress compiler copyright message</value>
  </data>
  <data name="optsHelp" xml:space="preserve">
    <value>Display this usage message (Short form: -?)</value>
  </data>
  <data name="optsResponseFile" xml:space="preserve">
    <value>Read response file for more options</value>
  </data>
  <data name="optsCodepage" xml:space="preserve">
    <value>Specify the codepage used to read source files</value>
  </data>
  <data name="optsUtf8output" xml:space="preserve">
    <value>Output messages in UTF-8 encoding</value>
  </data>
  <data name="optsFullpaths" xml:space="preserve">
    <value>Output messages with fully qualified paths</value>
  </data>
  <data name="optsLib" xml:space="preserve">
    <value>Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)</value>
  </data>
  <data name="optsBaseaddress" xml:space="preserve">
    <value>Base address for the library to be built</value>
  </data>
  <data name="optsNoframework" xml:space="preserve">
    <value>Do not reference the default CLI assemblies by default</value>
  </data>
  <data name="optsStandalone" xml:space="preserve">
    <value>Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated</value>
  </data>
  <data name="optsStaticlink" xml:space="preserve">
    <value>Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.</value>
  </data>
  <data name="optsResident" xml:space="preserve">
    <value>Use a resident background compilation service to improve compiler startup times.</value>
  </data>
  <data name="optsPdb" xml:space="preserve">
    <value>Name the output debug file</value>
  </data>
  <data name="optsSimpleresolution" xml:space="preserve">
    <value>Resolve assembly references using directory-based rules rather than MSBuild resolution</value>
  </data>
  <data name="optsUnrecognizedTarget" xml:space="preserve">
    <value>Unrecognized target '{0}', expected 'exe', 'winexe', 'library' or 'module'</value>
  </data>
  <data name="optsUnrecognizedDebugType" xml:space="preserve">
    <value>Unrecognized debug type '{0}', expected 'pdbonly' or 'full'</value>
  </data>
  <data name="optsInvalidWarningLevel" xml:space="preserve">
    <value>Invalid warning level '{0}'</value>
  </data>
  <data name="optsShortFormOf" xml:space="preserve">
    <value>Short form of '{0}'</value>
  </data>
  <data name="optsClirootDeprecatedMsg" xml:space="preserve">
    <value>The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.</value>
  </data>
  <data name="optsClirootDescription" xml:space="preserve">
    <value>Use to override where the compiler looks for mscorlib.dll and framework components</value>
  </data>
  <data name="optsHelpBannerOutputFiles" xml:space="preserve">
    <value>- OUTPUT FILES -</value>
  </data>
  <data name="optsHelpBannerInputFiles" xml:space="preserve">
    <value>- INPUT FILES -</value>
  </data>
  <data name="optsHelpBannerResources" xml:space="preserve">
    <value>- RESOURCES -</value>
  </data>
  <data name="optsHelpBannerCodeGen" xml:space="preserve">
    <value>- CODE GENERATION -</value>
  </data>
  <data name="optsHelpBannerAdvanced" xml:space="preserve">
    <value>- ADVANCED -</value>
  </data>
  <data name="optsHelpBannerMisc" xml:space="preserve">
    <value>- MISCELLANEOUS -</value>
  </data>
  <data name="optsHelpBannerLanguage" xml:space="preserve">
    <value>- LANGUAGE -</value>
  </data>
  <data name="optsHelpBannerErrsAndWarns" xml:space="preserve">
    <value>- ERRORS AND WARNINGS -</value>
  </data>
  <data name="optsUnknownArgumentToTheTestSwitch" xml:space="preserve">
    <value>Unknown --test argument: '{0}'</value>
  </data>
  <data name="optsUnknownPlatform" xml:space="preserve">
    <value>Unrecognized platform '{0}', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'</value>
  </data>
  <data name="optsInternalNoDescription" xml:space="preserve">
    <value>The command-line option '{0}' is for test purposes only</value>
  </data>
  <data name="optsDCLONoDescription" xml:space="preserve">
    <value>The command-line option '{0}' has been deprecated</value>
  </data>
  <data name="optsDCLODeprecatedSuggestAlternative" xml:space="preserve">
    <value>The command-line option '{0}' has been deprecated. Use '{1}' instead.</value>
  </data>
  <data name="optsDCLOHtmlDoc" xml:space="preserve">
    <value>The command-line option '{0}' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.</value>
  </data>
  <data name="optsConsoleColors" xml:space="preserve">
    <value>Output warning and error messages in color</value>
  </data>
  <data name="optsUseHighEntropyVA" xml:space="preserve">
    <value>Enable high-entropy ASLR</value>
  </data>
  <data name="optsSubSystemVersion" xml:space="preserve">
    <value>Specify subsystem version of this assembly</value>
  </data>
  <data name="optsTargetProfile" xml:space="preserve">
    <value>Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib</value>
  </data>
  <data name="optsEmitDebugInfoInQuotations" xml:space="preserve">
    <value>Emit debug information in quotations</value>
  </data>
  <data name="optsPreferredUiLang" xml:space="preserve">
    <value>Specify the preferred output language culture name (e.g. es-ES, ja-JP)</value>
  </data>
  <data name="optsNoCopyFsharpCore" xml:space="preserve">
    <value>Don't copy FSharp.Core.dll along the produced binaries</value>
  </data>
  <data name="optsInvalidSubSystemVersion" xml:space="preserve">
    <value>Invalid version '{0}' for '--subsystemversion'. The version must be 4.00 or greater.</value>
  </data>
  <data name="optsInvalidTargetProfile" xml:space="preserve">
    <value>Invalid value '{0}' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.</value>
  </data>
  <data name="typeInfoFullName" xml:space="preserve">
    <value>Full name</value>
  </data>
  <data name="typeInfoOtherOverloads" xml:space="preserve">
    <value>and {0} other overloads</value>
  </data>
  <data name="typeInfoUnionCase" xml:space="preserve">
    <value>union case</value>
  </data>
  <data name="typeInfoActivePatternResult" xml:space="preserve">
    <value>active pattern result</value>
  </data>
  <data name="typeInfoActiveRecognizer" xml:space="preserve">
    <value>active recognizer</value>
  </data>
  <data name="typeInfoField" xml:space="preserve">
    <value>field</value>
  </data>
  <data name="typeInfoEvent" xml:space="preserve">
    <value>event</value>
  </data>
  <data name="typeInfoProperty" xml:space="preserve">
    <value>property</value>
  </data>
  <data name="typeInfoExtension" xml:space="preserve">
    <value>extension</value>
  </data>
  <data name="typeInfoCustomOperation" xml:space="preserve">
    <value>custom operation</value>
  </data>
  <data name="typeInfoArgument" xml:space="preserve">
    <value>argument</value>
  </data>
  <data name="typeInfoPatternVariable" xml:space="preserve">
    <value>patvar</value>
  </data>
  <data name="typeInfoNamespace" xml:space="preserve">
    <value>namespace</value>
  </data>
  <data name="typeInfoModule" xml:space="preserve">
    <value>module</value>
  </data>
  <data name="typeInfoNamespaceOrModule" xml:space="preserve">
    <value>namespace/module</value>
  </data>
  <data name="typeInfoFromFirst" xml:space="preserve">
    <value>from {0}</value>
  </data>
  <data name="typeInfoFromNext" xml:space="preserve">
    <value>also from {0}</value>
  </data>
  <data name="typeInfoGeneratedProperty" xml:space="preserve">
    <value>generated property</value>
  </data>
  <data name="typeInfoGeneratedType" xml:space="preserve">
    <value>generated type</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersKey" xml:space="preserve">
    <value>Found by AssemblyFolders registry key</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersExKey" xml:space="preserve">
    <value>Found by AssemblyFoldersEx registry key</value>
  </data>
  <data name="assemblyResolutionNetFramework" xml:space="preserve">
    <value>.NET Framework</value>
  </data>
  <data name="assemblyResolutionGAC" xml:space="preserve">
    <value>Global Assembly Cache</value>
  </data>
  <data name="recursiveClassHierarchy" xml:space="preserve">
    <value>Recursive class hierarchy in type '{0}'</value>
  </data>
  <data name="InvalidRecursiveReferenceToAbstractSlot" xml:space="preserve">
    <value>Invalid recursive reference to an abstract slot</value>
  </data>
  <data name="eventHasNonStandardType" xml:space="preserve">
    <value>The event '{0}' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit {1} and {2} methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent&lt;_&gt;' or 'IEvent&lt;_,_&gt;'.</value>
  </data>
  <data name="typeIsNotAccessible" xml:space="preserve">
    <value>The type '{0}' is not accessible from this code location</value>
  </data>
  <data name="unionCasesAreNotAccessible" xml:space="preserve">
    <value>The union cases or fields of the type '{0}' are not accessible from this code location</value>
  </data>
  <data name="valueIsNotAccessible" xml:space="preserve">
    <value>The value '{0}' is not accessible from this code location</value>
  </data>
  <data name="unionCaseIsNotAccessible" xml:space="preserve">
    <value>The union case '{0}' is not accessible from this code location</value>
  </data>
  <data name="fieldIsNotAccessible" xml:space="preserve">
    <value>The record, struct or class field '{0}' is not accessible from this code location</value>
  </data>
  <data name="structOrClassFieldIsNotAccessible" xml:space="preserve">
    <value>The struct or class field '{0}' is not accessible from this code location</value>
  </data>
  <data name="experimentalConstruct" xml:space="preserve">
    <value>This construct is experimental</value>
  </data>
  <data name="noInvokeMethodsFound" xml:space="preserve">
    <value>No Invoke methods found for delegate type</value>
  </data>
  <data name="moreThanOneInvokeMethodFound" xml:space="preserve">
    <value>More than one Invoke method found for delegate type</value>
  </data>
  <data name="delegatesNotAllowedToHaveCurriedSignatures" xml:space="preserve">
    <value>Delegates are not allowed to have curried signatures</value>
  </data>
  <data name="tlrUnexpectedTExpr" xml:space="preserve">
    <value>Unexpected Expr.TyChoose</value>
  </data>
  <data name="tlrLambdaLiftingOptimizationsNotApplied" xml:space="preserve">
    <value>Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.</value>
  </data>
  <data name="lexhlpIdentifiersContainingAtSymbolReserved" xml:space="preserve">
    <value>Identifiers containing '@' are reserved for use in F# code generation</value>
  </data>
  <data name="lexhlpIdentifierReserved" xml:space="preserve">
    <value>The identifier '{0}' is reserved for future use by F#</value>
  </data>
  <data name="patcMissingVariable" xml:space="preserve">
    <value>Missing variable '{0}'</value>
  </data>
  <data name="patcPartialActivePatternsGenerateOneResult" xml:space="preserve">
    <value>Partial active patterns may only generate one result</value>
  </data>
  <data name="impTypeRequiredUnavailable" xml:space="preserve">
    <value>The type '{0}' is required here and is unavailable. You must add a reference to assembly '{1}'.</value>
  </data>
  <data name="impReferencedTypeCouldNotBeFoundInAssembly" xml:space="preserve">
    <value>A reference to the type '{0}' in assembly '{1}' was found, but the type could not be found in that assembly</value>
  </data>
  <data name="impNotEnoughTypeParamsInScopeWhileImporting" xml:space="preserve">
    <value>Internal error or badly formed metadata: not enough type parameters were in scope while importing</value>
  </data>
  <data name="impReferenceToDllRequiredByAssembly" xml:space="preserve">
    <value>A reference to the DLL {0} is required by assembly {1}. The imported type {2} is located in the first assembly and could not be resolved.</value>
  </data>
  <data name="impImportedAssemblyUsesNotPublicType" xml:space="preserve">
    <value>An imported assembly uses the type '{0}' but that type is not public</value>
  </data>
  <data name="optValueMarkedInlineButIncomplete" xml:space="preserve">
    <value>The value '{0}' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible</value>
  </data>
  <data name="optValueMarkedInlineButWasNotBoundInTheOptEnv" xml:space="preserve">
    <value>The value '{0}' was marked inline but was not bound in the optimization environment</value>
  </data>
  <data name="optLocalValueNotFoundDuringOptimization" xml:space="preserve">
    <value>Local value {0} not found during optimization</value>
  </data>
  <data name="optValueMarkedInlineHasUnexpectedValue" xml:space="preserve">
    <value>A value marked as 'inline' has an unexpected value</value>
  </data>
  <data name="optValueMarkedInlineCouldNotBeInlined" xml:space="preserve">
    <value>A value marked as 'inline' could not be inlined</value>
  </data>
  <data name="optFailedToInlineValue" xml:space="preserve">
    <value>Failed to inline the value '{0}' marked 'inline', perhaps because a recursive value was marked 'inline'</value>
  </data>
  <data name="optRecursiveValValue" xml:space="preserve">
    <value>Recursive ValValue {0}</value>
  </data>
  <data name="lexfltIncorrentIndentationOfIn" xml:space="preserve">
    <value>The indentation of this 'in' token is incorrect with respect to the corresponding 'let'</value>
  </data>
  <data name="lexfltTokenIsOffsideOfContextStartedEarlier" xml:space="preserve">
    <value>Possible incorrect indentation: this token is offside of context started at position {0}. Try indenting this token further or using standard formatting conventions.</value>
  </data>
  <data name="lexfltSeparatorTokensOfPatternMatchMisaligned" xml:space="preserve">
    <value>The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.</value>
  </data>
  <data name="nrInvalidModuleExprType" xml:space="preserve">
    <value>Invalid module/expression/type</value>
  </data>
  <data name="nrTypeInstantiationNeededToDisambiguateTypesWithSameName" xml:space="preserve">
    <value>Multiple types exist called '{0}', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '{1}'.</value>
  </data>
  <data name="nrTypeInstantiationIsMissingAndCouldNotBeInferred" xml:space="preserve">
    <value>The instantiation of the generic type '{0}' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '{1}'.</value>
  </data>
  <data name="nrGlobalUsedOnlyAsFirstName" xml:space="preserve">
    <value>'global' may only be used as the first name in a qualified path</value>
  </data>
  <data name="nrIsNotConstructorOrLiteral" xml:space="preserve">
    <value>This is not a constructor or literal, or a constructor is being used incorrectly</value>
  </data>
  <data name="nrUnexpectedEmptyLongId" xml:space="preserve">
    <value>Unexpected empty long identifier</value>
  </data>
  <data name="nrRecordDoesNotContainSuchLabel" xml:space="preserve">
    <value>The record type '{0}' does not contain a label '{1}'.</value>
  </data>
  <data name="nrInvalidFieldLabel" xml:space="preserve">
    <value>Invalid field label</value>
  </data>
  <data name="nrInvalidExpression" xml:space="preserve">
    <value>Invalid expression '{0}'</value>
  </data>
  <data name="nrNoConstructorsAvailableForType" xml:space="preserve">
    <value>No constructors are available for the type '{0}'</value>
  </data>
  <data name="nrUnionTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>The union type for union case '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('{1}') in the name you are using.</value>
  </data>
  <data name="nrRecordTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>The record type for the record field '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('{1}') in the name you are using.</value>
  </data>
  <data name="ilwriteErrorCreatingPdb" xml:space="preserve">
    <value>Unexpected error creating debug information file '{0}'</value>
  </data>
  <data name="lexOutsideIntegerRange" xml:space="preserve">
    <value>This number is outside the allowable range for this integer type</value>
  </data>
  <data name="lexCharNotAllowedInOperatorNames" xml:space="preserve">
    <value>'{0}' is not permitted as a character in operator names and is reserved for future use</value>
  </data>
  <data name="lexUnexpectedChar" xml:space="preserve">
    <value>Unexpected character '{0}'</value>
  </data>
  <data name="lexByteArrayCannotEncode" xml:space="preserve">
    <value>This byte array literal contains characters that do not encode as a single byte</value>
  </data>
  <data name="lexIdentEndInMarkReserved" xml:space="preserve">
    <value>Identifiers followed by '{0}' are reserved for future use</value>
  </data>
  <data name="lexOutsideEightBitSigned" xml:space="preserve">
    <value>This number is outside the allowable range for 8-bit signed integers</value>
  </data>
  <data name="lexOutsideEightBitSignedHex" xml:space="preserve">
    <value>This number is outside the allowable range for hexadecimal 8-bit signed integers</value>
  </data>
  <data name="lexOutsideEightBitUnsigned" xml:space="preserve">
    <value>This number is outside the allowable range for 8-bit unsigned integers</value>
  </data>
  <data name="lexOutsideSixteenBitSigned" xml:space="preserve">
    <value>This number is outside the allowable range for 16-bit signed integers</value>
  </data>
  <data name="lexOutsideSixteenBitUnsigned" xml:space="preserve">
    <value>This number is outside the allowable range for 16-bit unsigned integers</value>
  </data>
  <data name="lexOutsideThirtyTwoBitSigned" xml:space="preserve">
    <value>This number is outside the allowable range for 32-bit signed integers</value>
  </data>
  <data name="lexOutsideThirtyTwoBitUnsigned" xml:space="preserve">
    <value>This number is outside the allowable range for 32-bit unsigned integers</value>
  </data>
  <data name="lexOutsideSixtyFourBitSigned" xml:space="preserve">
    <value>This number is outside the allowable range for 64-bit signed integers</value>
  </data>
  <data name="lexOutsideSixtyFourBitUnsigned" xml:space="preserve">
    <value>This number is outside the allowable range for 64-bit unsigned integers</value>
  </data>
  <data name="lexOutsideNativeSigned" xml:space="preserve">
    <value>This number is outside the allowable range for signed native integers</value>
  </data>
  <data name="lexOutsideNativeUnsigned" xml:space="preserve">
    <value>This number is outside the allowable range for unsigned native integers</value>
  </data>
  <data name="lexInvalidFloat" xml:space="preserve">
    <value>Invalid floating point number</value>
  </data>
  <data name="lexOusideDecimal" xml:space="preserve">
    <value>This number is outside the allowable range for decimal literals</value>
  </data>
  <data name="lexOusideThirtyTwoBitFloat" xml:space="preserve">
    <value>This number is outside the allowable range for 32-bit floats</value>
  </data>
  <data name="lexInvalidNumericLiteral" xml:space="preserve">
    <value>This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</value>
  </data>
  <data name="lexInvalidByteLiteral" xml:space="preserve">
    <value>This is not a valid byte literal</value>
  </data>
  <data name="lexInvalidCharLiteral" xml:space="preserve">
    <value>This is not a valid character literal</value>
  </data>
  <data name="lexThisUnicodeOnlyInStringLiterals" xml:space="preserve">
    <value>This Unicode encoding is only valid in string literals</value>
  </data>
  <data name="lexTokenReserved" xml:space="preserve">
    <value>This token is reserved for future use</value>
  </data>
  <data name="lexTabsNotAllowed" xml:space="preserve">
    <value>TABs are not allowed in F# code unless the #indent \"off\" option is used</value>
  </data>
  <data name="lexInvalidLineNumber" xml:space="preserve">
    <value>Invalid line number: '{0}'</value>
  </data>
  <data name="lexHashIfMustBeFirst" xml:space="preserve">
    <value>#if directive must appear as the first non-whitespace character on a line</value>
  </data>
  <data name="lexHashElseNoMatchingIf" xml:space="preserve">
    <value>#else has no matching #if</value>
  </data>
  <data name="lexHashEndifRequiredForElse" xml:space="preserve">
    <value>#endif required for #else</value>
  </data>
  <data name="lexHashElseMustBeFirst" xml:space="preserve">
    <value>#else directive must appear as the first non-whitespace character on a line</value>
  </data>
  <data name="lexHashEndingNoMatchingIf" xml:space="preserve">
    <value>#endif has no matching #if</value>
  </data>
  <data name="lexHashEndifMustBeFirst" xml:space="preserve">
    <value>#endif directive must appear as the first non-whitespace character on a line</value>
  </data>
  <data name="lexHashIfMustHaveIdent" xml:space="preserve">
    <value>#if directive should be immediately followed by an identifier</value>
  </data>
  <data name="lexWrongNestedHashEndif" xml:space="preserve">
    <value>Syntax error. Wrong nested #endif, unexpected tokens before it.</value>
  </data>
  <data name="lexHashBangMustBeFirstInFile" xml:space="preserve">
    <value>#! may only appear as the first line at the start of a file.</value>
  </data>
  <data name="pplexExpectedSingleLineComment" xml:space="preserve">
    <value>Expected single line comment or end of line</value>
  </data>
  <data name="memberOperatorDefinitionWithNoArguments" xml:space="preserve">
    <value>Infix operator member '{0}' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</value>
  </data>
  <data name="memberOperatorDefinitionWithNonPairArgument" xml:space="preserve">
    <value>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</value>
  </data>
  <data name="memberOperatorDefinitionWithCurriedArguments" xml:space="preserve">
    <value>Infix operator member '{0}' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</value>
  </data>
  <data name="tcFSharpCoreRequiresExplicit" xml:space="preserve">
    <value>All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied1" xml:space="preserve">
    <value>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the type parameter '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied2" xml:space="preserve">
    <value>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the component type '{1}' does not satisfy the 'comparison' constraint</value>
  </data>
  <data name="tcNoComparisonNeeded1" xml:space="preserve">
    <value>The struct, record or union type '{0}' is not structurally comparable because the type parameter {1} does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</value>
  </data>
  <data name="tcNoComparisonNeeded2" xml:space="preserve">
    <value>The struct, record or union type '{0}' is not structurally comparable because the type '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</value>
  </data>
  <data name="tcNoEqualityNeeded1" xml:space="preserve">
    <value>The struct, record or union type '{0}' does not support structural equality because the type parameter {1} does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</value>
  </data>
  <data name="tcNoEqualityNeeded2" xml:space="preserve">
    <value>The struct, record or union type '{0}' does not support structural equality because the type '{1}' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied1" xml:space="preserve">
    <value>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the type parameter '{1}' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied2" xml:space="preserve">
    <value>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the component type '{1}' does not satisfy the 'equality' constraint</value>
  </data>
  <data name="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly" xml:space="preserve">
    <value>Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct.</value>
  </data>
  <data name="chkUnusedValue" xml:space="preserve">
    <value>The value '{0}' is unused</value>
  </data>
  <data name="chkUnusedThisVariable" xml:space="preserve">
    <value>The recursive object reference '{0}' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.</value>
  </data>
  <data name="parsGetterAtMostOneArgument" xml:space="preserve">
    <value>A getter property may have at most one argument group</value>
  </data>
  <data name="parsSetterAtMostTwoArguments" xml:space="preserve">
    <value>A setter property may have at most two argument groups</value>
  </data>
  <data name="parsInvalidProperty" xml:space="preserve">
    <value>Invalid property getter or setter</value>
  </data>
  <data name="parsIndexerPropertyRequiresAtLeastOneArgument" xml:space="preserve">
    <value>An indexer property must be given at least one argument</value>
  </data>
  <data name="tastInvalidAddressOfMutableAcrossAssemblyBoundary" xml:space="preserve">
    <value>This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation</value>
  </data>
  <data name="parsNonAdjacentTypars" xml:space="preserve">
    <value>Type parameters must be placed directly adjacent to the type name, e.g. \"type C&lt;'T&gt;\", not     type \"C   &lt;'T&gt;\"</value>
  </data>
  <data name="parsNonAdjacentTyargs" xml:space="preserve">
    <value>Type arguments must be placed directly adjacent to the type name, e.g. \"C&lt;'T&gt;\", not \"C  &lt;'T&gt;\"</value>
  </data>
  <data name="parsNonAtomicType" xml:space="preserve">
    <value>The use of the type syntax 'int C' and 'C  &lt;int&gt;' is not permitted here. Consider adjusting this type to be written in the form 'C&lt;int&gt;'</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespace" xml:space="preserve">
    <value>The module/namespace '{0}' from compilation unit '{1}' did not contain the module/namespace '{2}'</value>
  </data>
  <data name="tastUndefinedItemRefVal" xml:space="preserve">
    <value>The module/namespace '{0}' from compilation unit '{1}' did not contain the val '{2}'</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespaceType" xml:space="preserve">
    <value>The module/namespace '{0}' from compilation unit '{1}' did not contain the namespace, module or type '{2}'</value>
  </data>
  <data name="tcInvalidUseNullAsTrueValue" xml:space="preserve">
    <value>The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case</value>
  </data>
  <data name="tcParameterInferredByref" xml:space="preserve">
    <value>The parameter '{0}' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref&lt;int&gt;'. When used, a byref parameter is implicitly dereferenced.</value>
  </data>
  <data name="tcNonUniformMemberUse" xml:space="preserve">
    <value>The generic member '{0}' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.</value>
  </data>
  <data name="tcAttribArgsDiffer" xml:space="preserve">
    <value>The attribute '{0}' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.</value>
  </data>
  <data name="tcCannotCallAbstractBaseMember" xml:space="preserve">
    <value>Cannot call an abstract base member: '{0}'</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInUnmanaged" xml:space="preserve">
    <value>Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position</value>
  </data>
  <data name="mlCompatMessage" xml:space="preserve">
    <value>This construct is for ML compatibility. {0}. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'.</value>
  </data>
  <data name="ilFieldDoesNotHaveValidOffsetForStructureLayout" xml:space="preserve">
    <value>The type '{0}' has been marked as having an Explicit layout, but the field '{1}' has not been marked with the 'FieldOffset' attribute</value>
  </data>
  <data name="tcInterfacesShouldUseInheritNotInterface" xml:space="preserve">
    <value>Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'</value>
  </data>
  <data name="parsInvalidPrefixOperator" xml:space="preserve">
    <value>Invalid prefix operator</value>
  </data>
  <data name="parsInvalidPrefixOperatorDefinition" xml:space="preserve">
    <value>Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.</value>
  </data>
  <data name="buildCompilingExtensionIsForML" xml:space="preserve">
    <value>The file extensions '.ml' and '.mli' are for ML compatibility</value>
  </data>
  <data name="lexIndentOffForML" xml:space="preserve">
    <value>Consider using a file with extension '.ml' or '.mli' instead</value>
  </data>
  <data name="activePatternIdentIsNotFunctionTyped" xml:space="preserve">
    <value>Active pattern '{0}' is not a function</value>
  </data>
  <data name="activePatternChoiceHasFreeTypars" xml:space="preserve">
    <value>Active pattern '{0}' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</value>
  </data>
  <data name="ilFieldHasOffsetForSequentialLayout" xml:space="preserve">
    <value>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="tcOptionalArgsMustComeAfterNonOptionalArgs" xml:space="preserve">
    <value>Optional arguments must come at the end of the argument list, after any non-optional arguments</value>
  </data>
  <data name="tcConditionalAttributeUsage" xml:space="preserve">
    <value>Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes</value>
  </data>
  <data name="tcMemberOperatorDefinitionInExtrinsic" xml:space="preserve">
    <value>Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.</value>
  </data>
  <data name="ilwriteMDBFileNameCannotBeChangedWarning" xml:space="preserve">
    <value>The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.</value>
  </data>
  <data name="ilwriteMDBMemberMissing" xml:space="preserve">
    <value>MDB generation failed. Could not find compatible member {0}</value>
  </data>
  <data name="ilwriteErrorCreatingMdb" xml:space="preserve">
    <value>Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly.</value>
  </data>
  <data name="tcUnionCaseNameConflictsWithGeneratedType" xml:space="preserve">
    <value>The union case named '{0}' conflicts with the generated type '{1}'</value>
  </data>
  <data name="chkNoReflectedDefinitionOnStructMember" xml:space="preserve">
    <value>ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter</value>
  </data>
  <data name="tcDllImportNotAllowed" xml:space="preserve">
    <value>DLLImport bindings must be static members in a class or function definitions in a module</value>
  </data>
  <data name="buildExplicitCoreLibRequiresNoFramework" xml:space="preserve">
    <value>When mscorlib.dll or FSharp.Core.dll is explicitly referenced the {0} option must also be passed</value>
  </data>
  <data name="buildExpectedSigdataFile" xml:space="preserve">
    <value>FSharp.Core.sigdata not found alongside FSharp.Core. File expected in {0}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</value>
  </data>
  <data name="buildExpectedFileAlongSideFSharpCore" xml:space="preserve">
    <value>File '{0}' not found alongside FSharp.Core. File expected in {1}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</value>
  </data>
  <data name="buildUnexpectedFileNameCharacter" xml:space="preserve">
    <value>Filename '{0}' contains invalid character '{1}'</value>
  </data>
  <data name="tcInvalidUseBangBinding" xml:space="preserve">
    <value>'use!' bindings must be of the form 'use! &lt;var&gt; = &lt;expr&gt;'</value>
  </data>
  <data name="crefNoInnerGenericsInQuotations" xml:space="preserve">
    <value>Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.</value>
  </data>
  <data name="tcEnumTypeCannotBeEnumerated" xml:space="preserve">
    <value>The type '{0}' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property</value>
  </data>
  <data name="parsEofInTripleQuoteString" xml:space="preserve">
    <value>End of file in triple-quote string begun at or before here</value>
  </data>
  <data name="parsEofInTripleQuoteStringInComment" xml:space="preserve">
    <value>End of file in triple-quote string embedded in comment begun at or before here</value>
  </data>
  <data name="tcTypeTestLosesMeasures" xml:space="preserve">
    <value>This type test or downcast will ignore the unit-of-measure '{0}'</value>
  </data>
  <data name="parsMissingTypeArgs" xml:space="preserve">
    <value>Expected type argument or static argument</value>
  </data>
  <data name="parsMissingGreaterThan" xml:space="preserve">
    <value>Unmatched '&lt;'. Expected closing '&gt;'</value>
  </data>
  <data name="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString" xml:space="preserve">
    <value>Unexpected quotation operator '&lt;@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '&lt;' and '@' characters.</value>
  </data>
  <data name="parsErrorParsingAsOperatorName" xml:space="preserve">
    <value>Attempted to parse this as an operator name, but failed</value>
  </data>
  <data name="lexInvalidUnicodeLiteral" xml:space="preserve">
    <value>\U{0} is not a valid Unicode character escape sequence</value>
  </data>
  <data name="tcCallerInfoWrongType" xml:space="preserve">
    <value>'{0}' must be applied to an argument of type '{1}', but has been applied to an argument of type '{2}'</value>
  </data>
  <data name="tcCallerInfoNotOptional" xml:space="preserve">
    <value>'{0}' can only be applied to optional arguments</value>
  </data>
  <data name="toolLocationHelperUnsupportedFrameworkVersion" xml:space="preserve">
    <value>The specified .NET Framework version '{0}' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</value>
  </data>
  <data name="ilSignInvalidMagicValue" xml:space="preserve">
    <value>Invalid Magic value in CLR Header</value>
  </data>
  <data name="ilSignBadImageFormat" xml:space="preserve">
    <value>Bad image format</value>
  </data>
  <data name="ilSignPrivateKeyExpected" xml:space="preserve">
    <value>Private key expected</value>
  </data>
  <data name="ilSignRsaKeyExpected" xml:space="preserve">
    <value>RSA key expected</value>
  </data>
  <data name="ilSignInvalidBitLen" xml:space="preserve">
    <value>Invalid bit Length</value>
  </data>
  <data name="ilSignInvalidRSAParams" xml:space="preserve">
    <value>Invalid RSAParameters structure - '{{0}}' expected</value>
  </data>
  <data name="ilSignInvalidAlgId" xml:space="preserve">
    <value>Invalid algId - 'Exponent' expected</value>
  </data>
  <data name="ilSignInvalidSignatureSize" xml:space="preserve">
    <value>Invalid signature size</value>
  </data>
  <data name="ilSignNoSignatureDirectory" xml:space="preserve">
    <value>No signature directory</value>
  </data>
  <data name="ilSignInvalidPKBlob" xml:space="preserve">
    <value>Invalid Public Key blob</value>
  </data>
  <data name="fscTooManyErrors" xml:space="preserve">
    <value>Exiting - too many errors</value>
  </data>
  <data name="docfileNoXmlSuffix" xml:space="preserve">
    <value>The documentation file has no .xml suffix</value>
  </data>
  <data name="fscNoImplementationFiles" xml:space="preserve">
    <value>No implementation files specified</value>
  </data>
  <data name="fscBadAssemblyVersion" xml:space="preserve">
    <value>The attribute {0} specified version '{1}', but this value is invalid and has been ignored</value>
  </data>
  <data name="fscTwoResourceManifests" xml:space="preserve">
    <value>Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used.</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking" xml:space="preserve">
    <value>The code in assembly '{0}' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking0" xml:space="preserve">
    <value>Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</value>
  </data>
  <data name="fscStaticLinkingNoEXE" xml:space="preserve">
    <value>Static linking may not include a .EXE</value>
  </data>
  <data name="fscStaticLinkingNoMixedDLL" xml:space="preserve">
    <value>Static linking may not include a mixed managed/unmanaged DLL</value>
  </data>
  <data name="fscIgnoringMixedWhenLinking" xml:space="preserve">
    <value>Ignoring mixed managed/unmanaged assembly '{0}' during static linking</value>
  </data>
  <data name="fscAssumeStaticLinkContainsNoDependencies" xml:space="preserve">
    <value>Assembly '{0}' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.</value>
  </data>
  <data name="fscAssemblyNotFoundInDependencySet" xml:space="preserve">
    <value>Assembly '{0}' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.</value>
  </data>
  <data name="fscKeyFileCouldNotBeOpened" xml:space="preserve">
    <value>The key file '{0}' could not be opened</value>
  </data>
  <data name="fscProblemWritingBinary" xml:space="preserve">
    <value>A problem occurred writing the binary '{0}': {1}</value>
  </data>
  <data name="fscAssemblyVersionAttributeIgnored" xml:space="preserve">
    <value>The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option</value>
  </data>
  <data name="fscAssemblyCultureAttributeError" xml:space="preserve">
    <value>Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'</value>
  </data>
  <data name="fscDelaySignWarning" xml:space="preserve">
    <value>Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module</value>
  </data>
  <data name="fscKeyFileWarning" xml:space="preserve">
    <value>Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module</value>
  </data>
  <data name="fscKeyNameWarning" xml:space="preserve">
    <value>Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module</value>
  </data>
  <data name="fscReferenceOnCommandLine" xml:space="preserve">
    <value>The assembly '{0}' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'.</value>
  </data>
  <data name="fscRemotingError" xml:space="preserve">
    <value>The resident compilation service was not used because a problem occured in communicating with the server.</value>
  </data>
  <data name="pathIsInvalid" xml:space="preserve">
    <value>Problem with filename '{0}': Illegal characters in path.</value>
  </data>
  <data name="fscResxSourceFileDeprecated" xml:space="preserve">
    <value>Passing a .resx file ({0}) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.</value>
  </data>
  <data name="fscStaticLinkingNoProfileMismatches" xml:space="preserve">
    <value>Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).</value>
  </data>
  <data name="fscAssemblyWildcardAndDeterminism" xml:space="preserve">
    <value>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</value>
  </data>
  <data name="fscDeterministicDebugRequiresPortablePdb" xml:space="preserve">
    <value>Determinstic builds only support portable PDBs (--debug:portable or --debug:embedded)</value>
  </data>
  <data name="etIllegalCharactersInNamespaceName" xml:space="preserve">
    <value>Character '{0}' is not allowed in provided namespace name '{1}'</value>
  </data>
  <data name="etNullOrEmptyMemberName" xml:space="preserve">
    <value>The provided type '{0}' returned a member with a null or empty member name</value>
  </data>
  <data name="etNullMember" xml:space="preserve">
    <value>The provided type '{0}' returned a null member</value>
  </data>
  <data name="etNullMemberDeclaringType" xml:space="preserve">
    <value>The provided type '{0}' member info '{1}' has null declaring type</value>
  </data>
  <data name="etNullMemberDeclaringTypeDifferentFromProvidedType" xml:space="preserve">
    <value>The provided type '{0}' has member '{1}' which has declaring type '{2}'. Expected declaring type to be the same as provided type.</value>
  </data>
  <data name="etHostingAssemblyFoundWithoutHosts" xml:space="preserve">
    <value>Referenced assembly '{0}' has assembly level attribute '{1}' but no public type provider classes were found</value>
  </data>
  <data name="etEmptyNamespaceOfTypeNotAllowed" xml:space="preserve">
    <value>Type '{0}' from type provider '{1}' has an empty namespace. Use 'null' for the global namespace.</value>
  </data>
  <data name="etEmptyNamespaceNotAllowed" xml:space="preserve">
    <value>Empty namespace found from the type provider '{0}'. Use 'null' for the global namespace.</value>
  </data>
  <data name="etMustNotBeGeneric" xml:space="preserve">
    <value>Provided type '{0}' has 'IsGenericType' as true, but generic types are not supported.</value>
  </data>
  <data name="etMustNotBeAnArray" xml:space="preserve">
    <value>Provided type '{0}' has 'IsArray' as true, but array types are not supported.</value>
  </data>
  <data name="etMethodHasRequirements" xml:space="preserve">
    <value>Invalid member '{0}' on provided type '{1}'. Provided type members must be public, and not be generic, virtual, or abstract.</value>
  </data>
  <data name="etUnsupportedMemberKind" xml:space="preserve">
    <value>Invalid member '{0}' on provided type '{1}'. Only properties, methods and constructors are allowed</value>
  </data>
  <data name="etPropertyCanReadButHasNoGetter" xml:space="preserve">
    <value>Property '{0}' on provided type '{1}' has CanRead=true but there was no value from GetGetMethod()</value>
  </data>
  <data name="etPropertyHasGetterButNoCanRead" xml:space="preserve">
    <value>Property '{0}' on provided type '{1}' has CanRead=false but GetGetMethod() returned a method</value>
  </data>
  <data name="etPropertyCanWriteButHasNoSetter" xml:space="preserve">
    <value>Property '{0}' on provided type '{1}' has CanWrite=true but there was no value from GetSetMethod()</value>
  </data>
  <data name="etPropertyHasSetterButNoCanWrite" xml:space="preserve">
    <value>Property '{0}' on provided type '{1}' has CanWrite=false but GetSetMethod() returned a method</value>
  </data>
  <data name="etOneOrMoreErrorsSeenDuringExtensionTypeSetting" xml:space="preserve">
    <value>One or more errors seen during provided type setup</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedTypeMember" xml:space="preserve">
    <value>Unexpected exception from provided type '{0}' member '{1}': {2}</value>
  </data>
  <data name="etUnsupportedConstantType" xml:space="preserve">
    <value>Unsupported constant type '{0}'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal.</value>
  </data>
  <data name="etUnsupportedProvidedExpression" xml:space="preserve">
    <value>Unsupported expression '{0}' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedName" xml:space="preserve">
    <value>Expected provided type named '{0}' but provided type has 'Name' with value '{1}'</value>
  </data>
  <data name="etEventNoAdd" xml:space="preserve">
    <value>Event '{0}' on provided type '{1}' has no value from GetAddMethod()</value>
  </data>
  <data name="etEventNoRemove" xml:space="preserve">
    <value>Event '{0}' on provided type '{1}' has no value from GetRemoveMethod()</value>
  </data>
  <data name="etProviderHasWrongDesignerAssembly" xml:space="preserve">
    <value>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded or doesn't exist. {2}</value>
  </data>
  <data name="etProviderDoesNotHaveValidConstructor" xml:space="preserve">
    <value>The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected.</value>
  </data>
  <data name="etProviderError" xml:space="preserve">
    <value>The type provider '{0}' reported an error: {1}</value>
  </data>
  <data name="etIncorrectParameterExpression" xml:space="preserve">
    <value>The type provider '{0}' used an invalid parameter in the ParameterExpression: {1}</value>
  </data>
  <data name="etIncorrectProvidedMethod" xml:space="preserve">
    <value>The type provider '{0}' provided a method with a name '{1}' and metadata token '{2}', which is not reported among its methods of its declaring type '{3}'</value>
  </data>
  <data name="etIncorrectProvidedConstructor" xml:space="preserve">
    <value>The type provider '{0}' provided a constructor which is not reported among the constructors of its declaring type '{1}'</value>
  </data>
  <data name="etDirectReferenceToGeneratedTypeNotAllowed" xml:space="preserve">
    <value>A direct reference to the generated type '{0}' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = &lt;path&gt;'. This indicates that a type provider adds generated types to your assembly.</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedPath" xml:space="preserve">
    <value>Expected provided type with path '{0}' but provided type has path '{1}'</value>
  </data>
  <data name="etUnexpectedNullFromProvidedTypeMember" xml:space="preserve">
    <value>Unexpected 'null' return value from provided type '{0}' member '{1}'</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedMemberMember" xml:space="preserve">
    <value>Unexpected exception from member '{0}' of provided type '{1}' member '{2}': {3}</value>
  </data>
  <data name="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters" xml:space="preserve">
    <value>Nested provided types do not take static arguments or generic parameters</value>
  </data>
  <data name="etInvalidStaticArgument" xml:space="preserve">
    <value>Invalid static argument to provided type. Expected an argument of kind '{0}'.</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToType" xml:space="preserve">
    <value>An error occured applying the static arguments to a provided type</value>
  </data>
  <data name="etUnknownStaticArgumentKind" xml:space="preserve">
    <value>Unknown static argument kind '{0}' when resolving a reference to a provided type or method '{1}'</value>
  </data>
  <data name="invalidNamespaceForProvidedType" xml:space="preserve">
    <value>invalid namespace for provided type</value>
  </data>
  <data name="invalidFullNameForProvidedType" xml:space="preserve">
    <value>invalid full name for provided type</value>
  </data>
  <data name="etProviderReturnedNull" xml:space="preserve">
    <value>The type provider returned 'null', which is not a valid return value from '{0}'</value>
  </data>
  <data name="etTypeProviderConstructorException" xml:space="preserve">
    <value>The type provider constructor has thrown an exception: {0}</value>
  </data>
  <data name="etNullProvidedExpression" xml:space="preserve">
    <value>Type provider '{0}' returned null from GetInvokerExpression.</value>
  </data>
  <data name="etProvidedAppliedTypeHadWrongName" xml:space="preserve">
    <value>The type provider '{0}' returned an invalid type from 'ApplyStaticArguments'. A type with name '{1}' was expected, but a type with name '{2}' was returned.</value>
  </data>
  <data name="etProvidedAppliedMethodHadWrongName" xml:space="preserve">
    <value>The type provider '{0}' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '{1}' was expected, but a method with name '{2}' was returned.</value>
  </data>
  <data name="tcTypeTestLossy" xml:space="preserve">
    <value>This type test or downcast will erase the provided type '{0}' to the type '{1}'</value>
  </data>
  <data name="tcTypeCastErased" xml:space="preserve">
    <value>This downcast will erase the provided type '{0}' to the type '{1}'.</value>
  </data>
  <data name="tcTypeTestErased" xml:space="preserve">
    <value>This type test with a provided type '{0}' is not allowed because this provided type will be erased to '{1}' at runtime.</value>
  </data>
  <data name="tcCannotInheritFromErasedType" xml:space="preserve">
    <value>Cannot inherit from erased provided type</value>
  </data>
  <data name="etInvalidTypeProviderAssemblyName" xml:space="preserve">
    <value>Assembly '{0}' hase TypeProviderAssembly attribute with invalid value '{1}'. The value should be a valid assembly name</value>
  </data>
  <data name="tcInvalidMemberNameCtor" xml:space="preserve">
    <value>Invalid member name. Members may not have name '.ctor' or '.cctor'</value>
  </data>
  <data name="tcInferredGenericTypeGivesRiseToInconsistency" xml:space="preserve">
    <value>The function or member '{0}' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '{1}'.</value>
  </data>
  <data name="tcInvalidTypeArgumentCount" xml:space="preserve">
    <value>The number of type arguments did not match: '{0}' given, '{1}' expected. This may be related to a previously reported error.</value>
  </data>
  <data name="tcCannotOverrideSealedMethod" xml:space="preserve">
    <value>Cannot override inherited member '{0}' because it is sealed</value>
  </data>
  <data name="etProviderErrorWithContext" xml:space="preserve">
    <value>The type provider '{0}' reported an error in the context of provided type '{1}', member '{2}'. The error: {3}</value>
  </data>
  <data name="etProvidedTypeWithNameException" xml:space="preserve">
    <value>An exception occurred when accessing the '{0}' of a provided type: {1}</value>
  </data>
  <data name="etProvidedTypeWithNullOrEmptyName" xml:space="preserve">
    <value>The '{0}' of a provided type was null or empty.</value>
  </data>
  <data name="etIllegalCharactersInTypeName" xml:space="preserve">
    <value>Character '{0}' is not allowed in provided type name '{1}'</value>
  </data>
  <data name="tcJoinMustUseSimplePattern" xml:space="preserve">
    <value>In queries, '{0}' must use a simple pattern</value>
  </data>
  <data name="tcMissingCustomOperation" xml:space="preserve">
    <value>A custom query operation for '{0}' is required but not specified</value>
  </data>
  <data name="etBadUnnamedStaticArgs" xml:space="preserve">
    <value>Named static arguments must come after all unnamed static arguments</value>
  </data>
  <data name="etStaticParameterRequiresAValue" xml:space="preserve">
    <value>The static parameter '{0}' of the provided type or method '{1}' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '{2}&lt;{3}=...&gt;'.</value>
  </data>
  <data name="etNoStaticParameterWithName" xml:space="preserve">
    <value>No static parameter exists with name '{0}'</value>
  </data>
  <data name="etStaticParameterAlreadyHasValue" xml:space="preserve">
    <value>The static parameter '{0}' has already been given a value</value>
  </data>
  <data name="etMultipleStaticParameterWithName" xml:space="preserve">
    <value>Multiple static parameters exist with name '{0}'</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings" xml:space="preserve">
    <value>A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedHere" xml:space="preserve">
    <value>A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression</value>
  </data>
  <data name="tcCustomOperationMayNotBeOverloaded" xml:space="preserve">
    <value>The custom operation '{0}' refers to a method which is overloaded. The implementations of custom operations may not be overloaded.</value>
  </data>
  <data name="tcIfThenElseMayNotBeUsedWithinQueries" xml:space="preserve">
    <value>An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.</value>
  </data>
  <data name="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen" xml:space="preserve">
    <value>Invalid argument to 'methodhandleof' during codegen</value>
  </data>
  <data name="etProvidedTypeReferenceMissingArgument" xml:space="preserve">
    <value>A reference to a provided type was missing a value for the static parameter '{0}'. You may need to recompile one or more referenced assemblies.</value>
  </data>
  <data name="etProvidedTypeReferenceInvalidText" xml:space="preserve">
    <value>A reference to a provided type had an invalid value '{0}' for a static parameter. You may need to recompile one or more referenced assemblies.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly" xml:space="preserve">
    <value>'{0}' is not used correctly. This is a custom operation in this query or computation expression.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly2" xml:space="preserve">
    <value>'{0}' is not used correctly. Usage: {1}. This is a custom operation in this query or computation expression.</value>
  </data>
  <data name="customOperationTextLikeJoin" xml:space="preserve">
    <value>{0} var in collection {1} (outerKey = innerKey). Note that parentheses are required after '{2}'</value>
  </data>
  <data name="customOperationTextLikeGroupJoin" xml:space="preserve">
    <value>{0} var in collection {1} (outerKey = innerKey) into group. Note that parentheses are required after '{2}'</value>
  </data>
  <data name="customOperationTextLikeZip" xml:space="preserve">
    <value>{0} var in collection</value>
  </data>
  <data name="tcBinaryOperatorRequiresVariable" xml:space="preserve">
    <value>'{0}' must be followed by a variable name. Usage: {1}.</value>
  </data>
  <data name="tcOperatorIncorrectSyntax" xml:space="preserve">
    <value>Incorrect syntax for '{0}'. Usage: {1}.</value>
  </data>
  <data name="tcBinaryOperatorRequiresBody" xml:space="preserve">
    <value>'{0}' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... {1} ...</value>
  </data>
  <data name="tcCustomOperationHasIncorrectArgCount" xml:space="preserve">
    <value>'{0}' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected {1} argument(s), but given {2}.</value>
  </data>
  <data name="parsExpectedExpressionAfterToken" xml:space="preserve">
    <value>Expected an expression after this point</value>
  </data>
  <data name="parsExpectedTypeAfterToken" xml:space="preserve">
    <value>Expected a type after this point</value>
  </data>
  <data name="parsUnmatchedLBrackLess" xml:space="preserve">
    <value>Unmatched '[&lt;'. Expected closing '&gt;]'</value>
  </data>
  <data name="parsUnexpectedEndOfFileMatch" xml:space="preserve">
    <value>Unexpected end of input in 'match' expression. Expected 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTry" xml:space="preserve">
    <value>Unexpected end of input in 'try' expression. Expected 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWhile" xml:space="preserve">
    <value>Unexpected end of input in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFor" xml:space="preserve">
    <value>Unexpected end of input in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWith" xml:space="preserve">
    <value>Unexpected end of input in 'match' or 'try' expression</value>
  </data>
  <data name="parsUnexpectedEndOfFileThen" xml:space="preserve">
    <value>Unexpected end of input in 'then' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileElse" xml:space="preserve">
    <value>Unexpected end of input in 'else' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFunBody" xml:space="preserve">
    <value>Unexpected end of input in body of lambda expression. Expected 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeArgs" xml:space="preserve">
    <value>Unexpected end of input in type arguments</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeSignature" xml:space="preserve">
    <value>Unexpected end of input in type signature</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeDefinition" xml:space="preserve">
    <value>Unexpected end of input in type definition</value>
  </data>
  <data name="parsUnexpectedEndOfFileObjectMembers" xml:space="preserve">
    <value>Unexpected end of input in object members</value>
  </data>
  <data name="parsUnexpectedEndOfFileDefinition" xml:space="preserve">
    <value>Unexpected end of input in value, function or member definition</value>
  </data>
  <data name="parsUnexpectedEndOfFileExpression" xml:space="preserve">
    <value>Unexpected end of input in expression</value>
  </data>
  <data name="parsExpectedNameAfterToken" xml:space="preserve">
    <value>Unexpected end of type. Expected a name after this point.</value>
  </data>
  <data name="parsUnmatchedLet" xml:space="preserve">
    <value>Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.</value>
  </data>
  <data name="parsUnmatchedLetBang" xml:space="preserve">
    <value>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword.</value>
  </data>
  <data name="parsUnmatchedUseBang" xml:space="preserve">
    <value>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword.</value>
  </data>
  <data name="parsUnmatchedUse" xml:space="preserve">
    <value>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword.</value>
  </data>
  <data name="parsWhileDoExpected" xml:space="preserve">
    <value>Missing 'do' in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="parsForDoExpected" xml:space="preserve">
    <value>Missing 'do' in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="tcInvalidRelationInJoin" xml:space="preserve">
    <value>Invalid join relation in '{0}'. Expected 'expr &lt;op&gt; expr', where &lt;op&gt; is =, =?, ?= or ?=?.</value>
  </data>
  <data name="typeInfoCallsWord" xml:space="preserve">
    <value>Calls</value>
  </data>
  <data name="impInvalidNumberOfGenericArguments" xml:space="preserve">
    <value>Invalid number of generic arguments to type '{0}' in provided type. Expected '{1}' arguments, given '{2}'.</value>
  </data>
  <data name="impInvalidMeasureArgument1" xml:space="preserve">
    <value>Invalid value '{0}' for unit-of-measure parameter '{1}'</value>
  </data>
  <data name="impInvalidMeasureArgument2" xml:space="preserve">
    <value>Invalid value unit-of-measure parameter '{0}'</value>
  </data>
  <data name="etPropertyNeedsCanWriteOrCanRead" xml:space="preserve">
    <value>Property '{0}' on provided type '{1}' is neither readable nor writable as it has CanRead=false and CanWrite=false</value>
  </data>
  <data name="tcIntoNeedsRestOfQuery" xml:space="preserve">
    <value>A use of 'into' must be followed by the remainder of the computation</value>
  </data>
  <data name="tcOperatorDoesntAcceptInto" xml:space="preserve">
    <value>The operator '{0}' does not accept the use of 'into'</value>
  </data>
  <data name="tcCustomOperationInvalid" xml:space="preserve">
    <value>The definition of the custom operator '{0}' does not use a valid combination of attribute flags</value>
  </data>
  <data name="tcThisTypeMayNotHaveACLIMutableAttribute" xml:space="preserve">
    <value>This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute.</value>
  </data>
  <data name="tcAutoPropertyRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSet" xml:space="preserve">
    <value>Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet" xml:space="preserve">
    <value>To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</value>
  </data>
  <data name="chkNoByrefsOfByrefs" xml:space="preserve">
    <value>Type '{0}' is illegal because in byref&lt;T&gt;, T cannot contain byref types.</value>
  </data>
  <data name="tastopsMaxArrayThirtyTwo" xml:space="preserve">
    <value>F# supports array ranks between 1 and 32. The value {0} is not allowed.</value>
  </data>
  <data name="tcNoIntegerForLoopInQuery" xml:space="preserve">
    <value>In queries, use the form 'for x in n .. m do ...' for ranging over integers</value>
  </data>
  <data name="tcNoWhileInQuery" xml:space="preserve">
    <value>'while' expressions may not be used in queries</value>
  </data>
  <data name="tcNoTryFinallyInQuery" xml:space="preserve">
    <value>'try/finally' expressions may not be used in queries</value>
  </data>
  <data name="tcUseMayNotBeUsedInQueries" xml:space="preserve">
    <value>'use' expressions may not be used in queries</value>
  </data>
  <data name="tcBindMayNotBeUsedInQueries" xml:space="preserve">
    <value>'let!', 'use!' and 'do!' expressions may not be used in queries</value>
  </data>
  <data name="tcReturnMayNotBeUsedInQueries" xml:space="preserve">
    <value>'return' and 'return!' may not be used in queries</value>
  </data>
  <data name="tcUnrecognizedQueryOperator" xml:space="preserve">
    <value>This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type.</value>
  </data>
  <data name="tcTryWithMayNotBeUsedInQueries" xml:space="preserve">
    <value>'try/with' expressions may not be used in queries</value>
  </data>
  <data name="tcNonSimpleLetBindingInQuery" xml:space="preserve">
    <value>This 'let' definition may not be used in a query. Only simple value definitions may be used in queries.</value>
  </data>
  <data name="etTooManyStaticParameters" xml:space="preserve">
    <value>Too many static parameters. Expected at most {0} parameters, but got {1} unnamed and {2} named parameters.</value>
  </data>
  <data name="infosInvalidProvidedLiteralValue" xml:space="preserve">
    <value>Invalid provided literal value '{0}'</value>
  </data>
  <data name="invalidPlatformTarget" xml:space="preserve">
    <value>The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead.</value>
  </data>
  <data name="tcThisValueMayNotBeInlined" xml:space="preserve">
    <value>This member, function or value declaration may not be declared 'inline'</value>
  </data>
  <data name="etErasedTypeUsedInGeneration" xml:space="preserve">
    <value>The provider '{0}' returned a non-generated type '{1}' in the context of a set of generated types. Consider adjusting the type provider to only return generated types.</value>
  </data>
  <data name="tcUnrecognizedQueryBinaryOperator" xml:space="preserve">
    <value>Arguments to query operators may require parentheses, e.g. 'where (x &gt; y)' or 'groupBy (x.Length / 10)'</value>
  </data>
  <data name="crefNoSetOfHole" xml:space="preserve">
    <value>A quotation may not involve an assignment to or taking the address of a captured local variable</value>
  </data>
  <data name="nicePrintOtherOverloads1" xml:space="preserve">
    <value>+ 1 overload</value>
  </data>
  <data name="nicePrintOtherOverloadsN" xml:space="preserve">
    <value>+ {0} overloads</value>
  </data>
  <data name="erasedTo" xml:space="preserve">
    <value>Erased to</value>
  </data>
  <data name="parsUnfinishedExpression" xml:space="preserve">
    <value>Unexpected token '{0}' or incomplete expression</value>
  </data>
  <data name="parsAttributeOnIncompleteCode" xml:space="preserve">
    <value>Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.</value>
  </data>
  <data name="parsTypeNameCannotBeEmpty" xml:space="preserve">
    <value>Type name cannot be empty.</value>
  </data>
  <data name="buildProblemReadingAssembly" xml:space="preserve">
    <value>Problem reading assembly '{0}': {1}</value>
  </data>
  <data name="tcTPFieldMustBeLiteral" xml:space="preserve">
    <value>Invalid provided field. Provided fields of erased provided types must be literals.</value>
  </data>
  <data name="loadingDescription" xml:space="preserve">
    <value>(loading description...)</value>
  </data>
  <data name="descriptionUnavailable" xml:space="preserve">
    <value>(description unavailable...)</value>
  </data>
  <data name="chkTyparMultipleClassConstraints" xml:space="preserve">
    <value>A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.</value>
  </data>
  <data name="tcMatchMayNotBeUsedWithQuery" xml:space="preserve">
    <value>'match' expressions may not be used in queries</value>
  </data>
  <data name="memberOperatorDefinitionWithNonTripleArgument" xml:space="preserve">
    <value>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 3 arguments</value>
  </data>
  <data name="cannotResolveNullableOperators" xml:space="preserve">
    <value>The operator '{0}' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="tcOperatorRequiresIn" xml:space="preserve">
    <value>'{0}' must be followed by 'in'. Usage: {1}.</value>
  </data>
  <data name="parsIllegalMemberVarInObjectImplementation" xml:space="preserve">
    <value>Neither 'member val' nor 'override val' definitions are permitted in object expressions.</value>
  </data>
  <data name="tcEmptyCopyAndUpdateRecordInvalid" xml:space="preserve">
    <value>Copy-and-update record expressions must include at least one field.</value>
  </data>
  <data name="parsUnderscoreInvalidFieldName" xml:space="preserve">
    <value>'_' cannot be used as field name</value>
  </data>
  <data name="tcGeneratedTypesShouldBeInternalOrPrivate" xml:space="preserve">
    <value>The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'.</value>
  </data>
  <data name="chkGetterAndSetterHaveSamePropertyType" xml:space="preserve">
    <value>A property's getter and setter must have the same type. Property '{0}' has getter of type '{1}' but setter of type '{2}'.</value>
  </data>
  <data name="tcRuntimeSuppliedMethodCannotBeUsedInUserCode" xml:space="preserve">
    <value>Array method '{0}' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.</value>
  </data>
  <data name="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName" xml:space="preserve">
    <value>Union case/exception '{0}' does not have field named '{1}'.</value>
  </data>
  <data name="tcUnionCaseFieldCannotBeUsedMoreThanOnce" xml:space="preserve">
    <value>Union case/exception field '{0}' cannot be used more than once.</value>
  </data>
  <data name="tcFieldNameIsUsedModeThanOnce" xml:space="preserve">
    <value>Named field '{0}' is used more than once.</value>
  </data>
  <data name="tcFieldNameConflictsWithGeneratedNameForAnonymousField" xml:space="preserve">
    <value>Named field '{0}' conflicts with autogenerated name for anonymous field.</value>
  </data>
  <data name="tastConstantExpressionOverflow" xml:space="preserve">
    <value>This literal expression or attribute argument results in an arithmetic overflow.</value>
  </data>
  <data name="tcIllegalStructTypeForConstantExpression" xml:space="preserve">
    <value>This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.</value>
  </data>
  <data name="fscSystemRuntimeInteropServicesIsRequired" xml:space="preserve">
    <value>System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.</value>
  </data>
  <data name="abImplicitHeapAllocation" xml:space="preserve">
    <value>The mutable local '{0}' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.</value>
  </data>
  <data name="estApplyStaticArgumentsForMethodNotImplemented" xml:space="preserve">
    <value>A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToMethod" xml:space="preserve">
    <value>An error occured applying the static arguments to a provided method</value>
  </data>
  <data name="pplexUnexpectedChar" xml:space="preserve">
    <value>Unexpected character '{0}' in preprocessor expression</value>
  </data>
  <data name="ppparsUnexpectedToken" xml:space="preserve">
    <value>Unexpected token '{0}' in preprocessor expression</value>
  </data>
  <data name="ppparsIncompleteExpression" xml:space="preserve">
    <value>Incomplete preprocessor expression</value>
  </data>
  <data name="ppparsMissingToken" xml:space="preserve">
    <value>Missing token '{0}' in preprocessor expression</value>
  </data>
  <data name="pickleMissingDefinition" xml:space="preserve">
    <value>An error occurred while reading the F# metadata node at position {0} in table '{1}' of assembly '{2}'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Type inference caused the type variable {0} to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScopeAnon" xml:space="preserve">
    <value>Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.</value>
  </data>
  <data name="checkRaiseFamilyFunctionArgumentCount" xml:space="preserve">
    <value>Redundant arguments are being ignored in function '{0}'. Expected {1} but got {2} arguments.</value>
  </data>
  <data name="checkLowercaseLiteralBindingInPattern" xml:space="preserve">
    <value>Lowercase literal '{0}' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.</value>
  </data>
  <data name="tcLiteralDoesNotTakeArguments" xml:space="preserve">
    <value>This literal pattern does not take arguments</value>
  </data>
  <data name="tcConstructorsIllegalInAugmentation" xml:space="preserve">
    <value>Constructors are not permitted as extension members - they must be defined as part of the original definition of the type</value>
  </data>
  <data name="optsInvalidResponseFile" xml:space="preserve">
    <value>Invalid response file '{0}' ( '{1}' )</value>
  </data>
  <data name="optsResponseFileNotFound" xml:space="preserve">
    <value>Response file '{0}' not found in '{1}'</value>
  </data>
  <data name="optsResponseFileNameInvalid" xml:space="preserve">
    <value>Response file name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</value>
  </data>
  <data name="fsharpCoreNotFoundToBeCopied" xml:space="preserve">
    <value>Cannot find FSharp.Core.dll in compiler's directory</value>
  </data>
  <data name="tcTupleStructMismatch" xml:space="preserve">
    <value>One tuple type is a struct tuple, the other is a reference tuple</value>
  </data>
  <data name="etMissingStaticArgumentsToMethod" xml:space="preserve">
    <value>This provided method requires static parameters</value>
  </data>
  <data name="considerUpcast" xml:space="preserve">
    <value>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'.</value>
  </data>
  <data name="considerUpcastOperator" xml:space="preserve">
    <value>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.</value>
  </data>
  <data name="tcRecImplied" xml:space="preserve">
    <value>The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored</value>
  </data>
  <data name="tcOpenFirstInMutRec" xml:space="preserve">
    <value>In a recursive declaration group, 'open' declarations must come first in each module</value>
  </data>
  <data name="tcModuleAbbrevFirstInMutRec" xml:space="preserve">
    <value>In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations</value>
  </data>
  <data name="tcUnsupportedMutRecDecl" xml:space="preserve">
    <value>This declaration is not supported in recursive declaration groups</value>
  </data>
  <data name="parsInvalidUseOfRec" xml:space="preserve">
    <value>Invalid use of 'rec' keyword</value>
  </data>
  <data name="tcStructUnionMultiCaseDistinctFields" xml:space="preserve">
    <value>If a union type has more than one case and is a struct, then all fields within the union type must be given unique names.</value>
  </data>
  <data name="CallerMemberNameIsOverriden" xml:space="preserve">
    <value>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</value>
  </data>
  <data name="tcFixedNotAllowed" xml:space="preserve">
    <value>Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'</value>
  </data>
  <data name="tcCouldNotFindOffsetToStringData" xml:space="preserve">
    <value>Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression.</value>
  </data>
  <data name="chkNoByrefReturnOfLocal" xml:space="preserve">
    <value>The address of the variable '{0}' cannot be used at this point. A method or function may not return the address of this local value.</value>
  </data>
  <data name="tcNamedActivePattern" xml:space="preserve">
    <value>{0} is an active pattern and cannot be treated as a discriminated union case with named fields.</value>
  </data>
  <data name="DefaultParameterValueNotAppropriateForArgument" xml:space="preserve">
    <value>The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'.</value>
  </data>
  <data name="tcGlobalsSystemTypeNotFound" xml:space="preserve">
    <value>The system type '{0}' was required but no referenced system DLL contained this type</value>
  </data>
  <data name="typrelMemberHasMultiplePossibleDispatchSlots" xml:space="preserve">
    <value>The member '{0}' matches multiple overloads of the same method.\nPlease restrict it to one of the following:{1}.</value>
  </data>
  <data name="methodIsNotStatic" xml:space="preserve">
    <value>Method or object constructor '{0}' is not static</value>
  </data>
  <data name="parsUnexpectedSymbolEqualsInsteadOfIn" xml:space="preserve">
    <value>Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?</value>
  </data>
  <data name="keywordDescriptionAbstract" xml:space="preserve">
    <value>Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</value>
  </data>
  <data name="keyworkDescriptionAnd" xml:space="preserve">
    <value>Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</value>
  </data>
  <data name="keywordDescriptionAs" xml:space="preserve">
    <value>Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</value>
  </data>
  <data name="keywordDescriptionAssert" xml:space="preserve">
    <value>Used to verify code during debugging.</value>
  </data>
  <data name="keywordDescriptionBase" xml:space="preserve">
    <value>Used as the name of the base class object.</value>
  </data>
  <data name="keywordDescriptionBegin" xml:space="preserve">
    <value>In verbose syntax, indicates the start of a code block.</value>
  </data>
  <data name="keywordDescriptionClass" xml:space="preserve">
    <value>In verbose syntax, indicates the start of a class definition.</value>
  </data>
  <data name="keywordDescriptionDefault" xml:space="preserve">
    <value>Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</value>
  </data>
  <data name="keywordDescriptionDelegate" xml:space="preserve">
    <value>Used to declare a delegate.</value>
  </data>
  <data name="keywordDescriptionDo" xml:space="preserve">
    <value>Used in looping constructs or to execute imperative code.</value>
  </data>
  <data name="keywordDescriptionDone" xml:space="preserve">
    <value>In verbose syntax, indicates the end of a block of code in a looping expression.</value>
  </data>
  <data name="keywordDescriptionDowncast" xml:space="preserve">
    <value>Used to convert to a type that is lower in the inheritance chain.</value>
  </data>
  <data name="keywordDescriptionDownto" xml:space="preserve">
    <value>In a for expression, used when counting in reverse.</value>
  </data>
  <data name="keywordDescriptionElif" xml:space="preserve">
    <value>Used in conditional branching. A short form of else if.</value>
  </data>
  <data name="keywordDescriptionElse" xml:space="preserve">
    <value>Used in conditional branching.</value>
  </data>
  <data name="keywordDescriptionEnd" xml:space="preserve">
    <value>In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</value>
  </data>
  <data name="keywordDescriptionException" xml:space="preserve">
    <value>Used to declare an exception type.</value>
  </data>
  <data name="keywordDescriptionExtern" xml:space="preserve">
    <value>Indicates that a declared program element is defined in another binary or assembly.</value>
  </data>
  <data name="keywordDescriptionTrueFalse" xml:space="preserve">
    <value>Used as a Boolean literal.</value>
  </data>
  <data name="keywordDescriptionFinally" xml:space="preserve">
    <value>Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</value>
  </data>
  <data name="keywordDescriptionFor" xml:space="preserve">
    <value>Used in looping constructs.</value>
  </data>
  <data name="keywordDescriptionFun" xml:space="preserve">
    <value>Used in lambda expressions, also known as anonymous functions.</value>
  </data>
  <data name="keywordDescriptionFunction" xml:space="preserve">
    <value>Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</value>
  </data>
  <data name="keywordDescriptionGlobal" xml:space="preserve">
    <value>Used to reference the top-level .NET namespace.</value>
  </data>
  <data name="keywordDescriptionIf" xml:space="preserve">
    <value>Used in conditional branching constructs.</value>
  </data>
  <data name="keywordDescriptionIn" xml:space="preserve">
    <value>Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</value>
  </data>
  <data name="keywordDescriptionInherit" xml:space="preserve">
    <value>Used to specify a base class or base interface.</value>
  </data>
  <data name="keywordDescriptionInline" xml:space="preserve">
    <value>Used to indicate a function that should be integrated directly into the caller's code.</value>
  </data>
  <data name="keywordDescriptionInterface" xml:space="preserve">
    <value>Used to declare and implement interfaces.</value>
  </data>
  <data name="keywordDescriptionInternal" xml:space="preserve">
    <value>Used to specify that a member is visible inside an assembly but not outside it.</value>
  </data>
  <data name="keywordDescriptionLazy" xml:space="preserve">
    <value>Used to specify a computation that is to be performed only when a result is needed.</value>
  </data>
  <data name="keywordDescriptionLet" xml:space="preserve">
    <value>Used to associate, or bind, a name to a value or function.</value>
  </data>
  <data name="keywordDescriptionLetBang" xml:space="preserve">
    <value>Used in asynchronous workflows to bind a name to the result of an asynchronous computation, or, in other computation expressions, used to bind a name to a result, which is of the computation type.</value>
  </data>
  <data name="keywordDescriptionMatch" xml:space="preserve">
    <value>Used to branch by comparing a value to a pattern.</value>
  </data>
  <data name="keywordDescriptionMatchBang" xml:space="preserve">
    <value>Used in computation expressions to pattern match directly over the result of another computation expression.</value>
  </data>
  <data name="keywordDescriptionMember" xml:space="preserve">
    <value>Used to declare a property or method in an object type.</value>
  </data>
  <data name="keywordDescriptionModule" xml:space="preserve">
    <value>Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</value>
  </data>
  <data name="keywordDescriptionMutable" xml:space="preserve">
    <value>Used to declare a variable, that is, a value that can be changed.</value>
  </data>
  <data name="keywordDescriptionNamespace" xml:space="preserve">
    <value>Used to associate a name with a group of related types and modules, to logically separate it from other code.</value>
  </data>
  <data name="keywordDescriptionNew" xml:space="preserve">
    <value>Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.</value>
  </data>
  <data name="keywordDescriptionNot" xml:space="preserve">
    <value>Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</value>
  </data>
  <data name="keywordDescriptionNull" xml:space="preserve">
    <value>Indicates the absence of an object. Also used in generic parameter constraints.</value>
  </data>
  <data name="keywordDescriptionOf" xml:space="preserve">
    <value>Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</value>
  </data>
  <data name="keywordDescriptionOpen" xml:space="preserve">
    <value>Used to make the contents of a namespace or module available without qualification.</value>
  </data>
  <data name="keywordDescriptionOr" xml:space="preserve">
    <value>Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.</value>
  </data>
  <data name="keywordDescriptionOverride" xml:space="preserve">
    <value>Used to implement a version of an abstract or virtual method that differs from the base version.</value>
  </data>
  <data name="keywordDescriptionPrivate" xml:space="preserve">
    <value>Restricts access to a member to code in the same type or module.</value>
  </data>
  <data name="keywordDescriptionPublic" xml:space="preserve">
    <value>Allows access to a member from outside the type.</value>
  </data>
  <data name="keywordDescriptionRec" xml:space="preserve">
    <value>Used to indicate that a function is recursive.</value>
  </data>
  <data name="keywordDescriptionReturn" xml:space="preserve">
    <value>Used to indicate a value to provide as the result of a computation expression.</value>
  </data>
  <data name="keywordDescriptionReturnBang" xml:space="preserve">
    <value>Used to indicate a computation expression that, when evaluated, provides the result of the containing computation expression.</value>
  </data>
  <data name="keywordDescriptionSelect" xml:space="preserve">
    <value>Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</value>
  </data>
  <data name="keywordDescriptionStatic" xml:space="preserve">
    <value>Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</value>
  </data>
  <data name="keywordDescriptionStruct" xml:space="preserve">
    <value>Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions.</value>
  </data>
  <data name="keywordDescriptionThen" xml:space="preserve">
    <value>Used in conditional expressions. Also used to perform side effects after object construction.</value>
  </data>
  <data name="keywordDescriptionTo" xml:space="preserve">
    <value>Used in for loops to indicate a range.</value>
  </data>
  <data name="keywordDescriptionTry" xml:space="preserve">
    <value>Used to introduce a block of code that might generate an exception. Used together with with or finally.</value>
  </data>
  <data name="keywordDescriptionType" xml:space="preserve">
    <value>Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</value>
  </data>
  <data name="keywordDescriptionUpcast" xml:space="preserve">
    <value>Used to convert to a type that is higher in the inheritance chain.</value>
  </data>
  <data name="keywordDescriptionUse" xml:space="preserve">
    <value>Used instead of let for values that require Dispose to be called to free resources.</value>
  </data>
  <data name="keywordDescriptionUseBang" xml:space="preserve">
    <value>Used instead of let! in asynchronous workflows and other computation expressions for values that require Dispose to be called to free resources.</value>
  </data>
  <data name="keywordDescriptionVal" xml:space="preserve">
    <value>Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</value>
  </data>
  <data name="keywordDescriptionVoid" xml:space="preserve">
    <value>Indicates the .NET void type. Used when interoperating with other .NET languages.</value>
  </data>
  <data name="keywordDescriptionWhen" xml:space="preserve">
    <value>Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.</value>
  </data>
  <data name="keywordDescriptionWhile" xml:space="preserve">
    <value>Introduces a looping construct.</value>
  </data>
  <data name="keywordDescriptionWith" xml:space="preserve">
    <value>Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</value>
  </data>
  <data name="keywordDescriptionYield" xml:space="preserve">
    <value>Used in a sequence expression to produce a value for a sequence.</value>
  </data>
  <data name="keywordDescriptionYieldBang" xml:space="preserve">
    <value>Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</value>
  </data>
  <data name="keywordDescriptionRightArrow" xml:space="preserve">
    <value>In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions</value>
  </data>
  <data name="keywordDescriptionLeftArrow" xml:space="preserve">
    <value>Assigns a value to a variable.</value>
  </data>
  <data name="keywordDescriptionCast" xml:space="preserve">
    <value>Converts a type to type that is higher in the hierarchy.</value>
  </data>
  <data name="keywordDescriptionDynamicCast" xml:space="preserve">
    <value>Converts a type to a type that is lower in the hierarchy.</value>
  </data>
  <data name="keywordDescriptionTypedQuotation" xml:space="preserve">
    <value>Delimits a typed code quotation.</value>
  </data>
  <data name="keywordDescriptionUntypedQuotation" xml:space="preserve">
    <value>Delimits a untyped code quotation.</value>
  </data>
  <data name="itemNotFoundDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} '{1}' not found in assembly '{2}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</value>
  </data>
  <data name="itemNotFoundInTypeDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} '{1}' not found in type '{2}' from assembly '{3}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</value>
  </data>
  <data name="descriptionWordIs" xml:space="preserve">
    <value>is</value>
  </data>
  <data name="notAFunction" xml:space="preserve">
    <value>This value is not a function and cannot be applied.</value>
  </data>
  <data name="notAFunctionButMaybeIndexerWithName" xml:space="preserve">
    <value>This value is not a function and cannot be applied. Did you intend to access the indexer via {0}.[index] instead?</value>
  </data>
  <data name="notAFunctionButMaybeIndexer" xml:space="preserve">
    <value>This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?</value>
  </data>
  <data name="notAFunctionButMaybeIndexerErrorCode" xml:space="preserve">
    <value>
    </value>
  </data>
  <data name="notAFunctionButMaybeDeclaration" xml:space="preserve">
    <value>This value is not a function and cannot be applied. Did you forget to terminate a declaration?</value>
  </data>
  <data name="ArgumentsInSigAndImplMismatch" xml:space="preserve">
    <value>The argument names in the signature '{0}' and implementation '{1}' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling.</value>
  </data>
  <data name="pickleUnexpectedNonZero" xml:space="preserve">
    <value>An error occurred while reading the F# metadata of assembly '{0}'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct.</value>
  </data>
  <data name="tcTupleMemberNotNormallyUsed" xml:space="preserve">
    <value>This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.</value>
  </data>
  <data name="implicitlyDiscardedInSequenceExpression" xml:space="preserve">
    <value>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'.</value>
  </data>
  <data name="implicitlyDiscardedSequenceInSequenceExpression" xml:space="preserve">
    <value>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'.</value>
  </data>
  <data name="ilreadFileChanged" xml:space="preserve">
    <value>The file '{0}' changed on disk unexpectedly, please reload.</value>
  </data>
</root>