<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ja" original="../FSCore.resx">
    <body>
      <trans-unit id="matchCasesIncomplete">
        <source>The match cases were incomplete</source>
        <target state="translated">一致条件が不完全でした</target>
        <note />
      </trans-unit>
      <trans-unit id="addressOpNotFirstClass">
        <source>First class uses of address-of operators are not permitted.</source>
        <target state="translated">アドレス演算子のファースト クラスの使用は許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="arraysHadDifferentLengths">
        <source>The arrays have different lengths.</source>
        <target state="translated">配列の長さが異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="arrayWasEmpty">
        <source>The input array was empty.</source>
        <target state="translated">入力配列が空でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="badFormatString">
        <source>Input string was not in a correct format.</source>
        <target state="translated">文字列の形式が正しくありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="delegateExpected">
        <source>Expecting delegate type.</source>
        <target state="translated">デリゲート型を必要としています。</target>
        <note />
      </trans-unit>
      <trans-unit id="dyInvDivByIntCoerce">
        <source>Dynamic invocation of DivideByInt involving coercions is not supported.</source>
        <target state="translated">強制型変換に関連する DivideByInt の動的な呼び出しはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="dyInvOpAddCoerce">
        <source>Dynamic invocation of op_Addition involving coercions is not supported.</source>
        <target state="translated">強制型変換に関連する op_Addition の動的な呼び出しはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="dyInvOpAddOverload">
        <source>Dynamic invocation of op_Addition involving overloading is not supported.</source>
        <target state="translated">オーバーロードに関連する op_Addition の動的な呼び出しはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="dyInvOpMultCoerce">
        <source>Dynamic invocation of op_Multiply involving coercions is not supported.</source>
        <target state="translated">強制型変換に関連する op_Multiply の動的な呼び出しはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="dyInvOpMultOverload">
        <source>Dynamic invocation of op_Multiply involving overloading is not supported.</source>
        <target state="translated">オーバーロードに関連する op_Multiply の動的な呼び出しはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="endCannotBeNaN">
        <source>The end of a range cannot be NaN.</source>
        <target state="translated">範囲の最後を NaN にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="enumerationAlreadyFinished">
        <source>Enumeration already finished.</source>
        <target state="translated">列挙は既に終了しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="enumerationNotStarted">
        <source>Enumeration has not started. Call MoveNext.</source>
        <target state="translated">列挙は開始していません。MoveNext を呼び出してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="setContainsNoElements">
        <source>Set contains no elements.</source>
        <target state="translated">セットに要素がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="enumerationPastIntMaxValue">
        <source>Enumeration based on System.Int32 exceeded System.Int32.MaxValue.</source>
        <target state="translated">System.Int32 に基づく列挙型が System.Int32.MaxValue を超えました。</target>
        <note />
      </trans-unit>
      <trans-unit id="failedReadEnoughBytes">
        <source>Failed to read enough bytes from the stream.</source>
        <target state="translated">ストリームから十分なバイト数を読み取ることができませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="genericCompareFail1">
        <source>Failure during generic comparison: the type '{0}' does not implement the System.IComparable interface. This error may be arise from the use of a function such as 'compare', 'max' or 'min' or a data structure such as 'Set' or 'Map' whose keys contain instances of this type.</source>
        <target state="translated">汎用的な比較中にエラーが発生しました: 型 '{0}' は System.IComparable インターフェイスを実装しません。このエラーは、'compare'、'max'、'min' などの関数、またはこの型のインスタンスを含むキーを持つ 'Set' や 'Map' などのデータ構造を使用した場合に発生することがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="indexOutOfBounds">
        <source>The index was outside the range of elements in the list.</source>
        <target state="translated">インデックスはリストの要素の範囲外にありました。</target>
        <note />
      </trans-unit>
      <trans-unit id="inputListWasEmpty">
        <source>The input list was empty.</source>
        <target state="translated">入力リストが空でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="inputMustBeNonNegative">
        <source>The input must be non-negative.</source>
        <target state="translated">入力は負以外である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="inputMustBePositive">
        <source>The input must be positive.</source>
        <target state="translated">入力は正である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="inputSequenceEmpty">
        <source>The input sequence was empty.</source>
        <target state="translated">入力シーケンスが空でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidTupleTypes">
        <source>This is not a valid tuple type for the F# reflection library.</source>
        <target state="translated">これは F# リフレクション ライブラリに対して有効なタプル型ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="keyNotFound">
        <source>The item, key, or index was not found in the collection.</source>
        <target state="translated">項目、キー、またはインデックスがコレクションに見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="listsHadDifferentLengths">
        <source>The lists had different lengths.</source>
        <target state="translated">リストの長さが異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="mailboxProcessorAlreadyStarted">
        <source>The MailboxProcessor has already been started.</source>
        <target state="translated">MailboxProcessor は既に開始されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="mailboxProcessorPostAndAsyncReplyTimedOut">
        <source>MailboxProcessor.PostAndAsyncReply timed out.</source>
        <target state="translated">MailboxProcessor.PostAndAsyncReply がタイムアウトしました。</target>
        <note />
      </trans-unit>
      <trans-unit id="mailboxProcessorPostAndReplyTimedOut">
        <source>MailboxProcessor.PostAndReply timed out.</source>
        <target state="translated">MailboxProcessor.PostAndReply がタイムアウトしました。</target>
        <note />
      </trans-unit>
      <trans-unit id="mailboxReceiveTimedOut">
        <source>Mailbox.Receive timed out.</source>
        <target state="translated">Mailbox.Receive がタイムアウトしました。</target>
        <note />
      </trans-unit>
      <trans-unit id="mailboxScanTimedOut">
        <source>Mailbox.Scan timed out.</source>
        <target state="translated">Mailbox.Scan がタイムアウトしました。</target>
        <note />
      </trans-unit>
      <trans-unit id="mapCannotBeMutated">
        <source>Map values cannot be mutated.</source>
        <target state="translated">マップ値は変換できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="mismatchIARCancel">
        <source>The IAsyncResult object provided does not match this 'Cancel' operation.</source>
        <target state="translated">提供された IAsyncResult オブジェクトはこの '取り消し' 操作と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="mismatchIAREnd">
        <source>The IAsyncResult object provided does not match this 'End' operation.</source>
        <target state="translated">提供された IAsyncResult オブジェクトはこの '終了' 操作と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="noNegateMinValue">
        <source>Negating the minimum value of a twos complement number is invalid.</source>
        <target state="translated">2 の補数の最小値を無効にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="checkInit">
        <source>The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.</source>
        <target state="translated">オブジェクトまたは値の初期化の結果、そのオブジェクトまたは値が、完全に初期化される前に再帰的にアクセスされました。</target>
        <note />
      </trans-unit>
      <trans-unit id="checkStaticInit">
        <source>The static initialization of a file or type resulted in static data being accessed recursively before it was fully initialized.</source>
        <target state="translated">ファイルまたは型の静的な初期化の結果、静的データが、完全に初期化される前に再帰的にアクセスされました。</target>
        <note />
      </trans-unit>
      <trans-unit id="nonZeroBasedDisallowed">
        <source>Arrays with non-zero base cannot be created on this platform.</source>
        <target state="translated">このプラットフォームでは、ゼロ以外を基数とする配列を作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionType">
        <source>Type '{0}' is not a function type.</source>
        <target state="translated">型 '{0}' は関数型ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="notAnExceptionType">
        <source>Type '{0}' is not the representation of an F# exception declaration.</source>
        <target state="translated">型 '{0}' は F# 例外宣言の表現ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="notAPermutation">
        <source>The function did not compute a permutation.</source>
        <target state="translated">関数は順列をコンピューティングしませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="notARecordType">
        <source>Type '{0}' is not an F# record type.</source>
        <target state="translated">型 '{0}' は F# レコード型ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="notATupleType">
        <source>Type '{0}' is not a tuple type.</source>
        <target state="translated">型 '{0}' はタプル型ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="notAUnionType">
        <source>Type '{0}' is not an F# union type.</source>
        <target state="translated">型 '{0}' は F# 共用体型ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="notComparable">
        <source>The two objects have different types and are not comparable.</source>
        <target state="translated">2 つのオブジェクトの型が異なり、比較できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="notEnoughElements">
        <source>The input sequence has an insufficient number of elements.</source>
        <target state="translated">入力シーケンスには十分な数の要素がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="notUsedForHashing">
        <source>This object is for recursive equality calls and cannot be used for hashing.</source>
        <target state="translated">このオブジェクトは再帰的な等値呼び出し用であり、ハッシュには使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="nullsNotAllowedInArray">
        <source>One of the elements in the array is null.</source>
        <target state="translated">配列の要素の 1 つが null です。</target>
        <note />
      </trans-unit>
      <trans-unit id="objIsNotARecord">
        <source>The object is not an F# record value.</source>
        <target state="translated">オブジェクトは F# レコード値ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="objIsNullAndNoType">
        <source>The object is null and no type was given.  Either pass a non-null object or a non-null type parameter.</source>
        <target state="translated">オブジェクトは null であり、型が指定されていません。null 以外のオブジェクトまたは null 以外の型パラメーターを渡してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="outOfRange">
        <source>The index is outside the legal range.</source>
        <target state="translated">インデックスは有効範囲外です。</target>
        <note />
      </trans-unit>
      <trans-unit id="privateExceptionType">
        <source>The type '{0}' is the representation of an F# exception declaration but its representation is private. You must specify BindingFlags.NonPublic to access private type representations.</source>
        <target state="translated">型 '{0}' は F# 例外宣言の表現ですが、その表現はプライベートです。プライベート型表現にアクセスするには BindingFlags.NonPublic を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="privateRecordType">
        <source>The type '{0}' is an F# record type but its representation is private. You must specify BindingFlags.NonPublic to access private type representations.</source>
        <target state="translated">型 '{0}' は F# レコード型ですが、その表現はプライベートです。プライベート型表現にアクセスするには BindingFlags.NonPublic を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="privateUnionType">
        <source>The type '{0}' is an F# union type but its representation is private. You must specify BindingFlags.NonPublic to access private type representations.</source>
        <target state="translated">型 '{0}' は F# 共用体型ですが、その表現はプライベートです。プライベート型表現にアクセスするには BindingFlags.NonPublic を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="QexpectedOneType">
        <source>Expected exactly one type argument.</source>
        <target state="translated">型引数が 1 つだけ必要でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="QexpectedTwoTypes">
        <source>Expected exactly two type arguments.</source>
        <target state="translated">型引数が 2 つだけ必要でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="QinvalidCaseIndex">
        <source>Not a valid F# union case index.</source>
        <target state="translated">有効な F# 共用体ケース インデックスではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="QmissingRecordField">
        <source>Type '{0}' did not have an F# record field named '{1}'.</source>
        <target state="translated">型 '{0}' には '{1}' という名前の F# レコード フィールドがありませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="QmissingUnionCase">
        <source>Type '{0}' did not have an F# union case named '{1}'.</source>
        <target state="translated">型 '{0}' には '{1}' という名前の F# 共用体ケースがありませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmBadFieldType">
        <source>Type mismatch when building '{0}': the type of the field was incorrect. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: フィールドの型が正しくありませんでした。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmBodyMustBeUnit">
        <source>Type mismatch when building '{0}': body must return unit. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: 本体はユニットを返す必要があります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmCondMustBeBool">
        <source>Type mismatch when building '{0}': condition expression must be of type bool. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: 条件式は bool 型である必要があります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmExpectedFunction">
        <source>Type mismatch when building '{0}': expected function type in function application or let binding. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: 関数アプリケーションまたは let 束縛では関数型が必要でした。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmExprNotMatchTuple">
        <source>Type mismatch when building '{0}': expression doesn't match the tuple type. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: 式がタプル型と一致しません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmExprTypeMismatch">
        <source>Type mismatch when building '{0}': types of expression does not match. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: 式の型が一致しません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmFunctionArgTypeMismatch">
        <source>Type mismatch when building '{0}': function argument type doesn't match. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: 関数引数型が一致しません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmGuardMustBeBool">
        <source>Type mismatch when building '{0}': guard must return boolean. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: ガードはブール型を返す必要があります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmIncorrectArgForRecord">
        <source>Type mismatch when building '{0}': incorrect argument type for an F# record. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: F# レコードの引数型が正しくありません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmIncorrectArgForUnion">
        <source>Type mismatch when building '{0}': incorrect argument type for an F# union. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: F# 共用体の引数型が正しくありません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmInitArray">
        <source>Type mismatch when building '{0}': initializer doesn't match array type. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: 初期化子が配列型と一致しません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmInvalidParam">
        <source>Type mismatch when building '{0}': invalid parameter for a method or indexer property. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致:メソッドまたはインデクサー プロパティのパラメーターが無効です。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmLoopBodyMustBeLambdaTakingInteger">
        <source>Type mismatch when building '{0}': body of the for loop must be lambda taking integer as an argument. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: for loop の本体は整数を引数として受け取るラムダである必要があります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmLowerUpperBoundMustBeInt">
        <source>Type mismatch when building '{0}': lower and upper bounds must be integers. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: 下限と上限は整数である必要があります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmTrueAndFalseMustMatch">
        <source>Type mismatch when building '{0}': types of true and false branches differ. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: true と false の分岐の型が異なります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmTuple">
        <source>Type mismatch when building '{0}': mismatched type of argument and tuple element. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: 引数とタプル要素の型が一致しませんでした。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmVarTypeNotMatchRHS">
        <source>Type mismatch when building '{0}': the variable type doesn't match the type of the right-hand-side of a let binding. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: 変数型が let 束縛の右側の型と一致しません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QunexpectedHole">
        <source>Unexpected quotation hole in expression.</source>
        <target state="translated">式に予期しない引用のホールがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="QunrecognizedMethodCall">
        <source>The parameter is not a recognized method name.</source>
        <target state="translated">パラメーターは認識されているメソッド名ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="resetNotSupported">
        <source>Reset is not supported on this enumerator.</source>
        <target state="translated">この列挙型ではリセットがサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="startCannotBeNaN">
        <source>The start of a range cannot be NaN.</source>
        <target state="translated">範囲の開始を NaN にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="stepCannotBeNaN">
        <source>The step of a range cannot be NaN.</source>
        <target state="translated">範囲のステップを NaN にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="stepCannotBeZero">
        <source>The step of a range cannot be zero.</source>
        <target state="translated">範囲のステップをゼロにすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="syncContextNull">
        <source>The System.Threading.SynchronizationContext.Current of the calling thread is null.</source>
        <target state="translated">呼び出しスレッドの System.Threading.SynchronizationContext.Current が null です。</target>
        <note />
      </trans-unit>
      <trans-unit id="tupleIndexOutOfRange">
        <source>The tuple index '{1}' was out of range for tuple type '{0}'.</source>
        <target state="translated">タプル インデックス '{1}' はタプル型 '{0}' の範囲外でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="QfailedToBindConstructor">
        <source>Failed to bind constructor</source>
        <target state="translated">コンストラクターをバインドできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="QfailedToBindField">
        <source>Failed to bind field '{0}'</source>
        <target state="translated">フィールド '{0}' をバインドできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="QfailedToBindProperty">
        <source>Failed to bind property '{0}'</source>
        <target state="translated">プロパティ '{0}' をバインドできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="QfailedToBindTypeInAssembly">
        <source>Failed to bind type '{0}' in assembly '{1}'</source>
        <target state="translated">アセンブリ '{1}' の型 '{0}' をバインドできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="QincompatibleRecordLength">
        <source>Incompatible record length</source>
        <target state="translated">互換性のないレコード長</target>
        <note />
      </trans-unit>
      <trans-unit id="QincorrectInstanceType">
        <source>Incorrect instance type</source>
        <target state="translated">インスタンス型が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="QincorrectNumArgs">
        <source>Incorrect number of arguments</source>
        <target state="translated">引数の数が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="QincorrectType">
        <source>Incorrect type</source>
        <target state="translated">型が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="QinvalidFuncType">
        <source>Invalid function type</source>
        <target state="translated">無効な関数型</target>
        <note />
      </trans-unit>
      <trans-unit id="QnonStaticNoReceiverObject">
        <source>The member is non-static (instance), but no receiver object was supplied</source>
        <target state="translated">メンバーは非静的 (インスタンス) ですが、レシーバー オブジェクトが指定されませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="QparentCannotBeNull">
        <source>Parent type cannot be null</source>
        <target state="translated">親の型を null にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="QreadingSetOnly">
        <source>Reading a set-only property</source>
        <target state="translated">設定専用のプロパティを読み取っています</target>
        <note />
      </trans-unit>
      <trans-unit id="QstaticWithReceiverObject">
        <source>Receiver object was unexpected, as member is static</source>
        <target state="translated">メンバーは静的であるため、レシーバー オブジェクトは予期されていませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmExprHasWrongType">
        <source>Type mismatch when building '{0}': the expression has the wrong type. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: 式に間違った型があります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmFunTypeNotMatchDelegate">
        <source>Type mismatch when building '{0}': function type doesn't match delegate type. Expected '{1}', but received type '{2}'.</source>
        <target state="translated">{0}' を構築するときの型の不一致: 関数型がデリゲート型と一致しません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtmmRaw">
        <source>Type mismatch when splicing expression into quotation literal. The type of the expression tree being inserted doesn't match the type expected by the splicing operation. Expected '{0}', but received type '{1}'. Consider type-annotating with the expected expression type, e.g., (%% x : {0}) or (%x : {0}).</source>
        <target state="translated">式を引用リテラルにスプライスするときの型が一致していません。挿入されている式ツリーの型が、スプライス操作に必要な型と一致しません。'{0}' が必要でしたが、型 '{1}' を受け取りました。(%% x : {0}) や (%x : {0}) など必要な式の型での型注釈付けを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="QtupleAccessOutOfRange">
        <source>Tuple access out of range</source>
        <target state="translated">タプルのアクセスが範囲外です</target>
        <note />
      </trans-unit>
      <trans-unit id="QtupleLengthsDiffer">
        <source>The tuple lengths are different</source>
        <target state="translated">タプルの長さが異なります</target>
        <note />
      </trans-unit>
      <trans-unit id="QunionNeedsDiffNumArgs">
        <source>F# union type requires different number of arguments</source>
        <target state="translated">F# 共用体型には異なる数の引数が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="QwritingGetOnly">
        <source>Writing a get-only property</source>
        <target state="translated">取得専用のプロパティを書き込んでいます</target>
        <note />
      </trans-unit>
      <trans-unit id="QwrongNumOfTypeArgs">
        <source>The method '{0}' expects {1} type arguments but {2} were provided</source>
        <target state="translated">メソッド '{0}' には {1} 個の型引数が必要ですが、{2} 個が指定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="keyNotFoundAlt">
        <source>An index satisfying the predicate was not found in the collection.</source>
        <target state="translated">述語を満たすインデックスがコレクションに見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="constructorForUnionCaseNotFound">
        <source>The constructor method '{0}' for the union case could not be found</source>
        <target state="translated">共用体ケースのコンストラクター メソッド '{0}' が見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="firstClassUsesOfSplice">
        <source>first class uses of '%' or '%%' are not permitted</source>
        <target state="translated">'%' または '%%' のファースト クラスの使用は許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="moveNextNotCalledOrFinished">
        <source>MoveNext not called, or finished</source>
        <target state="translated">MoveNext は呼び出されていないか、終了しました</target>
        <note />
      </trans-unit>
      <trans-unit id="multipleCompilationMappings">
        <source>Multiple CompilationMappingAttributes, expected at most one</source>
        <target state="translated">複数の CompilationMappingAttribute がありますが、必要なのは最大 1 つです</target>
        <note />
      </trans-unit>
      <trans-unit id="printfBadFloatValue">
        <source>Bad float value</source>
        <target state="translated">浮動小数値が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="printfBadFormatSpecifier">
        <source>Bad format specifier:{0}</source>
        <target state="translated">書式指定子が正しくありません: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="printfBadIntegerForDynamicFomatter">
        <source>Bad integer supplied to dynamic formatter</source>
        <target state="translated">動的フォーマッタに対して指定された整数が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="printfExpectedPrecision">
        <source>Expected a precision argument</source>
        <target state="translated">精度引数が必要でした</target>
        <note />
      </trans-unit>
      <trans-unit id="printfExpectedWidth">
        <source>Expected a width argument</source>
        <target state="translated">幅引数が必要でした</target>
        <note />
      </trans-unit>
      <trans-unit id="printfHashFormatSpecifierIllegal">
        <source>The # formatting modifier is invalid in F#</source>
        <target state="translated"># 書式修飾子は F# では無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="printfMissingFormatSpecifier">
        <source>Missing format specifier</source>
        <target state="translated">書式指定子がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="printfNotAFunType">
        <source>Not a function type</source>
        <target state="translated">関数型ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="printfPrecisonSpecifierIllegal">
        <source>Bad format specifier (precision)</source>
        <target state="translated">書式指定子 (精度) が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="printfSpecifierAfterIllegal">
        <source>Bad format specifier (after {0})</source>
        <target state="translated">書式指定子 ({0} の後) が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="printfWidthSpecifierIllegal">
        <source>Bad format specifier (width)</source>
        <target state="translated">書式指定子 (幅) が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="QcannotBindFunction">
        <source>Could not bind function {0} in type {1}</source>
        <target state="translated">型 {1} で関数 {0} をバインドできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="QcannotBindProperty">
        <source>Could not bind property {0} in type {1}</source>
        <target state="translated">型 {1} でプロパティ {0} をバインドできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="QcannotBindToMethod">
        <source>Could not bind to method</source>
        <target state="translated">メソッドにバインドできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="QcannotTakeAddress">
        <source>Cannot take the address of this quotation</source>
        <target state="translated">この引用のアドレスを取得できません</target>
        <note />
      </trans-unit>
      <trans-unit id="QfailedToBindAssembly">
        <source>Failed to bind assembly '{0}' while processing quotation data</source>
        <target state="translated">引用データの処理中にアセンブリ '{0}' をバインドできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="QillFormedAppOrLet">
        <source>ill formed expression: AppOp or LetOp</source>
        <target state="translated">正しくない形式の式: AppOp または LetOp</target>
        <note />
      </trans-unit>
      <trans-unit id="QtypeArgumentOutOfRange">
        <source>type argument out of range</source>
        <target state="translated">型引数が範囲外です</target>
        <note />
      </trans-unit>
      <trans-unit id="thisValueCannotBeMutated">
        <source>This value cannot be mutated</source>
        <target state="translated">この値は変換できません</target>
        <note />
      </trans-unit>
      <trans-unit id="optionValueWasNone">
        <source>The option value was None</source>
        <target state="translated">オプション値は None でした</target>
        <note />
      </trans-unit>
      <trans-unit id="controlContinuationInvokedMultipleTimes">
        <source>A continuation provided by Async.FromContinuations was invoked multiple times</source>
        <target state="translated">Async.FromContinuations で提供される継続が複数回呼び出されました</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidRecordTypeConstructorNotDefined">
        <source>The record type '{0}' is invalid. Required constructor is not defined.</source>
        <target state="translated">レコード型 '{0}' は無効です。必要なコンストラクターが定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidTupleTypeConstructorNotDefined">
        <source>The tuple type '{0}' is invalid. Required constructor is not defined.</source>
        <target state="translated">タプル型 '{0}' は無効です。必要なコンストラクターが定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="inputSequenceTooLong">
        <source>The input sequence contains more than one element.</source>
        <target state="translated">入力シーケンスに複数の要素が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="thenByError">
        <source>'thenBy' and 'thenByDescending' may only be used with an ordered input</source>
        <target state="translated">'thenBy' および 'thenByDescending' は、順序付けされた入力だけで使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="failDueToUnsupportedInputTypeInSumByOrAverageBy">
        <source>Unrecognized use of a 'sumBy' or 'averageBy' operator in a query. In queries whose original data is of static type IQueryable, these operators may only be used with result type int32, int64, single, double or decimal</source>
        <target state="translated">クエリ内で 'sumBy' または 'averageBy' 演算子が認識されない使われ方をしています。元のデータがスタティック型 IQueryable であるクエリでは、これらの演算子は結果の型が int32、int64、single、double、または decimal である場合にだけ使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="unsupportedIfThenElse">
        <source>An if/then/else conditional or pattern matching expression with multiple branches is not permitted in a query. An if/then/else conditional may be used.</source>
        <target state="translated">if/then/else 条件節、または分岐のあるパターン一致式は、クエリで使用できません。if/then/else 条件節が使用されている可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="unsupportedQueryConstruct">
        <source>This is not a valid query expression. The following construct was used in a query but is not recognized by the F#-to-LINQ query translator:\n{0}\nCheck the specification of permitted queries and consider moving some of the operations out of the query expression.</source>
        <target state="translated">これは有効なクエリ式ではありません。クエリで次の構造が使用されていますが、F# から LINQ へのクエリ トランスレーターに認識されません:\n{0}\n許可されたクエリの仕様を確認し、一部の操作をクエリ式の外に移動することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="unsupportedQueryCall">
        <source>This is not a valid query expression. The method '{0}' was used in a query but is not recognized by the F#-to-LINQ query translator. Check the specification of permitted queries and consider moving some of the operations out of the query expression</source>
        <target state="translated">これは有効なクエリ式ではありません。クエリでメソッド '{0}' が使用されていますが、F# から LINQ へのクエリ トランスレーターに認識されません。許可されたクエリの仕様を確認し、一部の操作をクエリ式の外に移動することを検討してください</target>
        <note />
      </trans-unit>
      <trans-unit id="unsupportedQueryProperty">
        <source>This is not a valid query expression. The property '{0}' was used in a query but is not recognized by the F#-to-LINQ query translator. Check the specification of permitted queries and consider moving some of the operations out of the query expression.</source>
        <target state="translated">これは有効なクエリ式ではありません。クエリでプロパティ '{0}' が使用されていますが、F# から LINQ へのクエリ トランスレーターに認識されません。許可されたクエリの仕様を確認し、一部の操作をクエリ式の外に移動することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="unsupportedQueryConstructKind">
        <source>This is not a valid query expression. The construct '{0}' was used in a query but is not recognized by the F#-to-LINQ query translator. Check the specification of permitted queries and consider moving some of the operations out of the query expression.</source>
        <target state="translated">これは有効なクエリ式ではありません。クエリで構造 '{0}' が使用されていますが、F# から LINQ へのクエリ トランスレーターに認識されません。許可されたクエリの仕様を確認し、一部の操作をクエリ式の外に移動することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="maxDegreeOfParallelismNotPositive">
        <source>maxDegreeOfParallelism must be positive, was {0}</source>
        <target state="translated">maxDegreeOfParallelism には正の値を指定する必要がありますが、{0} が指定されました</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>