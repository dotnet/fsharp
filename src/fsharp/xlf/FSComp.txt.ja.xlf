<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ja" original="../FSComp.resx">
    <body>
      <trans-unit id="undefinedNameNamespace">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">名前空間 '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespaceOrModule">
        <source>The namespace or module '{0}' is not defined.</source>
        <target state="translated">名前空間またはモジュール '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMember">
        <source>The field, constructor or member '{0}' is not defined.</source>
        <target state="translated">フィールド、コンストラクター、またはメンバー '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueConstructorNamespaceOrType">
        <source>The value, constructor, namespace or type '{0}' is not defined.</source>
        <target state="translated">値、コンストラクター、名前空間、または型 '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueOfConstructor">
        <source>The value or constructor '{0}' is not defined.</source>
        <target state="translated">値またはコンストラクター '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueNamespaceTypeOrModule">
        <source>The value, namespace, type or module '{0}' is not defined.</source>
        <target state="translated">値、名前空間、型、またはモジュール '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameConstructorModuleOrNamespace">
        <source>The constructor, module or namespace '{0}' is not defined.</source>
        <target state="translated">コンストラクター、モジュール、または名前空間 '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameType">
        <source>The type '{0}' is not defined.</source>
        <target state="translated">型 '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeIn">
        <source>The type '{0}' is not defined in '{1}'.</source>
        <target state="translated">{1}' で型 '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabelOrNamespace">
        <source>The record label or namespace '{0}' is not defined.</source>
        <target state="translated">レコード ラベルまたは名前空間 '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabel">
        <source>The record label '{0}' is not defined.</source>
        <target state="translated">レコード ラベル '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameSuggestionsIntro">
        <source>Maybe you want one of the following:</source>
        <target state="translated">次のいずれかの可能性はありませんか:</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeParameter">
        <source>The type parameter {0} is not defined.</source>
        <target state="translated">型パラメーター {0} が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNamePatternDiscriminator">
        <source>The pattern discriminator '{0}' is not defined.</source>
        <target state="translated">パターン識別子 '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="replaceWithSuggestion">
        <source>Replace with '{0}'</source>
        <target state="translated">'{0}' で置換</target>
        <note />
      </trans-unit>
      <trans-unit id="addIndexerDot">
        <source>Add . for indexer access.</source>
        <target state="translated">インデクサーにアクセスするには . を追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="listElementHasWrongType">
        <source>All elements of a list constructor expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</source>
        <target state="translated">リスト コンストラクター式のすべての要素は同じ型である必要があります。この式に必要な型は '{0}' ですが、ここでは型 '{1}' になっています。</target>
        <note />
      </trans-unit>
      <trans-unit id="arrayElementHasWrongType">
        <source>All elements of an array constructor expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</source>
        <target state="translated">配列コンストラクター式の要素はすべて同じ型である必要があります。この式に必要な型は '{0}' ですが、ここでは型 '{1}' になっています。</target>
        <note />
      </trans-unit>
      <trans-unit id="missingElseBranch">
        <source>The 'if' expression is missing an 'else' branch. The 'then' branch has type '{0}'. Because 'if' is an expression, and not a statement, add an 'else' branch which returns a value of the same type.</source>
        <target state="translated">'if' 式に 'else' ブランチがありません。'then' ブランチは型 '{0}' です。'if' はステートメントではなく式であるため、同じ型の値を返す 'else' ブランチを追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ifExpression">
        <source>The 'if' expression needs to have type '{0}' to satisfy context type requirements. It currently has type '{1}'.</source>
        <target state="translated">コンテキストの型要件を満たすためには、'if' 式の型は '{0}' である必要があります。現在の型は '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="elseBranchHasWrongType">
        <source>All branches of an 'if' expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</source>
        <target state="translated">if' 式のすべてのブランチは同じ型である必要があります。この式に必要な型は '{0}' ですが、ここでは型 '{1}' になっています。</target>
        <note />
      </trans-unit>
      <trans-unit id="followingPatternMatchClauseHasWrongType">
        <source>All branches of a pattern match expression must return values of the same type. The first branch returned a value of type '{0}', but this branch returned a value of type '{1}'.</source>
        <target state="needs-review-translation">パターン マッチ式のすべてのブランチは同じ型である必要があります。この式に必要な型は '{0}' ですが、ここでは型 '{1}' になっています。</target>
        <note />
      </trans-unit>
      <trans-unit id="patternMatchGuardIsNotBool">
        <source>A pattern match guard must be of type 'bool', but this 'when' expression is of type '{0}'.</source>
        <target state="translated">パターン マッチ ガードは型 'bool' である必要がありますが、この 'when' 式は型 '{0}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="commaInsteadOfSemicolonInRecord">
        <source>A ';' is used to separate field values in records. Consider replacing ',' with ';'.</source>
        <target state="translated">';' は、レコード内でフィールド値を区切るために使われます。',' を ';' で置き換えることを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="derefInsteadOfNot">
        <source>The '!' operator is used to dereference a ref cell. Consider using 'not expr' here.</source>
        <target state="translated">'!' 演算子は ref セルの逆参照に使用されます。ここに 'not expr' を使用することをご検討ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedTypeArgs">
        <source>The non-generic type '{0}' does not expect any type arguments, but here is given {1} type argument(s)</source>
        <target state="translated">非ジェネリック型 '{0}' に型引数は使用できませんが、{1} 個の型引数があります</target>
        <note />
      </trans-unit>
      <trans-unit id="returnUsedInsteadOfReturnBang">
        <source>Consider using 'return!' instead of 'return'.</source>
        <target state="translated">'return' の代わりに 'return!' を使うことを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="yieldUsedInsteadOfYieldBang">
        <source>Consider using 'yield!' instead of 'yield'.</source>
        <target state="translated">'yield' の代わりに 'yield!' を使うことを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tupleRequiredInAbstractMethod">
        <source>\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.</source>
        <target state="translated">\n1 つ以上の引数についてタプル型を指定する必要があります。指定した引数を追加のかっこ内にラップすることを検討するか、インターフェイスの定義を確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidWarningNumber">
        <source>Invalid warning number '{0}'</source>
        <target state="translated">警告番号 '{0}' が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionString">
        <source>Invalid version string '{0}'</source>
        <target state="translated">バージョン文字列 '{0}' が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionFile">
        <source>Invalid version file '{0}'</source>
        <target state="translated">バージョン ファイル '{0}' が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProductName">
        <source>Microsoft (R) F# Compiler version {0}</source>
        <target state="translated">Microsoft (R) F# Compiler バージョン {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProductNameCommunity">
        <source>F# Compiler for F# {0}</source>
        <target state="translated">F# {0} の F# コンパイラ</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemWithFilename">
        <source>Problem with filename '{0}': {1}</source>
        <target state="translated">ファイル名 '{0}' に問題があります: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildNoInputsSpecified">
        <source>No inputs specified</source>
        <target state="translated">入力が指定されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="buildPdbRequiresDebug">
        <source>The '--pdb' option requires the '--debug' option to be used</source>
        <target state="translated">'--pdb' オプションでは '--debug' オプションを使用する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSearchDirectory">
        <source>The search directory '{0}' is invalid</source>
        <target state="translated">検索ディレクトリ '{0}' が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSearchDirectoryNotFound">
        <source>The search directory '{0}' could not be found</source>
        <target state="translated">検索ディレクトリ '{0}' が見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidFilename">
        <source>'{0}' is not a valid filename</source>
        <target state="translated">'{0}' は有効なファイル名ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidAssemblyName">
        <source>'{0}' is not a valid assembly name</source>
        <target state="translated">'{0}' は有効なアセンブリ名ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidPrivacy">
        <source>Unrecognized privacy setting '{0}' for managed resource, valid options are 'public' and 'private'</source>
        <target state="translated">マネージ リソースの認識されないプライバシー設定 '{0}'。有効なオプションは 'public' および 'private' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleReferencesNotAllowed">
        <source>Multiple references to '{0}.dll' are not permitted</source>
        <target state="translated">'{0}.dll' に対する複数の参照は許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotReadVersionInfoFromMscorlib">
        <source>Could not read version from mscorlib.dll</source>
        <target state="translated">mscorlib.dll からバージョンを読み取ることができませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCannotReadAssembly">
        <source>Unable to read assembly '{0}'</source>
        <target state="translated">アセンブリ '{0}' を読み取れません</target>
        <note />
      </trans-unit>
      <trans-unit id="buildAssemblyResolutionFailed">
        <source>Assembly resolution failure at or near this location</source>
        <target state="translated">この場所またはこの場所付近でアセンブリ解決エラーが発生しました</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplicitModuleIsNotLegalIdentifier">
        <source>The declarations in this file will be placed in an implicit module '{0}' based on the file name '{1}'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file.</source>
        <target state="translated">このファイルの宣言は、ファイル名 '{1}' に基づいて、暗黙的なモジュール '{0}' に配置されます。ただし、これは有効な F# 識別子ではないため、その内容には他のファイルからアクセスできません。ファイル名を変更するか、ファイルの一番上に 'module' または 'namespace' の宣言を追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultiFileRequiresNamespaceOrModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration.</source>
        <target state="translated">ライブラリまたは複数ファイル アプリケーション内のファイルは、名前空間またはモジュールの宣言から開始する必要があります (例: 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'。アプリケーションの最後のソース ファイルのみ、このような宣言を省略できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="noEqualSignAfterModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.</source>
        <target state="translated">ライブラリ内のファイル、または複数ファイル アプリケーション内のファイルでは、先頭に名前空間宣言またはモジュール宣言を置く必要があります。ファイルの先頭にモジュール宣言を置く場合、'=' 記号は指定できません。これが最上位レベルのモジュールである場合は、このエラーを解決するために = を削除することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleToplevelModules">
        <source>This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules.</source>
        <target state="translated">このファイルには、'module SomeNamespace.SomeModule' という形式の宣言が複数含まれます。1 ファイル内で指定できるこの形式の宣言は 1 つのみです。最初の名前空間宣言を使用するようにファイルを変更するか、'module ModuleName = ...' を使用してモジュールを定義してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildOptionRequiresParameter">
        <source>Option requires parameter: {0}</source>
        <target state="translated">オプションにパラメーターが必要です: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotFindSourceFile">
        <source>Source file '{0}' could not be found</source>
        <target state="translated">ソース ファイル '{0}' が見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSourceFileExtension">
        <source>The file extension of '{0}' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.</source>
        <target state="translated">'{0}' のファイル拡張子は認識されません。ソース ファイルの拡張子は .fs、.fsi、.fsx、.fsscript、.ml、または .mli にする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssembly">
        <source>Could not resolve assembly '{0}'</source>
        <target state="translated">アセンブリ '{0}' を解決できませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssemblyRequiredByFile">
        <source>Could not resolve assembly '{0}' required by '{1}'</source>
        <target state="translated">{1}' に必要なアセンブリ '{0}' を解決できませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="buildErrorOpeningBinaryFile">
        <source>Error opening binary file '{0}': {1}</source>
        <target state="translated">バイナリ ファイル '{0}' を開くときにエラーが発生しました: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDifferentVersionMustRecompile">
        <source>The F#-compiled DLL '{0}' needs to be recompiled to be used with this version of F#</source>
        <target state="translated">F# でコンパイルされたこの DLL '{0}' は、このバージョンの F# で使用するために再コンパイルする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashIDirective">
        <source>Invalid directive. Expected '#I \"&lt;path&gt;\"'.</source>
        <target state="translated">ディレクティブが無効です。'#I \"&lt;path&gt;\"' という形式で指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashrDirective">
        <source>Invalid directive. Expected '#r \"&lt;file-or-assembly&gt;\"'.</source>
        <target state="translated">ディレクティブが無効です。'#r \"&lt;file-or-assembly&gt;\"' という形式で指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashloadDirective">
        <source>Invalid directive. Expected '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</source>
        <target state="translated">ディレクティブが無効です。'#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"' という形式で指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashtimeDirective">
        <source>Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'.</source>
        <target state="translated">ディレクティブが無効です。'#time'、'#time \"on\"'、または '#time \"off\"' という形式で指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDirectivesInModulesAreIgnored">
        <source>Directives inside modules are ignored</source>
        <target state="translated">モジュール内のディレクティブは無視されます</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureAlreadySpecified">
        <source>A signature for the file or module '{0}' has already been specified</source>
        <target state="translated">ファイルまたはモジュール '{0}' のシグネチャは指定済みです</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGivenDetail">
        <source>An implementation of file or module '{0}' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.</source>
        <target state="translated">ファイルまたはモジュール '{0}' の実装は指定済みです。型推論があるため、F# ではコンパイルの順序が重要です。必要に応じて、実装の前にシグネチャ ファイルを配置するよう、ファイルの順序を調整します。Visual Studio では、プロジェクト ファイル内の出現順にファイルが型チェックされます。プロジェクト ファイルは、手動で編集するか、ソリューション エクスプローラーを使用して調整することができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGiven">
        <source>An implementation of the file or module '{0}' has already been given</source>
        <target state="translated">ファイルまたはモジュール '{0}' の実装は指定済みです</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureWithoutImplementation">
        <source>The signature file '{0}' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match.</source>
        <target state="translated">シグネチャ ファイル '{0}' に対応する実装ファイルがありません。実装ファイルが存在する場合、シグネチャ ファイルおよび実装ファイル内の 'module' 宣言や 'namespace' 宣言が一致することを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidInt">
        <source>'{0}' is not a valid integer argument</source>
        <target state="translated">'{0}' は有効な整数引数ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidFloat">
        <source>'{0}' is not a valid floating point argument</source>
        <target state="translated">'{0}' は有効な浮動小数点引数ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnrecognizedOption">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">認識されないオプション:'{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidModuleOrNamespaceName">
        <source>Invalid module or namespace name</source>
        <target state="translated">モジュール名または名前空間名が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleErrorReadingWritingMetadata">
        <source>Error reading/writing metadata for the F# compiled DLL '{0}'. Was the DLL compiled with an earlier version of the F# compiler? (error: '{1}').</source>
        <target state="translated">F# でコンパイルした DLL '{0}' のメタデータの読み取り/書き込み中にエラーが発生しました。旧バージョンの F# コンパイラーでコンパイルした DLL ですか? (エラー: '{1}')</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeOrModuleNotConcrete">
        <source>The type/module '{0}' is not a concrete module or type</source>
        <target state="translated">型/モジュール '{0}' は具象モジュールまたは具象型ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeHasAssemblyCodeRepresentation">
        <source>The type '{0}' has an inline assembly code representation</source>
        <target state="translated">型 '{0}' にはインライン アセンブラー コード表現があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNamespaceAndModuleWithSameNameInAssembly">
        <source>A namespace and a module named '{0}' both occur in two parts of this assembly</source>
        <target state="translated">'{0}' という名前空間とモジュールの両方がこのアセンブリの 2 か所で発生しています</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTwoModulesWithSameNameInAssembly">
        <source>Two modules named '{0}' occur in two parts of this assembly</source>
        <target state="translated">'{0}' という 2 つのモジュールがこのアセンブリの 2 か所で使用されています</target>
        <note />
      </trans-unit>
      <trans-unit id="tastDuplicateTypeDefinitionInAssembly">
        <source>Two type definitions named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">{0}' という 2 つの型の定義が、このアセンブリの 2 か所の名前空間 '{1}' で発生しています</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConflictingModuleAndTypeDefinitionInAssembly">
        <source>A module and a type definition named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">{0}' というモジュールおよび型の定義が、このアセンブリの 2 か所の名前空間 '{1}' で発生しています</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMemberSignature">
        <source>Invalid member signature encountered because of an earlier error</source>
        <target state="translated">前に発生しているエラーのために、メンバーのシグネチャが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueDoesNotHaveSetterType">
        <source>This value does not have a valid property setter type</source>
        <target state="translated">この値には、有効なプロパティの set アクセス操作子の型がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertyGetter">
        <source>Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax.</source>
        <target state="translated">プロパティのゲッターの形式が無効です。明示的な構文を使用する場合、少なくとも 1 つの '()' 引数が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertySetter">
        <source>Invalid form for a property setter. At least one argument is required.</source>
        <target state="translated">プロパティの set アクセス操作子の形式が無効です。少なくとも 1 つの引数が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedByRef">
        <source>Unexpected use of a byref-typed variable</source>
        <target state="translated">byref 型変数の予期しない使用方法です:</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeMutable">
        <source>A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'</source>
        <target state="translated">値の型の内容を変更するか、値の型のアドレスを使用するために、値は変更可能にする必要があります (たとえば、'let mutable x = ...')</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMutationOfConstant">
        <source>Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'.</source>
        <target state="translated">定数式の変更は無効です。変更可能なローカルに式をコピーしてください (たとえば、'let mutable x = ...')。</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueHasBeenCopied">
        <source>The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed</source>
        <target state="translated">この操作で元の値が変更されないように、値はコピーされました</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeInConstructionOfTuple">
        <source>Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding</source>
        <target state="translated">再帰的に定義された値は、再帰的な束縛内にあるタプル値の構造の一部として直接使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotAppearInConstructionOfType">
        <source>Recursive values cannot appear directly as a construction of the type '{0}' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.</source>
        <target state="translated">再帰的な値は、再帰的な束縛内の型 '{0}' の構造として直接使用することはできません。この機能は F# 言語から削除されました。代わりにレコードを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeAssignedToNonMutableField">
        <source>Recursive values cannot be directly assigned to the non-mutable field '{0}' of the type '{1}' within a recursive binding. Consider using a mutable field instead.</source>
        <target state="translated">再帰的な値は、再帰的な束縛内の型 '{1}' の変更可能ではないフィールド '{0}' に直接割り当てることはできません。代わりに変更可能なフィールドを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfAutoOpenAttribute">
        <source>Unexpected decode of AutoOpenAttribute</source>
        <target state="translated">AutoOpenAttribute の予期しないデコードです:</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInternalsVisibleToAttribute">
        <source>Unexpected decode of InternalsVisibleToAttribute</source>
        <target state="translated">InternalsVisibleToAttribute の予期しないデコードです:</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
        <source>Unexpected decode of InterfaceDataVersionAttribute</source>
        <target state="translated">InterfaceDataVersionAttribute の予期しないデコードです:</target>
        <note />
      </trans-unit>
      <trans-unit id="tastActivePatternsLimitedToSeven">
        <source>Active patterns cannot return more than 7 possibilities</source>
        <target state="translated">アクティブ パターンが返すことができる結果は 7 個以下です</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNotAConstantExpression">
        <source>This is not a valid constant expression or custom attribute value</source>
        <target state="translated">これは有効な定数式でもカスタム属性値でもありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAttributesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe mutability attributes differ</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。変更可能属性が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe names differ</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。名前が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityCompiledNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled names differ</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれていますが、シグネチャには\n    {2}    \nが指定されています。コンパイル名が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDisplayNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe display names differ</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれていますが、シグネチャには\n    {2}    \nが指定されています。表示名が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAccessibilityMore">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャでは\n    {2}    \nを指定しています。シグネチャに指定されたアクセシビリティの方が、実装よりも高い設定です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInlineFlagsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe inline flags differ</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。インライン フラグが異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityLiteralConstantValuesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe literal constant values and/or attributes differ</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。リテラル定数値、属性、またはその両方が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsTypeFunction">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方は型関数ですが、もう一方は違います。型パラメーターが実装にある場合、シグネチャには明示的な型パラメーターが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityParameterCountsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe respective type parameter counts differ</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。それぞれの型パラメーター数が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityTypesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe types differ</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。型が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityExtensionsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is an extension member and the other is not</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方は拡張メンバーですが、もう一方は違います。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityArityNotInferred">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nAn arity was not inferred for this value</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。この値の項数は推論されませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe number of generic parameters in the signature and implementation differ (the signature declares {3} but the implementation declares {4}</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。シグネチャと実装のジェネリック パラメーター数が異なります (シグネチャは {3} 個を宣言しましたが、実装は {4} 個です)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersAreDifferentKinds">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。シグネチャと実装のジェネリック パラメーターは種類が異なります。[&lt;Measure&gt;] 属性を指定していない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAritiesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe arities in the signature and implementation differ. The signature specifies that '{3}' is function definition or lambda expression accepting at least {4} argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int.</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャでは\n    {2}    \nを指定しています。シグネチャと実装の項数が異なります。シグネチャは、'{3}' が {4} 個以上の引数を受け入れる関数定義またはラムダ式であると指定していますが、実装は計算された関数値です。計算された関数値が許可された実装であることを宣言するには、シグネチャの型をかっこで囲んでください。たとえば、\n\tval {6}: int -&gt; int -&gt; int\nではなく、次のように指定します。\n\tval {5}: int -&gt; (int -&gt; int)</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDotNetNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe CLI member names differ</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。CLI メンバー名が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is static and the other isn't</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方は静的ですが、もう一方は違います。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityVirtualsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is virtual and the other isn't</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方は仮想ですが、もう一方は違います。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAbstractsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is abstract and the other isn't</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方は抽象ですが、もう一方は違います。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityFinalsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is final and the other isn't</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方は final ですが、もう一方は違います。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOverridesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is marked as an override and the other isn't</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方はオーバーライドとマークされていますが、もう一方は違います。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsConstructor">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a constructor/property and the other is not</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方はコンストラクター/プロパティですが、もう一方は違います。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticButInstance">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。このメソッドのコンパイル済み表現は静的メンバーとして指定されていますが、シグネチャが示すコンパイル済み表現はインスタンス メンバーです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInstanceButStatic">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member</source>
        <target state="translated">モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。このメソッドのコンパイル済み表現はインスタンス メンバーとして指定されていますが、シグネチャが示すコンパイル済み表現は静的メンバーです。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNamesDiffer">
        <source>The {0} definitions in the signature and implementation are not compatible because the names differ. The type is called '{1}' in the signature file but '{2}' in implementation.</source>
        <target state="translated">シグネチャおよび実装内の {0} 定義は、名前が異なるため、互換性がありません。この型はシグネチャ ファイルでは '{1}' という名前ですが、実装では '{2}' という名前です。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">型パラメーターの数が異なるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">シグネチャに指定されたアクセシビリティが実装の指定よりも高いため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleMissingInterface">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature requires that the type supports the interface {2} but the interface has not been implemented</source>
        <target state="translated">シグネチャでは型がインターフェイス {2} をサポートする必要がありますが、インターフェイスが実装されていないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not</source>
        <target state="translated">実装では表現としてこの型に null を使用できると指定していますが、シグネチャは指定していないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not</source>
        <target state="translated">実装では特別な値としてこの型に null を使用できると指定していますが、シグネチャは指定していないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not</source>
        <target state="translated">シグネチャでは表現としてこの型に null を使用できると指定していますが、実装では指定していないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not</source>
        <target state="translated">シグネチャでは特別な値としてこの型に null を使用できると指定していますが、実装は指定していないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.</source>
        <target state="translated">実装の型はシールドですが、シグネチャではシールドではないと考えられるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません。シグネチャに [&lt;Sealed&gt;] 属性を追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.</source>
        <target state="translated">実装の型はシールドですが、シグネチャではシールドではないと考えられるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません。実装に [&lt;Sealed&gt;] 属性を追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.</source>
        <target state="translated">実装は抽象クラスですが、シグネチャは抽象クラスではないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません。シグネチャに [&lt;AbstractClass&gt;] 属性を追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.</source>
        <target state="translated">シグネチャは抽象クラスですが、実装は抽象クラスではないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません。実装に [&lt;AbstractClass&gt;] 属性を追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types have different base types</source>
        <target state="translated">型の基本型が異なるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNumbersDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the number of {2}s differ</source>
        <target state="translated">{2} の数が異なるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature defines the {2} '{3}' but the implementation does not (or does, but not in the same order)</source>
        <target state="translated">シグネチャでは {2} '{3}' を定義していますが、実装では定義していないため (または定義していても同じ順序ではないため)、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines the {2} '{3}' but the signature does not (or does, but not in the same order)</source>
        <target state="translated">実装では {2} '{3}' を定義していますが、シグネチャでは定義していないため (または定義していても同じ順序ではないため)、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation</source>
        <target state="translated">実装では構造体を定義していますが、シグネチャでは隠ぺいされた表現で型を定義しているため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature</source>
        <target state="translated">CLI の型表現がシグネチャによって隠ぺいされているため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a type representation is being hidden by a signature</source>
        <target state="translated">型表現がシグネチャによって隠ぺいされているため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types are of different kinds</source>
        <target state="translated">型の種類が異なるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleILDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the IL representations differ</source>
        <target state="translated">IL 表現が異なるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the representations differ</source>
        <target state="translated">シグネチャおよび実装内の型 '{1}' の {0} 定義は、表現が異なるため、互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldWasPresent">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was present in the implementation but not in the signature</source>
        <target state="translated">フィールド {2} が実装にはありますがシグネチャにはないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation</source>
        <target state="translated">フィールドの順序がシグネチャと実装とで異なるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was required by the signature but was not specified by the implementation</source>
        <target state="translated">シグネチャにはフィールド {2} が必要ですが、実装では指定されていないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field '{2}' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'.</source>
        <target state="translated">フィールド '{2}' が実装にはありますがシグネチャにはないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません。この型のシグネチャでは、構造体型のフィールドを公開する必要があります。ただし、フィールドのラベルは 'private' または 'internal' のままにすることもできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was required by the signature but was not specified by the implementation</source>
        <target state="translated">シグネチャには抽象メンバー '{2}' が必要ですが、実装では指定されていないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was present in the implementation but not in the signature</source>
        <target state="translated">抽象メンバー '{2}' が実装にはありますがシグネチャにはないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature declares a {2} while the implementation declares a {3}</source>
        <target state="translated">シグネチャは {2} を宣言していますが、実装では {3} を宣言しているため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abbreviations differ: {2} versus {3}</source>
        <target state="translated">シグネチャおよび実装内の型 '{1}' の {0} 定義は、省略形が異なるため ({2} と {3})、互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.</source>
        <target state="translated">省略形がシグネチャによって隠ぺいされているため、シグネチャおよび実装の型 '{1}' の {0} 定義に互換性がありません。省略形は他の CLI 言語から参照できるようにする必要があります。シグネチャ内の省略形を参照できるようにしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not</source>
        <target state="translated">シグネチャには省略形がありますが、実装にはないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButNamesDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">モジュールにはコンストラクター\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。名前が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButDataFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe respective number of data fields differ</source>
        <target state="translated">モジュールにはコンストラクター\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。データ フィールドの数が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButTypesOfFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe types of the fields differ</source>
        <target state="translated">モジュールにはコンストラクター\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。フィールドの型が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButAccessibilityDiffers">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">モジュールにはコンストラクター\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。シグネチャに指定されたアクセシビリティの方が、実装よりも高い設定です。</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedNamesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">モジュールにはフィールド\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。名前が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedAccessibilitiesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">モジュールにはフィールド\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。シグネチャに指定されたアクセシビリティの方が、実装よりも高い設定です。</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedStaticsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'static' modifiers differ</source>
        <target state="translated">モジュールにはフィールド\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。'static' 修飾子が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedMutablesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'mutable' modifiers differ</source>
        <target state="translated">モジュールにはフィールド\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。'mutable' 修飾子が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedLiteralsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'literal' modifiers differ</source>
        <target state="translated">モジュールにはフィールド\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。'literal' 修飾子が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedTypesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe types differ</source>
        <target state="translated">モジュールにはフィールド\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。型が異なります。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveImplicitGenericInstantiation">
        <source>The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '{0}' and '{1}'. Consider using type annotations to resolve the ambiguity</source>
        <target state="translated">この場所またはその付近にあるジェネリック コンストラクトの暗黙的なインスタンス化を解決できませんでした。これは、関連性のない複数の型に解決される可能性があるためです (たとえば、'{0}' と '{1}')。あいまいさを解決するために、型の注釈を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInPrintf">
        <source>Could not resolve the ambiguity inherent in the use of a 'printf'-style format string</source>
        <target state="translated">'printf' 形式の書式指定文字列の使用に関して、あいまいな継承を解決できませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInEnum">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position</source>
        <target state="translated">この位置、またはこの位置付近にある 'enum' 制約を含むジェネリック コンストラクトの使用に関して、あいまいさを解決できませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInDelegate">
        <source>Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position</source>
        <target state="translated">この位置、またはこの位置付近にある 'delegate' 制約を含むジェネリック コンストラクトの使用に関して、あいまいさを解決できませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInvalidValue">
        <source>Invalid value</source>
        <target state="translated">無効な値</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleParamCountsDiffer">
        <source>The signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">それぞれの型パラメーターの数が異なるため、シグネチャおよび実装は互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
        <source>The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation</source>
        <target state="translated">クラス/シグネチャの型パラメーターには、メンバー/実装の型パラメーターとは異なるコンパイル時の要件があるため、シグネチャと実装には互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDiffer">
        <source>The signature and implementation are not compatible because the declaration of the type parameter '{0}' requires a constraint of the form {1}</source>
        <target state="translated">型パラメーター '{0}' の宣言には形式 {1} の制約が必要なため、シグネチャと実装には互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDifferRemove">
        <source>The signature and implementation are not compatible because the type parameter '{0}' has a constraint of the form {1} but the implementation does not. Either remove this constraint from the signature or add it to the implementation.</source>
        <target state="translated">型パラメーター '{0}' には形式 {1} の制約がありますが、実装にはないため、シグネチャと実装には互換性がありません。シグネチャからこの制約を削除するか、実装に制約を追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableShouldOverrideObjectEquals">
        <source>The type '{0}' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'</source>
        <target state="translated">型 '{0}' は 'System.IComparable' を実装しています。'Object.Equals' の明示的なオーバーライドも追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableDefaultObjectEqualsProvided">
        <source>The type '{0}' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly</source>
        <target state="translated">型 '{0}' は 'System.IComparable' を明示的に実装していますが、'Object.Equals' に対応するオーバーライドを提供していません。'Object.Equals' の実装は自動的に提供され、'System.IComparable' を介して実装されます。明示的にオーバーライド 'Object.Equals' を実装してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCodeOrEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type</source>
        <target state="translated">構造体型、レコード型、または共用体型 '{0}' には 'Object.GetHashCode' または 'Object.Equals' の明示的な実装があります。この型には 'CustomEquality' 属性を適用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCode">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'</source>
        <target state="translated">構造体型、レコード型、または共用体型 '{0}' には 'Object.GetHashCode' の明示的な実装があります。'Object.Equals(obj)' に対応するオーバーライドを実装してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'</source>
        <target state="translated">構造体型、レコード型、または共用体型 '{0}' には 'Object.Equals' の明示的な実装があります。'Object.GetHashCode()' に対応するオーバーライドを実装してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleHiddenBySignature">
        <source>The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">CLI の例外のマッピングがシグネチャによって隠ぺいされているため、例外の定義に互換性がありません。例外のマッピングは他のモジュールから参照できるようにする必要があります。モジュールには例外の定義\n    {0}    \nが含まれますが、シグネチャでは\n\t{1}\nを指定しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer">
        <source>The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">CLI 表現が異なるため、例外の定義に互換性がありません。モジュールには例外の定義\n    {0}    \nが含まれますが、シグネチャでは\n\t{1}\nを指定しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature">
        <source>The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">例外の省略形がシグネチャによって隠ぺいされているため、例外の定義に互換性がありません。省略形は他の CLI 言語から参照できるようにする必要があります。シグネチャ内の省略形を参照できるようにしてください。モジュールには例外の定義\n    {0}    \nがありますが、シグネチャでは\n\t{1}\nを指定しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleSignaturesDiffer">
        <source>The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">例外の省略形がシグネチャと実装とで異なるため、例外の定義に互換性がありません。モジュールには例外の定義\n    {0}    \nが含まれますが、シグネチャでは\n\t{1}\nを指定しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer">
        <source>The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">例外の宣言が異なるため、例外の定義に互換性がありません。モジュールには例外の定義\n    {0}    \nが含まれますが、シグネチャでは\n\t{1}\nを指定しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInSigButNotImpl">
        <source>The exception definitions are not compatible because the field '{0}' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">シグネチャにはフィールド '{0}' が必要ですが、実装では指定されなかったため、例外の定義に互換性がありません。モジュールには例外の定義\n    {1}    \nが含まれますが、シグネチャでは\n\t{2}\nを指定しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInImplButNotSig">
        <source>The exception definitions are not compatible because the field '{0}' was present in the implementation but not in the signature. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">実装にはフィールド '{0}' がありますが、シグネチャにはないため、例外の定義に互換性がありません。モジュールには例外の定義\n    {1}    \nが含まれますが、シグネチャでは\n\t{2}\nを指定しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldOrderDiffers">
        <source>The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">フィールドの順序がシグネチャと実装とで異なるため、例外の定義に互換性がありません。モジュールには例外の定義\n    {0}    \nが含まれますが、シグネチャでは\n\t{1}\nを指定しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelModuleNamespaceAttributesDifferInSigAndImpl">
        <source>The namespace or module attributes differ between signature and implementation</source>
        <target state="translated">名前空間属性またはモジュール属性が、シグネチャと実装とで異なります</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsOverconstrained">
        <source>This method is over-constrained in its type parameters</source>
        <target state="translated">型パラメーターのこのメソッドは、制約過多です</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverloadNotFound">
        <source>No implementations of '{0}' had the correct number of arguments and type parameters. The required signature is '{1}'.</source>
        <target state="translated">正しい数の引数と型パラメーターが指定された '{0}' の実装がありません。必要なシグネチャは '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideWasAmbiguous">
        <source>The override for '{0}' was ambiguous</source>
        <target state="translated">'{0}' のオーバーライドがあいまいでした</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMoreThenOneOverride">
        <source>More than one override implements '{0}'</source>
        <target state="translated">複数のオーバーライドが '{0}' を実装しています</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsSealed">
        <source>The method '{0}' is sealed and cannot be overridden</source>
        <target state="translated">メソッド '{0}' がシールドであるため、オーバーライドできません</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideImplementsMoreThenOneSlot">
        <source>The override '{0}' implements more than one abstract slot, e.g. '{1}' and '{2}'</source>
        <target state="translated">オーバーライド '{0}' は複数の抽象スロットを実装しています (たとえば、'{1}' と '{2}')</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelDuplicateInterface">
        <source>Duplicate or redundant interface</source>
        <target state="translated">インターフェイスが重複するか、冗長です</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNeedExplicitImplementation">
        <source>The interface '{0}' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.</source>
        <target state="translated">複数の明示的に実装されたインターフェイス型に、インターフェイス '{0}' が含まれています。このインターフェイスの明示的な実装を追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNamedArgumentHasBeenAssignedMoreThenOnce">
        <source>A named argument has been assigned more than one value</source>
        <target state="translated">名前付き引数に複数の値が割り当てられました</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGiven">
        <source>No implementation was given for '{0}'</source>
        <target state="translated">'{0}' に指定された実装がありませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenWithSuggestion">
        <source>No implementation was given for '{0}'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">'{0}' に指定された実装がありませんでした。すべてのインターフェイス メンバーを実装し、適切な 'interface' 宣言で列挙してください (たとえば、'interface ... with member ...')。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfArguments">
        <source>The member '{0}' does not have the correct number of arguments. The required signature is '{1}'.</source>
        <target state="translated">メンバー '{0}' には引数の正しいメンバーがありません。必要なシグネチャは '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters">
        <source>The member '{0}' does not have the correct number of method type parameters. The required signature is '{1}'.</source>
        <target state="translated">メンバー '{0}' には正しい数のメソッド型パラメーターがありません。必要なシグネチャは '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters">
        <source>The member '{0}' does not have the correct kinds of generic parameters. The required signature is '{1}'.</source>
        <target state="translated">メンバー '{0}' には正しい種類のジェネリック パラメーターがありません。必要なシグネチャは '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberCannotImplement">
        <source>The member '{0}' cannot be used to implement '{1}'. The required signature is '{2}'.</source>
        <target state="translated">{1}' を実装するためにメンバー '{0}' は使用できません。必要なシグネチャは '{2}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILError">
        <source>Error while parsing embedded IL</source>
        <target state="translated">埋め込まれた IL の解析中にエラーが発生しました</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILTypeError">
        <source>Error while parsing embedded IL type</source>
        <target state="translated">埋め込まれた IL 型の解析中にエラーが発生しました</target>
        <note />
      </trans-unit>
      <trans-unit id="astDeprecatedIndexerNotation">
        <source>This indexer notation has been removed from the F# language</source>
        <target state="translated">このインデクサー表記は F# 言語から削除されました</target>
        <note />
      </trans-unit>
      <trans-unit id="astInvalidExprLeftHandOfAssignment">
        <source>Invalid expression on left of assignment</source>
        <target state="translated">代入式の左辺が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoRefEqualsOnStruct">
        <source>The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'.</source>
        <target state="translated">構造体で 'ReferenceEquality' 属性は使用できません。代わりに 'StructuralEquality' 属性を使用するか、'System.Object.Equals(obj)' のオーバーライドを実装してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="augInvalidAttrs">
        <source>This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'</source>
        <target state="translated">この型には、'NoEquality' 属性、'ReferenceEquality' 属性、'StructuralEquality' 属性、'NoComparison' 属性、および 'StructuralComparison' 属性の無効な組み合わせが使用されています</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqualityNeedsNoComparison">
        <source>The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute</source>
        <target state="translated">'NoEquality' 属性は、'NoComparison' 属性と組み合わせて使用する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructCompNeedsStructEquality">
        <source>The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute</source>
        <target state="translated">'StructuralComparison' 属性は、'StructuralEquality' 属性と組み合わせて使用する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructEqNeedsNoCompOrStructComp">
        <source>The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes</source>
        <target state="translated">'StructuralEquality' 属性は、'NoComparison' 属性または 'StructuralComparison' 属性と組み合わせて使用する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="augTypeCantHaveRefEqAndStructAttrs">
        <source>A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes</source>
        <target state="translated">1 つの型に 'ReferenceEquality' 属性および 'StructuralEquality' 属性、または 'ReferenceEquality' 属性および 'StructuralComparison' 属性を同時に使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="augOnlyCertainTypesCanHaveAttrs">
        <source>Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes</source>
        <target state="translated">'ReferenceEquality' 属性、'StructuralEquality' 属性、および 'StructuralComparison' 属性を使用して拡張できるのは、レコード型、共用体型、例外型、および構造体型のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="augRefEqCantHaveObjEquals">
        <source>A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">'ReferenceEquality' 属性を持つ型には、'Object.Equals(obj)'、'System.IEquatable&lt;_&gt;'、または 'System.Collections.IStructuralEquatable' を明示的に実装することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsObjEquals">
        <source>A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">'CustomEquality' 属性を持つ型には、’Object.Equals(obj)’、'System.IEquatable&lt;_&gt;' または 'System.Collections.IStructuralEquatable' の少なくとも 1 つの明示的な実装が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomCompareNeedsIComp">
        <source>A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'</source>
        <target state="translated">'CustomComparison' 属性を持つ型には、'System.IComparable' または 'System.Collections.IStructuralComparable' の少なくとも 1 つの明示的な実装が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqNeedsNoObjEquals">
        <source>A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">通常、'NoEquality' 属性を持つ型には、'Object.Equals(obj)' を明示的に実装しません。相互運用性のために意図的に実装した場合、この警告は無効にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoCompCantImpIComp">
        <source>A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable&lt;_&gt;' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">通常、'NoComparison' 属性を持つ型には、'System.IComparable'、'System.IComparable&lt;_&gt;'、または 'System.Collections.IStructuralComparable' を明示的に実装しません。相互運用性のために意図的に実装した場合、この警告は無効にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsNoCompOrCustomComp">
        <source>The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes</source>
        <target state="translated">'CustomEquality' 属性は、'NoComparison' 属性または 'CustomComparison' 属性と組み合わせて使用する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="forPositionalSpecifiersNotPermitted">
        <source>Positional specifiers are not permitted in format strings</source>
        <target state="translated">位置指定子は書式指定文字列で許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="forMissingFormatSpecifier">
        <source>Missing format specifier</source>
        <target state="translated">書式指定子がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="forFlagSetTwice">
        <source>'{0}' flag set twice</source>
        <target state="translated">'{0}' フラグが 2 回設定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrefixFlagSpacePlusSetTwice">
        <source>Prefix flag (' ' or '+') set twice</source>
        <target state="translated">プレフィックスのフラグ (' ' または '+') が 2 回設定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="forHashSpecifierIsInvalid">
        <source>The # formatting modifier is invalid in F#</source>
        <target state="translated"># 書式修飾子は F# では無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadPrecision">
        <source>Bad precision in format specifier</source>
        <target state="translated">書式指定子の精度に誤りがあります</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadWidth">
        <source>Bad width in format specifier</source>
        <target state="translated">書式指定子の幅に誤りがあります</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportZeroFlag">
        <source>'{0}' format does not support '0' flag</source>
        <target state="translated">'{0}' 形式は '0' フラグをサポートしていません</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrecisionMissingAfterDot">
        <source>Precision missing after the '.'</source>
        <target state="translated">'.' の後に精度がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatDoesntSupportPrecision">
        <source>'{0}' format does not support precision</source>
        <target state="translated">'{0}' 形式は精度をサポートしていません</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifier">
        <source>Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">(l または L の後の) 書式指定子に誤りがあります。ld、li、lo、lu、lx、または lX を指定してください。F# コードでは、代わりに %d、%x、%o、または %u を使用できます。これらは、すべての基本的な整数型を扱うためにオーバーロードされます。</target>
        <note />
      </trans-unit>
      <trans-unit id="forLIsUnnecessary">
        <source>The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">この書式指定子に 'l' または 'L' は不要です。F# のコードでは、%d、%x、%o、または %u を使用できます。これらは、すべての基本的な整数型を扱うためにオーバーロードされます。</target>
        <note />
      </trans-unit>
      <trans-unit id="forHIsUnnecessary">
        <source>The 'h' or 'H' in this format specifier is unnecessary. You can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">この書式指定子に 'h' または 'H' は不要です。代わりに %d、%x、%o、または %u を使用できます。これらは、すべての基本的な整数型を扱うためにオーバーロードされます。</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportPrefixFlag">
        <source>'{0}' does not support prefix '{1}' flag</source>
        <target state="translated">{0}' はプレフィックスの '{1}' フラグをサポートしていません</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifierGeneral">
        <source>Bad format specifier: '{0}'</source>
        <target state="translated">書式指定子に誤りがあります:'{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="elSysEnvExitDidntExit">
        <source>System.Environment.Exit did not exit</source>
        <target state="translated">System.Environment.Exit が終了しませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="elDeprecatedOperator">
        <source>The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined</source>
        <target state="translated">この演算子は F# コンパイラーが直接処理するようになったため、演算子の意味を再定義することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkProtectedOrBaseCalled">
        <source>A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope.</source>
        <target state="translated">プロテクト メンバーが呼び出されたか、'base' が使用されています。この操作が許可されているのはメンバーの直接実装の場合のみです。直接実装ではオブジェクトのスコープを回避できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkByrefUsedInInvalidWay">
        <source>The byref-typed variable '{0}' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.</source>
        <target state="translated">byref 型の変数 '{0}' の使用方法に誤りがあります。byref をクロージャでキャプチャすること、または内部関数に渡すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkBaseUsedInInvalidWay">
        <source>The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.</source>
        <target state="translated">'base' キーワードの使用方法に誤りがあります。'base' の呼び出しはクロージャに使用できません。'base' の呼び出しを行うには、プライベート メンバーを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkVariableUsedInInvalidWay">
        <source>The variable '{0}' is used in an invalid way</source>
        <target state="translated">変数 '{0}' の使用方法に誤りがあります</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTypeLessAccessibleThanType">
        <source>The type '{0}' is less accessible than the value, member or type '{1}' it is used in.</source>
        <target state="translated">型 '{0}' は、使用されている値、メンバー、型 '{1}' よりもアクセシビリティが低く設定されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSystemVoidOnlyInTypeof">
        <source>'System.Void' can only be used as 'typeof&lt;System.Void&gt;' in F#</source>
        <target state="translated">F# では、'System.Void' は 'typeof&lt;System.Void&gt;' としてのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorUseOfByref">
        <source>A type instantiation involves a byref type. This is not permitted by the rules of Common IL.</source>
        <target state="translated">型のインスタンス化に byref 型が使用されています。この操作は Common IL の規則では許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorContainsCallToRethrow">
        <source>Calls to 'reraise' may only occur directly in a handler of a try-with</source>
        <target state="translated">'reraise' への呼び出しを直接実行できるのは、try-with ハンドラーの中のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSplicingOnlyInQuotations">
        <source>Expression-splicing operators may only be used within quotations</source>
        <target state="translated">式スプライス演算子は引用符で囲む必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassSplicing">
        <source>First-class uses of the expression-splicing operator are not permitted</source>
        <target state="translated">式スプライス演算子のファーストクラスの使用は許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassAddressOf">
        <source>First-class uses of the address-of operators are not permitted</source>
        <target state="translated">アドレス演算子のファーストクラスの使用は許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassRethrow">
        <source>First-class uses of the 'reraise' function is not permitted</source>
        <target state="translated">'reraise' 関数のファーストクラスの使用は許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAtThisPoint">
        <source>The byref typed value '{0}' cannot be used at this point</source>
        <target state="translated">この時点で byref 型の値 '{0}' は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkLimitationsOfBaseKeyword">
        <source>'base' values may only be used to make direct calls to the base implementations of overridden members</source>
        <target state="translated">'base' 値を使用できるのは、オーバーライドされたメンバーの基本実装に対して直接呼び出しを行う場合のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkObjCtorsCantUseExceptionHandling">
        <source>Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.</source>
        <target state="translated">オブジェクト コンストラクターでは、オブジェクトの初期化前に try/with および try/finally を直接使用できません。'for x in ...' などのコストラクトを呼び出す可能性があるようなコンストラクトがこれに含まれます。これは Common IL での制限事項です。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfAtThisPoint">
        <source>The address of the variable '{0}' cannot be used at this point</source>
        <target state="translated">この時点で変数 '{0}' のアドレスは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressStaticFieldAtThisPoint">
        <source>The address of the static field '{0}' cannot be used at this point</source>
        <target state="translated">この時点で静的フィールド '{0}' のアドレスは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressFieldAtThisPoint">
        <source>The address of the field '{0}' cannot be used at this point</source>
        <target state="translated">この時点でフィールド '{0}' のアドレスは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfArrayElementAtThisPoint">
        <source>The address of an array element cannot be used at this point</source>
        <target state="translated">この時点で配列要素のアドレスは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFirstClassFuncNoByref">
        <source>The type of a first-class function cannot contain byrefs</source>
        <target state="translated">ファーストクラス関数の型に byref を含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReturnTypeNoByref">
        <source>A method return type would contain byrefs which is not permitted</source>
        <target state="translated">メソッドの戻り値の型に許可されていない byref が含まれています</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidCustAttrVal">
        <source>Invalid custom attribute value (not a constant or literal)</source>
        <target state="translated">カスタム属性値が無効です (定数またはリテラルではありません)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkAttrHasAllowMultiFalse">
        <source>The attribute type '{0}' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element.</source>
        <target state="translated">属性の型 '{0}' に 'AllowMultiple=false' があります。この属性を持つ複数のインスタンスは、単一の言語要素にアタッチできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to its definition at or near '{2}'. This is an invalid forward reference.</source>
        <target state="translated">メンバー '{0}' の使用方法に誤りがあります。'{2}' または '{2}' 付近の定義の前に '{1}' の使用が推論されました。これは無効な前方参照です。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAsTopValue">
        <source>A byref typed value would be stored here. Top-level let-bound byref values are not permitted.</source>
        <target state="translated">byref 型の値がここに保存されます。トップレベルの let-bound byref 値は許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReflectedDefCantSplice">
        <source>[&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">[&lt;ReflectedDefinition&gt;] 用語には、プレフィックスのスプライス演算子 '%' を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkEntryPointUsage">
        <source>A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence.</source>
        <target state="translated">'EntryPointAttribute' 属性のラベルを付けた関数は、コンパイル シーケンスの最後のファイルの最後の宣言にする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseCompiledForm">
        <source>compiled form of the union case</source>
        <target state="translated">共用体ケースのコンパイル済みの形式</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseDefaultAugmentation">
        <source>default augmentation of the union case</source>
        <target state="translated">共用体ケースの既定の拡張</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameMethod">
        <source>The property '{0}' has the same name as a method in type '{1}'.</source>
        <target state="translated">プロパティ '{0}' は、型 '{1}' のメソッドと名前が同じです。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterSetterDoNotMatchAbstract">
        <source>The property '{0}' of type '{1}' has a getter and a setter that do not match. If one is abstract then the other must be as well.</source>
        <target state="translated">型 '{1}' のプロパティ '{0}' には一致しないゲッターとセッターがあります。一方が抽象の場合、もう一方も抽象にします。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameIndexer">
        <source>The property '{0}' has the same name as another property in type '{1}', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.</source>
        <target state="translated">プロパティ '{0}' は型 '{1}' の別のプロパティと名前が同じですが、一方はインデクサー引数を使用し、もう一方は使用していません。一方のプロパティでインデクサー引数を失う可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCantStoreByrefValue">
        <source>A type would store a byref typed value. This is not permitted by Common IL.</source>
        <target state="translated">型に byref 型の値が保存されています。この操作は Common IL では許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethod">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}'.</source>
        <target state="translated">重複したメソッド。メソッド '{0}' は、名前とシグネチャが型 '{1}' の別のメソッドと同じです。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodWithSuffix">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">重複したメソッド。メソッド '{0}' は、タプル、関数、測定単位、指定された型が消去されると、名前とシグネチャが型 '{1}' の他のメソッドと同じになります。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodCurried">
        <source>The method '{0}' has curried arguments but has the same name as another method in type '{1}'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.</source>
        <target state="translated">メソッド '{0}' にはカリー化された引数が使用されていますが、型 '{1}' の別のメソッドと名前が同じです。カリー化された引数を使用したメソッドはオーバーロードできません。メソッドにはタプル化された引数を使用することをご検討ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCurriedMethodsCantHaveOutParams">
        <source>Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments</source>
        <target state="translated">カリー化された引数を使用したメソッドでは、'out'、'ParamArray'、'optional'、'ReflectedDefinition'、'byref'、'CallerLineNumber'、'CallerMemberName'、または 'CallerFilePath' の各引数を宣言できません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateProperty">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}'.</source>
        <target state="translated">重複したプロパティ。プロパティ '{0}' は、名前とシグネチャが型 '{1}' の別のプロパティと同じです。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicatePropertyWithSuffix">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">重複したプロパティ。プロパティ '{0}' は、タプル、関数、測定単位、指定された型が消去されると、名前とシグネチャが型 '{1}' の別のプロパティと同じになります。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedType">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type.</source>
        <target state="translated">重複したメソッド。抽象メソッド '{0}' は、名前とシグネチャが継承型の抽象メソッドと同じです。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedTypeWithSuffix">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">重複したメソッド。抽象メソッド '{0}' は、タプル、関数、測定単位、または指定された型が消去されると、名前とシグネチャが継承型の抽象メソッドと同じになります。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMultipleGenericInterfaceInstantiations">
        <source>This type implements the same interface at different generic instantiations '{0}' and '{1}'. This is not permitted in this version of F#.</source>
        <target state="translated">この型は、異なるジェネリックのインスタンス化 '{0}' と '{1}' で同じインターフェイスを実装しています。これは、このバージョンの F# で許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkValueWithDefaultValueMustHaveDefaultValue">
        <source>The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check</source>
        <target state="translated">'DefaultValue' 属性を使用するフィールドの型は、既定の初期化を許可する必要があります。つまり、'null' が正規の値として含まれるか、すべてのフィールドが既定の初期化を許可する構造体型です。このチェックを無効にするには、'DefaultValue(false)' を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefInTypeAbbrev">
        <source>The type abbreviation contains byrefs. This is not permitted by F#.</source>
        <target state="translated">型略称に byref が含まれます。この操作は F# で許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="crefBoundVarUsedInSplice">
        <source>The variable '{0}' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.</source>
        <target state="translated">変数 '{0}' は引用符内でバインドされていますが、スプライスされた式の一部として使用されています。スコープが回避される可能性があるため、この操作は許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericExprs">
        <source>Quotations cannot contain uses of generic expressions</source>
        <target state="translated">引用符内にはジェネリック式の使用を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericFunctions">
        <source>Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.</source>
        <target state="translated">引用符内には、ジェネリック型に推論または宣言する関数定義を含めることはできません。有効な引用符付きの式にするには、何らかの型の制約を追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainObjExprs">
        <source>Quotations cannot contain object expressions</source>
        <target state="translated">引用符内には、オブジェクト式を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainAddressOf">
        <source>Quotations cannot contain expressions that take the address of a field</source>
        <target state="translated">引用符内には、フィールドのアドレスを使用した式を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainStaticFieldRef">
        <source>Quotations cannot contain expressions that fetch static fields</source>
        <target state="translated">引用符内には、静的フィールドをフェッチする式を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainInlineIL">
        <source>Quotations cannot contain inline assembly code or pattern matching on arrays</source>
        <target state="translated">引用符内にインライン アセンブラー コードまたは配列のパターン マッチを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainDescendingForLoops">
        <source>Quotations cannot contain descending for loops</source>
        <target state="translated">引用符内に降順の for loop を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantFetchUnionIndexes">
        <source>Quotations cannot contain expressions that fetch union case indexes</source>
        <target state="translated">引用符内には、共用体ケースのインデックスをフェッチする式を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetUnionFields">
        <source>Quotations cannot contain expressions that set union case fields</source>
        <target state="translated">引用符内には、共用体ケースのフィールドを設定する式を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetExceptionFields">
        <source>Quotations cannot contain expressions that set fields in exception values</source>
        <target state="translated">引用符内には、例外値のフィールドを設定する式を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantRequireByref">
        <source>Quotations cannot contain expressions that require byref pointers</source>
        <target state="translated">引用符内には、byref ポインターを必要とする式を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantCallTraitMembers">
        <source>Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call</source>
        <target state="translated">引用符内にメンバーの制約を呼び出す式を含めること、または暗黙的にメンバーの制約の呼び出しに解決される演算子を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisConstant">
        <source>Quotations cannot contain this kind of constant</source>
        <target state="translated">引用符内には、この種類の定数を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisPatternMatch">
        <source>Quotations cannot contain this kind of pattern match</source>
        <target state="translated">引用符内には、この種類のパターン マッチを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainArrayPatternMatching">
        <source>Quotations cannot contain array pattern matching</source>
        <target state="translated">引用符内には、配列のパターン マッチを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisType">
        <source>Quotations cannot contain this kind of type</source>
        <target state="translated">引用符内には、この種類の型を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeCannotBeResolvedAtCompileTime">
        <source>The declared type parameter '{0}' cannot be used here since the type parameter cannot be resolved at compile time</source>
        <target state="translated">宣言された型パラメーター '{0}' はコンパイル時に解決できないため、使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="csCodeLessGeneric">
        <source>This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'.</source>
        <target state="translated">このコードは注釈よりも総称性が低く設定されています。'_' を使用して指定された単位は、'1' (無次元) と判断されます。コードをジェネリックにするか、'_' を使用しないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInferenceMaxDepth">
        <source>Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.</source>
        <target state="translated">複雑すぎるため、型推論ができません (最大反復回数に達しました)。さらに詳細な型の注釈を増やしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectedArguments">
        <source>Expected arguments to an instance member</source>
        <target state="translated">インスタンス メンバーに対して引数を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="csIndexArgumentMismatch">
        <source>This indexer expects {0} arguments but is here given {1}</source>
        <target state="translated">このインデクサーには {0} 個の引数が必要ですが、存在するのは {1} 個です</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenFunction">
        <source>Expecting a type supporting the operator '{0}' but given a function type. You may be missing an argument to a function.</source>
        <target state="translated">演算子 '{0}' をサポートし、特定の関数型である型が必要です。関数に対する引数が足りない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenTuple">
        <source>Expecting a type supporting the operator '{0}' but given a tuple type</source>
        <target state="translated">演算子 '{0}' をサポートする型が必要ですが、タプル型が指定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperator">
        <source>None of the types '{0}' support the operator '{1}'</source>
        <target state="translated">型 '{0}' はいずれも演算子 '{1}' をサポートしていません</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperator">
        <source>The type '{0}' does not support the operator '{1}'</source>
        <target state="translated">型 '{0}' は演算子 '{1}' をサポートしていません</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperatorNullable">
        <source>None of the types '{0}' support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">型 '{0}' はいずれも演算子 '{1}' をサポートしていません。'Microsoft.FSharp.Linq.NullableOperators' モジュールを開いてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperatorNullable">
        <source>The type '{0}' does not support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">型 '{0}' は演算子 '{1}' をサポートしていません。'Microsoft.FSharp.Linq.NullableOperators' モジュールを開いてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportConversion">
        <source>The type '{0}' does not support a conversion to the type '{1}'</source>
        <target state="translated">型 '{0}' は型 '{1}' への変換をサポートしていません</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is static</source>
        <target state="translated">型 '{0}' にメソッド '{1}' (フル ネームは '{2}') がありますが、メソッドは静的です</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsNotStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is not static</source>
        <target state="translated">型 '{0}' にメソッド '{1}' (フル ネームは '{2}') がありますが、メソッドは静的ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="csStructConstraintInconsistent">
        <source>The constraints 'struct' and 'not struct' are inconsistent</source>
        <target state="translated">'struct' および 'not struct' という制約は矛盾しています</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value</source>
        <target state="translated">型 '{0}' に 'null' は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="csNullableTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'.</source>
        <target state="translated">型 '{0}' に 'null' は使用できません。Null 許容型に対して null 値を作成するには、'System.Nullable()' を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison1">
        <source>The type '{0}' does not support the 'comparison' constraint because it has the 'NoComparison' attribute</source>
        <target state="translated">型 '{0}' は 'NoComparison' 属性があるため、'comparison' 制約をサポートしません</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison2">
        <source>The type '{0}' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface</source>
        <target state="translated">型 '{0}' は 'comparison' 制約をサポートしません。たとえば、'System.IComparable' インターフェイスをサポートしません。</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison3">
        <source>The type '{0}' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison</source>
        <target state="translated">型 '{0}' は、'comparison' 制約をサポートしない 1 個または複数の構造体の要素型を持つレコード、共用体、または構造体なので、'comparison' 制約をサポートしません。この型では comparison を使用しないようにするか、または、comparison をサポートしないフィールド型を決定するために、'StructuralComparison' 属性を型に追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality1">
        <source>The type '{0}' does not support the 'equality' constraint because it has the 'NoEquality' attribute</source>
        <target state="translated">型 '{0}' は 'NoEquality' 属性があるため、'equality' 制約をサポートしません</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality2">
        <source>The type '{0}' does not support the 'equality' constraint because it is a function type</source>
        <target state="translated">型 '{0}' は関数型なので、'equality' 制約をサポートしません</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality3">
        <source>The type '{0}' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality</source>
        <target state="translated">型 '{0}' は、'equality' 制約をサポートしない 1 個または複数の構造体の要素型を持つレコード、共用体、または構造体なので、'equality' 制約をサポートしません。この型を持つ equality を使用しないでください。または、equality をサポートしないフィールド型を決定するために、'StructuralEquality' 属性を型に追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotEnumType">
        <source>The type '{0}' is not a CLI enum type</source>
        <target state="translated">型 '{0}' は CLI の列挙型ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeHasNonStandardDelegateType">
        <source>The type '{0}' has a non-standard delegate type</source>
        <target state="translated">型 '{0}' には標準ではないデリゲート型があります</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotDelegateType">
        <source>The type '{0}' is not a CLI delegate type</source>
        <target state="translated">型 '{0}' は CLI のデリゲート型ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeParameterCannotBeNullable">
        <source>This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values.</source>
        <target state="translated">の型パラメーターは 'Nullable' にインスタンス化できません。別の CLI 言語などでも 'Nullable' の値との関係で、'null' の意味があいまいにならないように、この制限があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructType">
        <source>A generic construct requires that the type '{0}' is a CLI or F# struct type</source>
        <target state="translated">ジェネリック コンストラクトの型 '{0}' は、CLI または F# の構造体型にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresUnmanagedType">
        <source>A generic construct requires that the type '{0}' is an unmanaged type</source>
        <target state="translated">ジェネリック コンストラクターの型 '{0}' はアンマネージ型にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeNotCompatibleBecauseOfPrintf">
        <source>The type '{0}' is not compatible with any of the types {1}, arising from the use of a printf-style format string</source>
        <target state="translated">型 '{0}' は、printf 形式の書式指定文字列の使用によって生じる型 {1} のいずれとも互換性がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresReferenceSemantics">
        <source>A generic construct requires that the type '{0}' have reference semantics, but it does not, i.e. it is a struct</source>
        <target state="translated">ジェネリック コンストラクトの型 '{0}' には参照のセマンティクスが必要ですが、存在しません (つまり構造体です)</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresNonAbstract">
        <source>A generic construct requires that the type '{0}' be non-abstract</source>
        <target state="translated">ジェネリック コンストラクトの型 '{0}' は、非抽象にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresPublicDefaultConstructor">
        <source>A generic construct requires that the type '{0}' have a public default constructor</source>
        <target state="translated">ジェネリック コンストラクトの型 '{0}' には、パブリック既定コンストラクターが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInstantiationLengthMismatch">
        <source>Type instantiation length mismatch</source>
        <target state="translated">型のインスタンス化の長さが一致しません</target>
        <note />
      </trans-unit>
      <trans-unit id="csOptionalArgumentNotPermittedHere">
        <source>Optional arguments not permitted here</source>
        <target state="translated">オプションの引数は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotStatic">
        <source>{0} is not a static member</source>
        <target state="translated">{0} は静的メンバーではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotInstance">
        <source>{0} is not an instance member</source>
        <target state="translated">{0} はインスタンス メンバーではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentLengthMismatch">
        <source>Argument length mismatch</source>
        <target state="translated">引数の長さが一致しません</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentTypesDoNotMatch">
        <source>The argument types don't match</source>
        <target state="translated">引数の型が一致しません</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodExpectsParams">
        <source>This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument</source>
        <target state="translated">このメソッドのこの位置には、CLI 'params' パラメーターが必要です。'params' は、可変個数の引数を C# などの言語のメソッドに渡すときに使用されます。この引数には配列を渡してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible">
        <source>The member or object constructor '{0}' is not {1}</source>
        <target state="translated">メンバーまたはオブジェクト コンストラクター '{0}' は {1} ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible2">
        <source>The member or object constructor '{0}' is not {1}. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.</source>
        <target state="translated">メンバーまたはオブジェクト コンストラクター '{0}' は {1} ではありません。プライベート メンバーには、宣言する型の中からのみアクセスできます。プロテクト メンバーには、拡張する型からのみアクセスでき、内部ラムダ式からアクセスすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAStaticMethod">
        <source>{0} is not a static method</source>
        <target state="translated">{0} は静的メソッドではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAnInstanceMethod">
        <source>{0} is not an instance method</source>
        <target state="translated">{0} はインスタンス メソッドではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberHasNoArgumentOrReturnProperty">
        <source>The member or object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">メンバーまたはオブジェクト コンストラクター '{0}' には、引数または設定可能な戻り値のプロパティ '{1}' がありません。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorHasNoArgumentOrReturnProperty">
        <source>The object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">オブジェクト コンストラクター '{0}' には、引数または設定可能な戻り値のプロパティ '{1}' がありません。{2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="csRequiredSignatureIs">
        <source>The required signature is {0}</source>
        <target state="translated">必要なシグネチャは {0} です</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'.</source>
        <target state="translated">メンバーまたはオブジェクト コンストラクター '{0}' には {1} 個の引数が必要です。必要なシグネチャは '{2}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch2">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'.</source>
        <target state="translated">メンバーまたはオブジェクト コンストラクター '{0}' には追加で {1} 個の引数が必要です。必要なシグネチャは '{2}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch3">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">メンバーまたはオブジェクト コンストラクター '{0}' には {1} 個の引数が必要です。必要なシグネチャは '{2}' です。足りない引数の名前は {3} です。</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch4">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">メンバーまたはオブジェクト コンストラクター '{0}' には追加で {1} 個の引数が必要です。必要なシグネチャは '{2}' です。足りない引数の名前は {3} です。</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityNamed">
        <source>The member or object constructor '{0}' requires {1} argument(s) but is here given {2} unnamed and {3} named argument(s). The required signature is '{4}'.</source>
        <target state="translated">メンバーまたはオブジェクト コンストラクター '{0}' には {1} 個の引数が必要ですが、名前がない引数が {2} 個、名前付き引数が {3} 個です。必要なシグネチャは '{4}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArity">
        <source>The member or object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">メンバーまたはオブジェクト コンストラクター '{0}' には {1} 個の引数が必要ですが、{2} 個です。必要なシグネチャは '{3}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArity">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">オブジェクト コンストラクター '{0}' には {1} 個の引数が必要ですが、指定されているのは {2} 個です。必要なシグネチャは '{3}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArityProp">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',').</source>
        <target state="translated">オブジェクト コンストラクター '{0}' には {1} 個の引数が必要ですが、指定されているのは {2} 個です。必要なシグネチャは '{3}' です。いくつかの引数がプロパティに値を割り当てる引数である場合は、それらの引数をコンマ (',') で区切ることを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityType">
        <source>The member or object constructor '{0}' takes {1} type argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">メンバーまたはオブジェクト コンストラクター '{0}' には {1} 個の型引数が必要ですが、存在するのは {2} 個です。必要なシグネチャは '{3}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberNotAccessible">
        <source>A member or object constructor '{0}' taking {1} arguments is not accessible from this code location. All accessible versions of method '{2}' take {3} arguments.</source>
        <target state="translated">{1} 個の引数を使用するメンバーまたはオブジェクト コンストラクター '{0}' は、このコードの場所からはアクセスできません。メソッド '{2}' のすべてのアクセス可能なバージョンは {3} 個の引数を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="csIncorrectGenericInstantiation">
        <source>Incorrect generic instantiation. No {0} member named '{1}' takes {2} generic arguments.</source>
        <target state="translated">ジェネリックのインスタンス化が正しくありません。{2} のジェネリック引数を使用する '{1}' という {0} メンバーはありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberOverloadArityMismatch">
        <source>The member or object constructor '{0}' does not take {1} argument(s). An overload was found taking {2} arguments.</source>
        <target state="translated">メンバーまたはオブジェクト コンストラクター '{0}' は {1} 個の引数ではありません。{2} 個の引数を使用するオーバーロードが見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments</source>
        <target state="translated">{2} 個の引数を使用する {0} メンバーまたはオブジェクト コンストラクター '{1}' がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments2">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. Note the call to this member also provides {3} named arguments.</source>
        <target state="translated">{2} 個の引数を使用する {0} メンバーまたはオブジェクト コンストラクター '{1}' がありません。このメンバーの呼び出しには、{3} 個の名前付き引数も必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments3">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. The named argument '{3}' doesn't correspond to any argument or settable return property for any overload.</source>
        <target state="translated">{2} 個の引数を使用する {0} メンバーまたはオブジェクト コンストラクター '{1}' がありません。名前付き引数 '{3}' に対応する、オーバーロードに合致した任意の引数、または設定可能な戻り値のプロパティはありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodNotFound">
        <source>Method or object constructor '{0}' not found</source>
        <target state="translated">メソッドまたはオブジェクト コンストラクター '{0}' が見つかりません</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFound">
        <source>No overloads match for method '{0}'.</source>
        <target state="translated">メソッド '{0}' に一致するオーバーロードはありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsOverloaded">
        <source>A unique overload for method '{0}' could not be determined based on type information prior to this program point. A type annotation may be needed.</source>
        <target state="translated">このプログラム ポイントよりも前の型情報に基づいて、メソッド '{0}' の固有のオーバーロードを決定することができませんでした。型の注釈が必要な場合があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="csCandidates">
        <source>Candidates: {0}</source>
        <target state="translated">候補: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csSeeAvailableOverloads">
        <source>The available overloads are shown below.</source>
        <target state="translated">使用できるオーバーロードを以下に示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsDoCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on 'do' bindings, but '{0}' was given.</source>
        <target state="translated">'do' バインドにはアクセシビリティ修飾子を使用できませんが、'{0}' が指定されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInHashIf">
        <source>End of file in #if section begun at or after here</source>
        <target state="translated">この位置以前に始まった #if セクションの途中でファイルの終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInString">
        <source>End of file in string begun at or before here</source>
        <target state="translated">この位置以前に始まった文字列の途中でファイルの終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimString">
        <source>End of file in verbatim string begun at or before here</source>
        <target state="translated">この位置以前に始まった verbatim 文字列の途中でファイルの終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInComment">
        <source>End of file in comment begun at or before here</source>
        <target state="translated">この位置以前に始まったコメントの途中でファイルの終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInStringInComment">
        <source>End of file in string embedded in comment begun at or before here</source>
        <target state="translated">この位置以前に始まったコメントに埋め込まれた文字列の途中でファイルの終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimStringInComment">
        <source>End of file in verbatim string embedded in comment begun at or before here</source>
        <target state="translated">この位置以前に始まったコメントに埋め込まれた verbatim 文字列の途中でファイルの終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInIfOcaml">
        <source>End of file in IF-OCAML section begun at or before here</source>
        <target state="translated">この位置以前に始まった IF-OCAML セクションの途中でファイルの終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInDirective">
        <source>End of file in directive begun at or before here</source>
        <target state="translated">この位置以前に始まったディレクティブの途中でファイルの終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoHashEndIfFound">
        <source>No #endif found for #if or #else</source>
        <target state="translated">#if または #else の #endif が見つかりません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIgnored">
        <source>Attributes have been ignored in this construct</source>
        <target state="translated">このコンストラクトの属性は無視されました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInImplicitClassConstructors">
        <source>'use' bindings are not permitted in primary constructors</source>
        <target state="translated">プライマリ コンストラクターに 'use' 束縛は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInModules">
        <source>'use' bindings are not permitted in modules and are treated as 'let' bindings</source>
        <target state="translated">モジュールに 'use' 束縛は使用できません。この束縛は 'let' 束縛として扱われます。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIntegerForLoopRequiresSimpleIdentifier">
        <source>An integer for loop must use a simple identifier</source>
        <target state="translated">ループの整数には単純な識別子を使用する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyOneWithAugmentationAllowed">
        <source>At most one 'with' augmentation is permitted</source>
        <target state="translated">使用できる 'with' の拡張の数は 1 以下です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSemicolon">
        <source>A semicolon is not expected at this point</source>
        <target state="translated">この位置にセミコロンは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFile">
        <source>Unexpected end of input</source>
        <target state="translated">予期しない入力の終わりです:</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedVisibilityDeclaration">
        <source>Accessibility modifiers are not permitted here, but '{0}' was given.</source>
        <target state="translated">ここではアクセシビリティ修飾子を使用できませんが、'{0}' が指定されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyHashDirectivesAllowed">
        <source>Only '#' compiler directives may occur prior to the first 'namespace' declaration</source>
        <target state="translated">最初の 'namespace' 宣言の前に指定できるのは、'#' コンパイラ ディレクティブのみです</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityDeclarationsShouldComePriorToIdentifier">
        <source>Accessibility modifiers should come immediately prior to the identifier naming a construct</source>
        <target state="translated">アクセシビリティ修飾子は、コンストラクトを示す識別子の直前に指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNamespaceOrModuleNotBoth">
        <source>Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'</source>
        <target state="translated">ファイルは名前空間またはモジュールの宣言から開始する必要があります。たとえば、'namespace SomeNamespace.SubNamespace'、'module SomeNamespace.SomeModule' などです。ただし、両方は指定しません。名前空間内でモジュールを定義するには、'module SomeModule = ...' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleAbbreviationMustBeSimpleName">
        <source>A module abbreviation must be a simple name, not a path</source>
        <target state="translated">モジュールの省略形はパスではなく簡易名にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviation">
        <source>Ignoring attributes on module abbreviation</source>
        <target state="translated">モジュールの省略形にある属性を無視します</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">モジュールの省略形には '{0}' アクセシビリティ属性を使用できません。モジュールの省略形は常にプライベートです。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">モジュールの省略形には '{0}' 可視属性を使用できません。モジュールの省略形は常にプライベートです。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnClosedBlockInHashLight">
        <source>Unclosed block</source>
        <target state="translated">ブロックが閉じられていません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBeginOrStruct">
        <source>Unmatched 'begin' or 'struct'</source>
        <target state="translated">'begin' または 'struct' が対応しません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleDefnMustBeSimpleName">
        <source>A module name must be a simple name, not a path</source>
        <target state="translated">モジュール名はパスではなく簡易名にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEmptyModuleDefn">
        <source>Unexpected empty type moduleDefn list</source>
        <target state="translated">予期しない空の型の moduleDefn リストです:</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesMustComeBeforeVal">
        <source>Attributes should be placed before 'val'</source>
        <target state="translated">属性は 'val' の前に配置してください</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesAreNotPermittedOnInterfaceImplementations">
        <source>Attributes are not permitted on interface implementations</source>
        <target state="translated">インターフェイスの実装に属性は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxError">
        <source>Syntax error</source>
        <target state="translated">構文エラー</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAugmentationsIllegalOnDelegateType">
        <source>Augmentations are not permitted on delegate type moduleDefns</source>
        <target state="translated">デリゲート型 moduleDefns では拡張が許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedClassInterfaceOrStruct">
        <source>Unmatched 'class', 'interface' or 'struct'</source>
        <target state="translated">'class'、'interface'、または 'struct' が対応しません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyTypeDefinition">
        <source>A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'.</source>
        <target state="translated">型定義には、1 つまたは複数のメンバーまたは他の宣言が必要です。空のクラス、構造体、またはインターフェイスを定義する場合、'type ... = class end'、'interface end'、または 'struct end' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedWith">
        <source>Unmatched 'with' or badly formatted 'with' block</source>
        <target state="translated">with' が対応しないか、'with' ブロックの形式に誤りがあります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetOrSetRequired">
        <source>'get', 'set' or 'get,set' required</source>
        <target state="translated">'get'、'set'、または 'get,set' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyClassCanTakeValueArguments">
        <source>Only class types may take value arguments</source>
        <target state="translated">値の引数を使用できるのはクラス型のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBegin">
        <source>Unmatched 'begin'</source>
        <target state="translated">'begin' が対応しません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidDeclarationSyntax">
        <source>Invalid declaration syntax</source>
        <target state="translated">宣言の構文が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetAndOrSetRequired">
        <source>'get' and/or 'set' required</source>
        <target state="translated">'get'、'set'、またはその両方が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAnnotationsOnGetSet">
        <source>Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'</source>
        <target state="translated">プロパティのゲッターおよびセッターでは、'get()' または 'set(v)' の後に型の注釈を指定する必要があります。たとえば、'with get() : string = ...' などです。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterMustHaveAtLeastOneArgument">
        <source>A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'</source>
        <target state="translated">ゲッターのプロパティは関数にする必要があります (たとえば、'get() = ...'、'get(index) = ...')</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultipleAccessibilitiesForGetSet">
        <source>Multiple accessibilities given for property getter or setter</source>
        <target state="translated">プロパティのゲッターまたはセッターに指定されたアクセシビリティが複数あります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetSyntax">
        <source>Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '</source>
        <target state="translated">プロパティ Set アクセス操作子を定義するには、'set value = '、'set idx value = '、または 'set (idx1,...,idxN) value = ... ' を使用する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInterfacesHaveSameVisibilityAsEnclosingType">
        <source>Interfaces always have the same visibility as the enclosing type</source>
        <target state="translated">インターフェイスは、それを囲む型と常に同じ可視性を持ちます</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAccessibilityModsIllegalForAbstract">
        <source>Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.</source>
        <target state="translated">アクセシビリティ修飾子はこのメンバーでは許可されていません。抽象スロットには、それを囲む型と常に同じ可視性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalOnInherit">
        <source>Attributes are not permitted on 'inherit' declarations</source>
        <target state="translated">'inherit' 宣言に属性は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityIllegalOnInherit">
        <source>Accessibility modifiers are not permitted on an 'inherits' declaration</source>
        <target state="translated">'inherits' 宣言にアクセシビリティ修飾子は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInheritDeclarationsCannotHaveAsBindings">
        <source>'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding.</source>
        <target state="translated">'inherit' 宣言に 'as' 束縛は指定できません。メソッドをオーバーライドするときに基底クラスのメンバーにアクセスするには、'base.SomeMember' という構文を使用できます。'base' はキーワードです。この 'as' 束縛は削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalHere">
        <source>Attributes are not allowed here</source>
        <target state="translated">ここでは属性を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for type abbreviations</source>
        <target state="translated">型略称のこの位置にアクセシビリティ修飾子は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumTypesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for enum types</source>
        <target state="translated">列挙型のこの位置にアクセシビリティ修飾子は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAllEnumFieldsRequireValues">
        <source>All enum fields must be given values</source>
        <target state="translated">すべての列挙型フィールドに値を指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInlineAssemblyCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on inline assembly code types</source>
        <target state="translated">アクセシビリティ修飾子はインライン アセンブラー コード型では許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIdentifier">
        <source>Unexpected identifier: '{0}'</source>
        <target state="translated">予期しない識別子: '{0}':</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnionCasesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">アクセシビリティ修飾子は共用体ケースに使用できません。表現全体にアクセシビリティを付与するには、'type U = internal ...' または 'type U = private ...' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on enumeration fields</source>
        <target state="translated">列挙型フィールドにアクセシビリティ修飾子は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsConsiderUsingSeparateRecordType">
        <source>Consider using a separate record type instead</source>
        <target state="translated">代わりに別のレコード型を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="parsRecordFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">アクセシビリティ修飾子はレコード フィールドに使用できません。表現全体にアクセシビリティを付与するには、'type R = internal ...' または 'type R = private ...' を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="parsLetAndForNonRecBindings">
        <source>The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings</source>
        <target state="translated">非再帰的な束縛の宣言の形式 'let ... and ...' は、F# コードでは使用されません。'let' 束縛のシーケンスを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedParen">
        <source>Unmatched '('</source>
        <target state="translated">'(' が対応しません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessivePatternsShouldBeSpacedOrTupled">
        <source>Successive patterns should be separated by spaces or tupled</source>
        <target state="translated">複数のパターンが連続する場合、スペースで区切るかタプル化します</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoMatchingInForLet">
        <source>No matching 'in' found for this 'let'</source>
        <target state="translated">この 'let' に対応する 'in' が見つかりません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorInReturnForLetIncorrectIndentation">
        <source>Error in the return expression for this 'let'. Possible incorrect indentation.</source>
        <target state="translated">この 'let' の return 式にエラーが見つかりました。インデントが正しくない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterLet">
        <source>The block following this '{0}' is unfinished. Every code block is an expression and must have a result. '{1}' cannot be the final code element in a block. Consider giving this block an explicit result.</source>
        <target state="translated">この '{0}' に続くブロックが完了していません。すべてのコード ブロックは式であり、結果を持つ必要があります。'{1}' をブロック内の最後のコード要素にすることはできません。このブロックに明示的な結果を指定することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIncompleteIf">
        <source>Incomplete conditional. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">条件が不完全です。'if &lt;expr&gt; then &lt;expr&gt;' または 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' という形式にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAssertIsNotFirstClassValue">
        <source>'assert' may not be used as a first class value. Use 'assert &lt;expr&gt;' instead.</source>
        <target state="translated">'assert' はファースト クラス値として使用できません。代わりに 'assert &lt;expr&gt;' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">識別子がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInOrEqualExpected">
        <source>'in' or '=' expected</source>
        <target state="translated">'in' または '=' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsArrowUseIsLimited">
        <source>The use of '-&gt;' in sequence and computation expressions is limited to the form 'for pat in expr -&gt; expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions.</source>
        <target state="translated">シーケンス式およびコンピュテーション式で、'-&gt;' の使用は 'for pat in expr -&gt; expr' の形式に制限されています。より複雑なシーケンス式で要素を生成するには、構文 'for ... in ... do ... yield...' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessiveArgsShouldBeSpacedOrTupled">
        <source>Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized</source>
        <target state="translated">複数の引数が連続する場合、スペースで区切るかタプル化します。関数またはメソッド アプリケーションに関する引数の場合、かっこで囲む必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracket">
        <source>Unmatched '['</source>
        <target state="translated">'[' が対応しません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingQualificationAfterDot">
        <source>Missing qualification after '.'</source>
        <target state="translated">'.' の後に修飾子がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsParenFormIsForML">
        <source>In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array</source>
        <target state="translated">F# コードでは、'expr.[expr]' を使用できます。最初の式が配列であることを示すには、型の注釈が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuote">
        <source>Mismatched quotation, beginning with '{0}'</source>
        <target state="translated">'{0}' で始まる引用符が対応しません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatched">
        <source>Unmatched '{0}'</source>
        <target state="translated">'{0}' が対応しません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracketBar">
        <source>Unmatched '[|'</source>
        <target state="translated">'[|' が対応しません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBrace">
        <source>Unmatched '{{'</source>
        <target state="translated">'{{' が対応しません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsFieldBinding">
        <source>Field bindings must have the form 'id = expr;'</source>
        <target state="translated">フィールドの束縛は 'id = expr;' という形式にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMemberIllegalInObjectImplementation">
        <source>This member is not permitted in an object implementation</source>
        <target state="translated">オブジェクトの実装では、このメンバーは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingFunctionBody">
        <source>Missing function body</source>
        <target state="translated">関数の本体がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxErrorInLabeledType">
        <source>Syntax error in labelled type argument</source>
        <target state="translated">ラベル付き型引数に構文エラーが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedInfixOperator">
        <source>Unexpected infix operator in type expression</source>
        <target state="translated">型式に予期しない挿入演算子が見つかりました:</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultiArgumentGenericTypeFormDeprecated">
        <source>The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident&lt;typ,...,typ&gt;' instead</source>
        <target state="translated">F# コードでは、構文 '(typ,...,typ) ident' は使用されません。'ident&lt;typ,...,typ&gt;' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidLiteralInType">
        <source>Invalid literal in type</source>
        <target state="translated">型のリテラルが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedOperatorForUnitOfMeasure">
        <source>Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'.</source>
        <target state="translated">単位式に予期しない挿入演算子が見つかりました。正しい演算子は '*'、'/'、および '^' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIntegerLiteralForUnitOfMeasure">
        <source>Unexpected integer literal in unit-of-measure expression</source>
        <target state="translated">単位式に予期しない整数リテラルが見つかりました:</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedTypeParameter">
        <source>Syntax error: unexpected type parameter specification</source>
        <target state="translated">構文エラー: 予期しない型パラメーターが指定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuotationName">
        <source>Mismatched quotation operator name, beginning with '{0}'</source>
        <target state="translated">'{0}' で始まる演算子名の引用符が対応しません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseMustBeginWithUpperCase">
        <source>Active pattern case identifiers must begin with an uppercase letter</source>
        <target state="translated">アクティブ パターンのケース識別子は先頭を大文字にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseContainsPipe">
        <source>The '|' character is not permitted in active pattern case identifiers</source>
        <target state="translated">文字 ' |' は、アクティブなパターンのケース識別子では許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalDenominatorForMeasureExponent">
        <source>Denominator must not be 0 in unit-of-measure exponent</source>
        <target state="translated">分母は単位指数で、0 以外でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoEqualShouldFollowNamespace">
        <source>No '=' symbol should follow a 'namespace' declaration</source>
        <target state="translated">'namespace' 宣言の後に '=' 記号は指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleStructEndDeprecated">
        <source>The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">F# コードでは 'module ... = struct .. end' という構文は使用されません。'module ... = begin .. end' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleSigEndDeprecated">
        <source>The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">F# コードでは 'module ... : sig .. end' という構文は使用されません。'module ... = begin .. end' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticFieldUsedWhenInstanceFieldExpected">
        <source>A static field was used where an instance field is expected</source>
        <target state="translated">インスタンス フィールドが必要な場所に静的フィールドが使用されました</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodNotAccessible">
        <source>Method '{0}' is not accessible from this code location</source>
        <target state="translated">メソッド '{0}' はこのコードの場所からアクセスできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplicitMeasureFollowingSlash">
        <source>Implicit product of measures following /</source>
        <target state="translated">/ に続く暗黙的な単位の積</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedMeasureAnon">
        <source>Unexpected SynMeasure.Anon</source>
        <target state="translated">予期しない SynMeasure.Anon です:</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonZeroConstantCannotHaveGenericUnit">
        <source>Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.</source>
        <target state="translated">0 でない定数にジェネリック ユニットは使用できません。ジェネリックな 0 の場合、0.0&lt;_&gt; と記述してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSeqResultsUseYield">
        <source>In sequence expressions, results are generated using 'yield'</source>
        <target state="translated">シーケンス式の結果は、'yield' を使用して生成されます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedBigRationalConstant">
        <source>Unexpected big rational constant</source>
        <target state="translated">有理定数が大きすぎます:</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForUnitsOfMeasure">
        <source>Units-of-measure supported only on float, float32, decimal and signed integer types</source>
        <target state="translated">float 型、float32 型、decimal 型、および符号付き整数型でのみサポートされる単位です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstUint16Array">
        <source>Unexpected Const_uint16array</source>
        <target state="translated">予期しない Const_uint16array です:</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstByteArray">
        <source>Unexpected Const_bytearray</source>
        <target state="translated">予期しない Const_bytearray です:</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterRequiresName">
        <source>A parameter with attributes must also be given a name, e.g. '[&lt;Attribute&gt;] Name : Type'</source>
        <target state="translated">属性を持つパラメーターには名前を指定してください (たとえば、'[&lt;Attribute&gt;] Name : Type')</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnValuesCannotHaveNames">
        <source>Return values cannot have names</source>
        <target state="translated">戻り値には名前を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberKindPropertyGetSetNotExpected">
        <source>MemberKind.PropertyGetSet only expected in parse trees</source>
        <target state="translated">解析ツリーに使用できるのは MemberKind.PropertyGetSet のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainValues">
        <source>Namespaces cannot contain values. Consider using a module to hold your value declarations.</source>
        <target state="translated">名前空間に値を含めることはできません。値の宣言を保持するモジュールを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainExtensionMembers">
        <source>Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.</source>
        <target state="translated">型を定義したファイルおよび名前空間宣言グループの場合を除き、名前空間に拡張メンバーを含めることはできません。拡張メンバーの宣言を保持するモジュールを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributes">
        <source>Multiple visibility attributes have been specified for this identifier</source>
        <target state="translated">この識別子に複数の可視属性が指定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributesWithLet">
        <source>Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions.</source>
        <target state="translated">この識別子に複数の可視属性が指定されました。式内のすべての 'let' 束縛と同様に、クラス内の 'let' 束縛は常にプライベートです。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForRelationalOperator">
        <source>The name '({0})' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">名前 '({0})' はメンバー名として使用しないでください。型の比較セマンティクスを定義するには、'System.IComparable' インターフェイスを実装してください。他の CLI 言語から使用するために静的メンバーを定義する場合、代わりに '{1}' という名前を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForEquality">
        <source>The name '({0})' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">名前 '({0})' はメンバー名として使用しないでください。型の等値セマンティクスを定義するには、'Object.Equals' メンバーをオーバーライドしてください。他の CLI 言語から使用するために静的メンバーを定義する場合、代わりに '{1}' という名前を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberName">
        <source>The name '({0})' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">名前 '({0})' はメンバー名として使用しないでください。他の CLI 言語から使用するために静的メンバーを定義する場合、代わりに '{1}' という名前を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameFixedTypes">
        <source>The name '({0})' should not be used as a member name because it is given a standard definition in the F# library over fixed types</source>
        <target state="translated">名前 '({0})' はメンバー名として使用しないでください。固定の型に関して、F# ライブラリではこの名前は標準的な定義が指定されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionRelational">
        <source>The '{0}' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type.</source>
        <target state="translated">通常、'{0}' 演算子は再定義できません。特定の型について、オーバーロードされた比較セマンティクスを定義するには、その型の定義で 'System.IComparable' インターフェイスを実装してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionEquality">
        <source>The '{0}' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type.</source>
        <target state="translated">通常、'{0}' 演算子は再定義できません。型の等値セマンティクスを定義するには、その型の定義で 'Object.Equals' メンバーをオーバーライドしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinition">
        <source>The '{0}' operator should not normally be redefined. Consider using a different operator name</source>
        <target state="translated">通常、'{0}' 演算子は再定義できません。別の演算子名を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexOperatorDefinition">
        <source>The '{0}' operator cannot be redefined. Consider using a different operator name</source>
        <target state="translated">'{0}' 演算子は再定義できません。別の演算子名を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectModuleOrNamespaceParent">
        <source>Expected module or namespace parent {0}</source>
        <target state="translated">モジュールまたは名前空間の親 {0} を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">構造体型、レコード型、または共用体型の '{0}' はインターフェイス 'System.IComparable' を明示的に実装しています。この型には 'CustomComparison' 属性を適用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsGenericIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable&lt;_&gt;' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.</source>
        <target state="translated">構造体型、レコード型、または共用体型の '{0}' は、インターフェイス 'System.IComparable&lt;_&gt;' を明示的に実装しています。この型には 'CustomComparison' 属性を適用し、さらに整合性のある非ジェネリック インターフェイス System.IComparable の実装を用意する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">構造体型、レコード型、または共用体型の '{0}' はインターフェイス 'System.IStructuralComparable' を明示的に実装しています。この型には 'CustomComparison' 属性を適用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordFieldInconsistentTypes">
        <source>This record contains fields from inconsistent types</source>
        <target state="translated">このレコードには、相反する型からのフィールドが含まれます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportStubsCannotBeInlined">
        <source>DLLImport stubs cannot be inlined</source>
        <target state="translated">DLLImport スタブはインライン展開できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCanOnlyBindThisAtMemberDeclaration">
        <source>Structs may only bind a 'this' parameter at member declarations</source>
        <target state="translated">構造体は、メンバーの宣言の 'this' パラメーターのみをバインドできます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedExprAtRecInfPoint">
        <source>Unexpected expression at recursive inference point</source>
        <target state="translated">再帰的推論ポイントに予期しない式があります:</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLessGenericBecauseOfAnnotation">
        <source>This code is less generic than required by its annotations because the explicit type variable '{0}' could not be generalized. It was constrained to be '{1}'.</source>
        <target state="translated">明示的な型変数 '{0}' をジェネリック化できないため、このコードは、注釈に必要な総称性よりも低くなります。このコードは '{1}' に制限されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstrainedTypeVariableCannotBeGeneralized">
        <source>One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types</source>
        <target state="translated">この束縛に関する 1 つまたは複数の明示的クラスまたは関数型の変数は、他の型に制限されているため、ジェネリック化できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericParameterHasBeenConstrained">
        <source>A generic type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">常に '{0}' であるという制約があるジェネリック型パラメーターが使用されました</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterHasBeenConstrained">
        <source>This type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">常に '{0}' であるという制約がある型パラメーターが使用されました</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParametersInferredAreNotStable">
        <source>The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</source>
        <target state="translated">この値で推論された型パラメーターは、型略称がなくなると安定しません。これは、型パラメーターの脱落や順序の変更を行う型略称を使用しているためです。次に例を示します。\n\ttype taggedInt&lt;'a&gt; = int または\n\ttype swap&lt;'a,'b&gt; = 'b * 'a\nこの値の型パラメーターを明示的に宣言してください。次に例を示します。\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x)</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeParameterInvalid">
        <source>Explicit type parameters may only be used on module or member bindings</source>
        <target state="translated">明示的な型パラメーターを使用できるのは、モジュールまたはメンバーの束縛のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridingMethodRequiresAllOrNoTypeParameters">
        <source>You must explicitly declare either all or no type parameters when overriding a generic abstract method</source>
        <target state="translated">ジェネリック抽象メソッドをオーバーライドする場合、明示的にすべての型パラメーターを宣言するか、まったく宣言しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldsDoNotDetermineUniqueRecordType">
        <source>The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type</source>
        <target state="translated">フィールド ラベルとこのレコード式またはパターンの型だけでは、対応するレコード型を一意に決定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldAppearsTwiceInRecord">
        <source>The field '{0}' appears twice in this record expression or pattern</source>
        <target state="translated">のレコード式またはパターンに、フィールド '{0}' が 2 回出現します</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnknownUnion">
        <source>Unknown union case</source>
        <target state="translated">不明な共用体ケースです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotSufficientlyGenericBecauseOfScope">
        <source>This code is not sufficiently generic. The type variable {0} could not be generalized because it would escape its scope.</source>
        <target state="translated">このコードの総称性が十分ではありません。スコープが回避されるため、型変数 {0} をジェネリック化することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyRequiresExplicitTypeParameters">
        <source>A property cannot have explicit type parameters. Consider using a method instead.</source>
        <target state="translated">プロパティには明示的な型パラメーターを使用できません。代わりにメソッドを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorCannotHaveTypeParameters">
        <source>A constructor cannot have explicit type parameters. Consider using a static construction method instead.</source>
        <target state="translated">コンストラクターには明示的な型パラメーターを使用できません。代わりに静的構築のメソッドを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInstanceMemberRequiresTarget">
        <source>This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'.</source>
        <target state="translated">このインスタンス メンバーには、呼び出されるオブジェクトを表すパラメーターが必要です。メンバーを静的にするか、'member x.Member(args) = ...' という表記を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertyInSyntaxTree">
        <source>Unexpected source-level property specification in syntax tree</source>
        <target state="translated">構文ツリーに予期しないソースレベルのプロパティの指定があります:</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializerRequiresArgument">
        <source>A static initializer requires an argument</source>
        <target state="translated">静的初期化子には引数が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorRequiresArgument">
        <source>An object constructor requires an argument</source>
        <target state="translated">オブジェクト コンストラクターには引数が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticMemberShouldNotHaveThis">
        <source>This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'.</source>
        <target state="translated">この静的メンバーに 'this' パラメーターを指定することはできません。'member Member(args) = ...' という表記を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitStaticInitializerSyntax">
        <source>An explicit static initializer should use the syntax 'static new(args) = expr'</source>
        <target state="translated">明示的な静的初期化子には 'static new(args) = expr' という構文を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitObjectConstructorSyntax">
        <source>An explicit object constructor should use the syntax 'new(args) = expr'</source>
        <target state="translated">明示的なオブジェクト コンストラクターには 'new(args) = expr' という構文を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertySpec">
        <source>Unexpected source-level property specification</source>
        <target state="translated">予期しないソースレベルのプロパティの指定があります:</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionFormDeprecated">
        <source>This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions.</source>
        <target state="translated">この形式のオブジェクト式は F# では使用されません。オブジェクト式でメンバーの実装を定義するには、'member this.MemberName ... = ...' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDeclaration">
        <source>Invalid declaration</source>
        <target state="translated">宣言が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesInvalidInPatterns">
        <source>Attributes are not allowed within patterns</source>
        <target state="translated">パターン内では属性を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitTypeArguments">
        <source>The generic function '{0}' must be given explicit type argument(s)</source>
        <target state="translated">ジェネリック関数 '{0}' に明示的な型引数を指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoesNotAllowExplicitTypeArguments">
        <source>The method or function '{0}' should not be given explicit type argument(s) because it does not declare its type parameters explicitly</source>
        <target state="translated">メソッドまたは関数 '{0}' は、型パラメーターを明示的に宣言していないため、明示的な型引数を指定しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterArityMismatch">
        <source>This value, type or method expects {0} type parameter(s) but was given {1}</source>
        <target state="translated">この値、型、またはメソッドには {0} 型パラメーターを使用しますが、{1} が指定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultStructConstructorCall">
        <source>The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization</source>
        <target state="translated">構造体型のすべてのフィールドが既定の初期化を許可している場合のみ、既定である、ゼロで初期化した構造型のコンストラクターを使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindIDisposable">
        <source>Couldn't find Dispose on IDisposable, or it was overloaded</source>
        <target state="translated">IDisposable に Dispose が見つからないか、Dispose がオーバーロードされました</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonLiteralCannotBeUsedInPattern">
        <source>This value is not a literal and cannot be used in a pattern</source>
        <target state="translated">この値はリテラルではないため、パターンに使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsReadonly">
        <source>This field is readonly</source>
        <target state="translated">このフィールドは読み取り専用です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameArgumentsMustAppearLast">
        <source>Named arguments must appear after all other arguments</source>
        <target state="translated">名前付き引数は、その他の引数の後ろに指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitLambda">
        <source>This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking {0} arguments.</source>
        <target state="translated">この関数値は、byref 引数を含むシグネチャのデリゲート型を構築するために使用されます。{0} 個の引数を使用する明示的なラムダ式を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCannotBeEnumerated">
        <source>The type '{0}' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method</source>
        <target state="translated">型 '{0}' は、この構文で列挙できる値を持つ型ではありません。つまり、seq&lt;_&gt;、IEnumerable&lt;_&gt;、または IEnumerable のいずれとも互換性がなく、GetEnumerator メソッドを含みません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMixtureOfRecursiveForms">
        <source>This recursive binding uses an invalid mixture of recursive forms</source>
        <target state="translated">この再帰的束縛に使用されている再帰形式の混合は無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectConstructionExpression">
        <source>This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.</source>
        <target state="translated">これは有効なオブジェクト構築式ではありません。明示的なオブジェクト コンストラクターでは、代わりのコンストラクターを呼び出すかまたはオブジェクトのすべてのフィールドを初期化し、スーパークラス コンストラクターの呼び出しを指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraint">
        <source>Invalid constraint</source>
        <target state="translated">制約が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraintTypeSealed">
        <source>Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution</source>
        <target state="translated">無効な制約: 制約に使用された型がシールドです。つまり、制約を満たすことができるのは、最高でも 1 つの解です。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumConstraint">
        <source>An 'enum' constraint must be of the form 'enum&lt;type&gt;'</source>
        <target state="translated">'enum' 制約は 'enum&lt;type&gt;' という形式で指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNewConstraint">
        <source>'new' constraints must take one argument of type 'unit' and return the constructed type</source>
        <target state="translated">'new' 制約は型 'unit' の引数を 1 つ指定し、構築された型を返す必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPropertyType">
        <source>This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -&gt; ty3'. Properties returning functions should have types of the form '(ty1 -&gt; ty2)'.</source>
        <target state="translated">このプロパティの型は無効です。複数のインデクサー引数を使用するプロパティには、'ty1 * ty2 -&gt; ty3' という形式の型を使用してください。関数を返すプロパティには、'(ty1 -&gt; ty2)' という形式の型を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureMarkWithAttribute">
        <source>Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.</source>
        <target state="translated">型パラメーターではなく単位パラメーターを指定してください。明示的な単位パラメーターは [&lt;Measure&gt;] 属性でマークする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeParameter">
        <source>Expected type parameter, not unit-of-measure parameter</source>
        <target state="translated">単位パラメーターではなく型パラメーターを指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeNotUnitOfMeasure">
        <source>Expected type, not unit-of-measure</source>
        <target state="translated">単位ではなく型を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureNotType">
        <source>Expected unit-of-measure, not type</source>
        <target state="translated">型ではなく単位を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUnitsOfMeasurePrefix">
        <source>Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.</source>
        <target state="translated">型に対するプレフィックス引数として単位を使用することはできません。山かっこで囲んだ後置引数として書き換えてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnitsOfMeasureInvalidInTypeConstructor">
        <source>Unit-of-measure cannot be used in type constructor application</source>
        <target state="translated">型コンストラクター応用には単位を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireBuilderMethod">
        <source>This control construct may only be used if the computation expression builder defines a '{0}' method</source>
        <target state="translated">この制御コンストラクトを使用できるのは、コンピュテーション式ビルダーが '{0}' メソッドを定義する場合のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoNestedTypes">
        <source>This type has no nested types</source>
        <target state="translated">この型に入れ子の型はありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSymbolInTypeExpression">
        <source>Unexpected {0} in type expression</source>
        <target state="translated">型式に予期しない {0} があります:</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterInvalidAsTypeConstructor">
        <source>Type parameter cannot be used as type constructor</source>
        <target state="translated">型パラメーターは型コンストラクターとして使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalSyntaxInTypeExpression">
        <source>Illegal syntax in type expression</source>
        <target state="translated">型式の構文が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousUnitsOfMeasureCannotBeNested">
        <source>Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression</source>
        <target state="translated">匿名の単位は、別の単位式の中に入れ子にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousTypeInvalidInDeclaration">
        <source>Anonymous type variables are not permitted in this declaration</source>
        <target state="translated">この宣言で匿名型の変数は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSlashInType">
        <source>Unexpected / in type</source>
        <target state="translated">型に予期しない / があります:</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedTypeArguments">
        <source>Unexpected type arguments</source>
        <target state="translated">予期しない型引数です:</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsOnlyOnMembers">
        <source>Optional arguments are only permitted on type members</source>
        <target state="translated">型メンバーにはオプションの引数のみを使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameNotBoundInPattern">
        <source>Name '{0}' not bound in pattern context</source>
        <target state="translated">名前 '{0}' がパターン コンテキストにバインドされていません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNonPrimitiveLiteralInPatternMatch">
        <source>Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when &lt;variable&gt; = &lt;constant&gt;' at the end of the match clause.</source>
        <target state="translated">プリミティブではない数値リテラル定数は、NumericLiteral モジュールを介して複数の型にマップされる可能性があるため、パターン マッチには使用できません。変数で置き換え、match 句の末尾に 'when &lt;variable&gt; = &lt;constant&gt;' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentUsage">
        <source>Type arguments cannot be specified here</source>
        <target state="translated">ここで型引数は指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireActivePatternWithOneResult">
        <source>Only active patterns returning exactly one result may accept arguments</source>
        <target state="translated">結果を 1 つだけ返すアクティブ パターンのみが、引数を使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidArgForParameterizedPattern">
        <source>Invalid argument to parameterized pattern label</source>
        <target state="translated">パラメーター化されたパターン ラベルに無効な引数が指定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexIntoActivePatternArray">
        <source>Internal error. Invalid index into active pattern array</source>
        <target state="translated">内部エラー。アクティブ パターン配列への無効なインデックスです。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseDoesNotTakeArguments">
        <source>This union case does not take arguments</source>
        <target state="translated">この共用体ケースに引数は指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseRequiresOneArgument">
        <source>This union case takes one argument</source>
        <target state="translated">この共用体ケースには 1 つの引数を指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseExpectsTupledArguments">
        <source>This union case expects {0} arguments in tupled form</source>
        <target state="translated">この共用体ケースにはタプル形式の引数を {0} 個指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotStatic">
        <source>Field '{0}' is not static</source>
        <target state="translated">フィールド '{0}' は静的ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNotLiteralCannotBeUsedInPattern">
        <source>This field is not a literal and cannot be used in a pattern</source>
        <target state="translated">このフィールドはリテラルではないため、パターンに使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireVarConstRecogOrLiteral">
        <source>This is not a variable, constant, active recognizer or literal</source>
        <target state="translated">これは変数、定数、アクティブ レコグナイザー、またはリテラルではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPattern">
        <source>This is not a valid pattern</source>
        <target state="translated">これは有効なパターンではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseWhenPatternGuard">
        <source>Character range matches have been removed in F#. Consider using a 'when' pattern guard instead.</source>
        <target state="translated">F# では文字範囲の一致が削除されました。代わりに 'when' パターン ガードを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalPattern">
        <source>Illegal pattern</source>
        <target state="translated">パターンが正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxErrorUnexpectedQMark">
        <source>Syntax error - unexpected '?' symbol</source>
        <target state="translated">構文エラー - 予期しない '?' 記号です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionCountMisMatch">
        <source>Expected {0} expressions, got {1}</source>
        <target state="translated">{0} 式を指定する必要がありますが、{1} が指定されました</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExprUndelayed">
        <source>TcExprUndelayed: delayed</source>
        <target state="translated">TcExprUndelayed: 遅延しました</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionRequiresSequence">
        <source>This expression form may only be used in sequence and computation expressions</source>
        <target state="translated">この式の形式を使用できるのは、シーケンス式またはコンピュテーション式のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectExpressionSyntaxForm">
        <source>Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.</source>
        <target state="translated">オブジェクト式が無効です。オーバーライドまたはインターフェイスがないオブジェクトには、かっこなしで 'new Type(args)' という形式の式を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectSequenceOrRecordExpression">
        <source>Invalid object, sequence or record expression</source>
        <target state="translated">オブジェクト式、シーケンス式、またはレコード式が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSequenceExpressionSyntaxForm">
        <source>Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq {{ ... }}'</source>
        <target state="translated">無効なレコード、シーケンス式、またはコンピュテーション式です。シーケンス式は 'seq {{ ... }}' という形式にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionWithIfRequiresParenthesis">
        <source>This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression</source>
        <target state="translated">このリスト式または配列式には、'if ... then ... else' という形式の要素が含まれます。この式をかっこで囲んでリストまたは配列の個別の要素であることを示し、シーケンス式を使用して生成されたリストとこのリストを区別してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseFormatString">
        <source>Unable to parse format string '{0}'</source>
        <target state="translated">書式指定文字列 '{0}' を解析できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcListLiteralMaxSize">
        <source>This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.</source>
        <target state="translated">このリスト式は、リスト リテラルの最大サイズを超えています。より大きなリテラルの配列を使用し、Array.ToList を呼び出してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresObjectConstructor">
        <source>The expression form 'expr then expr' may only be used as part of an explicit object constructor</source>
        <target state="translated">明示的なオブジェクト コンストラクターの一部としてのみ、'expr then expr' という形式の式を使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentsCannotBeUsedInMemberTraits">
        <source>Named arguments cannot be given to member trait calls</source>
        <target state="translated">名前付き引数をメンバーの特徴 (trait) の呼び出しに指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotValidEnumCaseName">
        <source>This is not a valid name for an enumeration case</source>
        <target state="translated">列挙型のケースの有効な名前ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotMutable">
        <source>This field is not mutable</source>
        <target state="translated">このフィールドは変更可能ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresListArrayOrSequence">
        <source>This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq {{ ... }}', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements</source>
        <target state="translated">このコンストラクトは、リスト式、配列式、およびシーケンス式内でのみ使用できます (たとえば、'seq {{ ... }}'、'[ ... ]'、'[| ... |]' などの形式の式)。この場合、要素を生成するには 'for ... in ... do ... yield...' という構文を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpressions">
        <source>This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'.</source>
        <target state="translated">このコンストラクトはコンピュテーション式内でのみ使用できます。通常の関数から値を返すには、'return' を使用せずに式を記述してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresSequenceOrComputations">
        <source>This construct may only be used within sequence or computation expressions</source>
        <target state="translated">このコンストラクトはシーケンス式およびコンピュテーション式内でのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpression">
        <source>This construct may only be used within computation expressions</source>
        <target state="translated">このコンストラクトはコンピュテーション式内でのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexerExpression">
        <source>Invalid indexer expression</source>
        <target state="translated">インデクサー式が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
        <source>The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints</source>
        <target state="translated">このプログラムのポイントよりも前の情報に基づいた不確定の型のオブジェクトに、演算子 'expr.[idx]' が使用されました。型の制約を増やしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromVariableType">
        <source>Cannot inherit from a variable type</source>
        <target state="translated">変数型から継承できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsOnTypeParametersCannotTakeArguments">
        <source>Calls to object constructors on type parameters cannot be given arguments</source>
        <target state="translated">型パラメーター上のオブジェクト コンストラクターの呼び出しに引数を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCompiledNameAttributeMisused">
        <source>The 'CompiledName' attribute cannot be used with this language element</source>
        <target state="translated">この言語要素では、'CompiledName' 属性を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedTypeRequired">
        <source>'{0}' may only be used with named types</source>
        <target state="translated">'{0}' を使用できるのは、名前付き型のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritCannotBeUsedOnInterfaceType">
        <source>'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead.</source>
        <target state="translated">インターフェイス型に 'inherit' は使用できません。代わりに 'interface ... with ... end' を使用してインターフェイスを実装してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewCannotBeUsedOnInterfaceType">
        <source>'new' cannot be used on interface types. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">インターフェイス型では 'new' を使用できません。代わりにオブジェクト式 '{{ new ... with ... }}' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractTypeCannotBeInstantiated">
        <source>Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">abstract とマークされているか、一部のメソッドが実装されていないため、この型のインスタンスを作成できません。代わりにオブジェクト式 '{{ new ... with ... }}' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIDisposableTypeShouldUseNew">
        <source>It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value</source>
        <target state="translated">IDisposable インターフェイスをサポートするオブジェクトは、コンストラクターを表す関数値として 'Type(args)' や 'Type' ではなく 'new Type(args)' の構文を使用して作成することをお勧めします。これは、リソースが生成された値に所有される可能性があることを示すためです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxCanOnlyBeUsedToCreateObjectTypes">
        <source>'{0}' may only be used to construct object types</source>
        <target state="translated">'{0}' は、オブジェクト型を構築するときにのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresCall">
        <source>Constructors for the type '{0}' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.</source>
        <target state="translated">型 '{0}' のコンストラクターはその暗黙的なオブジェクト コンストラクターを直接、または間接的に呼び出す必要があります。レコード式ではなく、暗黙的なオブジェクト コンストラクターの呼び出しを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUndefinedField">
        <source>The field '{0}' has been given a value, but is not present in the type '{1}'</source>
        <target state="translated">フィールド '{0}' に値が指定されましたが、このフィールドは型 '{1}' に存在しません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresAssignment">
        <source>No assignment given for field '{0}' of type '{1}'</source>
        <target state="translated">型 '{1}' のフィールド '{0}' に割り当てが指定されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExtraneousFieldsGivenValues">
        <source>Extraneous fields have been given values</source>
        <target state="translated">不適切なフィールドに値を指定しました</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
        <source>Only overrides of abstract and virtual members may be specified in object expressions</source>
        <target state="translated">オブジェクト式に指定できるのは、抽象メンバーおよび仮想メンバーのオーバーライドのみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoAbstractOrVirtualMemberFound">
        <source>The member '{0}' does not correspond to any abstract or virtual method available to override or implement.</source>
        <target state="translated">メンバー '{0}' は、無視または実装に使用できるどの抽象メソッドまたは仮想メソッドにも対応していません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberFoundIsNotAbstractOrVirtual">
        <source>The type {0} contains the member '{1}' but it is not a virtual or abstract method that is available to override or implement.</source>
        <target state="translated">型 {0} にメンバー '{1}' が含まれていますが、このメンバーは無視または実装に使用できる仮想メソッドでも抽象メソッドでもありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatch">
        <source>The member '{0}' does not accept the correct number of arguments. {1} argument(s) are expected, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">メンバー '{0}' の引数の数が正しくありません。{1} 個の引数が必要ですが、指定されたのは {2} 個です。必要な署名は '{3}' です。{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatchOneOverload">
        <source>The member '{0}' does not accept the correct number of arguments. One overload accepts {1} arguments, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">メンバー '{0}' の引数の数が正しくありません。1 つのオーバーロードには {1} 個の引数を指定できますが、{2} 個が指定されました。必要な署名は '{3}' です。{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSimpleMethodNameRequired">
        <source>A simple method name is required here</source>
        <target state="translated">ここでは単純なメソッド名が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPredefinedTypeCannotBeUsedAsSuperType">
        <source>The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class</source>
        <target state="translated">型 System.ValueType、System.Enum、System.Delegate、System.MulticastDelegate、および System.Array は、オブジェクト式またはクラスのスーパー型として使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMustBeUsedWithNamedType">
        <source>'new' must be used with a named type</source>
        <target state="translated">名前付き型には 'new' を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCreateExtensionOfSealedType">
        <source>Cannot create an extension of a sealed type</source>
        <target state="translated">シールド型の拡張は作成できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoArgumentsForRecordValue">
        <source>No arguments may be given when constructing a record value</source>
        <target state="translated">レコード値を構築するときに指定できる引数はありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoInterfaceImplementationForConstructionExpression">
        <source>Interface implementations cannot be given on construction expressions</source>
        <target state="translated">構築式ではインターフェイスの実装を指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionCanOnlyBeUsedInClassTypes">
        <source>Object construction expressions may only be used to implement constructors in class types</source>
        <target state="translated">オブジェクト構築式は、クラス型のコンストラクターを実装する場合にのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
        <source>Only simple bindings of the form 'id = expr' can be used in construction expressions</source>
        <target state="translated">構築式に使用できるのは、'id = expr' という形式の単純な束縛のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectsMustBeInitializedWithObjectExpression">
        <source>Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field</source>
        <target state="translated">オブジェクトを初期化するには、継承したオブジェクト コンストラクターを呼び出し、値を各フィールドに割り当てるオブジェクト構築式を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedInterfaceType">
        <source>Expected an interface type</source>
        <target state="translated">インターフェイスの型を指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorForInterfacesDoNotTakeArguments">
        <source>Constructor expressions for interfaces do not take arguments</source>
        <target state="translated">インターフェイスのコンストラクター式には引数を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresArguments">
        <source>This object constructor requires arguments</source>
        <target state="translated">このオブジェクト コンストラクターには引数が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewRequiresObjectConstructor">
        <source>'new' may only be used with object constructors</source>
        <target state="translated">'new' を使用できるのは、オブジェクト コンストラクターのみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAtLeastOneOverrideIsInvalid">
        <source>At least one override did not correctly implement its corresponding abstract member</source>
        <target state="translated">少なくとも 1 つのオーバーライドが対応する抽象メンバーを正しく実装していません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNumericLiteralRequiresModule">
        <source>This numeric literal requires that a module '{0}' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope</source>
        <target state="translated">数値リテラルの場合、関数 FromZero、FromOne、FromInt32、FromInt64、および FromString を定義するモジュール '{0}' がスコープに含まれている必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRecordConstruction">
        <source>Invalid record construction</source>
        <target state="translated">レコードの構造が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresRecordTypes">
        <source>The expression form {{ expr with ... }} may only be used with record types. To build object types use {{ new Type(...) with ... }}</source>
        <target state="translated">{{ expr with ... }} という形式の式を使用できるのはレコード型のみです。オブジェクトの型を構築するには、{{ new Type(...) with ... }} を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritedTypeIsNotObjectModelType">
        <source>The inherited type is not an object model type</source>
        <target state="translated">継承された型はオブジェクト モデル型ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
        <source>Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors</source>
        <target state="translated">オブジェクト構築式 (つまり、継承の指定があるレコード式) は、オブジェクト モデル型のコンストラクターを実装する場合にのみ使用できます。コンストラクターの外側でオブジェクト モデル型のインスタンスを構築するには、'new ObjectType(args)' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyRecordInvalid">
        <source>'{{ }}' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.</source>
        <target state="translated">'{{ }}' は有効な式ではありません。レコードには 1 つ以上のフィールドを含める必要があります。空のシーケンスを指定するには、Seq.empty または空のリスト '[]' をご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordTypeNeedConstructor">
        <source>This type is not a record type. Values of class and struct types must be created using calls to object constructors.</source>
        <target state="translated">この型はレコード型ではありません。クラス型および構造体型の値は、オブジェクト コンストラクターの呼び出しを使用して作成してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordType">
        <source>This type is not a record type</source>
        <target state="translated">この型はレコード型ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInComputationExpression">
        <source>This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder {{ ... }}'.</source>
        <target state="translated">このコンストラクトはコンピュテーション式の一部としてあいまいです。入れ子の式を記述するには 'let _ = (...)' を使用し、入れ子の計算には 'let! res = builder {{ ... }}' を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInSequenceExpression">
        <source>This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {{... }}'.</source>
        <target state="translated">このコンストラクトはシーケンス式の一部としてあいまいです。入れ子の式を記述するには 'let _ = (...)' を使用し、入れ子のシーケンスには 'yield! seq {{... }}' を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoBangIllegalInSequenceExpression">
        <source>'do!' cannot be used within sequence expressions</source>
        <target state="translated">シーケンス式内には 'do!' を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseForInSequenceExpression">
        <source>The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead.</source>
        <target state="translated">シーケンス式では 'let! x = coll' を使用できません。代わりに 'for x in coll' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryIllegalInSequenceExpression">
        <source>'try'/'with' cannot be used within sequence expressions</source>
        <target state="translated">シーケンス式内には 'try'/'with' を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseYieldBangForMultipleResults">
        <source>In sequence expressions, multiple results are generated using 'yield!'</source>
        <target state="translated">シーケンス式で、複数の結果は 'yield!' を使用して生成されます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAssignment">
        <source>Invalid assignment</source>
        <target state="translated">割り当てが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfTypeName">
        <source>Invalid use of a type name</source>
        <target state="translated">型名の使用方法に誤りがあります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoAccessibleConstructor">
        <source>This type has no accessible object constructors</source>
        <target state="translated">この型にアクセスできるオブジェクト コンストラクターはありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfInterfaceType">
        <source>Invalid use of an interface type</source>
        <target state="translated">インターフェイス型の使用方法に誤りがあります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfDelegate">
        <source>Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'.</source>
        <target state="translated">デリゲート コンストラクターの使用方法に誤りがあります。'new Type(args)' か、単に 'Type(args)' という構文を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotStatic">
        <source>Property '{0}' is not static</source>
        <target state="translated">プロパティ '{0}' は静的ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotReadable">
        <source>Property '{0}' is not readable</source>
        <target state="translated">プロパティ '{0}' は読み取り可能ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLookupMayNotBeUsedHere">
        <source>This lookup cannot be used here</source>
        <target state="translated">ここでこの参照は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsStatic">
        <source>Property '{0}' is static</source>
        <target state="translated">プロパティ '{0}' は静的です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet1">
        <source>Property '{0}' cannot be set</source>
        <target state="translated">プロパティ '{0}' は設定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsCannotBeFirstClassValues">
        <source>Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</source>
        <target state="translated">コンストラクターは引数に割り当てる必要があります。また、コンストラクターをファーストクラスの値として使用することはできません。必要に応じて、匿名関数 '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
        <source>The syntax 'expr.id' may only be used with record labels, properties and fields</source>
        <target state="translated">構文 'expr.id' を使用できるのは、レコードのラベル、プロパティ、およびフィールドのみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsStatic">
        <source>Event '{0}' is static</source>
        <target state="translated">イベント '{0}' は静的です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsNotStatic">
        <source>Event '{0}' is not static</source>
        <target state="translated">イベント '{0}' は静的ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentDidNotMatch">
        <source>The named argument '{0}' did not match any argument or mutable property</source>
        <target state="translated">名前付き引数 '{0}' と一致する引数または変更可能なプロパティがありませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverloadsCannotHaveCurriedArguments">
        <source>One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.</source>
        <target state="translated">このメソッドのオーバーロードの 1 つまたは複数にカリー化された引数があります。タプル化された形式で引数を使用するようにこれらのメンバーを再設計してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnnamedArgumentsDoNotFormPrefix">
        <source>The unnamed arguments do not form a prefix of the arguments of the method called</source>
        <target state="translated">名前なしの引数は、呼び出されるメソッドの引数のプレフィックスを形成できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
        <source>Static optimization conditionals are only for use within the F# library</source>
        <target state="translated">静的最適化の条件は、F# ライブラリ内でのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFormalArgumentIsNotOptional">
        <source>The corresponding formal argument is not optional</source>
        <target state="translated">対応する正式な引数はオプションではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOptionalAssignmentToPropertyOrField">
        <source>Invalid optional assignment to a property or field</source>
        <target state="translated">プロパティまたはフィールドに対するオプションの割り当てが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegateConstructorMustBePassed">
        <source>A delegate constructor must be passed a single function value</source>
        <target state="translated">デリゲート コンストラクターには単一の関数値を渡す必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindingCannotBeUseAndRec">
        <source>A binding cannot be marked both 'use' and 'rec'</source>
        <target state="translated">束縛に 'use' と 'rec' の両方をマークすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileOnlyOnClassLetBindings">
        <source>The 'VolatileField' attribute may only be used on 'let' bindings in classes</source>
        <target state="translated">'VolatileField' 属性を使用できるのは、クラス内の 'let' 束縛上のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesAreNotPermittedOnLetBindings">
        <source>Attributes are not permitted on 'let' bindings in expressions</source>
        <target state="translated">式内の 'let' 束縛では、属性を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultValueAttributeRequiresVal">
        <source>The 'DefaultValue' attribute may only be used on 'val' declarations</source>
        <target state="translated">'DefaultValue' 属性は 'val' 宣言でのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeRequiresMembers">
        <source>The 'ConditionalAttribute' attribute may only be used on members</source>
        <target state="translated">'ConditionalAttribute' 属性はメンバーでのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidActivePatternName">
        <source>This is not a valid name for an active pattern</source>
        <target state="translated">アクティブ パターンの有効な名前ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEntryPointAttributeRequiresFunctionInModule">
        <source>The 'EntryPointAttribute' attribute may only be used on function definitions in modules</source>
        <target state="translated">'EntryPointAttribute' 属性を使用できるのは、モジュールの関数定義のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesCannotBeInline">
        <source>Mutable values cannot be marked 'inline'</source>
        <target state="translated">変更可能な値を 'inline' とマークすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesMayNotHaveGenericParameters">
        <source>Mutable values cannot have generic parameters</source>
        <target state="translated">変更可能な値にジェネリック パラメーターを指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesSyntax">
        <source>Mutable function values should be written 'let mutable f = (fun args -&gt; ...)'</source>
        <target state="translated">変更可能な関数値は 'let mutable f = (fun args -&gt; ...)' と記述してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyFunctionsCanBeInline">
        <source>Only functions may be marked 'inline'</source>
        <target state="translated">'inline' とマークできるのは関数のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalAttributesForLiteral">
        <source>A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes</source>
        <target state="translated">リテラル値に [&lt;ThreadStatic&gt;] 属性または [&lt;ContextStatic&gt;] 属性を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeMutable">
        <source>A literal value cannot be marked 'mutable'</source>
        <target state="translated">リテラル値に 'mutable' とマークすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeInline">
        <source>A literal value cannot be marked 'inline'</source>
        <target state="translated">リテラル値に 'inline' とマークすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotHaveGenericParameters">
        <source>Literal values cannot have generic parameters</source>
        <target state="translated">リテラル値にジェネリック パラメーターを指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstantExpression">
        <source>This is not a valid constant expression</source>
        <target state="translated">これは有効な定数式ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsInaccessible">
        <source>This type is not accessible from this code location</source>
        <target state="translated">このコードの場所からこの型にアクセスすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConditionInImportedAssembly">
        <source>Unexpected condition in imported assembly: failed to decode AttributeUsage attribute</source>
        <target state="translated">インポートされたアセンブリに予期しない条件があります。AttributeUsage 属性のデコードに失敗しました:</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedAttributeTarget">
        <source>Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</source>
        <target state="translated">認識されない属性のターゲットです。有効な属性のターゲットは、'assembly'、'module'、'type'、'method'、'property'、'return'、'param'、'field'、'event'、および 'constructor' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElementUseDo">
        <source>This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module.</source>
        <target state="translated">この言語要素では、この属性を使用できません。アセンブリの属性は (必要に応じて F# モジュール内で) 'do ()' 宣言にアタッチする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElement">
        <source>This attribute is not valid for use on this language element</source>
        <target state="translated">この言語要素では、この属性を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgumentsCannotBeUsedInCustomAttribute">
        <source>Optional arguments cannot be used in custom attributes</source>
        <target state="translated">カスタム属性にはオプションの引数を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet0">
        <source>This property cannot be set</source>
        <target state="translated">このプロパティは設定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyOrFieldNotFoundInAttribute">
        <source>This property or field was not found on this custom attribute type</source>
        <target state="translated">このカスタム属性型に、このプロパティまたはフィールドが見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustBeReferenceType">
        <source>A custom attribute must be a reference type</source>
        <target state="translated">カスタム属性は参照型にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeArgumentMismatch">
        <source>The number of args for a custom attribute does not match the expected number of args for the attribute constructor</source>
        <target state="translated">カスタム属性の引数の数は、属性コンストラクターの引数に必要な数と一致しません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustInvokeConstructor">
        <source>A custom attribute must invoke an object constructor</source>
        <target state="translated">カスタム属性はオブジェクト コンストラクターを呼び出す必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeExpressionsMustBeConstructorCalls">
        <source>Attribute expressions must be calls to object constructors</source>
        <target state="translated">属性式は、オブジェクト コンストラクターに対する呼び出しにしてください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedAttribute">
        <source>This attribute cannot be used in this version of F#</source>
        <target state="translated">このバージョンの F# では、この属性を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidInlineSpecification">
        <source>Invalid inline specification</source>
        <target state="translated">インラインの指定が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBinding">
        <source>'use' bindings must be of the form 'use &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">'use' 束縛の形式は 'use &lt;var&gt; = &lt;expr&gt;' にしてください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractMembersIllegalInAugmentation">
        <source>Abstract members are not permitted in an augmentation - they must be defined as part of the type itself</source>
        <target state="translated">拡張に抽象メンバーは使用できません。型の一部として定義する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodOverridesIllegalHere">
        <source>Method overrides and interface implementations are not permitted here</source>
        <target state="translated">ここでメソッドのオーバーライドおよびインターフェイスの実装は許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoMemberFoundForOverride">
        <source>No abstract or interface member was found that corresponds to this override</source>
        <target state="translated">このオーバーライドに対応する抽象メンバーまたはインターフェイス メンバーが見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverrideArityMismatch">
        <source>This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:{0}</source>
        <target state="translated">この無視では、対応する抽象メンバーに対して異なる数の引数を使用しています。次の抽象メンバーが見つかりました: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationAlreadyExists">
        <source>This method already has a default implementation</source>
        <target state="translated">このメソッドには既に既定の実装があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultAmbiguous">
        <source>The method implemented by this default is ambiguous</source>
        <target state="translated">この既定で実装されたメソッドはあいまいです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoPropertyFoundForOverride">
        <source>No abstract property was found that corresponds to this override</source>
        <target state="translated">このオーバーライドに対応する抽象プロパティが見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractPropertyMissingGetOrSet">
        <source>This property overrides or implements an abstract property but the abstract property doesn't have a corresponding {0}</source>
        <target state="translated">このプロパティは、抽象プロパティをオーバーライドまたは実装しますが、抽象プロパティには対応する {0} がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSignatureForSet">
        <source>Invalid signature for set member</source>
        <target state="translated">set メンバーのシグネチャが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMember">
        <source>This new member hides the abstract member '{0}'. Rename the member or use 'override' instead.</source>
        <target state="translated">この新しいメンバーは抽象メンバー '{0}' を隠ぺいしています。メンバーの名前を変更するか、代わりに 'override' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMemberWithSuffix">
        <source>This new member hides the abstract member '{0}' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead.</source>
        <target state="translated">タプル、関数、測定単位、または指定された型が消去されると、この新しいメンバーは抽象メンバー '{0}' を隠ぺいします。メンバーの名前を変更するか、代わりに 'override' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializersIllegalInInterface">
        <source>Interfaces cannot contain definitions of static initializers</source>
        <target state="translated">インターフェイスに静的初期化子の定義を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsIllegalInInterface">
        <source>Interfaces cannot contain definitions of object constructors</source>
        <target state="translated">インターフェイスにオブジェクト コンストラクターの定義を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOverridesIllegalInInterface">
        <source>Interfaces cannot contain definitions of member overrides</source>
        <target state="translated">インターフェイスにメンバーのオーバーライドの定義を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConcreteMembersIllegalInInterface">
        <source>Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.</source>
        <target state="translated">インターフェイスに具象メンバーの定義を含めることはできません。必要に応じて、型にコンストラクターを定義して、型がクラスであることを示してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsDisallowedInExceptionAugmentation">
        <source>Constructors cannot be specified in exception augmentations</source>
        <target state="translated">例外の拡張にコンストラクターは指定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCannotHaveConstructorWithNoArguments">
        <source>Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.</source>
        <target state="translated">構造体には、引数なしのオブジェクト コンストラクターを使用できません。構造体は既定のコンストラクターを自動的にサポートするため、これはすべての CLI 言語に課せられた制限です。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalForThisType">
        <source>Constructors cannot be defined for this type</source>
        <target state="translated">この型にコンストラクターは定義できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
        <source>Recursive bindings that include member specifications can only occur as a direct augmentation of a type</source>
        <target state="translated">メンバーの指定を含む再帰的束縛は、型の直接的な拡張としてのみ実行できます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimplePatternsInLetRec">
        <source>Only simple variable patterns can be bound in 'let rec' constructs</source>
        <target state="translated">'let rec' コンストラクトでバインドできるのは、単純な変数パターンのみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
        <source>Only record fields and simple, non-recursive 'let' bindings may be marked mutable</source>
        <target state="translated">'mutable' とマークできるのはレコード フィールドと単純で非再帰的な 'let' バインディングのみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberIsNotSufficientlyGeneric">
        <source>This member is not sufficiently generic</source>
        <target state="translated">このメンバーの総称性が十分ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralAttributeRequiresConstantValue">
        <source>A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. 'val x : int = 1'</source>
        <target state="translated">定数値も指定する場合、宣言は [&lt;Literal&gt;] 属性にしてください (たとえば、'val x : int = 1')</target>
        <note />
      </trans-unit>
      <trans-unit id="tcValueInSignatureRequiresLiteralAttribute">
        <source>A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute</source>
        <target state="translated">宣言に [&lt;Literal&gt;] 属性がある場合、その宣言に指定できるのはシグネチャ内の値のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThreadStaticAndContextStaticMustBeStatic">
        <source>Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread</source>
        <target state="translated">thread-static 変数および context-static 変数は静的にし、[&lt;DefaultValue&gt;] 属性を指定して、新しいスレッドごとに値が既定値に初期化されることを示してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileFieldsMustBeMutable">
        <source>Volatile fields must be marked 'mutable' and cannot be thread-static</source>
        <target state="translated">volatile フィールドは 'mutable' とマークしてください。また、thread-static にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUninitializedValFieldsMustBeMutable">
        <source>Uninitialized 'val' fields must be mutable and marked with the '[&lt;DefaultValue&gt;]' attribute. Consider using a 'let' binding instead of a 'val' field.</source>
        <target state="translated">初期化されていない 'val' フィールドは変更可能にし、'[&lt;DefaultValue&gt;]' 属性でマークする必要があります。'val' フィールドの代わりに 'let' 束縛をご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticValFieldsMustBeMutableAndPrivate">
        <source>Static 'val' fields in types must be mutable, private and marked with the '[&lt;DefaultValue&gt;]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type.</source>
        <target state="translated">型の静的 'val' フィールドは、変更可能で、プライベートにし、さらに '[&lt;DefaultValue&gt;]' 属性でマークしてください。フィールドはその型の 'null' 値または 'zero' 値に初期化されます。また、クラス型の 'static let mutable' 束縛もご使用ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresName">
        <source>This field requires a name</source>
        <target state="translated">このフィールドには名前が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNamespaceModuleTypeUnionName">
        <source>Invalid namespace, module, type or union case name</source>
        <target state="translated">名前空間、モジュール、型、または共用体ケースの名前が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalFormForExplicitTypeDeclaration">
        <source>Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -&gt; resTy'. Parentheses may be required around 'resTy'</source>
        <target state="translated">コンストラクターの明示的な型宣言は、'ty1 * ... * tyN -&gt; resTy' という形式にする必要があります。必要に応じて、'resTy' をかっこで囲んでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnTypesForUnionMustBeSameAsType">
        <source>Return types of union cases must be identical to the type being defined, up to abbreviations</source>
        <target state="translated">共用体ケースの戻り値の型は、省略形に従い、定義されている型と同じにする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumerationLiteral">
        <source>This is not a valid value for an enumeration literal</source>
        <target state="translated">列挙型リテラルの有効な値ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType1">
        <source>The type '{0}' is not an interface type</source>
        <target state="translated">型 '{0}' はインターフェイス型ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDuplicateSpecOfInterface">
        <source>Duplicate specification of an interface</source>
        <target state="translated">インターフェイスの指定に重複があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldValIllegalHere">
        <source>A field/val declaration is not permitted here</source>
        <target state="translated">ここでは field/val の宣言を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritIllegalHere">
        <source>A inheritance declaration is not permitted here</source>
        <target state="translated">ここでは継承の宣言を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleRequiresQualifiedAccess">
        <source>This declaration opens the module '{0}', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.</source>
        <target state="translated">この宣言はモジュール '{0}' を開きます。'{0}' は 'RequireQualifiedAccess' とマークされています。代わりにモジュールの要素に対する限定参照を使用するようにコードを変更してください (たとえば、'map' の代わりに 'List.map')。この変更によってコードが堅牢になり、新しいコンストラクターがライブラリに追加された場合にも対応できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenUsedWithPartiallyQualifiedPath">
        <source>This declaration opens the namespace or module '{0}' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.</source>
        <target state="translated">この宣言は部分的な修飾パスを介して名前空間またはモジュール '{0}' を開きます。名前空間の完全パスを使用するようにコードを変更してください。この変更によってコードが堅牢になり、新しいコンストラクターが F# ライブラリや CLI ライブラリに追加された場合にも対応できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLocalClassBindingsCannotBeInline">
        <source>Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.</source>
        <target state="translated">ローカル クラスの束縛に 'inline' とマークすることはできません。クラスから定義を取り除くか、'inline' とマークしないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsMayNotHaveMembers">
        <source>Type abbreviations cannot have members</source>
        <target state="translated">型略称にメンバーを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCheckedAtCompileTime">
        <source>As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.</source>
        <target state="translated">F# 4.1 まででは、型略称のアクセシビリティはコンパイル時に確認されます。型略称のアクセシビリティを変更することを検討してください。この警告を無視すると、ランタイム エラーが発生する可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsMayNotHaveMembers">
        <source>Enumerations cannot have members</source>
        <target state="translated">列挙型にメンバーを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembers">
        <source>Measure declarations may have only static members</source>
        <target state="translated">単位の宣言に使用できるのは静的なメンバーのみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainDoBindings">
        <source>Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings</source>
        <target state="translated">構造体の既定のコンストラクターは束縛を実行しないため、構造体には 'do' 束縛を含むことができません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainLetBindings">
        <source>Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.</source>
        <target state="translated">構造体の既定のコンストラクターは束縛を実行しないため、構造体には値の定義を含むことができません。型のプライマリ コンストラクターに引数を追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticLetBindingsRequireClassesWithImplicitConstructors">
        <source>Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">静的な値の定義は、プライマリ コンストラクターを含む型でのみ使用できます。型定義に引数を追加してください ( たとえば、'type X(args) = ...')。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembersNotConstructors">
        <source>Measure declarations may have only static members: constructors are not available</source>
        <target state="translated">単位の宣言に使用できるのは静的なメンバーのみです。コンストラクターは使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberAndLocalClassBindingHaveSameName">
        <source>A member and a local class binding both have the name '{0}'</source>
        <target state="translated">メンバーとローカル クラスの束縛はどちらも '{0}' という名前を使用しています</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
        <source>Type abbreviations cannot have interface declarations</source>
        <target state="translated">型略称にインターフェイスの宣言を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsCannotHaveInterfaceDeclaration">
        <source>Enumerations cannot have interface declarations</source>
        <target state="translated">列挙型にインターフェイスの宣言を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType0">
        <source>This type is not an interface type</source>
        <target state="translated">この型はインターフェイス型ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllImplementedInterfacesShouldBeDeclared">
        <source>All implemented interfaces should be declared on the initial declaration of the type</source>
        <target state="translated">実装したすべてのインターフェイスは、型の最初の宣言で宣言する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
        <source>A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type</source>
        <target state="translated">インターフェイスの明示的な実装が型の定義時に指定されなかったため、このインターフェイスの既定の実装が追加されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberNotPermittedInInterfaceImplementation">
        <source>This member is not permitted in an interface implementation</source>
        <target state="translated">インターフェイスの実装では、このメンバーは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclarationElementNotPermittedInAugmentation">
        <source>This declaration element is not permitted in an augmentation</source>
        <target state="translated">拡張にこの宣言の要素は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotContainNestedTypes">
        <source>Types cannot contain nested type definitions</source>
        <target state="translated">型に入れ子の型定義を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeExceptionOrModule">
        <source>type, exception or module</source>
        <target state="translated">型、例外、またはモジュール</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeOrModule">
        <source>type or module</source>
        <target state="translated">型またはモジュール</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type.</source>
        <target state="translated">構造体型、レコード型、または共用体型の '{0}' はインターフェイス 'System.IStructuralEquatable' を明示的に実装しています。この型には 'CustomEquality' 属性を適用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IEquatable&lt;_&gt;' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'.</source>
        <target state="translated">構造体型、レコード型、または共用体型の '{0}' は、インターフェイス 'System.IEquatable&lt;_&gt;' を明示的に実装しています。この型には 'CustomEquality' 属性を適用し、さらに整合性のある非ジェネリック オーバーライド 'System.Object.Equals(obj)' の実装を用意してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
        <source>Explicit type specifications cannot be used for exception constructors</source>
        <target state="translated">明示的な型の指定は、例外のコンストラクターには使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsShouldNotHaveArgumentList">
        <source>Exception abbreviations should not have argument lists</source>
        <target state="translated">例外の省略形に引数リストを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
        <source>Abbreviations for Common IL exceptions cannot take arguments</source>
        <target state="translated">Common IL の例外型の場合、省略形には引数を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsMustReferToValidExceptions">
        <source>Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception</source>
        <target state="translated">例外の省略形は、既存の例外、または System.Exception から派生した F# 型を参照する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
        <source>Abbreviations for Common IL exception types must have a matching object constructor</source>
        <target state="translated">Common IL の例外型の場合、省略形には対応するオブジェクト コンストラクターが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotAnException">
        <source>Not an exception</source>
        <target state="translated">例外ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidModuleName">
        <source>Invalid module name</source>
        <target state="translated">モジュール名が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeExtension">
        <source>Invalid type extension</source>
        <target state="translated">型の拡張が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesOfTypeSpecifyMultipleKindsForType">
        <source>The attributes of this type specify multiple kinds for the type</source>
        <target state="translated">この型の属性は、その型に対して複数の種類を指定しています</target>
        <note />
      </trans-unit>
      <trans-unit id="tcKindOfTypeSpecifiedDoesNotMatchDefinition">
        <source>The kind of the type specified by its attributes does not match the kind implied by its definition</source>
        <target state="translated">この属性によって指定された型の種類は、定義が示す種類と一致しません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDefinitionsCannotHaveTypeParameters">
        <source>Measure definitions cannot have type parameters</source>
        <target state="translated">単位の定義に型パラメーターは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeRequiresDefinition">
        <source>This type requires a definition</source>
        <target state="translated">この型には定義が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationHasTypeParametersMissingOnType">
        <source>This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C&lt;'a&gt; = C of ...'.</source>
        <target state="translated">この型略称では、省略される型に出現しない型パラメーターが 1 つまたは複数宣言されました。型略称には、省略される型のすべての宣言済み型パラメーターを使用する必要があります。1 つまたは複数のパラメーターを削除するか、基底となる型をラップする具象型定義を使用してください (たとえば、'type C&lt;'a&gt; = C of ...')。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
        <source>Structs, interfaces, enums and delegates cannot inherit from other types</source>
        <target state="translated">構造体、インターフェイス、列挙型、およびデリゲートは、他の型から継承できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotInheritFromMultipleConcreteTypes">
        <source>Types cannot inherit from multiple concrete types</source>
        <target state="translated">型は複数の具象型から継承できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
        <source>Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute</source>
        <target state="translated">レコード型、共用体型、省略形型、および構造体型に 'AllowNullLiteral' 属性を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
        <source>Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal</source>
        <target state="translated">'AllowNullLiteral' 属性を持つ型が継承または実装できるのは、null のリテラルも使用できる型のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericTypesCannotHaveStructLayout">
        <source>Generic types cannot be given the 'StructLayout' attribute</source>
        <target state="translated">ジェネリック型に 'StructLayout' 属性を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyStructsCanHaveStructLayout">
        <source>Only structs and classes without primary constructors may be given the 'StructLayout' attribute</source>
        <target state="translated">'StructLayout' 属性を指定できるのは、プライマリ コンストラクターなしの構造体およびクラスのみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRepresentationOfTypeHiddenBySignature">
        <source>The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.</source>
        <target state="translated">この型の表現はシグネチャによって隠ぺいされています。型の特性を示すために、[&lt;Sealed&gt;]、[&lt;Class&gt;]、[&lt;Interface&gt;] などの属性を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyClassesCanHaveAbstract">
        <source>Only classes may be given the 'AbstractClass' attribute</source>
        <target state="translated">'AbstractClass' 属性を指定できるのはクラスのみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
        <source>Only types representing units-of-measure may be given the 'Measure' attribute</source>
        <target state="translated">'Measure' 属性を指定できるのは、単位を表す型のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on overrides or interface implementations</source>
        <target state="translated">オーバーライドまたはインターフェイスの実装にはアクセシビリティ修飾子を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDU">
        <source>Discriminated union types are always sealed</source>
        <target state="translated">判別された共用体型は常にシールドです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedRecord">
        <source>Record types are always sealed</source>
        <target state="translated">レコード型は常にシールドです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedAssemblyCode">
        <source>Assembly code types are always sealed</source>
        <target state="translated">アセンブリ コード型は常にシールドです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedStruct">
        <source>Struct types are always sealed</source>
        <target state="translated">構造体型は常にシールドです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDelegate">
        <source>Delegate types are always sealed</source>
        <target state="translated">デリゲート型は常にシールドです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedEnum">
        <source>Enum types are always sealed</source>
        <target state="translated">列挙型は常にシールドです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesAndDelegatesCannotContainFields">
        <source>Interface types and delegate types cannot contain fields</source>
        <target state="translated">インターフェイス型またはデリゲート型にフィールドを含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviatedTypesCannotBeSealed">
        <source>Abbreviated types cannot be given the 'Sealed' attribute</source>
        <target state="translated">省略された型に 'Sealed' 属性を指定することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromSealedType">
        <source>Cannot inherit a sealed type</source>
        <target state="translated">シールド型を継承できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromInterfaceType">
        <source>Cannot inherit from interface type. Use interface ... with instead.</source>
        <target state="translated">インターフェイスの型から継承できません。代わりに interface ... with を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructTypesCannotContainAbstractMembers">
        <source>Struct types cannot contain abstract members</source>
        <target state="translated">構造体型に抽象メンバーを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesCannotBeSealed">
        <source>Interface types cannot be sealed</source>
        <target state="translated">インターフェイス型をシールドにすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDelegateSpecification">
        <source>Delegate specifications must be of the form 'typ -&gt; typ'</source>
        <target state="translated">デリゲートは 'typ -&gt; typ' という形式で指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegatesCannotBeCurried">
        <source>Delegate specifications must not be curried types. Use 'typ * ... * typ -&gt; typ' for multi-argument delegates, and 'typ -&gt; (typ -&gt; typ)' for delegates returning function values.</source>
        <target state="translated">デリゲートにはカリー化された型を指定しないでください。複数引数のデリゲートには 'typ * ... * typ -&gt; typ' を使用し、関数値を返すデリゲートには 'typ -&gt; (typ -&gt; typ)' を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForLiteralEnumeration">
        <source>Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char</source>
        <target state="translated">リテラル列挙値の型は、int、uint、int16、uint16、int64、uint64、byte、sbyte、または char にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclic">
        <source>This type definition involves an immediate cyclic reference through an abbreviation</source>
        <target state="translated">この型定義では、省略形による直接的な循環参照が発生します</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclicThroughInheritance">
        <source>This type definition involves an immediate cyclic reference through a struct field or inheritance relation</source>
        <target state="translated">この型定義では、構造体フィールドまたは継承の関係による直接的な循環参照が発生します</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReservedSyntaxForAugmentation">
        <source>The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[&lt;Sealed&gt;] attribute to the type definition in the signature</source>
        <target state="translated">構文 'type X with ...' は拡張のために予約されています。表現が隠ぺいされていてメンバーがある型が、'type X = ...' を使用するシグネチャで宣言されています。必要に応じて、シグネチャ内の型定義に '[&lt;Sealed&gt;]' 属性も追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
        <source>Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.</source>
        <target state="translated">インターフェイス型、デリゲート型、または列挙型を拡張するメンバーは、型の定義とは別のモジュールに配置する必要があります。このモジュールに AutoOpen 属性を指定するか、クライアント コードで明示的にモジュールを開いて、拡張メンバーをスコープに含める必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal">
        <source>One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '{0}'</source>
        <target state="translated">この型の拡張の 1 つ以上の宣言された型パラメーターについて、型の制約が見つからないか、型の制約が '{0}' の元の型の制約に一致しないため正しくありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
        <source>Type definitions may only have one 'inherit' specification and it must be the first declaration</source>
        <target state="translated">型定義に含めることができる 'inherit' 指定は 1 つのみであり、これを最初の宣言にする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
        <source>'let' and 'do' bindings must come before member and interface definitions in type definitions</source>
        <target state="translated">型定義内のメンバーとインターフェイスの定義の前に、'let' および 'do' 束縛を含める必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritDeclarationMissingArguments">
        <source>This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'.</source>
        <target state="translated">この 'inherit' 宣言は継承された型を指定していますが、引数がありません。引数を指定してください (たとえば、'inherit BaseType(args)')。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritConstructionCallNotPartOfImplicitSequence">
        <source>This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">この 'inherit' 宣言には引数が含まれていますが、これはプライマリ コンストラクターを含む型ではありません。型定義に引数を追加してください (たとえば、'type X(args) = ...')。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLetAndDoRequiresImplicitConstructionSequence">
        <source>This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">この定義は、プライマリ コンストラクターを含む型でのみ使用できます。型定義に引数を追加してください (たとえば、'type X(args) = ...')。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveAugmentations">
        <source>Type abbreviations cannot have augmentations</source>
        <target state="translated">型略称に拡張を含めることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbreviationForNamespace">
        <source>The path '{0}' is a namespace. A module abbreviation may not abbreviate a namespace.</source>
        <target state="translated">パス '{0}' は名前空間です。モジュールの省略形は名前空間の省略形にはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeUsedInInvalidWay">
        <source>The type '{0}' is used in an invalid way. A value prior to '{1}' has an inferred type involving '{2}', which is an invalid forward reference.</source>
        <target state="translated">型 '{0}' の使用方法に誤りがあります。'{1}' の前の値に、'{2}' と推論されるような型があります。これは無効な前方参照です。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to the definition of '{2}', which is an invalid forward reference.</source>
        <target state="translated">メンバー '{0}' の使用方法に誤りがあります。'{2}' の定義の前に '{1}' の使用が推論されました。これは無効な前方参照です。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeAutoOpenWasIgnored">
        <source>The attribute 'AutoOpen(\"{0}\")' in the assembly '{1}' did not refer to a valid module or namespace in that assembly and has been ignored</source>
        <target state="translated">アセンブリ '{1}' の属性 'AutoOpen(\"{0}\")' は、このアセンブリ内の有効なモジュールまたは名前空間を参照していないため、無視されました</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUndefinedValue">
        <source>Undefined value '{0}'</source>
        <target state="translated">未定義の値 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLabelNotFound">
        <source>Label {0} not found</source>
        <target state="translated">ラベル {0} が見つかりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilIncorrectNumberOfTypeArguments">
        <source>Incorrect number of type arguments to local call</source>
        <target state="translated">ローカルの呼び出しに対する型引数の数が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDynamicInvocationNotSupported">
        <source>Dynamic invocation of {0} is not supported</source>
        <target state="translated">{0} の動的呼び出しはサポートされません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfLiteralFieldIsInvalid">
        <source>Taking the address of a literal field is invalid</source>
        <target state="translated">リテラル フィールドのアドレスは使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfValueHereIsInvalid">
        <source>This operation involves taking the address of a value '{0}' represented using a local variable or other special representation. This is invalid.</source>
        <target state="translated">この操作には、ローカル変数または他の特殊な表現を使用して表された値 '{0}' のアドレスが使用されています。これは無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ilCustomMarshallersCannotBeUsedInFSharp">
        <source>Custom marshallers cannot be specified in F# code. Consider using a C# helper function.</source>
        <target state="translated">F# コードではカスタム マーシャラーを指定できません。C# ヘルパー関数を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMarshalAsAttributeCannotBeDecoded">
        <source>The MarshalAs attribute could not be decoded</source>
        <target state="translated">MarshalAs 属性をデコードできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignatureForExternalFunctionContainsTypeParameters">
        <source>The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.</source>
        <target state="translated">この外部関数のシグネチャには型パラメーターが含まれます。引数を制限し、対応する C 関数の型を示す型を戻してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDllImportAttributeCouldNotBeDecoded">
        <source>The DllImport attribute could not be decoded</source>
        <target state="translated">DllImport 属性をデコードできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLiteralFieldsCannotBeSet">
        <source>Literal fields cannot be set</source>
        <target state="translated">リテラル フィールドを設定できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStaticMethodIsNotLambda">
        <source>GenSetStorage: {0} was represented as a static method but was not an appropriate lambda expression</source>
        <target state="translated">GenSetStorage: {0} は静的メソッドとして表現されましたが、適切なラムダ式ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMutableVariablesCannotEscapeMethod">
        <source>Mutable variables cannot escape their method</source>
        <target state="translated">変更可能な変数ではメソッドをエスケープできません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedUnrealizedValue">
        <source>Compiler error: unexpected unrealized value</source>
        <target state="translated">コンパイラー エラー: 予期しない認識されない値</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMainModuleEmpty">
        <source>Main module of program is empty: nothing will happen when it is run</source>
        <target state="translated">プログラムのメイン モジュールが空です。実行しても何も処理されません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilTypeCannotBeUsedForLiteralField">
        <source>This type cannot be used for a literal field</source>
        <target state="translated">リテラル フィールドにこの型は使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedGetSetAnnotation">
        <source>Unexpected GetSet annotation on a property</source>
        <target state="translated">プロパティに予期しない GetSet 注釈がありました:</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldOffsetAttributeCouldNotBeDecoded">
        <source>The FieldOffset attribute could not be decoded</source>
        <target state="translated">FieldOffset 属性をデコードできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStructLayoutAttributeCouldNotBeDecoded">
        <source>The StructLayout attribute could not be decoded</source>
        <target state="translated">StructLayout 属性をデコードできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDefaultAugmentationAttributeCouldNotBeDecoded">
        <source>The DefaultAugmentation attribute could not be decoded</source>
        <target state="translated">DefaultAugmentation 属性をデコードできませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ilReflectedDefinitionsCannotUseSliceOperator">
        <source>Reflected definitions cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">リフレクションされた定義には、プレフィックスのスプライス演算子 '%' を使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="optsProblemWithCodepage">
        <source>Problem with codepage '{0}': {1}</source>
        <target state="translated">コードページ '{0}' に問題があります: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyright">
        <source>Copyright (c) Microsoft Corporation. All Rights Reserved.</source>
        <target state="translated">Copyright (c) Microsoft Corporation. All Rights Reserved.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyrightCommunity">
        <source>Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</source>
        <target state="translated">MIT のオープン ソース ライセンスで無料配布されています。https://github.com/Microsoft/visualfsharp/blob/master/License.txt</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNameOfOutputFile">
        <source>Name of the output file (Short form: -o)</source>
        <target state="translated">出力ファイルの名前 (短い形式: -o)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildConsole">
        <source>Build a console executable</source>
        <target state="translated">コンソール実行可能ファイルをビルドします</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildWindows">
        <source>Build a Windows executable</source>
        <target state="translated">Windows 実行可能ファイルをビルドします</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildLibrary">
        <source>Build a library (Short form: -a)</source>
        <target state="translated">ライブラリをビルドします (短い形式: -a)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildModule">
        <source>Build a module that can be added to another assembly</source>
        <target state="translated">別のアセンブリに追加できるモジュールをビルドします</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDelaySign">
        <source>Delay-sign the assembly using only the public portion of the strong name key</source>
        <target state="translated">厳密名キーのパブリックな部分のみを使ってアセンブリを遅延署名します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPublicSign">
        <source>Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed</source>
        <target state="translated">厳密な名前のキーの公開部分のみを使ってアセンブリを公開署名し、アセンブリを署名済みとしてマークします</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWriteXml">
        <source>Write the xmldoc of the assembly to the given file</source>
        <target state="translated">指定したファイルにアセンブリの xmldoc を書き込みます</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyFile">
        <source>Specify a strong name key file</source>
        <target state="translated">厳密名キー ファイルを指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyContainer">
        <source>Specify a strong name key container</source>
        <target state="translated">厳密名キー コンテナーを指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPlatform">
        <source>Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.</source>
        <target state="translated">このコードが実行されるプラットフォームの制限: x86、Itanium、x64、anycpu32bitpreferred、または anycpu。既定は anycpu です。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoOpt">
        <source>Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.</source>
        <target state="translated">インライン コンストラクトの実装に必要な最適化情報のみを含めてください。モジュール間のインライン処理を禁止し、バイナリの互換性を改善してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoInterface">
        <source>Don't add a resource to the generated assembly containing F#-specific metadata</source>
        <target state="translated">F# 固有のメタデータを含む生成済みアセンブリにリソースを追加しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSig">
        <source>Print the inferred interface of the assembly to a file</source>
        <target state="translated">アセンブリの推論されたインターフェイスをファイルに出力します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsReference">
        <source>Reference an assembly (Short form: -r)</source>
        <target state="translated">アセンブリを参照します (短い形式: -r)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32res">
        <source>Specify a Win32 resource file (.res)</source>
        <target state="translated">Win32 リソース ファイル (.res) を指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32manifest">
        <source>Specify a Win32 manifest file</source>
        <target state="translated">Win32 マニフェスト ファイルを指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowin32manifest">
        <source>Do not include the default Win32 manifest</source>
        <target state="translated">既定の Win32 マニフェストを含めないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedAllSource">
        <source>Embed all source files in the portable PDB file</source>
        <target state="translated">ポータブル PDB ファイル内にすべてのソース ファイルを埋め込む</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedSource">
        <source>Embed specific source files in the portable PDB file</source>
        <target state="translated">ポータブル PDB ファイル内に特定のソース ファイルを埋め込む</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLink">
        <source>Source link information file to embed in the portable PDB file</source>
        <target state="translated">ポータブル PDB ファイルに埋め込むソース リンク情報ファイル</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbeddedSourceRequirePortablePDBs">
        <source>--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">--embed スイッチは、ポータブル PDB の生成時にのみサポートされます (--debug:portable または --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLinkRequirePortablePDBs">
        <source>--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">--sourcelink スイッチは、ポータブル PDB の生成時にのみサポートされます (--debug:portable または --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="srcFileTooLarge">
        <source>Source file is too large to embed in a portable PDB</source>
        <target state="translated">ソース ファイルが大きすぎるので、ポータブル PDB 内に埋め込めません</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResource">
        <source>Embed the specified managed resource</source>
        <target state="translated">指定したマネージ リソースを埋め込みます</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLinkresource">
        <source>Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]</source>
        <target state="translated">指定したリソースをこのアセンブリにリンクします。このとき、リソース情報の形式は &lt;ファイル&gt;[,&lt;文字列名&gt;[,public|private]] です。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebugPM">
        <source>Emit debug information (Short form: -g)</source>
        <target state="translated">デバッグ情報を生成します (短い形式: -g)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebug">
        <source>Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file).</source>
        <target state="translated">デバッグの種類 full、portable、pdbonly を指定します (デバッグの種類が指定されない場合には '{0}' が既定で、実行中のプログラムにデバッガーを付加することができます。'portable' はクロスプラットフォーム形式、'embedded' は出力ファイルに埋め込まれたクロスプラットフォーム形式です)。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsOptimize">
        <source>Enable optimizations (Short form: -O)</source>
        <target state="translated">最適化を有効にします (短い形式: -O)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTailcalls">
        <source>Enable or disable tailcalls</source>
        <target state="translated">tail の呼び出しを有効または無効にします</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDeterministic">
        <source>Produce a deterministic assembly (including module version GUID and timestamp)</source>
        <target state="translated">決定論的アセンブリを作成します (モジュール バージョン GUID やタイムスタンプなど)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCrossoptimize">
        <source>Enable or disable cross-module optimizations</source>
        <target state="translated">モジュール間の最適化を有効または無効にします</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserrorPM">
        <source>Report all warnings as errors</source>
        <target state="translated">すべての警告をエラーとして報告する</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserror">
        <source>Report specific warnings as errors</source>
        <target state="translated">指定した警告をエラーとして報告する</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarn">
        <source>Set a warning level (0-5)</source>
        <target state="translated">警告レベル (0 ～ 5) を設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowarn">
        <source>Disable specific warning messages</source>
        <target state="translated">指定の警告メッセージを無効にする</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnOn">
        <source>Enable specific warnings that may be off by default</source>
        <target state="translated">既定でオフにすることができる特定の警告を有効にします</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecked">
        <source>Generate overflow checks</source>
        <target state="translated">オーバーフロー チェックの生成</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDefine">
        <source>Define conditional compilation symbols (Short form: -d)</source>
        <target state="translated">条件付きコンパイル シンボルを定義します (短い形式: -d)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsMlcompatibility">
        <source>Ignore ML compatibility warnings</source>
        <target state="translated">ML 互換性に関する警告を無視します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNologo">
        <source>Suppress compiler copyright message</source>
        <target state="translated">コンパイラーの著作権メッセージを表示しません</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelp">
        <source>Display this usage message (Short form: -?)</source>
        <target state="translated">この使用方法に関するメッセージを表示します (短い形式: -?)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFile">
        <source>Read response file for more options</source>
        <target state="translated">その他のオプションを、応答ファイルから読み取ります</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCodepage">
        <source>Specify the codepage used to read source files</source>
        <target state="translated">ソース ファイルの読み取りに使用するコードページを指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUtf8output">
        <source>Output messages in UTF-8 encoding</source>
        <target state="translated">UTF-8 エンコードでメッセージを出力します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsFullpaths">
        <source>Output messages with fully qualified paths</source>
        <target state="translated">完全修飾パスを含むメッセージを出力します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLib">
        <source>Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)</source>
        <target state="translated">ソース ファイルおよびアセンブリの解決に使用する include パスのディレクトリを指定します (短い形式: -I)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBaseaddress">
        <source>Base address for the library to be built</source>
        <target state="translated">ビルドするライブラリのベース アドレス</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoframework">
        <source>Do not reference the default CLI assemblies by default</source>
        <target state="translated">既定では、既定の CLI アセンブリを参照しません</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStandalone">
        <source>Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated</source>
        <target state="translated">F# ライブラリと、ライブラリに依存するすべての参照 DLL を、生成されるアセンブリへ静的にリンクします</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStaticlink">
        <source>Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.</source>
        <target state="translated">指定したアセンブリと、そのアセンブリに依存するすべての参照 DLL を静的にリンクします。DLL 名ではなく、アセンブリ名 (たとえば、mylib) を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResident">
        <source>Use a resident background compilation service to improve compiler startup times.</source>
        <target state="translated">バックグラウンドに常駐するコンパイル サービスを使用して、コンパイラの起動時間を改善します。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPdb">
        <source>Name the output debug file</source>
        <target state="translated">出力デバッグ ファイルの名前を指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSimpleresolution">
        <source>Resolve assembly references using directory-based rules rather than MSBuild resolution</source>
        <target state="translated">MSBuild の解決ではなく、ディレクトリベースの規則を使用してアセンブリの参照を解決します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedTarget">
        <source>Unrecognized target '{0}', expected 'exe', 'winexe', 'library' or 'module'</source>
        <target state="translated">認識されないターゲット '{0}'。'exe'、'winexe'、'library'、または 'module' を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedDebugType">
        <source>Unrecognized debug type '{0}', expected 'pdbonly' or 'full'</source>
        <target state="translated">認識されないデバッグの種類 '{0}'。'pdbonly' または 'full' を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidWarningLevel">
        <source>Invalid warning level '{0}'</source>
        <target state="translated">警告レベル '{0}' が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="optsShortFormOf">
        <source>Short form of '{0}'</source>
        <target state="translated">'{0}' の短い形式</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDeprecatedMsg">
        <source>The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.</source>
        <target state="translated">コマンド ライン オプション '--cliroot' は使用されなくなりました。代わりに mscorlib.dll の特定のコピーに対する明示的な参照を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDescription">
        <source>Use to override where the compiler looks for mscorlib.dll and framework components</source>
        <target state="translated">コンパイラーが mscorlib.dll およびフレームワーク コンポーネントを検索する場所をオーバーライドするために使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerOutputFiles">
        <source>- OUTPUT FILES -</source>
        <target state="translated">- 出力ファイル -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerInputFiles">
        <source>- INPUT FILES -</source>
        <target state="translated">- 入力ファイル -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerResources">
        <source>- RESOURCES -</source>
        <target state="translated">- リソース -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerCodeGen">
        <source>- CODE GENERATION -</source>
        <target state="translated">- コード生成 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerAdvanced">
        <source>- ADVANCED -</source>
        <target state="translated">- 詳細 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerMisc">
        <source>- MISCELLANEOUS -</source>
        <target state="translated">- その他 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerLanguage">
        <source>- LANGUAGE -</source>
        <target state="translated">- 言語 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerErrsAndWarns">
        <source>- ERRORS AND WARNINGS -</source>
        <target state="translated">- エラーと警告 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownArgumentToTheTestSwitch">
        <source>Unknown --test argument: '{0}'</source>
        <target state="translated">不明 -- テスト引数:'{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownPlatform">
        <source>Unrecognized platform '{0}', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'</source>
        <target state="translated">認識されないプラットフォーム '{0}'。有効な値は 'x86'、'x64'、'Itanium'、'anycpu32bitpreferred'、および 'anycpu' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInternalNoDescription">
        <source>The command-line option '{0}' is for test purposes only</source>
        <target state="translated">コマンド ライン オプション '{0}' はテスト目的でのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLONoDescription">
        <source>The command-line option '{0}' has been deprecated</source>
        <target state="translated">コマンド ライン オプション '{0}' は使用されなくなりました</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLODeprecatedSuggestAlternative">
        <source>The command-line option '{0}' has been deprecated. Use '{1}' instead.</source>
        <target state="translated">コマンド ライン オプション '{0}' は使用されなくなりました。代わりに '{1}' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLOHtmlDoc">
        <source>The command-line option '{0}' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.</source>
        <target state="translated">コマンド ライン オプション '{0}' は使用されなくなりました。HTML ドキュメントの生成は、F# Power Pack のツール FsHtmlDoc.exe で実行できるようになりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsConsoleColors">
        <source>Output warning and error messages in color</source>
        <target state="translated">警告メッセージとエラー メッセージを色つきで表示します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUseHighEntropyVA">
        <source>Enable high-entropy ASLR</source>
        <target state="translated">高エントロピ ASLR の有効化</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSubSystemVersion">
        <source>Specify subsystem version of this assembly</source>
        <target state="translated">このアセンブリのサブシステム バージョンを指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTargetProfile">
        <source>Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib</source>
        <target state="translated">このアセンブリのターゲット フレームワーク プロファイルを指定します。有効な値は、mscorlib、netcore、netstandard のいずれかです。既定 - mscorlib</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmitDebugInfoInQuotations">
        <source>Emit debug information in quotations</source>
        <target state="translated">デバッグ情報を引用符で囲んで生成します</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPreferredUiLang">
        <source>Specify the preferred output language culture name (e.g. es-ES, ja-JP)</source>
        <target state="translated">優先する出力用言語のカルチャ名を指定します (例: es-ES, ja-JP)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoCopyFsharpCore">
        <source>Don't copy FSharp.Core.dll along the produced binaries</source>
        <target state="translated">生成したバイナリと共に FSharp.Core.dll をコピーしないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidSubSystemVersion">
        <source>Invalid version '{0}' for '--subsystemversion'. The version must be 4.00 or greater.</source>
        <target state="translated">'--subsystemversion' のバージョン '{0}' が無効です。バージョンは 4.00 以上でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidTargetProfile">
        <source>Invalid value '{0}' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.</source>
        <target state="translated">'--targetprofile' の値 '{0}' が無効です。有効な値は 'mscorlib'、'netcore'、'netstandard' のいずれかです。</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFullName">
        <source>Full name</source>
        <target state="translated">完全名</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoOtherOverloads">
        <source>and {0} other overloads</source>
        <target state="translated">およびその他の {0} 個のオーバーロード</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoUnionCase">
        <source>union case</source>
        <target state="translated">共用体ケース</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActivePatternResult">
        <source>active pattern result</source>
        <target state="translated">アクティブ パターンの結果</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActiveRecognizer">
        <source>active recognizer</source>
        <target state="translated">アクティブ レコグナイザー</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoField">
        <source>field</source>
        <target state="translated">フィールド</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoEvent">
        <source>event</source>
        <target state="translated">イベント</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoProperty">
        <source>property</source>
        <target state="translated">プロパティ</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoExtension">
        <source>extension</source>
        <target state="translated">拡張子</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCustomOperation">
        <source>custom operation</source>
        <target state="translated">カスタム操作</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoArgument">
        <source>argument</source>
        <target state="translated">引数</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoPatternVariable">
        <source>patvar</source>
        <target state="translated">patvar</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespace">
        <source>namespace</source>
        <target state="translated">名前空間</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoModule">
        <source>module</source>
        <target state="translated">モジュール</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespaceOrModule">
        <source>namespace/module</source>
        <target state="translated">名前空間/モジュール</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromFirst">
        <source>from {0}</source>
        <target state="translated">{0} から</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromNext">
        <source>also from {0}</source>
        <target state="translated">また、{0} から</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedProperty">
        <source>generated property</source>
        <target state="translated">生成されたプロパティ</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedType">
        <source>generated type</source>
        <target state="translated">生成された型</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersKey">
        <source>Found by AssemblyFolders registry key</source>
        <target state="translated">AssemblyFolders レジストリ キーによって検出されました</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersExKey">
        <source>Found by AssemblyFoldersEx registry key</source>
        <target state="translated">AssemblyFoldersEx レジストリ キーによって検出されました</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionNetFramework">
        <source>.NET Framework</source>
        <target state="translated">.NET Framework</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionGAC">
        <source>Global Assembly Cache</source>
        <target state="translated">グローバル アセンブリ キャッシュ</target>
        <note />
      </trans-unit>
      <trans-unit id="recursiveClassHierarchy">
        <source>Recursive class hierarchy in type '{0}'</source>
        <target state="translated">型 '{0}' の再帰的クラス階層</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRecursiveReferenceToAbstractSlot">
        <source>Invalid recursive reference to an abstract slot</source>
        <target state="translated">抽象スロットに対する再帰的参照が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="eventHasNonStandardType">
        <source>The event '{0}' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit {1} and {2} methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent&lt;_&gt;' or 'IEvent&lt;_,_&gt;'.</source>
        <target state="translated">イベント '{0}' が標準以外の型です。このイベントが別の CLI 言語で宣言された場合、イベントにアクセスするには、このイベントに明示的な {1} メソッドや {2} メソッドを使用する必要があります。このイベントが F# で宣言された場合、イベントの型を IDelegateEvent&lt;_&gt;' または 'IEvent&lt;_,_&gt;' のインスタンス化にします。</target>
        <note />
      </trans-unit>
      <trans-unit id="typeIsNotAccessible">
        <source>The type '{0}' is not accessible from this code location</source>
        <target state="translated">型 '{0}' はこのコードの場所からアクセスできません</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCasesAreNotAccessible">
        <source>The union cases or fields of the type '{0}' are not accessible from this code location</source>
        <target state="translated">型 '{0}' の共用体ケースまたはフィールドは、このコードの場所からアクセスできません</target>
        <note />
      </trans-unit>
      <trans-unit id="valueIsNotAccessible">
        <source>The value '{0}' is not accessible from this code location</source>
        <target state="translated">値 '{0}' はこのコードの場所からアクセスできません</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCaseIsNotAccessible">
        <source>The union case '{0}' is not accessible from this code location</source>
        <target state="translated">共用体ケース '{0}' はこのコードの場所からアクセスできません</target>
        <note />
      </trans-unit>
      <trans-unit id="fieldIsNotAccessible">
        <source>The record, struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">レコード、構造体、またはクラスのフィールド '{0}' はこのコードの場所からアクセスできません</target>
        <note />
      </trans-unit>
      <trans-unit id="structOrClassFieldIsNotAccessible">
        <source>The struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">構造体またはクラスのフィールド '{0}' はこのコードの場所からアクセスできません</target>
        <note />
      </trans-unit>
      <trans-unit id="experimentalConstruct">
        <source>This construct is experimental</source>
        <target state="translated">このコンストラクトは試験段階です</target>
        <note />
      </trans-unit>
      <trans-unit id="noInvokeMethodsFound">
        <source>No Invoke methods found for delegate type</source>
        <target state="translated">デリゲート型に Invoke メソッドが見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="moreThanOneInvokeMethodFound">
        <source>More than one Invoke method found for delegate type</source>
        <target state="translated">デリゲート型に複数の Invoke メソッドが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="delegatesNotAllowedToHaveCurriedSignatures">
        <source>Delegates are not allowed to have curried signatures</source>
        <target state="translated">カリー化されたシグネチャを含むデリゲートは許可されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrUnexpectedTExpr">
        <source>Unexpected Expr.TyChoose</source>
        <target state="translated">予期しない Expr.TyChoose です:</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrLambdaLiftingOptimizationsNotApplied">
        <source>Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.</source>
        <target state="translated">注意: ファースト クラス値としてこのローカルの制約付きジェネリック関数が使用されているため、ラムダリフティングの最適化は適用されませんでした。型制約を追加することで、この状態を解決できる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifiersContainingAtSymbolReserved">
        <source>Identifiers containing '@' are reserved for use in F# code generation</source>
        <target state="translated">'@' を含む識別子は、F# コードの生成で使用するために予約されています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifierReserved">
        <source>The identifier '{0}' is reserved for future use by F#</source>
        <target state="translated">識別子 '{0}' は F# で将来利用するために予約されています</target>
        <note />
      </trans-unit>
      <trans-unit id="patcMissingVariable">
        <source>Missing variable '{0}'</source>
        <target state="translated">変数 '{0}' が見つかりません</target>
        <note />
      </trans-unit>
      <trans-unit id="patcPartialActivePatternsGenerateOneResult">
        <source>Partial active patterns may only generate one result</source>
        <target state="translated">パーシャル アクティブ パターンで生成できる結果は 1 個のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="impTypeRequiredUnavailable">
        <source>The type '{0}' is required here and is unavailable. You must add a reference to assembly '{1}'.</source>
        <target state="translated">ここでは型 '{0}' が必要ですが使用できません。アセンブリ '{1}' に参照を追加する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferencedTypeCouldNotBeFoundInAssembly">
        <source>A reference to the type '{0}' in assembly '{1}' was found, but the type could not be found in that assembly</source>
        <target state="translated">アセンブリ '{1}' 内の型 '{0}' に対する参照が見つかりましたが、型はそのアセンブリ内に見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="impNotEnoughTypeParamsInScopeWhileImporting">
        <source>Internal error or badly formed metadata: not enough type parameters were in scope while importing</source>
        <target state="translated">内部エラーまたはメタデータの形式エラー: インポート中のスコープに含まれる型パラメーターが足りません</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferenceToDllRequiredByAssembly">
        <source>A reference to the DLL {0} is required by assembly {1}. The imported type {2} is located in the first assembly and could not be resolved.</source>
        <target state="translated">アセンブリ {1} には DLL {0} に対する参照が必要です。インポートされた型 {2} は最初のアセンブリにあり、解決できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="impImportedAssemblyUsesNotPublicType">
        <source>An imported assembly uses the type '{0}' but that type is not public</source>
        <target state="translated">インポートされたアセンブリでは型 '{0}' を使用していますが、その型はパブリックではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButIncomplete">
        <source>The value '{0}' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible</source>
        <target state="translated">値 '{0}' は 'inline' とマークされましたが、実装ではアクセシビリティが低い内部関数またはプライベート関数を使用しています</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButWasNotBoundInTheOptEnv">
        <source>The value '{0}' was marked inline but was not bound in the optimization environment</source>
        <target state="translated">値 '{0}' は 'inline' とマークされましたが、最適化環境ではバインドされません</target>
        <note />
      </trans-unit>
      <trans-unit id="optLocalValueNotFoundDuringOptimization">
        <source>Local value {0} not found during optimization</source>
        <target state="translated">最適化中にローカルの値 {0} が見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineHasUnexpectedValue">
        <source>A value marked as 'inline' has an unexpected value</source>
        <target state="translated">'inline' とマークされた値に予期しない値が含まれます</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineCouldNotBeInlined">
        <source>A value marked as 'inline' could not be inlined</source>
        <target state="translated">'inline' とマークされた値をインライン展開できませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="optFailedToInlineValue">
        <source>Failed to inline the value '{0}' marked 'inline', perhaps because a recursive value was marked 'inline'</source>
        <target state="translated">'inline' とマークされた値 '{0}' をインライン化できませんでした。再帰的な値が 'inline' とマークされた可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="optRecursiveValValue">
        <source>Recursive ValValue {0}</source>
        <target state="translated">再帰的な ValValue {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltIncorrentIndentationOfIn">
        <source>The indentation of this 'in' token is incorrect with respect to the corresponding 'let'</source>
        <target state="translated">この 'in' トークンのインデントは、対応する 'let' に対して正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltTokenIsOffsideOfContextStartedEarlier">
        <source>Possible incorrect indentation: this token is offside of context started at position {0}. Try indenting this token further or using standard formatting conventions.</source>
        <target state="translated">インデントが正しくない可能性があります。このトークンは位置 {0} から開始されるコンテキストのオフサイドになります。このトークンのインデントを増やすか、標準的な書式規則を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltSeparatorTokensOfPatternMatchMisaligned">
        <source>The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.</source>
        <target state="translated">ある列で、このパターン マッチの規則を区切る '|' トークンが正しく配置されていません。コードの配置を変更するか、インデントを増やしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidModuleExprType">
        <source>Invalid module/expression/type</source>
        <target state="translated">モジュール/式/型が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationNeededToDisambiguateTypesWithSameName">
        <source>Multiple types exist called '{0}', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '{1}'.</source>
        <target state="translated">異なる数のジェネリック パラメーターを使用する '{0}' という複数の型が存在します。厳密に型を解決できるように、型のインスタンス化を指定してください (たとえば、'{1}')。</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationIsMissingAndCouldNotBeInferred">
        <source>The instantiation of the generic type '{0}' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '{1}'.</source>
        <target state="translated">ジェネリック型 '{0}' のインスタンス化がありません。また、このメンバーの引数または戻り値の型から推論できません。この型にアクセスするときは型のインスタンス化を指定してください (たとえば、'{1}')。</target>
        <note />
      </trans-unit>
      <trans-unit id="nrGlobalUsedOnlyAsFirstName">
        <source>'global' may only be used as the first name in a qualified path</source>
        <target state="translated">'global' は、修飾パスの最初の名前としてのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="nrIsNotConstructorOrLiteral">
        <source>This is not a constructor or literal, or a constructor is being used incorrectly</source>
        <target state="translated">これはコンストラクターまたはリテラルではありません。またはコンストラクターの使用方法に誤りがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnexpectedEmptyLongId">
        <source>Unexpected empty long identifier</source>
        <target state="translated">予期しない空の長識別子:</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordDoesNotContainSuchLabel">
        <source>The record type '{0}' does not contain a label '{1}'.</source>
        <target state="translated">レコードの種類 '{0}' にラベル '{1}' が含まれていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidFieldLabel">
        <source>Invalid field label</source>
        <target state="translated">フィールド ラベルが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidExpression">
        <source>Invalid expression '{0}'</source>
        <target state="translated">式 '{0}' は無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="nrNoConstructorsAvailableForType">
        <source>No constructors are available for the type '{0}'</source>
        <target state="translated">型 '{0}' に使用できるコンストラクターがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnionTypeNeedsQualifiedAccess">
        <source>The union type for union case '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('{1}') in the name you are using.</source>
        <target state="translated">共用体ケース '{0}' の共用体型が RequireQualifiedAccessAttribute によって定義されました。使用中の名前に共用体型 ('{1}') の名前を含めてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordTypeNeedsQualifiedAccess">
        <source>The record type for the record field '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('{1}') in the name you are using.</source>
        <target state="translated">レコード フィールド '{0}' のレコード型が RequireQualifiedAccessAttribute によって定義されました。使用中の名前にレコード型 ('{1}') の名前を含めてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingPdb">
        <source>Unexpected error creating debug information file '{0}'</source>
        <target state="translated">デバッグ情報ファイル '{0}' の作成中に予期しないエラーが発生しました:</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideIntegerRange">
        <source>This number is outside the allowable range for this integer type</source>
        <target state="translated">この数値は、この整数型に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexCharNotAllowedInOperatorNames">
        <source>'{0}' is not permitted as a character in operator names and is reserved for future use</source>
        <target state="translated">'{0}' は演算子名の文字として使用できません。将来利用するために予約されています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexUnexpectedChar">
        <source>Unexpected character '{0}'</source>
        <target state="translated">予期しない文字 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteArrayCannotEncode">
        <source>This byte array literal contains characters that do not encode as a single byte</source>
        <target state="translated">このバイト配列リテラルには、シングル バイトとしてエンコードされない文字が含まれます</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIdentEndInMarkReserved">
        <source>Identifiers followed by '{0}' are reserved for future use</source>
        <target state="translated">'{0}' が続く識別子は将来利用するために予約されています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSigned">
        <source>This number is outside the allowable range for 8-bit signed integers</source>
        <target state="translated">この数値は、8 ビット符号付き整数に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSignedHex">
        <source>This number is outside the allowable range for hexadecimal 8-bit signed integers</source>
        <target state="translated">この数値は、16 進 8 ビット符号付き整数に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitUnsigned">
        <source>This number is outside the allowable range for 8-bit unsigned integers</source>
        <target state="translated">この数値は、8 ビット符号なし整数に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitSigned">
        <source>This number is outside the allowable range for 16-bit signed integers</source>
        <target state="translated">この数値は、16 ビット符号付き整数に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitUnsigned">
        <source>This number is outside the allowable range for 16-bit unsigned integers</source>
        <target state="translated">この数値は、16 ビット符号なし整数に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitSigned">
        <source>This number is outside the allowable range for 32-bit signed integers</source>
        <target state="translated">この数値は、32 ビット符号付き整数に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitUnsigned">
        <source>This number is outside the allowable range for 32-bit unsigned integers</source>
        <target state="translated">この数値は、32 ビット符号なし整数に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitSigned">
        <source>This number is outside the allowable range for 64-bit signed integers</source>
        <target state="translated">この数値は、64 ビット符号付き整数に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitUnsigned">
        <source>This number is outside the allowable range for 64-bit unsigned integers</source>
        <target state="translated">この数値は、64 ビット符号なし整数に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeSigned">
        <source>This number is outside the allowable range for signed native integers</source>
        <target state="translated">この数値は、符号付きネイティブ整数に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeUnsigned">
        <source>This number is outside the allowable range for unsigned native integers</source>
        <target state="translated">この数値は、符号なしネイティブ整数に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidFloat">
        <source>Invalid floating point number</source>
        <target state="translated">浮動小数点数が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideDecimal">
        <source>This number is outside the allowable range for decimal literals</source>
        <target state="translated">この数値は、10 進リテラルに使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideThirtyTwoBitFloat">
        <source>This number is outside the allowable range for 32-bit floats</source>
        <target state="translated">この数値は、32 ビット浮動小数点に使用できる範囲から外れています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidNumericLiteral">
        <source>This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</source>
        <target state="translated">これは有効な数値リテラルではありません。有効な数値リテラルの例には、1、0x1、0b0001 (int)、1u (uint32)、1L (int64)、1UL (uint64)、1s (int16)、1y (sbyte)、1uy (byte)、1.0 (float)、1.0f (float32)、1.0m (decimal)、1I (BigInteger) などがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidByteLiteral">
        <source>This is not a valid byte literal</source>
        <target state="translated">これは有効なバイト リテラルではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidCharLiteral">
        <source>This is not a valid character literal</source>
        <target state="translated">これは有効な文字リテラルではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="lexThisUnicodeOnlyInStringLiterals">
        <source>This Unicode encoding is only valid in string literals</source>
        <target state="translated">この Unicode エンコーディングが有効なのはリテラル文字列内のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTokenReserved">
        <source>This token is reserved for future use</source>
        <target state="translated">このトークンは将来利用するために予約されています</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTabsNotAllowed">
        <source>TABs are not allowed in F# code unless the #indent \"off\" option is used</source>
        <target state="translated">F# コードにタブを使用するには、#indent \"off\" オプションを使用する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidLineNumber">
        <source>Invalid line number: '{0}'</source>
        <target state="translated">行番号: '{0}' は無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustBeFirst">
        <source>#if directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">#if ディレクティブは、スペース以外の最初の文字として行頭に指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseNoMatchingIf">
        <source>#else has no matching #if</source>
        <target state="translated">#else に対応する #if がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifRequiredForElse">
        <source>#endif required for #else</source>
        <target state="translated">#else には #endif が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseMustBeFirst">
        <source>#else directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">#else ディレクティブは、スペース以外の最初の文字として行頭に指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndingNoMatchingIf">
        <source>#endif has no matching #if</source>
        <target state="translated">#endif に対応する #if がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifMustBeFirst">
        <source>#endif directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">#endif ディレクティブは、スペース以外の最初の文字として行頭に指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustHaveIdent">
        <source>#if directive should be immediately followed by an identifier</source>
        <target state="translated">#if ディレクティブの直後に識別子を指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="lexWrongNestedHashEndif">
        <source>Syntax error. Wrong nested #endif, unexpected tokens before it.</source>
        <target state="translated">構文エラー。#endif の入れ子が不適切です。#endif の前に予期しないトークンがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashBangMustBeFirstInFile">
        <source>#! may only appear as the first line at the start of a file.</source>
        <target state="translated">#! は、ファイル先頭の最初の行にのみ指定できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexExpectedSingleLineComment">
        <source>Expected single line comment or end of line</source>
        <target state="translated">単一行のコメントまたは行の終わりが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNoArguments">
        <source>Infix operator member '{0}' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">挿入演算子メンバー '{0}' に引数がありません。静的メンバー (+) (x,y) = ... など、2 つの引数を持つタプルを指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonPairArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">挿入演算子メンバー '{0}' に {1} 個の初期引数があります。静的メンバー (+) (x,y) = ... など、2 つの引数を持つタプルを指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithCurriedArguments">
        <source>Infix operator member '{0}' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">挿入演算子メンバー '{0}' に余分なカリー化された引数があります。静的メンバー (+) (x,y) = ... など、2 つの引数を持つタプルを指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFSharpCoreRequiresExplicit">
        <source>All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'</source>
        <target state="translated">FSharp.Core.dll のすべてのレコード型、共用体型、および構造体型は、'StructuralComparison' または 'NoComparison' で明示的にラベル指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the type parameter '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter</source>
        <target state="translated">構造体型、レコード型、または共用体型 '{0}' に 'StructuralComparison' 属性がありますが、型パラメーター '{1}' は 'comparison' 制約を満たしていません。型パラメーターに 'comparison' 制約を追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the component type '{1}' does not satisfy the 'comparison' constraint</source>
        <target state="translated">構造体型、レコード型、または共用体型 '{0}' に 'StructuralComparison' 属性がありますが、コンポーネント型 '{1}' は 'comparison' 制約を満たしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded1">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type parameter {1} does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">型パラメーター {1} が 'comparison' 制約を満たしていないため、構造体型、レコード型、または共用体型 '{0}' は構造的に比較できません。型 '{2}' に 'NoComparison' 属性を追加して、型が比較できないことを明確にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded2">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">型 {1} が 'comparison' 制約を満たしていないため、構造体型、レコード型、または共用体型 '{0}' は構造的に比較できません。型 '{2}' に 'NoComparison' 属性を追加して、型が比較できないことを明確にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded1">
        <source>The struct, record or union type '{0}' does not support structural equality because the type parameter {1} does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">型パラメーター {1} が 'equality' 制約を満たしていないため、構造体型、レコード型、または共用体型 '{0}' は構造の等値性をサポートしません。型 '{2}' に 'NoEquality' 属性を追加して、型が構造の等値性をサポートしないことを明確にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded2">
        <source>The struct, record or union type '{0}' does not support structural equality because the type '{1}' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">型 {1} が 'equality' 制約を満たしていないため、構造体型、レコード型、または共用体型 '{0}' は構造の等値性をサポートしません。型 '{2}' に 'NoEquality' 属性を追加して、型が構造の等値性をサポートしないことを明確にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the type parameter '{1}' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter</source>
        <target state="translated">構造体型、レコード型、または共用体型 '{0}' に 'StructuralEquality' 属性がありますが、型パラメーター '{1}' は 'equality' 制約を満たしていません。型パラメーターに 'equality' 制約を追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the component type '{1}' does not satisfy the 'equality' constraint</source>
        <target state="translated">構造体型、レコード型、または共用体型 '{0}' に 'StructuralEquality' 属性がありますが、コンポーネント型 '{1}' は 'equality' 制約を満たしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
        <source>Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct.</source>
        <target state="translated">構造体のプライマリ コンストラクターの各引数には型を指定してください (たとえば、'type S(x1:int, x2: int) = ...')。これらの引数で構造体のフィールドが決定されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedValue">
        <source>The value '{0}' is unused</source>
        <target state="translated">値 '{0}' は使用されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedThisVariable">
        <source>The recursive object reference '{0}' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.</source>
        <target state="translated">再帰的オブジェクト参照 '{0}' は使用されていません。再帰的オブジェクト参照が存在すると、この型および派生型のメンバーに対するランタイムの初期化チェックが追加されます。この再帰的オブジェクト参照を削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterAtMostOneArgument">
        <source>A getter property may have at most one argument group</source>
        <target state="translated">ゲッターのプロパティに指定できる引数グループの数は 1 以下です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetterAtMostTwoArguments">
        <source>A setter property may have at most two argument groups</source>
        <target state="translated">Set アクセス操作子のプロパティに指定できる引数グループの数は 2 以下です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidProperty">
        <source>Invalid property getter or setter</source>
        <target state="translated">プロパティのゲッターまたはセッターが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIndexerPropertyRequiresAtLeastOneArgument">
        <source>An indexer property must be given at least one argument</source>
        <target state="translated">インデクサーのプロパティに 1 つ以上の引数を指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidAddressOfMutableAcrossAssemblyBoundary">
        <source>This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation</source>
        <target state="translated">この操作は、別のアセンブリに定義されている変更可能な最上位の値にアクセスしていますが、サポートされないアクセス方法です。アドレスでは値にアクセスできません。変更可能なローカル変数に式をコピーし (たとえば、'let mutable x = ...')、必要に応じて、操作の完了後に値を割り当て直してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTypars">
        <source>Type parameters must be placed directly adjacent to the type name, e.g. \"type C&lt;'T&gt;\", not     type \"C   &lt;'T&gt;\"</source>
        <target state="translated">型パラメーターと型名は隣接している必要があります。たとえば、type \"C   &lt;'T&gt;\" ではなく \"type C&lt;'T&gt;\" と指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTyargs">
        <source>Type arguments must be placed directly adjacent to the type name, e.g. \"C&lt;'T&gt;\", not \"C  &lt;'T&gt;\"</source>
        <target state="translated">型引数と型名は隣接している必要があります。たとえば、\"C  &lt;'T&gt;\" ではなく \"C&lt;'T&gt;\" と指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAtomicType">
        <source>The use of the type syntax 'int C' and 'C  &lt;int&gt;' is not permitted here. Consider adjusting this type to be written in the form 'C&lt;int&gt;'</source>
        <target state="translated">'int C' および 'C  &lt;int&gt;' という型の構文は、ここでは使用できません。'C&lt;int&gt;' という形式でこの型を記述してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespace">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the module/namespace '{2}'</source>
        <target state="translated">コンパイル ユニット '{1}' のモジュール/名前空間 '{0}' には、モジュール/名前空間 '{2}' が含まれません</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefVal">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the val '{2}'</source>
        <target state="translated">コンパイル ユニット '{1}' のモジュール/名前空間 '{0}' には、val '{2}' が含まれません</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespaceType">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the namespace, module or type '{2}'</source>
        <target state="translated">コンパイル ユニット '{1}' のモジュール/名前空間 '{0}' には、名前空間、モジュール、または型の '{2}' が含まれません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseNullAsTrueValue">
        <source>The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case</source>
        <target state="translated">'UseNullAsTrueValue' 属性フラグを使用できるのは、引数がないケース 1 つと、引数があるケース 1 つ以上を持つ共用体型のみです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterInferredByref">
        <source>The parameter '{0}' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref&lt;int&gt;'. When used, a byref parameter is implicitly dereferenced.</source>
        <target state="translated">パラメーター '{0}' は byref 型であると推論されました。byref 型のパラメーターには、明示的な型の注釈を付ける必要があります ('x1: byref&lt;int&gt;' など)。byref パラメーターは、使用時に暗黙的に逆参照されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonUniformMemberUse">
        <source>The generic member '{0}' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.</source>
        <target state="translated">このプログラム ポイントよりも前の同型でないインスタンス化で、汎用メンバー '{0}' が使用されています。このメンバーが最初に出現するようにメンバーの順序を変えることを検討してください。または、引数の型、戻り値の型、および追加のジェネリック パラメーターと制約を含む、メンバーの完全な型を明示的に指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttribArgsDiffer">
        <source>The attribute '{0}' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.</source>
        <target state="translated">属性 '{0}' が実装とシグネチャの双方に出現していますが、属性の引数が異なります。コンパイル済みコードには、シグネチャの属性のみが含まれます。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallAbstractBaseMember">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">抽象基本メンバーを呼び出すことはできません:'{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInUnmanaged">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position</source>
        <target state="translated">この位置、またはこの位置付近にある 'unmanaged' 制約を含むジェネリック コンストラクトの使用に関して、あいまいさを解決できませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="mlCompatMessage">
        <source>This construct is for ML compatibility. {0}. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'.</source>
        <target state="translated">このコンストラクターは ML 互換用です。{0}。'--mlcompatibility' または '--nowarn:62' を使用して、この警告を無効にできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldDoesNotHaveValidOffsetForStructureLayout">
        <source>The type '{0}' has been marked as having an Explicit layout, but the field '{1}' has not been marked with the 'FieldOffset' attribute</source>
        <target state="translated">型 '{0}' は明示的なレイアウトがあるとしてマークされていますが、フィールド '{1}' は 'FieldOffset' 属性でマークされていません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfacesShouldUseInheritNotInterface">
        <source>Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'</source>
        <target state="translated">他のインターフェイスによって継承されたインターフェイスは、'interface ...' ではなく 'inherit ...' を使用して宣言する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperator">
        <source>Invalid prefix operator</source>
        <target state="translated">無効なプレフィックス演算子です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperatorDefinition">
        <source>Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.</source>
        <target state="translated">無効な演算子の定義です。プレフィックス演算子の定義には、有効なプレフィックス演算子名を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCompilingExtensionIsForML">
        <source>The file extensions '.ml' and '.mli' are for ML compatibility</source>
        <target state="translated">ファイル拡張子 '.ml' および '.mli' は ML 互換用です</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIndentOffForML">
        <source>Consider using a file with extension '.ml' or '.mli' instead</source>
        <target state="translated">代わりに、ファイル拡張子に '.ml' または '.mli' を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternIdentIsNotFunctionTyped">
        <source>Active pattern '{0}' is not a function</source>
        <target state="translated">アクティブ パターン '{0}' が関数ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternChoiceHasFreeTypars">
        <source>Active pattern '{0}' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</source>
        <target state="translated">アクティブ パターン '{0}' に、入力によって決定されない型変数を含む結果の型があります。一般的な原因は、結果の型が記述されていないことです (例: 'let (|A|B|) (x:int) = A x')。この場合は、型の制約によって問題を解決できます (例: 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x')。</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldHasOffsetForSequentialLayout">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">FieldOffset 属性は、StructLayout(LayoutKind.Explicit) でマークされた型のメンバーでのみ使用できます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsMustComeAfterNonOptionalArgs">
        <source>Optional arguments must come at the end of the argument list, after any non-optional arguments</source>
        <target state="translated">オプションの引数は、オプションではないすべての引数の後で、引数リストの末尾に指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeUsage">
        <source>Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes</source>
        <target state="translated">属性 'System.Diagnostics.ConditionalAttribute' はメソッド クラスまたは属性クラスでのみ有効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOperatorDefinitionInExtrinsic">
        <source>Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.</source>
        <target state="translated">拡張メンバーでは演算子のオーバーロードを実行できません。代わりに型定義の一部として演算子を定義してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBFileNameCannotBeChangedWarning">
        <source>The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.</source>
        <target state="translated">MDB ファイルの名前は、&lt;アセンブリ ファイルの名前&gt;.mdb にする必要があります。--pdb オプションは無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBMemberMissing">
        <source>MDB generation failed. Could not find compatible member {0}</source>
        <target state="translated">MDB を生成できませんでした。互換性のあるメンバー {0} が見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingMdb">
        <source>Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly.</source>
        <target state="translated">MDB デバッグ情報を生成できません。'Mono.CompilerServices.SymbolWriter.dll' アセンブリから 'MonoSymbolWriter' 型を読み込むことができませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseNameConflictsWithGeneratedType">
        <source>The union case named '{0}' conflicts with the generated type '{1}'</source>
        <target state="translated">{0}' という名前の共用体ケースが、生成された型 '{1}' と競合します</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoReflectedDefinitionOnStructMember">
        <source>ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter</source>
        <target state="translated">ReflectedDefinitionAttribute は、構造体型でインスタンス メンバーに適用することはできません。これは、このインスタンス メンバーが暗黙的な 'this' byref パラメーターを受け取るためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportNotAllowed">
        <source>DLLImport bindings must be static members in a class or function definitions in a module</source>
        <target state="translated">DLLImport 束縛はモジュール内のクラスまたは関数定義の静的メンバーであることが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExplicitCoreLibRequiresNoFramework">
        <source>When mscorlib.dll or FSharp.Core.dll is explicitly referenced the {0} option must also be passed</source>
        <target state="translated">mscorlib.dll または FSharp.Core.dll が明示的に参照される場合は、{0} オプションも渡す必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedSigdataFile">
        <source>FSharp.Core.sigdata not found alongside FSharp.Core. File expected in {0}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">FSharp.Core と同じ場所に FSharp.Core.sigdata が見つかりません。ファイルは {0} にある必要があります。このファイルを必要としない、より新しいバージョンの FSharp.Core にアップグレードすることをご検討ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedFileAlongSideFSharpCore">
        <source>File '{0}' not found alongside FSharp.Core. File expected in {1}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">FSharp.Core と同じ場所にファイル '{0}' が見つかりません。ファイルは {1} にある必要があります。このファイルを必要としない、より新しいバージョンの FSharp.Core にアップグレードすることをご検討ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedFileNameCharacter">
        <source>Filename '{0}' contains invalid character '{1}'</source>
        <target state="translated">ファイル名 '{0}' に無効な文字 '{1}' が含まれています</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBinding">
        <source>'use!' bindings must be of the form 'use! &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">'use!' 束縛は 'use! &lt;var&gt; = &lt;expr&gt;' という形式にする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoInnerGenericsInQuotations">
        <source>Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.</source>
        <target state="translated">内部ジェネリック関数は引用符付きの式には使用できません。関数の型を特定できるまで、何らかの型の制約を追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumTypeCannotBeEnumerated">
        <source>The type '{0}' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property</source>
        <target state="translated">型 '{0}' は有効な列挙子の型ではありません。つまり、ブール値を返す 'MoveNext()' メソッドと 'Current' プロパティが含まれていません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteString">
        <source>End of file in triple-quote string begun at or before here</source>
        <target state="translated">この位置以前に始まった三重引用符文字列の途中でファイルの終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteStringInComment">
        <source>End of file in triple-quote string embedded in comment begun at or before here</source>
        <target state="translated">この位置以前に始まったコメントに埋め込まれた三重引用符文字列の途中でファイルの終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLosesMeasures">
        <source>This type test or downcast will ignore the unit-of-measure '{0}'</source>
        <target state="translated">この型テストまたはダウンキャストでは、測定単位 '{0}' が無視されます</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingTypeArgs">
        <source>Expected type argument or static argument</source>
        <target state="translated">型引数または静的引数が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingGreaterThan">
        <source>Unmatched '&lt;'. Expected closing '&gt;'</source>
        <target state="translated">'&lt;' が対応しません。対応する '&gt;' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
        <source>Unexpected quotation operator '&lt;@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '&lt;' and '@' characters.</source>
        <target state="translated">型定義に予期しない引用演算子 '&lt;@' が見つかりました。verbatim 文字列を静的引数として型プロバイダーに渡す場合は、'&lt;' と '@' の間に空白を挿入してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorParsingAsOperatorName">
        <source>Attempted to parse this as an operator name, but failed</source>
        <target state="translated">これを演算子名として解析しようとしましたが、失敗しました</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidUnicodeLiteral">
        <source>\U{0} is not a valid Unicode character escape sequence</source>
        <target state="translated">\U{0} は、無効な Unicode 文字のエスケープ シーケンスです</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoWrongType">
        <source>'{0}' must be applied to an argument of type '{1}', but has been applied to an argument of type '{2}'</source>
        <target state="translated">'{0}' は、型が '{1}' の引数に適用する必要がありますが、型が '{2}' の引数に適用されています</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoNotOptional">
        <source>'{0}' can only be applied to optional arguments</source>
        <target state="translated">'{0}' の適用対象にできるのはオプションの引数だけです</target>
        <note />
      </trans-unit>
      <trans-unit id="toolLocationHelperUnsupportedFrameworkVersion">
        <source>The specified .NET Framework version '{0}' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
        <target state="translated">指定した .NET Framework のバージョン '{0}' はサポートされていません。列挙型 Microsoft.Build.Utilities.TargetDotNetFrameworkVersion からの値を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidMagicValue">
        <source>Invalid Magic value in CLR Header</source>
        <target state="translated">CLR ヘッダーのマジック値が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignBadImageFormat">
        <source>Bad image format</source>
        <target state="translated">イメージ形式が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignPrivateKeyExpected">
        <source>Private key expected</source>
        <target state="translated">秘密キーが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignRsaKeyExpected">
        <source>RSA key expected</source>
        <target state="translated">RSA キーが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidBitLen">
        <source>Invalid bit Length</source>
        <target state="translated">ビット長が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidRSAParams">
        <source>Invalid RSAParameters structure - '{{0}}' expected</source>
        <target state="translated">RSAParameters 構造が正しくありません - '{{0}}' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidAlgId">
        <source>Invalid algId - 'Exponent' expected</source>
        <target state="translated">algId が正しくありません - '指数' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidSignatureSize">
        <source>Invalid signature size</source>
        <target state="translated">シグネチャのサイズが正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignNoSignatureDirectory">
        <source>No signature directory</source>
        <target state="translated">シグネチャのディレクトリがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidPKBlob">
        <source>Invalid Public Key blob</source>
        <target state="translated">公開キー BLOB が正しくありません</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTooManyErrors">
        <source>Exiting - too many errors</source>
        <target state="translated">終了しています - エラーが多すぎます</target>
        <note />
      </trans-unit>
      <trans-unit id="docfileNoXmlSuffix">
        <source>The documentation file has no .xml suffix</source>
        <target state="translated">ドキュメント ファイルに .xml サフィックスがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="fscNoImplementationFiles">
        <source>No implementation files specified</source>
        <target state="translated">実装ファイルが指定されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="fscBadAssemblyVersion">
        <source>The attribute {0} specified version '{1}', but this value is invalid and has been ignored</source>
        <target state="translated">{0} がバージョン '{1}' を指定しましたが、この値は無効なため無視されました</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTwoResourceManifests">
        <source>Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used.</source>
        <target state="translated">競合するオプションが指定されました: 'win32manifest' および 'win32res'。これらのうち、1 つのみを使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking">
        <source>The code in assembly '{0}' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">アセンブリ '{0}' 内のコードで引用符リテラルが使用されています。静的リンクでは、F# 4.0 以上ですべてのアセンブリがコンパイルされる場合を除き、引用符リテラルを使用するコンポーネントがインクルードされない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking0">
        <source>Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">このアセンブリ内のコードでは引用符リテラルが使用されています。静的リンクでは、F# 4.0 以上ですべてのアセンブリがコンパイルされる場合を除き、引用符リテラルを使用するコンポーネントがインクルードされない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoEXE">
        <source>Static linking may not include a .EXE</source>
        <target state="translated">静的リンクでは、.EXE がインクルードされない可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoMixedDLL">
        <source>Static linking may not include a mixed managed/unmanaged DLL</source>
        <target state="translated">静的リンクでは、混合マネージ/アンマネージ DLL がインクルードされない可能性があります</target>
        <note />
      </trans-unit>
      <trans-unit id="fscIgnoringMixedWhenLinking">
        <source>Ignoring mixed managed/unmanaged assembly '{0}' during static linking</source>
        <target state="translated">静的リンク中に混合マネージ/アンマネージ アセンブリ '{0}' を無視しています</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssumeStaticLinkContainsNoDependencies">
        <source>Assembly '{0}' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.</source>
        <target state="translated">アセンブリ '{0}' は推移的に参照され、このアセンブリを自動的に解決できませんでした。静的リンクでは、この DLL に F# ライブラリ上またはその他の静的にリンクされた DLL 上の依存関係がないと見なされます。この DLL に明示的な参照を追加することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyNotFoundInDependencySet">
        <source>Assembly '{0}' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.</source>
        <target state="translated">アセンブリ '{0}' は、対象のバイナリの依存関係セットから見つかりませんでした。静的にリンクされたルートは、DLL または EXE 拡張子なしでアセンブリ名を使用して指定する必要があります。このアセンブリが明示的に参照された場合、アセンブリは生成されたバイナリで実際に要求されていない可能性があり、この場合には静的にリンクしないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileCouldNotBeOpened">
        <source>The key file '{0}' could not be opened</source>
        <target state="translated">キー ファイル '{0}' を開けませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="fscProblemWritingBinary">
        <source>A problem occurred writing the binary '{0}': {1}</source>
        <target state="translated">バイナリ '{0}' の書き込み中に問題が発生しました: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyVersionAttributeIgnored">
        <source>The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option</source>
        <target state="translated">'AssemblyVersionAttribute' は、バージョンがコマンド ライン オプションを使用して指定されたため無視されました</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyCultureAttributeError">
        <source>Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'</source>
        <target state="translated">'System.Reflection.AssemblyCultureAttribute' 属性の生成中にエラーが発生しました -- '実行可能ファイルをサテライト アセンブリにすることはできません。カルチャは常に空である必要があります'</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDelaySignWarning">
        <source>Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module</source>
        <target state="translated">ソース ファイルまたは追加されたモジュールに指定された 'System.Reflection.AssemblyDelaySignAttribute' 属性は、'--delaysign' オプションでオーバーライドされます</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileWarning">
        <source>Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module</source>
        <target state="translated">ソース ファイルまたは追加されたモジュールに指定された 'System.Reflection.AssemblyKeyFileAttribute' 属性は、'--keyfile' オプションでオーバーライドされます</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyNameWarning">
        <source>Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module</source>
        <target state="translated">ソース ファイルまたは追加されたモジュールに指定された 'System.Reflection.AssemblyNameAttribute' 属性は、'--keycontainer' オプションでオーバーライドされます</target>
        <note />
      </trans-unit>
      <trans-unit id="fscReferenceOnCommandLine">
        <source>The assembly '{0}' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'.</source>
        <target state="translated">アセンブリ '{0}' はコマンド ラインに一覧表示されます。アセンブリは '-r' などのコマンド ライン フラグを使用して参照する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="fscRemotingError">
        <source>The resident compilation service was not used because a problem occured in communicating with the server.</source>
        <target state="translated">サーバーとの通信で問題が発生したため、常駐コンパイル サービスが使用されませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="pathIsInvalid">
        <source>Problem with filename '{0}': Illegal characters in path.</source>
        <target state="translated">ファイル名 '{0}' に問題があります: パスに無効な文字が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="fscResxSourceFileDeprecated">
        <source>Passing a .resx file ({0}) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.</source>
        <target state="translated">.resx ファイル ({0}) をソース ファイルとしてコンパイラに渡す処理は使用できなくなりました。resgen.exe を使用して、.resx ファイルを .resources ファイルに変換し、--resource オプションで渡してください。MSBuild を使用する場合は、.fsproj プロジェクト ファイル内の &lt;EmbeddedResource&gt; 項目を使用して、この変換を実行できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoProfileMismatches">
        <source>Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).</source>
        <target state="translated">静的リンクは、System.Runtime (.NET Core またはポータブル アセンブリなど) を参照するアセンブリを生成する場合、mscorlib (.NET Framework アセンブリなど) を参照するアセンブリには使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyWildcardAndDeterminism">
        <source>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</source>
        <target state="translated">{0} によりバージョン '{1}' が指定されましたが、この値はワイルドカードです。決定論的なビルドを要求しているため、これらの指定は矛盾しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDeterministicDebugRequiresPortablePdb">
        <source>Determinstic builds only support portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">決定論的ビルドはポータブル PDB のみをサポートします (--debug:portable または --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInNamespaceName">
        <source>Character '{0}' is not allowed in provided namespace name '{1}'</source>
        <target state="translated">指定された名前空間名 '{1}' には、文字 '{0}' を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullOrEmptyMemberName">
        <source>The provided type '{0}' returned a member with a null or empty member name</source>
        <target state="translated">指定された型 '{0}' が返したメンバーのメンバー名が null または空です</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMember">
        <source>The provided type '{0}' returned a null member</source>
        <target state="translated">指定された型 '{0}' が null のメンバーを返しました</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringType">
        <source>The provided type '{0}' member info '{1}' has null declaring type</source>
        <target state="translated">指定された型 '{0}' のメンバー情報 '{1}' に null を宣言する型が含まれています</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringTypeDifferentFromProvidedType">
        <source>The provided type '{0}' has member '{1}' which has declaring type '{2}'. Expected declaring type to be the same as provided type.</source>
        <target state="translated">指定された型 '{0}' のメンバー '{1}' に、宣言する型 '{2}' が含まれています。宣言する型は、指定された型と同じである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="etHostingAssemblyFoundWithoutHosts">
        <source>Referenced assembly '{0}' has assembly level attribute '{1}' but no public type provider classes were found</source>
        <target state="translated">参照アセンブリ '{0}' にアセンブリ レベル属性 '{1}' が含まれていますが、パブリックな型プロバイダー クラスが見つかりません</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceOfTypeNotAllowed">
        <source>Type '{0}' from type provider '{1}' has an empty namespace. Use 'null' for the global namespace.</source>
        <target state="translated">型プロバイダー '{1}' からの型 '{0}' に空の名前空間が含まれています。グローバル名前空間を表す 'null' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceNotAllowed">
        <source>Empty namespace found from the type provider '{0}'. Use 'null' for the global namespace.</source>
        <target state="translated">型プロバイダー '{0}' に空の名前空間が見つかりました。グローバル名前空間を表す 'null' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeGeneric">
        <source>Provided type '{0}' has 'IsGenericType' as true, but generic types are not supported.</source>
        <target state="translated">指定された型 '{0}' で 'IsGenericType' が true になっていますが、ジェネリック型はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeAnArray">
        <source>Provided type '{0}' has 'IsArray' as true, but array types are not supported.</source>
        <target state="translated">指定された型 '{0}' で 'IsArray' が true になっていますが、配列型はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="etMethodHasRequirements">
        <source>Invalid member '{0}' on provided type '{1}'. Provided type members must be public, and not be generic, virtual, or abstract.</source>
        <target state="translated">指定された型 '{1}' に無効なメンバー '{0}' が含まれています。指定された型のメンバーはパブリックである必要があり、汎用メンバー、仮想メンバー、および抽象メンバーは無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedMemberKind">
        <source>Invalid member '{0}' on provided type '{1}'. Only properties, methods and constructors are allowed</source>
        <target state="translated">指定された型 '{1}' のメンバー '{0}' が無効です。許容されるのは、プロパティ、メソッド、およびコンストラクターのみです</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanReadButHasNoGetter">
        <source>Property '{0}' on provided type '{1}' has CanRead=true but there was no value from GetGetMethod()</source>
        <target state="translated">指定された型 '{1}' のプロパティ '{0}' で CanRead=true となっていますが、GetGetMethod() からの値が存在しません</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasGetterButNoCanRead">
        <source>Property '{0}' on provided type '{1}' has CanRead=false but GetGetMethod() returned a method</source>
        <target state="translated">指定された型 '{1}' のプロパティ '{0}' で CanRead=false となっていますが、GetGetMethod() がメソッドを返しました</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanWriteButHasNoSetter">
        <source>Property '{0}' on provided type '{1}' has CanWrite=true but there was no value from GetSetMethod()</source>
        <target state="translated">指定された型 '{1}' のプロパティ '{0}' で CanWrite=true となっていますが、GetSetMethod() からの値が存在しません</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasSetterButNoCanWrite">
        <source>Property '{0}' on provided type '{1}' has CanWrite=false but GetSetMethod() returned a method</source>
        <target state="translated">指定された型 '{1}' のプロパティ '{0}' で CanWrite=false となっていますが、GetSetMethod() がメソッドを返しました</target>
        <note />
      </trans-unit>
      <trans-unit id="etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
        <source>One or more errors seen during provided type setup</source>
        <target state="translated">指定された型のセットアップ中にエラーが発生しました</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedTypeMember">
        <source>Unexpected exception from provided type '{0}' member '{1}': {2}</source>
        <target state="translated">指定された型 '{0}' のメンバー '{1}' で予期しない例外が発生しました: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedConstantType">
        <source>Unsupported constant type '{0}'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal.</source>
        <target state="translated">サポートされない定数型 '{0}'。型プロバイダーで提供される引用に含められるのは単純定数のみです。型プロバイダーの実装は、指定された引用リテラル外部で宣言された値を移動して、引用リテラル内部の 'let' バインドにすることによって調整することが必要な場合があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedProvidedExpression">
        <source>Unsupported expression '{0}' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.</source>
        <target state="translated">型プロバイダーから、サポートされない式 '{0}' が指定されました。この型プロバイダーの作成者である場合は、別の指定された式を指定するように調整することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedName">
        <source>Expected provided type named '{0}' but provided type has 'Name' with value '{1}'</source>
        <target state="translated">指定された型の名前が '{0}' である必要がありましたが、指定された型の名前は 'Name'、値は '{1}' でした</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoAdd">
        <source>Event '{0}' on provided type '{1}' has no value from GetAddMethod()</source>
        <target state="translated">指定された型 '{1}' におけるイベント '{0}' に、GetAddMethod() の値が含まれていません</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoRemove">
        <source>Event '{0}' on provided type '{1}' has no value from GetRemoveMethod()</source>
        <target state="translated">指定された型 '{1}' におけるイベント '{0}' に、GetRemoveMethod() の値が含まれていません</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssembly">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded or doesn't exist. {2}</source>
        <target state="translated">アセンブリ属性 '{0}' はデザイナー アセンブリ '{1}' を参照していますが、このアセンブリは読み込めないか、存在していません。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderDoesNotHaveValidConstructor">
        <source>The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected.</source>
        <target state="translated">型プロバイダーに有効なコンストラクターが含まれていません。引数を受け取らないコンストラクター、または 'TypeProviderConfig' 型の引数を 1 つ受け取るコンストラクターが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderError">
        <source>The type provider '{0}' reported an error: {1}</source>
        <target state="translated">型プロバイダー '{0}' がエラーを報告しました: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectParameterExpression">
        <source>The type provider '{0}' used an invalid parameter in the ParameterExpression: {1}</source>
        <target state="translated">型プロバイダー '{0}' の ParameterExpression 内で無効なパラメーターが使用されました: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedMethod">
        <source>The type provider '{0}' provided a method with a name '{1}' and metadata token '{2}', which is not reported among its methods of its declaring type '{3}'</source>
        <target state="translated">型プロバイダー '{0}' で、'{1}' という名前のメソッドとメタデータ トークン '{2}' が指定されましたが、これは宣言型 '{3}' のメソッドの中で報告されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedConstructor">
        <source>The type provider '{0}' provided a constructor which is not reported among the constructors of its declaring type '{1}'</source>
        <target state="translated">型プロバイダー '{0}' で指定されたコンストラクターは、宣言型 '{1}' のコンストラクターの中で報告されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="etDirectReferenceToGeneratedTypeNotAllowed">
        <source>A direct reference to the generated type '{0}' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = &lt;path&gt;'. This indicates that a type provider adds generated types to your assembly.</source>
        <target state="translated">生成された型 '{0}' への直接参照は許可されていません。型定義を使用してください (たとえば、'type TypeAlias = &lt;path&gt;')。この例では、生成された型が型プロバイダーによってアセンブリに追加されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedPath">
        <source>Expected provided type with path '{0}' but provided type has path '{1}'</source>
        <target state="translated">指定された型のパスが '{0}' である必要がありましたが、指定された型のパスは '{1}' でした</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedNullFromProvidedTypeMember">
        <source>Unexpected 'null' return value from provided type '{0}' member '{1}'</source>
        <target state="translated">指定された型 '{0}' のメンバー '{1}' から予期しない 'null' 戻り値が返されました</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedMemberMember">
        <source>Unexpected exception from member '{0}' of provided type '{1}' member '{2}': {3}</source>
        <target state="translated">指定された型 '{1}' のメンバー '{2}' のメンバー '{0}' で予期しない例外が発生しました: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
        <source>Nested provided types do not take static arguments or generic parameters</source>
        <target state="translated">指定された型が入れ子の場合、静的引数もジェネリック パラメーターも受け取りません</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidStaticArgument">
        <source>Invalid static argument to provided type. Expected an argument of kind '{0}'.</source>
        <target state="translated">指定された型に対して無効な静的引数が渡されました。'{0}' という種類の引数を渡す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToType">
        <source>An error occured applying the static arguments to a provided type</source>
        <target state="translated">指定された型に静的引数を適用する際にエラーが発生しました</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnknownStaticArgumentKind">
        <source>Unknown static argument kind '{0}' when resolving a reference to a provided type or method '{1}'</source>
        <target state="translated">指定された型またはメソッド '{1}' への参照を解決する際に、不明な静的引数の種類 '{0}' が検出されました</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidNamespaceForProvidedType">
        <source>invalid namespace for provided type</source>
        <target state="translated">指定された型の名前空間が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidFullNameForProvidedType">
        <source>invalid full name for provided type</source>
        <target state="translated">指定された型の完全名が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderReturnedNull">
        <source>The type provider returned 'null', which is not a valid return value from '{0}'</source>
        <target state="translated">型プロバイダーが 'null' を返しましたが、これは '{0}' からの戻り値としては無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="etTypeProviderConstructorException">
        <source>The type provider constructor has thrown an exception: {0}</source>
        <target state="translated">型プロバイダー コンストラクターが例外をスローしました: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullProvidedExpression">
        <source>Type provider '{0}' returned null from GetInvokerExpression.</source>
        <target state="translated">型プロバイダー '{0}' が、GetInvokerExpression から null を返しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedTypeHadWrongName">
        <source>The type provider '{0}' returned an invalid type from 'ApplyStaticArguments'. A type with name '{1}' was expected, but a type with name '{2}' was returned.</source>
        <target state="translated">型プロバイダー '{0}' が 'ApplyStaticArguments' から無効な型を返しました。'{1}' という名前の型が返される必要がありましたが、返されたのは '{2}' という名前の型でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedMethodHadWrongName">
        <source>The type provider '{0}' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '{1}' was expected, but a method with name '{2}' was returned.</source>
        <target state="translated">型プロバイダー '{0}' が、'ApplyStaticArgumentsForMethod' から無効なメソッドを返しました。名前が '{1}' のメソッドが必要ですが、名前が '{2}' のメソッドが返されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLossy">
        <source>This type test or downcast will erase the provided type '{0}' to the type '{1}'</source>
        <target state="translated">この型テストまたはダウンキャストによって、指定された型 '{0}' が型 '{1}' に消去されます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCastErased">
        <source>This downcast will erase the provided type '{0}' to the type '{1}'.</source>
        <target state="translated">このダウンキャストによって、指定された型 '{0}' が型 '{1}' に消去されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestErased">
        <source>This type test with a provided type '{0}' is not allowed because this provided type will be erased to '{1}' at runtime.</source>
        <target state="translated">指定された型 '{0}' は実行時に '{1}' に消去されるため、この型を使用して型テストを実行することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromErasedType">
        <source>Cannot inherit from erased provided type</source>
        <target state="translated">指定された型が消去されている場合、継承することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidTypeProviderAssemblyName">
        <source>Assembly '{0}' hase TypeProviderAssembly attribute with invalid value '{1}'. The value should be a valid assembly name</source>
        <target state="translated">アセンブリ '{0}' の TypeProviderAssembly 属性に、無効な値 '{1}' が含まれています。この値は有効なアセンブリ名であることが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameCtor">
        <source>Invalid member name. Members may not have name '.ctor' or '.cctor'</source>
        <target state="translated">メンバー名が無効です。メンバーに '.ctor' または '.cctor' という名前を付けることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInferredGenericTypeGivesRiseToInconsistency">
        <source>The function or member '{0}' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '{1}'.</source>
        <target state="translated">現在使用されている関数またはメンバー '{0}' では、推論された型の一貫性を確保するために、さらに型の注釈が必要です。推論されたシグネチャは '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentCount">
        <source>The number of type arguments did not match: '{0}' given, '{1}' expected. This may be related to a previously reported error.</source>
        <target state="translated">型引数の数が一致しません: 指定されているのは '{0}' 個ですが、'{1}' 個にする必要があります。このエラーは、前に報告されたエラーに関係する場合があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotOverrideSealedMethod">
        <source>Cannot override inherited member '{0}' because it is sealed</source>
        <target state="translated">継承されたメンバー '{0}' はシールドであるため、オーバーライドできません</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderErrorWithContext">
        <source>The type provider '{0}' reported an error in the context of provided type '{1}', member '{2}'. The error: {3}</source>
        <target state="translated">型プロバイダー '{0}' が、指定された型 '{1}'、メンバー '{2}' のコンテキストでエラーを報告しました。エラー: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNameException">
        <source>An exception occurred when accessing the '{0}' of a provided type: {1}</source>
        <target state="translated">指定された型の '{0}' にアクセスする際に例外が発生しました: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNullOrEmptyName">
        <source>The '{0}' of a provided type was null or empty.</source>
        <target state="translated">指定された型の '{0}' が null または空でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInTypeName">
        <source>Character '{0}' is not allowed in provided type name '{1}'</source>
        <target state="translated">指定された型名 '{1}' には、文字 '{0}' を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcJoinMustUseSimplePattern">
        <source>In queries, '{0}' must use a simple pattern</source>
        <target state="translated">クエリ内では、'{0}' は単純なパターンを使用する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMissingCustomOperation">
        <source>A custom query operation for '{0}' is required but not specified</source>
        <target state="translated">'{0}' に対するカスタム クエリ操作が必要ですが、指定されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="etBadUnnamedStaticArgs">
        <source>Named static arguments must come after all unnamed static arguments</source>
        <target state="translated">名前付きの静的引数は、名前のない静的引数の後に置く必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterRequiresAValue">
        <source>The static parameter '{0}' of the provided type or method '{1}' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '{2}&lt;{3}=...&gt;'.</source>
        <target state="translated">指定された型またはメソッド '{1}' の静的パラメーター '{0}' には値が必要です。型プロバイダーの静的パラメーターは、名前付き引数 (例: '{2}&lt;{3}=...&gt;') を使用してオプションで指定できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="etNoStaticParameterWithName">
        <source>No static parameter exists with name '{0}'</source>
        <target state="translated">'{0}' という名前の静的パラメーターがありません</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterAlreadyHasValue">
        <source>The static parameter '{0}' has already been given a value</source>
        <target state="translated">静的パラメーター '{0}' には既に値が指定されています</target>
        <note />
      </trans-unit>
      <trans-unit id="etMultipleStaticParameterWithName">
        <source>Multiple static parameters exist with name '{0}'</source>
        <target state="translated">'{0}' という名前の静的パラメーターが複数存在しています</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
        <source>A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression</source>
        <target state="translated">このコンピュテーション式の別の部分に値のない束縛または再帰的な 'let' 束縛が含まれている場合、カスタム操作を使用することができません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedHere">
        <source>A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression</source>
        <target state="translated">このコンピュテーション式に 'use'、'try/with'、'try/finally'、'if/then/else'、または 'match' 演算子が含まれている場合、カスタム操作を使用することができません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeOverloaded">
        <source>The custom operation '{0}' refers to a method which is overloaded. The implementations of custom operations may not be overloaded.</source>
        <target state="translated">カスタム操作 '{0}' が、オーバーロードされたメソッドを参照しています。カスタム操作の実装をオーバーロードすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIfThenElseMayNotBeUsedWithinQueries">
        <source>An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.</source>
        <target state="translated">if/then/else 式はクエリ内で使用できません。if/then 式を使用するか、シーケンス式を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
        <source>Invalid argument to 'methodhandleof' during codegen</source>
        <target state="translated">codegen で 'methodhandleof' に無効な引数が渡されました</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceMissingArgument">
        <source>A reference to a provided type was missing a value for the static parameter '{0}'. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">指定された型に対する参照に、静的パラメーター '{0}' に対応する値がありません。1 つ以上の参照アセンブリを再コンパイルする必要がある場合があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceInvalidText">
        <source>A reference to a provided type had an invalid value '{0}' for a static parameter. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">指定された型に対する参照に、静的パラメーターでは無効な値 '{0}' が含まれていました。1 つ以上の参照アセンブリを再コンパイルする必要がある場合があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly">
        <source>'{0}' is not used correctly. This is a custom operation in this query or computation expression.</source>
        <target state="translated">'{0}' の使用方法が正しくありません。これは、このクエリまたはコンピュテーション式のカスタム操作です。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly2">
        <source>'{0}' is not used correctly. Usage: {1}. This is a custom operation in this query or computation expression.</source>
        <target state="translated">'{0}' の使用方法が正しくありません。使い方: {1}。これは、このクエリまたはコンピュテーション式のカスタム操作です。</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeJoin">
        <source>{0} var in collection {1} (outerKey = innerKey). Note that parentheses are required after '{2}'</source>
        <target state="translated">{0} var in collection {1} (outerKey = innerKey)。'{2}' の後ろにはかっこが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeGroupJoin">
        <source>{0} var in collection {1} (outerKey = innerKey) into group. Note that parentheses are required after '{2}'</source>
        <target state="translated">{0} var in collection {1} (outerKey = innerKey) into group。'{2}' の後ろにかっこが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeZip">
        <source>{0} var in collection</source>
        <target state="translated">{0} var in collection</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresVariable">
        <source>'{0}' must be followed by a variable name. Usage: {1}.</source>
        <target state="translated">'{0}' の後には変数名が必要です。使い方: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorIncorrectSyntax">
        <source>Incorrect syntax for '{0}'. Usage: {1}.</source>
        <target state="translated">{0}' の構文が正しくありません。使い方: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresBody">
        <source>'{0}' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... {1} ...</source>
        <target state="translated">'{0}' は 'for' 選択句の後に配置し、その後に残りのクエリを配置する必要があります。構文: ... {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationHasIncorrectArgCount">
        <source>'{0}' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected {1} argument(s), but given {2}.</source>
        <target state="translated">'{0}' で使用されている引数の数が正しくありません。これはこのクエリのカスタム操作であるか、コンピュテーション式です。適正な引数の数は {1} 個ですが、渡されたのは {2} 個でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterToken">
        <source>Expected an expression after this point</source>
        <target state="translated">この位置より後に式を置く必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedTypeAfterToken">
        <source>Expected a type after this point</source>
        <target state="translated">この位置より後に型を置く必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLBrackLess">
        <source>Unmatched '[&lt;'. Expected closing '&gt;]'</source>
        <target state="translated">'[&lt;' が対応しません。対応する '&gt;]' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileMatch">
        <source>Unexpected end of input in 'match' expression. Expected 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</source>
        <target state="translated">'match' 式に予期しない入力の終わりが見つかりました。'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...' という形式を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTry">
        <source>Unexpected end of input in 'try' expression. Expected 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;'.</source>
        <target state="translated">'try' 式に予期しない入力の終わりが見つかりました。'try &lt;expr&gt; with &lt;rules&gt;' または 'try &lt;expr&gt; finally &lt;expr&gt;' という形式を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWhile">
        <source>Unexpected end of input in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'while' 式に予期しない入力の終わり見つかりました。'while &lt;expr&gt; do &lt;expr&gt;' という形式を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFor">
        <source>Unexpected end of input in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'for' 式の中に予期しない入力の終わりが見つかりました。'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;' という形式を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWith">
        <source>Unexpected end of input in 'match' or 'try' expression</source>
        <target state="translated">'match' 式または 'try' 式に予期しない入力の終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileThen">
        <source>Unexpected end of input in 'then' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">条件式の 'then' 分岐に予期しない入力の終わりが見つかりました。'if &lt;expr&gt; then &lt;expr&gt;' または 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' という形式を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileElse">
        <source>Unexpected end of input in 'else' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">条件式の 'else' 分岐で予期しない入力の終わりが見つかりました。'if &lt;expr&gt; then &lt;expr&gt;' または 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' という形式を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFunBody">
        <source>Unexpected end of input in body of lambda expression. Expected 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</source>
        <target state="translated">ラムダ式の本体に予期しない入力の終わりが見つかりました。'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;' という形式を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeArgs">
        <source>Unexpected end of input in type arguments</source>
        <target state="translated">型引数に予期しない入力の終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeSignature">
        <source>Unexpected end of input in type signature</source>
        <target state="translated">型シグネチャに予期しない入力の終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeDefinition">
        <source>Unexpected end of input in type definition</source>
        <target state="translated">型定義に予期しない入力の終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileObjectMembers">
        <source>Unexpected end of input in object members</source>
        <target state="translated">オブジェクト メンバーに予期しない入力の終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileDefinition">
        <source>Unexpected end of input in value, function or member definition</source>
        <target state="translated">値、関数、またはメンバーの定義内で予期しない入力の終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileExpression">
        <source>Unexpected end of input in expression</source>
        <target state="translated">式の中に予期しない入力の終わりが見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedNameAfterToken">
        <source>Unexpected end of type. Expected a name after this point.</source>
        <target state="translated">予期しない型の末尾です。この位置より後に名前を置く必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLet">
        <source>Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.</source>
        <target state="translated">値または関数定義が不完全です。これが式の中にある場合、式の本体を 'let' キーワードと同じ列にインデントする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLetBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword.</source>
        <target state="translated">値の定義が不完全です。これが式の中にある場合、式の本体を 'let!' キーワードと同じ列にインデントする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUseBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword.</source>
        <target state="translated">値の定義が不完全です。これが式の中にある場合、式の本体を 'use!' キーワードと同じ列にインデントする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUse">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword.</source>
        <target state="translated">値の定義が不完全です。これが式の中にある場合、式の本体を 'use' キーワードと同じ列にインデントする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsWhileDoExpected">
        <source>Missing 'do' in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'while' 式に 'do' がありません。'while &lt;expr&gt; do &lt;expr&gt;' という形式を使用する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsForDoExpected">
        <source>Missing 'do' in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'for' 式の中に 'do' がありません。'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;' という形式にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRelationInJoin">
        <source>Invalid join relation in '{0}'. Expected 'expr &lt;op&gt; expr', where &lt;op&gt; is =, =?, ?= or ?=?.</source>
        <target state="translated">'{0}' に無効な結合関係が含まれています。'expr &lt;op&gt; expr' という形式を使用する必要があります (&lt;op&gt; は =、=?、?=、または ?=? です)。</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCallsWord">
        <source>Calls</source>
        <target state="translated">呼び出し</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidNumberOfGenericArguments">
        <source>Invalid number of generic arguments to type '{0}' in provided type. Expected '{1}' arguments, given '{2}'.</source>
        <target state="translated">指定された型で、型 '{0}' に対して渡された汎用引数の数が無効です。適正な引数の数は '{1}' 個ですが、渡されたのは '{2}' 個でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument1">
        <source>Invalid value '{0}' for unit-of-measure parameter '{1}'</source>
        <target state="translated">測定単位のパラメーター '{1}' の値 '{0}' は無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument2">
        <source>Invalid value unit-of-measure parameter '{0}'</source>
        <target state="translated">測定単位のパラメーター '{0}' の値が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyNeedsCanWriteOrCanRead">
        <source>Property '{0}' on provided type '{1}' is neither readable nor writable as it has CanRead=false and CanWrite=false</source>
        <target state="translated">指定された型 '{1}' のプロパティ '{0}' で CanRead=false および CanWrite=false とされているため、読み取りも書き込みもできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIntoNeedsRestOfQuery">
        <source>A use of 'into' must be followed by the remainder of the computation</source>
        <target state="translated">'into' を使用する場合、その後に残りの計算を配置する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorDoesntAcceptInto">
        <source>The operator '{0}' does not accept the use of 'into'</source>
        <target state="translated">演算子 '{0}' では、'into' を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationInvalid">
        <source>The definition of the custom operator '{0}' does not use a valid combination of attribute flags</source>
        <target state="translated">カスタム演算子 '{0}' の定義で使用されている属性フラグの組み合わせが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisTypeMayNotHaveACLIMutableAttribute">
        <source>This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute.</source>
        <target state="translated">この型定義には 'CLIMutable' 属性を含めることができません。この属性を含めることができるのはレコード型のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAutoPropertyRequiresImplicitConstructionSequence">
        <source>'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">'member val' 定義は、プライマリ コンストラクターを含む型でのみ使用できます。型定義に引数を追加してください (たとえば、'type X(args) = ...')。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSet">
        <source>Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">プロパティの定義は変更可能として宣言することはできません。このプロパティが設定できることを示すには、'member val PropertyName = expr with get,set' を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
        <source>To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">このプロパティを設定できることを示すには、'member val PropertyName = expr with get,set' を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefsOfByrefs">
        <source>Type '{0}' is illegal because in byref&lt;T&gt;, T cannot contain byref types.</source>
        <target state="translated">byref&lt;T&gt; では T に byref 型を含めることができないため、型 '{0}' は正しくありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tastopsMaxArrayThirtyTwo">
        <source>F# supports array ranks between 1 and 32. The value {0} is not allowed.</source>
        <target state="translated">F# は、1 から 32 の配列ランクをサポートしています。値 {0} は使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoIntegerForLoopInQuery">
        <source>In queries, use the form 'for x in n .. m do ...' for ranging over integers</source>
        <target state="translated">クエリで整数の範囲を扱う場合は、'for x in n .. m do ...' という形式を使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoWhileInQuery">
        <source>'while' expressions may not be used in queries</source>
        <target state="translated">'while' 式は、クエリ内で使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoTryFinallyInQuery">
        <source>'try/finally' expressions may not be used in queries</source>
        <target state="translated">'try/finally' 式は、クエリ内で使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseMayNotBeUsedInQueries">
        <source>'use' expressions may not be used in queries</source>
        <target state="translated">'use' 式はクエリ内で使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindMayNotBeUsedInQueries">
        <source>'let!', 'use!' and 'do!' expressions may not be used in queries</source>
        <target state="translated">クエリで 'let!'、'use!'、および 'do!' 式を使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnMayNotBeUsedInQueries">
        <source>'return' and 'return!' may not be used in queries</source>
        <target state="translated">'return' および 'return!' は、クエリ内で使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryOperator">
        <source>This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type.</source>
        <target state="translated">これは既知のクエリ演算子ではありません。クエリ演算子は、'select'、'where'、'sortBy'、'thenBy'、'groupBy'、'groupValBy'、'join'、'groupJoin'、'sumBy'、および 'averageBy' などの識別子であり、'QueryBuilder' 型で対応するメソッドを使用して定義されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryWithMayNotBeUsedInQueries">
        <source>'try/with' expressions may not be used in queries</source>
        <target state="translated">'try/with' 式はクエリ内で使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonSimpleLetBindingInQuery">
        <source>This 'let' definition may not be used in a query. Only simple value definitions may be used in queries.</source>
        <target state="translated">この 'let' 定義は、クエリ内では使用できません。クエリで使用できるのは単純な値の定義のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="etTooManyStaticParameters">
        <source>Too many static parameters. Expected at most {0} parameters, but got {1} unnamed and {2} named parameters.</source>
        <target state="translated">静的パラメーターが多すぎます。静的パラメーターの最大数は {0} 個ですが、名前のないパラメーターが {1} 個、名前付きパラメーターが {2} 個あります。</target>
        <note />
      </trans-unit>
      <trans-unit id="infosInvalidProvidedLiteralValue">
        <source>Invalid provided literal value '{0}'</source>
        <target state="translated">指定されたリテラル値 '{0}' が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidPlatformTarget">
        <source>The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead.</source>
        <target state="translated">'anycpu32bitpreferred' プラットフォームは、EXE ターゲットでのみ使用できます。代わりに、'anycpu' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisValueMayNotBeInlined">
        <source>This member, function or value declaration may not be declared 'inline'</source>
        <target state="translated">このメンバー、関数、または値の宣言を 'inline' で宣言することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="etErasedTypeUsedInGeneration">
        <source>The provider '{0}' returned a non-generated type '{1}' in the context of a set of generated types. Consider adjusting the type provider to only return generated types.</source>
        <target state="translated">プロバイダー '{0}' は、一連の生成された型のコンテキスト内で、生成されていない型 '{1}' を返しました。型プロバイダーが生成された型のみを返すように調整することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryBinaryOperator">
        <source>Arguments to query operators may require parentheses, e.g. 'where (x &gt; y)' or 'groupBy (x.Length / 10)'</source>
        <target state="translated">クエリ演算子に対する引数には、たとえば 'where (x &gt; y)' や 'groupBy (x.Length / 10)' のように、かっこが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoSetOfHole">
        <source>A quotation may not involve an assignment to or taking the address of a captured local variable</source>
        <target state="translated">キャプチャされたローカル変数のアドレスの割り当てまたは取得は引用符で囲まれない場合があります</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloads1">
        <source>+ 1 overload</source>
        <target state="translated">+ 1 オーバーロード</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloadsN">
        <source>+ {0} overloads</source>
        <target state="translated">+ {0} オーバーロード</target>
        <note />
      </trans-unit>
      <trans-unit id="erasedTo">
        <source>Erased to</source>
        <target state="translated">消去先</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnfinishedExpression">
        <source>Unexpected token '{0}' or incomplete expression</source>
        <target state="translated">予期しないトークン '{0}' または不完全な式です</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributeOnIncompleteCode">
        <source>Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.</source>
        <target state="translated">この属性を対象にしたコードが見つかりません。属性の後のコードが完全ではない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeNameCannotBeEmpty">
        <source>Type name cannot be empty.</source>
        <target state="translated">型名を入力してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemReadingAssembly">
        <source>Problem reading assembly '{0}': {1}</source>
        <target state="translated">アセンブリ '{0}' を読み取る際に問題が発生しました: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTPFieldMustBeLiteral">
        <source>Invalid provided field. Provided fields of erased provided types must be literals.</source>
        <target state="translated">指定されたフィールドが無効です。指定された型が消去されている場合、指定されたフィールドはリテラルである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="loadingDescription">
        <source>(loading description...)</source>
        <target state="translated">(説明を読み込んでいます...)</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionUnavailable">
        <source>(description unavailable...)</source>
        <target state="translated">(説明はありません...)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTyparMultipleClassConstraints">
        <source>A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.</source>
        <target state="translated">型変数が複数の異なるクラス型によって制約されています。型変数が持つことのできるクラス制約は 1 つだけです。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMatchMayNotBeUsedWithQuery">
        <source>'match' expressions may not be used in queries</source>
        <target state="translated">'match' 式はクエリ内で使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonTripleArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 3 arguments</source>
        <target state="translated">挿入演算子メンバー '{0}' に {1} 個の初期引数があります。3 つの引数を持つタプルを指定してください</target>
        <note />
      </trans-unit>
      <trans-unit id="cannotResolveNullableOperators">
        <source>The operator '{0}' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">演算子 '{0}' を解決できません。'Microsoft.FSharp.Linq.NullableOperators' モジュールを開いてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorRequiresIn">
        <source>'{0}' must be followed by 'in'. Usage: {1}.</source>
        <target state="translated">'{0}' の後には 'in' が必要です。使い方: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalMemberVarInObjectImplementation">
        <source>Neither 'member val' nor 'override val' definitions are permitted in object expressions.</source>
        <target state="translated">オブジェクト式では 'member val' 定義も 'override val' 定義も使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyCopyAndUpdateRecordInvalid">
        <source>Copy-and-update record expressions must include at least one field.</source>
        <target state="translated">copy-and-update レコード式には 1 つ以上のフィールドを含める必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnderscoreInvalidFieldName">
        <source>'_' cannot be used as field name</source>
        <target state="translated">'_' はフィールド名に使用できません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGeneratedTypesShouldBeInternalOrPrivate">
        <source>The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'.</source>
        <target state="translated">ここで型プロバイダーを使用して生成した指定された型は、他の F# アセンブリからは使用できないため、内部またはプライベートとしてマークする必要があります。'type internal TypeName = ...' または 'type private TypeName = ...' を使用することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterAndSetterHaveSamePropertyType">
        <source>A property's getter and setter must have the same type. Property '{0}' has getter of type '{1}' but setter of type '{2}'.</source>
        <target state="translated">プロパティのゲッターとセッターは同じ型でなければなりません。プロパティ '{0}' は、ゲッターの型が '{1}' でセッターの型が '{2}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRuntimeSuppliedMethodCannotBeUsedInUserCode">
        <source>Array method '{0}' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.</source>
        <target state="translated">配列メソッド '{0}' はランタイムによって提供されるため、コードで直接使用することはできません。配列要素を操作する場合は、LanguagePrimitives.IntrinsicFunctions モジュールにある GetArray/SetArray 関数のファミリを使用することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName">
        <source>Union case/exception '{0}' does not have field named '{1}'.</source>
        <target state="translated">共用体ケース/例外 '{0}' には、'{1}' という名前のフィールドがありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseFieldCannotBeUsedMoreThanOnce">
        <source>Union case/exception field '{0}' cannot be used more than once.</source>
        <target state="translated">共用体ケース/例外フィールド '{0}' を 2 回以上使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameIsUsedModeThanOnce">
        <source>Named field '{0}' is used more than once.</source>
        <target state="translated">名前付きフィールド '{0}' が複数回使用されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameConflictsWithGeneratedNameForAnonymousField">
        <source>Named field '{0}' conflicts with autogenerated name for anonymous field.</source>
        <target state="translated">名前付きフィールド '{0}' が、匿名フィールドのために自動生成された名前と競合しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConstantExpressionOverflow">
        <source>This literal expression or attribute argument results in an arithmetic overflow.</source>
        <target state="translated">この定数式または属性引数の演算結果は、オーバーフローになります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalStructTypeForConstantExpression">
        <source>This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.</source>
        <target state="translated">これは有効な定数式ではありません。[&lt;Literal&gt;] 属性は無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="fscSystemRuntimeInteropServicesIsRequired">
        <source>System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.</source>
        <target state="translated">UnknownWrapper\DispatchWrapper クラスを使用するには、System.Runtime.InteropServices アセンブリが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="abImplicitHeapAllocation">
        <source>The mutable local '{0}' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.</source>
        <target state="translated">変更可能なローカル '{0}' がクロージャでキャプチャされているため、参照セルとして暗黙的に割り当てられています。この警告は、情報提供のみの目的で、暗黙的な割り当てを実行する場所を示しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="estApplyStaticArgumentsForMethodNotImplemented">
        <source>A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid</source>
        <target state="translated">型プロバイダーが GetStaticParametersForMethod を実装しましたが、ApplyStaticArgumentsForMethod は実装されなかったか、無効でした</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToMethod">
        <source>An error occured applying the static arguments to a provided method</source>
        <target state="translated">静的な引数を指定されたメソッドに適用する際エラーが発生しました</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexUnexpectedChar">
        <source>Unexpected character '{0}' in preprocessor expression</source>
        <target state="translated">プリプロセッサの式に予期しない文字 '{0}' があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsUnexpectedToken">
        <source>Unexpected token '{0}' in preprocessor expression</source>
        <target state="translated">プリプロセッサの式に予期しないトークン '{0}' があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsIncompleteExpression">
        <source>Incomplete preprocessor expression</source>
        <target state="translated">不完全なプリプロセッサの式です</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsMissingToken">
        <source>Missing token '{0}' in preprocessor expression</source>
        <target state="translated">プリプロセッサの式にトークン '{0}' がありません</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleMissingDefinition">
        <source>An error occurred while reading the F# metadata node at position {0} in table '{1}' of assembly '{2}'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.</source>
        <target state="translated">F# メタデータ ノードをアセンブリ '{2}' のテーブル '{1}' の位置 {0} で読み取るときにエラーが発生しました。このノードには、一致する宣言がありませんでした。この警告を報告してください。使用している F# アセンブリの再コンパイルが必要になる場合があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScope">
        <source>Type inference caused the type variable {0} to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.</source>
        <target state="translated">型推論により型変数 {0} はスコープを回避しました。明示的な型パラメーター宣言を追加するか、コードの総称性が低くなるよう調整してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScopeAnon">
        <source>Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.</source>
        <target state="translated">型推論により型変数はスコープを回避しました。型の注釈を追加して総称性が低くなるようにしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="checkRaiseFamilyFunctionArgumentCount">
        <source>Redundant arguments are being ignored in function '{0}'. Expected {1} but got {2} arguments.</source>
        <target state="translated">冗長な引数は、関数 '{0}' で無視されます。{1} 個の引数が必要ですが、{2} 個の引数があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="checkLowercaseLiteralBindingInPattern">
        <source>Lowercase literal '{0}' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.</source>
        <target state="translated">小文字のリテラル '{0}' は、同じ名前の新しいパターンによりシャドウされています。大文字かモジュール プレフィックスのリテラルのみ名前付きパターンとして使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralDoesNotTakeArguments">
        <source>This literal pattern does not take arguments</source>
        <target state="translated">このリテラル パターンは引数を使用しません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalInAugmentation">
        <source>Constructors are not permitted as extension members - they must be defined as part of the original definition of the type</source>
        <target state="translated">コンストラクターは拡張メンバーとして許可されていません - その型の元の定義の一部として定義する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidResponseFile">
        <source>Invalid response file '{0}' ( '{1}' )</source>
        <target state="translated">正しくない応答ファイル '{0}' ( '{1}' )</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNotFound">
        <source>Response file '{0}' not found in '{1}'</source>
        <target state="translated">応答ファイル '{0}' が '{1}' にありません</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNameInvalid">
        <source>Response file name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">応答ファイル名 '{0}' は、空であるか、正しくない文字が含まれているか、ドライブ指定があるが絶対パスがないか、あるいは長すぎます</target>
        <note />
      </trans-unit>
      <trans-unit id="fsharpCoreNotFoundToBeCopied">
        <source>Cannot find FSharp.Core.dll in compiler's directory</source>
        <target state="translated">コンパイラのディレクトリ内に FSharp.Core.dll が見つかりませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleStructMismatch">
        <source>One tuple type is a struct tuple, the other is a reference tuple</source>
        <target state="translated">片方のタプル型は構造体タプルで、もう一方は参照タプルです</target>
        <note />
      </trans-unit>
      <trans-unit id="etMissingStaticArgumentsToMethod">
        <source>This provided method requires static parameters</source>
        <target state="translated">指定されたこのメソッドには静的パラメーターが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcast">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'.</source>
        <target state="translated">{0} から {1} への変換は、コンパイル時のダウンキャストではなく、セーフ アップキャストです。'downcast' の代わりに 'upcast' を使うことを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcastOperator">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.</source>
        <target state="translated">{0} から {1} への変換は、コンパイル時のダウンキャストではなく、セーフ アップキャストです。:?&gt; (ダウンキャスト) 演算子の代わりに :&gt; (アップキャスト) 演算子を使うことを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecImplied">
        <source>The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored</source>
        <target state="translated">このモジュールの 'rec' は外側の 'rec' 宣言で暗黙的に示されており、無視されます</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenFirstInMutRec">
        <source>In a recursive declaration group, 'open' declarations must come first in each module</source>
        <target state="translated">再帰的な宣言グループでは、'open' 宣言は各モジュールの先頭になければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbrevFirstInMutRec">
        <source>In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations</source>
        <target state="translated">再帰的な宣言グループでは、モジュールの省略形は、すべての 'open' 宣言の後、その他の宣言の前になければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedMutRecDecl">
        <source>This declaration is not supported in recursive declaration groups</source>
        <target state="translated">この宣言は、再帰的な宣言グループではサポートされていません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidUseOfRec">
        <source>Invalid use of 'rec' keyword</source>
        <target state="translated">'rec' キーワードの使用法が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructUnionMultiCaseDistinctFields">
        <source>If a union type has more than one case and is a struct, then all fields within the union type must be given unique names.</source>
        <target state="translated">共用体型が複数のケースを持つ 1 つの構造体である場合は、共用体型内のすべてのフィールドに一意の名前を付ける必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerMemberNameIsOverriden">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">パラメーター '{0}' に適用される CallerMemberNameAttribute は無効になります。CallerFilePathAttribute に上書きされます。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFixedNotAllowed">
        <source>Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'</source>
        <target state="translated">'fixed' の使い方が正しくありません。'fixed' を使用できるのは書式 'use x = fixed expr' の宣言内だけで、この式は配列、フィールドのアドレス、配列要素のアドレス、または文字列です</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindOffsetToStringData">
        <source>Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression.</source>
        <target state="translated">'fixed' 式のビルド時に、参照内でメソッド System.Runtime.CompilerServices.OffsetToStringData が見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefReturnOfLocal">
        <source>The address of the variable '{0}' cannot be used at this point. A method or function may not return the address of this local value.</source>
        <target state="translated">変数 '{0}' のアドレスはこのポイントでは使用できません。メソッドまたは関数がこのローカル値のアドレスを返さない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedActivePattern">
        <source>{0} is an active pattern and cannot be treated as a discriminated union case with named fields.</source>
        <target state="translated">{0} はアクティブ パターンで、名前付きフィールドのある判別された共用体ケースとしては扱えません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultParameterValueNotAppropriateForArgument">
        <source>The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'.</source>
        <target state="translated">既定値が引数と同じ型ではありません。DefaultParameterValue 属性とすべての Optional 属性は無視されます。注: 'null' には適切な型の注釈を付ける必要があります。例: 'DefaultParameterValue(null:obj)'。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGlobalsSystemTypeNotFound">
        <source>The system type '{0}' was required but no referenced system DLL contained this type</source>
        <target state="translated">システム型 '{0}' が必要でしたが、この型を含む参照されたシステム DLL はありません</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberHasMultiplePossibleDispatchSlots">
        <source>The member '{0}' matches multiple overloads of the same method.\nPlease restrict it to one of the following:{1}.</source>
        <target state="translated">メンバー '{0}' は同じメソッドの複数のオーバーロードと一致しています。\n次のいずれかに制限してください: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="methodIsNotStatic">
        <source>Method or object constructor '{0}' is not static</source>
        <target state="translated">メソッドまたはオブジェクト コンストラクター '{0}' が静的ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolEqualsInsteadOfIn">
        <source>Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?</source>
        <target state="translated">式の予期しない記号 '='。代わりに 'for x in y .. z do' を使用するつもりでしたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAbstract">
        <source>Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</source>
        <target state="translated">宣言された型に実装がないメソッド、または既定の実装がある仮想のメソッドを示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keyworkDescriptionAnd">
        <source>Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</source>
        <target state="translated">相互に再帰的なバインディング、プロパティの宣言、およびジェネリック パラメーターの複数の制約に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAs">
        <source>Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</source>
        <target state="translated">現在のクラス オブジェクトにオブジェクト名を指定するために使用します。パターン マッチ内のパターン全体に名前を指定するためにも使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAssert">
        <source>Used to verify code during debugging.</source>
        <target state="translated">デバッグ中のコードの検証に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBase">
        <source>Used as the name of the base class object.</source>
        <target state="translated">基底クラス オブジェクトの名前として使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBegin">
        <source>In verbose syntax, indicates the start of a code block.</source>
        <target state="translated">冗語構文で、コード ブロックの先頭を示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionClass">
        <source>In verbose syntax, indicates the start of a class definition.</source>
        <target state="translated">冗語構文で、クラス定義の始まりを示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDefault">
        <source>Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</source>
        <target state="translated">抽象メソッドの実装を示します。抽象メソッドの宣言と同時に使用して仮想メソッドを作成します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDelegate">
        <source>Used to declare a delegate.</source>
        <target state="translated">デリゲートの宣言に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDo">
        <source>Used in looping constructs or to execute imperative code.</source>
        <target state="translated">ループ コンストラクト、または命令型コードの実行に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDone">
        <source>In verbose syntax, indicates the end of a block of code in a looping expression.</source>
        <target state="translated">冗語構文で、ループ式のコード ブロックの末尾を示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDowncast">
        <source>Used to convert to a type that is lower in the inheritance chain.</source>
        <target state="translated">継承チェーン内の下位の型に変換するために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDownto">
        <source>In a for expression, used when counting in reverse.</source>
        <target state="translated">for 式で、逆方向にカウントするときに使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElif">
        <source>Used in conditional branching. A short form of else if.</source>
        <target state="translated">条件分岐で使用します。else if の短い形式です。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElse">
        <source>Used in conditional branching.</source>
        <target state="translated">条件分岐で使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionEnd">
        <source>In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</source>
        <target state="translated">型定義や型拡張で、メンバー定義セクションの末尾を示します。冗語構文では、begin キーワードで始まるコード ブロックの末尾を示すために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionException">
        <source>Used to declare an exception type.</source>
        <target state="translated">例外の種類の宣言に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionExtern">
        <source>Indicates that a declared program element is defined in another binary or assembly.</source>
        <target state="translated">宣言されたプログラム要素が別のバイナリまたはアセンブリで定義されていることを示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTrueFalse">
        <source>Used as a Boolean literal.</source>
        <target state="translated">ブール型のリテラルとして使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFinally">
        <source>Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</source>
        <target state="translated">例外が発生するかどうかに関係なく実行されるコード ブロックを開始するために、try と一緒に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFor">
        <source>Used in looping constructs.</source>
        <target state="translated">ループ コンストラクトで使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFun">
        <source>Used in lambda expressions, also known as anonymous functions.</source>
        <target state="translated">ラムダ式で使用し、匿名関数とも呼ばれます。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFunction">
        <source>Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</source>
        <target state="translated">単一の引数でパターン マッチングを持つラムダ式で fun キーワードと match 式の代わりに省略形として使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionGlobal">
        <source>Used to reference the top-level .NET namespace.</source>
        <target state="translated">最上位の .NET 名前空間を参照するために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIf">
        <source>Used in conditional branching constructs.</source>
        <target state="translated">条件分岐のコンストラクトで使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIn">
        <source>Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</source>
        <target state="translated">冗語構文で、式のバインディングを分離するためにシーケンス式に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInherit">
        <source>Used to specify a base class or base interface.</source>
        <target state="translated">基底クラスまたは基底インターフェイスを指定するために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInline">
        <source>Used to indicate a function that should be integrated directly into the caller's code.</source>
        <target state="translated">呼び出し元のコードに直接統合する必要のある関数を示すために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInterface">
        <source>Used to declare and implement interfaces.</source>
        <target state="translated">インターフェイスの宣言と実装に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInternal">
        <source>Used to specify that a member is visible inside an assembly but not outside it.</source>
        <target state="translated">アセンブリの外部では表示されず、内部でのみ表示されるメンバーを指定するために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLazy">
        <source>Used to specify a computation that is to be performed only when a result is needed.</source>
        <target state="translated">結果が必要な場合にのみ実行するコンピュテーションを指定するために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLet">
        <source>Used to associate, or bind, a name to a value or function.</source>
        <target state="translated">値または関数への名前の関連付けまたはバインドに使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLetBang">
        <source>Used in asynchronous workflows to bind a name to the result of an asynchronous computation, or, in other computation expressions, used to bind a name to a result, which is of the computation type.</source>
        <target state="translated">非同期コンピュテーションの結果に名前をバインドする非同期ワークフローで使用します。また別のコンピュテーション式では、そのコンピュテーション型を示す名前を結果にバインドします。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatch">
        <source>Used to branch by comparing a value to a pattern.</source>
        <target state="translated">値をパターンと比較して分岐するために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMember">
        <source>Used to declare a property or method in an object type.</source>
        <target state="translated">オブジェクトの種類のプロパティまたはメソッドの宣言に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionModule">
        <source>Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</source>
        <target state="translated">関連する型、値、関数のグループに名前を関連付け、その他のコードと論理的に分離するために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMutable">
        <source>Used to declare a variable, that is, a value that can be changed.</source>
        <target state="translated">変更可能な値である変数の宣言に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNamespace">
        <source>Used to associate a name with a group of related types and modules, to logically separate it from other code.</source>
        <target state="translated">関連する型とモジュールのグループに名前を関連付け、その他のコードと論理的に分離するために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNew">
        <source>Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.</source>
        <target state="translated">オブジェクトを作成または作成可能なコンストラクターの宣言、定義、起動に使用します。ジェネリック パラメーターの制約でも、型が特定のコンストラクターを持つ必要があることを示すために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNot">
        <source>Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</source>
        <target state="translated">実際にはキーワードではありませんが、not struct という組み合わせでジェネリック パラメーターの制約として使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNull">
        <source>Indicates the absence of an object. Also used in generic parameter constraints.</source>
        <target state="translated">オブジェクトがないことを示します。ジェネリック パラメーターの制約にも使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOf">
        <source>Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</source>
        <target state="translated">判別共同体で値のカテゴリの種類を示し、デリゲート宣言と例外宣言でも使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOpen">
        <source>Used to make the contents of a namespace or module available without qualification.</source>
        <target state="translated">修飾子を使用せずに名前空間またはモジュールのコンテンツを利用可能にするために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOr">
        <source>Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.</source>
        <target state="translated">ブール値の or 演算子としてブール条件で使用します。|| に相当します。メンバー制約でも使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOverride">
        <source>Used to implement a version of an abstract or virtual method that differs from the base version.</source>
        <target state="translated">基本バージョンと異なる抽象メソッドまたは仮想メソッドのバージョンの実装に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPrivate">
        <source>Restricts access to a member to code in the same type or module.</source>
        <target state="translated">メンバーに対して、同じ型やモジュールのコードへのアクセスを制限します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPublic">
        <source>Allows access to a member from outside the type.</source>
        <target state="translated">型の外部からのメンバーに対して、アクセスを許可します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRec">
        <source>Used to indicate that a function is recursive.</source>
        <target state="translated">関数が再帰的であることを示すために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturn">
        <source>Used to indicate a value to provide as the result of a computation expression.</source>
        <target state="translated">コンピュテーション式の結果として提供される値を示すために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturnBang">
        <source>Used to indicate a computation expression that, when evaluated, provides the result of the containing computation expression.</source>
        <target state="translated">コンピュテーション式を示し、評価されたときはそのコンピュテーション式の結果を示すために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionSelect">
        <source>Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</source>
        <target state="translated">クエリ式でどのフィールドまたは列を抽出するかを指定するために使用します。これはコンテキスト キーワードであり、実際には予約語ではなく、適切なコンテキストでキーワードとしてのみ動作します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStatic">
        <source>Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</source>
        <target state="translated">型のインスタンスなしで呼び出すことのできるメソッドまたはプロパティ、または型のすべてのインスタンスで共有される値メンバーを示すために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStruct">
        <source>Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions.</source>
        <target state="translated">構造体型の宣言に使用します。ジェネリック パラメーターの制約にも使用します。モジュール定義の OCaml の互換性を保つために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionThen">
        <source>Used in conditional expressions. Also used to perform side effects after object construction.</source>
        <target state="translated">条件分岐で使用します。オブジェクトの構築後の副作用の実行にも使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTo">
        <source>Used in for loops to indicate a range.</source>
        <target state="translated">for ループで範囲を示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTry">
        <source>Used to introduce a block of code that might generate an exception. Used together with with or finally.</source>
        <target state="translated">例外を生成する可能性があるコード ブロックを開始するために使用します。with または finally と一緒に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionType">
        <source>Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</source>
        <target state="translated">クラス、レコード、構造体、判別された共同体、列挙型、数量単位、型の省略形の宣言に使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUpcast">
        <source>Used to convert to a type that is higher in the inheritance chain.</source>
        <target state="translated">継承チェーン内の上位の型に変換するために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUse">
        <source>Used instead of let for values that require Dispose to be called to free resources.</source>
        <target state="translated">Dispose を呼び出してリソースを解放する必要のある値に対して、let の代わりに使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUseBang">
        <source>Used instead of let! in asynchronous workflows and other computation expressions for values that require Dispose to be called to free resources.</source>
        <target state="translated">非同期ワークフロー、および Dispose を呼び出してリソースを解放する必要のある値のその他のコンピュテーション式で let! の代わりに使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVal">
        <source>Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</source>
        <target state="translated">限定された状態において、シグネチャで値を示したり、型でメンバーを宣言したりするために使用されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVoid">
        <source>Indicates the .NET void type. Used when interoperating with other .NET languages.</source>
        <target state="translated">.NET の void 型を示します。他の .NET 言語と相互運用するときに使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhen">
        <source>Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.</source>
        <target state="translated">パターン マッチでのブール条件 (when ガード) で、ジェネリック型パラメーターの制約句を開始するために使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhile">
        <source>Introduces a looping construct.</source>
        <target state="translated">ループ コンストラクトを導入します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWith">
        <source>Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</source>
        <target state="translated">パターン マッチング式で match キーワードを指定して使用します。メンバー定義と例外ハンドラーを導入するため、オブジェクト式、レコード コピー式、および型拡張でも使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYield">
        <source>Used in a sequence expression to produce a value for a sequence.</source>
        <target state="translated">シーケンス式でシーケンスの値を生成します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYieldBang">
        <source>Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</source>
        <target state="translated">コンピュテーション式で、コンピュテーション式を含む結果のコレクションにそのコンピュテーション式の結果を追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRightArrow">
        <source>In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions</source>
        <target state="translated">関数型で、引数と戻り値を区切ります。式 (シーケンス式) が得られ、yield キーワードに相当します。match 式に使用されます</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLeftArrow">
        <source>Assigns a value to a variable.</source>
        <target state="translated">変数に値を割り当てます。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionCast">
        <source>Converts a type to type that is higher in the hierarchy.</source>
        <target state="translated">型を階層の上位にある型に変換します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDynamicCast">
        <source>Converts a type to a type that is lower in the hierarchy.</source>
        <target state="translated">型を階層の下位にある型に変換します。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTypedQuotation">
        <source>Delimits a typed code quotation.</source>
        <target state="translated">型指定されたコード引用符を区切ります。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUntypedQuotation">
        <source>Delimits a untyped code quotation.</source>
        <target state="translated">型指定のないコード引用符を区切ります。</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundDuringDynamicCodeGen">
        <source>{0} '{1}' not found in assembly '{2}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{0} '{1}' がアセンブリ '{2}' に見つかりません。バージョンの互換性がないことが原因の可能性があります。すべての参照コンポーネントが正しいバージョンを使用できるように、このアセンブリの正しいバージョンを明示的に参照しなければならない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundInTypeDuringDynamicCodeGen">
        <source>{0} '{1}' not found in type '{2}' from assembly '{3}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{0} '{1}' がアセンブリ '{3}' の '{2}' 型に見つかりません。バージョンの互換性がないことが原因の可能性があります。すべての参照コンポーネントが正しいバージョンを使用できるように、このアセンブリの正しいバージョンを明示的に参照しなければならない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionWordIs">
        <source>is</source>
        <target state="translated">は</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunction">
        <source>This value is not a function and cannot be applied.</source>
        <target state="translated">この値は関数ではないため、適用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexerWithName">
        <source>This value is not a function and cannot be applied. Did you intend to access the indexer via {0}.[index] instead?</source>
        <target state="translated">この値は関数ではないため、適用できません。そうではなく、{0}.[index] によってインデクサーにアクセスしようとしましたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexer">
        <source>This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?</source>
        <target state="translated">この式は関数ではないため、適用できません。そうではなく、expr.[index] によってインデクサーにアクセスしようとしましたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeDeclaration">
        <source>This value is not a function and cannot be applied. Did you forget to terminate a declaration?</source>
        <target state="translated">この値は関数ではないため、適用できません。宣言を終結しましたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentsInSigAndImplMismatch">
        <source>The argument names in the signature '{0}' and implementation '{1}' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling.</source>
        <target state="translated">シグネチャ '{0}' と実装 '{1}' の引数の名前が一致しません。シグネチャ ファイルの引数の名前が使用されます。デバッグまたはプロファイルするときに問題が生じる原因となる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleUnexpectedNonZero">
        <source>An error occurred while reading the F# metadata of assembly '{0}'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct.</source>
        <target state="translated">アセンブリ '{0}' の F# メタデータ の読み取り中にエラーが発生しました。予約済みのコンストラクトが使用されました。F# コンパイラをアップグレードするか、特定のコンストラクトを使用しない以前のバージョンのアセンブリを使用しなければならない場合があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleMemberNotNormallyUsed">
        <source>This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.</source>
        <target state="translated">このメソッドまたはプロパティは通常、F# コードから使用されません。代わりに、明示的なタプル パターンを分解に使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'.</source>
        <target state="translated">この式は型 '{0}' の値を返しますが、暗黙的に破棄されます。'let' を使用して結果を名前にバインドすることを検討してください。例: 'let result = expression'。式をシーケンス内で値として使用する場合は、明示的に 'yield' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedSequenceInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'.</source>
        <target state="translated">この式は型 '{0}' の値を返しますが、暗黙的に破棄されます。'let' を使用して結果を名前にバインドすることを検討してください。例: 'let result = expression'。式をシーケンス内で値として使用する場合は、明示的に 'yield!' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatchBang">
        <source>Used in computation expressions to pattern match directly over the result of another computation expression.</source>
        <target state="new">Used in computation expressions to pattern match directly over the result of another computation expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilreadFileChanged">
        <source>The file '{0}' changed on disk unexpectedly, please reload.</source>
        <target state="translated">ファイル '{0}' がディスク上で予期せず変更されました。再度読み込んでください。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>