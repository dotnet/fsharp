<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="de" original="../FSStrings.resx">
    <body>
      <trans-unit id="Parser.TOKEN.DOT.DOT.HAT">
        <source>symbol '..^'</source>
        <target state="translated">Symbol "..^"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INTERP.STRING.BEGIN.END">
        <source>interpolated string</source>
        <target state="translated">Interpolierte Zeichenfolge</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INTERP.STRING.BEGIN.PART">
        <source>interpolated string (first part)</source>
        <target state="translated">Interpolierte Zeichenfolge (erster Teil)</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INTERP.STRING.END">
        <source>interpolated string (final part)</source>
        <target state="translated">Interpolierte Zeichenfolge (letzter Teil)</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INTERP.STRING.PART">
        <source>interpolated string (part)</source>
        <target state="translated">Interpolierte Zeichenfolge (Teil)</target>
        <note />
      </trans-unit>
      <trans-unit id="SeeAlso">
        <source>. See also {0}.</source>
        <target state="translated">. Siehe auch "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstraintSolverTupleDiffLengths">
        <source>The tuples have differing lengths of {0} and {1}</source>
        <target state="translated">Die Tupel haben eine unterschiedliche Länge von {0} und {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstraintSolverInfiniteTypes">
        <source>The types '{0}' and '{1}' cannot be unified.</source>
        <target state="translated">Die Typen "{0}" und "{1}" können nicht vereinheitlicht werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstraintSolverMissingConstraint">
        <source>A type parameter is missing a constraint '{0}'</source>
        <target state="translated">Einem Typparameter fehlt die Einschränkung "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstraintSolverTypesNotInEqualityRelation1">
        <source>The unit of measure '{0}' does not match the unit of measure '{1}'</source>
        <target state="translated">Die Maßeinheit "{0}" stimmt nicht mit der Maßeinheit "{1}" überein.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstraintSolverTypesNotInEqualityRelation2">
        <source>The type '{0}' does not match the type '{1}'</source>
        <target state="translated">Der Typ "{0}" stimmt nicht mit dem Typ "{1}" überein.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstraintSolverTypesNotInSubsumptionRelation">
        <source>The type '{0}' is not compatible with the type '{1}'{2}</source>
        <target state="translated">Der Typ "{0}" ist nicht mit dem Typ "{1}"{2} kompatibel.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorFromAddingTypeEquation1">
        <source>This expression was expected to have type\n    '{1}'    \nbut here has type\n    '{0}'    {2}</source>
        <target state="translated">Dieser Ausdruck sollte den folgenden Typ aufweisen:\n    "{1}"    \nEr ist jedoch vom folgenden Typ:\n    "{0}"    {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorFromAddingTypeEquation2">
        <source>Type mismatch. Expecting a\n    '{0}'    \nbut given a\n    '{1}'    {2}\n</source>
        <target state="translated">Typenkonflikt. Erwartet:\n    "{0}"    \nErhalten:\n    "{1}"    {2}\n</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorFromApplyingDefault1">
        <source>Type constraint mismatch when applying the default type '{0}' for a type inference variable. </source>
        <target state="translated">Typeinschränkungen stimmen nicht überein, wenn der Standardtyp "{0}" auf eine Typrückschlussvariable angewendet wird. </target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorFromApplyingDefault2">
        <source> Consider adding further type constraints</source>
        <target state="translated"> Fügen Sie ggf. weitere Typeinschränkungen hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorsFromAddingSubsumptionConstraint">
        <source>Type constraint mismatch. The type \n    '{0}'    \nis not compatible with type\n    '{1}'    {2}\n</source>
        <target state="translated">Die Typeinschränkungen stimmen nicht überein. Der Typ \n    "{0}"    \nist nicht mit folgendem Typ kompatibel:\n    "{1}"    {2}\n</target>
        <note />
      </trans-unit>
      <trans-unit id="UpperCaseIdentifierInPattern">
        <source>Uppercase variable identifiers should not generally be used in patterns, and may indicate a missing open declaration or a misspelt pattern name.</source>
        <target state="translated">Variablenbezeichner in Großbuchstaben sollten im Allgemeinen nicht in Mustern verwendet werden und können ein Hinweis auf eine fehlende open-Deklaration oder einen falsch geschriebenen Musternamen sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="NotUpperCaseConstructor">
        <source>Discriminated union cases and exception labels must be uppercase identifiers</source>
        <target state="translated">Diskriminierte Union-Fälle und Ausnahmebezeichnungen müssen Bezeichner in Großbuchstaben sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionExpected">
        <source>This function takes too many arguments, or is used in a context where a function is not expected</source>
        <target state="translated">Diese Funktion akzeptiert zu viele Argumente oder wird in einem Kontext verwendet, in dem keine Funktion erwartet wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="BakedInMemberConstraintName">
        <source>Member constraints with the name '{0}' are given special status by the F# compiler as certain .NET types are implicitly augmented with this member. This may result in runtime failures if you attempt to invoke the member constraint from your own code.</source>
        <target state="translated">Membereinschränkungen mit dem Namen "{0}" erhalten vom F#-Compiler einen Sonderstatus, da bestimmte .NET-Typen mit diesem Member implizit augmentiert werden. Dies kann Laufzeitfehler zur Folge haben, falls Sie versuchen, die Membereinschränkung in Ihrem eigenen Code aufzurufen.</target>
        <note />
      </trans-unit>
      <trans-unit id="BadEventTransformation">
        <source>A definition to be compiled as a .NET event does not have the expected form. Only property members can be compiled as .NET events.</source>
        <target state="translated">Eine Definition, die als .NET-Ereignis kompiliert werden soll, weist nicht die erwartete Form auf. Nur Eigenschaftenmember können als .NET-Ereignisse kompiliert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterlessStructCtor">
        <source>Implicit object constructors for structs must take at least one argument</source>
        <target state="translated">Implizite Objektkonstruktoren für Strukturen müssen mindestens ein Argument akzeptieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceNotRevealed">
        <source>The type implements the interface '{0}' but this is not revealed by the signature. You should list the interface in the signature, as the interface will be discoverable via dynamic type casts and/or reflection.</source>
        <target state="translated">Der Typ implementiert die {0}-Schnittstelle, das wird jedoch von der Signatur nicht offengelegt. Sie sollten die Schnittstelle in der Signatur auflisten, da die Schnittstelle durch dynamische Typumwandlungen und/oder Reflektion erkannt werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="TyconBadArgs">
        <source>The type '{0}' expects {1} type argument(s) but is given {2}</source>
        <target state="translated">Der Typ "{0}" erwartet {1} Typargument(e), erhält aber {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IndeterminateType">
        <source>Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.</source>
        <target state="translated">Lookup für ein Objekt unbestimmten Typs, der auf Informationen vor diesem Programmpunkt basiert. Möglicherweise ist vor diesem Programmpunkt eine Typanmerkung erforderlich, um den Objekttyp einzuschränken. Dadurch kann das Lookup möglicherweise aufgelöst werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="NameClash1">
        <source>Duplicate definition of {0} '{1}'</source>
        <target state="translated">Doppelte Definition von {0} "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="NameClash2">
        <source>The {0} '{1}' can not be defined because the name '{2}' clashes with the {3} '{4}' in this type or module</source>
        <target state="translated">{0} "{1}" kann nicht definiert werden, weil der Name "{2}" einen Konflikt mit {3} "{4}" in diesem Typ oder Modul verursacht.</target>
        <note />
      </trans-unit>
      <trans-unit id="Duplicate1">
        <source>Two members called '{0}' have the same signature</source>
        <target state="translated">Zwei Member namens "{0}" weisen dieselbe Signatur auf.</target>
        <note />
      </trans-unit>
      <trans-unit id="Duplicate2">
        <source>Duplicate definition of {0} '{1}'</source>
        <target state="translated">Doppelte Definition von {0} "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="UndefinedName2">
        <source> A construct with this name was found in FSharp.PowerPack.dll, which contains some modules and types that were implicitly referenced in some previous versions of F#. You may need to add an explicit reference to this DLL in order to compile this code.</source>
        <target state="translated"> Ein Konstrukt mit diesem Namen wurde in "FSharp.PowerPack.dll" gefunden; diese DLL enthält einige Module und Typen, auf die in früheren Versionen von F# implizit verwiesen wurde. Möglicherweise müssen Sie einen expliziten Verweis auf diese DLL hinzufügen, um den Code kompilieren zu können.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotMutable">
        <source>This field is not mutable</source>
        <target state="translated">Dieses Feld ist nicht änderbar.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldsFromDifferentTypes">
        <source>The fields '{0}' and '{1}' are from different types</source>
        <target state="translated">Die Felder "{0}" und "{1}" stammen aus unterschiedlichen Typen.</target>
        <note />
      </trans-unit>
      <trans-unit id="VarBoundTwice">
        <source>'{0}' is bound twice in this pattern</source>
        <target state="translated">{0} ist in diesem Muster doppelt gebunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Recursion">
        <source>A use of the function '{0}' does not match a type inferred elsewhere. The inferred type of the function is\n    {1}.    \nThe type of the function required at this point of use is\n    {2}    {3}\nThis error may be due to limitations associated with generic recursion within a 'let rec' collection or within a group of classes. Consider giving a full type signature for the targets of recursive calls including type annotations for both argument and return types.</source>
        <target state="translated">Ein Vorkommen der Funktion "{0}" stimmt nicht mit einem an anderer Stelle per Rückschluss abgeleiteten Typ überein. Der abgeleitete Typ der Funktion ist:\n    {1}.    \nAn diesem Verwendungsort ist folgender Funktionstyp erforderlich:\n    {2}    {3}\nDieser Fehler kann auf Einschränkungen im Zusammenhang mit der generischen Rekursion innerhalb einer "let rec"-Sammlung oder innerhalb einer Gruppe von Klassen zurückzuführen sein. Definieren Sie ggf. eine vollständige Typsignatur für die Ziele von rekursiven Aufrufen, einschließlich Typanmerkungen für Argument- und Rückgabetyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRuntimeCoercion">
        <source>Invalid runtime coercion or type test from type {0} to {1}\n{2}</source>
        <target state="translated">Ungültige Laufzeitkoersion oder ungültiger Typtest von Typ "{0}" in "{1}"\n{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="IndeterminateRuntimeCoercion">
        <source>This runtime coercion or type test from type\n    {0}    \n to \n    {1}    \ninvolves an indeterminate type based on information prior to this program point. Runtime type tests are not allowed on some types. Further type annotations are needed.</source>
        <target state="translated">Diese Laufzeitkoersion oder dieser Typtest vom Typ\n    {0}    \n in \n    {1}    \numfasst einen unbestimmten Typ, der auf Informationen vor diesem Programmpunkt basiert. Laufzeittyptests sind für einige Typen nicht zulässig. Weitere Typanmerkungen sind erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="IndeterminateStaticCoercion">
        <source>The static coercion from type\n    {0}    \nto \n    {1}    \n involves an indeterminate type based on information prior to this program point. Static coercions are not allowed on some types. Further type annotations are needed.</source>
        <target state="translated">Die statische Koersion vom Typ\n    {0}    \nin \n    {1}    \n umfasst einen unbestimmten Typ, der auf Informationen vor diesem Programmpunkt basiert. Statische Koersionen sind für einige Typen nicht zulässig. Weitere Typanmerkungen sind erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticCoercionShouldUseBox">
        <source>A coercion from the value type \n    {0}    \nto the type \n    {1}    \nwill involve boxing. Consider using 'box' instead</source>
        <target state="translated">Eine Koersion vom Werttyp \n    {0}    \nin den Typ \n    {1}    \nerfordert Boxing. Verwenden Sie stattdessen "box".</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeIsImplicitlyAbstract">
        <source>This type is 'abstract' since some abstract members have not been given an implementation. If this is intentional then add the '[&lt;AbstractClass&gt;]' attribute to your type.</source>
        <target state="translated">Der Typ entspricht "abstract", da einige abstrakte Member nicht mit einer Implementierung versehen wurden. Wenn dies Ihre Absicht ist, fügen Sie das [&lt;AbstractClass&gt;]-Attribut zu Ihrem Typ hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonRigidTypar1">
        <source>This construct causes code to be less generic than indicated by its type annotations. The type variable implied by the use of a '#', '_' or other type annotation at or near '{0}' has been constrained to be type '{1}'.</source>
        <target state="translated">Durch dieses Konstrukt wird der Code weniger generisch, als aus den Typanmerkungen hervorgeht. Die durch die Verwendung von "#", "_" oder einer anderen Typanmerkung bei oder in der Nähe von "{0}" implizierte Typvariable wurde auf den Typ "{1}" eingeschränkt.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonRigidTypar2">
        <source>This construct causes code to be less generic than indicated by the type annotations. The unit-of-measure variable '{0} has been constrained to be measure '{1}'.</source>
        <target state="translated">Durch dieses Konstrukt wird der Code weniger generisch, als aus den Typanmerkungen hervorgeht. Die Maßeinheitenvariable "{0}" wurde auf die Maßeinheit "{1}" eingeschränkt.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonRigidTypar3">
        <source>This construct causes code to be less generic than indicated by the type annotations. The type variable '{0} has been constrained to be type '{1}'.</source>
        <target state="translated">Durch dieses Konstrukt wird der Code weniger generisch, als aus den Typanmerkungen hervorgeht. Die Typvariable "{0}" wurde auf den Typ "{1}" eingeschränkt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.IDENT">
        <source>identifier</source>
        <target state="translated">Bezeichner</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INT">
        <source>integer literal</source>
        <target state="translated">Integer-Literal</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.FLOAT">
        <source>floating point literal</source>
        <target state="translated">Gleitkommaliteral</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.DECIMAL">
        <source>decimal literal</source>
        <target state="translated">Dezimalliteral</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.CHAR">
        <source>character literal</source>
        <target state="translated">Zeichenliteral</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.BASE">
        <source>keyword 'base'</source>
        <target state="translated">Schlüsselwort "base"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LPAREN.STAR.RPAREN">
        <source>symbol '(*)'</source>
        <target state="translated">Symbol "(*)"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.DOLLAR">
        <source>symbol '$'</source>
        <target state="translated">Symbol "$"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INFIX.STAR.STAR.OP">
        <source>infix operator</source>
        <target state="translated">infix-Operator</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INFIX.COMPARE.OP">
        <source>infix operator</source>
        <target state="translated">infix-Operator</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.COLON.GREATER">
        <source>symbol ':&gt;'</source>
        <target state="translated">Symbol ":&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.COLON.COLON">
        <source>symbol '::'</source>
        <target state="translated">Symbol "::"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.PERCENT.OP">
        <source>symbol '{0}</source>
        <target state="translated">Symbol "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INFIX.AT.HAT.OP">
        <source>infix operator</source>
        <target state="translated">infix-Operator</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INFIX.BAR.OP">
        <source>infix operator</source>
        <target state="translated">infix-Operator</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.PLUS.MINUS.OP">
        <source>infix operator</source>
        <target state="translated">infix-Operator</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.PREFIX.OP">
        <source>prefix operator</source>
        <target state="translated">Präfixoperator</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.COLON.QMARK.GREATER">
        <source>symbol ':?&gt;'</source>
        <target state="translated">Symbol ":?&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INFIX.STAR.DIV.MOD.OP">
        <source>infix operator</source>
        <target state="translated">infix-Operator</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INFIX.AMP.OP">
        <source>infix operator</source>
        <target state="translated">infix-Operator</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.AMP">
        <source>symbol '&amp;'</source>
        <target state="translated">Symbol "&amp;"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.AMP.AMP">
        <source>symbol '&amp;&amp;'</source>
        <target state="translated">Symbol "&amp;&amp;"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.BAR.BAR">
        <source>symbol '||'</source>
        <target state="translated">Symbol "||"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LESS">
        <source>symbol '&lt;'</source>
        <target state="translated">Symbol "&lt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.GREATER">
        <source>symbol '&gt;'</source>
        <target state="translated">Symbol "&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.QMARK">
        <source>symbol '?'</source>
        <target state="translated">Symbol "?"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.QMARK.QMARK">
        <source>symbol '??'</source>
        <target state="translated">Symbol "??"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.COLON.QMARK">
        <source>symbol ':?'</source>
        <target state="translated">Symbol ":?"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INT32.DOT.DOT">
        <source>integer..</source>
        <target state="translated">integer..</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.DOT.DOT">
        <source>symbol '..'</source>
        <target state="translated">Symbol ".."</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.QUOTE">
        <source>quote symbol</source>
        <target state="translated">Anführungszeichensymbol</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.STAR">
        <source>symbol '*'</source>
        <target state="translated">Symbol "*"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.HIGH.PRECEDENCE.TYAPP">
        <source>type application </source>
        <target state="translated">Typanwendung </target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.COLON">
        <source>symbol ':'</source>
        <target state="translated">Symbol ":"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.COLON.EQUALS">
        <source>symbol ':='</source>
        <target state="translated">Symbol ":="</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LARROW">
        <source>symbol '&lt;-'</source>
        <target state="translated">Symbol "&lt;-"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.EQUALS">
        <source>symbol '='</source>
        <target state="translated">Symbol "="</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.GREATER.BAR.RBRACK">
        <source>symbol '&gt;|]'</source>
        <target state="translated">Symbol "&gt;|]"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.MINUS">
        <source>symbol '-'</source>
        <target state="translated">Symbol "-"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.ADJACENT.PREFIX.OP">
        <source>prefix operator</source>
        <target state="translated">Präfixoperator</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.FUNKY.OPERATOR.NAME">
        <source>operator name</source>
        <target state="translated">Operatorname</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.COMMA">
        <source>symbol ','</source>
        <target state="translated">Symbol ","</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.DOT">
        <source>symbol '.'</source>
        <target state="translated">Symbol "."</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.BAR">
        <source>symbol '|'</source>
        <target state="translated">Symbol "|"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.HASH">
        <source>symbol #</source>
        <target state="translated">Symbol "#"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.UNDERSCORE">
        <source>symbol '_'</source>
        <target state="translated">Symbol "_"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.SEMICOLON">
        <source>symbol ';'</source>
        <target state="translated">Symbol ";"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.SEMICOLON.SEMICOLON">
        <source>symbol ';;'</source>
        <target state="translated">Symbol ";;"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LPAREN">
        <source>symbol '('</source>
        <target state="translated">Symbol "("</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.RPAREN">
        <source>symbol ')'</source>
        <target state="translated">Symbol ")"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.SPLICE.SYMBOL">
        <source>symbol 'splice'</source>
        <target state="translated">Symbol "splice"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LQUOTE">
        <source>start of quotation</source>
        <target state="translated">Zitat Anfang</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LBRACK">
        <source>symbol '['</source>
        <target state="translated">Symbol "["</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LBRACK.BAR">
        <source>symbol '[|'</source>
        <target state="translated">Symbol "[|"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LBRACK.LESS">
        <source>symbol '[&lt;'</source>
        <target state="translated">Symbol "[&lt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LBRACE">
        <source>symbol '{'</source>
        <target state="translated">Symbol "{"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LBRACE.LESS">
        <source>symbol '{&lt;'</source>
        <target state="translated">Symbol "{&lt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.BAR.RBRACK">
        <source>symbol '|]'</source>
        <target state="translated">Symbol "|]"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.GREATER.RBRACE">
        <source>symbol '&gt;}'</source>
        <target state="translated">Symbol "&gt;}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.GREATER.RBRACK">
        <source>symbol '&gt;]'</source>
        <target state="translated">Symbol "&gt;]"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.RQUOTE">
        <source>end of quotation</source>
        <target state="translated">Zitat Ende</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.RBRACK">
        <source>symbol ']'</source>
        <target state="translated">Symbol "]"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.RBRACE">
        <source>symbol '}'</source>
        <target state="translated">Symbol "}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.PUBLIC">
        <source>keyword 'public'</source>
        <target state="translated">Schlüsselwort "public"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.PRIVATE">
        <source>keyword 'private'</source>
        <target state="translated">Schlüsselwort "private"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INTERNAL">
        <source>keyword 'internal'</source>
        <target state="translated">Schlüsselwort "internal"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.FIXED">
        <source>keyword 'fixed'</source>
        <target state="translated">Schlüsselwort "fixed"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.CONSTRAINT">
        <source>keyword 'constraint'</source>
        <target state="translated">Schlüsselwort "constraint"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INSTANCE">
        <source>keyword 'instance'</source>
        <target state="translated">Schlüsselwort "instance"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.DELEGATE">
        <source>keyword 'delegate'</source>
        <target state="translated">Schlüsselwort "delegate"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INHERIT">
        <source>keyword 'inherit'</source>
        <target state="translated">Schlüsselwort "inherit"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.CONSTRUCTOR">
        <source>keyword 'constructor'</source>
        <target state="translated">Schlüsselwort "constructor"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.DEFAULT">
        <source>keyword 'default'</source>
        <target state="translated">Schlüsselwort "default"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OVERRIDE">
        <source>keyword 'override'</source>
        <target state="translated">Schlüsselwort "override"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.ABSTRACT">
        <source>keyword 'abstract'</source>
        <target state="translated">Schlüsselwort "abstract"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.CLASS">
        <source>keyword 'class'</source>
        <target state="translated">Schlüsselwort "class"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.MEMBER">
        <source>keyword 'member'</source>
        <target state="translated">Schlüsselwort "member"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.STATIC">
        <source>keyword 'static'</source>
        <target state="translated">Schlüsselwort "static"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.NAMESPACE">
        <source>keyword 'namespace'</source>
        <target state="translated">Schlüsselwort "namespace"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OBLOCKBEGIN">
        <source>start of structured construct</source>
        <target state="translated">Anfang des strukturierten Konstrukts</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OBLOCKEND">
        <source>incomplete structured construct at or before this point</source>
        <target state="translated">Unvollständig strukturiertes Konstrukt vor oder bis zu diesem Punkt</target>
        <note />
      </trans-unit>
      <trans-unit id="BlockEndSentence">
        <source>Incomplete structured construct at or before this point</source>
        <target state="translated">Unvollständig strukturiertes Konstrukt vor oder bis zu diesem Punkt</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OTHEN">
        <source>keyword 'then'</source>
        <target state="translated">Schlüsselwort "then"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OELSE">
        <source>keyword 'else'</source>
        <target state="translated">Schlüsselwort "else"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OLET">
        <source>keyword 'let' or 'use'</source>
        <target state="translated">Schlüsselwort "let" oder "use"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.BINDER">
        <source>binder keyword</source>
        <target state="translated">Schlüsselwort "binder"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.ODO">
        <source>keyword 'do'</source>
        <target state="translated">Schlüsselwort "do"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.CONST">
        <source>keyword 'const'</source>
        <target state="translated">Schlüsselwort "const"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OWITH">
        <source>keyword 'with'</source>
        <target state="translated">Schlüsselwort "with"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OFUNCTION">
        <source>keyword 'function'</source>
        <target state="translated">Schlüsselwort "function"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OFUN">
        <source>keyword 'fun'</source>
        <target state="translated">Schlüsselwort "fun"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.ORESET">
        <source>end of input</source>
        <target state="translated">Ende der Eingabe</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.ODUMMY">
        <source>internal dummy token</source>
        <target state="translated">internes Platzhaltertoken</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.ODO.BANG">
        <source>keyword 'do!'</source>
        <target state="translated">Schlüsselwort "do!"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.YIELD">
        <source>yield</source>
        <target state="translated">yield</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.YIELD.BANG">
        <source>yield!</source>
        <target state="translated">yield!</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OINTERFACE.MEMBER">
        <source>keyword 'interface'</source>
        <target state="translated">Schlüsselwort "interface"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.ELIF">
        <source>keyword 'elif'</source>
        <target state="translated">Schlüsselwort "elif"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.RARROW">
        <source>symbol '-&gt;'</source>
        <target state="translated">Symbol "-&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.SIG">
        <source>keyword 'sig'</source>
        <target state="translated">Schlüsselwort "sig"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.STRUCT">
        <source>keyword 'struct'</source>
        <target state="translated">Schlüsselwort "struct"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.UPCAST">
        <source>keyword 'upcast'</source>
        <target state="translated">Schlüsselwort "upcast"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.DOWNCAST">
        <source>keyword 'downcast'</source>
        <target state="translated">Schlüsselwort "downcast"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.NULL">
        <source>keyword 'null'</source>
        <target state="translated">Schlüsselwort "null"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.RESERVED">
        <source>reserved keyword</source>
        <target state="translated">reserviertes Schlüsselwort</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.MODULE">
        <source>keyword 'module'</source>
        <target state="translated">Schlüsselwort "module"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.AND">
        <source>keyword 'and'</source>
        <target state="translated">Schlüsselwort "and"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.AS">
        <source>keyword 'as'</source>
        <target state="translated">Schlüsselwort "as"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.ASSERT">
        <source>keyword 'assert'</source>
        <target state="translated">Schlüsselwort "assert"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.ASR">
        <source>keyword 'asr'</source>
        <target state="translated">Schlüsselwort "asr"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.DOWNTO">
        <source>keyword 'downto'</source>
        <target state="translated">Schlüsselwort "downto"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.EXCEPTION">
        <source>keyword 'exception'</source>
        <target state="translated">Schlüsselwort "exception"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.FALSE">
        <source>keyword 'false'</source>
        <target state="translated">Schlüsselwort "false"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.FOR">
        <source>keyword 'for'</source>
        <target state="translated">Schlüsselwort "for"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.FUN">
        <source>keyword 'fun'</source>
        <target state="translated">Schlüsselwort "fun"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.FUNCTION">
        <source>keyword 'function'</source>
        <target state="translated">Schlüsselwort "function"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.FINALLY">
        <source>keyword 'finally'</source>
        <target state="translated">Schlüsselwort "finally"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LAZY">
        <source>keyword 'lazy'</source>
        <target state="translated">Schlüsselwort "lazy"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.MATCH">
        <source>keyword 'match'</source>
        <target state="translated">Schlüsselwort "match"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.MATCH.BANG">
        <source>keyword 'match!'</source>
        <target state="translated">Schlüsselwort "match!"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.MUTABLE">
        <source>keyword 'mutable'</source>
        <target state="translated">Schlüsselwort "mutable"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.NEW">
        <source>keyword 'new'</source>
        <target state="translated">Schlüsselwort "new"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OF">
        <source>keyword 'of'</source>
        <target state="translated">Schlüsselwort "of"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OPEN">
        <source>keyword 'open'</source>
        <target state="translated">Schlüsselwort "open"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.OR">
        <source>keyword 'or'</source>
        <target state="translated">Schlüsselwort "or"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.VOID">
        <source>keyword 'void'</source>
        <target state="translated">Schlüsselwort "void"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.EXTERN">
        <source>keyword 'extern'</source>
        <target state="translated">Schlüsselwort "extern"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INTERFACE">
        <source>keyword 'interface'</source>
        <target state="translated">Schlüsselwort "interface"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.REC">
        <source>keyword 'rec'</source>
        <target state="translated">Schlüsselwort "rec"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.TO">
        <source>keyword 'to'</source>
        <target state="translated">Schlüsselwort "to"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.TRUE">
        <source>keyword 'true'</source>
        <target state="translated">Schlüsselwort "true"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.TRY">
        <source>keyword 'try'</source>
        <target state="translated">Schlüsselwort "try"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.TYPE">
        <source>keyword 'type'</source>
        <target state="translated">Schlüsselwort "type"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.VAL">
        <source>keyword 'val'</source>
        <target state="translated">Schlüsselwort "val"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INLINE">
        <source>keyword 'inline'</source>
        <target state="translated">Schlüsselwort "inline"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.WHEN">
        <source>keyword 'when'</source>
        <target state="translated">Schlüsselwort "when"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.WHILE">
        <source>keyword 'while'</source>
        <target state="translated">Schlüsselwort "while"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.WITH">
        <source>keyword 'with'</source>
        <target state="translated">Schlüsselwort "with"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.IF">
        <source>keyword 'if'</source>
        <target state="translated">Schlüsselwort "if"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.DO">
        <source>keyword 'do'</source>
        <target state="translated">Schlüsselwort "do"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.GLOBAL">
        <source>keyword 'global'</source>
        <target state="translated">Schlüsselwort "global"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.DONE">
        <source>keyword 'done'</source>
        <target state="translated">Schlüsselwort "done"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.IN">
        <source>keyword 'in'</source>
        <target state="translated">Schlüsselwort "in"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.HIGH.PRECEDENCE.PAREN.APP">
        <source>symbol '('</source>
        <target state="translated">Symbol "("</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.HIGH.PRECEDENCE.BRACK.APP">
        <source>symbol'['</source>
        <target state="translated">Symbol "["</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.BEGIN">
        <source>keyword 'begin'</source>
        <target state="translated">Schlüsselwort "begin"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.END">
        <source>keyword 'end'</source>
        <target state="translated">Schlüsselwort "end"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.HASH.ENDIF">
        <source>directive</source>
        <target state="translated">Direktive</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.INACTIVECODE">
        <source>inactive code</source>
        <target state="translated">inaktiver Code</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LEX.FAILURE">
        <source>lex failure</source>
        <target state="translated">Lexfehler</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.WHITESPACE">
        <source>whitespace</source>
        <target state="translated">Leerzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.COMMENT">
        <source>comment</source>
        <target state="translated">Kommentar</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LINE.COMMENT">
        <source>line comment</source>
        <target state="translated">Zeilenkommentar</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.STRING.TEXT">
        <source>string text</source>
        <target state="translated">Zeichenfolgentext</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.KEYWORD_STRING">
        <source>compiler generated literal</source>
        <target state="translated">vom Compiler generiertes Literal</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.BYTEARRAY">
        <source>byte array literal</source>
        <target state="translated">Bytearrayliteral</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.STRING">
        <source>string literal</source>
        <target state="translated">Zeichenfolgenliteral</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.EOF">
        <source>end of input</source>
        <target state="translated">Ende der Eingabe</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfInput">
        <source>Unexpected end of input</source>
        <target state="translated">Unerwartetes Ende der Eingabe</target>
        <note />
      </trans-unit>
      <trans-unit id="Unexpected">
        <source>Unexpected {0}</source>
        <target state="translated">Unerwartete(s/r) {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.interaction">
        <source> in interaction</source>
        <target state="translated"> in Interaktion</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.hashDirective">
        <source> in directive</source>
        <target state="translated"> in Direktive</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.fieldDecl">
        <source> in field declaration</source>
        <target state="translated"> in Felddeklaration</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.unionCaseRepr">
        <source> in discriminated union case declaration</source>
        <target state="translated"> in diskriminierter Union-Falldeklaration</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.localBinding">
        <source> in binding</source>
        <target state="translated"> in Bindung</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.hardwhiteLetBindings">
        <source> in binding</source>
        <target state="translated"> in Bindung</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.classDefnMember">
        <source> in member definition</source>
        <target state="translated"> in Memberdefinition</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.defnBindings">
        <source> in definitions</source>
        <target state="translated"> in Definitionen</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.classMemberSpfn">
        <source> in member signature</source>
        <target state="translated"> in Membersignatur</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.valSpfn">
        <source> in value signature</source>
        <target state="translated"> in Wertsignatur</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.tyconSpfn">
        <source> in type signature</source>
        <target state="translated"> in Typsignatur</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.anonLambdaExpr">
        <source> in lambda expression</source>
        <target state="translated"> in lambda-Ausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.attrUnionCaseDecl">
        <source> in union case</source>
        <target state="translated"> in Union-Fall</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.cPrototype">
        <source> in extern declaration</source>
        <target state="translated"> in externer Deklaration</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.objectImplementationMembers">
        <source> in object expression</source>
        <target state="translated"> in Objektausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.ifExprCases">
        <source> in if/then/else expression</source>
        <target state="translated"> in if/then/else-Ausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.openDecl">
        <source> in open declaration</source>
        <target state="translated"> in open-Deklaration</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.fileModuleSpec">
        <source> in module or namespace signature</source>
        <target state="translated"> in Modul- oder Namespacesignatur</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.patternClauses">
        <source> in pattern matching</source>
        <target state="translated"> in Mustervergleich</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.beginEndExpr">
        <source> in begin/end expression</source>
        <target state="translated"> in begin/end-Ausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.recdExpr">
        <source> in record expression</source>
        <target state="translated"> in Datensatzausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.tyconDefn">
        <source> in type definition</source>
        <target state="translated"> in Typdefinition</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.exconCore">
        <source> in exception definition</source>
        <target state="translated"> in Ausnahmedefinition</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.typeNameInfo">
        <source> in type name</source>
        <target state="translated"> in Typname</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.attributeList">
        <source> in attribute list</source>
        <target state="translated"> in Attributliste</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.quoteExpr">
        <source> in quotation literal</source>
        <target state="translated"> in Quotation-Literal</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.typeConstraint">
        <source> in type constraint</source>
        <target state="translated"> in Typeinschränkung</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.Category.ImplementationFile">
        <source> in implementation file</source>
        <target state="translated"> in Implementierungsdatei</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.Category.Definition">
        <source> in definition</source>
        <target state="translated"> in Definition</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.Category.SignatureFile">
        <source> in signature file</source>
        <target state="translated"> in Signaturdatei</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.Category.Pattern">
        <source> in pattern</source>
        <target state="translated"> in Muster</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.Category.Expr">
        <source> in expression</source>
        <target state="translated"> in Ausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.Category.Type">
        <source> in type</source>
        <target state="translated"> in Typ</target>
        <note />
      </trans-unit>
      <trans-unit id="NONTERM.typeArgsActual">
        <source> in type arguments</source>
        <target state="translated"> in Typargumenten</target>
        <note />
      </trans-unit>
      <trans-unit id="FixKeyword">
        <source>keyword </source>
        <target state="translated">Schlüsselwort</target>
        <note />
      </trans-unit>
      <trans-unit id="FixSymbol">
        <source>symbol </source>
        <target state="translated">Symbol </target>
        <note />
      </trans-unit>
      <trans-unit id="FixReplace">
        <source> (due to indentation-aware syntax)</source>
        <target state="translated"> (aufgrund der einzugsabhängigen Syntax)</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenName1">
        <source>. Expected {0} or other token.</source>
        <target state="translated">. "{0}" oder ein anderes Token wurde erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenName1TokenName2">
        <source>. Expected {0}, {1} or other token.</source>
        <target state="translated">. "{0}", "{1}" oder ein anderes Token wurde erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenName1TokenName2TokenName3">
        <source>. Expected {0}, {1}, {2} or other token.</source>
        <target state="translated">. "{0}", "{1}", "{2}" oder ein anderes Token wurde erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeCoercionSourceSealed1">
        <source>The type '{0}' cannot be used as the source of a type test or runtime coercion</source>
        <target state="translated">Der Typ "{0}" kann nicht als Quelle eines Typtests oder einer Laufzeitkoersion verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeCoercionSourceSealed2">
        <source>The type '{0}' does not have any proper subtypes and cannot be used as the source of a type test or runtime coercion.</source>
        <target state="translated">Der Typ "{0}" besitzt keine geeigneten Untertypen und kann nicht als Quelle eines Typtests oder einer Laufzeitkoersion verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="CoercionTargetSealed">
        <source>The type '{0}' does not have any proper subtypes and need not be used as the target of a static coercion</source>
        <target state="translated">Der Typ "{0}" besitzt keine geeigneten Untertypen und darf nicht als Ziel einer statischen Koersion verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="UpcastUnnecessary">
        <source>This upcast is unnecessary - the types are identical</source>
        <target state="translated">Diese Typumwandlung nach oben (Upcast) ist nicht notwendig, da die Typen identisch sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeTestUnnecessary">
        <source>This type test or downcast will always hold</source>
        <target state="translated">Dieser Typtest oder diese Typumwandlung nach unten (Downcast) ist immer erfolgreich.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideDoesntOverride1">
        <source>The member '{0}' does not have the correct type to override any given virtual method</source>
        <target state="translated">Der Member "{0}" weist nicht den richtigen Typ auf, um eine beliebige virtuelle Methode zu überschreiben.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideDoesntOverride2">
        <source>The member '{0}' does not have the correct type to override the corresponding abstract method.</source>
        <target state="translated">Der Member "{0}" weist nicht den richtigen Typ auf, um die entsprechende abstrakte Methode zu überschreiben.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideDoesntOverride3">
        <source> The required signature is '{0}'.</source>
        <target state="translated"> Die erforderliche Signatur lautet "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideDoesntOverride4">
        <source>The member '{0}' is specialized with 'unit' but 'unit' can't be used as return type of an abstract method parameterized on return type.</source>
        <target state="translated">Der Member "{0}" ist mit "unit" spezialisiert, "unit" kann aber nicht als Rückgabetyp einer abstrakten Methode verwendet werden, die für den Rückgabetyp parametrisiert wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnionCaseWrongArguments">
        <source>This constructor is applied to {0} argument(s) but expects {1}</source>
        <target state="translated">Dieser Konstruktor wird auf {0} Argument(e) angewendet, erwartet aber {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnionPatternsBindDifferentNames">
        <source>The two sides of this 'or' pattern bind different sets of variables</source>
        <target state="translated">Die beiden Seiten dieses or-Musters binden unterschiedliche Variablensätze.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContained">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \n{3}.</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \n{3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredButNotSpecified">
        <source>Module '{0}' requires a {1} '{2}'</source>
        <target state="translated">Das Modul "{0}" erfordert eine(n) {1} "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOfAddressOfOperator">
        <source>The use of native pointers may result in unverifiable .NET IL code</source>
        <target state="translated">Durch die Verwendung von nativen Zeigern kann nicht verifizierbarer .NET-IL-Code entstehen.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefensiveCopyWarning">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedThreadStaticBindingWarning">
        <source>Thread static and context static 'let' bindings are deprecated. Instead use a declaration of the form 'static val mutable &lt;ident&gt; : &lt;type&gt;' in a class. Add the 'DefaultValue' attribute to this declaration to indicate that the value is initialized to the default value on each new thread.</source>
        <target state="translated">Threadstatische und kontextstatische "let"-Bindungen sind veraltet. Verwenden Sie stattdessen eine Deklaration im Format "static val mutable &lt;ident&gt; : &lt;type&gt;" in einer Klasse. Fügen Sie dieser Deklaration das DefaultValue-Attribut hinzu, um anzugeben, dass der Wert bei jedem neuen Thread mit dem Standardwert initialisiert wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionValueUnexpected">
        <source>This expression is a function value, i.e. is missing arguments. Its type is {0}.</source>
        <target state="translated">Dieser Ausdruck ist ein Funktionswert, d.h., es fehlen Argumente. Typ: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitTypeExpected">
        <source>The result of this expression has type '{0}' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |&gt; ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.</source>
        <target state="translated">Das Ergebnis dieses Ausdrucks hat den Typ "{0}" und wird implizit ignoriert. Verwenden Sie "ignore", um diesen Wert explizit zu verwerfen, z.B. "expr |&gt; ignore", oder "let", um das Ergebnis an einen Namen zu binden, z.B. "let result = expr".</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitTypeExpectedWithEquality">
        <source>The result of this equality expression has type '{0}' and is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'.</source>
        <target state="translated">Das Ergebnis dieses Gleichheitsausdrucks weist den Typ "{0}" auf und wird implizit verworfen. Verwenden Sie ggf. "let", um das Ergebnis an einen Namen zu binden. Beispiel: "let Ergebnis = Ausdruck".</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitTypeExpectedWithPossiblePropertySetter">
        <source>The result of this equality expression has type '{0}' and is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to set a value to a property, then use the '&lt;-' operator e.g. '{1}.{2} &lt;- expression'.</source>
        <target state="translated">Das Ergebnis dieses Gleichheitsausdrucks weist den Typ "{0}" auf und wird implizit verworfen. Verwenden Sie ggf. "let", um das Ergebnis an einen Namen zu binden. Beispiel: "let Ergebnis = Ausdruck". Falls Sie einen Wert auf eine Eigenschaft festlegen möchten, verwenden Sie den Operator "&lt;-". Beispiel: "{1}.{2} &lt;- Ausdruck".</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitTypeExpectedWithPossibleAssignment">
        <source>The result of this equality expression has type '{0}' and is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to mutate a value, then mark the value 'mutable' and use the '&lt;-' operator e.g. '{1} &lt;- expression'.</source>
        <target state="translated">Das Ergebnis dieses Gleichheitsausdrucks weist den Typ "{0}" auf und wird implizit verworfen. Verwenden Sie ggf. "let", um das Ergebnis an einen Namen zu binden. Beispiel: "let Ergebnis = Ausdruck". Falls Sie einen Wert mutieren möchten, markieren Sie ihn als "mutable", und verwenden Sie den Operator "&lt;-" . Beispiel: "{1} &lt;- Ausdruck".</target>
        <note />
      </trans-unit>
      <trans-unit id="UnitTypeExpectedWithPossibleAssignmentToMutable">
        <source>The result of this equality expression has type '{0}' and is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to mutate a value, then use the '&lt;-' operator e.g. '{1} &lt;- expression'.</source>
        <target state="translated">Das Ergebnis dieses Gleichheitsausdrucks weist den Typ "{0}" auf und wird implizit verworfen. Verwenden Sie ggf. "let", um das Ergebnis an einen Namen zu binden. Beispiel: "let Ergebnis = Ausdruck". Falls Sie einen Wert mutieren möchten, verwenden Sie den Operator "&lt;-". Beispiel: "{1} &lt;- Ausdruck".</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveUseCheckedAtRuntime">
        <source>This recursive use will be checked for initialization-soundness at runtime. This warning is usually harmless, and may be suppressed by using '#nowarn "21"' or '--nowarn:21'.</source>
        <target state="translated">Diese rekursive Verwendung wird zur Laufzeit auf ihre ordnungsgemäße Initialisierung geprüft. Diese Warnung ist in der Regel harmlos und kann mithilfe von "#nowarn "21"" oder "--nowarn 21" unterdrückt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetRecUnsound1">
        <source>The value '{0}' will be evaluated as part of its own definition</source>
        <target state="translated">Der Wert "{0}" wird als Teil seiner eigenen Definition ausgewertet.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetRecUnsound2">
        <source>This value will be eventually evaluated as part of its own definition. You may need to make the value lazy or a function. Value '{0}'{1}.</source>
        <target state="translated">Dieser Wert wird schließlich als Teil seiner eigenen Definition ausgewertet. Möglicherweise müssen Sie den Wert verzögern oder als Funktion festlegen. Wert "{0}"{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetRecUnsoundInner">
        <source> will evaluate '{0}'</source>
        <target state="translated"> wird zu "{0}" ausgewertet</target>
        <note />
      </trans-unit>
      <trans-unit id="LetRecEvaluatedOutOfOrder">
        <source>Bindings may be executed out-of-order because of this forward reference.</source>
        <target state="translated">Bindungen werden aufgrund dieses Vorwärtsverweises möglicherweise in der falschen Reihenfolge ausgeführt.</target>
        <note />
      </trans-unit>
      <trans-unit id="LetRecCheckedAtRuntime">
        <source>This and other recursive references to the object(s) being defined will be checked for initialization-soundness at runtime through the use of a delayed reference. This is because you are defining one or more recursive objects, rather than recursive functions. This warning may be suppressed by using '#nowarn "40"' or '--nowarn:40'.</source>
        <target state="translated">Dieser und andere rekursive Verweise auf das bzw. die definierte(n) Objekt(e) werden zur Laufzeit mithilfe eines verzögerten Verweises auf ihre ordnungsgemäße Initialisierung geprüft. Der Grund hierfür ist, dass Sie mindestens ein rekursives Objekt definieren, keine rekursiven Funktionen. Diese Warnung kann mithilfe von "#nowarn "40"" oder "--nowarn 40" unterdrückt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="SelfRefObjCtor1">
        <source>Recursive references to the object being defined will be checked for initialization soundness at runtime through the use of a delayed reference. Consider placing self-references in members or within a trailing expression of the form '&lt;ctor-expr&gt; then &lt;expr&gt;'.</source>
        <target state="translated">Rekursive Verweise auf das definierte Objekt werden zur Laufzeit mithilfe eines verzögerten Verweises auf ihre ordnungsgemäße Initialisierung geprüft. Sie sollten in Membern oder innerhalb eines nachgestellten Ausdrucks Eigenverweise im Format "&lt;ctor-expr&gt; then &lt;expr&gt;" platzieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="SelfRefObjCtor2">
        <source>Recursive references to the object being defined will be checked for initialization soundness at runtime through the use of a delayed reference. Consider placing self-references within 'do' statements after the last 'let' binding in the construction sequence.</source>
        <target state="translated">Rekursive Verweise auf das definierte Objekt werden zur Laufzeit mithilfe eines verzögerten Verweises auf ihre ordnungsgemäße Iniitalisierung geprüft. Sie sollten in do-Anweisungen hinter der letzten let-Bindung in der Konstruktionssequenz Eigenverweise platzieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="VirtualAugmentationOnNullValuedType">
        <source>The containing type can use 'null' as a representation value for its nullary union case. Invoking an abstract or virtual member or an interface implementation on a null value will lead to an exception. If necessary add a dummy data value to the nullary constructor to avoid 'null' being used as a representation for this type.</source>
        <target state="translated">Der enthaltende Typ kann NULL als Darstellungswert für seinen nullären Union-Fall verwenden. Das Aufrufen eines abstrakten oder virtuellen Members oder einer Schnittstellenimplementierung für einen NULL-Wert verursacht eine Ausnahme. Fügen Sie dem nullären Konstruktor bei Bedarf einen Platzhalterdatenwert hinzu, damit NULL nicht als Darstellung für diesen Typ verwendet wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonVirtualAugmentationOnNullValuedType">
        <source>The containing type can use 'null' as a representation value for its nullary union case. This member will be compiled as a static member.</source>
        <target state="translated">Der enthaltende Typ kann NULL als Darstellungswert für seinen nullären Union-Fall verwenden. Dieser Member wird als statischer Member kompiliert.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonUniqueInferredAbstractSlot1">
        <source>The member '{0}' doesn't correspond to a unique abstract slot based on name and argument count alone</source>
        <target state="translated">Der Member "{0}" kann anhand des Namens und der Anzahl der Argumente keinem eindeutigen abstrakten Umsetzungsplatz zugeordnet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonUniqueInferredAbstractSlot2">
        <source>. Multiple implemented interfaces have a member with this name and argument count</source>
        <target state="translated">. Mehrere implementierte Schnittstellen besitzen einen Member mit diesem Namen und dieser Anzahl von Argumenten.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonUniqueInferredAbstractSlot3">
        <source>. Consider implementing interfaces '{0}' and '{1}' explicitly.</source>
        <target state="translated">. Implementieren Sie die {0}-Schnittstelle und die {1}-Schnittstelle explizit.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonUniqueInferredAbstractSlot4">
        <source>. Additional type annotations may be required to indicate the relevant override. This warning can be disabled using '#nowarn "70"' or '--nowarn:70'.</source>
        <target state="translated">. Möglicherweise sind zusätzliche Typanmerkungen erforderlich, um die relevante Überschreibung anzugeben. Diese Warnung kann mit "#nowarn "70"" oder "--nowarn 70" deaktiviert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Failure1">
        <source>parse error</source>
        <target state="translated">Analysefehler</target>
        <note />
      </trans-unit>
      <trans-unit id="Failure2">
        <source>parse error: unexpected end of file</source>
        <target state="translated">Analysefehler: Unerwartetes Ende der Datei.</target>
        <note />
      </trans-unit>
      <trans-unit id="Failure3">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Failure4">
        <source>internal error: {0}</source>
        <target state="translated">Interner Fehler: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="FullAbstraction">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchIncomplete1">
        <source>Incomplete pattern matches on this expression.</source>
        <target state="translated">Unvollständige Musterübereinstimmungen für diesen Ausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchIncomplete2">
        <source> For example, the value '{0}' may indicate a case not covered by the pattern(s).</source>
        <target state="translated"> Beispielsweise kann der Wert "{0}" einen Fall kennzeichnen, der nicht von dem bzw. den Muster(n) abgedeckt wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchIncomplete3">
        <source> For example, the value '{0}' may indicate a case not covered by the pattern(s). However, a pattern rule with a 'when' clause might successfully match this value.</source>
        <target state="translated"> Beispielsweise kann der Wert "{0}" einen Fall kennzeichnen, der nicht von dem bzw. den Muster(n) abgedeckt wird. Mit einer Musterregel mit einer when-Klausel kann dieser Wert allerdings unter Umständen erfolgreich abgeglichen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="MatchIncomplete4">
        <source> Unmatched elements will be ignored.</source>
        <target state="translated"> Nicht zugeordnete Elemente werden ignoriert.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumMatchIncomplete1">
        <source>Enums may take values outside known cases.</source>
        <target state="translated">Enumerationen können Werte außerhalb bekannter Fälle verwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="RuleNeverMatched">
        <source>This rule will never be matched</source>
        <target state="translated">Für diese Regel wird niemals eine Übereinstimmung gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValNotMutable">
        <source>This value is not mutable. Consider using the mutable keyword, e.g. 'let mutable {0} = expression'.</source>
        <target state="translated">Dieser Wert ist nicht änderbar. Verwenden Sie ggf. ein änderbares Schlüsselwort, z.B. "let mutable {0} = Ausdruck".</target>
        <note />
      </trans-unit>
      <trans-unit id="ValNotLocal">
        <source>This value is not local</source>
        <target state="translated">Dieser Wert ist nicht lokal.</target>
        <note />
      </trans-unit>
      <trans-unit id="Obsolete1">
        <source>This construct is deprecated</source>
        <target state="translated">Dieses Konstrukt ist veraltet.</target>
        <note />
      </trans-unit>
      <trans-unit id="Obsolete2">
        <source>. {0}</source>
        <target state="translated">. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Experimental">
        <source>{0}. This warning can be disabled using '--nowarn:57' or '#nowarn "57"'.</source>
        <target state="translated">{0}. Diese Warnung kann mit "--nowarn 57" oder "#nowarn "57"" deaktiviert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="PossibleUnverifiableCode">
        <source>Uses of this construct may result in the generation of unverifiable .NET IL code. This warning can be disabled using '--nowarn:9' or '#nowarn "9"'.</source>
        <target state="translated">Die Verwendung dieses Konstrukts kann die Erzeugung von nicht verifizierbarem .NET-IL-Code zur Folge haben. Diese Warnung kann mit "--nowarn 9" oder "#nowarn "9"" deaktiviert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Deprecated">
        <source>This construct is deprecated: {0}</source>
        <target state="translated">Dieses Konstrukt ist veraltet: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="LibraryUseOnly">
        <source>This construct is deprecated: it is only for use in the F# library</source>
        <target state="translated">Dieses Konstrukt ist veraltet: Es wird nur in der F#-Bibliothek verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingFields">
        <source>The following fields require values: {0}</source>
        <target state="translated">Für die folgenden Felder sind Werte erforderlich: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueRestriction1">
        <source>Value restriction. The value '{0}' has generic type\n    {1}    \nEither make the arguments to '{2}' explicit or, if you do not intend for it to be generic, add a type annotation.</source>
        <target state="translated">Werteinschränkung. Der Wert "{0}" hat den generischen Typ\n    {1}    \nLegen Sie die Argumente für "{2}" entweder als explizit fest, oder fügen Sie eine Typanmerkung hinzu, wenn der Typ nicht generisch sein soll.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueRestriction2">
        <source>Value restriction. The value '{0}' has generic type\n    {1}    \nEither make '{2}' into a function with explicit arguments or, if you do not intend for it to be generic, add a type annotation.</source>
        <target state="translated">Werteinschränkung. Der Wert "{0}" hat den generischen Typ\n    {1}    \nDefinieren Sie "{2}" entweder als Funktion mit expliziten Argumenten, oder fügen Sie eine Typanmerkung hinzu, wenn der Typ nicht generisch sein soll.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueRestriction3">
        <source>Value restriction. This member has been inferred to have generic type\n    {0}    \nConstructors and property getters/setters cannot be more generic than the enclosing type.  Add a type annotation to indicate the exact types involved.</source>
        <target state="translated">Werteinschränkung. Dieser Member wurde per Rückschluss abgeleitet als generischer Typ\n    {0}    \nKonstruktoren und Eigenschaftengetter/-setter dürfen nicht generischer sein als der einschließende Typ. Fügen Sie eine Typanmerkung hinzu, um die genauen Typen anzugeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueRestriction4">
        <source>Value restriction. The value '{0}' has been inferred to have generic type\n    {1}    \nEither make the arguments to '{2}' explicit or, if you do not intend for it to be generic, add a type annotation.</source>
        <target state="translated">Werteinschränkung. Der Wert "{0}" wurde per Rückschluss abgeleitet als generischer Typ\n    {1}    \nLegen Sie die Argumente für "{2}" entweder als explizit fest, oder fügen Sie eine Typanmerkung hinzu, wenn der Typ nicht generisch sein soll.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueRestriction5">
        <source>Value restriction. The value '{0}' has been inferred to have generic type\n    {1}    \nEither define '{2}' as a simple data term, make it a function with explicit arguments or, if you do not intend for it to be generic, add a type annotation.</source>
        <target state="translated">Werteinschränkung. Der Wert "{0}" wurde per Rückschluss abgeleitet als generischer Typ\n    {1}    \nDefinieren Sie "{2}" entweder als einfachen Ausdruck oder als Funktion mit expliziten Argumenten, oder fügen Sie eine Typanmerkung hinzu, wenn der Typ nicht generisch sein soll.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecoverableParseError">
        <source>syntax error</source>
        <target state="translated">Syntaxfehler</target>
        <note />
      </trans-unit>
      <trans-unit id="ReservedKeyword">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="IndentationProblem">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideInIntrinsicAugmentation">
        <source>Override implementations in augmentations are now deprecated. Override implementations should be given as part of the initial declaration of a type.</source>
        <target state="translated">Überschreibungsimplementierungen in Augmentationen sind jetzt veraltet. Überschreibungsimplementierungen sollten als Teil der ersten Deklaration eines Typs angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideInExtrinsicAugmentation">
        <source>Override implementations should be given as part of the initial declaration of a type.</source>
        <target state="translated">Überschreibungsimplementierungen sollten als Teil der ersten Deklaration eines Typs angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="IntfImplInIntrinsicAugmentation">
        <source>Interface implementations in augmentations are now deprecated. Interface implementations should be given on the initial declaration of a type.</source>
        <target state="translated">Schnittstellenimplementierungen in Augmentationen sind jetzt veraltet. Schnittstellenimplementierungen sollten in der ersten Deklaration eines Typs angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="IntfImplInExtrinsicAugmentation">
        <source>Interface implementations should be given on the initial declaration of a type.</source>
        <target state="translated">Schnittstellenimplementierungen sollten in der ersten Deklaration eines Typs angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnresolvedReferenceNoRange">
        <source>A required assembly reference is missing. You must add a reference to assembly '{0}'.</source>
        <target state="translated">Ein erforderlicher Assemblyverweis fehlt. Sie müssen einen Verweis auf Assembly "{0}" hinzufügen.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnresolvedPathReferenceNoRange">
        <source>The type referenced through '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.</source>
        <target state="translated">Der Typ, auf den über "{0}" verwiesen wird, wird in einer Assembly definiert, auf die nicht verwiesen wird. Sie müssen einen Verweis auf Assembly "{1}" hinzufügen.</target>
        <note />
      </trans-unit>
      <trans-unit id="HashIncludeNotAllowedInNonScript">
        <source>#I directives may only occur in F# script files (extensions .fsx or .fsscript). Either move this code to a script file, add a '-I' compiler option for this reference or delimit the directive with delimit it with '#if INTERACTIVE'/'#endif'.</source>
        <target state="translated">#I-Direktiven dürfen nur in F#-Skriptdateien (Dateierweiterungen .fsx oder .fsscript) verwendet werden. Verschieben Sie entweder diesen Code in eine Skriptdatei, fügen Sie die Compileroption "-I" für diesen Verweis hinzu, oder trennen Sie die Direktive mit "#if INTERACTIVE"/"#endif" ab.</target>
        <note />
      </trans-unit>
      <trans-unit id="HashReferenceNotAllowedInNonScript">
        <source>#r directives may only occur in F# script files (extensions .fsx or .fsscript). Either move this code to a script file or replace this reference with the '-r' compiler option. If this directive is being executed as user input, you may delimit it with '#if INTERACTIVE'/'#endif'.</source>
        <target state="translated">#r-Anweisungen dürfen nur in F#-Skriptdateien (Dateierweiterungen .fsx oder .fsscript) verwendet werden. Verschieben Sie entweder diesen Code in eine Skriptdatei, oder ersetzen Sie diesen Verweis durch die Compileroption "-r". Wenn diese Anweisung als Benutzereingabe ausgeführt wird, trennen Sie sie mit "#if INTERACTIVE"/"#endif" ab.</target>
        <note />
      </trans-unit>
      <trans-unit id="HashDirectiveNotAllowedInNonScript">
        <source>This directive may only be used in F# script files (extensions .fsx or .fsscript). Either remove the directive, move this code to a script file or delimit the directive with '#if INTERACTIVE'/'#endif'.</source>
        <target state="translated">Diese Direktive darf nur in F#-Skriptdateien (Dateierweiterungen .fsx oder .fsscript) verwendet werden. Entfernen Sie entweder die Direktive, verschieben Sie diesen Code in eine Skriptdatei, oder trennen Sie die Direktive mit "#if INTERACTIVE"/"#endif" ab.</target>
        <note />
      </trans-unit>
      <trans-unit id="FileNameNotResolved">
        <source>Unable to find the file '{0}' in any of\n {1}</source>
        <target state="translated">Die Datei "{0}" kann nicht gefunden werden in:\n {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyNotResolved">
        <source>Assembly reference '{0}' was not found or is invalid</source>
        <target state="translated">Der Assemblyverweis "{0}" wurde nicht gefunden oder ist ungültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="HashLoadedSourceHasIssues1">
        <source>One or more warnings in loaded file.\n</source>
        <target state="translated">Mindestens eine Warnung in geladener Datei.\n</target>
        <note />
      </trans-unit>
      <trans-unit id="HashLoadedSourceHasIssues2">
        <source>One or more errors in loaded file.\n</source>
        <target state="translated">Mindestens ein Fehler in geladener Datei.\n</target>
        <note />
      </trans-unit>
      <trans-unit id="HashLoadedScriptConsideredSource">
        <source>Loaded files may only be F# source files (extension .fs). This F# script file (.fsx or .fsscript) will be treated as an F# source file</source>
        <target state="translated">Geladene Dateien dürfen nur F#-Quellcodedateien (Dateierweiterung .fs) sein. Diese F#-Skriptdatei (.fsx oder .fsscript) wird wie eine F#-Quellcodedatei behandelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidInternalsVisibleToAssemblyName1">
        <source>Invalid assembly name '{0}' from InternalsVisibleTo attribute in {1}</source>
        <target state="translated">Ungültiger Assemblyname "{0}" aus dem InternalsVisibleTo-Attribut in "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidInternalsVisibleToAssemblyName2">
        <source>Invalid assembly name '{0}' from InternalsVisibleTo attribute (assembly filename not available)</source>
        <target state="translated">Ungültiger Assemblyname "{0}" aus dem InternalsVisibleTo-Attribut (Assemblydateiname nicht verfügbar).</target>
        <note />
      </trans-unit>
      <trans-unit id="LoadedSourceNotFoundIgnoring">
        <source>Could not load file '{0}' because it does not exist or is inaccessible</source>
        <target state="translated">Datei "{0}" konnte nicht geladen werden, weil sie nicht vorhanden oder nicht zugreifbar ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="MSBuildReferenceResolutionError">
        <source>{0} (Code={1})</source>
        <target state="translated">{0} (Code={1})</target>
        <note />
      </trans-unit>
      <trans-unit id="TargetInvocationExceptionWrapper">
        <source>internal error: {0}</source>
        <target state="translated">Interner Fehler: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.LBRACE.BAR">
        <source>symbol '{|'</source>
        <target state="translated">Symbol "{|"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.BAR.RBRACE">
        <source>symbol '|}'</source>
        <target state="translated">Symbol "|}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Parser.TOKEN.AND.BANG">
        <source>keyword 'and!'</source>
        <target state="translated">Schlüsselwort "and!"</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>