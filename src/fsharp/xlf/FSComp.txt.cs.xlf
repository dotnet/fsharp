<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="cs" original="../FSComp.resx">
    <body>
      <trans-unit id="undefinedNameNamespace">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">Není definovaný obor názvů {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespaceOrModule">
        <source>The namespace or module '{0}' is not defined.</source>
        <target state="translated">Není definovaný obor názvů nebo modul {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMember">
        <source>The field, constructor or member '{0}' is not defined.</source>
        <target state="translated">Není definované pole, konstruktor nebo člen {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueConstructorNamespaceOrType">
        <source>The value, constructor, namespace or type '{0}' is not defined.</source>
        <target state="translated">Není definovaný konstruktor, hodnota, obor názvů nebo typ {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueOfConstructor">
        <source>The value or constructor '{0}' is not defined.</source>
        <target state="translated">Není definovaná hodnota nebo konstruktor {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueNamespaceTypeOrModule">
        <source>The value, namespace, type or module '{0}' is not defined.</source>
        <target state="translated">Není definovaný obor názvů, hodnota, typ nebo modul {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameConstructorModuleOrNamespace">
        <source>The constructor, module or namespace '{0}' is not defined.</source>
        <target state="translated">Není definovaný konstruktor, modul nebo obor názvů {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameType">
        <source>The type '{0}' is not defined.</source>
        <target state="translated">Není definovaný typ {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeIn">
        <source>The type '{0}' is not defined in '{1}'.</source>
        <target state="translated">Typ {0} není definovaný v {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabelOrNamespace">
        <source>The record label or namespace '{0}' is not defined.</source>
        <target state="translated">Není definovaný popisek záznamů nebo obor názvů {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabel">
        <source>The record label '{0}' is not defined.</source>
        <target state="translated">Nemáte definovaný popisek záznamů {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameSuggestionsIntro">
        <source>Maybe you want one of the following:</source>
        <target state="translated">Možná budete potřebovat něco z tohoto:</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeParameter">
        <source>The type parameter {0} is not defined.</source>
        <target state="translated">Není definovaný parametr typu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNamePatternDiscriminator">
        <source>The pattern discriminator '{0}' is not defined.</source>
        <target state="translated">Není definovaný rozlišovací prvek vzorů {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="replaceWithSuggestion">
        <source>Replace with '{0}'</source>
        <target state="translated">Nahradit návrhem: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="addIndexerDot">
        <source>Add . for indexer access.</source>
        <target state="translated">Přidejte . pro přístup indexeru.</target>
        <note />
      </trans-unit>
      <trans-unit id="listElementHasWrongType">
        <source>All elements of a list constructor expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</source>
        <target state="translated">Všechny elementy výrazu konstruktoru seznamu musí mít stejný typ. Očekávalo se, že tento výraz bude mít typ {0}, ale tady je typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="arrayElementHasWrongType">
        <source>All elements of an array constructor expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</source>
        <target state="translated">Všechny elementy výrazu konstruktoru pole musí mít stejný typ. Očekávalo se, že tento výraz bude mít typ {0}, ale tady je typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="missingElseBranch">
        <source>The 'if' expression is missing an 'else' branch. The 'then' branch has type '{0}'. Because 'if' is an expression, and not a statement, add an 'else' branch which returns a value of the same type.</source>
        <target state="translated">Ve výrazu if chybí větev else. Větev then je typu {0}. Protože if je výraz a ne příkaz, přidejte větev else, která vrátí hodnotu stejného typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ifExpression">
        <source>The 'if' expression needs to have type '{0}' to satisfy context type requirements. It currently has type '{1}'.</source>
        <target state="translated">Aby se splnily požadavky na typ kontextu, musí mít výraz if typ {0}. V tuto chvíli má typ {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="elseBranchHasWrongType">
        <source>All branches of an 'if' expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</source>
        <target state="translated">Všechny větve výrazu if musí mít stejný typ. Očekávalo se, že tento výraz bude mít typ {0}, ale tady je typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="followingPatternMatchClauseHasWrongType">
        <source>All branches of a pattern match expression must return values of the same type. The first branch returned a value of type '{0}', but this branch returned a value of type '{1}'.</source>
        <target state="needs-review-translation">Všechny větve výrazu porovnání vzorů musí mít stejný typ. Očekávalo se, že tento výraz bude mít typ {0}, ale tady je typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="patternMatchGuardIsNotBool">
        <source>A pattern match guard must be of type 'bool', but this 'when' expression is of type '{0}'.</source>
        <target state="translated">Ochrana porovnání vzorů musí být typu bool, ale tento výraz when je typu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="commaInsteadOfSemicolonInRecord">
        <source>A ';' is used to separate field values in records. Consider replacing ',' with ';'.</source>
        <target state="translated">Pro oddělení hodnot v záznamech se používá znak ; (středník). Zvažte nahrazení znaků , (čárka) znaky ; (středník).</target>
        <note />
      </trans-unit>
      <trans-unit id="derefInsteadOfNot">
        <source>The '!' operator is used to dereference a ref cell. Consider using 'not expr' here.</source>
        <target state="translated">Operátor ! se používá k přístupu k buňce ref přes ukazatel. Zvažte možnost použít tady not expr.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedTypeArgs">
        <source>The non-generic type '{0}' does not expect any type arguments, but here is given {1} type argument(s)</source>
        <target state="translated">U typu {0}, který není obecný, se neočekávají žádné argumenty typu, ale tady se mu argumenty typu předávají ({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="returnUsedInsteadOfReturnBang">
        <source>Consider using 'return!' instead of 'return'.</source>
        <target state="translated">Zvažte použití parametru return! namísto return.</target>
        <note />
      </trans-unit>
      <trans-unit id="yieldUsedInsteadOfYieldBang">
        <source>Consider using 'yield!' instead of 'yield'.</source>
        <target state="translated">Zvažte použití parametru yield! namísto yield.</target>
        <note />
      </trans-unit>
      <trans-unit id="tupleRequiredInAbstractMethod">
        <source>\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.</source>
        <target state="translated">\nPro jeden nebo více argumentů se vyžaduje typ řazené kolekce členů. Zvažte možnost uzavřít dané argumenty do dodatečných závorek nebo zkontrolovat definici rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidWarningNumber">
        <source>Invalid warning number '{0}'</source>
        <target state="translated">Neplatné číslo upozornění {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionString">
        <source>Invalid version string '{0}'</source>
        <target state="translated">Neplatný řetězec verze {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionFile">
        <source>Invalid version file '{0}'</source>
        <target state="translated">Neplatný soubor verze {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProductName">
        <source>Microsoft (R) F# Compiler version {0}</source>
        <target state="translated">Microsoft (R) F# Compiler verze {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProductNameCommunity">
        <source>F# Compiler for F# {0}</source>
        <target state="translated">Kompilátor jazyka F# pro F# {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemWithFilename">
        <source>Problem with filename '{0}': {1}</source>
        <target state="translated">Problém s názvem souboru {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildNoInputsSpecified">
        <source>No inputs specified</source>
        <target state="translated">Nezadali jste žádné vstupy.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildPdbRequiresDebug">
        <source>The '--pdb' option requires the '--debug' option to be used</source>
        <target state="translated">Možnost --pdb vyžaduje použití možnosti --debug.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSearchDirectory">
        <source>The search directory '{0}' is invalid</source>
        <target state="translated">Adresář hledání {0} není platný.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSearchDirectoryNotFound">
        <source>The search directory '{0}' could not be found</source>
        <target state="translated">Adresář hledání {0} se nedal najít.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidFilename">
        <source>'{0}' is not a valid filename</source>
        <target state="translated">{0} není platný název souboru.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidAssemblyName">
        <source>'{0}' is not a valid assembly name</source>
        <target state="translated">{0} není platný název sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidPrivacy">
        <source>Unrecognized privacy setting '{0}' for managed resource, valid options are 'public' and 'private'</source>
        <target state="translated">Nerozpoznané nastavení ochrany osobních údajů {0} pro spravovaný prostředek. Platné možnosti jsou public a private.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleReferencesNotAllowed">
        <source>Multiple references to '{0}.dll' are not permitted</source>
        <target state="translated">Víc odkazů na knihovnu {0}.dll se nepovoluje.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotReadVersionInfoFromMscorlib">
        <source>Could not read version from mscorlib.dll</source>
        <target state="translated">Nedala se přečíst verze souboru mscorlib.dll.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCannotReadAssembly">
        <source>Unable to read assembly '{0}'</source>
        <target state="translated">Sestavení {0} se nedá přečíst.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildAssemblyResolutionFailed">
        <source>Assembly resolution failure at or near this location</source>
        <target state="translated">Došlo k selhání překladu sestavení na této pozici nebo blízko ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplicitModuleIsNotLegalIdentifier">
        <source>The declarations in this file will be placed in an implicit module '{0}' based on the file name '{1}'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file.</source>
        <target state="translated">Deklarace z tohoto souboru se umístí do implicitního modulu {0} založeného na názvu souboru {1}. To ale není platný identifikátor F#, takže obsah nebude dostupný z jiných souborů. Zvažte přejmenování souboru nebo přidání deklarace modulu nebo oboru názvů na jeho začátek.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultiFileRequiresNamespaceOrModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration.</source>
        <target state="translated">Soubory v knihovnách nebo aplikacích s víc soubory musí začínat deklarací oboru názvů nebo modulu, třeba namespace SomeNamespace.SubNamespace nebo module SomeNamespace.SomeModule. Tato deklarace se dá vynechat jenom u posledního zdrojového souboru aplikace.</target>
        <note />
      </trans-unit>
      <trans-unit id="noEqualSignAfterModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.</source>
        <target state="translated">Soubory v knihovnách nebo aplikacích s víc soubory musí začínat deklarací oboru názvů nebo modulu. Pokud na začátku souboru použijete deklaraci modulu, není povolený znak =. Pokud to je modul nejvyšší úrovně, zvažte odebrání znaku = pro vyřešení této chyby.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleToplevelModules">
        <source>This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules.</source>
        <target state="translated">Tento soubor obsahuje víc deklarací v podobě module SomeNamespace.SomeModule. V souboru se povoluje jenom jedna deklarace v této podobě. Upravte soubor tak, aby používal počáteční deklaraci oboru názvů, nebo použijte k definování modulů deklaraci v podobě module ModuleName = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="buildOptionRequiresParameter">
        <source>Option requires parameter: {0}</source>
        <target state="translated">Možnost vyžaduje parametr: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotFindSourceFile">
        <source>Source file '{0}' could not be found</source>
        <target state="translated">Zdrojový soubor {0} se nenašel.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSourceFileExtension">
        <source>The file extension of '{0}' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.</source>
        <target state="translated">Soubor {0} má nerozpoznanou příponu. Zdrojový soubor musí mít příponu .fs, .fsi, .fsx, .fsscript, .ml nebo .mli.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssembly">
        <source>Could not resolve assembly '{0}'</source>
        <target state="translated">Sestavení {0} se nedalo přeložit.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssemblyRequiredByFile">
        <source>Could not resolve assembly '{0}' required by '{1}'</source>
        <target state="translated">Sestavení {0} požadované souborem {1} se nedalo přeložit.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildErrorOpeningBinaryFile">
        <source>Error opening binary file '{0}': {1}</source>
        <target state="translated">Chyba při otevírání binárního souboru {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDifferentVersionMustRecompile">
        <source>The F#-compiled DLL '{0}' needs to be recompiled to be used with this version of F#</source>
        <target state="translated">Aby se knihovna DLL {0} zkompilovaná v F# dala použít v této verzi F#, musí se znovu zkompilovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashIDirective">
        <source>Invalid directive. Expected '#I \"&lt;path&gt;\"'.</source>
        <target state="translated">Neplatná direktiva. Očekávaná direktiva je #I \"&lt;cesta&gt;\".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashrDirective">
        <source>Invalid directive. Expected '#r \"&lt;file-or-assembly&gt;\"'.</source>
        <target state="translated">Neplatná direktiva. Očekávaná direktiva je #r \"&lt;file-or-assembly&gt;\".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashloadDirective">
        <source>Invalid directive. Expected '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</source>
        <target state="translated">Neplatná direktiva. Očekávaná direktiva je #load \"&lt;soubor&gt;\" ... \"&lt;soubor&gt;\".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashtimeDirective">
        <source>Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'.</source>
        <target state="translated">Neplatná direktiva. Očekávaná direktiva je #time, #time \"on\" nebo #time \"off\".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDirectivesInModulesAreIgnored">
        <source>Directives inside modules are ignored</source>
        <target state="translated">Direktivy uvnitř modulů se ignorují.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureAlreadySpecified">
        <source>A signature for the file or module '{0}' has already been specified</source>
        <target state="translated">Signatura pro soubor nebo modul {0} už je zadaná.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGivenDetail">
        <source>An implementation of file or module '{0}' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.</source>
        <target state="translated">Implementace souboru nebo modulu {0} už je zadaná. V F# záleží na pořadí kompilace, a to kvůli odvození typů proměnných. Pořadí souborů můžete upravit a podpisový soubor umístit před implementaci. Ve Visual Studiu se typ souborů kontroluje v tom pořadí, ve kterém se soubory objeví v souboru projektu, který se dá upravit ručně nebo pomocí Průzkumníka řešení.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGiven">
        <source>An implementation of the file or module '{0}' has already been given</source>
        <target state="translated">Implementace souboru nebo modulu {0} už je zadaná.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureWithoutImplementation">
        <source>The signature file '{0}' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match.</source>
        <target state="translated">Podpisový soubor {0} nemá odpovídající implementační soubor. Pokud implementační soubor existuje, zkontrolujte, jestli se deklarace module a namespace v podpisovém a implementačním souboru shodují.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidInt">
        <source>'{0}' is not a valid integer argument</source>
        <target state="translated">{0} není platný celočíselný argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidFloat">
        <source>'{0}' is not a valid floating point argument</source>
        <target state="translated">{0} není platný argument s plovoucí desetinnou čárkou.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnrecognizedOption">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">Nerozpoznaná možnost: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidModuleOrNamespaceName">
        <source>Invalid module or namespace name</source>
        <target state="translated">Neplatný název modulu nebo oboru názvů</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleErrorReadingWritingMetadata">
        <source>Error reading/writing metadata for the F# compiled DLL '{0}'. Was the DLL compiled with an earlier version of the F# compiler? (error: '{1}').</source>
        <target state="translated">Chyba čtení nebo zápisu metadat pro knihovnu DLL {0} zkompilovanou v F#. Byla knihovna DLL zkompilovaná ve starší verzi kompilátoru F#? (chyba: {1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeOrModuleNotConcrete">
        <source>The type/module '{0}' is not a concrete module or type</source>
        <target state="translated">Typ nebo modul {0} není konkrétním modulem nebo typem.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeHasAssemblyCodeRepresentation">
        <source>The type '{0}' has an inline assembly code representation</source>
        <target state="translated">Typ {0} má reprezentaci vloženého kódu sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNamespaceAndModuleWithSameNameInAssembly">
        <source>A namespace and a module named '{0}' both occur in two parts of this assembly</source>
        <target state="translated">Obor názvů a modul s názvem {0} se oba vyskytují ve dvou částech tohoto sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTwoModulesWithSameNameInAssembly">
        <source>Two modules named '{0}' occur in two parts of this assembly</source>
        <target state="translated">Dva moduly s názvem {0} se vyskytují ve dvou částech tohoto sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastDuplicateTypeDefinitionInAssembly">
        <source>Two type definitions named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">Dvě definice typu s názvem {0} se vyskytují v oboru názvů {1} ve dvou částech tohoto sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConflictingModuleAndTypeDefinitionInAssembly">
        <source>A module and a type definition named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">Modul a definice typu s názvem {0} se vyskytují v oboru názvů {1} ve dvou částech tohoto sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMemberSignature">
        <source>Invalid member signature encountered because of an earlier error</source>
        <target state="translated">Zjistila se neplatná signatura člena kvůli dřívější chybě.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueDoesNotHaveSetterType">
        <source>This value does not have a valid property setter type</source>
        <target state="translated">Tato hodnota nemá platný typ metody set vlastnosti.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertyGetter">
        <source>Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax.</source>
        <target state="translated">Neplatná notace pro metodu getter vlastnosti. Při použití explicitní syntaxe se vyžaduje aspoň jeden argument ().</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertySetter">
        <source>Invalid form for a property setter. At least one argument is required.</source>
        <target state="translated">Neplatná notace pro metodu set vlastnosti. Vyžaduje se aspoň jeden argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedByRef">
        <source>Unexpected use of a byref-typed variable</source>
        <target state="translated">Neočekávané použití proměnné typu ByRef.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeMutable">
        <source>A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'</source>
        <target state="translated">Hodnota musí být proměnlivá, aby se dal změnit obsah nebo aby se dala převzít adresa typu hodnoty, třeba let mutable x = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMutationOfConstant">
        <source>Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'.</source>
        <target state="translated">Neplatná mutace konstantního výrazu. Zvažte možnost zkopírovat výraz do lokální proměnné, třeba let mutable x = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueHasBeenCopied">
        <source>The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed</source>
        <target state="translated">Hodnota se zkopírovala pro případ, že by se v důsledku této operace původní hodnota změnila.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeInConstructionOfTuple">
        <source>Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding</source>
        <target state="translated">Rekurzivně definované hodnoty se nedají použít přímo jako součást konstrukce hodnoty řazené kolekce členů v rekurzivní vazbě.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotAppearInConstructionOfType">
        <source>Recursive values cannot appear directly as a construction of the type '{0}' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.</source>
        <target state="translated">Rekurzivní hodnoty nejde použít přímo jako konstrukce typu {0} v rekurzivní vazbě. Tato funkce je už z jazyka F# odebraná. Zvažte možnost použít místo ní záznam.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeAssignedToNonMutableField">
        <source>Recursive values cannot be directly assigned to the non-mutable field '{0}' of the type '{1}' within a recursive binding. Consider using a mutable field instead.</source>
        <target state="translated">Rekurzivní hodnoty se nedají přímo přiřadit k neproměnlivému poli {0} typu {1} v rekurzivní vazbě. Zvažte možnost použít místo toho proměnlivé pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfAutoOpenAttribute">
        <source>Unexpected decode of AutoOpenAttribute</source>
        <target state="translated">Neočekávané dekódování AutoOpenAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInternalsVisibleToAttribute">
        <source>Unexpected decode of InternalsVisibleToAttribute</source>
        <target state="translated">Neočekávané dekódování InternalsVisibleToAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
        <source>Unexpected decode of InterfaceDataVersionAttribute</source>
        <target state="translated">Neočekávané dekódování InterfaceDataVersionAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastActivePatternsLimitedToSeven">
        <source>Active patterns cannot return more than 7 possibilities</source>
        <target state="translated">Aktivní vzory nemůžou vracet víc než 7 možností.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNotAConstantExpression">
        <source>This is not a valid constant expression or custom attribute value</source>
        <target state="translated">Toto není platný konstantní výraz nebo hodnota vlastního atributu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAttributesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe mutability attributes differ</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se atributy proměnlivosti.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe names differ</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se názvy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityCompiledNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled names differ</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se zkompilovanými názvy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDisplayNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe display names differ</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se zobrazované názvy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAccessibilityMore">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nDostupnost zadaná v signatuře přesahuje dostupnost zadanou v implementaci.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInlineFlagsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe inline flags differ</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se vloženými příznaky.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityLiteralConstantValuesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe literal constant values and/or attributes differ</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nHodnoty nebo atributy literálové konstanty se liší.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsTypeFunction">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je funkcí typu a druhá ne. Signatura vyžaduje explicitní parametry typu (pokud se v implementaci vyskytují).</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityParameterCountsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe respective type parameter counts differ</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se odpovídajícím počtem parametrů typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityTypesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe types differ</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityExtensionsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is an extension member and the other is not</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je členem rozšíření a druhá ne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityArityNotInferred">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nAn arity was not inferred for this value</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nPro tuto hodnotu se neodvodila arita.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe number of generic parameters in the signature and implementation differ (the signature declares {3} but the implementation declares {4}</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nPočet obecných parametrů v signatuře a implementaci se liší (signatura deklaruje {3}, ale implementace {4}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersAreDifferentKinds">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nObecné parametry v signatuře a implementaci jsou různých druhů. Je možné, že chybí atribut [&lt;Measure&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAritiesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe arities in the signature and implementation differ. The signature specifies that '{3}' is function definition or lambda expression accepting at least {4} argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int.</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nArity v signatuře a implementaci se liší. Signatura určuje, že {3} je definice funkce nebo výraz lambda přijímající argumenty aspoň v počtu {4}, ale implementace je vypočítaná hodnota funkce. Pokud chcete deklarovat vypočítanou hodnotu funkce jako povolenou implementaci, jednoduše ohraničte její typ v signatuře závorkami, třeba pomocí notace\n\tval {5}: int -&gt; (int -&gt; int),\nkterá nahradí notaci\n\tval {6}: int -&gt; int -&gt; int.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDotNetNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe CLI member names differ</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se názvy členů CLI.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is static and the other isn't</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je statická a druhá ne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityVirtualsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is virtual and the other isn't</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je virtuální a druhá ne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAbstractsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is abstract and the other isn't</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je abstraktní a druhá ne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityFinalsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is final and the other isn't</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna z nich je finální a druhá ne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOverridesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is marked as an override and the other isn't</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je označená jako přepsání a druhá ne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsConstructor">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a constructor/property and the other is not</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je konstruktorem nebo vlastností a druhá ne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticButInstance">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nZkompilovaná reprezentace této metody je statickým členem, ale signatura určuje její zkompilovanou reprezentaci jako člena instance.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInstanceButStatic">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member</source>
        <target state="translated">Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nZkompilovaná reprezentace této metody je členem instance, ale signatura určuje její zkompilovanou reprezentaci jako statického člena.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNamesDiffer">
        <source>The {0} definitions in the signature and implementation are not compatible because the names differ. The type is called '{1}' in the signature file but '{2}' in implementation.</source>
        <target state="translated">Definice {0} v signatuře a implementaci nejsou kompatibilní, protože se liší názvy. Typ se v souboru signatury nazývá {1}, ale v implementaci se nazývá {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože se liší odpovídajícím počtem parametrů typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože dostupnost zadaná v signatuře přesahuje dostupnost zadanou v implementaci.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleMissingInterface">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature requires that the type supports the interface {2} but the interface has not been implemented</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura vyžaduje, aby typ podporoval rozhraní {2}, které se ale neimplementovalo.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože implementace uvádí, že tento typ může jako reprezentaci používat null, ale signatura to neuvádí.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože implementace uvádí, že tento typ může jako hodnotu navíc používat null, ale signatura to neuvádí.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura uvádí, že tento typ může jako reprezentaci používat null, ale implementace to neuvádí.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura uvádí, že tento typ může jako hodnotu navíc používat null, ale implementace to neuvádí.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože typ implementace je zapečetěný, ale ze signatury vyplývá, že není. Zvažte možnost přidat k signatuře atribut [&lt;Sealed&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože typ implementace není zapečetěný, ale ze signatury vyplývá, že je. Zvažte možnost přidat k implementaci atribut [&lt;Sealed&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože implementace je abstraktní třída, ale signatura ne. Zvažte možnost přidat k signatuře atribut [&lt;AbstractClass&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura je abstraktní třída, ale implementace ne. Zvažte možnost přidat k implementaci atribut [&lt;AbstractClass&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types have different base types</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože jejich typy mají odlišné základní typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNumbersDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the number of {2}s differ</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože se liší počet {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature defines the {2} '{3}' but the implementation does not (or does, but not in the same order)</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura definuje {2} {3}, ale implementace ne (anebo ano, ale ne ve stejném pořadí).</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines the {2} '{3}' but the signature does not (or does, but not in the same order)</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože implementace definuje {2} {3}, ale signatura ne (anebo ano, ale ne ve stejném pořadí).</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože implementace definuje strukturu, zatímco signatura typ se skrytou reprezentací.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura skrývá reprezentaci typu CLI.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a type representation is being hidden by a signature</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura skrývá reprezentaci typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types are of different kinds</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože typy jsou různého druhu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleILDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the IL representations differ</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože se liší reprezentace IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the representations differ</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože se liší reprezentace.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldWasPresent">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was present in the implementation but not in the signature</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože pole {2} se nacházelo v implementaci, ale v signatuře ne.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože se signatura a implementace liší pořadím polí.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was required by the signature but was not specified by the implementation</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura vyžadovala pole {2}, které ale v implementaci zadané nebylo.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field '{2}' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'.</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože pole {2} se nacházelo v implementaci, ale v signatuře ne. Typy Struct teď musí zobrazovat svoje pole v signatuře typu. Přesto můžou mít pole označení private nebo internal.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was required by the signature but was not specified by the implementation</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura vyžadovala abstraktního člena {2}, který ale v implementaci zadaný nebyl.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was present in the implementation but not in the signature</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože abstraktní člen {2} se nacházel v implementaci, ale v signatuře ne.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature declares a {2} while the implementation declares a {3}</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura deklaruje {2}, ale implementace deklaruje {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abbreviations differ: {2} versus {3}</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože se liší zkratky: {2} oproti {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura skrývá zkratku. Zkratka musí být viditelná pro ostatní jazyky CLI. Zvažte zviditelnění zkratky v signatuře.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not</source>
        <target state="translated">Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura má zkratku, ale implementace ne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButNamesDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">Modul obsahuje konstruktor\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se názvy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButDataFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe respective number of data fields differ</source>
        <target state="translated">Modul obsahuje konstruktor\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se odpovídající počty datových polí.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButTypesOfFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe types of the fields differ</source>
        <target state="translated">Modul obsahuje konstruktor\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se typy polí.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButAccessibilityDiffers">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Modul obsahuje konstruktor\n    {0},    \nale jeho signatura definuje\n    {1}.    \nDostupnost zadaná v signatuře přesahuje dostupnost zadanou v implementaci.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedNamesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">Modul obsahuje pole\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se názvy.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedAccessibilitiesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Modul obsahuje pole\n    {0},    \nale jeho signatura definuje\n    {1}.    \nDostupnost zadaná v signatuře přesahuje dostupnost zadanou v implementaci.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedStaticsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'static' modifiers differ</source>
        <target state="translated">Modul obsahuje pole\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se modifikátory static.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedMutablesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'mutable' modifiers differ</source>
        <target state="translated">Modul obsahuje pole\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se modifikátory mutable.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedLiteralsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'literal' modifiers differ</source>
        <target state="translated">Modul obsahuje pole\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se modifikátory literal.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedTypesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe types differ</source>
        <target state="translated">Modul obsahuje pole\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveImplicitGenericInstantiation">
        <source>The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '{0}' and '{1}'. Consider using type annotations to resolve the ambiguity</source>
        <target state="translated">Nepovedlo se přeložit implicitní vytvoření instance obecného konstruktoru na této pozici nebo blízko ní, protože by se dala přeložit na víc nesouvisejících typů, třeba {0} a {1}. Tuto nejednoznačnost můžete vyřešit pomocí poznámek typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInPrintf">
        <source>Could not resolve the ambiguity inherent in the use of a 'printf'-style format string</source>
        <target state="translated">Nepovedlo se vyřešit nejednoznačnost vyplývající z použití formátovacího řetězce ve stylu printf.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInEnum">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position</source>
        <target state="translated">Nepovedlo se vyřešit nejednoznačnost v použití obecného konstruktoru s omezením enum na této pozici nebo blízko ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInDelegate">
        <source>Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position</source>
        <target state="translated">Nepovedlo se vyřešit nejednoznačnost v použití obecného konstruktoru s omezením delegate na této pozici nebo blízko ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInvalidValue">
        <source>Invalid value</source>
        <target state="translated">Neplatná hodnota</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleParamCountsDiffer">
        <source>The signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">Signatura a implementace nejsou kompatibilní, protože se liší počtem příslušných parametrů typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
        <source>The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation</source>
        <target state="translated">Signatura a implementace nejsou kompatibilní, protože parametr typu v třídě nebo signatuře má jiný požadavek za kompilace než parametr u člena nebo implementace.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDiffer">
        <source>The signature and implementation are not compatible because the declaration of the type parameter '{0}' requires a constraint of the form {1}</source>
        <target state="translated">Signatura a implementace nejsou kompatibilní, protože deklarace parametru typu {0} vyžaduje omezení v podobě {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDifferRemove">
        <source>The signature and implementation are not compatible because the type parameter '{0}' has a constraint of the form {1} but the implementation does not. Either remove this constraint from the signature or add it to the implementation.</source>
        <target state="translated">Signatura a implementace nejsou kompatibilní, protože parametr typu {0} má omezení v podobě {1}, ale implementace ne. Buď toto omezení odeberte ze signatury, nebo ho přidejte do implementace.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableShouldOverrideObjectEquals">
        <source>The type '{0}' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'</source>
        <target state="translated">Typ {0} implementuje rozhraní System.IComparable. Zvažte možnost přidat taky explicitní přepsání Object.Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableDefaultObjectEqualsProvided">
        <source>The type '{0}' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly</source>
        <target state="translated">Typ {0} má explicitní implementaci rozhraní System.IComparable, ale neposkytuje žádné odpovídající přepsání Object.Equals. Implementace Object.Equals se poskytla automaticky prostřednictvím rozhraní System.IComparable. Zvažte možnost implementovat přepsání Object.Equals explicitně.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCodeOrEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} explicitně implementuje Object.GetHashCode nebo Object.Equals. U tohoto typu musíte použít atribut CustomEquality.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCode">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} explicitně implementuje Object.GetHashCode. Zvažte implementaci odpovídajícího přepsání pro Object.Equals(obj).</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} explicitně implementuje Object.Equals. Zvažte možnost implementace odpovídajícího přepsání pro Object.GetHashCode().</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleHiddenBySignature">
        <source>The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">Definice výjimek nejsou kompatibilní, protože signatura skrývá mapování výjimky CLI. Mapování výjimky musí být viditelné pro ostatní moduly. Modul obsahuje definici výjimky\n    {0},    \nale jeho signatura definuje\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer">
        <source>The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">Definice výjimek nejsou kompatibilní, protože se liší reprezentace CLI. Modul obsahuje definici výjimky\n    {0},    \nale jeho signatura definuje\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature">
        <source>The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Definice výjimek nejsou kompatibilní, protože signatura skrývá zkratku výjimky. Zkratka musí být viditelná pro ostatní jazyky CLI. Zvažte zviditelnění zkratky v signatuře. Modul obsahuje definici výjimky\n    {0},    \nale jeho signatura definuje\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleSignaturesDiffer">
        <source>The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Definice výjimek nejsou kompatibilní, protože zkratky výjimek v signatuře a implementaci se liší. Modul obsahuje definici výjimky\n    {0},    \nale jeho signatura definuje\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer">
        <source>The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Definice výjimek nejsou kompatibilní, protože se liší deklarace výjimek. Modul obsahuje definici výjimky\n    {0},    \nale jeho signatura definuje\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInSigButNotImpl">
        <source>The exception definitions are not compatible because the field '{0}' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">Definice výjimek nejsou kompatibilní, protože signatura vyžadovala pole {0}, které ale implementace nedefinuje. Modul obsahuje definici výjimky\n    {1},    \nale jeho signatura definuje \n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInImplButNotSig">
        <source>The exception definitions are not compatible because the field '{0}' was present in the implementation but not in the signature. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">Definice výjimek nejsou kompatibilní, protože pole {0} se nacházelo v implementaci, ale v signatuře ne. Modul obsahuje definici výjimky\n    {1},    \nale jeho signatura definuje\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldOrderDiffers">
        <source>The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Definice výjimek nejsou kompatibilní, protože se signatura a implementace liší pořadím polí. Modul obsahuje definici výjimky\n    {0},    \nale jeho signatura definuje\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelModuleNamespaceAttributesDifferInSigAndImpl">
        <source>The namespace or module attributes differ between signature and implementation</source>
        <target state="translated">Atributy oboru názvů nebo modulu se v signatuře a implementaci liší.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsOverconstrained">
        <source>This method is over-constrained in its type parameters</source>
        <target state="translated">Tato metoda je v parametrech typu příliš omezená.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverloadNotFound">
        <source>No implementations of '{0}' had the correct number of arguments and type parameters. The required signature is '{1}'.</source>
        <target state="translated">Žádná implementace {0} nemá správný počet argumentů a parametrů typu. Požadovaná signatura je {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideWasAmbiguous">
        <source>The override for '{0}' was ambiguous</source>
        <target state="translated">Přepsání {0} bylo nejednoznačné.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMoreThenOneOverride">
        <source>More than one override implements '{0}'</source>
        <target state="translated">Víc než jedno přepsání implementuje {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsSealed">
        <source>The method '{0}' is sealed and cannot be overridden</source>
        <target state="translated">Metoda {0} je zapečetěná a nedá se přepisovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideImplementsMoreThenOneSlot">
        <source>The override '{0}' implements more than one abstract slot, e.g. '{1}' and '{2}'</source>
        <target state="translated">Přepsání {0} implementuje víc než jednu abstraktní datovou oblast, třeba {1} a {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelDuplicateInterface">
        <source>Duplicate or redundant interface</source>
        <target state="translated">Duplicitní nebo nadbytečné rozhraní</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNeedExplicitImplementation">
        <source>The interface '{0}' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.</source>
        <target state="translated">Rozhraní {0} je zahrnuté v několika explicitně implementovaných typech rozhraní. Přidejte explicitní implementaci tohoto rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNamedArgumentHasBeenAssignedMoreThenOnce">
        <source>A named argument has been assigned more than one value</source>
        <target state="translated">Pojmenovaný argument má přiřazenou víc než jednu hodnotu.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGiven">
        <source>No implementation was given for '{0}'</source>
        <target state="translated">{0} nemá žádnou implementaci.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenWithSuggestion">
        <source>No implementation was given for '{0}'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">{0} nemá žádnou implementaci. Všechny členy rozhraní je potřeba implementovat a uvést pod příslušnou deklarací interface, třeba takto: interface ... with member ...</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfArguments">
        <source>The member '{0}' does not have the correct number of arguments. The required signature is '{1}'.</source>
        <target state="translated">Člen {0} nemá správný počet argumentů. Požadovaná signatura je {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters">
        <source>The member '{0}' does not have the correct number of method type parameters. The required signature is '{1}'.</source>
        <target state="translated">Člen {0} nemá správný počet parametrů typu metody. Požadovaná signatura je {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters">
        <source>The member '{0}' does not have the correct kinds of generic parameters. The required signature is '{1}'.</source>
        <target state="translated">Člen {0} nemá správný druh obecných parametrů. Požadovaná signatura je {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberCannotImplement">
        <source>The member '{0}' cannot be used to implement '{1}'. The required signature is '{2}'.</source>
        <target state="translated">Člen {0} se k implementaci {1} použít nedá. Požadovaná signatura je {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILError">
        <source>Error while parsing embedded IL</source>
        <target state="translated">Chyba při analýze vloženého kódu IL</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILTypeError">
        <source>Error while parsing embedded IL type</source>
        <target state="translated">Chyba při analýze vloženého typu IL</target>
        <note />
      </trans-unit>
      <trans-unit id="astDeprecatedIndexerNotation">
        <source>This indexer notation has been removed from the F# language</source>
        <target state="translated">Tato notace indexeru se už v jazyce F# nepoužívá.</target>
        <note />
      </trans-unit>
      <trans-unit id="astInvalidExprLeftHandOfAssignment">
        <source>Invalid expression on left of assignment</source>
        <target state="translated">Neplatný výraz nalevo od přiřazení</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoRefEqualsOnStruct">
        <source>The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'.</source>
        <target state="translated">Atribut ReferenceEquality se u struktur použít nedá. Zvažte, jestli byste místo něho neměli použít atribut StructuralEquality nebo implementovat přepsání pro System.Object.Equals(obj).</target>
        <note />
      </trans-unit>
      <trans-unit id="augInvalidAttrs">
        <source>This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'</source>
        <target state="translated">Tento typ používá neplatnou kombinaci atributů NoEquality, ReferenceEquality, StructuralEquality, NoComparison a StructuralComparison.</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqualityNeedsNoComparison">
        <source>The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute</source>
        <target state="translated">Atribut NoEquality je potřeba použít ve spojení s atributem NoComparison.</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructCompNeedsStructEquality">
        <source>The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute</source>
        <target state="translated">Atribut StructuralComparison je potřeba použít ve spojení s atributem StructuralEquality.</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructEqNeedsNoCompOrStructComp">
        <source>The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes</source>
        <target state="translated">Atribut StructuralEquality je potřeba použít ve spojení s atributem NoComparison nebo StructuralComparison.</target>
        <note />
      </trans-unit>
      <trans-unit id="augTypeCantHaveRefEqAndStructAttrs">
        <source>A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes</source>
        <target state="translated">Typ nemůže mít zároveň atribut ReferenceEquality a StructuralEquality nebo StructuralComparison.</target>
        <note />
      </trans-unit>
      <trans-unit id="augOnlyCertainTypesCanHaveAttrs">
        <source>Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes</source>
        <target state="translated">O atributy ReferenceEquality, StructuralEquality a StructuralComparison se dají rozšířit jenom typy záznam, sjednocení, výjimka a struktura.</target>
        <note />
      </trans-unit>
      <trans-unit id="augRefEqCantHaveObjEquals">
        <source>A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">Typ s atributem ReferenceEquality nemůže mít explicitní implementaci Object.Equals(obj), System.IEquatable&lt;_&gt; nebo System.Collections.IStructuralEquatable.</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsObjEquals">
        <source>A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">Typ s atributem CustomEquality musí mít explicitní implementaci aspoň jednoho z následujících: Object.Equals(obj), System.IEquatable&lt;_&gt;, nebo System.Collections.IStructuralEquatable.</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomCompareNeedsIComp">
        <source>A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'</source>
        <target state="translated">Typ s atributem CustomComparison musí mít explicitní implementaci buď aspoň System.IComparable, nebo aspoň System.Collections.IStructuralComparable.</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqNeedsNoObjEquals">
        <source>A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">Není běžné, aby typ s atributem NoEquality měl explicitní implementaci Object.Equals(obj). Pokud je to záměr s cílem dosáhnout interoperability, pak toto upozornění vypněte.</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoCompCantImpIComp">
        <source>A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable&lt;_&gt;' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">Není běžné, aby typ s atributem NoComparison měl explicitní implementaci System.IComparable, System.IComparable&lt;_&gt; nebo System.Collections.IStructuralComparable. Pokud je to záměr s cílem dosáhnout interoperability, pak toto upozornění vypněte.</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsNoCompOrCustomComp">
        <source>The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes</source>
        <target state="translated">Atribut CustomEquality je potřeba použít ve spojení s atributem NoComparison nebo CustomComparison.</target>
        <note />
      </trans-unit>
      <trans-unit id="forPositionalSpecifiersNotPermitted">
        <source>Positional specifiers are not permitted in format strings</source>
        <target state="translated">Specifikátory pozice nejsou v řetězcích formátu povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="forMissingFormatSpecifier">
        <source>Missing format specifier</source>
        <target state="translated">Chybí specifikátor formátu.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFlagSetTwice">
        <source>'{0}' flag set twice</source>
        <target state="translated">Příznak {0} je nastavený dvakrát.</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrefixFlagSpacePlusSetTwice">
        <source>Prefix flag (' ' or '+') set twice</source>
        <target state="translated">Příznak předpony (mezera nebo znaménko plus) je nastavený dvakrát.</target>
        <note />
      </trans-unit>
      <trans-unit id="forHashSpecifierIsInvalid">
        <source>The # formatting modifier is invalid in F#</source>
        <target state="translated">Modifikátor formátu # je v jazyce F# neplatný.</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadPrecision">
        <source>Bad precision in format specifier</source>
        <target state="translated">Chybná přesnost ve specifikátoru formátu</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadWidth">
        <source>Bad width in format specifier</source>
        <target state="translated">Chybná šířka ve specifikátoru formátu</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportZeroFlag">
        <source>'{0}' format does not support '0' flag</source>
        <target state="translated">Formát {0} nepodporuje příznak 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrecisionMissingAfterDot">
        <source>Precision missing after the '.'</source>
        <target state="translated">Za tečkou chybí určení přesnosti.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatDoesntSupportPrecision">
        <source>'{0}' format does not support precision</source>
        <target state="translated">Formát {0} nepodporuje přesnost.</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifier">
        <source>Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Špatný specifikátor formátu (po l nebo L): Očekávaný specifikátor je ld, li, lo, lu, lx nebo lX. V kódu F# můžete místo toho použít %d, %x, %o nebo %u: tyto specifikátory formátu jsou přetěžované, takže fungují se všemi základními celočíselnými typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="forLIsUnnecessary">
        <source>The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Použití l nebo L je u tohoto specifikátoru formátu nadbytečné. V kódu F# můžete místo toho použít %d, %x, %o nebo %u: tyto specifikátory formátu jsou přetěžované, takže fungují se všemi základními celočíselnými typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="forHIsUnnecessary">
        <source>The 'h' or 'H' in this format specifier is unnecessary. You can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">U tohoto specifikátoru formátu není nutné používat h nebo H. Místo toho můžete použít %d, %x, %o nebo %u. Tyto specifikátory formátu se přetěžují, aby fungovaly se všemi základními celočíselnými typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportPrefixFlag">
        <source>'{0}' does not support prefix '{1}' flag</source>
        <target state="translated">{0} nepodporuje příznak předpony {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifierGeneral">
        <source>Bad format specifier: '{0}'</source>
        <target state="translated">Špatný specifikátor formátu: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="elSysEnvExitDidntExit">
        <source>System.Environment.Exit did not exit</source>
        <target state="translated">Metoda System.Environment.Exit neprovedla ukončení.</target>
        <note />
      </trans-unit>
      <trans-unit id="elDeprecatedOperator">
        <source>The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined</source>
        <target state="translated">Zpracování tohoto operátoru teď provádí přímo kompilátor F# a jeho význam se nedá předefinovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkProtectedOrBaseCalled">
        <source>A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope.</source>
        <target state="translated">Volá se chráněný člen nebo se používá base. To je povolené jenom u přímé implementace členů, protože by se tak mohly dostat mimo definiční obor objektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkByrefUsedInInvalidWay">
        <source>The byref-typed variable '{0}' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.</source>
        <target state="translated">Proměnná {0} typu ByRef se používá neplatným způsobem. Proměnné typu ByRef nejde zachytávat ukončením nebo předávat vnitřní funkci.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkBaseUsedInInvalidWay">
        <source>The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.</source>
        <target state="translated">Klíčové slovo base je použité neplatným způsobem. Volání base se u ukončení použít nedají. K volání base se dá použít privátní člen.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkVariableUsedInInvalidWay">
        <source>The variable '{0}' is used in an invalid way</source>
        <target state="translated">Proměnná {0} je použitá neplatným způsobem.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTypeLessAccessibleThanType">
        <source>The type '{0}' is less accessible than the value, member or type '{1}' it is used in.</source>
        <target state="translated">Typ {0} je méně dostupný než hodnota, člen nebo typ {1}, ve kterém se používá.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSystemVoidOnlyInTypeof">
        <source>'System.Void' can only be used as 'typeof&lt;System.Void&gt;' in F#</source>
        <target state="translated">System.Void se dá v F# použít jenom jako typeof&lt;System.Void&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorUseOfByref">
        <source>A type instantiation involves a byref type. This is not permitted by the rules of Common IL.</source>
        <target state="translated">Vytvoření instance typu zahrnuje typ ByRef. To ale pravidla Common IL nepovolují.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorContainsCallToRethrow">
        <source>Calls to 'reraise' may only occur directly in a handler of a try-with</source>
        <target state="translated">Volání reraise se může vyskytovat jenom přímo v obslužné rutině try-with.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSplicingOnlyInQuotations">
        <source>Expression-splicing operators may only be used within quotations</source>
        <target state="translated">Operátory spojení výrazů je možné použít jenom uvnitř citace.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassSplicing">
        <source>First-class uses of the expression-splicing operator are not permitted</source>
        <target state="translated">Použití operátoru spojení výrazů se u první třídy nepovoluje.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassAddressOf">
        <source>First-class uses of the address-of operators are not permitted</source>
        <target state="translated">Použití operátorů address-of jako výrazů první třídy není povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassRethrow">
        <source>First-class uses of the 'reraise' function is not permitted</source>
        <target state="translated">Použití funkce reraise jako výrazu první třídy není povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAtThisPoint">
        <source>The byref typed value '{0}' cannot be used at this point</source>
        <target state="translated">Hodnota typu ByRef {0} se na tomto místě použít nedá.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkLimitationsOfBaseKeyword">
        <source>'base' values may only be used to make direct calls to the base implementations of overridden members</source>
        <target state="translated">Hodnoty base se dají použít jenom k přímému volání implementací base přepsaných členů.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkObjCtorsCantUseExceptionHandling">
        <source>Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.</source>
        <target state="translated">Konstruktory objektu nemůžou použít try/with a try/finally přímo, dokud se objekt neinicializuje. To zahrnuje i konstrukce, jako je třeba for x in ..., které se dají na použití těchto konstruktorů rozpracovat. Toto je omezení mezijazyka Common IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfAtThisPoint">
        <source>The address of the variable '{0}' cannot be used at this point</source>
        <target state="translated">Adresa proměnné {0} se na tomto místě použít nedá.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressStaticFieldAtThisPoint">
        <source>The address of the static field '{0}' cannot be used at this point</source>
        <target state="translated">Adresa statického pole {0} se na tomto místě použít nedá.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressFieldAtThisPoint">
        <source>The address of the field '{0}' cannot be used at this point</source>
        <target state="translated">Adresa pole {0} se na tomto místě použít nedá.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfArrayElementAtThisPoint">
        <source>The address of an array element cannot be used at this point</source>
        <target state="translated">Adresa prvku pole se na tomto místě použít nedá.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFirstClassFuncNoByref">
        <source>The type of a first-class function cannot contain byrefs</source>
        <target state="translated">Typ funkce první třídy nemůže obsahovat parametry typu ByRef.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReturnTypeNoByref">
        <source>A method return type would contain byrefs which is not permitted</source>
        <target state="translated">Návratový typ metody by obsahoval parametry ByRef a to není povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidCustAttrVal">
        <source>Invalid custom attribute value (not a constant or literal)</source>
        <target state="translated">Neplatná hodnota vlastního atributu (není to konstanta nebo literál)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkAttrHasAllowMultiFalse">
        <source>The attribute type '{0}' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element.</source>
        <target state="translated">Typ atributu {0} má nastavení AllowMultiple=false. K elementu s jedním jazykem se nedá připojit víc instancí tohoto atributu.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to its definition at or near '{2}'. This is an invalid forward reference.</source>
        <target state="translated">Člen {0} je použitý neplatným způsobem. Použití členu {1} se odvozuje před jeho definicí na pozici {2} nebo blízko ní. To je neplatný dopředný odkaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAsTopValue">
        <source>A byref typed value would be stored here. Top-level let-bound byref values are not permitted.</source>
        <target state="translated">Hodnota typu ByRef by se uložila tady. Hodnoty ByRef s vazbou na let na nejvyšší úrovni nejsou povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReflectedDefCantSplice">
        <source>[&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">Výrazy [&lt;ReflectedDefinition&gt;] nemůžou obsahovat použití operátoru spojení předpon %.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkEntryPointUsage">
        <source>A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence.</source>
        <target state="translated">Funkce označená atributem EntryPointAttribute musí být poslední deklarací v posledním souboru v sekvenci kompilace.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseCompiledForm">
        <source>compiled form of the union case</source>
        <target state="translated">Zkompilovaná forma případu typu union</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseDefaultAugmentation">
        <source>default augmentation of the union case</source>
        <target state="translated">Výchozí rozšíření případu typu union</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameMethod">
        <source>The property '{0}' has the same name as a method in type '{1}'.</source>
        <target state="translated">Vlastnost {0} má stejný název jako metoda v typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterSetterDoNotMatchAbstract">
        <source>The property '{0}' of type '{1}' has a getter and a setter that do not match. If one is abstract then the other must be as well.</source>
        <target state="translated">Metody get a set vlastnosti {0} typu {1} si neodpovídají. Pokud je jedna z nich abstraktní, musí být abstraktní i ta druhá.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameIndexer">
        <source>The property '{0}' has the same name as another property in type '{1}', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.</source>
        <target state="translated">Vlastnost {0} má stejný název jako jiná vlastnost v typu {1}, ale jedna z nich přebírá argumenty indexeru a druhá ne. Je možné, že u jedné z vlastností chybí argument indexeru.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCantStoreByrefValue">
        <source>A type would store a byref typed value. This is not permitted by Common IL.</source>
        <target state="translated">Typ by uložil hodnotu typu ByRef. To ale Common IL nepovoluje.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethod">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}'.</source>
        <target state="translated">Duplicitní metoda. Metoda {0} má stejný název a signaturu jako jiná metoda v typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodWithSuffix">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Duplicitní metoda. Metoda {0} má po vymazání řazených kolekcí členů, funkcí, měrných jednotek a poskytnutých typů stejný název a signaturu jako jiná metoda v typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodCurried">
        <source>The method '{0}' has curried arguments but has the same name as another method in type '{1}'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.</source>
        <target state="translated">Metoda {0} má curryfikované argumenty, ale má stejný název jako jiná metoda v typu {1}. Metody s curryfikovanými argumenty se nedají přetěžovat. Zvažte použití metody, která přebírá argumenty s řazenou kolekcí členů.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCurriedMethodsCantHaveOutParams">
        <source>Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments</source>
        <target state="translated">Metody s curryfikovanými argumenty nemůžou deklarovat argumenty out, ParamArray, optional, ReflectedDefiniton, byref, CallerLineNumber, CallerMemberName a CallerFilePath.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateProperty">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}'.</source>
        <target state="translated">Duplicitní vlastnost. Vlastnost {0} má stejný název a signaturu jako jiná vlastnost v typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicatePropertyWithSuffix">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Duplicitní vlastnost. Vlastnost {0} má po vymazání řazených kolekcí členů, funkcí, měrných jednotek a poskytnutých typů stejný název a signaturu jako jiná vlastnost v typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedType">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type.</source>
        <target state="translated">Duplicitní metoda. Abstraktní metoda {0} má stejný název a signaturu jako abstraktní metoda ve zděděném typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedTypeWithSuffix">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Duplicitní metoda. Abstraktní metoda {0} má po vymazání řazených kolekcí členů, funkcí, měrných jednotek a poskytnutých typů stejný název a signaturu jako abstraktní metoda ve zděděném typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMultipleGenericInterfaceInstantiations">
        <source>This type implements the same interface at different generic instantiations '{0}' and '{1}'. This is not permitted in this version of F#.</source>
        <target state="translated">Tento typ implementuje stejné rozhraní u různých obecných instancí {0} a {1}. To není v této verzi F# povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkValueWithDefaultValueMustHaveDefaultValue">
        <source>The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check</source>
        <target state="translated">Typ pole, které používá atribut DefaultValue, musí připouštět výchozí inicializaci, tj. mít null jako správnou hodnotu nebo být typu struktura, jejíž všechna pole připouštějí výchozí inicializaci. Tuto kontrolu můžete vypnout pomocí DefaultValue(false).</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefInTypeAbbrev">
        <source>The type abbreviation contains byrefs. This is not permitted by F#.</source>
        <target state="translated">Zkratka typu obsahuje parametry Byref. To F# nepovoluje.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefBoundVarUsedInSplice">
        <source>The variable '{0}' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.</source>
        <target state="translated">Proměnná {0} je vázaná v citaci, ale používá se jako součást spojeného výrazu. To není povolené, protože se tak proměnná může dostat mimo definiční obor.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericExprs">
        <source>Quotations cannot contain uses of generic expressions</source>
        <target state="translated">Citace nemůžou obsahovat použití obecných výrazů.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericFunctions">
        <source>Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.</source>
        <target state="translated">Citace nemůžou obsahovat definice funkcí, které jsou odvozené nebo deklarované jako obecné. Zvažte přidání některých omezení typu, abyste vytvořili platný citovaný výraz.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainObjExprs">
        <source>Quotations cannot contain object expressions</source>
        <target state="translated">Citace nemůžou obsahovat objektové výrazy.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainAddressOf">
        <source>Quotations cannot contain expressions that take the address of a field</source>
        <target state="translated">Citace nemůžou obsahovat výrazy, které přebírají adresu pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainStaticFieldRef">
        <source>Quotations cannot contain expressions that fetch static fields</source>
        <target state="translated">Citace nemůžou obsahovat výrazy, které načítají statická pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainInlineIL">
        <source>Quotations cannot contain inline assembly code or pattern matching on arrays</source>
        <target state="translated">Citace nemůžou obsahovat vložený kód sestavení nebo porovnávání vzorů polí.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainDescendingForLoops">
        <source>Quotations cannot contain descending for loops</source>
        <target state="translated">Citace nemůžou obsahovat sestupné smyčky for.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantFetchUnionIndexes">
        <source>Quotations cannot contain expressions that fetch union case indexes</source>
        <target state="translated">Citace nemůžou obsahovat výrazy, které načítají indexy případů typu union.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetUnionFields">
        <source>Quotations cannot contain expressions that set union case fields</source>
        <target state="translated">Citace nemůžou obsahovat výrazy, které nastavují pole případů typu union.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetExceptionFields">
        <source>Quotations cannot contain expressions that set fields in exception values</source>
        <target state="translated">Citace nemůžou obsahovat výrazy, které u polí nastavují výjimečné hodnoty.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantRequireByref">
        <source>Quotations cannot contain expressions that require byref pointers</source>
        <target state="translated">Citace nemůžou obsahovat výrazy, které vyžadují ukazatele na parametry ByRef.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantCallTraitMembers">
        <source>Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call</source>
        <target state="translated">Citace nemůže zahrnovat výrazy, které volají omezení členů, ani nemůže používat operátory, které se na volání omezení členů implicitně překládají.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisConstant">
        <source>Quotations cannot contain this kind of constant</source>
        <target state="translated">Citace nemůžou obsahovat tento druh konstanty.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisPatternMatch">
        <source>Quotations cannot contain this kind of pattern match</source>
        <target state="translated">Citace nemůžou obsahovat tento druh porovnávání vzorů.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainArrayPatternMatching">
        <source>Quotations cannot contain array pattern matching</source>
        <target state="translated">V citacích nemůže být zahrnuté porovnávání vzorů polí.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisType">
        <source>Quotations cannot contain this kind of type</source>
        <target state="translated">Citace nemůžou obsahovat tento druh typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeCannotBeResolvedAtCompileTime">
        <source>The declared type parameter '{0}' cannot be used here since the type parameter cannot be resolved at compile time</source>
        <target state="translated">Parametr deklarovaného typu {0} se tady použít nedá, protože parametr typu nejde přeložit za kompilace.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCodeLessGeneric">
        <source>This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'.</source>
        <target state="translated">Tento kód je míň obecný, než udávají jeho poznámky. U měrné jednotky specifikované pomocí podtržítka (_) se určila hodnota 1, tj. bezrozměrná. Zvažte zobecnění kódu nebo odebrání podtržítka (_).</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInferenceMaxDepth">
        <source>Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.</source>
        <target state="translated">Problém s odvozením typu proměnných: příliš složité (dosáhli jste maximální možné hloubky iterace). Zvažte přidání dalších poznámek typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectedArguments">
        <source>Expected arguments to an instance member</source>
        <target state="translated">Očekávaly se argumenty člena instance.</target>
        <note />
      </trans-unit>
      <trans-unit id="csIndexArgumentMismatch">
        <source>This indexer expects {0} arguments but is here given {1}</source>
        <target state="translated">Počet argumentů, které tento indexer očekává, je {0}, ale počet těch, které se mu tady předávají, je {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenFunction">
        <source>Expecting a type supporting the operator '{0}' but given a function type. You may be missing an argument to a function.</source>
        <target state="translated">Očekává se typ podporující operátor {0}, ale předává se typ funkce. Možná, že u funkce chybí argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenTuple">
        <source>Expecting a type supporting the operator '{0}' but given a tuple type</source>
        <target state="translated">Očekává se typ podporující operátor {0}, ale předává se typ řazené kolekce členů.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperator">
        <source>None of the types '{0}' support the operator '{1}'</source>
        <target state="translated">Žádný z typů {0} nepodporuje operátor {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperator">
        <source>The type '{0}' does not support the operator '{1}'</source>
        <target state="translated">Typ {0} nepodporuje operátor {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperatorNullable">
        <source>None of the types '{0}' support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Žádný z typů {0} nepodporuje operátor {1}. Zvažte otevření modulu Microsoft.FSharp.Linq.NullableOperators.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperatorNullable">
        <source>The type '{0}' does not support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Typ {0} nepodporuje operátor {1}. Zvažte otevření modulu Microsoft.FSharp.Linq.NullableOperators.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportConversion">
        <source>The type '{0}' does not support a conversion to the type '{1}'</source>
        <target state="translated">Typ {0} nepodporuje převod na typ {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is static</source>
        <target state="translated">Typ {0} má metodu {1} (celý název je {2}), ale ta je statická.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsNotStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is not static</source>
        <target state="translated">Typ {0} má metodu {1} (celý název je {2}), ale ta není statická.</target>
        <note />
      </trans-unit>
      <trans-unit id="csStructConstraintInconsistent">
        <source>The constraints 'struct' and 'not struct' are inconsistent</source>
        <target state="translated">Omezení struct a not struct jsou nekonzistentní.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value</source>
        <target state="translated">Typ {0} nemá null jako správnou hodnotu.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNullableTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'.</source>
        <target state="translated">Typ {0} nemá null jako správnou hodnotu. Pokud chcete u typu s možnou hodnotou null vytvořit hodnotu null, použijte System.Nullable().</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison1">
        <source>The type '{0}' does not support the 'comparison' constraint because it has the 'NoComparison' attribute</source>
        <target state="translated">Typ {0} nepodporuje omezení comparison, protože má atribut NoComparison.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison2">
        <source>The type '{0}' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface</source>
        <target state="translated">Typ {0} nepodporuje omezení comparison. Nepodporuje třeba rozhraní System.IComparable.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison3">
        <source>The type '{0}' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison</source>
        <target state="translated">Typ {0} nepodporuje omezení comparison, protože je to záznam, sjednocení nebo struktura aspoň s jedním strukturálním typem prvků, který nepodporuje omezení comparison. Buď se u tohoto typu vyhněte použití comparison, nebo k němu přidejte atribut StructuralComparison a s jeho pomocí určete, který typ pole nepodporuje comparison.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality1">
        <source>The type '{0}' does not support the 'equality' constraint because it has the 'NoEquality' attribute</source>
        <target state="translated">Typ {0} nepodporuje omezení equality, protože má atribut NoEquality.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality2">
        <source>The type '{0}' does not support the 'equality' constraint because it is a function type</source>
        <target state="translated">Typ {0} nepodporuje omezení equality, protože je to typ funkce.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality3">
        <source>The type '{0}' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality</source>
        <target state="translated">Typ {0} nepodporuje omezení equality, protože je to záznam, sjednocení nebo struktura aspoň s jedním strukturálním typem prvků, který nepodporuje omezení equality. Buď se u tohoto typu vyhněte použití equality, nebo k němu přidejte atribut StructuralEquality a s jeho pomocí určete, který typ pole nepodporuje equality.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotEnumType">
        <source>The type '{0}' is not a CLI enum type</source>
        <target state="translated">Typ {0} není typu výčtu CLI.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeHasNonStandardDelegateType">
        <source>The type '{0}' has a non-standard delegate type</source>
        <target state="translated">Typ {0} má nestandardní typ delegáta.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotDelegateType">
        <source>The type '{0}' is not a CLI delegate type</source>
        <target state="translated">Typ {0} není delegátem CLI.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeParameterCannotBeNullable">
        <source>This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values.</source>
        <target state="translated">U tohoto parametru typu se nedá vytvořit instance Nullable. Toto omezení má zabránit situaci, ve které by byl význam null v některých jazycích CLI zavádějící v případě, že se použije ve spojení s hodnotami Nullable.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructType">
        <source>A generic construct requires that the type '{0}' is a CLI or F# struct type</source>
        <target state="translated">Obecný konstruktor vyžaduje, aby byl typ {0} typem struktura CLI nebo F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresUnmanagedType">
        <source>A generic construct requires that the type '{0}' is an unmanaged type</source>
        <target state="translated">Obecný konstruktor vyžaduje, aby byl typ {0} nespravovaným typem.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeNotCompatibleBecauseOfPrintf">
        <source>The type '{0}' is not compatible with any of the types {1}, arising from the use of a printf-style format string</source>
        <target state="translated">Typ {0} není v důsledku použití formátovacího řetězce ve stylu printf kompatibilní s žádným z typů {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresReferenceSemantics">
        <source>A generic construct requires that the type '{0}' have reference semantics, but it does not, i.e. it is a struct</source>
        <target state="translated">Obecný konstruktor vyžaduje, aby měl typ {0} sémantiku odkazu. To ale nemá: je to struktura.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresNonAbstract">
        <source>A generic construct requires that the type '{0}' be non-abstract</source>
        <target state="translated">Obecný konstruktor vyžaduje, aby byl typ {0} neabstraktní.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresPublicDefaultConstructor">
        <source>A generic construct requires that the type '{0}' have a public default constructor</source>
        <target state="translated">Obecný konstruktor vyžaduje, aby měl typ {0} veřejný výchozí konstruktor.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInstantiationLengthMismatch">
        <source>Type instantiation length mismatch</source>
        <target state="translated">Neshoda v délce instance typu</target>
        <note />
      </trans-unit>
      <trans-unit id="csOptionalArgumentNotPermittedHere">
        <source>Optional arguments not permitted here</source>
        <target state="translated">Nepovinné argumenty tady nejsou povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotStatic">
        <source>{0} is not a static member</source>
        <target state="translated">{0} není statický člen.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotInstance">
        <source>{0} is not an instance member</source>
        <target state="translated">{0} není člen instance.</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentLengthMismatch">
        <source>Argument length mismatch</source>
        <target state="translated">Neshoda v délce argumentů</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentTypesDoNotMatch">
        <source>The argument types don't match</source>
        <target state="translated">Typy argumentů se neshodují.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodExpectsParams">
        <source>This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument</source>
        <target state="translated">Tato metoda očekává na této pozici parametr CLI params. Použití parametru params umožňuje předat proměnlivý počet argumentů metodě v jazycích, jako je C#. Zvažte možnost předat tomuto argumentu pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible">
        <source>The member or object constructor '{0}' is not {1}</source>
        <target state="translated">Konstruktor členu nebo objektu {0} není {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible2">
        <source>The member or object constructor '{0}' is not {1}. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.</source>
        <target state="translated">Konstruktor členu nebo objektu {0} není {1}. K soukromým členům se dá přistupovat jenom z deklarujícího typu. K chráněným členům se dá přistupovat jenom z rozšiřujícího typu a nedá se k nim přistupovat z vnitřních výrazů lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAStaticMethod">
        <source>{0} is not a static method</source>
        <target state="translated">{0} není statická metoda.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAnInstanceMethod">
        <source>{0} is not an instance method</source>
        <target state="translated">{0} není metoda instance.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberHasNoArgumentOrReturnProperty">
        <source>The member or object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">Konstruktor členu nebo objektu {0} nemá žádný argument nebo nastavitelnou návratovou vlastnost {1}. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorHasNoArgumentOrReturnProperty">
        <source>The object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">Konstruktor objektu {0} nemá žádné argumenty nebo návratovou vlastnost {1}, která by šla nastavit. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csRequiredSignatureIs">
        <source>The required signature is {0}</source>
        <target state="translated">Požadovaná signatura je {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'.</source>
        <target state="translated">Konstruktor členu nebo objektu {0} vyžaduje argumenty ({1}). Požadovaná signatura je {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch2">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'.</source>
        <target state="translated">Konstruktor členu nebo objektu {0} vyžaduje další argumenty ({1}). Požadovaná signatura je {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch3">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">Konstruktor členu nebo objektu {0} vyžaduje argumenty ({1}). Požadovaná signatura je {2}. Některé názvy chybějících argumentů jsou {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch4">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">Konstruktor členu nebo objektu {0} vyžaduje další argumenty ({1}). Požadovaná signatura je {2}. Některé názvy chybějících argumentů jsou {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityNamed">
        <source>The member or object constructor '{0}' requires {1} argument(s) but is here given {2} unnamed and {3} named argument(s). The required signature is '{4}'.</source>
        <target state="translated">Počet argumentů, které konstruktor členu nebo objektu {0} vyžaduje, je {1}, ale počet těch, které se mu tady předávají, je {2} (nepojmenované) a {3} (pojmenované). Požadovaná signatura je {4}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArity">
        <source>The member or object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Počet argumentů, které přebírá konstruktor členu nebo objektu {0}, je {1}, ale počet těch, které se mu tady předávají, je {2}. Požadovaná signatura je {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArity">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Konstruktor objektu {0} přebírá tento počet argumentů: {1}. Tady ale získal jen tento počet: {2}. Vyžadovaná signatura: {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArityProp">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',').</source>
        <target state="translated">Konstruktor objektu {0} přebírá tento počet argumentů: {1}. Tady ale získal jen tento počet: {2}. Vyžadovaná signatura: {3}. Pokud je účelem některých argumentů přiřazování hodnot k vlastnostem, zvažte oddělení těchto argumentů čárkou (,).</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityType">
        <source>The member or object constructor '{0}' takes {1} type argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Počet argumentů typu, které konstruktor členu nebo objektu {0} přebírá, je {1}, ale počet těch, které se mu tady předávají, je {2}. Požadovaná signatura je {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberNotAccessible">
        <source>A member or object constructor '{0}' taking {1} arguments is not accessible from this code location. All accessible versions of method '{2}' take {3} arguments.</source>
        <target state="translated">Konstruktor členu nebo objektu {0}, který přebírá argumenty ({1}), není na tomto místě v kódu dostupný. Počet argumentů přebíraných všemi přístupnými verzemi metody {2} je {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csIncorrectGenericInstantiation">
        <source>Incorrect generic instantiation. No {0} member named '{1}' takes {2} generic arguments.</source>
        <target state="translated">Nesprávná obecná instance. Žádný člen {0} s názvem {1} nepřebírá obecné argumenty v počtu {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberOverloadArityMismatch">
        <source>The member or object constructor '{0}' does not take {1} argument(s). An overload was found taking {2} arguments.</source>
        <target state="translated">Konstruktor členu nebo objektu {0} nepřebírá argumenty ({1}). Zjistilo se, že počet argumentů přebíraných přetížením je {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments</source>
        <target state="translated">Žádný konstruktor členu nebo objektu {0} s názvem {1} nepřebírá argumenty v počtu {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments2">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. Note the call to this member also provides {3} named arguments.</source>
        <target state="translated">Žádný konstruktor členu nebo objektu {0} s názvem {1} nepřebírá argumenty v počtu {2}. Kromě toho poskytuje volání tohoto členu taky pojmenované argumenty ({3}).</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments3">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. The named argument '{3}' doesn't correspond to any argument or settable return property for any overload.</source>
        <target state="translated">Žádný konstruktor členu nebo objektu {0} s názvem {1} nepřebírá argumenty v počtu {2}. Pojmenovaný argument {3} neodpovídá žádnému argumentu ani nastavitelné návratové vlastnosti u žádného přetížení.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodNotFound">
        <source>Method or object constructor '{0}' not found</source>
        <target state="translated">Konstruktor metody nebo objektu {0} se nenašel.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFound">
        <source>No overloads match for method '{0}'.</source>
        <target state="translated">Metodě {0} neodpovídají žádná přetížení.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsOverloaded">
        <source>A unique overload for method '{0}' could not be determined based on type information prior to this program point. A type annotation may be needed.</source>
        <target state="translated">Unikátní přetížení u metody {0} se nedalo určit podle informací o typu před tímto místem v programu. Možná bude potřeba doplnit k typu poznámku.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCandidates">
        <source>Candidates: {0}</source>
        <target state="translated">Kandidáti: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csSeeAvailableOverloads">
        <source>The available overloads are shown below.</source>
        <target state="translated">Dostupná přetížení jsou zobrazena níže.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsDoCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on 'do' bindings, but '{0}' was given.</source>
        <target state="translated">Modifikátory dostupnosti nejsou u vazeb do povolené, ale předal se modifikátor {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInHashIf">
        <source>End of file in #if section begun at or after here</source>
        <target state="translated">Konec souboru začal v oddílu #if na této pozici nebo za ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInString">
        <source>End of file in string begun at or before here</source>
        <target state="translated">Konec souboru začal v řetězci na této pozici nebo před ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimString">
        <source>End of file in verbatim string begun at or before here</source>
        <target state="translated">Konec souboru začal v doslovném řetězci na této pozici nebo před ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInComment">
        <source>End of file in comment begun at or before here</source>
        <target state="translated">Konec souboru začal v komentáři na této pozici nebo před ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInStringInComment">
        <source>End of file in string embedded in comment begun at or before here</source>
        <target state="translated">Konec souboru začal v řetězci vloženém do komentáře na této pozici nebo před ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimStringInComment">
        <source>End of file in verbatim string embedded in comment begun at or before here</source>
        <target state="translated">Konec souboru začal v doslovném řetězci vloženém do komentáře na této pozici nebo před ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInIfOcaml">
        <source>End of file in IF-OCAML section begun at or before here</source>
        <target state="translated">Konec souboru začal v oddílu IF-OCAML na této pozici nebo před ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInDirective">
        <source>End of file in directive begun at or before here</source>
        <target state="translated">Konec souboru začal v direktivě na této pozici nebo před ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoHashEndIfFound">
        <source>No #endif found for #if or #else</source>
        <target state="translated">Pro direktivu #if nebo #else se nenašla žádná direktiva #endif.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIgnored">
        <source>Attributes have been ignored in this construct</source>
        <target state="translated">Atributy v tomto konstruktoru se ignorovaly.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInImplicitClassConstructors">
        <source>'use' bindings are not permitted in primary constructors</source>
        <target state="translated">U primárních konstruktorů nejsou vazby use povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInModules">
        <source>'use' bindings are not permitted in modules and are treated as 'let' bindings</source>
        <target state="translated">V modulech nejsou vazby use povolené. Zpracují se jako vazby let.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIntegerForLoopRequiresSimpleIdentifier">
        <source>An integer for loop must use a simple identifier</source>
        <target state="translated">Celočíselná smyčka for musí používat jednoduchý identifikátor.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyOneWithAugmentationAllowed">
        <source>At most one 'with' augmentation is permitted</source>
        <target state="translated">Povoluje se nanejvýš jedno rozšíření with.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSemicolon">
        <source>A semicolon is not expected at this point</source>
        <target state="translated">Středník se na této pozici neočekává.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFile">
        <source>Unexpected end of input</source>
        <target state="translated">Neočekávaný konec vstupu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedVisibilityDeclaration">
        <source>Accessibility modifiers are not permitted here, but '{0}' was given.</source>
        <target state="translated">Modifikátory dostupnosti tady nejsou povolené, ale předal se modifikátor {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyHashDirectivesAllowed">
        <source>Only '#' compiler directives may occur prior to the first 'namespace' declaration</source>
        <target state="translated">Před první deklarací namespace se dají použít jenom direktivy kompilátoru #.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityDeclarationsShouldComePriorToIdentifier">
        <source>Accessibility modifiers should come immediately prior to the identifier naming a construct</source>
        <target state="translated">Modifikátory dostupnosti by se měly umístit bezprostředně před identifikátor, který pojmenovává konstruktor.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNamespaceOrModuleNotBoth">
        <source>Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'</source>
        <target state="translated">Soubory by měly začínat buď oborem názvů, nebo deklarací modulu, třeba namespace SomeNamespace.SubNamespace nebo module SomeNamespace.SomeModule, nejde ale použít obojí. Pokud chcete definovat modul uvnitř oboru názvů, použijte syntaxi module SomeModule = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleAbbreviationMustBeSimpleName">
        <source>A module abbreviation must be a simple name, not a path</source>
        <target state="translated">Jako zkratku modulu musíte zadat jednoduchý název, ne cestu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviation">
        <source>Ignoring attributes on module abbreviation</source>
        <target state="translated">Atributy u zkratky modulu se ignorují.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">Atribut přístupu {0} se u zkratky modulu nepovoluje. Zkratky modulu jsou vždycky privátní.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">Atribut viditelnosti {0} se u zkratky modulu nepovoluje. Zkratky modulu jsou vždycky privátní.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnClosedBlockInHashLight">
        <source>Unclosed block</source>
        <target state="translated">Neuzavřený blok</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBeginOrStruct">
        <source>Unmatched 'begin' or 'struct'</source>
        <target state="translated">Nespárované klíčové slovo begin nebo struct</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleDefnMustBeSimpleName">
        <source>A module name must be a simple name, not a path</source>
        <target state="translated">Jako název modulu musíte zadat jednoduchý název, ne cestu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEmptyModuleDefn">
        <source>Unexpected empty type moduleDefn list</source>
        <target state="translated">Neočekávaný prázdný seznam typu moduleDefn</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesMustComeBeforeVal">
        <source>Attributes should be placed before 'val'</source>
        <target state="translated">Správné umístění atributů je před val.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesAreNotPermittedOnInterfaceImplementations">
        <source>Attributes are not permitted on interface implementations</source>
        <target state="translated">Atributy nejsou u implementací rozhraní povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxError">
        <source>Syntax error</source>
        <target state="translated">Chyba syntaxe</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAugmentationsIllegalOnDelegateType">
        <source>Augmentations are not permitted on delegate type moduleDefns</source>
        <target state="translated">Rozšíření nejsou u typu delegáta moduleDefns povolená.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedClassInterfaceOrStruct">
        <source>Unmatched 'class', 'interface' or 'struct'</source>
        <target state="translated">Nespárované klíčové slovo class, interface nebo struct</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyTypeDefinition">
        <source>A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'.</source>
        <target state="translated">Definice typu vyžaduje jeden nebo víc členů nebo jiné deklarace. Pokud máte v úmyslu definovat prázdnou třídu, strukturu nebo rozhraní, použijte formulaci type ... = class end, interface end nebo struct end.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedWith">
        <source>Unmatched 'with' or badly formatted 'with' block</source>
        <target state="translated">Nespárovaný nebo špatně formátovaný blok with</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetOrSetRequired">
        <source>'get', 'set' or 'get,set' required</source>
        <target state="translated">Vyžaduje se metoda get, set nebo get,set.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyClassCanTakeValueArguments">
        <source>Only class types may take value arguments</source>
        <target state="translated">Argumenty hodnoty můžou přebírat jenom typy třídy.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBegin">
        <source>Unmatched 'begin'</source>
        <target state="translated">Nespárované klíčové slovo begin</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidDeclarationSyntax">
        <source>Invalid declaration syntax</source>
        <target state="translated">Neplatná syntaxe deklarace</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetAndOrSetRequired">
        <source>'get' and/or 'set' required</source>
        <target state="translated">Vyžaduje se metoda get nebo set.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAnnotationsOnGetSet">
        <source>Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'</source>
        <target state="translated">Poznámky typu u metod getter nebo setter vlastnosti se musí předávat až po get() nebo set(v). Příklad: with get() : string = </target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterMustHaveAtLeastOneArgument">
        <source>A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'</source>
        <target state="translated">Očekává se, že vlastnost getter bude funkcí, třeba get() = ... nebo get(index) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultipleAccessibilitiesForGetSet">
        <source>Multiple accessibilities given for property getter or setter</source>
        <target state="translated">Zadali jste víc dostupností pro metodu getter nebo setter vlastnosti.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetSyntax">
        <source>Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '</source>
        <target state="translated">Metody set vlastnosti musí být definované pomocí syntaxe set value = , set idx value = nebo set (idx1,...,idxN) value = ... </target>
        <note />
      </trans-unit>
      <trans-unit id="parsInterfacesHaveSameVisibilityAsEnclosingType">
        <source>Interfaces always have the same visibility as the enclosing type</source>
        <target state="translated">Rozhraní mají vždycky stejnou viditelnost jako nadřazený typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAccessibilityModsIllegalForAbstract">
        <source>Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.</source>
        <target state="translated">Modifikátory dostupnosti nejsou u tohoto člena povolené. Abstraktní datové oblasti mají vždycky stejnou viditelnost jako nadřazený typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalOnInherit">
        <source>Attributes are not permitted on 'inherit' declarations</source>
        <target state="translated">Atributy u deklarací inherit nejsou povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityIllegalOnInherit">
        <source>Accessibility modifiers are not permitted on an 'inherits' declaration</source>
        <target state="translated">Modifikátory dostupnosti nejsou v deklaracích inherits povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInheritDeclarationsCannotHaveAsBindings">
        <source>'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding.</source>
        <target state="translated">Deklarace inherit nemůžou mít vazby as. Pro přístup ke členům základní třídy při přepisování metody se dá použít syntaxe base.SomeMember, kde base je klíčové slovo. Tuto vazbu as odeberte.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalHere">
        <source>Attributes are not allowed here</source>
        <target state="translated">Tady atributy nejsou povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for type abbreviations</source>
        <target state="translated">Modifikátory dostupnosti nejsou na této pozici pro zkratky typu povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumTypesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for enum types</source>
        <target state="translated">Modifikátory dostupnosti nejsou na této pozici pro typy výčtu povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAllEnumFieldsRequireValues">
        <source>All enum fields must be given values</source>
        <target state="translated">Všem polím výčtového typu se musí předat hodnota.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInlineAssemblyCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on inline assembly code types</source>
        <target state="translated">Modifikátory dostupnosti nejsou u typů kódu vložených sestavení povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIdentifier">
        <source>Unexpected identifier: '{0}'</source>
        <target state="translated">Neočekávaný identifikátor: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnionCasesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Modifikátory dostupnosti nejsou u případů typu union povolené. Pomocí notace type U = internal ... nebo type U = private ... předejte dostupnost celé reprezentaci.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on enumeration fields</source>
        <target state="translated">Modifikátory dostupnosti nejsou u polí výčtového typu povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsConsiderUsingSeparateRecordType">
        <source>Consider using a separate record type instead</source>
        <target state="translated">Zvažte možnost použít místo toho samostatný typ záznamu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsRecordFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Modifikátory dostupnosti nejsou v polích záznamů povolené. Pomocí type R = internal ... nebo type R = private ... předejte dostupnost celé reprezentaci.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsLetAndForNonRecBindings">
        <source>The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings</source>
        <target state="translated">Notace deklarace let ... and ... se pro nerekurzivní vazby v kódu F# nepoužívá. Zvažte použití posloupnosti vazeb let.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedParen">
        <source>Unmatched '('</source>
        <target state="translated">Nespárovaná závorka (</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessivePatternsShouldBeSpacedOrTupled">
        <source>Successive patterns should be separated by spaces or tupled</source>
        <target state="translated">Po sobě jdoucí vzory by měly být oddělené mezerami nebo by měly být řazenou kolekcí členů.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoMatchingInForLet">
        <source>No matching 'in' found for this 'let'</source>
        <target state="translated">Pro tuto klauzuli let se nenašel žádný odpovídající výraz in.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorInReturnForLetIncorrectIndentation">
        <source>Error in the return expression for this 'let'. Possible incorrect indentation.</source>
        <target state="translated">Chyba ve vráceném výrazu pro tuto klauzuli let. Důvodem může být nesprávné odsazení.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterLet">
        <source>The block following this '{0}' is unfinished. Every code block is an expression and must have a result. '{1}' cannot be the final code element in a block. Consider giving this block an explicit result.</source>
        <target state="translated">Blok, který následuje po tomto {0}, není dokončený. Každý blok kódu je výraz a musí mít výsledek. {1} nemůže být konečný element kódu v bloku. Zvažte, že tomuto bloku dáte explicitní výsledek.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIncompleteIf">
        <source>Incomplete conditional. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Neúplná podmínka. Očekávaná notace je if &lt;výraz&gt; then &lt;výraz&gt; nebo if &lt;výraz&gt; then &lt;výraz&gt; else &lt;výraz&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAssertIsNotFirstClassValue">
        <source>'assert' may not be used as a first class value. Use 'assert &lt;expr&gt;' instead.</source>
        <target state="translated">Metoda assert se nedá použít jako hodnota první třídy. Použijte místo ní assert &lt;výraz&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">Očekával se identifikátor.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInOrEqualExpected">
        <source>'in' or '=' expected</source>
        <target state="translated">Očekává se in nebo =.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsArrowUseIsLimited">
        <source>The use of '-&gt;' in sequence and computation expressions is limited to the form 'for pat in expr -&gt; expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions.</source>
        <target state="translated">Použití -&gt; ve výrazech pořadí a výpočtu je omezené na formu for pat in expr -&gt; expr. Ke generování prvků v komplexnějších výrazech pořadí použijte syntaxi for ... in ... do ... yield...</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessiveArgsShouldBeSpacedOrTupled">
        <source>Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized</source>
        <target state="translated">Po sobě jdoucí argumenty by měly být oddělené mezerami nebo by měly být řazenou kolekcí členů a argumenty zahrnující použití funkcí nebo metod by měly být v závorkách.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracket">
        <source>Unmatched '['</source>
        <target state="translated">Nespárovaná závorka [</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingQualificationAfterDot">
        <source>Missing qualification after '.'</source>
        <target state="translated">Za tečkou chybí kvalifikace.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsParenFormIsForML">
        <source>In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array</source>
        <target state="translated">V kódu F# můžete použít expr.[expr]. Je možné, že bude potřeba zadáním anotace typu vyznačit první výraz v poli.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuote">
        <source>Mismatched quotation, beginning with '{0}'</source>
        <target state="translated">Neshoda v citaci, která začíná na {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatched">
        <source>Unmatched '{0}'</source>
        <target state="translated">Nespárovaný výraz {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracketBar">
        <source>Unmatched '[|'</source>
        <target state="translated">Nespárovaná dvojice znaků [|</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBrace">
        <source>Unmatched '{{'</source>
        <target state="translated">Nespárovaná dvojice závorek {{</target>
        <note />
      </trans-unit>
      <trans-unit id="parsFieldBinding">
        <source>Field bindings must have the form 'id = expr;'</source>
        <target state="translated">Vazba pole musí být v podobě id = expr;</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMemberIllegalInObjectImplementation">
        <source>This member is not permitted in an object implementation</source>
        <target state="translated">Tento člen není u implementace objektu povolený.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingFunctionBody">
        <source>Missing function body</source>
        <target state="translated">Chybí tělo funkce.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxErrorInLabeledType">
        <source>Syntax error in labelled type argument</source>
        <target state="translated">Chyba syntaxe v argumentu typu s popiskem</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedInfixOperator">
        <source>Unexpected infix operator in type expression</source>
        <target state="translated">Neočekávaný operátor vpony ve výrazu typu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultiArgumentGenericTypeFormDeprecated">
        <source>The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident&lt;typ,...,typ&gt;' instead</source>
        <target state="translated">Syntaxe (typ,...,typ) ident se v kódu F# nepoužívá. Zvažte možnost použít místo ní syntaxi ident&lt;typ,...,typ&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidLiteralInType">
        <source>Invalid literal in type</source>
        <target state="translated">Neplatný literál v typu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedOperatorForUnitOfMeasure">
        <source>Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'.</source>
        <target state="translated">Neočekávaný operátor vpony ve výrazu měrné jednotky. Platnými operátory jsou znaky *, / a ^.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIntegerLiteralForUnitOfMeasure">
        <source>Unexpected integer literal in unit-of-measure expression</source>
        <target state="translated">Neočekávaný celočíselný literál ve výrazu měrné jednotky</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedTypeParameter">
        <source>Syntax error: unexpected type parameter specification</source>
        <target state="translated">Chyba syntaxe: neočekávaná specifikace parametru typu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuotationName">
        <source>Mismatched quotation operator name, beginning with '{0}'</source>
        <target state="translated">Neshoda v názvu operátoru citace (začíná na {0})</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseMustBeginWithUpperCase">
        <source>Active pattern case identifiers must begin with an uppercase letter</source>
        <target state="translated">Identifikátory velikosti písmen aktivního vzoru musí začínat velkým písmenem.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseContainsPipe">
        <source>The '|' character is not permitted in active pattern case identifiers</source>
        <target state="translated">Znak | není u identifikátorů velikosti písmen aktivních vzorů povolený.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalDenominatorForMeasureExponent">
        <source>Denominator must not be 0 in unit-of-measure exponent</source>
        <target state="translated">Jmenovatel nesmí být 0 v exponentu měrné jednotky.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoEqualShouldFollowNamespace">
        <source>No '=' symbol should follow a 'namespace' declaration</source>
        <target state="translated">Po deklaraci namespace nemůže následovat symbol =.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleStructEndDeprecated">
        <source>The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">Syntaxe module ... = struct ... end se v kódu F# nepoužívá. Zvažte použití syntaxe module ... = begin ... end.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleSigEndDeprecated">
        <source>The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">Syntaxe module ... : sig .. end se v kódu F# nepoužívá. Zvažte použití syntaxe module ... = begin ... end.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticFieldUsedWhenInstanceFieldExpected">
        <source>A static field was used where an instance field is expected</source>
        <target state="translated">Použili jste statické pole tam, kde se očekává pole instance.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodNotAccessible">
        <source>Method '{0}' is not accessible from this code location</source>
        <target state="translated">Metoda {0} není na tomto místě v kódu dostupná.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplicitMeasureFollowingSlash">
        <source>Implicit product of measures following /</source>
        <target state="translated">Za lomítkem (/) následuje implicitní vytvoření míry.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedMeasureAnon">
        <source>Unexpected SynMeasure.Anon</source>
        <target state="translated">Neočekávalo se SynMeasure.Anon.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonZeroConstantCannotHaveGenericUnit">
        <source>Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.</source>
        <target state="translated">U nenulových konstant nemůžou být obecné jednotky. Obecný nulový zápis je 0.0&lt;_&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSeqResultsUseYield">
        <source>In sequence expressions, results are generated using 'yield'</source>
        <target state="translated">Ve výrazech pořadí se výsledky generují pomocí yield.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedBigRationalConstant">
        <source>Unexpected big rational constant</source>
        <target state="translated">Neočekávaná rozměrná racionální konstanta</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForUnitsOfMeasure">
        <source>Units-of-measure supported only on float, float32, decimal and signed integer types</source>
        <target state="translated">Měrné jednotky se podporují jenom u typů float, float32, decimal a signed integer.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstUint16Array">
        <source>Unexpected Const_uint16array</source>
        <target state="translated">Const_uint16array se neočekávalo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstByteArray">
        <source>Unexpected Const_bytearray</source>
        <target state="translated">Const_bytearray se neočekávalo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterRequiresName">
        <source>A parameter with attributes must also be given a name, e.g. '[&lt;Attribute&gt;] Name : Type'</source>
        <target state="translated">Parametr s atributy vyžaduje rovněž název, například [&lt;atribut&gt;] Název : Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnValuesCannotHaveNames">
        <source>Return values cannot have names</source>
        <target state="translated">Návratové hodnoty nemůžou mít názvy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberKindPropertyGetSetNotExpected">
        <source>MemberKind.PropertyGetSet only expected in parse trees</source>
        <target state="translated">MemberKind.PropertyGetSet se očekává jenom ve stromech pro analýzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainValues">
        <source>Namespaces cannot contain values. Consider using a module to hold your value declarations.</source>
        <target state="translated">Obory názvů nemůžou obsahovat hodnoty. K uložení deklarací hodnot můžete použít modul.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainExtensionMembers">
        <source>Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.</source>
        <target state="translated">Obory názvů nemůžou obsahovat členy rozšíření (to jde jenom ve stejném souboru a skupině deklarací oboru názvů, kde je definovaný i typ). K uložení deklarací členů rozšíření můžete použít modul.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributes">
        <source>Multiple visibility attributes have been specified for this identifier</source>
        <target state="translated">Pro tento identifikátor jste zadali víc atributů viditelnosti.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributesWithLet">
        <source>Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions.</source>
        <target state="translated">Pro tento identifikátor jste zadali víc atributů viditelnosti. Vazby let ve třídách jsou vždycky privátní, stejně jako kterákoli vazba let ve výrazu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForRelationalOperator">
        <source>The name '({0})' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">({0}) není vhodný název pro člena. Pokud chcete definovat sémantiku porovnání pro typ, implementujte rozhraní System.IComparable. Pokud definujete statického člena, který se má použít z jiných jazyků CLI, použijte místo toho název {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForEquality">
        <source>The name '({0})' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">({0}) není vhodný název pro člena. Pokud chcete definovat sémantiku rovnosti pro typ, přepište člena Object.Equals. Pokud definujete statického člena, který se má použít z jiných jazyků CLI, použijte místo toho název {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberName">
        <source>The name '({0})' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">({0}) není vhodný název pro člena. Pokud definujete statického člena, který se má použít z jiných jazyků CLI, použijte místo toho název {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameFixedTypes">
        <source>The name '({0})' should not be used as a member name because it is given a standard definition in the F# library over fixed types</source>
        <target state="translated">({0}) není vhodný název pro člena, protože se mu v knihovně F# prostřednictvím pevných typů předává standardní definice.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionRelational">
        <source>The '{0}' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type.</source>
        <target state="translated">Operátor {0} se nedoporučuje předefinovávat. Pokud chcete definovat přetíženou sémantiku porovnání pro určitý typ, implementujte rozhraní System.IComparable v definici tohoto typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionEquality">
        <source>The '{0}' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type.</source>
        <target state="translated">Operátor {0} se nedoporučuje předefinovávat. Pokud chcete definovat sémantiku rovnosti pro typ, přepište člena Object.Equals v definici tohoto typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinition">
        <source>The '{0}' operator should not normally be redefined. Consider using a different operator name</source>
        <target state="translated">Operátor {0} se nedoporučuje předefinovávat. Zvažte použití jiného názvu operátoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexOperatorDefinition">
        <source>The '{0}' operator cannot be redefined. Consider using a different operator name</source>
        <target state="translated">Operátor {0} se nedá předefinovat. Zvažte možnost použití jiného názvu operátoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectModuleOrNamespaceParent">
        <source>Expected module or namespace parent {0}</source>
        <target state="translated">Očekával se nadřazený prvek modulu nebo oboru názvů {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} implementuje explicitně rozhraní System.IComparable. Pro tento typ musíte použít atribut CustomComparison.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsGenericIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable&lt;_&gt;' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} implementuje explicitně rozhraní System.IComparable&lt;_&gt;. Pro tento typ musíte použít atribut CustomComparison a vytvořit konzistentní implementaci rozhraní System.IComparable, které není obecné.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} implementuje explicitně rozhraní System.IStructuralComparable. Použijte pro tento typ atribut CustomComparison.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordFieldInconsistentTypes">
        <source>This record contains fields from inconsistent types</source>
        <target state="translated">Tento záznam obsahuje pole z nekonzistentních typů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportStubsCannotBeInlined">
        <source>DLLImport stubs cannot be inlined</source>
        <target state="translated">Provizorní kódy DLLImport nemůžou být vložené.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCanOnlyBindThisAtMemberDeclaration">
        <source>Structs may only bind a 'this' parameter at member declarations</source>
        <target state="translated">Struktury můžou u deklarací členů vázat jenom parametr this.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedExprAtRecInfPoint">
        <source>Unexpected expression at recursive inference point</source>
        <target state="translated">Neočekávaný výraz v místě rekurzivního odvození</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLessGenericBecauseOfAnnotation">
        <source>This code is less generic than required by its annotations because the explicit type variable '{0}' could not be generalized. It was constrained to be '{1}'.</source>
        <target state="translated">Tento kód je míň obecný, než požadují jeho poznámky, protože proměnná explicitního typu {0} se nedá zobecnit. Kód se omezil na {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstrainedTypeVariableCannotBeGeneralized">
        <source>One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types</source>
        <target state="translated">Jedna nebo víc proměnných explicitní třídy nebo typu funkce pro tuto vazbu se nedala zobecnit, protože má omezení na jiné typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericParameterHasBeenConstrained">
        <source>A generic type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Parametr obecného typu se použil tak, že ho to omezuje, aby vždycky byl {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterHasBeenConstrained">
        <source>This type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Tento parametr typu se použil způsobem, který ho omezuje v tom smyslu, že musí být vždycky {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParametersInferredAreNotStable">
        <source>The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</source>
        <target state="translated">Parametry typu odvozené pro tuto hodnotu nejsou v případě vymazání zkratek typů stabilní. To je způsobené použitím zkratek typu, které vypouštějí nebo mění pořadí parametrů typu, třeba pomocí notace\n\ttype taggedInt&lt;'a&gt; = int nebo\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nZvažte deklarování parametrů typu pro tuto hodnotu explicitně, třeba pomocí notace\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeParameterInvalid">
        <source>Explicit type parameters may only be used on module or member bindings</source>
        <target state="translated">Explicitní parametry typu se dají použít jenom u vazeb modulu nebo člena.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridingMethodRequiresAllOrNoTypeParameters">
        <source>You must explicitly declare either all or no type parameters when overriding a generic abstract method</source>
        <target state="translated">Při přepisování obecné abstraktní metody musíte explicitně deklarovat buď všechny, nebo žádné parametry typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldsDoNotDetermineUniqueRecordType">
        <source>The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type</source>
        <target state="translated">Tyto popisky pole a očekávaný typ tohoto výrazu záznamu nebo vzoru neurčují jednoznačně odpovídající typ záznamu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldAppearsTwiceInRecord">
        <source>The field '{0}' appears twice in this record expression or pattern</source>
        <target state="translated">Pole {0} se v tomto výrazu záznamu nebo vzoru vyskytuje dvakrát.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnknownUnion">
        <source>Unknown union case</source>
        <target state="translated">Neznámý případ typu union</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotSufficientlyGenericBecauseOfScope">
        <source>This code is not sufficiently generic. The type variable {0} could not be generalized because it would escape its scope.</source>
        <target state="translated">Tento kód není dostatečně obecný. Proměnná typu {0} se nedá zobecnit, protože by se tak dostala mimo svůj definiční obor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyRequiresExplicitTypeParameters">
        <source>A property cannot have explicit type parameters. Consider using a method instead.</source>
        <target state="translated">Vlastnost nemůže mít explicitní parametry typu. Zvažte místo toho možnost použití metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorCannotHaveTypeParameters">
        <source>A constructor cannot have explicit type parameters. Consider using a static construction method instead.</source>
        <target state="translated">Konstruktor nemůže mít parametry explicitního typu. Zvažte možnost použít místo toho metodu statické konstrukce.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInstanceMemberRequiresTarget">
        <source>This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'.</source>
        <target state="translated">Tento člen instance vyžaduje, aby parametr představoval objekt, který se vyvolává. Upravte člena tak, aby byl statický, nebo použijte notaci member x.Member(args) =</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertyInSyntaxTree">
        <source>Unexpected source-level property specification in syntax tree</source>
        <target state="translated">Ve stromu syntaxe se neočekávala specifikace vlastnosti na úrovni zdroje.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializerRequiresArgument">
        <source>A static initializer requires an argument</source>
        <target state="translated">Statický inicializátor vyžaduje argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorRequiresArgument">
        <source>An object constructor requires an argument</source>
        <target state="translated">Konstruktor objektu vyžaduje argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticMemberShouldNotHaveThis">
        <source>This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'.</source>
        <target state="translated">Tento statický člen by neměl mít parametr this. Zvažte použití notace member Member(args) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitStaticInitializerSyntax">
        <source>An explicit static initializer should use the syntax 'static new(args) = expr'</source>
        <target state="translated">Explicitní statický inicializátor by měl používat syntaxi static new(args) = expr.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitObjectConstructorSyntax">
        <source>An explicit object constructor should use the syntax 'new(args) = expr'</source>
        <target state="translated">Explicitní konstruktor objektu by měl používat syntaxi new(args) = expr.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertySpec">
        <source>Unexpected source-level property specification</source>
        <target state="translated">Neočekávaná specifikace vlastnosti na úrovni zdroje</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionFormDeprecated">
        <source>This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions.</source>
        <target state="translated">Tato notace objektového výrazu se v F# nepoužívá. K definování implementací členů v objektových výrazech použijte member this.MemberName ... = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDeclaration">
        <source>Invalid declaration</source>
        <target state="translated">Neplatná deklarace</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesInvalidInPatterns">
        <source>Attributes are not allowed within patterns</source>
        <target state="translated">Atributy nejsou ve vzorech se povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitTypeArguments">
        <source>The generic function '{0}' must be given explicit type argument(s)</source>
        <target state="translated">Obecné funkci {0} se musí předávat explicitní argumenty typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoesNotAllowExplicitTypeArguments">
        <source>The method or function '{0}' should not be given explicit type argument(s) because it does not declare its type parameters explicitly</source>
        <target state="translated">Metodě nebo funkci {0} by se neměly předávat argumenty explicitního typu, protože svoje parametry typu nedeklaruje explicitně.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterArityMismatch">
        <source>This value, type or method expects {0} type parameter(s) but was given {1}</source>
        <target state="translated">Tato hodnota, typ nebo metoda očekává parametry typu v počtu {0}, ale počet předaných je {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultStructConstructorCall">
        <source>The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization</source>
        <target state="translated">Výchozí konstruktor s nulovou inicializací typu struktura se dá použít jenom v případě, že všechna pole typu struktura připouštějí výchozí inicializaci.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindIDisposable">
        <source>Couldn't find Dispose on IDisposable, or it was overloaded</source>
        <target state="translated">V rozhraní IDisposable se nenašla metoda Dispose nebo je tato metoda přetížená.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonLiteralCannotBeUsedInPattern">
        <source>This value is not a literal and cannot be used in a pattern</source>
        <target state="translated">Tato hodnota není literálová a nedá se ve vzoru použít.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsReadonly">
        <source>This field is readonly</source>
        <target state="translated">Toto pole je jen pro čtení.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameArgumentsMustAppearLast">
        <source>Named arguments must appear after all other arguments</source>
        <target state="translated">Pojmenované argumenty musí být umístěné až za všemi ostatními argumenty.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitLambda">
        <source>This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking {0} arguments.</source>
        <target state="translated">Tato hodnota funkce se používá k vytvoření typu delegáta, jehož signatura obsahuje argument ByRef. Musíte použít explicitní výraz lambda, který přebírá argumenty v počtu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCannotBeEnumerated">
        <source>The type '{0}' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method</source>
        <target state="translated">Typ {0} není typem, u kterého by se dal pomocí této syntaxe vytvořit výčet hodnot, tj. není kompatibilní s seq&lt;_&gt;, IEnumerable&lt;_&gt; ani IEnumerable a nemá metodu GetEnumerator.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMixtureOfRecursiveForms">
        <source>This recursive binding uses an invalid mixture of recursive forms</source>
        <target state="translated">Tato rekurzivní vazba používá neplatnou kombinaci rekurzivních tvarů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectConstructionExpression">
        <source>This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.</source>
        <target state="translated">Toto není platný výraz konstruktoru objektu. Explicitní konstruktor objektu musí buď volat alternativní konstruktor, nebo inicializovat všechna pole objektu a specifikovat volání konstruktoru nadřazené třídy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraint">
        <source>Invalid constraint</source>
        <target state="translated">Neplatné omezení</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraintTypeSealed">
        <source>Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution</source>
        <target state="translated">Neplatné omezení: Typ použitý pro toto omezení je zapečetěný. Znamená to, že tomuto omezení může vyhovovat maximálně jedno řešení.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumConstraint">
        <source>An 'enum' constraint must be of the form 'enum&lt;type&gt;'</source>
        <target state="translated">Omezení enum musí mít notaci enum&lt;type&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNewConstraint">
        <source>'new' constraints must take one argument of type 'unit' and return the constructed type</source>
        <target state="translated">Omezení new musí přebírat jeden argument typu unit a vracet konstruovaný typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPropertyType">
        <source>This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -&gt; ty3'. Properties returning functions should have types of the form '(ty1 -&gt; ty2)'.</source>
        <target state="translated">Tato vlastnost je neplatného typu. Vlastnosti, které přebírají víc argumentů indexeru, by měly mít typy s notací ty1 * ty2 -&gt; ty3. Vlastnosti, které vrací funkce, by měly mít typy s notací (ty1 -&gt; ty2).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureMarkWithAttribute">
        <source>Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.</source>
        <target state="translated">Očekával se parametr měrné jednotky, ne parametr typu. Explicitní parametry měrných jednotek musí být označené atributem [&lt;Measure&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeParameter">
        <source>Expected type parameter, not unit-of-measure parameter</source>
        <target state="translated">Očekával se parametr typu, ne parametr měrné jednotky.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeNotUnitOfMeasure">
        <source>Expected type, not unit-of-measure</source>
        <target state="translated">Očekával se typ, ne měrná jednotka.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureNotType">
        <source>Expected unit-of-measure, not type</source>
        <target state="translated">Očekávala se měrná jednotka, ne typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUnitsOfMeasurePrefix">
        <source>Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.</source>
        <target state="translated">Měrné jednotky se nedají použít jako argumenty předpony typu. Přepište je na argumenty přípony v lomených závorkách.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnitsOfMeasureInvalidInTypeConstructor">
        <source>Unit-of-measure cannot be used in type constructor application</source>
        <target state="translated">Měrná jednotka se v použití konstruktoru typu použít nedá.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireBuilderMethod">
        <source>This control construct may only be used if the computation expression builder defines a '{0}' method</source>
        <target state="translated">Tento řídicí konstruktor se dá použít jenom v případě, že tvůrce výrazu výpočtu definuje metodu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoNestedTypes">
        <source>This type has no nested types</source>
        <target state="translated">Tento typ nemá žádné vnořené typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSymbolInTypeExpression">
        <source>Unexpected {0} in type expression</source>
        <target state="translated">Neočekávalo se {0} ve výrazu typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterInvalidAsTypeConstructor">
        <source>Type parameter cannot be used as type constructor</source>
        <target state="translated">Parametr typu se jako konstruktor typu použít nedá.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalSyntaxInTypeExpression">
        <source>Illegal syntax in type expression</source>
        <target state="translated">Neplatná syntaxe ve výrazu typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousUnitsOfMeasureCannotBeNested">
        <source>Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression</source>
        <target state="translated">Anonymní měrná jednotka se nedá vnořit do jiného výrazu měrné jednotky.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousTypeInvalidInDeclaration">
        <source>Anonymous type variables are not permitted in this declaration</source>
        <target state="translated">Anonymní typy proměnných nejsou v této deklaraci povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSlashInType">
        <source>Unexpected / in type</source>
        <target state="translated">V typu se neočekávalo lomítko (/).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedTypeArguments">
        <source>Unexpected type arguments</source>
        <target state="translated">Neočekávané argumenty typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsOnlyOnMembers">
        <source>Optional arguments are only permitted on type members</source>
        <target state="translated">Nepovinné argumenty jsou povolené jenom u členů typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameNotBoundInPattern">
        <source>Name '{0}' not bound in pattern context</source>
        <target state="translated">Název {0} nemá vazbu v kontextu vzoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNonPrimitiveLiteralInPatternMatch">
        <source>Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when &lt;variable&gt; = &lt;constant&gt;' at the end of the match clause.</source>
        <target state="translated">Konstanty číselných literálů, které nejsou primitivní, se nedají použít u porovnání vzorů, protože můžou být během použití modulu NumericLiteral mapované na víc různých typů. Zvažte možnost nahrazení proměnnou a na konci klauzule porovnání použijte when &lt;variable&gt; = &lt;constant&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentUsage">
        <source>Type arguments cannot be specified here</source>
        <target state="translated">Argumenty typu tady nejde zadat.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireActivePatternWithOneResult">
        <source>Only active patterns returning exactly one result may accept arguments</source>
        <target state="translated">Argumenty můžou přebírat jenom aktivní vzory, které vracejí právě jeden výsledek.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidArgForParameterizedPattern">
        <source>Invalid argument to parameterized pattern label</source>
        <target state="translated">Neplatný argument popisku parametrizovaného vzoru</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexIntoActivePatternArray">
        <source>Internal error. Invalid index into active pattern array</source>
        <target state="translated">Vnitřní chyba. Neplatný index pro pole aktivního vzoru</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseDoesNotTakeArguments">
        <source>This union case does not take arguments</source>
        <target state="translated">Tento případ typu union nepřebírá argumenty.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseRequiresOneArgument">
        <source>This union case takes one argument</source>
        <target state="translated">Tento případ typu union přebírá jeden argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseExpectsTupledArguments">
        <source>This union case expects {0} arguments in tupled form</source>
        <target state="translated">Tento případ typu union očekává argumenty v počtu {0} v podobě řazené kolekce členů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotStatic">
        <source>Field '{0}' is not static</source>
        <target state="translated">Pole {0} není statické.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNotLiteralCannotBeUsedInPattern">
        <source>This field is not a literal and cannot be used in a pattern</source>
        <target state="translated">Toto pole není literál a nedá se použít ve vzoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireVarConstRecogOrLiteral">
        <source>This is not a variable, constant, active recognizer or literal</source>
        <target state="translated">Toto není proměnná, konstanta, aktivní rozlišovač nebo literál.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPattern">
        <source>This is not a valid pattern</source>
        <target state="translated">Toto není platný vzor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseWhenPatternGuard">
        <source>Character range matches have been removed in F#. Consider using a 'when' pattern guard instead.</source>
        <target state="translated">Porovnání rozsahu znaků se už v F# nepoužívá. Zvažte možnost použít místo toho ochrannou vazbu vzoru when.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalPattern">
        <source>Illegal pattern</source>
        <target state="translated">Neplatný vzor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxErrorUnexpectedQMark">
        <source>Syntax error - unexpected '?' symbol</source>
        <target state="translated">Chyba syntaxe: neočekávaný symbol ?</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionCountMisMatch">
        <source>Expected {0} expressions, got {1}</source>
        <target state="translated">Očekávaný počet výrazů je {0}. Počet předaných je {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExprUndelayed">
        <source>TcExprUndelayed: delayed</source>
        <target state="translated">TcExprUndelayed: zpožděné</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionRequiresSequence">
        <source>This expression form may only be used in sequence and computation expressions</source>
        <target state="translated">Tato notace výrazu se dá použít jenom ve výrazech pořadí a výpočtu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectExpressionSyntaxForm">
        <source>Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.</source>
        <target state="translated">Neplatný objektový výraz. U objektů bez přepsání nebo rozhraní by se měl výraz formulovat pomocí notace new Type(args) bez složených závorek.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectSequenceOrRecordExpression">
        <source>Invalid object, sequence or record expression</source>
        <target state="translated">Neplatný výraz objektu, pořadí nebo záznamu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSequenceExpressionSyntaxForm">
        <source>Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq {{ ... }}'</source>
        <target state="translated">Neplatný výraz záznamu, pořadí nebo výpočtu. Výrazy pořadí by měly mít notaci seq {{ ... }}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionWithIfRequiresParenthesis">
        <source>This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression</source>
        <target state="translated">Tento výraz seznamu nebo pole zahrnuje element s formulací if ... then ... else. Ohraničte tento výraz závorkami, aby bylo jasné, že jde o samostatný prvek seznamu nebo pole. Odlišíte ho tak od seznamu generovaného pomocí výrazu pořadí.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseFormatString">
        <source>Unable to parse format string '{0}'</source>
        <target state="translated">Formátovací řetězec {0} se nedá parsovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcListLiteralMaxSize">
        <source>This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.</source>
        <target state="translated">Tento výraz seznamu překračuje maximální velikost literálů seznamu. Použijte pole pro rozsáhlejší literály a volejte metodu Array.ToList.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresObjectConstructor">
        <source>The expression form 'expr then expr' may only be used as part of an explicit object constructor</source>
        <target state="translated">Notace expr then expr se dá ve výrazu použít jenom v rámci explicitního konstruktoru objektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentsCannotBeUsedInMemberTraits">
        <source>Named arguments cannot be given to member trait calls</source>
        <target state="translated">Pojmenované argumenty nejde předávat voláním vlastností členů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotValidEnumCaseName">
        <source>This is not a valid name for an enumeration case</source>
        <target state="translated">Toto není platný název případu výčtu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotMutable">
        <source>This field is not mutable</source>
        <target state="translated">Toto pole není měnitelné.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresListArrayOrSequence">
        <source>This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq {{ ... }}', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements</source>
        <target state="translated">Tento konstruktor se dá použít jenom ve výrazech seznamů, polí a posloupností, například ve výrazech ve formě seq {{ ... }}, [ ... ] nebo [| ... |]. Tyto výrazy používají syntaxi for ... in ... do ... yield... ke generování elementů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpressions">
        <source>This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'.</source>
        <target state="translated">Tento konstruktor se dá použít jenom ve výrazech výpočtu. Pokud chcete vracet hodnotu z běžné funkce, napište jednoduše výraz bez return.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresSequenceOrComputations">
        <source>This construct may only be used within sequence or computation expressions</source>
        <target state="translated">Tento konstruktor se dá použít jenom ve výrazech pořadí nebo výpočtu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpression">
        <source>This construct may only be used within computation expressions</source>
        <target state="translated">Tento konstruktor se dá použít jenom ve výrazech výpočtu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexerExpression">
        <source>Invalid indexer expression</source>
        <target state="translated">Neplatný výraz indexeru</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
        <source>The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints</source>
        <target state="translated">Operátor expr.[idx] se používá u objektu neurčitého typu založeného na informacích před tímto místem v programu. Zvažte přidání dalších omezení typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromVariableType">
        <source>Cannot inherit from a variable type</source>
        <target state="translated">Z typu proměnné se nedá dědit.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsOnTypeParametersCannotTakeArguments">
        <source>Calls to object constructors on type parameters cannot be given arguments</source>
        <target state="translated">Volání konstruktorů objektu u parametrů typu se nedají předávat argumenty.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCompiledNameAttributeMisused">
        <source>The 'CompiledName' attribute cannot be used with this language element</source>
        <target state="translated">Atribut CompiledName se nedá u tohoto elementu jazyka použít.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedTypeRequired">
        <source>'{0}' may only be used with named types</source>
        <target state="translated">{0} se dá použít jenom u pojmenovaných typů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritCannotBeUsedOnInterfaceType">
        <source>'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead.</source>
        <target state="translated">Deklarace inherit se nedá použít u typů rozhraní. Zvažte místo toho možnost implementovat rozhraní pomocí interface ... with ... end.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewCannotBeUsedOnInterfaceType">
        <source>'new' cannot be used on interface types. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">U typů rozhraní se new použít nedá. Zvažte možnost použít místo toho objektový výraz {{ new ... with ... }}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractTypeCannotBeInstantiated">
        <source>Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">Instance tohoto typu se nedají vytvořit, a to buď proto, že je tento typ označený jako abstraktní, nebo proto, že jste neimplementovali všechny metody. Zvažte možnost použít místo toho objektový výraz {{ new ... with ... }}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIDisposableTypeShouldUseNew">
        <source>It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value</source>
        <target state="translated">Doporučuje se, aby se objekty, které podporují rozhraní IDisposable, vytvářely pomocí syntaxe new Type(args) a ne Type(args) nebo Type jako hodnota funkce představující konstruktor. Tím se určí, že prostředky může vlastnit generovaná hodnota.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxCanOnlyBeUsedToCreateObjectTypes">
        <source>'{0}' may only be used to construct object types</source>
        <target state="translated">{0} se dá použít jenom k vytvoření objektových typů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresCall">
        <source>Constructors for the type '{0}' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.</source>
        <target state="translated">Konstruktory pro typ {0} musí přímo nebo nepřímo volat svoje implicitní konstruktory objektu. Místo výrazu záznamu použijte volání implicitního konstruktoru objektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUndefinedField">
        <source>The field '{0}' has been given a value, but is not present in the type '{1}'</source>
        <target state="translated">Poli {0} se předala hodnota, která se ale nenachází v typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresAssignment">
        <source>No assignment given for field '{0}' of type '{1}'</source>
        <target state="translated">Poli {0} typu {1} se nepředalo žádné přiřazení.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExtraneousFieldsGivenValues">
        <source>Extraneous fields have been given values</source>
        <target state="translated">Nadbytečným polím se předaly hodnoty.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
        <source>Only overrides of abstract and virtual members may be specified in object expressions</source>
        <target state="translated">V objektových výrazech se dají specifikovat jenom přepsání abstraktních a virtuálních členů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoAbstractOrVirtualMemberFound">
        <source>The member '{0}' does not correspond to any abstract or virtual method available to override or implement.</source>
        <target state="translated">Člen {0} neodpovídá žádné abstraktní ani virtuální metodě, která by se dala přepsat nebo implementovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberFoundIsNotAbstractOrVirtual">
        <source>The type {0} contains the member '{1}' but it is not a virtual or abstract method that is available to override or implement.</source>
        <target state="translated">Typ {0} obsahuje člen {1}, ale není to virtuální nebo abstraktní metoda, která by se dala přepsat nebo implementovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatch">
        <source>The member '{0}' does not accept the correct number of arguments. {1} argument(s) are expected, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">Člen {0} nepřijímá správný počet argumentů. Očekávaný počet argumentů je {1}, ale předalo se jich {2}. Požadovaná signatura je {3}.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatchOneOverload">
        <source>The member '{0}' does not accept the correct number of arguments. One overload accepts {1} arguments, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">Člen {0} nepřijímá správný počet argumentů. Počet argumentů přijímaných jedním přetížením je {1}, ale předalo se jich {2}. Požadovaná signatura je {3}.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSimpleMethodNameRequired">
        <source>A simple method name is required here</source>
        <target state="translated">Tady se vyžaduje jednoduchý název metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPredefinedTypeCannotBeUsedAsSuperType">
        <source>The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class</source>
        <target state="translated">Typy System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate a System.Array se v objektovém výrazu nebo ve třídě objektu nedají použít jako nadřazené.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMustBeUsedWithNamedType">
        <source>'new' must be used with a named type</source>
        <target state="translated">U new se musí použít pojmenovaný typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCreateExtensionOfSealedType">
        <source>Cannot create an extension of a sealed type</source>
        <target state="translated">Nejde vytvořit rozšíření zapečetěného typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoArgumentsForRecordValue">
        <source>No arguments may be given when constructing a record value</source>
        <target state="translated">Při vytváření hodnoty záznamu nejde zadávat argumenty.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoInterfaceImplementationForConstructionExpression">
        <source>Interface implementations cannot be given on construction expressions</source>
        <target state="translated">Implementace rozhraní se s výrazy konstrukcí nedají předávat.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionCanOnlyBeUsedInClassTypes">
        <source>Object construction expressions may only be used to implement constructors in class types</source>
        <target state="translated">Výrazy konstruktoru objektu se dají použít jenom k implementaci konstruktorů v typech tříd.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
        <source>Only simple bindings of the form 'id = expr' can be used in construction expressions</source>
        <target state="translated">Ve výrazech konstrukcí se dají použít jenom jednoduché vazby s notací id = expr.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectsMustBeInitializedWithObjectExpression">
        <source>Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field</source>
        <target state="translated">Objekty se musí inicializovat pomocí výrazu konstruktoru objektu, který volá zděděný konstruktor objektu a přiřazuje hodnoty ke všem polím.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedInterfaceType">
        <source>Expected an interface type</source>
        <target state="translated">Očekával se typ rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorForInterfacesDoNotTakeArguments">
        <source>Constructor expressions for interfaces do not take arguments</source>
        <target state="translated">Výrazy konstruktorů pro rozhraní nepřebírají argumenty.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresArguments">
        <source>This object constructor requires arguments</source>
        <target state="translated">Tento konstruktor objektu vyžaduje argumenty.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewRequiresObjectConstructor">
        <source>'new' may only be used with object constructors</source>
        <target state="translated">Klíčové slovo new se dá použít jenom s konstruktory objektů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAtLeastOneOverrideIsInvalid">
        <source>At least one override did not correctly implement its corresponding abstract member</source>
        <target state="translated">Nejmíň jedno přepsání neimplementovalo správně odpovídající abstraktní člen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNumericLiteralRequiresModule">
        <source>This numeric literal requires that a module '{0}' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope</source>
        <target state="translated">Tento číselný literál vyžaduje, aby modul {0} definující funkce FromZero, FromOne, FromInt32, FromInt64 a FromString byl v definičním oboru.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRecordConstruction">
        <source>Invalid record construction</source>
        <target state="translated">Neplatná konstrukce záznamu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresRecordTypes">
        <source>The expression form {{ expr with ... }} may only be used with record types. To build object types use {{ new Type(...) with ... }}</source>
        <target state="translated">Notace {{ expr with ... }} se dá ve výrazech použít jenom u typů záznamu. Pokud chcete vytvořit objektové typy, použijte formulaci {{ new Type(...) with ... }}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritedTypeIsNotObjectModelType">
        <source>The inherited type is not an object model type</source>
        <target state="translated">Zděděný typ není typem objektového modelu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
        <source>Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors</source>
        <target state="translated">Výrazy konstruktoru objektu (třeba výrazy záznamu se specifikací dědičnosti) se dají použít jenom k implementaci konstruktorů v typech objektového modelu. K vytvoření instancí typů objektového modelu mimo konstruktory použijte new ObjectType(args).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyRecordInvalid">
        <source>'{{ }}' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.</source>
        <target state="translated">{{ }} není platný výraz. Záznamy musí obsahovat alespoň jedno pole. Prázdné posloupnosti se specifikují pomocí Seq.empty nebo prázdného seznamu [].</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordTypeNeedConstructor">
        <source>This type is not a record type. Values of class and struct types must be created using calls to object constructors.</source>
        <target state="translated">Tento typ není typem záznamu. Hodnoty typů třída a struktura se musí vytvořit pomocí volání konstruktorů objektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordType">
        <source>This type is not a record type</source>
        <target state="translated">Tento typ není typem záznamu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInComputationExpression">
        <source>This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder {{ ... }}'.</source>
        <target state="translated">Tento konstruktor je jako součást výrazu výpočtu nejednoznačný. Vnořené výrazy jde zapsat pomocí notace let _ = (...) a vnořené výpočty pomocí notace let! res = builder {{ ... }}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInSequenceExpression">
        <source>This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {{... }}'.</source>
        <target state="translated">Tento konstruktor je jako součást výrazu pořadí nejednoznačný. Vnořené výrazy jde zapsat pomocí notace let _ = (...) a vnořená pořadí pomocí notace yield! seq {{... }}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoBangIllegalInSequenceExpression">
        <source>'do!' cannot be used within sequence expressions</source>
        <target state="translated">Klíčové slovo do! se ve výrazech pořadí nedá použít.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseForInSequenceExpression">
        <source>The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead.</source>
        <target state="translated">Použití notace let! x = coll ve výrazech pořadí není povolené. Použijte místo ní notaci for x in coll.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryIllegalInSequenceExpression">
        <source>'try'/'with' cannot be used within sequence expressions</source>
        <target state="translated">Výrazy try/with se u výrazů pořadí použít nedají.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseYieldBangForMultipleResults">
        <source>In sequence expressions, multiple results are generated using 'yield!'</source>
        <target state="translated">Ve výrazech pořadí se víc výsledků generuje pomocí yield!.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAssignment">
        <source>Invalid assignment</source>
        <target state="translated">Neplatné přiřazení</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfTypeName">
        <source>Invalid use of a type name</source>
        <target state="translated">Neplatné použití názvu typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoAccessibleConstructor">
        <source>This type has no accessible object constructors</source>
        <target state="translated">Pro tento typ nejsou dostupné žádné konstruktory objektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfInterfaceType">
        <source>Invalid use of an interface type</source>
        <target state="translated">Neplatné použití typu rozhraní</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfDelegate">
        <source>Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'.</source>
        <target state="translated">Neplatné použití konstruktoru delegáta. Použijte syntaxi new Type(args) nebo jenom Type(args).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotStatic">
        <source>Property '{0}' is not static</source>
        <target state="translated">Vlastnost {0} není statická.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotReadable">
        <source>Property '{0}' is not readable</source>
        <target state="translated">Vlastnost {0} se nedá přečíst.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLookupMayNotBeUsedHere">
        <source>This lookup cannot be used here</source>
        <target state="translated">Toto vyhledávání se tady nedá použít.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsStatic">
        <source>Property '{0}' is static</source>
        <target state="translated">Vlastnost {0} je statická.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet1">
        <source>Property '{0}' cannot be set</source>
        <target state="translated">Vlastnost {0} se nedá nastavit.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsCannotBeFirstClassValues">
        <source>Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</source>
        <target state="translated">Konstruktory se musí použít pro argumenty a nejde je použít jako hodnoty první třídy. V případě potřeby použijte anonymní funkci (fun arg1 ... argN -&gt; new Type(arg1,...,argN)).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
        <source>The syntax 'expr.id' may only be used with record labels, properties and fields</source>
        <target state="translated">Syntaxe expr.id se dá použít jenom u vlastností, polí a popisků záznamů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsStatic">
        <source>Event '{0}' is static</source>
        <target state="translated">Událost {0} je statická.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsNotStatic">
        <source>Event '{0}' is not static</source>
        <target state="translated">Událost {0} není statická.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentDidNotMatch">
        <source>The named argument '{0}' did not match any argument or mutable property</source>
        <target state="translated">Pojmenovaný argument {0} neodpovídá žádnému argumentu nebo měnitelné vlastnosti.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverloadsCannotHaveCurriedArguments">
        <source>One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.</source>
        <target state="translated">Minimálně jedno přetížení této metody má curryfikované argumenty. Zvažte úpravu návrhu těchto členů tak, aby přebíraly argumenty v podobě řazené kolekce členů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnnamedArgumentsDoNotFormPrefix">
        <source>The unnamed arguments do not form a prefix of the arguments of the method called</source>
        <target state="translated">Nepojmenované argumenty netvoří předponu argumentů volané metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
        <source>Static optimization conditionals are only for use within the F# library</source>
        <target state="translated">Podmínky statické optimalizace se používají jenom v knihovně F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFormalArgumentIsNotOptional">
        <source>The corresponding formal argument is not optional</source>
        <target state="translated">Odpovídající formální argument není nepovinný.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOptionalAssignmentToPropertyOrField">
        <source>Invalid optional assignment to a property or field</source>
        <target state="translated">Neplatné nepovinné přiřazení k vlastnosti nebo poli</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegateConstructorMustBePassed">
        <source>A delegate constructor must be passed a single function value</source>
        <target state="translated">Konstruktoru delegáta se musí předávat jediná hodnota funkce.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindingCannotBeUseAndRec">
        <source>A binding cannot be marked both 'use' and 'rec'</source>
        <target state="translated">Vazba nemůže mít současně označení use i rec.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileOnlyOnClassLetBindings">
        <source>The 'VolatileField' attribute may only be used on 'let' bindings in classes</source>
        <target state="translated">Atribut VolatileField se dá v třídách použít jenom u vazeb let.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesAreNotPermittedOnLetBindings">
        <source>Attributes are not permitted on 'let' bindings in expressions</source>
        <target state="translated">Atributy nejsou u vazeb Let ve výrazech povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultValueAttributeRequiresVal">
        <source>The 'DefaultValue' attribute may only be used on 'val' declarations</source>
        <target state="translated">Atribut DefaultValue se dá použít jenom u deklarací val.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeRequiresMembers">
        <source>The 'ConditionalAttribute' attribute may only be used on members</source>
        <target state="translated">Atribut ConditionalAttribute se dá použít jenom u členů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidActivePatternName">
        <source>This is not a valid name for an active pattern</source>
        <target state="translated">Toto není platný název aktivního vzoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEntryPointAttributeRequiresFunctionInModule">
        <source>The 'EntryPointAttribute' attribute may only be used on function definitions in modules</source>
        <target state="translated">Atribut EntryPointAttribute se dá použít jenom u definic funkcí v modulech.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesCannotBeInline">
        <source>Mutable values cannot be marked 'inline'</source>
        <target state="translated">Označení inline se u proměnlivých hodnot použít nedá.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesMayNotHaveGenericParameters">
        <source>Mutable values cannot have generic parameters</source>
        <target state="translated">Proměnlivé hodnoty nemůžou mít obecné parametry.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesSyntax">
        <source>Mutable function values should be written 'let mutable f = (fun args -&gt; ...)'</source>
        <target state="translated">Zápis proměnlivých hodnot funkcí by měl být let mutable f = (fun args -&gt; ...).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyFunctionsCanBeInline">
        <source>Only functions may be marked 'inline'</source>
        <target state="translated">Označení inline můžou mít jenom funkce.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalAttributesForLiteral">
        <source>A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes</source>
        <target state="translated">Hodnotě literálu se nedají předávat atributy [&lt;ThreadStatic&gt;] nebo [&lt;ContextStatic&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeMutable">
        <source>A literal value cannot be marked 'mutable'</source>
        <target state="translated">Hodnota literálu nemůže mít označení mutable.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeInline">
        <source>A literal value cannot be marked 'inline'</source>
        <target state="translated">Hodnota literálu nemůže mít označení inline.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotHaveGenericParameters">
        <source>Literal values cannot have generic parameters</source>
        <target state="translated">Hodnota literálu nemůže mít obecné parametry.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstantExpression">
        <source>This is not a valid constant expression</source>
        <target state="translated">Toto není platný konstantní výraz.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsInaccessible">
        <source>This type is not accessible from this code location</source>
        <target state="translated">Tento typ není na tomto místě v kódu dostupný.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConditionInImportedAssembly">
        <source>Unexpected condition in imported assembly: failed to decode AttributeUsage attribute</source>
        <target state="translated">Neočekávaná podmínka v importovaném sestavení: nepovedlo se dekódovat atribut AttributeUsage.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedAttributeTarget">
        <source>Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</source>
        <target state="translated">Nerozpoznaný cíl atributu. Platné cíle atributu jsou assembly, module, type, method, property, return, param, field, event a constructor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElementUseDo">
        <source>This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module.</source>
        <target state="translated">Tento atribut není platný pro použití u tohoto elementu jazyka. Atributy sestavení by měly být připojené k deklaraci do (), v případě potřeby v modulu F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElement">
        <source>This attribute is not valid for use on this language element</source>
        <target state="translated">Tento atribut není platný pro použití u tohoto elementu jazyka.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgumentsCannotBeUsedInCustomAttribute">
        <source>Optional arguments cannot be used in custom attributes</source>
        <target state="translated">Nepovinné argumenty se u vlastních atributů použít nedají.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet0">
        <source>This property cannot be set</source>
        <target state="translated">Tato vlastnost se nedá nastavit.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyOrFieldNotFoundInAttribute">
        <source>This property or field was not found on this custom attribute type</source>
        <target state="translated">Tato vlastnost nebo pole se u tohoto typu vlastního atributu nenašla.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustBeReferenceType">
        <source>A custom attribute must be a reference type</source>
        <target state="translated">Vlastní atribut musí být odkazového typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeArgumentMismatch">
        <source>The number of args for a custom attribute does not match the expected number of args for the attribute constructor</source>
        <target state="translated">Počet argumentů pro vlastní atribut neodpovídá očekávanému počtu argumentů pro konstruktor atributu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustInvokeConstructor">
        <source>A custom attribute must invoke an object constructor</source>
        <target state="translated">Vlastní atribut musí vyvolat konstruktor objektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeExpressionsMustBeConstructorCalls">
        <source>Attribute expressions must be calls to object constructors</source>
        <target state="translated">Výrazy atributu musí být volání konstruktorů objektů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedAttribute">
        <source>This attribute cannot be used in this version of F#</source>
        <target state="translated">Tento atribut se v této verzi F# nedá použít.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidInlineSpecification">
        <source>Invalid inline specification</source>
        <target state="translated">Neplatná vložená specifikace</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBinding">
        <source>'use' bindings must be of the form 'use &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">Vazby use musí mít notaci use &lt;var&gt; = &lt;expr&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractMembersIllegalInAugmentation">
        <source>Abstract members are not permitted in an augmentation - they must be defined as part of the type itself</source>
        <target state="translated">Abstraktní členové se v rozšíření nepovolují – musí se definovat v samotném typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodOverridesIllegalHere">
        <source>Method overrides and interface implementations are not permitted here</source>
        <target state="translated">Přepsání metod a implementace rozhraní tady nejsou povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoMemberFoundForOverride">
        <source>No abstract or interface member was found that corresponds to this override</source>
        <target state="translated">Nenašel se žádný abstraktní člen nebo člen rozhraní, který by odpovídal tomuto přepsání.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverrideArityMismatch">
        <source>This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:{0}</source>
        <target state="translated">Toto přepsání přebírá jiný počet argumentů vzhledem k odpovídajícímu abstraktnímu členovi. Našli se následující abstraktní členové: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationAlreadyExists">
        <source>This method already has a default implementation</source>
        <target state="translated">Tato metoda už má výchozí implementaci.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultAmbiguous">
        <source>The method implemented by this default is ambiguous</source>
        <target state="translated">Metoda implementovaná touto výchozí třídou je nejednoznačná.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoPropertyFoundForOverride">
        <source>No abstract property was found that corresponds to this override</source>
        <target state="translated">Nenašla se žádná abstraktní vlastnost, která by odpovídala tomuto přepsání.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractPropertyMissingGetOrSet">
        <source>This property overrides or implements an abstract property but the abstract property doesn't have a corresponding {0}</source>
        <target state="translated">Tato hodnota přepisuje nebo implementuje abstraktní vlastnost, která ale nemá odpovídající metodu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSignatureForSet">
        <source>Invalid signature for set member</source>
        <target state="translated">Neplatná signatura pro člena sady</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMember">
        <source>This new member hides the abstract member '{0}'. Rename the member or use 'override' instead.</source>
        <target state="translated">Tento nový člen skrývá abstraktní člen {0}. Změňte jeho název nebo místo toho použijte klíčové slovo override.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMemberWithSuffix">
        <source>This new member hides the abstract member '{0}' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead.</source>
        <target state="translated">Tento nový člen skrývá po vymazání řazených kolekcí členů, funkcí, měrných jednotek a poskytnutých typů abstraktní člen {0}. Změňte jeho název nebo místo toho použijte klíčové slovo override.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializersIllegalInInterface">
        <source>Interfaces cannot contain definitions of static initializers</source>
        <target state="translated">Rozhraní nemůžou obsahovat definice statických inicializátorů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsIllegalInInterface">
        <source>Interfaces cannot contain definitions of object constructors</source>
        <target state="translated">Rozhraní nemůžou obsahovat definice konstruktorů objektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOverridesIllegalInInterface">
        <source>Interfaces cannot contain definitions of member overrides</source>
        <target state="translated">Rozhraní nemůžou obsahovat definice přepsání členů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConcreteMembersIllegalInInterface">
        <source>Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.</source>
        <target state="translated">Rozhraní nemůžou obsahovat definice konkrétních členů. Možná bude potřeba definovat u typu konstruktor, který bude vyjadřovat, že jde o třídu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsDisallowedInExceptionAugmentation">
        <source>Constructors cannot be specified in exception augmentations</source>
        <target state="translated">V rozšířeních výjimky nejde zadávat konstruktory.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCannotHaveConstructorWithNoArguments">
        <source>Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.</source>
        <target state="translated">Struktury nemůžou mít konstruktor objektu bez argumentů. Toto je omezení, které platí u všech jazyků CLI vzhledem k tomu, že struktury automaticky podporují výchozí konstruktor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalForThisType">
        <source>Constructors cannot be defined for this type</source>
        <target state="translated">Pro tento typ nejde definovat konstruktory.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
        <source>Recursive bindings that include member specifications can only occur as a direct augmentation of a type</source>
        <target state="translated">Rekurzivní vazby, které obsahují specifikace členů, se dají použít jenom jako přímé rozšíření typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimplePatternsInLetRec">
        <source>Only simple variable patterns can be bound in 'let rec' constructs</source>
        <target state="translated">Vazbu v konstruktorech let rec můžou mít jenom vzory s jednoduchými proměnnými.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
        <source>Only record fields and simple, non-recursive 'let' bindings may be marked mutable</source>
        <target state="translated">Označení mutable můžou mít jenom pole záznamu a jednoduché, nerekurzivní vazby let.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberIsNotSufficientlyGeneric">
        <source>This member is not sufficiently generic</source>
        <target state="translated">Tento člen není dostatečně obecný.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralAttributeRequiresConstantValue">
        <source>A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. 'val x : int = 1'</source>
        <target state="translated">Pokud se předává také hodnota konstanty, například val x : int = 1, může být deklarací jenom atribut [&lt;Literal&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="tcValueInSignatureRequiresLiteralAttribute">
        <source>A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute</source>
        <target state="translated">Deklaraci se může v signatuře předávat hodnota jenom v případě, že má deklarace atribut [&lt;Literal&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThreadStaticAndContextStaticMustBeStatic">
        <source>Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread</source>
        <target state="translated">Proměnné, které jsou statické na úrovni vlákna nebo kontextu, musí být statické a musí se jim předávat atribut [&lt;DefaultValue&gt;]. Tím se určí, že se hodnota v každém novém vláknu inicializuje na výchozí hodnotu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileFieldsMustBeMutable">
        <source>Volatile fields must be marked 'mutable' and cannot be thread-static</source>
        <target state="translated">Pole s modifikátorem volatile musí mít označení mutable a nemůžou být statická na úrovni vlákna.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUninitializedValFieldsMustBeMutable">
        <source>Uninitialized 'val' fields must be mutable and marked with the '[&lt;DefaultValue&gt;]' attribute. Consider using a 'let' binding instead of a 'val' field.</source>
        <target state="translated">Neinicializovaná pole val musí být měnitelná a označená atributem [&lt;DefaultValue&gt;]. Zvažte možnost použít místo pole val vazbu let.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticValFieldsMustBeMutableAndPrivate">
        <source>Static 'val' fields in types must be mutable, private and marked with the '[&lt;DefaultValue&gt;]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type.</source>
        <target state="translated">Statická pole val v typech musí být měnitelná, privátní a označená atributem [&lt;DefaultValue&gt;]. Inicializují se na hodnotu null nebo zero podle jejich typu. Zvažte možnost použít v typu třídy také vazbu static let mutable.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresName">
        <source>This field requires a name</source>
        <target state="translated">Toto pole vyžaduje název.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNamespaceModuleTypeUnionName">
        <source>Invalid namespace, module, type or union case name</source>
        <target state="translated">Neplatný název oboru názvů, modulu, typu nebo případu typu union</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalFormForExplicitTypeDeclaration">
        <source>Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -&gt; resTy'. Parentheses may be required around 'resTy'</source>
        <target state="translated">Explicitní deklarace typu pro konstruktory musí mít formulaci ty1 * ... * tyN -&gt; resTy. Je možné, že výraz resTy bude potřeba uzavřít do závorek.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnTypesForUnionMustBeSameAsType">
        <source>Return types of union cases must be identical to the type being defined, up to abbreviations</source>
        <target state="translated">Návratové typy případů typu union musí být identické s typem, který se definuje, a to až po zkratky.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumerationLiteral">
        <source>This is not a valid value for an enumeration literal</source>
        <target state="translated">Toto není platná hodnota pro literál výčtu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType1">
        <source>The type '{0}' is not an interface type</source>
        <target state="translated">Typ {0} není typ rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDuplicateSpecOfInterface">
        <source>Duplicate specification of an interface</source>
        <target state="translated">Duplicitní specifikace rozhraní</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldValIllegalHere">
        <source>A field/val declaration is not permitted here</source>
        <target state="translated">Deklarace pole nebo hodnoty tady není povolená.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritIllegalHere">
        <source>A inheritance declaration is not permitted here</source>
        <target state="translated">Zděděná deklarace tady není povolená.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleRequiresQualifiedAccess">
        <source>This declaration opens the module '{0}', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.</source>
        <target state="translated">Tato deklarace otevírá modul {0}, který má označení RequireQualifiedAccess. Upravte kód tak, aby místo toho používal kvalifikované odkazy na elementy modulu, třeba místo map použijte List.map. Touto změnou zajistíte, že bude kód funkční i v případě, že se budou do knihoven přidávat nové konstruktory.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenUsedWithPartiallyQualifiedPath">
        <source>This declaration opens the namespace or module '{0}' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.</source>
        <target state="translated">Tato deklarace otevírá obor názvů nebo modul {0} prostřednictvím částečně kvalifikované cesty. Upravte tento kód tak, aby používal úplnou cestu oboru názvů. Touto změnou zajistíte, že bude kód funkční i v případě, že se budou do knihoven F# a CLI přidávat nové konstruktory.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLocalClassBindingsCannotBeInline">
        <source>Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.</source>
        <target state="translated">Vazby lokální třídy nemůžou mít označení inline. Zvažte možnost rozšíření definice mimo třídu. V opačném případě neoznačujte jako inline.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsMayNotHaveMembers">
        <source>Type abbreviations cannot have members</source>
        <target state="translated">Zkratky typů nemůžou mít členy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCheckedAtCompileTime">
        <source>As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.</source>
        <target state="translated">Od jazyka F# 4.1 se dostupnost zkratek typů kontroluje při kompilaci. Zvažte možnost změnit dostupnost zkratek typů. Pokud budete toto upozornění ignorovat, může to mít za následek chyby za běhu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsMayNotHaveMembers">
        <source>Enumerations cannot have members</source>
        <target state="translated">Výčty nemůžou mít členy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembers">
        <source>Measure declarations may have only static members</source>
        <target state="translated">Deklarace míry můžou mít jenom statické členy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainDoBindings">
        <source>Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings</source>
        <target state="translated">Struktury nemůžou obsahovat vazby do, protože výchozí konstruktor pro struktury by tyto vazby neprovedl.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainLetBindings">
        <source>Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.</source>
        <target state="translated">Struktury nemůžou obsahovat definice hodnot, protože výchozí konstruktor pro struktury tyto vazby neprovede. Zvažte možnost přidat k primárnímu konstruktoru pro tento typ další argumenty.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticLetBindingsRequireClassesWithImplicitConstructors">
        <source>Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Statické definice hodnot se dají použít jenom u typů s primárním konstruktorem. Zvažte přidání argumentů do definice typu, třeba type X(args) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembersNotConstructors">
        <source>Measure declarations may have only static members: constructors are not available</source>
        <target state="translated">Deklarace míry můžou mít jenom statické členy: Konstruktory dostupné nejsou.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberAndLocalClassBindingHaveSameName">
        <source>A member and a local class binding both have the name '{0}'</source>
        <target state="translated">Vazba členské i lokální třídy má název {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
        <source>Type abbreviations cannot have interface declarations</source>
        <target state="translated">Zkratky typů nemůžou mít deklarace rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsCannotHaveInterfaceDeclaration">
        <source>Enumerations cannot have interface declarations</source>
        <target state="translated">Výčty nemůžou mít deklarace rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType0">
        <source>This type is not an interface type</source>
        <target state="translated">Tento typ není typem rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllImplementedInterfacesShouldBeDeclared">
        <source>All implemented interfaces should be declared on the initial declaration of the type</source>
        <target state="translated">Všechna implementovaná rozhraní by se měla deklarovat při počáteční deklaraci typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
        <source>A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type</source>
        <target state="translated">Výchozí implementace tohoto rozhraní už se přidala, protože jste v definici typu nezadali explicitní implementaci tohoto rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberNotPermittedInInterfaceImplementation">
        <source>This member is not permitted in an interface implementation</source>
        <target state="translated">Tento člen není v implementaci rozhraní povolený.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclarationElementNotPermittedInAugmentation">
        <source>This declaration element is not permitted in an augmentation</source>
        <target state="translated">Tento element deklarace není u rozšíření povolený.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotContainNestedTypes">
        <source>Types cannot contain nested type definitions</source>
        <target state="translated">Typy nemůžou obsahovat definice vnořených typů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeExceptionOrModule">
        <source>type, exception or module</source>
        <target state="translated">typ, výjimka nebo modul</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeOrModule">
        <source>type or module</source>
        <target state="translated">typ nebo modul</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type.</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} implementuje explicitně rozhraní System.IStructuralEquatable. Použijte pro tento typ atribut CustomEquality.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IEquatable&lt;_&gt;' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'.</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} implementuje explicitně rozhraní System.IEquatable&lt;_&gt;. Použijte pro tento typ atribut CustomEquality a vytvořte konzistentní implementaci přepsání System.Object.Equals(obj), které není obecné.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
        <source>Explicit type specifications cannot be used for exception constructors</source>
        <target state="translated">Explicitní specifikace typu se nedají použít u konstruktorů výjimek.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsShouldNotHaveArgumentList">
        <source>Exception abbreviations should not have argument lists</source>
        <target state="translated">Zkratky výjimek by neměly mít seznamy argumentů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
        <source>Abbreviations for Common IL exceptions cannot take arguments</source>
        <target state="translated">Zkratky pro výjimky Common IL nemůžou přebírat argumenty.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsMustReferToValidExceptions">
        <source>Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception</source>
        <target state="translated">Zkratky výjimek musí odkazovat na existující výjimky nebo typy F# odvozené od třídy System.Exception.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
        <source>Abbreviations for Common IL exception types must have a matching object constructor</source>
        <target state="translated">Zkratky pro typy výjimek Common IL musí mít odpovídající konstruktor objektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotAnException">
        <source>Not an exception</source>
        <target state="translated">Není výjimka.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidModuleName">
        <source>Invalid module name</source>
        <target state="translated">Neplatný název modulu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeExtension">
        <source>Invalid type extension</source>
        <target state="translated">Neplatné rozšíření typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesOfTypeSpecifyMultipleKindsForType">
        <source>The attributes of this type specify multiple kinds for the type</source>
        <target state="translated">Atributy tohoto typu určují pro typ víc druhů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcKindOfTypeSpecifiedDoesNotMatchDefinition">
        <source>The kind of the type specified by its attributes does not match the kind implied by its definition</source>
        <target state="translated">Druh typu určeného jeho atributy se neshoduje s druhem odvozeným jeho definicí.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDefinitionsCannotHaveTypeParameters">
        <source>Measure definitions cannot have type parameters</source>
        <target state="translated">Definice míry nemůžou mít parametry typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeRequiresDefinition">
        <source>This type requires a definition</source>
        <target state="translated">Teto typ vyžaduje definici.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationHasTypeParametersMissingOnType">
        <source>This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C&lt;'a&gt; = C of ...'.</source>
        <target state="translated">Tato zkratka typu má aspoň jeden parametr deklarovaného typu, který se u zkracovaného typu nevyskytuje. Při zkracování typů se musí použít všechny parametry deklarovaného typu. Zvažte možnost odebrání jednoho nebo víc parametrů typu, nebo použijte konkrétní definici typu, která zabaluje nadřízený typ, třeba type C&lt;'a&gt; = C f ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
        <source>Structs, interfaces, enums and delegates cannot inherit from other types</source>
        <target state="translated">Struktury, rozhraní, výčty ani delegáti nemůžou dědit z jiných typů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotInheritFromMultipleConcreteTypes">
        <source>Types cannot inherit from multiple concrete types</source>
        <target state="translated">Typy nemůžou dědit od více konkrétních typů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
        <source>Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute</source>
        <target state="translated">Typy záznam, sjednocení, zkratka a struktura nemůžou mít atribut AllowNullLiteral.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
        <source>Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal</source>
        <target state="translated">Typy s atributem AllowNullLiteral můžou dědit jenom od typů, které umožňují použít taky literál s hodnotou null, nebo tyto typy můžou implementovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericTypesCannotHaveStructLayout">
        <source>Generic types cannot be given the 'StructLayout' attribute</source>
        <target state="translated">Obecným typům se nemůže předávat atribut StructLayout.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyStructsCanHaveStructLayout">
        <source>Only structs and classes without primary constructors may be given the 'StructLayout' attribute</source>
        <target state="translated">Atribut StructLayout se dá předávat jenom strukturám a třídám bez primárních konstruktorů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRepresentationOfTypeHiddenBySignature">
        <source>The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.</source>
        <target state="translated">Signatura skrývá reprezentaci tohoto typu. Charakteristiku typu je potřeba určit pomocí atributu, jako je [&lt;Sealed&gt;], [&lt;Class&gt;] nebo [&lt;Interface&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyClassesCanHaveAbstract">
        <source>Only classes may be given the 'AbstractClass' attribute</source>
        <target state="translated">Atribut AbstractClass se dá předávat jenom třídám.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
        <source>Only types representing units-of-measure may be given the 'Measure' attribute</source>
        <target state="translated">Atribut Measure se dá předávat jenom typům, které představují měrné jednotky.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on overrides or interface implementations</source>
        <target state="translated">Modifikátory dostupnosti nejsou u implementací rozhraní nebo přepsání povolené.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDU">
        <source>Discriminated union types are always sealed</source>
        <target state="translated">Typy rozlišených sjednocení jsou vždycky zapečetěné.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedRecord">
        <source>Record types are always sealed</source>
        <target state="translated">Typy záznamu jsou vždycky zapečetěné.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedAssemblyCode">
        <source>Assembly code types are always sealed</source>
        <target state="translated">Typy kódu sestavení jsou vždycky zapečetěné.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedStruct">
        <source>Struct types are always sealed</source>
        <target state="translated">Typy struktury jsou vždycky zapečetěné.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDelegate">
        <source>Delegate types are always sealed</source>
        <target state="translated">Typy delegátů jsou vždycky zapečetěné.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedEnum">
        <source>Enum types are always sealed</source>
        <target state="translated">Typy výčtu jsou vždycky zapečetěné.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesAndDelegatesCannotContainFields">
        <source>Interface types and delegate types cannot contain fields</source>
        <target state="translated">Typy rozhraní a typy delegátů nemůžou obsahovat pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviatedTypesCannotBeSealed">
        <source>Abbreviated types cannot be given the 'Sealed' attribute</source>
        <target state="translated">Zkráceným typům se nedá předávat atribut Sealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromSealedType">
        <source>Cannot inherit a sealed type</source>
        <target state="translated">Zapečetěný typ nejde zdědit.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromInterfaceType">
        <source>Cannot inherit from interface type. Use interface ... with instead.</source>
        <target state="translated">Nejde dědit z typu rozhraní. Použijte místo toho výraz interface ... with.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructTypesCannotContainAbstractMembers">
        <source>Struct types cannot contain abstract members</source>
        <target state="translated">Typy struktury nemůžou obsahovat abstraktní členy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesCannotBeSealed">
        <source>Interface types cannot be sealed</source>
        <target state="translated">Typy rozhraní nemůžou být zapečetěné.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDelegateSpecification">
        <source>Delegate specifications must be of the form 'typ -&gt; typ'</source>
        <target state="translated">Určení delegátů musí mít notaci typ -&gt; typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegatesCannotBeCurried">
        <source>Delegate specifications must not be curried types. Use 'typ * ... * typ -&gt; typ' for multi-argument delegates, and 'typ -&gt; (typ -&gt; typ)' for delegates returning function values.</source>
        <target state="translated">Specifikace delegátů nesmí být curryfikované typy. Pro delegáty, kteří mají víc argumentů, použijte typ * ... * typ -&gt; typ a pro delegáty, kteří vrací hodnoty funkcí, použijte typ -&gt; (typ -&gt; typ).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForLiteralEnumeration">
        <source>Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char</source>
        <target state="translated">Literálový výčet musí být typu int, uint, int16, uint16, int64, uint64, byte, sbyte nebo char.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclic">
        <source>This type definition involves an immediate cyclic reference through an abbreviation</source>
        <target state="translated">Tato definice typu zahrnuje okamžitý cyklický odkaz zprostředkovaný zkratkou.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclicThroughInheritance">
        <source>This type definition involves an immediate cyclic reference through a struct field or inheritance relation</source>
        <target state="translated">Tato definice typu zahrnuje okamžitý cyklický odkaz zprostředkovaný polem struktury nebo vztahem dědičnosti.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReservedSyntaxForAugmentation">
        <source>The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[&lt;Sealed&gt;] attribute to the type definition in the signature</source>
        <target state="translated">Syntaxe type X with ... je rezervovaná pro rozšíření. Typy, které mají skrytou reprezentaci, ale mají členy, se teď v signaturách deklarují pomocí notace type X = ... Je možné, že k definici typu v signatuře budete muset přidat také atribut [&lt;Sealed&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
        <source>Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.</source>
        <target state="translated">Členové, kteří rozšiřují typy rozhraní, delegáta nebo výčtu, musí být umístěné v modulu odděleně od definice typu. Tento modul musí mít buď atribut AutoOpen, nebo musí být otevřený explicitně klientským kódem, aby se člen rozšíření vložil do oboru.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal">
        <source>One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '{0}'</source>
        <target state="translated">Minimálně jeden parametr deklarovaného typu u tohoto rozšíření typu neobsahuje omezení typu nebo má nesprávné omezení typu, které se neshoduje s původními omezeními typu na {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
        <source>Type definitions may only have one 'inherit' specification and it must be the first declaration</source>
        <target state="translated">Definice typu může mít jenom jednu specifikaci inherit a ta musí být první deklarací.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
        <source>'let' and 'do' bindings must come before member and interface definitions in type definitions</source>
        <target state="translated">Vazby let a do se musí v definicích typů umístit před definice členů a rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritDeclarationMissingArguments">
        <source>This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'.</source>
        <target state="translated">Tato deklarace inherit specifikuje zděděný typ, ale ne argumenty. Zvažte možnost poskytnutí argumentů, třeba inherit BaseType(args).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritConstructionCallNotPartOfImplicitSequence">
        <source>This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Deklarace inherit má argumenty, ale není v typu s primárním konstruktorem. Zvažte možnost přidat do definice typu argumenty, třeba type X(args) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLetAndDoRequiresImplicitConstructionSequence">
        <source>This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Tato definice se dá použít jenom u typu s primárním konstruktorem. Zvažte možnost přidat do definice typu argumenty, třeba type X(args) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveAugmentations">
        <source>Type abbreviations cannot have augmentations</source>
        <target state="translated">Zkratky typů nemůžou mít rozšíření.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbreviationForNamespace">
        <source>The path '{0}' is a namespace. A module abbreviation may not abbreviate a namespace.</source>
        <target state="translated">Cesta {0} je obor názvů. Zkratka modulu nemůže zkracovat obor názvů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeUsedInInvalidWay">
        <source>The type '{0}' is used in an invalid way. A value prior to '{1}' has an inferred type involving '{2}', which is an invalid forward reference.</source>
        <target state="translated">Typ {0} se používá neplatným způsobem. Hodnota před pozicí {1} má odvozený typ zahrnující {2}: to je neplatný dopředný odkaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to the definition of '{2}', which is an invalid forward reference.</source>
        <target state="translated">Člen {0} se používá neplatným způsobem. Použití {1} se odvozuje před definicí {2}. To je neplatný dopředný odkaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeAutoOpenWasIgnored">
        <source>The attribute 'AutoOpen(\"{0}\")' in the assembly '{1}' did not refer to a valid module or namespace in that assembly and has been ignored</source>
        <target state="translated">Atribut AutoOpen(\"{0}\") v sestavení {1} neodkazoval na platný modul nebo obor názvů v tomto sestavení a ignoroval se.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUndefinedValue">
        <source>Undefined value '{0}'</source>
        <target state="translated">Nedefinovaná hodnota {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLabelNotFound">
        <source>Label {0} not found</source>
        <target state="translated">Popisek {0} se nenašel.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilIncorrectNumberOfTypeArguments">
        <source>Incorrect number of type arguments to local call</source>
        <target state="translated">Nesprávný počet argumentů typu pro místní volání</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDynamicInvocationNotSupported">
        <source>Dynamic invocation of {0} is not supported</source>
        <target state="translated">Dynamické vyvolání {0} se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfLiteralFieldIsInvalid">
        <source>Taking the address of a literal field is invalid</source>
        <target state="translated">Přebírání adresy pole literálu je neplatné.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfValueHereIsInvalid">
        <source>This operation involves taking the address of a value '{0}' represented using a local variable or other special representation. This is invalid.</source>
        <target state="translated">Tato operace zahrnuje převzetí adresy hodnoty {0} vyjádřené pomocí lokální proměnné nebo jiného speciálního způsobu vyjádření. Tato akce je neplatná.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilCustomMarshallersCannotBeUsedInFSharp">
        <source>Custom marshallers cannot be specified in F# code. Consider using a C# helper function.</source>
        <target state="translated">V kódu F# se nedají zadat vlastní marshallery. Zvažte použití pomocné funkce v C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMarshalAsAttributeCannotBeDecoded">
        <source>The MarshalAs attribute could not be decoded</source>
        <target state="translated">Atribut MarshalAs se nedal dekódovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignatureForExternalFunctionContainsTypeParameters">
        <source>The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.</source>
        <target state="translated">Signatura pro tuto externí funkci obsahuje parametry typu. Omezte argument a návratové typy tak, aby zahrnovaly typy odpovídající funkce C.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDllImportAttributeCouldNotBeDecoded">
        <source>The DllImport attribute could not be decoded</source>
        <target state="translated">Atribut DllImport se nedal dekódovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLiteralFieldsCannotBeSet">
        <source>Literal fields cannot be set</source>
        <target state="translated">Pole literálů se nedají nastavit.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStaticMethodIsNotLambda">
        <source>GenSetStorage: {0} was represented as a static method but was not an appropriate lambda expression</source>
        <target state="translated">GenSetStorage: metoda {0} byla vyjádřená jako statická, ale není to odpovídající výraz lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMutableVariablesCannotEscapeMethod">
        <source>Mutable variables cannot escape their method</source>
        <target state="translated">Měnitelné proměnné nemůžou opustit svoji metodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedUnrealizedValue">
        <source>Compiler error: unexpected unrealized value</source>
        <target state="translated">Chyba kompilátoru: neočekávaná nerealizovaná hodnota</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMainModuleEmpty">
        <source>Main module of program is empty: nothing will happen when it is run</source>
        <target state="translated">Hlavní modul programu je prázdný: při jeho spuštění se nic nestane.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilTypeCannotBeUsedForLiteralField">
        <source>This type cannot be used for a literal field</source>
        <target state="translated">Tento typ se pro pole literálu použít nedá.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedGetSetAnnotation">
        <source>Unexpected GetSet annotation on a property</source>
        <target state="translated">Neočekávaná poznámka GetSet u vlastnosti</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldOffsetAttributeCouldNotBeDecoded">
        <source>The FieldOffset attribute could not be decoded</source>
        <target state="translated">Atribut FieldOffset se nedal dekódovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStructLayoutAttributeCouldNotBeDecoded">
        <source>The StructLayout attribute could not be decoded</source>
        <target state="translated">Atribut StructLayout se nedal dekódovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDefaultAugmentationAttributeCouldNotBeDecoded">
        <source>The DefaultAugmentation attribute could not be decoded</source>
        <target state="translated">Atribut DefaultAugmentation se nedal dekódovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilReflectedDefinitionsCannotUseSliceOperator">
        <source>Reflected definitions cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">Reflektované definice nemůžou obsahovat použití operátoru spojení předpon %.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsProblemWithCodepage">
        <source>Problem with codepage '{0}': {1}</source>
        <target state="translated">Problém se znakovou stránkou {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyright">
        <source>Copyright (c) Microsoft Corporation. All Rights Reserved.</source>
        <target state="translated">Copyright (c) Microsoft Corporation. Všechna práva vyhrazena.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyrightCommunity">
        <source>Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</source>
        <target state="translated">Volně distribuováno v rámci licence MIT Open Source. https://github.com/Microsoft/visualfsharp/blob/master/License.txt</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNameOfOutputFile">
        <source>Name of the output file (Short form: -o)</source>
        <target state="translated">Název výstupního souboru (krátký tvar: -o)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildConsole">
        <source>Build a console executable</source>
        <target state="translated">Vytvoří spustitelný soubor konzoly.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildWindows">
        <source>Build a Windows executable</source>
        <target state="translated">Vytvoří spustitelný soubor systému Windows.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildLibrary">
        <source>Build a library (Short form: -a)</source>
        <target state="translated">Vytvoří knihovnu (krátký tvar: -a).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildModule">
        <source>Build a module that can be added to another assembly</source>
        <target state="translated">Vytvoří modul, který se dá přidat do jiného sestavení</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDelaySign">
        <source>Delay-sign the assembly using only the public portion of the strong name key</source>
        <target state="translated">Vytvoří zpožděný podpis sestavení jenom s využitím veřejné části klíče silného názvu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPublicSign">
        <source>Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed</source>
        <target state="translated">Vytvoří veřejný podpis sestavení jenom s využitím veřejné části klíče silného názvu a označí sestavení jako podepsané.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWriteXml">
        <source>Write the xmldoc of the assembly to the given file</source>
        <target state="translated">Zapsat xmldoc sestavení do daného souboru</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyFile">
        <source>Specify a strong name key file</source>
        <target state="translated">Určuje soubor klíče se silným názvem.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyContainer">
        <source>Specify a strong name key container</source>
        <target state="translated">Určuje kontejner klíče se silným názvem.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPlatform">
        <source>Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.</source>
        <target state="translated">Omezuje platformy, na kterých je možné tento kód spustit: x86, Itanium, x64, anycpu32bitpreferred a anycpu. Výchozí je anycpu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoOpt">
        <source>Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.</source>
        <target state="translated">Zahrňte jenom informace o optimalizaci nutné k implementaci vložených konstruktorů. Deaktivuje se vkládání napříč moduly, ale zlepší se kompatibilita binárních souborů.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoInterface">
        <source>Don't add a resource to the generated assembly containing F#-specific metadata</source>
        <target state="translated">Nepřidávat prostředek do generovaného sestavení, které obsahuje metadata specifická pro F#</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSig">
        <source>Print the inferred interface of the assembly to a file</source>
        <target state="translated">Vytisknout odvozené rozhraní sestavení do souboru</target>
        <note />
      </trans-unit>
      <trans-unit id="optsReference">
        <source>Reference an assembly (Short form: -r)</source>
        <target state="translated">Odkazovat na sestavení (krátký tvar: -r)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32res">
        <source>Specify a Win32 resource file (.res)</source>
        <target state="translated">Určuje soubor prostředků Win32 (.res).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32manifest">
        <source>Specify a Win32 manifest file</source>
        <target state="translated">Zadat soubor manifestu Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowin32manifest">
        <source>Do not include the default Win32 manifest</source>
        <target state="translated">Nezahrnovat výchozí manifest Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedAllSource">
        <source>Embed all source files in the portable PDB file</source>
        <target state="translated">Vložit všechny zdrojové soubory do souboru PDB typu Portable</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedSource">
        <source>Embed specific source files in the portable PDB file</source>
        <target state="translated">Vloží konkrétní zdrojové soubory do přenosného souboru PDB.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLink">
        <source>Source link information file to embed in the portable PDB file</source>
        <target state="translated">Informační soubor zdrojového odkazu, který se má vložit do souboru PDB typu Portable</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbeddedSourceRequirePortablePDBs">
        <source>--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">Přepínač --embed se podporuje jenom při generování souboru PDB typu Portable (--debug:portable nebo --debug:embedded).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLinkRequirePortablePDBs">
        <source>--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">Přepínač --sourcelink se podporuje jenom při generování souboru PDB typu Portable (--debug:portable nebo --debug:embedded).</target>
        <note />
      </trans-unit>
      <trans-unit id="srcFileTooLarge">
        <source>Source file is too large to embed in a portable PDB</source>
        <target state="translated">Zdrojový soubor je příliš velký pro vložený do souboru PDB typu Portable.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResource">
        <source>Embed the specified managed resource</source>
        <target state="translated">Vložit zadaný spravovaný prostředek</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLinkresource">
        <source>Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]</source>
        <target state="translated">Propojí zadaný prostředek s tímto sestavením, kde formát resinfo je &lt;soubor&gt;[,&lt;název řetězce&gt;[,public|private]].</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebugPM">
        <source>Emit debug information (Short form: -g)</source>
        <target state="translated">Generuje ladicí informace (krátký tvar: -g).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebug">
        <source>Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file).</source>
        <target state="translated">Zadejte typ ladění: full, portable, embedded, pdbonly. ({0} je výchozí hodnota v případě, že není zadaný žádný typ ladění, a umožňuje připojení ladicího programu ke spuštěnému programu, portable je formát pro různé platformy, embedded je formát pro různé platformy vložený do výstupního souboru).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsOptimize">
        <source>Enable optimizations (Short form: -O)</source>
        <target state="translated">Povolit optimalizace (krátký tvar: -O)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTailcalls">
        <source>Enable or disable tailcalls</source>
        <target state="translated">Zapnout nebo vypnout volání funkce Tail</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDeterministic">
        <source>Produce a deterministic assembly (including module version GUID and timestamp)</source>
        <target state="translated">Vytvoří deterministické sestavení (včetně GUID verze modulu a časového razítka).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCrossoptimize">
        <source>Enable or disable cross-module optimizations</source>
        <target state="translated">Povoluje nebo zakazuje optimalizaci mezi moduly.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserrorPM">
        <source>Report all warnings as errors</source>
        <target state="translated">Oznamovat všechna upozornění jako chyby</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserror">
        <source>Report specific warnings as errors</source>
        <target state="translated">Oznamovat konkrétní upozornění jako chyby</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarn">
        <source>Set a warning level (0-5)</source>
        <target state="translated">Nastavit úroveň pro upozornění (0–5)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowarn">
        <source>Disable specific warning messages</source>
        <target state="translated">Zakázat specifická upozornění</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnOn">
        <source>Enable specific warnings that may be off by default</source>
        <target state="translated">Povolit specifická upozornění, která můžou být ve výchozím nastavení vypnutá</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecked">
        <source>Generate overflow checks</source>
        <target state="translated">Generovat kontroly přetečení</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDefine">
        <source>Define conditional compilation symbols (Short form: -d)</source>
        <target state="translated">Definuje symboly podmíněné kompilace (krátký tvar: -d).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsMlcompatibility">
        <source>Ignore ML compatibility warnings</source>
        <target state="translated">Ignoruje upozornění na kompatibilitu s ML.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNologo">
        <source>Suppress compiler copyright message</source>
        <target state="translated">Potlačí zprávu o autorských právech kompilátoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelp">
        <source>Display this usage message (Short form: -?)</source>
        <target state="translated">Zobrazí tuto zprávu o použití (krátký tvar: -?).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFile">
        <source>Read response file for more options</source>
        <target state="translated">Další možnosti najdete v souboru odpovědi.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCodepage">
        <source>Specify the codepage used to read source files</source>
        <target state="translated">Určuje znakovou stránku, která se používá ke čtení zdrojových souborů.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUtf8output">
        <source>Output messages in UTF-8 encoding</source>
        <target state="translated">Výstupní zprávy v kódování UTF-8</target>
        <note />
      </trans-unit>
      <trans-unit id="optsFullpaths">
        <source>Output messages with fully qualified paths</source>
        <target state="translated">Výstupní zprávy s plně kvalifikovanou cestou</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLib">
        <source>Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)</source>
        <target state="translated">Určuje adresář pro cestu vložených souborů, který se použije k překladu zdrojových souborů a sestavení (krátký tvar: -I).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBaseaddress">
        <source>Base address for the library to be built</source>
        <target state="translated">Základní adresa knihovny, která se má vytvořit</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoframework">
        <source>Do not reference the default CLI assemblies by default</source>
        <target state="translated">Neodkazovat ve výchozím nastavení na výchozí sestavení CLI</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStandalone">
        <source>Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated</source>
        <target state="translated">Staticky propojit knihovnu F# a všechny odkazované knihovny DLL, které jsou na ní závislé, do právě generovaného sestavení</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStaticlink">
        <source>Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.</source>
        <target state="translated">Staticky propojit zadané sestavení a všechny odkazované knihovny DLL, které jsou na tomto sestavení závislé. Použít název sestavení, třeba mylib, ne název knihovny DLL</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResident">
        <source>Use a resident background compilation service to improve compiler startup times.</source>
        <target state="translated">Použít rezidentní službu kompilace na pozadí ke zlepšení časů spuštění kompilátoru</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPdb">
        <source>Name the output debug file</source>
        <target state="translated">Pojmenovat výstupní ladicí soubor</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSimpleresolution">
        <source>Resolve assembly references using directory-based rules rather than MSBuild resolution</source>
        <target state="translated">Přeložit odkazy na sestavení pomocí pravidel založených na adresáři, ne pomocí MSBuild</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedTarget">
        <source>Unrecognized target '{0}', expected 'exe', 'winexe', 'library' or 'module'</source>
        <target state="translated">Nerozpoznaný cíl {0}. Očekávané jsou exe, winexe, library nebo module.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedDebugType">
        <source>Unrecognized debug type '{0}', expected 'pdbonly' or 'full'</source>
        <target state="translated">Nerozpoznaný typ ladění {0}. Očekávané typy jsou pdbonly nebo full.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidWarningLevel">
        <source>Invalid warning level '{0}'</source>
        <target state="translated">Neplatná úroveň pro upozornění {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsShortFormOf">
        <source>Short form of '{0}'</source>
        <target state="translated">Krátký tvar pro {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDeprecatedMsg">
        <source>The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.</source>
        <target state="translated">Možnost příkazového řádku --cliroot je zastaralá. Použijte místo ní explicitní odkaz na specifickou kopii knihovny mscorlib.dll.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDescription">
        <source>Use to override where the compiler looks for mscorlib.dll and framework components</source>
        <target state="translated">Používá se k přepsání umístění, kde kompilátor hledá knihovnu mscorlib.dll a komponenty rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerOutputFiles">
        <source>- OUTPUT FILES -</source>
        <target state="translated">- VÝSTUPNÍ SOUBORY -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerInputFiles">
        <source>- INPUT FILES -</source>
        <target state="translated">- VSTUPNÍ SOUBORY -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerResources">
        <source>- RESOURCES -</source>
        <target state="translated">- PROSTŘEDKY -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerCodeGen">
        <source>- CODE GENERATION -</source>
        <target state="translated">- GENEROVÁNÍ KÓDU -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerAdvanced">
        <source>- ADVANCED -</source>
        <target state="translated">- UPŘESNIT -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerMisc">
        <source>- MISCELLANEOUS -</source>
        <target state="translated">- RŮZNÉ -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerLanguage">
        <source>- LANGUAGE -</source>
        <target state="translated">- JAZYK -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerErrsAndWarns">
        <source>- ERRORS AND WARNINGS -</source>
        <target state="translated">- CHYBY A UPOZORNĚNÍ -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownArgumentToTheTestSwitch">
        <source>Unknown --test argument: '{0}'</source>
        <target state="translated">Neznámý argument --test: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownPlatform">
        <source>Unrecognized platform '{0}', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'</source>
        <target state="translated">Nerozpoznaná platforma {0}. Platné hodnoty jsou x86, x64, Itanium, anycpu32bitpreferred a anycpu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInternalNoDescription">
        <source>The command-line option '{0}' is for test purposes only</source>
        <target state="translated">Možnost příkazového řádku {0} je určená jenom pro testovací účely.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLONoDescription">
        <source>The command-line option '{0}' has been deprecated</source>
        <target state="translated">Možnost příkazového řádku {0} je zastaralá.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLODeprecatedSuggestAlternative">
        <source>The command-line option '{0}' has been deprecated. Use '{1}' instead.</source>
        <target state="translated">Možnost příkazového řádku {0} je zastaralá. Použijte místo ní {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLOHtmlDoc">
        <source>The command-line option '{0}' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.</source>
        <target state="translated">Možnost příkazového řádku {0} je zastaralá. Generování dokumentu HTML je teď součástí knihovny F# Power Pack a je přístupné prostřednictvím nástroje FsHtmlDoc.exe.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsConsoleColors">
        <source>Output warning and error messages in color</source>
        <target state="translated">Barevně rozlišená upozornění výstupu a chybové zprávy</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUseHighEntropyVA">
        <source>Enable high-entropy ASLR</source>
        <target state="translated">Povolit technologii ASLR s vysokou entropií</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSubSystemVersion">
        <source>Specify subsystem version of this assembly</source>
        <target state="translated">Zadejte verzi subsystému tohoto sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTargetProfile">
        <source>Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib</source>
        <target state="translated">Zadejte profil cílového rozhraní tohoto sestavení. Platné hodnoty jsou mscorlib, netcore nebo netstandard. Výchozí je mscorlib.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmitDebugInfoInQuotations">
        <source>Emit debug information in quotations</source>
        <target state="translated">Generovat ladicí informace v uvozovkách</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPreferredUiLang">
        <source>Specify the preferred output language culture name (e.g. es-ES, ja-JP)</source>
        <target state="translated">Zadejte preferovaný název jazykové verze (např. es-ES, ja-JP).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoCopyFsharpCore">
        <source>Don't copy FSharp.Core.dll along the produced binaries</source>
        <target state="translated">Nekopírujte FSharp.Core.dll k vytvářeným binárním souborům.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidSubSystemVersion">
        <source>Invalid version '{0}' for '--subsystemversion'. The version must be 4.00 or greater.</source>
        <target state="translated">Neplatná verze {0} pro --subsystemversion. Správná verze je 4.00 nebo vyšší.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidTargetProfile">
        <source>Invalid value '{0}' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.</source>
        <target state="translated">Neplatná hodnota {0} pro --targetprofile. Platné hodnoty jsou mscorlib, netcore nebo netstandard.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFullName">
        <source>Full name</source>
        <target state="translated">Úplný název</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoOtherOverloads">
        <source>and {0} other overloads</source>
        <target state="translated">a další přetížení ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoUnionCase">
        <source>union case</source>
        <target state="translated">případ typu union</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActivePatternResult">
        <source>active pattern result</source>
        <target state="translated">výsledek aktivního vzoru</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActiveRecognizer">
        <source>active recognizer</source>
        <target state="translated">aktivní rozlišovač</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoField">
        <source>field</source>
        <target state="translated">pole</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoEvent">
        <source>event</source>
        <target state="translated">událost</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoProperty">
        <source>property</source>
        <target state="translated">vlastnost</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoExtension">
        <source>extension</source>
        <target state="translated">rozšíření</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCustomOperation">
        <source>custom operation</source>
        <target state="translated">vlastní operace</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoArgument">
        <source>argument</source>
        <target state="translated">argument</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoPatternVariable">
        <source>patvar</source>
        <target state="translated">proměnná vzoru</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespace">
        <source>namespace</source>
        <target state="translated">obor názvů</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoModule">
        <source>module</source>
        <target state="translated">modul</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespaceOrModule">
        <source>namespace/module</source>
        <target state="translated">obor názvů nebo modul</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromFirst">
        <source>from {0}</source>
        <target state="translated">z: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromNext">
        <source>also from {0}</source>
        <target state="translated">taky z: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedProperty">
        <source>generated property</source>
        <target state="translated">generovaná vlastnost</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedType">
        <source>generated type</source>
        <target state="translated">generovaný typ</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersKey">
        <source>Found by AssemblyFolders registry key</source>
        <target state="translated">Nalezené klíčem registru AssemblyFolders</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersExKey">
        <source>Found by AssemblyFoldersEx registry key</source>
        <target state="translated">Nalezené klíčem registru AssemblyFoldersEx</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionNetFramework">
        <source>.NET Framework</source>
        <target state="translated">.NET Framework</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionGAC">
        <source>Global Assembly Cache</source>
        <target state="translated">Globální mezipaměť sestavení</target>
        <note />
      </trans-unit>
      <trans-unit id="recursiveClassHierarchy">
        <source>Recursive class hierarchy in type '{0}'</source>
        <target state="translated">Rekurzivní hierarchie tříd u typu {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRecursiveReferenceToAbstractSlot">
        <source>Invalid recursive reference to an abstract slot</source>
        <target state="translated">Neplatný rekurzivní odkaz na abstraktní datovou oblast</target>
        <note />
      </trans-unit>
      <trans-unit id="eventHasNonStandardType">
        <source>The event '{0}' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit {1} and {2} methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent&lt;_&gt;' or 'IEvent&lt;_,_&gt;'.</source>
        <target state="translated">Událost {0} je nestandardního typu. Pokud je tato událost deklarovaná v jiném jazyce CLI, bude možná potřeba k této události přistoupit pomocí jejích explicitních metod {1} a {2}. Pokud je tato událost deklarovaná v jazyce F#, vytvořte její typ jako instanci buď IDelegateEvent&lt;_&gt;, nebo IEvent&lt;_,_&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeIsNotAccessible">
        <source>The type '{0}' is not accessible from this code location</source>
        <target state="translated">Typ {0} není z tohoto místa v kódu dostupný.</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCasesAreNotAccessible">
        <source>The union cases or fields of the type '{0}' are not accessible from this code location</source>
        <target state="translated">Případy typu union nebo pole typu {0} nejsou z tohoto místa v kódu dostupné.</target>
        <note />
      </trans-unit>
      <trans-unit id="valueIsNotAccessible">
        <source>The value '{0}' is not accessible from this code location</source>
        <target state="translated">Hodnota {0} není z tohoto místa v kódu dostupná.</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCaseIsNotAccessible">
        <source>The union case '{0}' is not accessible from this code location</source>
        <target state="translated">Případ typu union {0} není z tohoto místa v kódu dostupný.</target>
        <note />
      </trans-unit>
      <trans-unit id="fieldIsNotAccessible">
        <source>The record, struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">Pole záznamu, struktury nebo třídy {0} není z tohoto místa v kódu dostupné.</target>
        <note />
      </trans-unit>
      <trans-unit id="structOrClassFieldIsNotAccessible">
        <source>The struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">Pole struktury nebo třídy {0} není na tomto místě v kódu dostupné.</target>
        <note />
      </trans-unit>
      <trans-unit id="experimentalConstruct">
        <source>This construct is experimental</source>
        <target state="translated">Tento konstruktor je experimentální.</target>
        <note />
      </trans-unit>
      <trans-unit id="noInvokeMethodsFound">
        <source>No Invoke methods found for delegate type</source>
        <target state="translated">Pro typ delegáta se nenašly žádné metody Invoke.</target>
        <note />
      </trans-unit>
      <trans-unit id="moreThanOneInvokeMethodFound">
        <source>More than one Invoke method found for delegate type</source>
        <target state="translated">Pro typ delegáta se našla víc než jedna metoda Invoke.</target>
        <note />
      </trans-unit>
      <trans-unit id="delegatesNotAllowedToHaveCurriedSignatures">
        <source>Delegates are not allowed to have curried signatures</source>
        <target state="translated">Delegáti nemůžou mít curryfikované signatury.</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrUnexpectedTExpr">
        <source>Unexpected Expr.TyChoose</source>
        <target state="translated">Neočekávaný výraz Expr.TyChoose</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrLambdaLiftingOptimizationsNotApplied">
        <source>Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.</source>
        <target state="translated">Poznámka: Optimalizace rozšiřující výraz lambda se kvůli použití této lokálně omezené obecné funkce jako hodnoty první třídy nepoužily. Tuto podmínku můžete ošetřit přidáním omezení typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifiersContainingAtSymbolReserved">
        <source>Identifiers containing '@' are reserved for use in F# code generation</source>
        <target state="translated">Identifikátory obsahující znak @ jsou vyhrazené pro použití při generování kódu F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifierReserved">
        <source>The identifier '{0}' is reserved for future use by F#</source>
        <target state="translated">Identifikátor {0} je vyhrazený pro budoucí použití v jazyce F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="patcMissingVariable">
        <source>Missing variable '{0}'</source>
        <target state="translated">Chybějící proměnná {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="patcPartialActivePatternsGenerateOneResult">
        <source>Partial active patterns may only generate one result</source>
        <target state="translated">Částečné aktivní vzory můžou generovat jenom jeden výsledek.</target>
        <note />
      </trans-unit>
      <trans-unit id="impTypeRequiredUnavailable">
        <source>The type '{0}' is required here and is unavailable. You must add a reference to assembly '{1}'.</source>
        <target state="translated">Tady se vyžaduje typ {0}, který ale není dostupný. Je potřeba přidat odkaz na sestavení {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferencedTypeCouldNotBeFoundInAssembly">
        <source>A reference to the type '{0}' in assembly '{1}' was found, but the type could not be found in that assembly</source>
        <target state="translated">Odkaz na typ {0} se v sestavení {1} našel, ale tento typ se v něm najít nepovedlo.</target>
        <note />
      </trans-unit>
      <trans-unit id="impNotEnoughTypeParamsInScopeWhileImporting">
        <source>Internal error or badly formed metadata: not enough type parameters were in scope while importing</source>
        <target state="translated">Vnitřní chyba nebo chybně vytvořená metadata: při importu byl v rozsahu nedostatečný počet parametrů typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferenceToDllRequiredByAssembly">
        <source>A reference to the DLL {0} is required by assembly {1}. The imported type {2} is located in the first assembly and could not be resolved.</source>
        <target state="translated">Sestavení {1} vyžaduje odkaz na knihovnu DLL {0}. Importovaný typ {2} se nachází v prvním sestavení a nedal se přeložit.</target>
        <note />
      </trans-unit>
      <trans-unit id="impImportedAssemblyUsesNotPublicType">
        <source>An imported assembly uses the type '{0}' but that type is not public</source>
        <target state="translated">Importované sestavení používá typ {0}, který ale není veřejný.</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButIncomplete">
        <source>The value '{0}' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible</source>
        <target state="translated">Hodnota {0} má označení inline, ale její implementace využívá interní nebo privátní funkci, ke které není dostatečný přístup.</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButWasNotBoundInTheOptEnv">
        <source>The value '{0}' was marked inline but was not bound in the optimization environment</source>
        <target state="translated">Hodnota {0} má označení inline, ale není svázaná s prostředím optimalizace.</target>
        <note />
      </trans-unit>
      <trans-unit id="optLocalValueNotFoundDuringOptimization">
        <source>Local value {0} not found during optimization</source>
        <target state="translated">Lokální hodnota {0} se během optimalizace nenašla.</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineHasUnexpectedValue">
        <source>A value marked as 'inline' has an unexpected value</source>
        <target state="translated">Hodnota s označením inline má neočekávanou hodnotu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineCouldNotBeInlined">
        <source>A value marked as 'inline' could not be inlined</source>
        <target state="translated">Hodnota s označením inline se nedá vložit.</target>
        <note />
      </trans-unit>
      <trans-unit id="optFailedToInlineValue">
        <source>Failed to inline the value '{0}' marked 'inline', perhaps because a recursive value was marked 'inline'</source>
        <target state="translated">Nepovedlo se vložit hodnotu {0} s označením inline: možná proto, že jste jako inline označili rekurzivní hodnotu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optRecursiveValValue">
        <source>Recursive ValValue {0}</source>
        <target state="translated">Rekurzivní hodnota ValValue {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltIncorrentIndentationOfIn">
        <source>The indentation of this 'in' token is incorrect with respect to the corresponding 'let'</source>
        <target state="translated">Odsazení tohoto tokenu in není ve vztahu k odpovídající klauzuli let správné.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltTokenIsOffsideOfContextStartedEarlier">
        <source>Possible incorrect indentation: this token is offside of context started at position {0}. Try indenting this token further or using standard formatting conventions.</source>
        <target state="translated">Je možné, že máte nesprávné odsazení: tento token leží mimo odsazení kontextu, který začíná na pozici {0}. Zkuste tento token odsadit víc nebo použijte standardní konvence formátování.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltSeparatorTokensOfPatternMatchMisaligned">
        <source>The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.</source>
        <target state="translated">Tokeny | oddělující pravidla tohoto porovnávacího vzoru nejsou zarovnané o jeden sloupec. Zvažte úpravu zarovnání kódu nebo použití většího odsazení.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidModuleExprType">
        <source>Invalid module/expression/type</source>
        <target state="translated">Neplatný modul/výraz/typ</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationNeededToDisambiguateTypesWithSameName">
        <source>Multiple types exist called '{0}', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '{1}'.</source>
        <target state="translated">Existuje víc typů s názvem {0}, které přebírají různý počet obecných parametrů. Pro jednoznačné rozlišení typu vytvořte instanci typu, třeba {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationIsMissingAndCouldNotBeInferred">
        <source>The instantiation of the generic type '{0}' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '{1}'.</source>
        <target state="translated">Instance obecného typu {0} chybí a nedá se ani odvodit od argumentů nebo návratového typu tohoto člena. Zvažte vytvoření instance typu při přístupu k tomuto typu, třeba {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrGlobalUsedOnlyAsFirstName">
        <source>'global' may only be used as the first name in a qualified path</source>
        <target state="translated">Výraz global se dá použít jenom jako první název v kvalifikované cestě.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrIsNotConstructorOrLiteral">
        <source>This is not a constructor or literal, or a constructor is being used incorrectly</source>
        <target state="translated">Toto není konstruktor nebo literál, anebo se konstruktor používá nesprávně.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnexpectedEmptyLongId">
        <source>Unexpected empty long identifier</source>
        <target state="translated">Neočekávaný prázdný dlouhý identifikátor</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordDoesNotContainSuchLabel">
        <source>The record type '{0}' does not contain a label '{1}'.</source>
        <target state="translated">Typ záznamu {0} neobsahuje popisek {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidFieldLabel">
        <source>Invalid field label</source>
        <target state="translated">Neplatný popisek pole</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidExpression">
        <source>Invalid expression '{0}'</source>
        <target state="translated">Neplatný výraz {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="nrNoConstructorsAvailableForType">
        <source>No constructors are available for the type '{0}'</source>
        <target state="translated">Pro typ {0} nejsou k dispozici žádné konstruktory.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnionTypeNeedsQualifiedAccess">
        <source>The union type for union case '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('{1}') in the name you are using.</source>
        <target state="translated">Typ sjednocení pro případ sjednocení {0} se definoval pomocí atributu RequireQualifiedAccessAttribute. Do jména, které používáte, přidejte název typu sjednocení ({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordTypeNeedsQualifiedAccess">
        <source>The record type for the record field '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('{1}') in the name you are using.</source>
        <target state="translated">Typ záznamu pro pole záznamu {0} se definoval pomocí atributu RequireQualifiedAccessAttribute. Do jména, které používáte, přidejte název typu záznamu ({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingPdb">
        <source>Unexpected error creating debug information file '{0}'</source>
        <target state="translated">Při vytváření souboru ladicích informací {0} došlo k neočekávané chybě.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideIntegerRange">
        <source>This number is outside the allowable range for this integer type</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro tento celočíselný typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexCharNotAllowedInOperatorNames">
        <source>'{0}' is not permitted as a character in operator names and is reserved for future use</source>
        <target state="translated">Znak {0} není v názvech operátorů povolený: je vyhrazený pro budoucí použití.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexUnexpectedChar">
        <source>Unexpected character '{0}'</source>
        <target state="translated">Neočekávaný znak {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteArrayCannotEncode">
        <source>This byte array literal contains characters that do not encode as a single byte</source>
        <target state="translated">Tento literál bajtového pole obsahuje znaky, které se nekódují jako jednobajtové.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIdentEndInMarkReserved">
        <source>Identifiers followed by '{0}' are reserved for future use</source>
        <target state="translated">Identifikátory, po kterých následuje {0}, jsou vyhrazené pro budoucí použití.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSigned">
        <source>This number is outside the allowable range for 8-bit signed integers</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro 8bitová celá čísla se znaménkem.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSignedHex">
        <source>This number is outside the allowable range for hexadecimal 8-bit signed integers</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro šestnáctková 8bitová celá čísla se znaménkem.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitUnsigned">
        <source>This number is outside the allowable range for 8-bit unsigned integers</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro 8bitová celá čísla bez znaménka.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitSigned">
        <source>This number is outside the allowable range for 16-bit signed integers</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro 16bitová celá čísla se znaménkem.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitUnsigned">
        <source>This number is outside the allowable range for 16-bit unsigned integers</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro 16bitová celá čísla bez znaménka.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitSigned">
        <source>This number is outside the allowable range for 32-bit signed integers</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro 32bitová celá čísla se znaménkem.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitUnsigned">
        <source>This number is outside the allowable range for 32-bit unsigned integers</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro 32bitová celá čísla bez znaménka.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitSigned">
        <source>This number is outside the allowable range for 64-bit signed integers</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro 64bitová celá čísla se znaménkem.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitUnsigned">
        <source>This number is outside the allowable range for 64-bit unsigned integers</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro 64bitová celá čísla bez znaménka.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeSigned">
        <source>This number is outside the allowable range for signed native integers</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro nativní celá čísla se znaménkem.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeUnsigned">
        <source>This number is outside the allowable range for unsigned native integers</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro nativní celá čísla bez znaménka.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidFloat">
        <source>Invalid floating point number</source>
        <target state="translated">Neplatné číslo s plovoucí desetinnou čárkou</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideDecimal">
        <source>This number is outside the allowable range for decimal literals</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro desítkové literály.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideThirtyTwoBitFloat">
        <source>This number is outside the allowable range for 32-bit floats</source>
        <target state="translated">Toto číslo je mimo povolený rozsah pro 32bitové číslo s plovoucí desetinnou čárkou.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidNumericLiteral">
        <source>This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</source>
        <target state="translated">Toto není platný číselný literál. Mezi platné číselné literály patří 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidByteLiteral">
        <source>This is not a valid byte literal</source>
        <target state="translated">Toto není platný bajtový literál.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidCharLiteral">
        <source>This is not a valid character literal</source>
        <target state="translated">Toto není platný znakový literál.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexThisUnicodeOnlyInStringLiterals">
        <source>This Unicode encoding is only valid in string literals</source>
        <target state="translated">Toto kódování Unicode je platné jenom u řetězcových literálů.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTokenReserved">
        <source>This token is reserved for future use</source>
        <target state="translated">Tento token je vyhrazený pro budoucí použití.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTabsNotAllowed">
        <source>TABs are not allowed in F# code unless the #indent \"off\" option is used</source>
        <target state="translated">Výraz tabulátoru není v kódu F# povolený, pokud se nepoužije možnost #indent \"off\".</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidLineNumber">
        <source>Invalid line number: '{0}'</source>
        <target state="translated">Neplatné číslo řádku: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustBeFirst">
        <source>#if directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">Direktiva #if musí být uvedená jako první neprázdný znak na řádku.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseNoMatchingIf">
        <source>#else has no matching #if</source>
        <target state="translated">Direktivě #else neodpovídá žádná direktiva #if.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifRequiredForElse">
        <source>#endif required for #else</source>
        <target state="translated">Pro direktivu #else se vyžaduje direktiva #endif.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseMustBeFirst">
        <source>#else directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">Direktiva #else musí být uvedená jako první neprázdný znak na řádku.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndingNoMatchingIf">
        <source>#endif has no matching #if</source>
        <target state="translated">Direktivě #endif neodpovídá žádná direktiva #if.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifMustBeFirst">
        <source>#endif directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">Direktiva #endif musí být uvedená jako první neprázdný znak na řádku.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustHaveIdent">
        <source>#if directive should be immediately followed by an identifier</source>
        <target state="translated">Za direktivou #if by měl bezprostředně následovat identifikátor.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexWrongNestedHashEndif">
        <source>Syntax error. Wrong nested #endif, unexpected tokens before it.</source>
        <target state="translated">Chyba syntaxe. Chybně vnořená direktiva #endif. Před výrazem it jsou neočekávané tokeny.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashBangMustBeFirstInFile">
        <source>#! may only appear as the first line at the start of a file.</source>
        <target state="translated">#! by se mělo objevit jenom jako první řádek na začátku souboru.</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexExpectedSingleLineComment">
        <source>Expected single line comment or end of line</source>
        <target state="translated">Očekával se jednořádkový komentář nebo konec řádku.</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNoArguments">
        <source>Infix operator member '{0}' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Člen operátoru vpony {0} nemá žádné argumenty. Očekávala se řazená kolekce členů se dvěma argumenty, třeba statický člen (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonPairArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Člen operátoru vpony {0} má počáteční argumenty v počtu {1}. Očekávala se řazená kolekce členů se dvěma argumenty, třeba statický člen (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithCurriedArguments">
        <source>Infix operator member '{0}' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Člen operátoru vpony {0} má curryfikované argumenty navíc. Očekávala se řazená kolekce členů se dvěma argumenty, třeba statický člen (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFSharpCoreRequiresExplicit">
        <source>All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'</source>
        <target state="translated">Všechny typy záznam, sjednocení a struktura v knihovně FSharp.Core.dll musí mít explicitní označení StructuralComparison nebo NoComparison.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the type parameter '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} má atribut StructuralComparison, ale parametr typu {1} nevyhovuje omezení comparison. Zvažte možnost přidat k parametru typu omezení comparison.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the component type '{1}' does not satisfy the 'comparison' constraint</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} má atribut StructuralComparison, ale typ komponenty {1} nevyhovuje omezení comparison.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded1">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type parameter {1} does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} se nedá strukturálně porovnávat, protože parametr typu {1} nevyhovuje omezení comparison. Zvažte možnost přidat k typu {2} atribut NoComparisonto: tak bude jasné, že se typ nedá porovnávat.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded2">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} se nedá strukturálně porovnávat, protože typ {1} nevyhovuje omezení comparison. Zvažte možnost přidat k typu {2} atribut NoComparisonto: tak bude jasné, že se typ nedá porovnávat.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded1">
        <source>The struct, record or union type '{0}' does not support structural equality because the type parameter {1} does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} nepodporuje strukturální rovnost, protože parametr typu {1} nevyhovuje omezení equality. Zvažte možnost přidat k typu {2} atribut NoEquality: tak bude jasné, že typ nepodporuje strukturální rovnost.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded2">
        <source>The struct, record or union type '{0}' does not support structural equality because the type '{1}' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} nepodporuje strukturální rovnost, protože typ {1} nevyhovuje omezení equality. Zvažte možnost přidat k typu {2} atribut NoEquality: tak bude jasné, že typ nepodporuje strukturální rovnost.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the type parameter '{1}' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} má atribut StructuralEquality, ale parametr typu {1} nevyhovuje omezení equality. Zvažte možnost přidat k parametru typu omezení equality.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the component type '{1}' does not satisfy the 'equality' constraint</source>
        <target state="translated">Typ struktura, záznam nebo sjednocení {0} má atribut StructuralEquality, ale typ komponenty {1} nevyhovuje omezení equality.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
        <source>Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct.</source>
        <target state="translated">Všem argumentům primárního konstruktoru pro strukturu se musí předávat typ, třeba pomocí notace type S(x1:int, x2: int) = ... Tyto argumenty určují pole struktury.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedValue">
        <source>The value '{0}' is unused</source>
        <target state="translated">Hodnota {0} se nepoužívá.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedThisVariable">
        <source>The recursive object reference '{0}' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.</source>
        <target state="translated">Rekurzivní odkaz na objekt {0} se nepoužívá. Přítomnost rekurzivního odkazu na objekt přidává ke členům tohoto a odvozených typů kontroly inicializace za běhu. Zvažte odebrání tohoto rekurzivního odkazu na objekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterAtMostOneArgument">
        <source>A getter property may have at most one argument group</source>
        <target state="translated">Vlastnost getter může mít maximálně jednu skupinu argumentů.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetterAtMostTwoArguments">
        <source>A setter property may have at most two argument groups</source>
        <target state="translated">Vlastnost setter může mít maximálně dvě skupiny argumentů.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidProperty">
        <source>Invalid property getter or setter</source>
        <target state="translated">Neplatná metoda getter nebo setter vlastnosti</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIndexerPropertyRequiresAtLeastOneArgument">
        <source>An indexer property must be given at least one argument</source>
        <target state="translated">Vlastnosti indexeru se musí předávat aspoň jeden argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidAddressOfMutableAcrossAssemblyBoundary">
        <source>This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation</source>
        <target state="translated">Tato operace přistupuje k proměnlivé hodnotě na nejvyšší úrovni definované v jiném sestavení nepodporovaným způsobem. K hodnotě se nedá přistupovat prostřednictvím její adresy. Zvažte následující postup: zkopírujte výraz do lokální proměnné, třeba let mutable x = ..., a po dokončení operace přiřaďte v případě potřeby znovu původní hodnotu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTypars">
        <source>Type parameters must be placed directly adjacent to the type name, e.g. \"type C&lt;'T&gt;\", not     type \"C   &lt;'T&gt;\"</source>
        <target state="translated">Parametry typu je potřeba zadat bezprostředně za název typu, třeba \"type C&lt;'T&gt;\", ne     type \"C   &lt;'T&gt;\".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTyargs">
        <source>Type arguments must be placed directly adjacent to the type name, e.g. \"C&lt;'T&gt;\", not \"C  &lt;'T&gt;\"</source>
        <target state="translated">Argumenty typu je potřeba zadat bezprostředně za název typu, třeba \"C&lt;'T&gt;\", ne \"C  &lt;'T&gt;\".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAtomicType">
        <source>The use of the type syntax 'int C' and 'C  &lt;int&gt;' is not permitted here. Consider adjusting this type to be written in the form 'C&lt;int&gt;'</source>
        <target state="translated">Použití syntaxe typu int C nebo C  &lt;int&gt; tady není povolené. Zvažte zapsání tohoto typu v podobě C&lt;int&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespace">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the module/namespace '{2}'</source>
        <target state="translated">Modul nebo obor názvů {0} z kompilační jednotky {1} neobsahoval modul nebo obor názvů {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefVal">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the val '{2}'</source>
        <target state="translated">Modul nebo obor názvů {0} z kompilační jednotky {1} neobsahoval hodnotu {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespaceType">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the namespace, module or type '{2}'</source>
        <target state="translated">Modul nebo obor názvů {0} z kompilační jednotky {1} neobsahoval obor názvů, modul nebo typ {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseNullAsTrueValue">
        <source>The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case</source>
        <target state="translated">Příznak atributu UseNullAsTrueValue se dá použít jenom s typy sjednocení, které mají jeden prázdný případ a aspoň jeden neprázdný případ.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterInferredByref">
        <source>The parameter '{0}' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref&lt;int&gt;'. When used, a byref parameter is implicitly dereferenced.</source>
        <target state="translated">Parametr {0} je odvozený jako parametr typu ByRef. Parametrům typu ByRef se musí předávat explicitní poznámka typu, třeba x1: byref&lt;int&gt;. V případě jejího použití se k parametru typu ByRef přistoupí implicitně přes ukazatel.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonUniformMemberUse">
        <source>The generic member '{0}' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.</source>
        <target state="translated">Použili jste obecný člen {0} v neuniformní instanci před tímto místem v programu. Zvažte možnost změnit pořadí členů tak, aby se tento uvedl jako první. Případně specifikujte úplný typ člena explicitně, včetně typů argumentů, návratového typu a všech dalších obecných parametrů a omezení.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttribArgsDiffer">
        <source>The attribute '{0}' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.</source>
        <target state="translated">Atribut {0} se vyskytuje jak v implementaci, tak v signatuře, ale argumenty atributu se liší. Do kompilovaného kódu se zahrne jenom atribut ze signatury.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallAbstractBaseMember">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">Nejde volat abstraktní základní člen: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInUnmanaged">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position</source>
        <target state="translated">Nepovedlo se vyřešit nejednoznačnost v použití obecného konstruktoru s omezením unmanaged na této pozici nebo blízko ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="mlCompatMessage">
        <source>This construct is for ML compatibility. {0}. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'.</source>
        <target state="translated">Tento konstruktor je určený pro kompatibilitu ML. {0}. Toto upozornění můžete pomocí --mlcompatibility nebo --nowarn:62 vypnout.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldDoesNotHaveValidOffsetForStructureLayout">
        <source>The type '{0}' has been marked as having an Explicit layout, but the field '{1}' has not been marked with the 'FieldOffset' attribute</source>
        <target state="translated">Typ {0} je označený jako typ s explicitním rozložením, ale u pole {1} chybí atribut FieldOffset.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfacesShouldUseInheritNotInterface">
        <source>Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'</source>
        <target state="translated">Rozhraní zděděná jinými rozhraními by se měla deklarovat pomocí inherit ... a ne pomocí interface...</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperator">
        <source>Invalid prefix operator</source>
        <target state="translated">Neplatný operátor předpony</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperatorDefinition">
        <source>Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.</source>
        <target state="translated">Neplatná definice operátora. Definice operátorů předpon musí používat platné názvy těchto operátorů.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCompilingExtensionIsForML">
        <source>The file extensions '.ml' and '.mli' are for ML compatibility</source>
        <target state="translated">Přípony .ml a .mli zajišťují kompatibilitu s ML.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIndentOffForML">
        <source>Consider using a file with extension '.ml' or '.mli' instead</source>
        <target state="translated">Zvažte možnost použít místo toho soubor s příponou .ml nebo .mli.</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternIdentIsNotFunctionTyped">
        <source>Active pattern '{0}' is not a function</source>
        <target state="translated">Aktivní vzor {0} není funkce.</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternChoiceHasFreeTypars">
        <source>Active pattern '{0}' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</source>
        <target state="translated">Typ výsledku aktivního vzoru {0} obsahuje proměnné typu, které nejsou určené vstupem. Příčinou je obvykle chybějící zmínka o rozlišení velkých a malých písmen výsledku, třeba výraz let (|A|B|) (x:int) = A x. Dá se to opravit omezením typu, třeba použitím výrazu let (|A|B|) (x:int) : Choice&lt;int,jednotka&gt; = A x.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldHasOffsetForSequentialLayout">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">Atribut FieldOffset jde použít jenom pro členy typů s deklarací StructLayout(LayoutKind.Explicit).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsMustComeAfterNonOptionalArgs">
        <source>Optional arguments must come at the end of the argument list, after any non-optional arguments</source>
        <target state="translated">Nepovinné argumenty musí být uvedené na konci seznamu argumentů, tj. až po všech povinných argumentech.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeUsage">
        <source>Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes</source>
        <target state="translated">Atribut System.Diagnostics.ConditionalAttribute je platný jenom u metod nebo tříd atributů.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOperatorDefinitionInExtrinsic">
        <source>Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.</source>
        <target state="translated">Členové rozšíření nemůžou poskytovat přetížení operátorů. Zvažte možnost definovat místo toho operátor v definici typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBFileNameCannotBeChangedWarning">
        <source>The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.</source>
        <target state="translated">Název souboru MDB musí být &lt;název-souboru-sestavení&gt;.mdb. Možnost --pdb se bude ignorovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBMemberMissing">
        <source>MDB generation failed. Could not find compatible member {0}</source>
        <target state="translated">Generování souboru MDB selhalo. Nenašel se kompatibilní člen {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingMdb">
        <source>Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly.</source>
        <target state="translated">Nedají se vygenerovat ladicí informace MDB. Načtení typu MonoSymbolWriter ze sestavení Mono.CompilerServices.SymbolWriter.dll selhalo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseNameConflictsWithGeneratedType">
        <source>The union case named '{0}' conflicts with the generated type '{1}'</source>
        <target state="translated">Případ typu union s názvem {0} koliduje s generovaným typem {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoReflectedDefinitionOnStructMember">
        <source>ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter</source>
        <target state="translated">ReflectedDefinitionAttribute se nedá použít pro člena instance u typu struktura, protože člen instance přebírá implicitní parametr this typu ByRef.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportNotAllowed">
        <source>DLLImport bindings must be static members in a class or function definitions in a module</source>
        <target state="translated">Vazby DLLImport musí být statickými členy v definici třídy nebo funkce v modulu.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExplicitCoreLibRequiresNoFramework">
        <source>When mscorlib.dll or FSharp.Core.dll is explicitly referenced the {0} option must also be passed</source>
        <target state="translated">Pokud se na knihovnu mscorlib.dll nebo FSharp.Core.dll odkazuje explicitně, musí se předávat taky možnost {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedSigdataFile">
        <source>FSharp.Core.sigdata not found alongside FSharp.Core. File expected in {0}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">V FSharp.Core se nenašel soubor FSharp.Core.sigdata. Soubor se očekával v {0}. Zvažte upgrade na novější verzi FSharp.Core, kde se tento soubor už nevyžaduje.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedFileAlongSideFSharpCore">
        <source>File '{0}' not found alongside FSharp.Core. File expected in {1}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">U souboru FSharp.Core se nenašel soubor {0}. Soubor se očekával v {1}. Zvažte upgrade na novější verzi souboru FSharp.Core, kde se tento soubor už nevyžaduje.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedFileNameCharacter">
        <source>Filename '{0}' contains invalid character '{1}'</source>
        <target state="translated">V názvu soboru {0} je neplatný znak {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBinding">
        <source>'use!' bindings must be of the form 'use! &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">Vazby use! musí mít notaci use! &lt;var&gt; = &lt;expr&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoInnerGenericsInQuotations">
        <source>Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.</source>
        <target state="translated">Vnitřní obecné funkce nejsou ve výrazech v uvozovkách povolené. Dokud bude tato funkce obecná, zvažte přidání některých omezení typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumTypeCannotBeEnumerated">
        <source>The type '{0}' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property</source>
        <target state="translated">Typ {0} není platným výčtovým typem, to znamená, že u něj chybí metoda MoveNext(), která by vracela logickou hodnotu, a vlastnost Current.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteString">
        <source>End of file in triple-quote string begun at or before here</source>
        <target state="translated">Konec souboru začal v řetězci v trojitých uvozovkách na této pozici nebo před ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteStringInComment">
        <source>End of file in triple-quote string embedded in comment begun at or before here</source>
        <target state="translated">Konec souboru začal v řetězci v trojitých uvozovkách vloženém do komentáře na této pozici nebo před ní.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLosesMeasures">
        <source>This type test or downcast will ignore the unit-of-measure '{0}'</source>
        <target state="translated">Test tohoto typu nebo jeho přetypování směrem dolů bude ignorovat měrnou jednotku {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingTypeArgs">
        <source>Expected type argument or static argument</source>
        <target state="translated">Očekával se argument typu nebo statický argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingGreaterThan">
        <source>Unmatched '&lt;'. Expected closing '&gt;'</source>
        <target state="translated">Nespárovaná levá závorka &lt;. Očekává se pravá závorka &gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
        <source>Unexpected quotation operator '&lt;@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '&lt;' and '@' characters.</source>
        <target state="translated">Neočekávaný operátor citace &lt;@ v definici typu. Pokud chcete zprostředkovateli typu předávat doslovný řetězec jako statický argument, vložte mezi znaky &lt; a @ mezeru.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorParsingAsOperatorName">
        <source>Attempted to parse this as an operator name, but failed</source>
        <target state="translated">Proběhl pokus o analýzu jako názvu operátoru, ale tento pokus selhal.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidUnicodeLiteral">
        <source>\U{0} is not a valid Unicode character escape sequence</source>
        <target state="translated">\U{0} není platná znaková řídicí sekvence Unicode.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoWrongType">
        <source>'{0}' must be applied to an argument of type '{1}', but has been applied to an argument of type '{2}'</source>
        <target state="translated">{0} se musí použít pro argument typu {1}, ale použil se pro argument typu {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoNotOptional">
        <source>'{0}' can only be applied to optional arguments</source>
        <target state="translated">{0} se dá použít jenom u volitelných argumentů.</target>
        <note />
      </trans-unit>
      <trans-unit id="toolLocationHelperUnsupportedFrameworkVersion">
        <source>The specified .NET Framework version '{0}' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
        <target state="translated">Zadaná verze rozhraní .NET Framework {0} není podporovaná. Zadejte hodnotu z výčtu Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidMagicValue">
        <source>Invalid Magic value in CLR Header</source>
        <target state="translated">Neplatná hodnota Magic v záhlaví CLR</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignBadImageFormat">
        <source>Bad image format</source>
        <target state="translated">Chybný formát image</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignPrivateKeyExpected">
        <source>Private key expected</source>
        <target state="translated">Očekává se privátní klíč</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignRsaKeyExpected">
        <source>RSA key expected</source>
        <target state="translated">Očekává se klíč RSA</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidBitLen">
        <source>Invalid bit Length</source>
        <target state="translated">Neplatná bitová délka</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidRSAParams">
        <source>Invalid RSAParameters structure - '{{0}}' expected</source>
        <target state="translated">Neplatná struktura parametru RSAParameters – očekává se {{0}}</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidAlgId">
        <source>Invalid algId - 'Exponent' expected</source>
        <target state="translated">Neplatné algId – očekává se Exponent</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidSignatureSize">
        <source>Invalid signature size</source>
        <target state="translated">Neplatná velikost podpisu</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignNoSignatureDirectory">
        <source>No signature directory</source>
        <target state="translated">Žádný adresář podpisu</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidPKBlob">
        <source>Invalid Public Key blob</source>
        <target state="translated">Neplatný objekt blob veřejného klíče</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTooManyErrors">
        <source>Exiting - too many errors</source>
        <target state="translated">Ukončení – příliš mnoho chyb</target>
        <note />
      </trans-unit>
      <trans-unit id="docfileNoXmlSuffix">
        <source>The documentation file has no .xml suffix</source>
        <target state="translated">Soubor dokumentace nemá příponu .xml.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscNoImplementationFiles">
        <source>No implementation files specified</source>
        <target state="translated">Nezadali jste žádné implementační soubory.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscBadAssemblyVersion">
        <source>The attribute {0} specified version '{1}', but this value is invalid and has been ignored</source>
        <target state="translated">Třída {0} definovala verzi {1}, ale tato hodnota není platná a ignoruje se.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTwoResourceManifests">
        <source>Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used.</source>
        <target state="translated">Zadali jste kolidující možnosti: win32manifest a win32res. Dá se použít jenom jedna z nich.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking">
        <source>The code in assembly '{0}' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">Kód v sestavení {0} využívá literály citace. Je možné, že při statickém propojování se komponenty využívající literály citace nezahrnou, pokud nejsou všechna sestavení zkompilovaná v F# ve verzi alespoň 4.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking0">
        <source>Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">Kód v tomto sestavení využívá literály citace. Je možné, že při statickém propojování se komponenty využívající literály citace nezahrnou, pokud nejsou všechna sestavení zkompilovaná v F# ve verzi alespoň 4.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoEXE">
        <source>Static linking may not include a .EXE</source>
        <target state="translated">Je možné, že se při statickém propojování nezahrne soubor .exe.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoMixedDLL">
        <source>Static linking may not include a mixed managed/unmanaged DLL</source>
        <target state="translated">Je možné, že se při statickém propojování nezahrne kombinovaná spravovaná nebo nespravovaná knihovna DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscIgnoringMixedWhenLinking">
        <source>Ignoring mixed managed/unmanaged assembly '{0}' during static linking</source>
        <target state="translated">Při statickém propojování se ignoruje kombinované spravované nebo nespravované sestavení {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssumeStaticLinkContainsNoDependencies">
        <source>Assembly '{0}' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.</source>
        <target state="translated">Na sestavení {0} se odkazovalo přechodně a nedalo se přeložit automaticky. Statické propojování bude předpokládat, že tato knihovna DLL nemá žádné závislosti na knihovně F# nebo jiných staticky propojených knihovnách DLL. Zvažte možnost přidat explicitní odkaz na tuto knihovnu DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyNotFoundInDependencySet">
        <source>Assembly '{0}' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.</source>
        <target state="translated">Sestavení {0} se v sadě závislostí cílového binárního souboru nenašlo. Staticky propojená kořenová umístění by se měla specifikovat pomocí názvu sestavení bez přípony DLL nebo EXE. Pokud se na toto sestavení odkazovalo explicitně, pak je možné, že ho generovaný binární soubor ve skutečnosti nevyžadoval, a v tom případě by se nemělo propojovat staticky.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileCouldNotBeOpened">
        <source>The key file '{0}' could not be opened</source>
        <target state="translated">Soubor klíče {0} se nedal otevřít.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscProblemWritingBinary">
        <source>A problem occurred writing the binary '{0}': {1}</source>
        <target state="translated">Při zapisování binárního souboru {0} došlo k potížím: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyVersionAttributeIgnored">
        <source>The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option</source>
        <target state="translated">Třída AssemblyVersionAttribute se ignorovala, protože jste verzi zadali pomocí možnosti příkazového řádku.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyCultureAttributeError">
        <source>Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'</source>
        <target state="translated">Chyba při generování atributu System.Reflection.AssemblyCultureAttribute: Spustitelné soubory nemůžou být satelitní sestavení. Jazyková verze by měla být vždycky prázdná.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDelaySignWarning">
        <source>Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module</source>
        <target state="translated">Možnost --delaysign přepisuje atribut System.Reflection.AssemblyDelaySignAttribute předaný ve zdrojovém souboru nebo přidaném modulu.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileWarning">
        <source>Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module</source>
        <target state="translated">Možnost --keyfile přepisuje atribut System.Reflection.AssemblyKeyFileAttribute předaný ve zdrojovém souboru nebo přidaném modulu.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyNameWarning">
        <source>Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module</source>
        <target state="translated">Možnost --keycontainer přepisuje atribut System.Reflection.AssemblyNameAttribute předaný ve zdrojovém souboru nebo přidaném modulu.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscReferenceOnCommandLine">
        <source>The assembly '{0}' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'.</source>
        <target state="translated">Sestavení {0} je uvedené na příkazovém řádku. Sestavení by se měla odkazovat pomocí příznaků příkazového řádku, jako je třeba -r.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscRemotingError">
        <source>The resident compilation service was not used because a problem occured in communicating with the server.</source>
        <target state="translated">Rezidentní kompilační služba se nepoužila, protože došlo k potížím při komunikaci se serverem.</target>
        <note />
      </trans-unit>
      <trans-unit id="pathIsInvalid">
        <source>Problem with filename '{0}': Illegal characters in path.</source>
        <target state="translated">Potíže s názvem souboru {0}: neplatné znaky v cestě</target>
        <note />
      </trans-unit>
      <trans-unit id="fscResxSourceFileDeprecated">
        <source>Passing a .resx file ({0}) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.</source>
        <target state="translated">Předávat kompilátoru soubor .resx ({0}) jako zdrojový soubor je zastaralý postup. Pomocí souboru resgen.exe převeďte soubor .resx na soubor .resources, aby se předával jako možnost --resource. Pokud používáte MSBuild, dá se to udělat prostřednictvím položky &lt;EmbeddedResource&gt; v souboru projektu .fsproj.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoProfileMismatches">
        <source>Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).</source>
        <target state="translated">Když se generuje sestavení, které se odkazuje na System.Runtime (třeba sestavení .NET Core nebo přenosné sestavení), nejde pro sestavení, které se odkazuje na knihovnu mscorlib (třeba sestavení rozhraní .NET Framework), použít statické propojování.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyWildcardAndDeterminism">
        <source>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</source>
        <target state="translated">Zadaná verze {0} je {1}, ale tato hodnota představuje zástupný znak a vy jste požádali o deterministické sestavení, což je v konfliktu.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDeterministicDebugRequiresPortablePdb">
        <source>Determinstic builds only support portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">Deterministická sestavení podporují jenom soubory PDB typu Portable (--debug:portable nebo --debug:embedded).</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInNamespaceName">
        <source>Character '{0}' is not allowed in provided namespace name '{1}'</source>
        <target state="translated">Znak {0} není v názvu poskytnutého oboru názvů {1} povolený.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullOrEmptyMemberName">
        <source>The provided type '{0}' returned a member with a null or empty member name</source>
        <target state="translated">Poskytnutý typ {0} vrátil člena, jehož název je prázdný nebo null.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMember">
        <source>The provided type '{0}' returned a null member</source>
        <target state="translated">Poskytnutý typ {0} vrátil člena s hodnotou null.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringType">
        <source>The provided type '{0}' member info '{1}' has null declaring type</source>
        <target state="translated">U informací o členu {1} poskytnutého typu {0} má deklarující typ hodnotu null.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringTypeDifferentFromProvidedType">
        <source>The provided type '{0}' has member '{1}' which has declaring type '{2}'. Expected declaring type to be the same as provided type.</source>
        <target state="translated">Poskytnutý typ {0} má člena {1} s deklarujícím typem {2}. Očekává se, že deklarující typ bude stejný jako poskytnutý typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="etHostingAssemblyFoundWithoutHosts">
        <source>Referenced assembly '{0}' has assembly level attribute '{1}' but no public type provider classes were found</source>
        <target state="translated">Odkazované sestavení {0} má atribut {1} na úrovní sestavení, ale nenašly se žádné třídy veřejného zprostředkovatele typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceOfTypeNotAllowed">
        <source>Type '{0}' from type provider '{1}' has an empty namespace. Use 'null' for the global namespace.</source>
        <target state="translated">Typ {0} od zprostředkovatele typu {1} má prázdný obor názvů. Pro globální obor názvů použijte null.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceNotAllowed">
        <source>Empty namespace found from the type provider '{0}'. Use 'null' for the global namespace.</source>
        <target state="translated">Našel se prázdný obor názvů od zprostředkovatele typu {0}. Pro globální obor názvů použijte null.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeGeneric">
        <source>Provided type '{0}' has 'IsGenericType' as true, but generic types are not supported.</source>
        <target state="translated">Vlastnost IsGenericType poskytnutého typu {0} má hodnotu true. Obecné typy se ale nepodporují.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeAnArray">
        <source>Provided type '{0}' has 'IsArray' as true, but array types are not supported.</source>
        <target state="translated">Vlastnost IsArray poskytnutého typu {0} má hodnotu true. Typy polí se ale nepodporují.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMethodHasRequirements">
        <source>Invalid member '{0}' on provided type '{1}'. Provided type members must be public, and not be generic, virtual, or abstract.</source>
        <target state="translated">Neplatný člen {0} u poskytnutého typu {1}. Členové poskytnutého typu musí být veřejné,ne obecné, virtuální nebo abstraktní.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedMemberKind">
        <source>Invalid member '{0}' on provided type '{1}'. Only properties, methods and constructors are allowed</source>
        <target state="translated">Neplatný člen {0} u poskytnutého typu {1}. Povolují se jenom vlastnosti, metody a konstruktory.</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanReadButHasNoGetter">
        <source>Property '{0}' on provided type '{1}' has CanRead=true but there was no value from GetGetMethod()</source>
        <target state="translated">Vlastnost {0} u poskytnutého typu {1} má CanRead s hodnotou true, ale metoda GetGetMethod() nevrátila žádnou hodnotu.</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasGetterButNoCanRead">
        <source>Property '{0}' on provided type '{1}' has CanRead=false but GetGetMethod() returned a method</source>
        <target state="translated">Vlastnost {0} u poskytnutého typu {1} má CanRead s hodnotou false, ale metoda GetGetMethod() vrátila metodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanWriteButHasNoSetter">
        <source>Property '{0}' on provided type '{1}' has CanWrite=true but there was no value from GetSetMethod()</source>
        <target state="translated">Vlastnost {0} u poskytnutého typu {1} má CanWrite s hodnotou true, ale metoda GetSetMethod() nevrátila žádnou hodnotu.</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasSetterButNoCanWrite">
        <source>Property '{0}' on provided type '{1}' has CanWrite=false but GetSetMethod() returned a method</source>
        <target state="translated">Vlastnost {0} u poskytnutého typu {1} má CanWrite s hodnotou false, ale metoda GetSetMethod() vrátila metodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
        <source>One or more errors seen during provided type setup</source>
        <target state="translated">Při nastavení poskytnutého typu se vyskytla nejmíň jedna chyba.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedTypeMember">
        <source>Unexpected exception from provided type '{0}' member '{1}': {2}</source>
        <target state="translated">U poskytnutého typu {0}, člena {1} došlo k neočekávané výjimce: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedConstantType">
        <source>Unsupported constant type '{0}'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal.</source>
        <target state="translated">Nepodporovaný typ konstanty {0}. Citace poskytované zprostředkovateli typu můžou obsahovat jenom jednoduché konstanty. Implementaci zprostředkovatele typu možná bude potřeba upravit přesunutím hodnoty deklarované mimo poskytnutý literál citace do vazby let v literálu citace.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedProvidedExpression">
        <source>Unsupported expression '{0}' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.</source>
        <target state="translated">U zprostředkovatele typu se vyskytl neplatný výraz {0}. Pokud jste autorem tohoto zprostředkovatele typu, zvažte možnost upravit ho tak, aby poskytoval jiný poskytnutý výraz.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedName">
        <source>Expected provided type named '{0}' but provided type has 'Name' with value '{1}'</source>
        <target state="translated">Očekával se poskytnutý typ s názvem {0}, ale Name u poskytnutého typu má hodnotu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoAdd">
        <source>Event '{0}' on provided type '{1}' has no value from GetAddMethod()</source>
        <target state="translated">Událost {0} u poskytnutého typu {1} nepřebírá žádnou hodnotu od GetAddMethod().</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoRemove">
        <source>Event '{0}' on provided type '{1}' has no value from GetRemoveMethod()</source>
        <target state="translated">Událost {0} u poskytnutého typu {1} nepřebírá žádnou hodnotu od GetRemoveMethod().</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssembly">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded or doesn't exist. {2}</source>
        <target state="translated">Atribut sestavení {0} odkazuje na navržené sestavení {1}, které se nedá načíst nebo neexistuje. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderDoesNotHaveValidConstructor">
        <source>The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected.</source>
        <target state="translated">Zprostředkovatel typu nemá platný konstruktor. Očekávaný konstruktor nemá přebírat buď žádné argumenty, nebo jeden argument typu TypeProviderConfig.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderError">
        <source>The type provider '{0}' reported an error: {1}</source>
        <target state="translated">Zprostředkovatel typu {0} oznámil chybu: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectParameterExpression">
        <source>The type provider '{0}' used an invalid parameter in the ParameterExpression: {1}</source>
        <target state="translated">Zprostředkovatel typu {0} použil ve výrazu ParameterExpression neplatný parametr: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedMethod">
        <source>The type provider '{0}' provided a method with a name '{1}' and metadata token '{2}', which is not reported among its methods of its declaring type '{3}'</source>
        <target state="translated">Zprostředkovatel typu {0} poskytnul metodu s názvem {1} a tokenem metadat {2}, která není uvedená mezi metodami jeho deklarujícího typu {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedConstructor">
        <source>The type provider '{0}' provided a constructor which is not reported among the constructors of its declaring type '{1}'</source>
        <target state="translated">Zprostředkovatel typu {0} poskytnul konstruktor, který není uvedený mezi konstruktory jeho deklarujícího typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="etDirectReferenceToGeneratedTypeNotAllowed">
        <source>A direct reference to the generated type '{0}' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = &lt;path&gt;'. This indicates that a type provider adds generated types to your assembly.</source>
        <target state="translated">Přímý odkaz na generovaný typ {0} není povolený. Místo něj použijte definici typu, třeba type TypeAlias = &lt;cesta&gt;. Ta označuje, že zprostředkovatel typu přidává k sestavení generované typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedPath">
        <source>Expected provided type with path '{0}' but provided type has path '{1}'</source>
        <target state="translated">Očekával se poskytnutý typ s cestou {0}, ale cesta poskytnutého typu je {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedNullFromProvidedTypeMember">
        <source>Unexpected 'null' return value from provided type '{0}' member '{1}'</source>
        <target state="translated">Poskytnutý typ {0}, člen {1} vrátil neočekávanou návratovou hodnotu null.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedMemberMember">
        <source>Unexpected exception from member '{0}' of provided type '{1}' member '{2}': {3}</source>
        <target state="translated">U člena {0} poskytnutého typu {1}, člena {2} došlo k neočekávané výjimce: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
        <source>Nested provided types do not take static arguments or generic parameters</source>
        <target state="translated">Vnořené poskytnuté typy nepřebírají statické argumenty ani obecné parametry.</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidStaticArgument">
        <source>Invalid static argument to provided type. Expected an argument of kind '{0}'.</source>
        <target state="translated">Neplatný statický argument poskytnutého typu. Očekávaný druh argumentu je {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToType">
        <source>An error occured applying the static arguments to a provided type</source>
        <target state="translated">Při použití statických argumentů u poskytnutého typu došlo k chybě.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnknownStaticArgumentKind">
        <source>Unknown static argument kind '{0}' when resolving a reference to a provided type or method '{1}'</source>
        <target state="translated">Při překladu odkazu na poskytnutý typ nebo metodu {1} se objevil neznámý druh statického argumentu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidNamespaceForProvidedType">
        <source>invalid namespace for provided type</source>
        <target state="translated">Neplatný obor názvů pro poskytnutý typ</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidFullNameForProvidedType">
        <source>invalid full name for provided type</source>
        <target state="translated">Neplatný úplný název poskytnutého typu</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderReturnedNull">
        <source>The type provider returned 'null', which is not a valid return value from '{0}'</source>
        <target state="translated">Zprostředkovatel typu vrátil hodnotu null, která není platnou návratovou hodnotou {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTypeProviderConstructorException">
        <source>The type provider constructor has thrown an exception: {0}</source>
        <target state="translated">Konstruktor zprostředkovatele typu vyvolal výjimku: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullProvidedExpression">
        <source>Type provider '{0}' returned null from GetInvokerExpression.</source>
        <target state="translated">Zprostředkovatel typu {0} vrátil u metody GetInvokerExpression hodnotu null.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedTypeHadWrongName">
        <source>The type provider '{0}' returned an invalid type from 'ApplyStaticArguments'. A type with name '{1}' was expected, but a type with name '{2}' was returned.</source>
        <target state="translated">Zprostředkovatel typu {0} vrátil u metody ApplyStaticArguments neplatný typ. Očekával se typ s názvem {1}, ale vrácený typ má název {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedMethodHadWrongName">
        <source>The type provider '{0}' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '{1}' was expected, but a method with name '{2}' was returned.</source>
        <target state="translated">Zprostředkovatel typu {0} vrátil z metody ApplyStaticArgumentsForMethod neplatnou metodu. Očekávala se metoda s názvem {1}, ale vrátila se metoda s názvem {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLossy">
        <source>This type test or downcast will erase the provided type '{0}' to the type '{1}'</source>
        <target state="translated">Test tohoto typu nebo jeho přetypování směrem dolů vymaže poskytnutý typ {0} na typ {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCastErased">
        <source>This downcast will erase the provided type '{0}' to the type '{1}'.</source>
        <target state="translated">Toto přetypování směrem dolů vymaže typ {0} poskytnutý typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestErased">
        <source>This type test with a provided type '{0}' is not allowed because this provided type will be erased to '{1}' at runtime.</source>
        <target state="translated">Test tohoto typu s poskytnutým typem {0} není povolený, protože tento poskytnutý typ se při běhu vymaže na {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromErasedType">
        <source>Cannot inherit from erased provided type</source>
        <target state="translated">Nejde dědit z vymazaného poskytnutého typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidTypeProviderAssemblyName">
        <source>Assembly '{0}' hase TypeProviderAssembly attribute with invalid value '{1}'. The value should be a valid assembly name</source>
        <target state="translated">Základní atribut TypeProviderAssembly sestavení {0} má neplatnou hodnotu {1}. Hodnotou by měl být platný název sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameCtor">
        <source>Invalid member name. Members may not have name '.ctor' or '.cctor'</source>
        <target state="translated">Neplatný název člena. Členové nemůžou mít název .ctor nebo .cctor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInferredGenericTypeGivesRiseToInconsistency">
        <source>The function or member '{0}' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '{1}'.</source>
        <target state="translated">Funkce nebo člen {0} se používá způsobem, který vyžaduje, aby se k jeho definici doplnily další poznámky typu. Je to kvůli zajištění konzistence odvozených typů. Odvozená signatura je {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentCount">
        <source>The number of type arguments did not match: '{0}' given, '{1}' expected. This may be related to a previously reported error.</source>
        <target state="translated">Počet argumentů typu se neshodoval: počet předaných je {0}, ale počet očekávaných je {1}. Může to souviset s dřív hlášenou chybou.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotOverrideSealedMethod">
        <source>Cannot override inherited member '{0}' because it is sealed</source>
        <target state="translated">Zděděný člen {0} se nedá přepsat, protože je zapečetěný.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderErrorWithContext">
        <source>The type provider '{0}' reported an error in the context of provided type '{1}', member '{2}'. The error: {3}</source>
        <target state="translated">Zprostředkovatel typu {0} oznámil chybu v kontextu poskytnutého typu {1} a člena {2}: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNameException">
        <source>An exception occurred when accessing the '{0}' of a provided type: {1}</source>
        <target state="translated">Při přístupu k {0} poskytnutého typu došlo k výjimce: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNullOrEmptyName">
        <source>The '{0}' of a provided type was null or empty.</source>
        <target state="translated">Název {0} poskytnutého typu má hodnotu null nebo je prázdný.</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInTypeName">
        <source>Character '{0}' is not allowed in provided type name '{1}'</source>
        <target state="translated">Znak {0} není v názvu poskytnutého typu {1} povolený.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcJoinMustUseSimplePattern">
        <source>In queries, '{0}' must use a simple pattern</source>
        <target state="translated">V dotazech musí {0} použít jednoduchý vzor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMissingCustomOperation">
        <source>A custom query operation for '{0}' is required but not specified</source>
        <target state="translated">Vyžaduje se operace vlastního dotazu pro {0}, která ale není zadaná.</target>
        <note />
      </trans-unit>
      <trans-unit id="etBadUnnamedStaticArgs">
        <source>Named static arguments must come after all unnamed static arguments</source>
        <target state="translated">Pojmenované statické argumenty se musí umístit až za všechny nepojmenované statické argumenty.</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterRequiresAValue">
        <source>The static parameter '{0}' of the provided type or method '{1}' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '{2}&lt;{3}=...&gt;'.</source>
        <target state="translated">Statický parametr {0} poskytnutého typu nebo metody {1} vyžaduje hodnotu. Statické parametry pro zprostředkovatele typů je případně možné zadat pomocí pojmenovaných argumentů, třeba {2}&lt;{3}=...&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNoStaticParameterWithName">
        <source>No static parameter exists with name '{0}'</source>
        <target state="translated">Neexistuje žádný statický parametr s názvem {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterAlreadyHasValue">
        <source>The static parameter '{0}' has already been given a value</source>
        <target state="translated">Statický parametr {0} už hodnotu převzal.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMultipleStaticParameterWithName">
        <source>Multiple static parameters exist with name '{0}'</source>
        <target state="translated">Existuje víc statických parametrů s názvem {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
        <source>A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression</source>
        <target state="translated">Vlastní operace se nedají použít ve spojení s vazbou let, která je bez hodnoty nebo rekurzivní a nachází se v jiné části tohoto výrazu výpočtu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedHere">
        <source>A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression</source>
        <target state="translated">Vlastní operace se ve spojení s operátory use, try/with, try/finally, if/then/else nebo match v tomto výrazu výpočtu použít nedají.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeOverloaded">
        <source>The custom operation '{0}' refers to a method which is overloaded. The implementations of custom operations may not be overloaded.</source>
        <target state="translated">Vlastní operace {0} odkazuje na metodu, která je přetěžovaná. Implementace vlastních operací se nemůžou přetěžovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIfThenElseMayNotBeUsedWithinQueries">
        <source>An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.</source>
        <target state="translated">Výraz if/then/else se nedá použít v dotazech. Zvažte možnost použít místo toho výraz if/then nebo výraz pořadí.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
        <source>Invalid argument to 'methodhandleof' during codegen</source>
        <target state="translated">Neplatný argument pro methodhandleof při generování kódu</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceMissingArgument">
        <source>A reference to a provided type was missing a value for the static parameter '{0}'. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">U odkazu na poskytnutý typ chybí hodnota pro statický parametr {0}. Možná bude potřeba znovu zkompilovat jedno nebo víc odkazovaných sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceInvalidText">
        <source>A reference to a provided type had an invalid value '{0}' for a static parameter. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">U odkazu na poskytnutý typ je hodnota {0} pro statický parametr neplatná. Možná bude potřeba znovu zkompilovat jedno nebo víc odkazovaných sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly">
        <source>'{0}' is not used correctly. This is a custom operation in this query or computation expression.</source>
        <target state="translated">{0} se nepoužívá správně. Toto je vlastní operace v tomto výrazu dotazu nebo výpočtu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly2">
        <source>'{0}' is not used correctly. Usage: {1}. This is a custom operation in this query or computation expression.</source>
        <target state="translated">{0} se nepoužívá správně. Použití: {1}. Toto je vlastní operace v tomto výrazu dotazu nebo výpočtu.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeJoin">
        <source>{0} var in collection {1} (outerKey = innerKey). Note that parentheses are required after '{2}'</source>
        <target state="translated">{0} proměnná v kolekci {1} (outerKey = innerKey). Poznámka: Za {2} se vyžadují závorky.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeGroupJoin">
        <source>{0} var in collection {1} (outerKey = innerKey) into group. Note that parentheses are required after '{2}'</source>
        <target state="translated">{0} proměnná v kolekci {1} (outerKey = innerKey) do skupiny. Poznámka: Za {2} se vyžadují závorky.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeZip">
        <source>{0} var in collection</source>
        <target state="translated">{0} proměnná v kolekci</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresVariable">
        <source>'{0}' must be followed by a variable name. Usage: {1}.</source>
        <target state="translated">Po {0} musí následovat název proměnné. Použití: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorIncorrectSyntax">
        <source>Incorrect syntax for '{0}'. Usage: {1}.</source>
        <target state="translated">Neplatná syntaxe pro {0}. Použití: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresBody">
        <source>'{0}' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... {1} ...</source>
        <target state="translated">{0} se musí umístit za klauzuli výběru for a pak musí následovat zbytek dotazu. Syntaxe: ... {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationHasIncorrectArgCount">
        <source>'{0}' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected {1} argument(s), but given {2}.</source>
        <target state="translated">{0} se používá s nesprávným počtem argumentů. Toto je vlastní operace v tomto výrazu dotazu nebo výpočtu. Očekávaný počet argumentů je {1}, ale počet předávaných je {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterToken">
        <source>Expected an expression after this point</source>
        <target state="translated">Za touto pozicí se očekává výraz.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedTypeAfterToken">
        <source>Expected a type after this point</source>
        <target state="translated">Za touto pozicí se očekával typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLBrackLess">
        <source>Unmatched '[&lt;'. Expected closing '&gt;]'</source>
        <target state="translated">Nespárovaný výraz [&lt;. Očekává se výraz &gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileMatch">
        <source>Unexpected end of input in 'match' expression. Expected 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</source>
        <target state="translated">Neočekávaný konec vstupu ve výrazu match. Očekávaná notace je match &lt;výraz&gt; with | &lt;cesta&gt; -&gt; &lt;výraz&gt; | &lt;cesta&gt; -&gt; &lt;výraz&gt; </target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTry">
        <source>Unexpected end of input in 'try' expression. Expected 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;'.</source>
        <target state="translated">Neočekávaný konec vstupu ve výrazu try. Očekávaná notace je try &lt;výraz&gt; with &lt;pravidla&gt; nebo try &lt;výraz&gt; finally &lt;výraz&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWhile">
        <source>Unexpected end of input in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Neočekávaný konec vstupu ve výrazu while. Očekávaná notace je while &lt;výraz&gt; do &lt;výraz&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFor">
        <source>Unexpected end of input in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Neočekávaný konec vstupu ve výrazu for. Očekávaná notace je for &lt;vzor&gt; in &lt;výraz&gt; do &lt;výraz&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWith">
        <source>Unexpected end of input in 'match' or 'try' expression</source>
        <target state="translated">Neočekávaný konec vstupu ve výrazu match nebo try</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileThen">
        <source>Unexpected end of input in 'then' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Neočekávaný konec vstupu ve větvi then podmínky. Očekávaná notace je if &lt;výraz&gt; then &lt;výraz&gt; nebo if &lt;výraz&gt; then &lt;výraz&gt; else &lt;výraz&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileElse">
        <source>Unexpected end of input in 'else' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Neočekávaný konec vstupu ve větvi else podmínky. Očekávaná notace je if &lt;výraz&gt; then &lt;výraz&gt; nebo if &lt;výraz&gt; then &lt;výraz&gt; else &lt;výraz&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFunBody">
        <source>Unexpected end of input in body of lambda expression. Expected 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</source>
        <target state="translated">Neočekávaný konec vstupu v těle výrazu lambda. Očekávaná notace je fun &lt;cesta&gt; ... &lt;cesta&gt; -&gt; &lt;výraz&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeArgs">
        <source>Unexpected end of input in type arguments</source>
        <target state="translated">Neočekávaný konec vstupu v argumentech typu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeSignature">
        <source>Unexpected end of input in type signature</source>
        <target state="translated">Neočekávaný konec vstupu v signatuře typu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeDefinition">
        <source>Unexpected end of input in type definition</source>
        <target state="translated">Neočekávaný konec vstupu v definici typu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileObjectMembers">
        <source>Unexpected end of input in object members</source>
        <target state="translated">Neočekávaný konec vstupu u členů objektu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileDefinition">
        <source>Unexpected end of input in value, function or member definition</source>
        <target state="translated">Neočekávaný konec vstupu v definici hodnoty, funkce nebo člena</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileExpression">
        <source>Unexpected end of input in expression</source>
        <target state="translated">Neočekávaný konec vstupu ve výrazu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedNameAfterToken">
        <source>Unexpected end of type. Expected a name after this point.</source>
        <target state="translated">Neočekávaný konec typu. Za touto pozicí se očekává název.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLet">
        <source>Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.</source>
        <target state="translated">Neúplná definice hodnoty nebo funkce. Pokud je tato definice ve výrazu, musí být tělo tohoto výrazu odsazené na stejnou úroveň jako klíčové slovo let.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLetBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword.</source>
        <target state="translated">Neúplná definice hodnoty. Pokud je tato definice ve výrazu, musí být tělo tohoto výrazu odsazené na stejnou úroveň jako klíčové slovo let!.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUseBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword.</source>
        <target state="translated">Neúplná definice hodnoty. Pokud je tato definice ve výrazu, musí být tělo tohoto výrazu odsazené na stejnou úroveň jako klíčové slovo use!.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUse">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword.</source>
        <target state="translated">Neúplná definice hodnoty. Pokud je tato definice ve výrazu, musí být tělo tohoto výrazu odsazené na stejnou úroveň jako klíčové slovo use.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsWhileDoExpected">
        <source>Missing 'do' in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Ve výrazu while chybí do. Očekávaná notace je while &lt;výraz&gt; do &lt;výraz&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsForDoExpected">
        <source>Missing 'do' in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Ve výrazu for chybí klíčové slovo do. Očekávaná notace je for &lt;cesta&gt; in &lt;výraz&gt; do &lt;výraz&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRelationInJoin">
        <source>Invalid join relation in '{0}'. Expected 'expr &lt;op&gt; expr', where &lt;op&gt; is =, =?, ?= or ?=?.</source>
        <target state="translated">Neplatná relace spojení v {0}. Očekávaná notace je expr &lt;op&gt; expr, kde &lt;op&gt; je =, =?, ?= nebo ?=?.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCallsWord">
        <source>Calls</source>
        <target state="translated">Počet volání</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidNumberOfGenericArguments">
        <source>Invalid number of generic arguments to type '{0}' in provided type. Expected '{1}' arguments, given '{2}'.</source>
        <target state="translated">Neplatný počet obecných argumentů pro typ {0} u poskytnutého typu. Očekávaný počet argumentů je: {1}, počet předaných je: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument1">
        <source>Invalid value '{0}' for unit-of-measure parameter '{1}'</source>
        <target state="translated">Neplatná hodnota {0} pro parametr měrné jednotky {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument2">
        <source>Invalid value unit-of-measure parameter '{0}'</source>
        <target state="translated">Neplatná hodnota parametru měrné jednotky {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyNeedsCanWriteOrCanRead">
        <source>Property '{0}' on provided type '{1}' is neither readable nor writable as it has CanRead=false and CanWrite=false</source>
        <target state="translated">Vlastnost {0} u poskytnutého typu {1} není ani čitelná ani zapisovatelná, protože má CanRead s hodnotou false a CanWrite s hodnotou false.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIntoNeedsRestOfQuery">
        <source>A use of 'into' must be followed by the remainder of the computation</source>
        <target state="translated">Za použitím into musí následovat zbytek výpočtu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorDoesntAcceptInto">
        <source>The operator '{0}' does not accept the use of 'into'</source>
        <target state="translated">Operátor {0} nepodporuje použití klíčového slova into.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationInvalid">
        <source>The definition of the custom operator '{0}' does not use a valid combination of attribute flags</source>
        <target state="translated">Definice vlastního operátoru {0} nepoužívá platnou kombinaci příznaků atributu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisTypeMayNotHaveACLIMutableAttribute">
        <source>This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute.</source>
        <target state="translated">Tato definice typu nemůže mít atribut CLIMutable. Ten můžou mít jenom typy záznamu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAutoPropertyRequiresImplicitConstructionSequence">
        <source>'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Definice member val jsou povolené jenom u typů s primárním konstruktorem. Zvažte možnost přidat do definice typu argumenty, třeba type X(args) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSet">
        <source>Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Definice vlastností se nedají deklarovat jako měnitelné. Pokud chcete tuto vlastnost definovat jako nastavitelnou, použijte syntaxi member val PropertyName = expr with get,set.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
        <source>To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Pokud chcete tuto vlastnost definovat jako nastavitelnou, použijte syntaxi member val PropertyName = expr with get,set.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefsOfByrefs">
        <source>Type '{0}' is illegal because in byref&lt;T&gt;, T cannot contain byref types.</source>
        <target state="translated">Typ {0} je neplatný, protože T v byref&lt;T&gt; nemůže obsahovat typy ByRef.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastopsMaxArrayThirtyTwo">
        <source>F# supports array ranks between 1 and 32. The value {0} is not allowed.</source>
        <target state="translated">F# podporuje rozměry polí od 1 do 32. Hodnota {0} není povolená.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoIntegerForLoopInQuery">
        <source>In queries, use the form 'for x in n .. m do ...' for ranging over integers</source>
        <target state="translated">V dotazech použijte notaci for x in n ... m do ..., která zajistí rozsah napříč celočíselnými typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoWhileInQuery">
        <source>'while' expressions may not be used in queries</source>
        <target state="translated">Výraz while se v dotazu použít nedá.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoTryFinallyInQuery">
        <source>'try/finally' expressions may not be used in queries</source>
        <target state="translated">Výraz try/finally se nedá použít v dotazech.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseMayNotBeUsedInQueries">
        <source>'use' expressions may not be used in queries</source>
        <target state="translated">Výrazy use se v dotazech použít nedají.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindMayNotBeUsedInQueries">
        <source>'let!', 'use!' and 'do!' expressions may not be used in queries</source>
        <target state="translated">Výrazy let!, use! a do! se v dotazech použít nedají.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnMayNotBeUsedInQueries">
        <source>'return' and 'return!' may not be used in queries</source>
        <target state="translated">V dotazech se nedá použít return! ani return.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryOperator">
        <source>This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type.</source>
        <target state="translated">Toto je neznámý operátor dotazu. Operátory dotazu jsou identifikátory jako třeba select, where, sortBy, thenBy, groupBy, groupValBy, join, groupJoin, sumBy nebo averageBy, které jsou definované pomocí odpovídajících metod v typu QueryBuilder.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryWithMayNotBeUsedInQueries">
        <source>'try/with' expressions may not be used in queries</source>
        <target state="translated">Výrazy try/with se u dotazů použít nedají.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonSimpleLetBindingInQuery">
        <source>This 'let' definition may not be used in a query. Only simple value definitions may be used in queries.</source>
        <target state="translated">Tato definice let se v dotazu použít nedá. V dotazech je možné použít jenom definice jednoduchých hodnot.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTooManyStaticParameters">
        <source>Too many static parameters. Expected at most {0} parameters, but got {1} unnamed and {2} named parameters.</source>
        <target state="translated">Příliš mnoho statických parametrů. Maximální očekávaný počet parametrů je {0}, ale počet přijatých parametrů je {1} (nepojmenované) a {2} (pojmenované).</target>
        <note />
      </trans-unit>
      <trans-unit id="infosInvalidProvidedLiteralValue">
        <source>Invalid provided literal value '{0}'</source>
        <target state="translated">Neplatná hodnota poskytnutého literálu {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidPlatformTarget">
        <source>The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead.</source>
        <target state="translated">Platforma anycpu32bitpreferred se dá použít jenom s cíli EXE. Místo ní je potřeba použít anycpu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisValueMayNotBeInlined">
        <source>This member, function or value declaration may not be declared 'inline'</source>
        <target state="translated">Člen, funkce nebo hodnota se nedá deklarovat jako inline.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErasedTypeUsedInGeneration">
        <source>The provider '{0}' returned a non-generated type '{1}' in the context of a set of generated types. Consider adjusting the type provider to only return generated types.</source>
        <target state="translated">Poskytovatel {0} vrátil negenerovaný typ {1} v kontextu sady generovaných typů. Zvažte možnost upravit zprostředkovatele typu tak, aby vracel jenom generované typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryBinaryOperator">
        <source>Arguments to query operators may require parentheses, e.g. 'where (x &gt; y)' or 'groupBy (x.Length / 10)'</source>
        <target state="translated">Argumenty operátorů dotazu můžou vyžadovat použití závorek, třeba where (x &gt; y) nebo groupBy (x.Length / 10).</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoSetOfHole">
        <source>A quotation may not involve an assignment to or taking the address of a captured local variable</source>
        <target state="translated">Citace nemůže zahrnovat přiřazení k adrese zachycené lokální proměnné nebo její přebírání.</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloads1">
        <source>+ 1 overload</source>
        <target state="translated">+ 1 přetížení</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloadsN">
        <source>+ {0} overloads</source>
        <target state="translated">+ {0} přetížení</target>
        <note />
      </trans-unit>
      <trans-unit id="erasedTo">
        <source>Erased to</source>
        <target state="translated">Vymazáno</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnfinishedExpression">
        <source>Unexpected token '{0}' or incomplete expression</source>
        <target state="translated">Neočekávaný token {0} nebo neúplný výraz</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributeOnIncompleteCode">
        <source>Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.</source>
        <target state="translated">Nedá se najít cíl kódu pro tento atribut. Možná je to proto, že kód za tímto atributem je neúplný.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeNameCannotBeEmpty">
        <source>Type name cannot be empty.</source>
        <target state="translated">Název typu nemůže být prázdný.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemReadingAssembly">
        <source>Problem reading assembly '{0}': {1}</source>
        <target state="translated">Problém při čtení sestavení {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTPFieldMustBeLiteral">
        <source>Invalid provided field. Provided fields of erased provided types must be literals.</source>
        <target state="translated">Neplatné poskytnuté pole. Poskytnutá pole vymazaných poskytnutých typů musí být literálová.</target>
        <note />
      </trans-unit>
      <trans-unit id="loadingDescription">
        <source>(loading description...)</source>
        <target state="translated">(Načítá se popis...)</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionUnavailable">
        <source>(description unavailable...)</source>
        <target state="translated">(popis není dostupný...)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTyparMultipleClassConstraints">
        <source>A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.</source>
        <target state="translated">Proměnná typu je omezená více různými typy tříd. Proměnná typu může mít jenom jedno omezení třídy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMatchMayNotBeUsedWithQuery">
        <source>'match' expressions may not be used in queries</source>
        <target state="translated">Výrazy match se nedají v dotazech použít.</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonTripleArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 3 arguments</source>
        <target state="translated">Člen operátoru vpony {0} má počáteční argumenty v počtu {1}. Očekávala se řazená kolekce členů se třemi argumenty.</target>
        <note />
      </trans-unit>
      <trans-unit id="cannotResolveNullableOperators">
        <source>The operator '{0}' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Operátor {0} se nedá přeložit. Zvažte možnost otevření modulu Microsoft.FSharp.Linq.NullableOperators.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorRequiresIn">
        <source>'{0}' must be followed by 'in'. Usage: {1}.</source>
        <target state="translated">Po {0} musí následovat in. Použití: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalMemberVarInObjectImplementation">
        <source>Neither 'member val' nor 'override val' definitions are permitted in object expressions.</source>
        <target state="translated">U objektových výrazů se nepovolují definice member val ani override val.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyCopyAndUpdateRecordInvalid">
        <source>Copy-and-update record expressions must include at least one field.</source>
        <target state="translated">Výrazy záznamu zkopírování a aktualizace musí zahrnovat aspoň jedno pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnderscoreInvalidFieldName">
        <source>'_' cannot be used as field name</source>
        <target state="translated">Podtržítko se pro název pole použít nedá.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGeneratedTypesShouldBeInternalOrPrivate">
        <source>The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'.</source>
        <target state="translated">Poskytnuté typy generované tímto použitím zprostředkovatele typu možná nepůjde použít v jiných sestaveních F# a měly by se označit jako interní nebo privátní. Zvažte použití notace type internal TypeName = ... nebo type private TypeName = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterAndSetterHaveSamePropertyType">
        <source>A property's getter and setter must have the same type. Property '{0}' has getter of type '{1}' but setter of type '{2}'.</source>
        <target state="translated">Metody getter a setter vlastnosti musí být stejného typu. Vlastnost {0} má metodu get typu {1}, ale metodu set typu {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRuntimeSuppliedMethodCannotBeUsedInUserCode">
        <source>Array method '{0}' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.</source>
        <target state="translated">Metodu pole {0} poskytuje modul runtime a nedá se v kódu použít přímo. U operací s prvky polí zvažte možnost použití skupiny funkcí GetArray/SetArray z modulu LanguagePrimitives.IntrinsicFunctions.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName">
        <source>Union case/exception '{0}' does not have field named '{1}'.</source>
        <target state="translated">Výjimka nebo případ typu union {0} nemá pole s názvem {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseFieldCannotBeUsedMoreThanOnce">
        <source>Union case/exception field '{0}' cannot be used more than once.</source>
        <target state="translated">Pole {0} výjimky nebo případu typu union se nedá použít víc než jednou.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameIsUsedModeThanOnce">
        <source>Named field '{0}' is used more than once.</source>
        <target state="translated">Pojmenované pole {0} se používá víc než jednou.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameConflictsWithGeneratedNameForAnonymousField">
        <source>Named field '{0}' conflicts with autogenerated name for anonymous field.</source>
        <target state="translated">Pojmenované pole {0} koliduje s automaticky generovaným názvem anonymního pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConstantExpressionOverflow">
        <source>This literal expression or attribute argument results in an arithmetic overflow.</source>
        <target state="translated">Tento literálový výraz nebo argument atributu má za následek přetečení aritmetické operace.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalStructTypeForConstantExpression">
        <source>This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.</source>
        <target state="translated">Toto není platný literálový výraz. Atribut [&lt;Literal&gt;] se bude ignorovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscSystemRuntimeInteropServicesIsRequired">
        <source>System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.</source>
        <target state="translated">Aby bylo možné použít třídy UnknownWrapper\DispatchWrapper, vyžaduje se sestavení System.Runtime.InteropServices.</target>
        <note />
      </trans-unit>
      <trans-unit id="abImplicitHeapAllocation">
        <source>The mutable local '{0}' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.</source>
        <target state="translated">Místní proměnná {0} se implicitně přiděluje jako odkazovaná buňka, protože ji zachytilo zavření. Toto upozornění slouží jenom k informativním účelům a ukazuje, kde k implicitním přidělením dochází.</target>
        <note />
      </trans-unit>
      <trans-unit id="estApplyStaticArgumentsForMethodNotImplemented">
        <source>A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid</source>
        <target state="translated">Zprostředkovatel typu implementuje metodu GetStaticParametersForMethod, ale metoda ApplyStaticArgumentsForMethod se neimplementovala nebo je neplatná.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToMethod">
        <source>An error occured applying the static arguments to a provided method</source>
        <target state="translated">Při použití statických argumentů u poskytnuté metody došlo k chybě.</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexUnexpectedChar">
        <source>Unexpected character '{0}' in preprocessor expression</source>
        <target state="translated">Neočekávaný znak {0} ve výrazu preprocesoru</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsUnexpectedToken">
        <source>Unexpected token '{0}' in preprocessor expression</source>
        <target state="translated">Neočekávaný token {0} ve výrazu preprocesoru</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsIncompleteExpression">
        <source>Incomplete preprocessor expression</source>
        <target state="translated">Neúplný výraz preprocesoru</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsMissingToken">
        <source>Missing token '{0}' in preprocessor expression</source>
        <target state="translated">Chybějící token {0} ve výrazu preprocesoru</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleMissingDefinition">
        <source>An error occurred while reading the F# metadata node at position {0} in table '{1}' of assembly '{2}'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.</source>
        <target state="translated">Nastala chyba při čtení uzlu metadat F# na pozici {0} v tabulce {1} sestavení {2}. Tento uzel nemá žádnou odpovídající deklaraci. Předejte toto upozornění dál. Sestavení F#, které používáte, může být potřeba znovu kompilovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScope">
        <source>Type inference caused the type variable {0} to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.</source>
        <target state="translated">Odvození typu proměnné způsobilo, že se proměnná typu {0} dostala mimo svůj rozsah. Zvažte přidání explicitní deklarace parametru typu nebo upravení kódu, aby byl méně obecný.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScopeAnon">
        <source>Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.</source>
        <target state="translated">Odvození typu proměnné způsobilo, že se proměnná typu odvození dostala mimo svůj rozsah. Zvažte přidání anotací typu, aby byl kód méně obecný.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkRaiseFamilyFunctionArgumentCount">
        <source>Redundant arguments are being ignored in function '{0}'. Expected {1} but got {2} arguments.</source>
        <target state="translated">Redundantní argumenty se ve funkci {0} ignorují. Očekávalo se tolik argumentů: {1}, ale bylo jich {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkLowercaseLiteralBindingInPattern">
        <source>Lowercase literal '{0}' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.</source>
        <target state="translated">Literál malými písmeny {0} je zastíněný novým vzorem se stejným názvem. Jako pojmenované vzory se dají používat literály velkými písmeny, kterým předchází modul.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralDoesNotTakeArguments">
        <source>This literal pattern does not take arguments</source>
        <target state="translated">V tomto vzoru literálu se nedají zadat argumenty.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalInAugmentation">
        <source>Constructors are not permitted as extension members - they must be defined as part of the original definition of the type</source>
        <target state="translated">Konstruktory nejsou povolené jako členy rozšíření – musí být definované v rámci původní definice typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidResponseFile">
        <source>Invalid response file '{0}' ( '{1}' )</source>
        <target state="translated">Neplatný soubor odpovědi {0} ({1})</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNotFound">
        <source>Response file '{0}' not found in '{1}'</source>
        <target state="translated">Soubor odpovědi {0} se nenašel v {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNameInvalid">
        <source>Response file name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">Název souboru odpovědi {0} je prázdný, obsahuje neplatné znaky, má jednotku zadanou bez absolutní cesty nebo je moc dlouhý.</target>
        <note />
      </trans-unit>
      <trans-unit id="fsharpCoreNotFoundToBeCopied">
        <source>Cannot find FSharp.Core.dll in compiler's directory</source>
        <target state="translated">Nepovedlo se najít FSharp.Core.dll v adresáři kompilátoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleStructMismatch">
        <source>One tuple type is a struct tuple, the other is a reference tuple</source>
        <target state="translated">Jeden typ řazené kolekce členů je struktura, ten druhý je řazená kolekce členů odkazu.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMissingStaticArgumentsToMethod">
        <source>This provided method requires static parameters</source>
        <target state="translated">Tato zadaná metoda vyžaduje statické parametry.</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcast">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'.</source>
        <target state="translated">Převod z {0} na {1} je přetypování nahoru bezpečné v době kompilace, ne přetypování dolů. Zvažte použití parametru upcast namísto downcast.</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcastOperator">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.</source>
        <target state="translated">Převod z {0} na {1} je přetypování nahoru bezpečné v době kompilace, ne přetypování dolů. Zvažte použití operátoru :&gt; (upcast) namísto :?&gt; (downcast).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecImplied">
        <source>The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored</source>
        <target state="translated">Klíčové slovo rec je v tomto modulu odvozené od vnější deklarace rec a ignoruje se.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenFirstInMutRec">
        <source>In a recursive declaration group, 'open' declarations must come first in each module</source>
        <target state="translated">Ve skupině rekurzivních deklarací musí být deklarace open v každém modulu první.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbrevFirstInMutRec">
        <source>In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations</source>
        <target state="translated">Ve skupině rekurzivních deklarací se musí zkratky modulu nacházet za deklaracemi open a před ostatními deklaracemi.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedMutRecDecl">
        <source>This declaration is not supported in recursive declaration groups</source>
        <target state="translated">Tato deklarace se ve skupinách rekurzivních deklarací nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidUseOfRec">
        <source>Invalid use of 'rec' keyword</source>
        <target state="translated">Neplatné použití klíčového slova rec</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructUnionMultiCaseDistinctFields">
        <source>If a union type has more than one case and is a struct, then all fields within the union type must be given unique names.</source>
        <target state="translated">Pokud je typ sjednocení struktura a obsahuje více než jeden případ, všem polím v tomto typu sjednocení se musí přiřadit jedinečný název.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerMemberNameIsOverriden">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">Atribut CallerMemberNameAttribute použitý pro parametr {0} nebude mít žádný účinek. Přepisuje ho atribut CallerFilePathAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFixedNotAllowed">
        <source>Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'</source>
        <target state="translated">Neplatné použití fixed. fixed se dá použít jenom v deklaraci ve tvaru use x = fixed expr, kde výraz je pole, adresa pole nebo adresa prvku pole nebo řetězce.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindOffsetToStringData">
        <source>Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression.</source>
        <target state="translated">Při sestavování výrazu fixed se mezi odkazy nepovedlo najít metodu System.Runtime.CompilerServices.OffsetToStringData.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefReturnOfLocal">
        <source>The address of the variable '{0}' cannot be used at this point. A method or function may not return the address of this local value.</source>
        <target state="translated">Adresa proměnné {0} se na tomto místě nedá použít. Metoda nebo funkce možná nebude vracet adresu této místní hodnoty.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedActivePattern">
        <source>{0} is an active pattern and cannot be treated as a discriminated union case with named fields.</source>
        <target state="translated">{0} je aktivní vzorek a není možné s ním zacházet jako s rozlišeným případem typu union s pojmenovanými poli.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultParameterValueNotAppropriateForArgument">
        <source>The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'.</source>
        <target state="translated">Výchozí hodnota má jiný typ než argument. Atribut DefaultParameterValue a případné volitelné atributy se budou ignorovat. Poznámka: null je potřeba anotovat správným typem, např. DefaultParameterValue(null:obj).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGlobalsSystemTypeNotFound">
        <source>The system type '{0}' was required but no referenced system DLL contained this type</source>
        <target state="translated">Požadoval se systémový typ {0}, ale žádná odkazovaná systémová knihovna DLL tento typ neobsahovala.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberHasMultiplePossibleDispatchSlots">
        <source>The member '{0}' matches multiple overloads of the same method.\nPlease restrict it to one of the following:{1}.</source>
        <target state="translated">Člen {0} odpovídá více přetížením stejné metody.\nOmezte ho prosím na jedno z následujících: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="methodIsNotStatic">
        <source>Method or object constructor '{0}' is not static</source>
        <target state="translated">Metoda nebo konstruktor objektu {0} nejsou statické.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolEqualsInsteadOfIn">
        <source>Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?</source>
        <target state="translated">Neočekávaný symbol = ve výrazu. Neměli jste v úmyslu použít místo toho for x in y ... z do?</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAbstract">
        <source>Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</source>
        <target state="translated">Označuje metodu, která buď nemá implementaci v typu, ve kterém je deklarovaná, nebo která je virtuální a má výchozí implementaci.</target>
        <note />
      </trans-unit>
      <trans-unit id="keyworkDescriptionAnd">
        <source>Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</source>
        <target state="translated">Používá se ve vzájemně rekurzivních vazbách, v deklaracích vlastností a s několika omezeními u generických parametrů.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAs">
        <source>Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</source>
        <target state="translated">Slouží k pojmenování objektu aktuální třídy. Používá se také k pojmenování celého vzoru v rámci porovnávání vzorů.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAssert">
        <source>Used to verify code during debugging.</source>
        <target state="translated">Slouží k ověření kódu během ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBase">
        <source>Used as the name of the base class object.</source>
        <target state="translated">Používá se jako název objektu základní třídy.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBegin">
        <source>In verbose syntax, indicates the start of a code block.</source>
        <target state="translated">V podrobné syntaxi označuje začátek bloku kódu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionClass">
        <source>In verbose syntax, indicates the start of a class definition.</source>
        <target state="translated">V podrobné syntaxi označuje začátek definice třídy.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDefault">
        <source>Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</source>
        <target state="translated">Označuje implementaci abstraktní metody; společně s deklarací abstraktní metody se používá k vytvoření virtuální metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDelegate">
        <source>Used to declare a delegate.</source>
        <target state="translated">Slouží k deklaraci delegáta.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDo">
        <source>Used in looping constructs or to execute imperative code.</source>
        <target state="translated">Používá se v konstruktorech cyklů nebo k provádění imperativního kódu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDone">
        <source>In verbose syntax, indicates the end of a block of code in a looping expression.</source>
        <target state="translated">V podrobné syntaxi označuje konec bloku kódu ve výrazu cyklu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDowncast">
        <source>Used to convert to a type that is lower in the inheritance chain.</source>
        <target state="translated">Slouží k převodu na typ, který je na nižší pozici v řetězu dědičnosti.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDownto">
        <source>In a for expression, used when counting in reverse.</source>
        <target state="translated">Slouží k počítání pozpátku ve výrazu for.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElif">
        <source>Used in conditional branching. A short form of else if.</source>
        <target state="translated">Používá se v podmíněném větvení. Krátká forma výrazu else if.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElse">
        <source>Used in conditional branching.</source>
        <target state="translated">Používá se v podmíněném větvení.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionEnd">
        <source>In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</source>
        <target state="translated">Označuje konec sekce definic členů v definicích typů a rozšířeních typů. V podrobné syntaxi se používá k určení konce bloku kódu, který začíná klíčovým slovem begin.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionException">
        <source>Used to declare an exception type.</source>
        <target state="translated">Slouží k deklaraci typu výjimky.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionExtern">
        <source>Indicates that a declared program element is defined in another binary or assembly.</source>
        <target state="translated">Označuje, že deklarovaný element programu je definovaný v jiném binárním souboru nebo sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTrueFalse">
        <source>Used as a Boolean literal.</source>
        <target state="translated">Používá se jako logický literál.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFinally">
        <source>Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</source>
        <target state="translated">Používá se společně s try k uvození bloku kódu, který se provede bez ohledu na to, jestli dojde k výjimce.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFor">
        <source>Used in looping constructs.</source>
        <target state="translated">Používá se v konstruktorech cyklů.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFun">
        <source>Used in lambda expressions, also known as anonymous functions.</source>
        <target state="translated">Používá se ve výrazech lambda, známých také pod označením anonymní funkce.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFunction">
        <source>Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</source>
        <target state="translated">Používá se jako kratší alternativa klíčového slova fun a jako porovnávací výraz ve výrazu lambda s porovnáváním vzoru u jednoho argumentu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionGlobal">
        <source>Used to reference the top-level .NET namespace.</source>
        <target state="translated">Slouží k odkazu na obor názvů .NET na nejvyšší úrovni.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIf">
        <source>Used in conditional branching constructs.</source>
        <target state="translated">Používá se v konstruktorech podmíněného větvení.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIn">
        <source>Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</source>
        <target state="translated">Používá se ve výrazech pořadí a v podrobné syntaxi k oddělení výrazů od vazeb.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInherit">
        <source>Used to specify a base class or base interface.</source>
        <target state="translated">Slouží k určení základní třídy nebo základního rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInline">
        <source>Used to indicate a function that should be integrated directly into the caller's code.</source>
        <target state="translated">Slouží k označení funkce, která se má integrovat přímo do kódu volajícího.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInterface">
        <source>Used to declare and implement interfaces.</source>
        <target state="translated">Slouží k deklaraci a implementaci rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInternal">
        <source>Used to specify that a member is visible inside an assembly but not outside it.</source>
        <target state="translated">Umožňuje určit, že je člen viditelný uvnitř sestavení, ale ne mimo toto sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLazy">
        <source>Used to specify a computation that is to be performed only when a result is needed.</source>
        <target state="translated">Slouží k určení výpočtu, který se má provést jen v případě, kdy je zapotřebí výsledek.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLet">
        <source>Used to associate, or bind, a name to a value or function.</source>
        <target state="translated">Slouží k přidružení (neboli svázání) názvu k hodnotě nebo funkci.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLetBang">
        <source>Used in asynchronous workflows to bind a name to the result of an asynchronous computation, or, in other computation expressions, used to bind a name to a result, which is of the computation type.</source>
        <target state="translated">Slouží v asynchronních pracovních postupech k vytvoření vazby názvu s výsledkem asynchronního výpočtu. V jiných výrazech výpočtu se používá k vytvoření vazby názvu s výsledkem, který je výpočetního typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatch">
        <source>Used to branch by comparing a value to a pattern.</source>
        <target state="translated">Používá se k větvení porovnáním hodnoty s určitým vzorem.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMember">
        <source>Used to declare a property or method in an object type.</source>
        <target state="translated">Slouží k deklaraci vlastnosti nebo metody v objektovém typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionModule">
        <source>Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</source>
        <target state="translated">Slouží k přidružení názvu ke skupině souvisejících typů, hodnot a funkcí a jeho logickému oddělení od jiného kódu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMutable">
        <source>Used to declare a variable, that is, a value that can be changed.</source>
        <target state="translated">Slouží k deklaraci proměnné, což je hodnota, která se může měnit.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNamespace">
        <source>Used to associate a name with a group of related types and modules, to logically separate it from other code.</source>
        <target state="translated">Slouží k přidružení názvu ke skupině souvisejících typů a modulů a jeho logickému oddělení od jiného kódu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNew">
        <source>Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.</source>
        <target state="translated">Slouží k deklaraci, definici nebo vyvolání konstruktoru, který vytvoří nebo dokáže vytvořit objekt. V omezeních obecných parametrů označuje, že nějaký typ musí mít určitý konstruktor.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNot">
        <source>Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</source>
        <target state="translated">Ve skutečnosti nejde o klíčové slovo. Kombinace not struct se ale používá jako omezení obecného parametru.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNull">
        <source>Indicates the absence of an object. Also used in generic parameter constraints.</source>
        <target state="translated">Označuje absenci objektu. Používá se také v omezeních obecných parametrů.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOf">
        <source>Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</source>
        <target state="translated">Slouží k označení typu kategorií hodnot v rozlišených sjednoceních a v deklaracích delegování a výjimek.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOpen">
        <source>Used to make the contents of a namespace or module available without qualification.</source>
        <target state="translated">Slouží ke zpřístupnění obsahu oboru názvů nebo modulu bez kvalifikace.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOr">
        <source>Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.</source>
        <target state="translated">Používá se v logických podmínkách jako logický operátor or. Ekvivalent ||. Používá se také v omezeních členů.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOverride">
        <source>Used to implement a version of an abstract or virtual method that differs from the base version.</source>
        <target state="translated">Slouží k implementaci verze abstraktní nebo virtuální metody, která se odlišuje od základní verze.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPrivate">
        <source>Restricts access to a member to code in the same type or module.</source>
        <target state="translated">Omezuje přístup k členovi na kód ve stejném typu nebo modulu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPublic">
        <source>Allows access to a member from outside the type.</source>
        <target state="translated">Umožňuje přístup ke členovi zvnějška typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRec">
        <source>Used to indicate that a function is recursive.</source>
        <target state="translated">Slouží k označení toho, že funkce je rekurzivní.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturn">
        <source>Used to indicate a value to provide as the result of a computation expression.</source>
        <target state="translated">Slouží k označení hodnoty, která vznikne jako výsledek výrazu výpočtu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturnBang">
        <source>Used to indicate a computation expression that, when evaluated, provides the result of the containing computation expression.</source>
        <target state="translated">Slouží k označení výrazu výpočtu, který po vyhodnocení poskytne výsledek obsahujícího výrazu výpočtu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionSelect">
        <source>Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</source>
        <target state="translated">Používá se ve výrazech dotazu k určení, která pole nebo sloupce se mají extrahovat. Toto klíčové slovo je kontextové, což znamená, že se ve skutečnosti nejedná o rezervované slovo a jako klíčové slovo funguje jen v příslušném kontextu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStatic">
        <source>Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</source>
        <target state="translated">Slouží k označení metody nebo vlastnosti, kterou lze volat bez instance typu, nebo člena hodnoty, který se sdílí mezi všemi instancemi typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStruct">
        <source>Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions.</source>
        <target state="translated">Slouží k deklaraci typu struktury. Používá se také v omezeních obecných parametrů. V definicích modulů se používá kvůli kompatibilitě s OCaml.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionThen">
        <source>Used in conditional expressions. Also used to perform side effects after object construction.</source>
        <target state="translated">Používá se podmíněných výrazech. Slouží rovněž k provedení vedlejších efektů po konstrukci objektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTo">
        <source>Used in for loops to indicate a range.</source>
        <target state="translated">Slouží k označení rozsahu v cyklech.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTry">
        <source>Used to introduce a block of code that might generate an exception. Used together with with or finally.</source>
        <target state="translated">Slouží k uvození bloku kódu, který může vygenerovat výjimku. Používá se společně s with nebo finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionType">
        <source>Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</source>
        <target state="translated">Slouží k deklaraci třídy, záznamu, struktury, rozlišeného sjednocení, výčtového typu, měrné jednotky nebo zkratky typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUpcast">
        <source>Used to convert to a type that is higher in the inheritance chain.</source>
        <target state="translated">Slouží k převodu na typ, který je na vyšší pozici v řetězu dědičnosti.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUse">
        <source>Used instead of let for values that require Dispose to be called to free resources.</source>
        <target state="translated">Používá se místo výrazu let u hodnot, které k uvolnění prostředků vyžadují volání funkce Dispose.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUseBang">
        <source>Used instead of let! in asynchronous workflows and other computation expressions for values that require Dispose to be called to free resources.</source>
        <target state="translated">Používá se místo výrazu let! v asynchronních pracovních postupech a jiných výrazech výpočtu pro hodnoty, které k uvolnění prostředků vyžadují volání funkce Dispose.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVal">
        <source>Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</source>
        <target state="translated">Slouží k označení hodnoty v signatuře nebo v určitých situacích k deklarování člena v daném typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVoid">
        <source>Indicates the .NET void type. Used when interoperating with other .NET languages.</source>
        <target state="translated">Označuje prázdný typ .NET. Používá se při vzájemné spolupráci s jinými jazyky .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhen">
        <source>Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.</source>
        <target state="translated">Používá se pro logické podmínky (klauzule when) u porovnávání vzorů a k uvození klauzule omezení parametru obecného typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhile">
        <source>Introduces a looping construct.</source>
        <target state="translated">Uvozuje konstruktor cyklu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWith">
        <source>Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</source>
        <target state="translated">Používá se společně s klíčovým slovem match ve výrazech porovnávání vzorů. Ve výrazech objektů, výrazech kopírování záznamů a rozšířeních typů slouží také k uvození definice člena a obslužných rutin výjimek.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYield">
        <source>Used in a sequence expression to produce a value for a sequence.</source>
        <target state="translated">Používá se ve výrazu pořadí k vytvoření hodnoty pořadí.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYieldBang">
        <source>Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</source>
        <target state="translated">Používá se ve výrazu výpočtu k připojení výsledku daného výpočetního výrazu ke kolekci výsledků obsahujícího výrazu výpočtu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRightArrow">
        <source>In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions</source>
        <target state="translated">Odděluje argumenty a návratové hodnoty v typech funkcí. Nabývá výrazu (ve výrazech pořadí); ekvivalent klíčového slova yield. Používá se v porovnávacích výrazech.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLeftArrow">
        <source>Assigns a value to a variable.</source>
        <target state="translated">Přiřadí hodnotu k proměnné.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionCast">
        <source>Converts a type to type that is higher in the hierarchy.</source>
        <target state="translated">Převede daný typ na typ, který je výše v hierarchii.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDynamicCast">
        <source>Converts a type to a type that is lower in the hierarchy.</source>
        <target state="translated">Převede daný typ na typ, který je níže v hierarchii.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTypedQuotation">
        <source>Delimits a typed code quotation.</source>
        <target state="translated">Odděluje citaci typového kódu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUntypedQuotation">
        <source>Delimits a untyped code quotation.</source>
        <target state="translated">Odděluje citaci netypového kódu</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundDuringDynamicCodeGen">
        <source>{0} '{1}' not found in assembly '{2}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{0} {1} – nenašlo se v sestavení {2}. Možnou příčinou může být nekompatibilita verzí. Možná budete muset vytvořit explicitní odkaz na správnou verzi tohoto sestavení, abyste zajistili, že ji budou používat všechny odkazované součásti.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundInTypeDuringDynamicCodeGen">
        <source>{0} '{1}' not found in type '{2}' from assembly '{3}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{0} {1} – nenašlo se v typu {2} ze sestavení {3}. Možnou příčinou může být nekompatibilita verzí. Možná budete muset vytvořit explicitní odkaz na správnou verzi tohoto sestavení, abyste zajistili, že ji budou používat všechny odkazované součásti.</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionWordIs">
        <source>is</source>
        <target state="translated">je</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunction">
        <source>This value is not a function and cannot be applied.</source>
        <target state="translated">Tato hodnota není funkcí a nedá se použít.</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexerWithName">
        <source>This value is not a function and cannot be applied. Did you intend to access the indexer via {0}.[index] instead?</source>
        <target state="translated">Tato hodnota není funkcí a nedá se použít. Nechtěli jste místo toho získat k indexeru přístup přes {0}.[index]?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexer">
        <source>This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?</source>
        <target state="translated">Tento výraz není funkcí a nedá se použít. Nechtěli jste místo toho získat k indexeru přístup přes expr.[index]?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeDeclaration">
        <source>This value is not a function and cannot be applied. Did you forget to terminate a declaration?</source>
        <target state="translated">Tato hodnota není funkce a nedá se použít. Nezapomněli jste ukončit deklaraci?</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentsInSigAndImplMismatch">
        <source>The argument names in the signature '{0}' and implementation '{1}' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling.</source>
        <target state="translated">Názvy argumentů v signatuře {0} a implementaci {1} si neodpovídají. Použije se název argumentu ze souboru signatury. To může způsobit problémy při ladění nebo profilování.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleUnexpectedNonZero">
        <source>An error occurred while reading the F# metadata of assembly '{0}'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct.</source>
        <target state="translated">Při čtení metadat jazyka F# sestavení {0} došlo k chybě. Byl použit rezervovaný konstruktor. Je možné, že budete muset upgradovat kompilátor jazyka F# nebo použít dřívější verzi sestavení, ve které se nevyužívá konkrétní konstruktor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleMemberNotNormallyUsed">
        <source>This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.</source>
        <target state="translated">Tato metoda nebo vlastnost se obvykle z kódu F# nepoužívá, použijte místo toho pro dekonstrukci explicitní vzor řazené kolekce členů.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'.</source>
        <target state="translated">Tento výraz vrátí hodnotu typu {0}, ale implicitně se zahodí. Zvažte vytvoření vazby mezi výsledkem a názvem pomocí klíčového slova let, např. let výsledek = výraz. Pokud jste chtěli výraz použít jako hodnotu v sekvenci, použijte explicitní klíčové slovo yield.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedSequenceInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'.</source>
        <target state="translated">Tento výraz vrátí hodnotu typu {0}, ale implicitně se zahodí. Zvažte vytvoření vazby mezi výsledkem a názvem pomocí klíčového slova let, např. let výsledek = výraz. Pokud jste chtěli výraz použít jako hodnotu v sekvenci, použijte explicitní klíčové slovo yield!.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatchBang">
        <source>Used in computation expressions to pattern match directly over the result of another computation expression.</source>
        <target state="new">Used in computation expressions to pattern match directly over the result of another computation expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilreadFileChanged">
        <source>The file '{0}' changed on disk unexpectedly, please reload.</source>
        <target state="translated">Soubor {0} se na disku neočekávaně změnil, opakujte prosím načtení.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>