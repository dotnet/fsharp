<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../FSComp.resx">
    <body>
      <trans-unit id="chkFeatureNotLanguageSupported">
        <source>Feature '{0}' is not available in F# {1}. Please use language version {2} or greater.</source>
        <target state="translated">'{0}' 기능은 F# {1}에서 사용할 수 없습니다. {2} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFeatureNotRuntimeSupported">
        <source>Feature '{0}' is not supported by target runtime.</source>
        <target state="translated">'{0}' 기능은 대상 런타임에서 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFeatureNotSupportedInLibrary">
        <source>Feature '{0}' requires the F# library for language version {1} or greater.</source>
        <target state="translated">언어 버전 {1} 이상에서 '{0}' 기능을 사용하려면 F# 라이브러리가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csAvailableOverloads">
        <source>Available overloads:\n{0}</source>
        <target state="translated">사용 가능한 오버로드:\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructOrReferenceConstraint">
        <source>A generic construct requires that a generic type parameter be known as a struct or reference type. Consider adding a type annotation.</source>
        <target state="translated">제네릭 구문을 사용하려면 구조체 또는 참조 형식의 제네릭 형식 매개 변수가 필요합니다. 형식 주석을 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundArgumentsPrefixPlural">
        <source>Known types of arguments: {0}</source>
        <target state="translated">알려진 인수 형식: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundArgumentsPrefixSingular">
        <source>Known type of argument: {0}</source>
        <target state="translated">알려진 인수 형식: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundReturnType">
        <source>Known return type: {0}</source>
        <target state="translated">알려진 반환 형식: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundTypeParametersPrefixPlural">
        <source>Known type parameters: {0}</source>
        <target state="translated">알려진 형식 매개 변수: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundTypeParametersPrefixSingular">
        <source>Known type parameter: {0}</source>
        <target state="translated">알려진 형식 매개 변수: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csOverloadCandidateIndexedArgumentTypeMismatch">
        <source>Argument at index {0} doesn't match</source>
        <target state="translated">인덱스 {0}의 인수가 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csOverloadCandidateNamedArgumentTypeMismatch">
        <source>Argument '{0}' doesn't match</source>
        <target state="translated">'{0}' 인수가 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasDesignerAssemblyDependency">
        <source>The type provider designer assembly '{0}' could not be loaded from folder '{1}' because a dependency was missing or could not loaded. All dependencies of the type provider designer assembly must be located in the same folder as that assembly. The exception reported was: {2} - {3}</source>
        <target state="translated">종속성이 없거나 로드되지 않았으므로 '{0}' 형식 공급자 디자이너 어셈블리를 '{1}' 폴더에서 로드할 수 없습니다. 형식 공급자 디자이너 어셈블리의 모든 종속성은 해당 어셈블리와 동일한 폴더에 있어야 합니다. 보고된 예외: {2} - {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasDesignerAssemblyException">
        <source>The type provider designer assembly '{0}' could not be loaded from folder '{1}'. The exception reported was: {2} - {3}</source>
        <target state="translated">'{0}' 형식 공급자 디자이너 어셈블리를 '{1}' 폴더에서 로드할 수 없습니다. 보고된 예외: {2} - {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssemblyNoPath">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded or doesn't exist. The exception reported was: {2} - {3}</source>
        <target state="translated">'{0}' 어셈블리 특성이 로드할 수 없거나 존재하지 않는 디자이너 어셈블리'{1}'을(를) 참조합니다. 보고된 예외: {2} - {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="featureAndBang">
        <source>applicative computation expressions</source>
        <target state="translated">적용 가능한 계산 식</target>
        <note />
      </trans-unit>
      <trans-unit id="featureDefaultInterfaceMemberConsumption">
        <source>default interface member consumption</source>
        <target state="translated">기본 인터페이스 멤버 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="featureDotlessFloat32Literal">
        <source>dotless float32 literal</source>
        <target state="translated">점이 없는 float32 리터럴</target>
        <note />
      </trans-unit>
      <trans-unit id="featureExpandedMeasurables">
        <source>more types support units of measure</source>
        <target state="new">more types support units of measure</target>
        <note />
      </trans-unit>
      <trans-unit id="featureFixedIndexSlice3d4d">
        <source>fixed-index slice 3d/4d</source>
        <target state="translated">고정 인덱스 슬라이스 3d/4d</target>
        <note />
      </trans-unit>
      <trans-unit id="featureFromEndSlicing">
        <source>from-end slicing</source>
        <target state="translated">끝에서부터 조각화</target>
        <note />
      </trans-unit>
      <trans-unit id="featureImplicitYield">
        <source>implicit yield</source>
        <target state="translated">암시적 yield</target>
        <note />
      </trans-unit>
      <trans-unit id="featureInterfacesWithMultipleGenericInstantiation">
        <source>interfaces with multiple generic instantiation</source>
        <target state="translated">여러 제네릭 인스턴스화가 포함된 인터페이스</target>
        <note />
      </trans-unit>
      <trans-unit id="featureNameOf">
        <source>nameof</source>
        <target state="translated">nameof</target>
        <note />
      </trans-unit>
      <trans-unit id="featureNullableOptionalInterop">
        <source>nullable optional interop</source>
        <target state="translated">nullable 선택적 interop</target>
        <note />
      </trans-unit>
      <trans-unit id="featureOpenTypeDeclaration">
        <source>open type declaration</source>
        <target state="translated">개방형 형식 선언</target>
        <note />
      </trans-unit>
      <trans-unit id="featureOverloadsForCustomOperations">
        <source>overloads for custom operations</source>
        <target state="translated">사용자 지정 작업의 오버로드</target>
        <note />
      </trans-unit>
      <trans-unit id="featurePackageManagement">
        <source>package management</source>
        <target state="translated">패키지 관리</target>
        <note />
      </trans-unit>
      <trans-unit id="featureRelaxWhitespace">
        <source>whitespace relexation</source>
        <target state="translated">공백 완화</target>
        <note />
      </trans-unit>
      <trans-unit id="featureSingleUnderscorePattern">
        <source>single underscore pattern</source>
        <target state="translated">단일 밑줄 패턴</target>
        <note />
      </trans-unit>
      <trans-unit id="featureStringInterpolation">
        <source>string interpolation</source>
        <target state="translated">문자열 보간</target>
        <note />
      </trans-unit>
      <trans-unit id="featureWildCardInForLoop">
        <source>wild card in for loop</source>
        <target state="translated">for 루프의 와일드카드</target>
        <note />
      </trans-unit>
      <trans-unit id="featureWitnessPassing">
        <source>witness passing for trait constraints in F# quotations</source>
        <target state="translated">F# 인용의 특성 제약 조건에 대한 감시 전달</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated">
        <source>Interpolated strings may not use '%' format specifiers unless each is given an expression, e.g. '%d{{1+1}}'.</source>
        <target state="translated">각 보간 문자열에 식(예: '%d{{1+1}}')이 지정되지 않는 한 '%' 형식 지정자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated2">
        <source>.NET-style format specifiers such as '{{x,3}}' or '{{x:N5}}' may not be mixed with '%' format specifiers.</source>
        <target state="translated">'{{x,3}}' 또는 '{{x:N5}}' 등의 .NET 스타일 형식 지정자를 '%' 형식 지정자와 혼합할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated3">
        <source>The '%P' specifier may not be used explicitly.</source>
        <target state="translated">'%P' 지정자를 명시적으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated4">
        <source>Interpolated strings used as type IFormattable or type FormattableString may not use '%' specifiers, only .NET-style interpolands such as '{{expr}}', '{{expr,3}}' or '{{expr:N5}}' may be used.</source>
        <target state="translated">형식 IFormattable 또는 형식 FormattableString으로 사용된 보간 문자열은 '%' 지정자를 사용할 수 없으며 '{{expr}}', '{{expr,3}}' 또는 '{{expr:N5}}' 등의 .NET 스타일 인터폴란드를 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="formatDashItem">
        <source> - {0}</source>
        <target state="translated"> - {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="fromEndSlicingRequiresVFive">
        <source>From the end slicing with requires language version 5.0, use /langversion:preview.</source>
        <target state="translated">언어 버전 5.0이 필요한 끝 조각화에서는 /langversion:preview를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="fsiInvalidDirective">
        <source>Invalid directive '#{0} {1}'</source>
        <target state="translated">잘못된 지시문 '#{0} {1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionConst">
        <source>Keyword to specify a constant literal as a type parameter argument in Type Providers.</source>
        <target state="translated">상수 리터럴을 형식 공급자의 형식 매개 변수 인수로 지정하는 키워드입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteStringMayNotBeInterpolated">
        <source>a byte string may not be interpolated</source>
        <target state="translated">바이트 문자열을 보간하지 못할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexRBraceInInterpolatedString">
        <source>A '}}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">'}}' 문자는 보간된 문자열에서 이중으로 사용하여 이스케이프해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexSingleQuoteInSingleQuote">
        <source>Invalid interpolated string. Single quote or verbatim string literals may not be used in interpolated expressions in single quote or verbatim strings. Consider using an explicit 'let' binding for the interpolation expression or use a triple quote string as the outer string literal.</source>
        <target state="translated">잘못된 보간 문자열. 작은 따옴표 또는 축자 문자열 리터럴은 작은 따옴표 또는 축자 문자열의 보간 식에 사용할 수 없습니다. 보간 식에 명시적 'let' 바인딩을 사용하거나 삼중 따옴표 문자열을 외부 문자열 리터럴로 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTripleQuoteInTripleQuote">
        <source>Invalid interpolated string. Triple quote string literals may not be used in interpolated expressions. Consider using an explicit 'let' binding for the interpolation expression.</source>
        <target state="translated">잘못된 보간 문자열. 삼중 따옴표 문자열 리터럴은 보간 식에 사용할 수 없습니다. 보간 식에 명시적 'let' 바인딩을 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="nativeResourceFormatError">
        <source>Stream does not begin with a null resource and is not in '.RES' format.</source>
        <target state="translated">스트림은 null 리소스로 시작되지 않으며 '.RES' 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="nativeResourceHeaderMalformed">
        <source>Resource header beginning at offset {0} is malformed.</source>
        <target state="translated">오프셋 {0}에서 시작하는 리소스 헤더의 형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLangVersion">
        <source>Display the allowed values for language version, specify language version such as 'latest' or 'preview'</source>
        <target state="translated">언어 버전의 허용된 값을 표시하고 '최신' 또는 '미리 보기'와 같은 언어 버전을 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSupportedLangVersions">
        <source>Supported language versions:</source>
        <target state="translated">지원되는 언어 버전:</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedLanguageVersion">
        <source>Unrecognized value '{0}' for --langversion use --langversion:? for complete list</source>
        <target state="translated">전체 목록에 대한 --langversion use --langversion:?의 인식할 수 없는 값 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsVersion">
        <source>Display compiler version banner and exit</source>
        <target state="new">Display compiler version banner and exit</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagementRequiresVFive">
        <source>The package management feature requires language version 5.0 use /langversion:preview</source>
        <target state="translated">패키지 관리 기능을 사용하려면 언어 버전 5.0이 필요합니다. /langversion:preview를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyFillInInterpolatedString">
        <source>Invalid interpolated string. This interpolated string expression fill is empty, an expression was expected.</source>
        <target state="translated">보간된 문자열이 잘못되었습니다. 이 보간된 문자열 식 채우기가 비어 있는데, 식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedString">
        <source>Incomplete interpolated string begun at or before here</source>
        <target state="translated">불완전한 보간 문자열이 여기 또는 이전에서 시작되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedStringFill">
        <source>Incomplete interpolated string expression fill begun at or before here</source>
        <target state="translated">불완전한 보간 문자열 식 채우기가 여기 또는 이전에서 시작되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedTripleQuoteString">
        <source>Incomplete interpolated triple-quote string begun at or before here</source>
        <target state="translated">불완전한 보간 삼중 따옴표 문자열이 여기 또는 이전에서 시작되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedVerbatimString">
        <source>Incomplete interpolated verbatim string begun at or before here</source>
        <target state="translated">불완전한 보간 축자 문자열이 여기 또는 이전에서 시작되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEqualsMissingInTypeDefinition">
        <source>Unexpected token in type definition. Expected '=' after the type '{0}'.</source>
        <target state="new">Unexpected token in type definition. Expected '=' after the type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolDot">
        <source>Unexpected symbol '.' in member definition. Expected 'with', '=' or other token.</source>
        <target state="translated">멤버 정의의 예기치 않은 기호 '.'입니다. 'with', '=' 또는 기타 토큰이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecksumAlgorithm">
        <source>Specify algorithm for calculating source file checksum stored in PDB. Supported values are: SHA1 or SHA256 (default)</source>
        <target state="translated">PDB에 저장된 소스 파일 체크섬을 계산하기 위한 알고리즘을 지정합니다. 지원되는 값은 SHA1 또는 SHA256(기본값)입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">{0}' 알고리즘은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="poundiNotSupportedByRegisteredDependencyManagers">
        <source>#i is not supported by the registered PackageManagers</source>
        <target state="translated">#i는 등록된 PackageManagers에서 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAndBangNotSupported">
        <source>This feature is not supported in this version of F#. You may need to add /langversion:preview to use this feature.</source>
        <target state="translated">이 기능은 이 F# 버전에서 지원되지 않습니다. 이 기능을 사용하기 위해 /langversion:preview를 추가해야 할 수도 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameDifferent">
        <source>This is the wrong anonymous record. It should have the fields {0}.</source>
        <target state="translated">잘못된 익명 레코드입니다. {0} 필드가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameSubset">
        <source>This anonymous record does not have enough fields. Add the missing fields {0}.</source>
        <target state="translated">이 익명 레코드에 필드가 부족합니다. 누락된 필드 {0}을(를) 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameSuperset">
        <source>This anonymous record has too many fields. Remove the extra fields {0}.</source>
        <target state="translated">이 익명 레코드에 필드가 너무 많습니다. 추가 필드 {0}을(를) 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdInvalid">
        <source>Invalid Anonymous Record type declaration.</source>
        <target state="translated">익명 레코드 형식 선언이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAugmentationsCannotHaveAttributes">
        <source>Attributes cannot be applied to type extensions.</source>
        <target state="translated">형식 확장에 특성을 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalByrefsInOpenTypeDeclaration">
        <source>Byref types are not allowed in an open type declaration.</source>
        <target state="translated">Byref 형식은 개방형 형식 선언에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterpolationMixedWithPercent">
        <source>Mismatch in interpolated string. Interpolated strings may not use '%' format specifiers unless each is given an expression, e.g. '%d{{1+1}}'</source>
        <target state="translated">보간 문자열의 불일치. 각 보간 문자열에 식(예: '%d{{1+1}}')이 지정되지 않는 한 '%' 형식 지정자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAlignmentInInterpolatedString">
        <source>Invalid alignment in interpolated string</source>
        <target state="translated">보간 문자열의 잘못된 정렬</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBindingNoAndBangs">
        <source>use! may not be combined with and!</source>
        <target state="translated">use!는 and!와 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralFieldAssignmentNoArg">
        <source>Cannot assign a value to another value marked literal</source>
        <target state="translated">리터럴로 표시된 다른 값에 값을 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralFieldAssignmentWithArg">
        <source>Cannot assign '{0}' to a value marked literal</source>
        <target state="translated">리터럴로 표시된 값에 '{0}'을(를) 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireMergeSourcesOrBindN">
        <source>The 'let! ... and! ...' construct may only be used if the computation expression builder defines either a '{0}' method or appropriate 'MergeSource' and 'Bind' methods</source>
        <target state="translated">'let! ... and! ...' 구문은 계산 식 작성기에서 '{0}' 메서드 또는 적절한 'MergeSource' 및 'Bind' 메서드를 정의한 경우에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseInterpolatedString">
        <source>Invalid interpolated string. {0}</source>
        <target state="translated">잘못된 보간 문자열. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceMemberNoMostSpecificImplementation">
        <source>Interface member '{0}' does not have a most specific implementation.</source>
        <target state="translated">인터페이스 멤버 '{0}'에 가장 한정적인 구현이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceWithConcreteAndVariable">
        <source>'{0}' cannot implement the interface '{1}' with the two instantiations '{2}' and '{3}' because they may unify.</source>
        <target state="translated">'{0}'이(가) '{2}' 및 '{3}' 인스턴스화가 포함된 '{1}' 인터페이스를 구현할 수 없습니다. 이 두 인스턴스화가 통합될 수 있기 때문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceWithConcreteAndVariableObjectExpression">
        <source>You cannot implement the interface '{0}' with the two instantiations '{1}' and '{2}' because they may unify.</source>
        <target state="translated">'{1}' 및 '{2}' 인스턴스화가 포함된 '{0}' 인터페이스를 구현할 수 없습니다. 이 두 인스턴스화가 통합될 수 있기 때문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMemberWhenTypeIsKnown">
        <source>The type '{0}' does not define the field, constructor or member '{1}'.</source>
        <target state="translated">'{0}' 형식은 '{1}' 필드, 생성자 또는 멤버를 정의하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespace">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">'{0}' 네임스페이스가 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespaceOrModule">
        <source>The namespace or module '{0}' is not defined.</source>
        <target state="translated">'{0}' 네임스페이스 또는 모듈이 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMember">
        <source>The field, constructor or member '{0}' is not defined.</source>
        <target state="translated">'{0}' 필드, 생성자 또는 멤버가 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueConstructorNamespaceOrType">
        <source>The value, constructor, namespace or type '{0}' is not defined.</source>
        <target state="translated">'{0}' 값, 생성자, 네임스페이스 또는 형식이 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueOfConstructor">
        <source>The value or constructor '{0}' is not defined.</source>
        <target state="translated">'{0}' 값 또는 생성자가 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueNamespaceTypeOrModule">
        <source>The value, namespace, type or module '{0}' is not defined.</source>
        <target state="translated">'{0}' 값, 네임스페이스, 형식 또는 모듈이 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameConstructorModuleOrNamespace">
        <source>The constructor, module or namespace '{0}' is not defined.</source>
        <target state="translated">'{0}' 생성자, 모듈 또는 네임스페이스가 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameType">
        <source>The type '{0}' is not defined.</source>
        <target state="translated">'{0}' 형식이 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeIn">
        <source>The type '{0}' is not defined in '{1}'.</source>
        <target state="translated">{0}' 형식이 '{1}'에 정의되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabelOrNamespace">
        <source>The record label or namespace '{0}' is not defined.</source>
        <target state="translated">레코드 레이블 또는 네임스페이스 '{0}'이(가) 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabel">
        <source>The record label '{0}' is not defined.</source>
        <target state="translated">레코드 레이블 '{0}'이(가) 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameSuggestionsIntro">
        <source>Maybe you want one of the following:</source>
        <target state="translated">다음 중 하나가 필요할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeParameter">
        <source>The type parameter {0} is not defined.</source>
        <target state="translated">형식 매개 변수 '{0}'이(가) 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNamePatternDiscriminator">
        <source>The pattern discriminator '{0}' is not defined.</source>
        <target state="translated">패턴 판별자 '{0}'이(가) 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="replaceWithSuggestion">
        <source>Replace with '{0}'</source>
        <target state="translated">'{0}'(으)로 바꾸기</target>
        <note />
      </trans-unit>
      <trans-unit id="addIndexerDot">
        <source>Add . for indexer access.</source>
        <target state="translated">인덱서 액세스의 경우 . 추가</target>
        <note />
      </trans-unit>
      <trans-unit id="listElementHasWrongType">
        <source>All elements of a list must be of the same type as the first element, which here is '{0}'. This element has type '{1}'.</source>
        <target state="translated">목록 생성자의 모든 요소는 동일한 형식이어야 합니다. 이 식에는 '{0}' 형식이 필요하지만 여기에서는 '{1}' 형식이 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="arrayElementHasWrongType">
        <source>All elements of an array must be of the same type as the first element, which here is '{0}'. This element has type '{1}'.</source>
        <target state="translated">배열 생성자의 모든 요소는 동일한 형식이어야 합니다. 이 식에는 '{0}' 형식이 필요하지만 여기에서는 '{1}' 형식이 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="missingElseBranch">
        <source>This 'if' expression is missing an 'else' branch. Because 'if' is an expression, and not a statement, add an 'else' branch which also returns a value of type '{0}'.</source>
        <target state="translated">'if' 식에 'else' 분기가 누락되었습니다. 'then' 분기의 형식은 '{0}'입니다. 'if'는 문이 아니라 식이므로 동일한 형식의 값을 반환하는 'else' 분기를 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ifExpression">
        <source>The 'if' expression needs to have type '{0}' to satisfy context type requirements. It currently has type '{1}'.</source>
        <target state="translated">if' 식은 컨텍스트 형식 요구 사항을 충족하기 위해 '{0}' 형식이 필요하지만 현재 형식은 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="elseBranchHasWrongType">
        <source>All branches of an 'if' expression must return values of the same type as the first branch, which here is '{0}'. This branch returns a value of type '{1}'.</source>
        <target state="translated">if' 식의 모든 분기는 동일한 형식이어야 합니다. 이 식에는 '{0}' 형식이 필요하지만 여기에서는 '{1}' 형식이 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="followingPatternMatchClauseHasWrongType">
        <source>All branches of a pattern match expression must return values of the same type as the first branch, which here is '{0}'. This branch returns a value of type '{1}'.</source>
        <target state="translated">패턴 일치 식의 모든 분기는 동일한 형식의 값을 반환해야 합니다. 첫 번째 분기는 '{0}' 형식의 값을 반환했지만 이 분기는 '{1}' 형식의 값을 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="patternMatchGuardIsNotBool">
        <source>A pattern match guard must be of type 'bool', but this 'when' expression is of type '{0}'.</source>
        <target state="translated">패턴 일치 가드의 형식은 'bool'이어야 하지만 'when' 식의 형식은 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="commaInsteadOfSemicolonInRecord">
        <source>A ';' is used to separate field values in records. Consider replacing ',' with ';'.</source>
        <target state="translated">';'은 레코드에서 필드 값을 구분하는 데 사용됩니다. ','를 ';'으로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="derefInsteadOfNot">
        <source>The '!' operator is used to dereference a ref cell. Consider using 'not expr' here.</source>
        <target state="translated">'!' 연산자는 참조 셀을 역참조하는 데 사용됩니다. 여기에 'not expr' 사용을 고려하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedTypeArgs">
        <source>The non-generic type '{0}' does not expect any type arguments, but here is given {1} type argument(s)</source>
        <target state="translated">제네릭이 아닌 형식 '{0}'에는 형식 인수가 필요하지 않지만 여기에서는 {1}개의 형식 인수가 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="returnUsedInsteadOfReturnBang">
        <source>Consider using 'return!' instead of 'return'.</source>
        <target state="translated">'return'이 아니라 'return!'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="useSdkRefs">
        <source>Use reference assemblies for .NET framework references when available (Enabled by default).</source>
        <target state="translated">기본적으로 활성화되는 참조 어셈블리를 .NET Framework 참조에 사용합니다(사용 가능한 경우).</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocBadlyFormed">
        <source>This XML comment is invalid: '{0}'</source>
        <target state="translated">이 XML 주석이 잘못됨: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocDuplicateParameter">
        <source>This XML comment is invalid: multiple documentation entries for parameter '{0}'</source>
        <target state="translated">이 XML 주석이 잘못됨: 매개 변수 '{0}'에 대한 여러 설명서 항목이 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocInvalidParameterName">
        <source>This XML comment is invalid: unknown parameter '{0}'</source>
        <target state="translated">이 XML 주석이 잘못됨: 알 수 없는 매개 변수 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingCrossReference">
        <source>This XML comment is invalid: missing 'cref' attribute for cross-reference</source>
        <target state="translated">이 XML 주석이 잘못됨: 상호 참조에 'cref' 특성이 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingParameter">
        <source>This XML comment is incomplete: no documentation for parameter '{0}'</source>
        <target state="translated">이 XML 주석이 불완전함: 매개 변수 '{0}'에 대한 설명서가 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingParameterName">
        <source>This XML comment is invalid: missing 'name' attribute for parameter or parameter reference</source>
        <target state="translated">이 XML 주석이 잘못됨: 매개 변수 또는 매개 변수 참조에 'name' 특성이 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocUnresolvedCrossReference">
        <source>This XML comment is invalid: unresolved cross-reference '{0}'</source>
        <target state="translated">이 XML 주석이 잘못됨: 확인되지 않은 상호 참조 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="yieldUsedInsteadOfYieldBang">
        <source>Consider using 'yield!' instead of 'yield'.</source>
        <target state="translated">'yield'가 아닌 'yield!'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tupleRequiredInAbstractMethod">
        <source>\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.</source>
        <target state="translated">\n하나 이상의 인수에 튜플 형식이 필요합니다. 지정된 인수를 추가 괄호로 래핑하거나 인터페이스의 정의를 검토하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidWarningNumber">
        <source>Invalid warning number '{0}'</source>
        <target state="translated">경고 번호 '{0}'이(가) 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionString">
        <source>Invalid version string '{0}'</source>
        <target state="translated">버전 문자열 '{0}'이(가) 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionFile">
        <source>Invalid version file '{0}'</source>
        <target state="translated">버전 파일 '{0}'이(가) 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemWithFilename">
        <source>Problem with filename '{0}': {1}</source>
        <target state="translated">파일 이름 '{0}'에 문제가 있습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildNoInputsSpecified">
        <source>No inputs specified</source>
        <target state="translated">지정한 입력이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildPdbRequiresDebug">
        <source>The '--pdb' option requires the '--debug' option to be used</source>
        <target state="translated">'--pdb' 옵션을 사용하려면 '--debug' 옵션을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSearchDirectory">
        <source>The search directory '{0}' is invalid</source>
        <target state="translated">검색 디렉터리 '{0}'이(가) 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSearchDirectoryNotFound">
        <source>The search directory '{0}' could not be found</source>
        <target state="translated">검색 디렉터리 '{0}'을(를) 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidFilename">
        <source>'{0}' is not a valid filename</source>
        <target state="translated">'{0}'은(는) 올바른 파일 이름이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidAssemblyName">
        <source>'{0}' is not a valid assembly name</source>
        <target state="translated">'{0}'은(는) 올바른 어셈블리 이름이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidPrivacy">
        <source>Unrecognized privacy setting '{0}' for managed resource, valid options are 'public' and 'private'</source>
        <target state="translated">관리되는 리소스에 대해 인식할 수 없는 개인 정보 보호 설정 '{0}'입니다. 올바른 옵션은 'public' 및 'private'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCannotReadAssembly">
        <source>Unable to read assembly '{0}'</source>
        <target state="translated">'{0}' 어셈블리를 읽을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildAssemblyResolutionFailed">
        <source>Assembly resolution failure at or near this location</source>
        <target state="translated">이 위치 또는 이 위치 근처에서 어셈블리를 확인하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplicitModuleIsNotLegalIdentifier">
        <source>The declarations in this file will be placed in an implicit module '{0}' based on the file name '{1}'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file.</source>
        <target state="translated">이 파일의 선언은 파일 이름 '{1}'을(를) 기반으로 암시적 모듈 '{0}'에 배치됩니다. 그러나 이는 올바른 F# 식별자가 아니므로 다른 파일에서 내용에 액세스할 수 없게 됩니다. 파일의 이름을 바꾸거나 파일의 맨 위에 'module' 또는 'namespace' 선언을 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultiFileRequiresNamespaceOrModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration.</source>
        <target state="translated">라이브러리 또는 다중 파일 애플리케이션의 파일은 네임스페이스 또는 모듈 선언으로 시작해야 합니다(예: 'namespace SomeNamespace.SubNamespace' 또는 'module SomeNamespace.SomeModule'). 애플리케이션의 마지막 소스 파일만 선언이 없어도 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="noEqualSignAfterModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.</source>
        <target state="translated">라이브러리 또는 다중 파일 애플리케이션의 파일은 네임스페이스 또는 모듈 선언으로 시작해야 합니다. 파일 시작에 모듈 선언을 사용하는 경우 '=' 기호를 사용할 수 없습니다. 최상위 모듈인 경우 =를 제거하여 이 오류를 해결하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleToplevelModules">
        <source>This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules.</source>
        <target state="translated">이 파일에는 'module SomeNamespace.SomeModule' 형식의 선언이 여러 개 포함되어 있습니다. 이러한 형식의 선언은 파일당 하나만 허용됩니다. 초기 네임스페이스 선언을 사용하도록 파일을 변경하거나 'module ModuleName = ...'을 사용하여 모듈을 정의하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildOptionRequiresParameter">
        <source>Option requires parameter: {0}</source>
        <target state="translated">옵션에 필요한 매개 변수: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotFindSourceFile">
        <source>Source file '{0}' could not be found</source>
        <target state="translated">소스 파일 '{0}'을(를) 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSourceFileExtension">
        <source>The file extension of '{0}' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.</source>
        <target state="translated">'{0}'의 파일 확장명을 인식할 수 없습니다. 소스 파일의 확장명은 .fs, .fsi, .fsx, .fsscript, .ml 또는 .mli여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssembly">
        <source>Could not resolve assembly '{0}'</source>
        <target state="translated">'{0}' 어셈블리를 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssemblyRequiredByFile">
        <source>Could not resolve assembly '{0}' required by '{1}'</source>
        <target state="translated">{1}'에 필요한 '{0}' 어셈블리를 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildErrorOpeningBinaryFile">
        <source>Error opening binary file '{0}': {1}</source>
        <target state="translated">이진 파일 '{0}'을(를) 여는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDifferentVersionMustRecompile">
        <source>The F#-compiled DLL '{0}' needs to be recompiled to be used with this version of F#</source>
        <target state="translated">F# 컴파일 DLL '{0}'을(를) 이 버전의 F#에 사용하려면 다시 컴파일해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashIDirective">
        <source>Invalid directive. Expected '#I \"&lt;path&gt;\"'.</source>
        <target state="translated">지시문이 잘못되었습니다. '#I \"&lt;path&gt;\"'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashrDirective">
        <source>Invalid directive. Expected '#r \"&lt;file-or-assembly&gt;\"'.</source>
        <target state="translated">지시문이 잘못되었습니다. '#r \"&lt;file-or-assembly&gt;\"'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashloadDirective">
        <source>Invalid directive. Expected '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</source>
        <target state="translated">지시문이 잘못되었습니다. '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashtimeDirective">
        <source>Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'.</source>
        <target state="translated">지시문이 잘못되었습니다. '#time', '#time \"on\"' 또는 '#time \"off\"'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDirectivesInModulesAreIgnored">
        <source>Directives inside modules are ignored</source>
        <target state="translated">모듈 내의 지시문은 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureAlreadySpecified">
        <source>A signature for the file or module '{0}' has already been specified</source>
        <target state="translated">'{0}' 파일 또는 모듈의 시그니처가 이미 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGivenDetail">
        <source>An implementation of file or module '{0}' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.</source>
        <target state="translated">'{0}' 파일 또는 모듈에 대한 구현이 이미 지정되었습니다. 형식 유추로 인해 F#에서는 컴파일 순서가 중요합니다. 구현하기 전에 시그니처 파일을 배치하기 위해 파일의 순서를 조정해야 할 수 있습니다. Visual Studio에서는 파일이 프로젝트 파일에 나타나는 순서대로 형식이 검사되며 이 순서는 수동으로 편집하거나 솔루션 탐색기를 사용하여 조정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGiven">
        <source>An implementation of the file or module '{0}' has already been given</source>
        <target state="translated">'{0}' 파일 또는 모듈에 대한 구현이 이미 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureWithoutImplementation">
        <source>The signature file '{0}' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match.</source>
        <target state="translated">시그니처 파일 '{0}'에 해당하는 구현 파일이 없습니다. 구현 파일이 있는 경우 시그니처 파일과 구현 파일의 'module' 및 'namespace' 선언이 일치하는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidInt">
        <source>'{0}' is not a valid integer argument</source>
        <target state="translated">'{0}'은(는) 올바른 정수 인수가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidFloat">
        <source>'{0}' is not a valid floating point argument</source>
        <target state="translated">'{0}'은(는) 올바른 부동 소수점 인수가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnrecognizedOption">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">인식할 수 없는 옵션: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidModuleOrNamespaceName">
        <source>Invalid module or namespace name</source>
        <target state="translated">모듈 또는 네임스페이스 이름이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleErrorReadingWritingMetadata">
        <source>Error reading/writing metadata for the F# compiled DLL '{0}'. Was the DLL compiled with an earlier version of the F# compiler? (error: '{1}').</source>
        <target state="translated">F# 컴파일 DLL '{0}'에 대한 메타데이터를 읽는/쓰는 동안 오류가 발생했습니다. DLL이 이전 버전의 F# 컴파일러를 사용하여 컴파일되었습니까?(오류: '{1}')</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeOrModuleNotConcrete">
        <source>The type/module '{0}' is not a concrete module or type</source>
        <target state="translated">'{0}' 형식/모듈이 구체적인 모듈 또는 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeHasAssemblyCodeRepresentation">
        <source>The type '{0}' has an inline assembly code representation</source>
        <target state="translated">'{0}' 형식에 인라인 어셈블리 코드 표현이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNamespaceAndModuleWithSameNameInAssembly">
        <source>A namespace and a module named '{0}' both occur in two parts of this assembly</source>
        <target state="translated">이 어셈블리의 두 부분에서 '{0}'(이)라는 네임스페이스와 모듈이 모두 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTwoModulesWithSameNameInAssembly">
        <source>Two modules named '{0}' occur in two parts of this assembly</source>
        <target state="translated">이 어셈블리의 두 부분에서 '{0}'(이)라는 두 개의 모듈이 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastDuplicateTypeDefinitionInAssembly">
        <source>Two type definitions named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">이 어셈블리의 두 부분에서 네임스페이스 '{1}'에 '{0}'(이)라는 두 개의 형식 정의가 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConflictingModuleAndTypeDefinitionInAssembly">
        <source>A module and a type definition named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">이 어셈블리의 두 부분에서 네임스페이스 '{1}'에 '{0}'(이)라는 모듈 및 형식 정의가 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMemberSignature">
        <source>Invalid member signature encountered because of an earlier error</source>
        <target state="translated">이전 오류로 인해 잘못된 멤버 시그니처가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueDoesNotHaveSetterType">
        <source>This value does not have a valid property setter type</source>
        <target state="translated">이 값에는 올바른 속성 setter 형식이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertyGetter">
        <source>Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax.</source>
        <target state="translated">속성 getter의 형식이 잘못되었습니다. 명시적 구문을 사용할 때는 하나 이상의 '()' 인수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertySetter">
        <source>Invalid form for a property setter. At least one argument is required.</source>
        <target state="translated">속성 setter의 형식이 잘못되었습니다. 하나 이상의 인수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedByRef">
        <source>Unexpected use of a byref-typed variable</source>
        <target state="translated">예기치 않은 byref 형식 변수의 사용입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMutationOfConstant">
        <source>Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'.</source>
        <target state="translated">상수 식을 잘못 변경했습니다. 식을 변경할 수 있는 로컬로 복사하십시오(예: 'let mutable x = ...').</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueHasBeenCopied">
        <source>The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed</source>
        <target state="translated">이 작업에 의해 원래 값이 변경되지 않도록 값이 복사되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeInConstructionOfTuple">
        <source>Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding</source>
        <target state="translated">재귀적으로 정의된 값은 재귀적 바인딩 내에서 튜플 값의 구성 요소에 대한 일부로 직접 나타날 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotAppearInConstructionOfType">
        <source>Recursive values cannot appear directly as a construction of the type '{0}' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.</source>
        <target state="translated">재귀 값은 재귀적 바인딩 내에서 '{0}' 형식의 구성 요소로 직접 나타날 수 없습니다. 이 기능은 F# 언어에서 제거되었습니다. 대신 레코드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeAssignedToNonMutableField">
        <source>Recursive values cannot be directly assigned to the non-mutable field '{0}' of the type '{1}' within a recursive binding. Consider using a mutable field instead.</source>
        <target state="translated">재귀 값은 재귀적 바인딩 내에서 '{1}' 형식의 변경할 수 없는 필드 '{0}'에 직접 할당할 수 없습니다. 대신 변경할 수 있는 필드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfAutoOpenAttribute">
        <source>Unexpected decode of AutoOpenAttribute</source>
        <target state="translated">예기치 않은 AutoOpenAttribute의 디코딩입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInternalsVisibleToAttribute">
        <source>Unexpected decode of InternalsVisibleToAttribute</source>
        <target state="translated">예기치 않은 InternalsVisibleToAttribute의 디코딩입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
        <source>Unexpected decode of InterfaceDataVersionAttribute</source>
        <target state="translated">예기치 않은 InterfaceDataVersionAttribute의 디코딩입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastActivePatternsLimitedToSeven">
        <source>Active patterns cannot return more than 7 possibilities</source>
        <target state="translated">활성 패턴은 7개가 넘는 가능성을 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNotAConstantExpression">
        <source>This is not a valid constant expression or custom attribute value</source>
        <target state="translated">올바른 상수 식 또는 사용자 지정 특성 값이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAttributesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe mutability attributes differ</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n변경 가능성 특성이 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe names differ</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n이름이 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityCompiledNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled names differ</source>
        <target state="translated">{0}' 모듈에는 다음이 포함되어 있습니다.\n    {1}    \n하지만 해당 시그니처는 다음을 지정합니다.\n    {2}    \n컴파일된 이름이 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDisplayNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe display names differ</source>
        <target state="translated">{0}' 모듈에는 다음이 포함되어 있습니다.\n    {1}    \n하지만 해당 시그니처는 다음을 지정합니다.\n    {2}    \n표시 이름이 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAccessibilityMore">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n시그니처에 지정된 액세스 가능성이 구현에 지정된 액세스 가능성보다 높습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInlineFlagsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe inline flags differ</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n인라인 플래그가 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityLiteralConstantValuesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe literal constant values and/or attributes differ</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n리터럴 상수 값 및/또는 특성이 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsTypeFunction">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 형식 함수이고 다른 하나는 그렇지 않습니다. 명시적 형식 매개 변수가 구현에 있는 경우 시그니처에도 해당 형식 매개 변수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityParameterCountsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe respective type parameter counts differ</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n각각의 형식 매개 변수 수가 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityTypesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe types differ</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n형식이 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityExtensionsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is an extension member and the other is not</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 확장 멤버이고 다른 하나는 그렇지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityArityNotInferred">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nAn arity was not inferred for this value</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n이 값에 대한 인자 수가 유추되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe number of generic parameters in the signature and implementation differ (the signature declares {3} but the implementation declares {4}</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n시그니처와 구현의 제네릭 매개 변수 수가 서로 다릅니다. 시그니처는 {3}개를 선언하지만 구현은 {4}개를 선언합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersAreDifferentKinds">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.</source>
        <target state="translated">'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n시그니처와 구현의 제네릭 매개 변수 종류가 서로 다릅니다. [&lt;Measure&gt;] 특성이 없는 것 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAritiesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe arities in the signature and implementation differ. The signature specifies that '{3}' is function definition or lambda expression accepting at least {4} argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int.</source>
        <target state="translated">'{0}' 모듈에\n {1}이(가) 포함되어 있지만 \n해당 시그니처는\n {2}을(를) 지정합니다. \n시그니처와 구현의 인자 수가 서로 다릅니다. 시그니처는 '{3}'이(가) {4}개 이상의 인수를 적용하는 함수 정의 또는 람다 식임을 지정하지만 구현은 계산된 함수 값입니다. 계산된 함수 값이 허용되는 구현임을 선언하려면 시그니처에서 해당 형식을 괄호로 묶기만 하면 됩니다(예: \n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int).</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDotNetNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe CLI member names differ</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \nCLI 멤버 이름이 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is static and the other isn't</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 정적 요소이고 다른 하나는 그렇지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityVirtualsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is virtual and the other isn't</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 가상 요소이고 다른 하나는 그렇지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAbstractsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is abstract and the other isn't</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 추상 요소이고 다른 하나는 그렇지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityFinalsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is final and the other isn't</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 최종 요소이고 다른 하나는 그렇지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOverridesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is marked as an override and the other isn't</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 override로 표시되어 있고 다른 하나는 그렇지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsConstructor">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a constructor/property and the other is not</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 생성자/속성이고 다른 하나는 그렇지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticButInstance">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n이 메서드의 컴파일 표현이 정적 멤버이지만 시그니처는 해당 컴파일 표현이 인스턴스 멤버임을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInstanceButStatic">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member</source>
        <target state="translated">{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n이 메서드의 컴파일 표현이 인스턴스 멤버이지만 시그니처는 해당 컴파일 표현이 정적 멤버임을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNamesDiffer">
        <source>The {0} definitions in the signature and implementation are not compatible because the names differ. The type is called '{1}' in the signature file but '{2}' in implementation.</source>
        <target state="translated">이름이 서로 다르므로 시그니처 및 구현의 {0} 정의가 호환되지 않습니다. 시그니처 파일의 형식은 '{1}'이지만 구현의 형식은 '{2}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">각각의 형식 매개 변수 수가 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">시그니처에 지정된 액세스 가능성이 구현에 지정된 액세스 가능성보다 높으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleMissingInterface">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature requires that the type supports the interface {2} but the interface has not been implemented</source>
        <target state="translated">시그니처를 사용하려면 형식이 {2} 인터페이스를 지원해야 하지만 이 인터페이스가 구현되지 않았으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not</source>
        <target state="translated">구현이 이 형식에서 null을 표현으로 사용할 수 있다고 하지만 시그니처는 그렇지 않으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not</source>
        <target state="translated">구현이 이 형식에서 null을 추가 값으로 사용할 수 있다고 하지만 시그니처는 그렇지 않으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not</source>
        <target state="translated">시그니처가 이 형식에서 null을 표현으로 사용할 수 있다고 하지만 구현은 그렇지 않으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not</source>
        <target state="translated">시그니처가 이 형식에서 null을 추가 값으로 사용할 수 있다고 하지만 구현은 그렇지 않으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.</source>
        <target state="translated">구현 형식이 봉인되어 있지만 시그니처는 봉인되어 있지 않음을 암시하므로 시그니처 및 구현의 '{1}' 형식 {0} 정의가 호환되지 않습니다. 시그니처에 [&lt;Sealed&gt;] 특성을 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.</source>
        <target state="translated">구현 형식이 봉인되어 있지 않지만 시그니처는 봉인되어 있음을 암시하므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다. 구현에 [&lt;Sealed&gt;] 특성을 추가해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.</source>
        <target state="translated">구현이 추상 클래스이지만 시그니처는 추상 클래스가 아니므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다. 시그니처에 [&lt;AbstractClass&gt;] 특성을 추가해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.</source>
        <target state="translated">시그니처가 추상 클래스이지만 구현은 추상 클래스가 아니므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다. 구현에 [&lt;AbstractClass&gt;] 특성을 추가해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types have different base types</source>
        <target state="translated">형식의 기본 형식이 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNumbersDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the number of {2}s differ</source>
        <target state="translated">{2} 수가 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature defines the {2} '{3}' but the implementation does not (or does, but not in the same order)</source>
        <target state="translated">시그니처가 {2} '{3}'을(를) 정의하지만 구현은 그렇지 않거나 그렇더라도 순서가 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines the {2} '{3}' but the signature does not (or does, but not in the same order)</source>
        <target state="translated">구현이 {2} '{3}'을(를) 정의하지만 시그니처는 그렇지 않거나 그렇더라도 순서가 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation</source>
        <target state="translated">구현이 구조체를 정의하지만 시그니처는 숨겨진 표현이 있는 형식을 정의하므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature</source>
        <target state="translated">시그니처에 의해 CLI 형식 표현이 숨겨져 있으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a type representation is being hidden by a signature</source>
        <target state="translated">시그니처에 의해 형식 표현이 숨겨져 있으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types are of different kinds</source>
        <target state="translated">형식의 종류가 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleILDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the IL representations differ</source>
        <target state="translated">IL 표현이 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the representations differ</source>
        <target state="translated">표현이 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldWasPresent">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was present in the implementation but not in the signature</source>
        <target state="translated">{2}' 필드가 구현에 있었지만 시그니처에는 없었으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation</source>
        <target state="translated">시그니처와 구현에서 필드의 순서가 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was required by the signature but was not specified by the implementation</source>
        <target state="translated">{2}' 필드가 시그니처에 필요했지만 구현에 의해 지정되지 않았으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field '{2}' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'.</source>
        <target state="translated">{2}' 필드가 구현에 있었지만 시그니처에는 없었으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다. 이제 구조체 형식은 시그니처에서 형식에 대해 필드를 표시해야 하지만 필드의 레이블은 계속 'private' 또는 'internal'로 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was required by the signature but was not specified by the implementation</source>
        <target state="translated">추상 멤버 '{2}'이(가) 시그니처에 필요했지만 구현에 의해 지정되지 않았으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was present in the implementation but not in the signature</source>
        <target state="translated">추상 멤버 '{2}'이(가) 구현에 있었지만 시그니처에는 없었으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature declares a {2} while the implementation declares a {3}</source>
        <target state="translated">시그니처가 {2}을(를) 선언하지만 구현은 {3}을(를) 선언하므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abbreviations differ: {2} versus {3}</source>
        <target state="translated">약어가 {2}과(와) {3}(으)로 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.</source>
        <target state="translated">시그니처에 의해 약어가 숨겨져 있으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다. 약어는 다른 CLI 언어에 표시되어야 합니다. 시그니처에서 약어를 표시하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not</source>
        <target state="translated">시그니처에 약어가 있지만 구현에는 없으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButNamesDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">모듈에\n    {0} 생성자가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n이름이 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButDataFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe respective number of data fields differ</source>
        <target state="translated">모듈에\n    {0} 생성자가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n각각의 데이터 필드 수가 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButTypesOfFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe types of the fields differ</source>
        <target state="translated">모듈에\n    {0} 생성자가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n필드의 형식이 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButAccessibilityDiffers">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">모듈에\n    {0} 생성자가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n시그니처에 지정된 액세스 가능성이 구현에 지정된 액세스 가능성보다 높습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedNamesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">모듈에\n    {0} 필드가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n이름이 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedAccessibilitiesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">모듈에\n    {0} 필드가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n시그니처에 지정된 액세스 가능성이 구현에 지정된 액세스 가능성보다 높습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedStaticsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'static' modifiers differ</source>
        <target state="translated">모듈에\n    {0} 필드가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n'static' 한정자가 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedMutablesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'mutable' modifiers differ</source>
        <target state="translated">모듈에\n    {0} 필드가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n'mutable' 한정자가 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedLiteralsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'literal' modifiers differ</source>
        <target state="translated">모듈에\n    {0} 필드가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n'literal' 한정자가 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedTypesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe types differ</source>
        <target state="translated">모듈에\n    {0} 필드가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n형식이 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveImplicitGenericInstantiation">
        <source>The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '{0}' and '{1}'. Consider using type annotations to resolve the ambiguity</source>
        <target state="translated">관련되지 않은 여러 형식(예: '{0}'과(와) '{1}')으로 확인될 수 있으므로 이 지점 또는 이 지점 근처에서 제네릭 구문의 암시적 인스턴스를 확인할 수 없습니다. 형식 주석을 사용하여 모호성을 해결하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInPrintf">
        <source>Could not resolve the ambiguity inherent in the use of a 'printf'-style format string</source>
        <target state="translated">'printf' 스타일의 서식 문자열 사용과 관련하여 본질적으로 발생하는 모호성을 해결할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInEnum">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position</source>
        <target state="translated">이 위치 또는 이 위치 근처에서 'enum' 제약 조건을 사용하여 제네릭 구문 사용의 모호성을 해결할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInDelegate">
        <source>Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position</source>
        <target state="translated">이 위치 또는 이 위치 근처에서 'delegate' 제약 조건을 사용하여 제네릭 구문 사용의 모호성을 해결할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInvalidValue">
        <source>Invalid value</source>
        <target state="translated">잘못된 값</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleParamCountsDiffer">
        <source>The signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">각각의 형식 매개 변수 수가 서로 다르므로 시그니처와 구현이 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
        <source>The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation</source>
        <target state="translated">클래스/시그니처에 있는 형식 매개 변수의 컴파일 시간 요구 사항이 멤버/구현에 있는 형식 매개 변수와 다르므로 시그니처와 구현이 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDiffer">
        <source>The signature and implementation are not compatible because the declaration of the type parameter '{0}' requires a constraint of the form {1}</source>
        <target state="translated">형식 매개 변수 '{0}'의 선언을 사용하려면 {1} 형식의 제약 조건이 필요하므로 시그니처와 구현이 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDifferRemove">
        <source>The signature and implementation are not compatible because the type parameter '{0}' has a constraint of the form {1} but the implementation does not. Either remove this constraint from the signature or add it to the implementation.</source>
        <target state="translated">형식 매개 변수 '{0}'에 {1} 형식의 제약 조건이 있지만 구현에는 없으므로 시그니처와 구현이 호환되지 않습니다. 이 제약 조건을 시그니처에서 제거하거나 구현에 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableShouldOverrideObjectEquals">
        <source>The type '{0}' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'</source>
        <target state="translated">'{0}' 형식이 'System.IComparable'을 구현합니다. 'Object.Equals'에 대한 명시적 재정의도 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableDefaultObjectEqualsProvided">
        <source>The type '{0}' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly</source>
        <target state="translated">'{0}' 형식이 'System.IComparable'을 명시적으로 구현하지만 'Object.Equals'에 해당하는 재정의를 제공하지 않습니다. 'System.IComparable'을 통해 구현된 'Object.Equals'의 구현이 자동으로 제공되었습니다. 재정의 'Object.Equals'를 명시적으로 구현하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCodeOrEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type</source>
        <target state="translated">구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'Object.GetHashCode' 또는 'Object.Equals'의 명시적 구현이 있습니다. 형식에 'CustomEquality' 특성을 적용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCode">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'</source>
        <target state="translated">구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'Object.GetHashCode'의 명시적 구현이 있습니다. 'Object.Equals(obj)'에 대해 일치하는 재정의를 구현하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'</source>
        <target state="translated">구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'Object.Equals'의 명시적 구현이 있습니다. 'Object.GetHashCode()'에 대해 일치하는 재정의를 구현하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleHiddenBySignature">
        <source>The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">시그니처에 의해 CLI 예외 매핑이 숨겨져 있으므로 예외 정의가 호환되지 않습니다. 예외 매핑은 다른 모듈에 표시되어야 합니다. 모듈에 예외 정의\n    {0}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{1}을(를) 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer">
        <source>The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">CLI 표현이 서로 다르므로 예외 정의가 호환되지 않습니다. 모듈에 예외 정의\n    {0}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{1}을(를) 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature">
        <source>The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">시그니처에 의해 예외 약어가 숨겨져 있으므로 예외 정의가 호환되지 않습니다. 약어는 다른 CLI 언어에 표시되어야 합니다. 시그니처에서 약어를 표시하세요. 모듈에 예외 정의\n    {0}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{1}을(를) 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleSignaturesDiffer">
        <source>The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">시그니처와 구현에서 예외 약어가 서로 다르므로 예외 정의가 호환되지 않습니다. 모듈에 예외 정의\n    {0}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{1}을(를) 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer">
        <source>The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">예외 선언이 서로 다르므로 예외 정의가 호환되지 않습니다. 모듈에 예외 정의\n    {0}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{1}을(를) 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInSigButNotImpl">
        <source>The exception definitions are not compatible because the field '{0}' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">{0}' 필드가 시그니처에 필요했지만 구현에 의해 지정되지 않았으므로 예외 정의가 호환되지 않습니다. 모듈에 예외 정의\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{2}을(를) 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInImplButNotSig">
        <source>The exception definitions are not compatible because the field '{0}' was present in the implementation but not in the signature. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">{0}' 필드가 구현에 있었지만 시그니처에는 없었으므로 예외 정의가 호환되지 않습니다. 모듈에 예외 정의\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{2}을(를) 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldOrderDiffers">
        <source>The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">시그니처와 구현에서 필드의 순서가 서로 다르므로 예외 정의가 호환되지 않습니다. 모듈에 예외 정의\n    {0}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{1}을(를) 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelModuleNamespaceAttributesDifferInSigAndImpl">
        <source>The namespace or module attributes differ between signature and implementation</source>
        <target state="translated">네임스페이스 또는 모듈 특성이 시그니처와 구현 간에 서로 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsOverconstrained">
        <source>This method is over-constrained in its type parameters</source>
        <target state="translated">이 메서드는 해당 형식 매개 변수에서 과다하게 제약 조건이 적용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverloadNotFound">
        <source>No implementations of '{0}' had the correct number of arguments and type parameters. The required signature is '{1}'.</source>
        <target state="translated">{0}'의 구현 중 올바른 수의 인수 및 형식 매개 변수를 포함하는 구현이 없습니다. 필요한 시그니처는 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideWasAmbiguous">
        <source>The override for '{0}' was ambiguous</source>
        <target state="translated">'{0}'의 재정의가 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMoreThenOneOverride">
        <source>More than one override implements '{0}'</source>
        <target state="translated">둘 이상의 재정의가 '{0}'을(를) 구현합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsSealed">
        <source>The method '{0}' is sealed and cannot be overridden</source>
        <target state="translated">'{0}' 메서드는 봉인되어 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideImplementsMoreThenOneSlot">
        <source>The override '{0}' implements more than one abstract slot, e.g. '{1}' and '{2}'</source>
        <target state="translated">재정의 '{0}'이(가) 둘 이상의 추상 슬롯을 구현합니다(예: '{1}' 및 '{2}').</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelDuplicateInterface">
        <source>Duplicate or redundant interface</source>
        <target state="translated">인터페이스가 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNeedExplicitImplementation">
        <source>The interface '{0}' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.</source>
        <target state="translated">'{0}' 인터페이스가 명시적으로 구현된 다중 인터페이스 형식에 포함되어 있습니다. 이 인터페이스의 명시적 구현을 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNamedArgumentHasBeenAssignedMoreThenOnce">
        <source>The named argument '{0}' has been assigned more than one value</source>
        <target state="translated">명명된 인수 '{0}'에 둘 이상의 값이 할당되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGiven">
        <source>No implementation was given for '{0}'</source>
        <target state="translated">'{0}'에 대해 지정된 구현이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenWithSuggestion">
        <source>No implementation was given for '{0}'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">'{0}'에 대해 지정된 구현이 없습니다. 모든 인터페이스 멤버가 구현되어 적절한 'interface' 선언에 나열되어야 합니다(예: 'interface ... with member ...').</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfArguments">
        <source>The member '{0}' does not have the correct number of arguments. The required signature is '{1}'.</source>
        <target state="translated">{0}' 멤버에 올바른 수의 인수가 없습니다. 필요한 시그니처는 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters">
        <source>The member '{0}' does not have the correct number of method type parameters. The required signature is '{1}'.</source>
        <target state="translated">{0}' 멤버에 올바른 수의 메서드 형식 매개 변수가 없습니다. 필요한 시그니처는 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters">
        <source>The member '{0}' does not have the correct kinds of generic parameters. The required signature is '{1}'.</source>
        <target state="translated">{0}' 멤버에 올바른 종류의 제네릭 매개 변수가 없습니다. 필요한 시그니처는 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberCannotImplement">
        <source>The member '{0}' cannot be used to implement '{1}'. The required signature is '{2}'.</source>
        <target state="translated">{0}' 멤버를 사용하여 '{1}'을(를) 구현할 수 없습니다. 필요한 시그니처는 '{2}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILError">
        <source>Error while parsing embedded IL</source>
        <target state="translated">포함된 IL을 구문 분석하는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILTypeError">
        <source>Error while parsing embedded IL type</source>
        <target state="translated">포함된 IL 형식을 구문 분석하는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="astDeprecatedIndexerNotation">
        <source>This indexer notation has been removed from the F# language</source>
        <target state="translated">이 인덱서 표기법은 F# 언어에서 제거되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="astInvalidExprLeftHandOfAssignment">
        <source>Invalid expression on left of assignment</source>
        <target state="translated">할당 왼쪽에 잘못된 식이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoRefEqualsOnStruct">
        <source>The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'.</source>
        <target state="translated">'ReferenceEquality' 특성은 구조체에 대해 사용할 수 없습니다. 대신 'StructuralEquality' 특성을 사용하거나 'System.Object.Equals(obj)'의 재정의를 구현하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="augInvalidAttrs">
        <source>This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'</source>
        <target state="translated">이 형식은 잘못된 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' 및 'StructuralComparison' 특성의 조합을 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqualityNeedsNoComparison">
        <source>The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute</source>
        <target state="translated">'NoEquality' 특성은 'NoComparison' 특성과 함께 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructCompNeedsStructEquality">
        <source>The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute</source>
        <target state="translated">'StructuralComparison' 특성은 'StructuralEquality' 특성과 함께 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructEqNeedsNoCompOrStructComp">
        <source>The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes</source>
        <target state="translated">'StructuralEquality' 특성은 'NoComparison' 또는 'StructuralComparison' 특성과 함께 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="augTypeCantHaveRefEqAndStructAttrs">
        <source>A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes</source>
        <target state="translated">형식에 'ReferenceEquality' 특성과 'StructuralEquality' 또는 'StructuralComparison' 특성을 모두 지정할 수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="augOnlyCertainTypesCanHaveAttrs">
        <source>Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes</source>
        <target state="translated">레코드, 공용 구조체, 예외 및 구조체 형식만 'ReferenceEquality', 'StructuralEquality' 및 'StructuralComparison' 특성으로 확대할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="augRefEqCantHaveObjEquals">
        <source>A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">특성 'ReferenceEquality'가 지정된 형식에는 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' 또는 'System.Collections.IStructuralEquatable'에 대한 명시적 구현이 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsObjEquals">
        <source>A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">'CustomEquality' 특성이 지정된 형식에는 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' 또는 'System.Collections.IStructuralEquatable' 중 하나 이상에 대한 명시적 구현이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomCompareNeedsIComp">
        <source>A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'</source>
        <target state="translated">특성 'CustomComparison'이 지정된 형식에는 'System.IComparable' 또는 'System.Collections.IStructuralComparable' 중 하나 이상에 대한 명시적 구현이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqNeedsNoObjEquals">
        <source>A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">특성 'NoEquality'가 지정된 형식에는 일반적으로 'Object.Equals(obj)'에 대한 명시적 구현이 있으면 안 됩니다. 상호 운용성을 위해 의도적으로 이러한 구현을 사용한 경우에는 이 경고를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoCompCantImpIComp">
        <source>A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable&lt;_&gt;' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">특성 'NoComparison'이 지정된 형식에는 일반적으로 'System.IComparable', 'System.IComparable&lt;_&gt;' 또는 'System.Collections.IStructuralComparable'에 대한 명시적 구현이 있으면 안 됩니다. 상호 운용성을 위해 의도적으로 이러한 구현을 사용한 경우에는 이 경고를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsNoCompOrCustomComp">
        <source>The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes</source>
        <target state="translated">'CustomEquality' 특성은 'NoComparison' 또는 'CustomComparison' 특성과 함께 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forPositionalSpecifiersNotPermitted">
        <source>Positional specifiers are not permitted in format strings</source>
        <target state="translated">위치 지정자는 서식 문자열에 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forMissingFormatSpecifier">
        <source>Missing format specifier</source>
        <target state="translated">서식 지정자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFlagSetTwice">
        <source>'{0}' flag set twice</source>
        <target state="translated">'{0}' 플래그를 두 번 설정했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrefixFlagSpacePlusSetTwice">
        <source>Prefix flag (' ' or '+') set twice</source>
        <target state="translated">접두사 플래그(' ' 또는 '+')를 두 번 설정했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forHashSpecifierIsInvalid">
        <source>The # formatting modifier is invalid in F#</source>
        <target state="translated">F#에서는 # 서식 지정 한정자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadPrecision">
        <source>Bad precision in format specifier</source>
        <target state="translated">서식 지정자의 정밀도가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadWidth">
        <source>Bad width in format specifier</source>
        <target state="translated">서식 지정자의 너비가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportZeroFlag">
        <source>'{0}' format does not support '0' flag</source>
        <target state="translated">'{0}' 형식은 '0' 플래그를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrecisionMissingAfterDot">
        <source>Precision missing after the '.'</source>
        <target state="translated">'.' 뒤에 정밀도가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatDoesntSupportPrecision">
        <source>'{0}' format does not support precision</source>
        <target state="translated">'{0}' 형식은 정밀도를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifier">
        <source>Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">l 또는 L 뒤에서 서식 지정자가 잘못되었습니다. ld, li, lo, lu, lx 또는 lX가 필요합니다. F# 코드에서는 모든 기본 정수 형식과 함께 사용할 수 있도록 오버로드되는 %d, %x, %o 또는 %u을(를) 대신 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forLIsUnnecessary">
        <source>The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">이 서식 지정자에서 'l' 또는 'L'은 불필요합니다. F# 코드에서는 모든 기본 정수 형식과 함께 사용할 수 있도록 오버로드되는 %d, %x, %o 또는 %u을(를) 대신 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forHIsUnnecessary">
        <source>The 'h' or 'H' in this format specifier is unnecessary. You can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">이 서식 지정자에서 'h' 또는 'H'는 불필요합니다. 모든 기본 정수 형식과 함께 사용할 수 있도록 오버로드되는 %d, %x, %o 또는 %u을(를) 대신 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportPrefixFlag">
        <source>'{0}' does not support prefix '{1}' flag</source>
        <target state="translated">'{0}'은(는) 접두사 '{1}' 플래그를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifierGeneral">
        <source>Bad format specifier: '{0}'</source>
        <target state="translated">서식 지정자가 잘못되었습니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="elSysEnvExitDidntExit">
        <source>System.Environment.Exit did not exit</source>
        <target state="translated">System.Environment.Exit이 종료되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="elDeprecatedOperator">
        <source>The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined</source>
        <target state="translated">이 연산자의 처리는 이제 F# 컴파일러에 의해 직접 수행되며 해당 의미를 다시 정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkProtectedOrBaseCalled">
        <source>A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope.</source>
        <target state="translated">보호된 멤버가 호출되었거나 'base'가 사용되고 있습니다. 이는 멤버를 직접 구현할 경우에만 허용됩니다. 이 경우 멤버가 개체 범위를 벗어날 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkByrefUsedInInvalidWay">
        <source>The byref-typed variable '{0}' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.</source>
        <target state="translated">byref 형식의 변수 '{0}'이(가) 잘못된 방식으로 사용되었습니다. byref는 클로저로 캡처하거나 내부 함수로 전달할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkBaseUsedInInvalidWay">
        <source>The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.</source>
        <target state="translated">'base' 키워드가 잘못된 방식으로 사용되었습니다. 기본 호출은 클로저에 사용할 수 없습니다. 전용 멤버를 사용하여 기본 호출을 수행하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkVariableUsedInInvalidWay">
        <source>The variable '{0}' is used in an invalid way</source>
        <target state="translated">'{0}' 변수가 잘못된 방식으로 사용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTypeLessAccessibleThanType">
        <source>The type '{0}' is less accessible than the value, member or type '{1}' it is used in.</source>
        <target state="translated">{0}' 형식은 사용되는 '{1}' 값, 멤버 또는 형식보다 액세스하기 어렵습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSystemVoidOnlyInTypeof">
        <source>'System.Void' can only be used as 'typeof&lt;System.Void&gt;' in F#</source>
        <target state="translated">'System.Void'는 F#에서 'typeof&lt;System.Void&gt;'로만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorUseOfByref">
        <source>A type instantiation involves a byref type. This is not permitted by the rules of Common IL.</source>
        <target state="translated">형식 인스턴스에 byref 형식이 포함되어 있습니다. 이는 공통 IL의 규칙에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorContainsCallToRethrow">
        <source>Calls to 'reraise' may only occur directly in a handler of a try-with</source>
        <target state="translated">'reraise'에 대한 호출은 try-with의 처리기 내에서 직접 발생할 수만 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSplicingOnlyInQuotations">
        <source>Expression-splicing operators may only be used within quotations</source>
        <target state="translated">expression-splicing 연산자는 인용구 내에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassSplicing">
        <source>First-class uses of the expression-splicing operator are not permitted</source>
        <target state="translated">expression-splicing 연산자의 첫 번째 클래스 사용은 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassAddressOf">
        <source>First-class uses of the address-of operators are not permitted</source>
        <target state="translated">address-of 연산자의 첫 번째 클래스 사용은 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassRethrow">
        <source>First-class uses of the 'reraise' function is not permitted</source>
        <target state="translated">'reraise' 함수의 첫 번째 클래스 사용은 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAtThisPoint">
        <source>The byref typed value '{0}' cannot be used at this point</source>
        <target state="translated">byref 형식의 값 '{0}'을(를) 현재 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkLimitationsOfBaseKeyword">
        <source>'base' values may only be used to make direct calls to the base implementations of overridden members</source>
        <target state="translated">'base' 값은 재정의된 멤버의 기본 구현에 대한 직접 호출을 수행하는 데에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkObjCtorsCantUseExceptionHandling">
        <source>Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.</source>
        <target state="translated">개체 생성자는 개체 초기화 전에 try/with 및 try/finally를 직접 사용할 수 없습니다. 여기에는 이러한 구문의 사용을 자세히 설명할 수 있는 'for x in ...'과 같은 구문이 포함됩니다. 이는 공통 IL의 제한입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfAtThisPoint">
        <source>The address of the variable '{0}' cannot be used at this point</source>
        <target state="translated">'{0}' 변수의 주소를 현재 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressStaticFieldAtThisPoint">
        <source>The address of the static field '{0}' cannot be used at this point</source>
        <target state="translated">정적 필드 '{0}'의 주소를 현재 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressFieldAtThisPoint">
        <source>The address of the field '{0}' cannot be used at this point</source>
        <target state="translated">'{0}' 필드의 주소를 현재 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfArrayElementAtThisPoint">
        <source>The address of an array element cannot be used at this point</source>
        <target state="translated">배열 요소의 주소를 현재 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFirstClassFuncNoByref">
        <source>The type of a first-class function cannot contain byrefs</source>
        <target state="translated">첫 번째 클래스 함수의 형식에는 byref를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReturnTypeNoByref">
        <source>A method return type would contain byrefs which is not permitted</source>
        <target state="translated">메서드 반환 형식에 허용되지 않는 byref가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidCustAttrVal">
        <source>Invalid custom attribute value (not a constant or literal)</source>
        <target state="translated">사용자 지정 특성 값이 잘못되었습니다(상수 또는 리터럴이 아님).</target>
        <note />
      </trans-unit>
      <trans-unit id="chkAttrHasAllowMultiFalse">
        <source>The attribute type '{0}' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element.</source>
        <target state="translated">특성 형식 '{0}'에 'AllowMultiple=false'가 있습니다. 이 특성의 여러 인스턴스를 단일 언어 요소에 연결할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to its definition at or near '{2}'. This is an invalid forward reference.</source>
        <target state="translated">’{0}' 멤버가 잘못된 방식으로 사용되었습니다. '{1}'이(가) 정의되기 전에 '{2}' 또는 그 근처에서 해당 사용이 유추되었습니다. 이는 잘못된 전방 참조입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAsTopValue">
        <source>A byref typed value would be stored here. Top-level let-bound byref values are not permitted.</source>
        <target state="translated">byref 형식의 값이 여기에 저장됩니다. 최상위 let 바인딩 byref 값은 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReflectedDefCantSplice">
        <source>[&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">[&lt;ReflectedDefinition&gt;] 용어에는 접두사 스플라이스 연산자 '%'을(를) 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkEntryPointUsage">
        <source>A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence.</source>
        <target state="translated">'EntryPointAttribute' 특성을 사용하여 레이블이 지정된 함수는 컴파일 시퀀스에서 마지막 파일의 마지막 선언이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseCompiledForm">
        <source>compiled form of the union case</source>
        <target state="translated">공용 구조체 케이스의 컴파일 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseDefaultAugmentation">
        <source>default augmentation of the union case</source>
        <target state="translated">공용 구조체 케이스의 기본 확대</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameMethod">
        <source>The property '{0}' has the same name as a method in type '{1}'.</source>
        <target state="translated">{0}' 속성의 이름이 '{1}' 형식의 메서드와 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterSetterDoNotMatchAbstract">
        <source>The property '{0}' of type '{1}' has a getter and a setter that do not match. If one is abstract then the other must be as well.</source>
        <target state="translated">{1}' 형식의 '{0}' 속성에 일치하지 않는 getter와 setter가 있습니다. 하나가 추상 요소인 경우 다른 하나도 추상 요소여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameIndexer">
        <source>The property '{0}' has the same name as another property in type '{1}', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.</source>
        <target state="translated">{0}' 속성의 이름이 '{1}' 형식의 다른 속성과 같지만 하나는 인덱서 인수를 사용하고 다른 하나는 그렇지 않습니다. 속성 중 하나에 대한 인덱서 인수가 없을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCantStoreByrefValue">
        <source>A type would store a byref typed value. This is not permitted by Common IL.</source>
        <target state="translated">형식에 byref 형식의 값이 저장됩니다. 이는 공통 IL에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethod">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}'.</source>
        <target state="translated">메서드가 중복되었습니다. '{0}' 메서드의 이름 및 시그니처가 '{1}' 형식의 다른 메서드와 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodWithSuffix">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">메서드가 중복되었습니다. '{0}' 메서드의 이름 및 시그니처가 '{1}' 형식의 다른 메서드와 같습니다(튜플, 함수, 측정 단위 및/또는 제공된 형식을 지울 경우).</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodCurried">
        <source>The method '{0}' has curried arguments but has the same name as another method in type '{1}'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.</source>
        <target state="translated">{0}' 메서드에 커리된 인수가 있지만 '{1}' 형식의 다른 메서드와 이름이 같습니다. 커리된 인수가 있는 메서드를 오버로드할 수 없습니다. 튜플된 인수를 포함하는 메서드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCurriedMethodsCantHaveOutParams">
        <source>Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments</source>
        <target state="translated">커리된 인수가 있는 메서드는 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName' 또는 'CallerFilePath' 인수를 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateProperty">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}'.</source>
        <target state="translated">속성이 중복되었습니다. '{0}' 속성의 이름 및 시그니처가 '{1}' 형식의 다른 속성과 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicatePropertyWithSuffix">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">속성이 중복되었습니다. '{0}' 속성의 이름 및 시그니처가 '{1}' 형식의 다른 속성과 같습니다(튜플, 함수, 측정 단위 및/또는 제공된 형식을 지울 경우).</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedType">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type.</source>
        <target state="translated">메서드가 중복되었습니다. 추상 메서드 '{0}'의 이름 및 시그니처가 상속된 형식의 추상 메서드와 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedTypeWithSuffix">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">메서드가 중복되었습니다. 추상 메서드 '{0}'의 이름 및 시그니처가 상속된 형식의 추상 메서드와 같습니다(튜플, 함수, 측정 단위 및/또는 제공된 형식을 지울 경우).</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMultipleGenericInterfaceInstantiations">
        <source>This type implements the same interface at different generic instantiations '{0}' and '{1}'. This is not permitted in this version of F#.</source>
        <target state="translated">이 형식은 서로 다른 제네릭 인스턴스 '{0}' 및 '{1}'에서 같은 인터페이스를 구현합니다. 이는 이 버전의 F#에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkValueWithDefaultValueMustHaveDefaultValue">
        <source>The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check</source>
        <target state="translated">'DefaultValue' 특성을 사용하는 필드의 형식은 기본 초기화를 허용해야 합니다. 즉, 이러한 형식은 적절한 값으로 'null'을 가지거나 필드가 모두 기본 초기화를 허용하는 구조체 형식이어야 합니다. 'DefaultValue(false)'를 사용하여 이 검사를 사용하지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefInTypeAbbrev">
        <source>The type abbreviation contains byrefs. This is not permitted by F#.</source>
        <target state="translated">형식 약어에 byref가 포함되어 있습니다. 이는 F#에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefBoundVarUsedInSplice">
        <source>The variable '{0}' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.</source>
        <target state="translated">'{0}' 변수가 인용구 내에 바인딩되어 있지만 스플라이스된 식의 일부로 사용되었습니다. 범위를 벗어날 수 있으므로 이는 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericExprs">
        <source>Quotations cannot contain uses of generic expressions</source>
        <target state="translated">인용구에는 제네릭 식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericFunctions">
        <source>Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.</source>
        <target state="translated">인용구에는 제네릭 형식으로 유추되거나 선언되는 함수 정의를 포함할 수 없습니다. 형식 제약 조건을 추가하여 올바른 따옴표 붙은 식으로 만드세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainObjExprs">
        <source>Quotations cannot contain object expressions</source>
        <target state="translated">인용구에는 개체 식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainAddressOf">
        <source>Quotations cannot contain expressions that take the address of a field</source>
        <target state="translated">인용구에는 필드의 주소를 사용하는 식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainStaticFieldRef">
        <source>Quotations cannot contain expressions that fetch static fields</source>
        <target state="translated">인용구에는 정적 필드를 페치하는 식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainInlineIL">
        <source>Quotations cannot contain inline assembly code or pattern matching on arrays</source>
        <target state="translated">인용구에는 인라인 어셈블리 코드 또는 배열에 대한 패턴 일치를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainDescendingForLoops">
        <source>Quotations cannot contain descending for loops</source>
        <target state="translated">인용구에는 루프의 내림차순을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantFetchUnionIndexes">
        <source>Quotations cannot contain expressions that fetch union case indexes</source>
        <target state="translated">인용구에는 공용 구조체 케이스 인덱스를 페치하는 식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetUnionFields">
        <source>Quotations cannot contain expressions that set union case fields</source>
        <target state="translated">인용구에는 공용 구조체 케이스 필드를 설정하는 식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetExceptionFields">
        <source>Quotations cannot contain expressions that set fields in exception values</source>
        <target state="translated">인용구에는 예외 값에 필드를 설정하는 식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantRequireByref">
        <source>Quotations cannot contain expressions that require byref pointers</source>
        <target state="translated">인용구에는 byref 포인터를 필요로 하는 식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantCallTraitMembers">
        <source>Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call</source>
        <target state="translated">인용구에는 멤버 제약 조건을 호출하는 식 또는 암시적으로 멤버 제약 조건 호출로 확인되는 연산자 사용을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisConstant">
        <source>Quotations cannot contain this kind of constant</source>
        <target state="translated">인용구에는 이러한 종류의 상수를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisPatternMatch">
        <source>Quotations cannot contain this kind of pattern match</source>
        <target state="translated">인용구에는 이러한 종류의 패턴 일치를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainArrayPatternMatching">
        <source>Quotations cannot contain array pattern matching</source>
        <target state="translated">인용구에는 배열 패턴 일치를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisType">
        <source>Quotations cannot contain this kind of type</source>
        <target state="translated">인용구에는 이러한 종류의 형식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeCannotBeResolvedAtCompileTime">
        <source>The declared type parameter '{0}' cannot be used here since the type parameter cannot be resolved at compile time</source>
        <target state="translated">선언된 형식 매개 변수 '{0}'은(는) 컴파일 시간에 확인할 수 없으므로 여기에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCodeLessGeneric">
        <source>This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'.</source>
        <target state="translated">이 코드는 해당 주석에 표시된 것보다 일반적이지 않습니다. '_'을 사용하여 지정된 측정 단위는 '1', 즉 차원이 없는 것으로 결정되었습니다. 코드를 제네릭 형식으로 만들거나 '_'을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInferenceMaxDepth">
        <source>Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.</source>
        <target state="translated">형식 유추 문제가 너무 복잡합니다(최대 반복 깊이에 도달함). 형식 주석을 더 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectedArguments">
        <source>Expected arguments to an instance member</source>
        <target state="translated">인스턴스 멤버에 대한 인수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csIndexArgumentMismatch">
        <source>This indexer expects {0} arguments but is here given {1}</source>
        <target state="translated">이 인덱서에 {0}개의 인수가 필요하지만 여기에서는 {1}개가 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenFunction">
        <source>Expecting a type supporting the operator '{0}' but given a function type. You may be missing an argument to a function.</source>
        <target state="translated">'{0}' 연산자를 지원하는 형식이 필요하지만 함수 형식이 지정되었습니다. 함수에 대한 인수가 없을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenTuple">
        <source>Expecting a type supporting the operator '{0}' but given a tuple type</source>
        <target state="translated">'{0}' 연산자를 지원하는 형식이 필요한데 튜플 형식을 지정했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperator">
        <source>None of the types '{0}' support the operator '{1}'</source>
        <target state="translated">{0}' 형식에서 '{1}' 연산자를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperator">
        <source>The type '{0}' does not support the operator '{1}'</source>
        <target state="translated">{0}' 형식은 '{1}' 연산자를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperatorNullable">
        <source>None of the types '{0}' support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">{0}' 형식에서 '{1}' 연산자를 지원하지 않습니다. 'Microsoft.FSharp.Linq.NullableOperators' 모듈을 열어 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperatorNullable">
        <source>The type '{0}' does not support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">{0}' 형식은 '{1}' 연산자를 지원하지 않습니다. 'Microsoft.FSharp.Linq.NullableOperators' 모듈을 열어 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportConversion">
        <source>The type '{0}' does not support a conversion to the type '{1}'</source>
        <target state="translated">{0}' 형식은 '{1}' 형식으로의 변환을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is static</source>
        <target state="translated">{0}' 형식에 '{1}' 메서드(전체 이름: '{2}')가 있지만 정적 메서드입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsNotStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is not static</source>
        <target state="translated">{0}' 형식에 '{1}' 메서드(전체 이름: '{2}')가 있지만 정적 메서드가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csStructConstraintInconsistent">
        <source>The constraints 'struct' and 'not struct' are inconsistent</source>
        <target state="translated">제약 조건 'struct'와 'not struct'는 서로 일관되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value</source>
        <target state="translated">'{0}' 형식은 적절한 값으로 'null'을 가지지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNullableTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'.</source>
        <target state="translated">'{0}' 형식은 적절한 값으로 'null'을 가지지 않습니다. Nullable 형식에 null 값을 만들려면 'System.Nullable()'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison1">
        <source>The type '{0}' does not support the 'comparison' constraint because it has the 'NoComparison' attribute</source>
        <target state="translated">'{0}' 형식은 'NoComparison' 특성을 가지므로 'comparison' 제약 조건을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison2">
        <source>The type '{0}' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface</source>
        <target state="translated">'{0}' 형식은 'comparison' 제약 조건을 지원하지 않습니다. 예를 들어, 이 형식은 'System.IComparable' 인터페이스를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison3">
        <source>The type '{0}' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison</source>
        <target state="translated">'{0}' 형식은 'comparison' 제약 조건을 지원하지 않는 하나 이상의 구조적 요소 형식을 포함하는 레코드, 공용 구조체 또는 구조체이므로 'comparison' 제약 조건을 지원하지 않습니다. 이 형식의 경우 비교를 사용하지 말거나 형식에 'StructuralComparison' 특성을 추가하여 비교를 지원하지 않는 필드 형식을 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality1">
        <source>The type '{0}' does not support the 'equality' constraint because it has the 'NoEquality' attribute</source>
        <target state="translated">'{0}' 형식은 'NoEquality' 특성을 가지므로 'equality' 제약 조건을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality2">
        <source>The type '{0}' does not support the 'equality' constraint because it is a function type</source>
        <target state="translated">'{0}' 형식은 함수 형식이므로 'equality' 제약 조건을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality3">
        <source>The type '{0}' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality</source>
        <target state="translated">'{0}' 형식은 'equality' 제약 조건을 지원하지 않는 하나 이상의 구조적 요소 형식을 포함하는 레코드, 공용 구조체 또는 구조체이므로 'equality' 제약 조건을 지원하지 않습니다. 이 형식의 경우 같음 조건을 사용하지 말거나 형식에 'StructuralEquality' 특성을 추가하여 같음 조건을 지원하지 않는 필드 형식을 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotEnumType">
        <source>The type '{0}' is not a CLI enum type</source>
        <target state="translated">'{0}' 형식은 CLI 열거형 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeHasNonStandardDelegateType">
        <source>The type '{0}' has a non-standard delegate type</source>
        <target state="translated">'{0}' 형식은 비표준 대리자 형식을 가집니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotDelegateType">
        <source>The type '{0}' is not a CLI delegate type</source>
        <target state="translated">'{0}' 형식은 CLI 대리자 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeParameterCannotBeNullable">
        <source>This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values.</source>
        <target state="translated">이 형식 매개 변수는 'Nullable'로 인스턴스화할 수 없습니다. 이는 'Nullable' 값과 함께 사용할 때 일부 CLI 언어에서 'null'의 의미가 혼동되지 않도록 하기 위한 제한입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructType">
        <source>A generic construct requires that the type '{0}' is a CLI or F# struct type</source>
        <target state="translated">제네릭 구문을 사용하려면 '{0}' 형식이 CLI 또는 F# 구조체 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresUnmanagedType">
        <source>A generic construct requires that the type '{0}' is an unmanaged type</source>
        <target state="translated">제네릭 구문을 사용하려면 '{0}' 형식이 관리되지 않은 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeNotCompatibleBecauseOfPrintf">
        <source>The type '{0}' is not compatible with any of the types {1}, arising from the use of a printf-style format string</source>
        <target state="translated">’{0}' 형식은 printf 스타일의 서식 문자열을 사용함으로 인해 발생하는 어떤 {1} 형식과도 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresReferenceSemantics">
        <source>A generic construct requires that the type '{0}' have reference semantics, but it does not, i.e. it is a struct</source>
        <target state="translated">제네릭 구문을 사용하려면 '{0}' 형식에 참조 의미 체계가 있어야 하지만 없습니다. 즉, 형식이 구조체입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresNonAbstract">
        <source>A generic construct requires that the type '{0}' be non-abstract</source>
        <target state="translated">제네릭 구문을 사용하려면 '{0}' 형식이 비추상 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresPublicDefaultConstructor">
        <source>A generic construct requires that the type '{0}' have a public default constructor</source>
        <target state="translated">제네릭 구문을 사용하려면 '{0}' 형식에 public 기본 생성자가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInstantiationLengthMismatch">
        <source>Type instantiation length mismatch</source>
        <target state="translated">형식 인스턴스 길이가 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csOptionalArgumentNotPermittedHere">
        <source>Optional arguments not permitted here</source>
        <target state="translated">선택적 인수는 여기에 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotStatic">
        <source>{0} is not a static member</source>
        <target state="translated">{0}은(는) 정적 멤버가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotInstance">
        <source>{0} is not an instance member</source>
        <target state="translated">{0}은(는) 인스턴스 멤버가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentLengthMismatch">
        <source>Argument length mismatch</source>
        <target state="translated">인수 길이가 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentTypesDoNotMatch">
        <source>The argument types don't match</source>
        <target state="translated">인수 형식이 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodExpectsParams">
        <source>This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument</source>
        <target state="translated">이 메서드에서는 이 위치에 CLI 'params' 매개 변수가 필요합니다. 'params'는 다양한 수의 인수를 C#과 같은 언어의 메서드에 전달하는 방법입니다. 이 인수에 대한 배열을 전달하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible">
        <source>The member or object constructor '{0}' is not {1}</source>
        <target state="translated">멤버 또는 개체 생성자 '{0}'은(는) {1}이(가) 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible2">
        <source>The member or object constructor '{0}' is not {1}. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.</source>
        <target state="translated">멤버 또는 개체 생성자 '{0}'은(는) {1}이(가) 아닙니다. 전용 멤버는 선언 형식 내에서만 액세스할 수 있습니다. 보호된 멤버는 확장 형식에서만 액세스할 수 있으며 내부 람다 식에서는 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAStaticMethod">
        <source>{0} is not a static method</source>
        <target state="translated">{0}은(는) 정적 메서드가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAnInstanceMethod">
        <source>{0} is not an instance method</source>
        <target state="translated">{0}은(는) 인스턴스 메서드가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberHasNoArgumentOrReturnProperty">
        <source>The member or object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">멤버 또는 개체 생성자 '{0}'에 인수 또는 설정 가능한 반환 속성 '{1}'이(가) 없습니다. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorHasNoArgumentOrReturnProperty">
        <source>The object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">개체 생성자 '{0}'에 인수 또는 설정 가능한 반환 속성 '{1}'이(가) 없습니다. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csRequiredSignatureIs">
        <source>The required signature is {0}</source>
        <target state="translated">필요한 시그니처는 {0}입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'.</source>
        <target state="translated">멤버 또는 개체 생성자 '{0}'을(를) 사용하려면 {1}개의 인수가 필요합니다. 필요한 시그니처는 '{2}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch2">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'.</source>
        <target state="translated">멤버 또는 개체 생성자 '{0}'을(를) 사용하려면 {1}개의 인수가 더 필요합니다. 필요한 시그니처는 '{2}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch3">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">멤버 또는 개체 생성자 '{0}'을(를) 사용하려면 {1}개의 인수가 필요합니다. 필요한 시그니처는 '{2}'입니다. 누락된 인수의 이름에는 {3} 등이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch4">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">멤버 또는 개체 생성자 '{0}'을(를) 사용하려면 {1}개의 인수가 더 필요합니다. 필요한 시그니처는 '{2}'입니다. 누락된 인수의 이름에는 {3} 등이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityNamed">
        <source>The member or object constructor '{0}' requires {1} argument(s) but is here given {2} unnamed and {3} named argument(s). The required signature is '{4}'.</source>
        <target state="translated">멤버 또는 개체 생성자 '{0}'을(를) 사용하려면 {1}개의 인수가 필요하지만 여기에서는 {2}개의 명명되지 않은 인수와 {3}개의 명명된 인수가 지정되었습니다. 필요한 시그니처는 '{4}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArity">
        <source>The member or object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">멤버 또는 개체 생성자 '{0}'은(는) {1}개의 인수를 사용하지만 여기에서는 {2}개가 지정되었습니다. 필요한 시그니처는 '{3}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArity">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">개체 생성자 '{0}'은(는) {1}개의 인수를 사용하지만, 여기에서는 {2}개가 지정되었습니다. 필요한 시그니처는 '{3}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArityProp">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',').</source>
        <target state="translated">개체 생성자 '{0}'은(는) {1}개의 인수를 사용하지만, 여기에서는 {2}개가 지정되었습니다. 필요한 시그니처는 '{3}'입니다. 여러 인수로 속성에 값을 할당하는 경우 해당 인수를 쉼표(',')로 구분하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityType">
        <source>The member or object constructor '{0}' takes {1} type argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">멤버 또는 개체 생성자 '{0}'은(는) {1}개의 형식 인수를 사용하지만 여기에서는 {2}개가 지정되었습니다. 필요한 시그니처는 '{3}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberNotAccessible">
        <source>A member or object constructor '{0}' taking {1} arguments is not accessible from this code location. All accessible versions of method '{2}' take {3} arguments.</source>
        <target state="translated">{1}개의 인수를 사용하는 멤버 또는 개체 생성자 '{0}'은(는) 이 코드 위치에서 액세스할 수 없습니다. '{2}' 메서드의 액세스할 수 있는 모든 버전은 {3}개의 인수를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csIncorrectGenericInstantiation">
        <source>Incorrect generic instantiation. No {0} member named '{1}' takes {2} generic arguments.</source>
        <target state="translated">제네릭 인스턴스가 잘못되었습니다. 이름이 '{1}'인 {0} 멤버 중 {2}개의 제네릭 인수를 사용하는 멤버가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberOverloadArityMismatch">
        <source>The member or object constructor '{0}' does not take {1} argument(s). An overload was found taking {2} arguments.</source>
        <target state="translated">멤버 또는 개체 생성자 '{0}'은(는) {1}개의 인수를 사용하지 않습니다. {2}개의 인수를 사용하는 오버로드를 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments</source>
        <target state="translated">이름이 '{1}'인 {0} 멤버 또는 개체 생성자 중 {2}개의 인수를 사용하는 요소가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments2">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. Note the call to this member also provides {3} named arguments.</source>
        <target state="translated">이름이 '{1}'인 {0} 멤버 또는 개체 생성자 중 {2}개의 인수를 사용하는 요소가 없습니다. 이 멤버를 호출하면 {3}개의 명명된 인수도 제공됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments3">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. The named argument '{3}' doesn't correspond to any argument or settable return property for any overload.</source>
        <target state="translated">이름이 '{1}'인 {0} 멤버 또는 개체 생성자 중 {2}개의 인수를 사용하는 요소가 없습니다. 명명된 인수 '{3}'은(는) 오버로드에 대한 어떠한 인수 또는 설정 가능한 반환 속성에도 해당하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodNotFound">
        <source>Method or object constructor '{0}' not found</source>
        <target state="translated">메서드 또는 개체 생성자 '{0}'을(를) 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFound">
        <source>No overloads match for method '{0}'.</source>
        <target state="translated">'{0}' 메서드와 일치하는 오버로드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsOverloaded">
        <source>A unique overload for method '{0}' could not be determined based on type information prior to this program point. A type annotation may be needed.</source>
        <target state="translated">이 프로그램 지점 전의 형식 정보를 기반으로 '{0}' 메서드에 대한 고유 오버로드를 결정할 수 없습니다. 형식 주석이 필요할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCandidates">
        <source>Candidates:\n{0}</source>
        <target state="translated">후보:\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="parsDoCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on 'do' bindings, but '{0}' was given.</source>
        <target state="translated">액세스 가능성 한정자는 'do' 바인딩에서 허용되지 않지만, '{0}'이(가) 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInHashIf">
        <source>End of file in #if section begun at or after here</source>
        <target state="translated">#if 섹션의 파일 끝이 여기에서 또는 여기 뒤에서 시작되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInString">
        <source>End of file in string begun at or before here</source>
        <target state="translated">문자열의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimString">
        <source>End of file in verbatim string begun at or before here</source>
        <target state="translated">축자 문자열의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInComment">
        <source>End of file in comment begun at or before here</source>
        <target state="translated">주석의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInStringInComment">
        <source>End of file in string embedded in comment begun at or before here</source>
        <target state="translated">주석에 포함된 문자열의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimStringInComment">
        <source>End of file in verbatim string embedded in comment begun at or before here</source>
        <target state="translated">주석에 포함된 축자 문자열의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInIfOcaml">
        <source>End of file in IF-OCAML section begun at or before here</source>
        <target state="translated">IF-OCAML 섹션의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInDirective">
        <source>End of file in directive begun at or before here</source>
        <target state="translated">지시문의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoHashEndIfFound">
        <source>No #endif found for #if or #else</source>
        <target state="translated">#if 또는 #else에 대한 #endif를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIgnored">
        <source>Attributes have been ignored in this construct</source>
        <target state="translated">특성은 이 구문에서 무시되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInImplicitClassConstructors">
        <source>'use' bindings are not permitted in primary constructors</source>
        <target state="translated">'use' 바인딩은 기본 생성자에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInModules">
        <source>'use' bindings are not permitted in modules and are treated as 'let' bindings</source>
        <target state="translated">'use' 바인딩은 모듈에서 허용되지 않으며 'let' 바인딩으로 처리됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIntegerForLoopRequiresSimpleIdentifier">
        <source>An integer for loop must use a simple identifier</source>
        <target state="translated">루프의 정수에는 단순 식별자를 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyOneWithAugmentationAllowed">
        <source>At most one 'with' augmentation is permitted</source>
        <target state="translated">최대 하나의 'with' 확대가 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSemicolon">
        <source>A semicolon is not expected at this point</source>
        <target state="translated">여기서는 세미콜론이 필요하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFile">
        <source>Unexpected end of input</source>
        <target state="translated">예기치 않은 입력의 끝입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedVisibilityDeclaration">
        <source>Accessibility modifiers are not permitted here, but '{0}' was given.</source>
        <target state="translated">액세스 가능성 한정자는 여기에 허용되지 않지만, '{0}'이(가) 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyHashDirectivesAllowed">
        <source>Only '#' compiler directives may occur prior to the first 'namespace' declaration</source>
        <target state="translated">'#' 컴파일러 지시문만 첫 번째 'namespace' 선언 앞에 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityDeclarationsShouldComePriorToIdentifier">
        <source>Accessibility modifiers should come immediately prior to the identifier naming a construct</source>
        <target state="translated">액세스 가능성 한정자는 구문의 이름을 지정하는 식별자 바로 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNamespaceOrModuleNotBoth">
        <source>Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'</source>
        <target state="translated">파일은 네임스페이스 또는 모듈 선언으로 시작해야 하지만(예: 'namespace SomeNamespace.SubNamespace' 또는 'module SomeNamespace.SomeModule') 둘 다로 시작할 수는 없습니다. 네임스페이스 내에 모듈을 정의하려면 'module SomeModule = ...'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleAbbreviationMustBeSimpleName">
        <source>A module abbreviation must be a simple name, not a path</source>
        <target state="translated">모듈 약어는 경로가 아니라 단순 이름이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviation">
        <source>Ignoring attributes on module abbreviation</source>
        <target state="translated">모듈 약어의 특성을 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">'{0}' 액세스 가능성 특성이 모듈 약어에서 허용되지 않습니다. 모듈 약어는 항상 Private입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">'{0}' 표시 유형 특성이 모듈 약어에서 허용되지 않습니다. 모듈 약어는 항상 Private입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnClosedBlockInHashLight">
        <source>Unclosed block</source>
        <target state="translated">블록이 닫히지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBeginOrStruct">
        <source>Unmatched 'begin' or 'struct'</source>
        <target state="translated">'begin' 또는 'struct'의 짝이 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleDefnMustBeSimpleName">
        <source>A module name must be a simple name, not a path</source>
        <target state="translated">모듈 이름은 경로가 아니라 단순 이름이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEmptyModuleDefn">
        <source>Unexpected empty type moduleDefn list</source>
        <target state="translated">예기치 않은 빈 형식 moduleDefn 목록입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesMustComeBeforeVal">
        <source>Attributes should be placed before 'val'</source>
        <target state="translated">특성은 'val' 앞에 배치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesAreNotPermittedOnInterfaceImplementations">
        <source>Attributes are not permitted on interface implementations</source>
        <target state="translated">특성은 인터페이스 구현에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxError">
        <source>Syntax error</source>
        <target state="translated">구문 오류입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAugmentationsIllegalOnDelegateType">
        <source>Augmentations are not permitted on delegate type moduleDefns</source>
        <target state="translated">확대는 대리자 형식 moduleDefns에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedClassInterfaceOrStruct">
        <source>Unmatched 'class', 'interface' or 'struct'</source>
        <target state="translated">'class', 'interface' 또는 'struct'의 짝이 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyTypeDefinition">
        <source>A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'.</source>
        <target state="translated">형식 정의에는 하나 이상의 멤버 또는 기타 선언이 필요합니다. 빈 클래스, 구조체 또는 인터페이스를 정의하려는 경우에는 'type ... = class end', 'interface end' 또는 'struct end'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedWith">
        <source>Unmatched 'with' or badly formatted 'with' block</source>
        <target state="translated">'with'의 짝이 맞지 않거나 'with' 블록의 형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetOrSetRequired">
        <source>'get', 'set' or 'get,set' required</source>
        <target state="translated">'get', 'set' 또는 'get,set'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyClassCanTakeValueArguments">
        <source>Only class types may take value arguments</source>
        <target state="translated">클래스 형식만 값 인수를 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBegin">
        <source>Unmatched 'begin'</source>
        <target state="translated">'begin'의 짝이 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidDeclarationSyntax">
        <source>Invalid declaration syntax</source>
        <target state="translated">선언 구문이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetAndOrSetRequired">
        <source>'get' and/or 'set' required</source>
        <target state="translated">'get' 및/또는 'set'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAnnotationsOnGetSet">
        <source>Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'</source>
        <target state="translated">속성 getter 및 setter에 대한 형식 주석은 'get()' 또는 'set(v)' 뒤에 지정해야 합니다(예: 'with get() : string = ...').</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterMustHaveAtLeastOneArgument">
        <source>A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'</source>
        <target state="translated">getter 속성은 함수여야 합니다(예: 'get() = ...' 또는 'get(index) = ...').</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultipleAccessibilitiesForGetSet">
        <source>Multiple accessibilities given for property getter or setter</source>
        <target state="translated">속성 getter 또는 setter에 대해 여러 액세스 가능성이 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetSyntax">
        <source>Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '</source>
        <target state="translated">속성 setter는 'set value = ', 'set idx value = ' 또는 'set (idx1,...,idxN) value = ... '를 사용하여 정의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInterfacesHaveSameVisibilityAsEnclosingType">
        <source>Interfaces always have the same visibility as the enclosing type</source>
        <target state="translated">인터페이스의 표시 유형은 항상 바깥쪽 형식과 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAccessibilityModsIllegalForAbstract">
        <source>Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.</source>
        <target state="translated">액세스 가능성 한정자는 이 멤버에서 허용되지 않습니다. 추상 슬롯의 표시 유형은 항상 바깥쪽 형식과 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalOnInherit">
        <source>Attributes are not permitted on 'inherit' declarations</source>
        <target state="translated">특성은 'inherit' 선언에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityIllegalOnInherit">
        <source>Accessibility modifiers are not permitted on an 'inherits' declaration</source>
        <target state="translated">액세스 가능성 한정자는 'inherits' 선언에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInheritDeclarationsCannotHaveAsBindings">
        <source>'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding.</source>
        <target state="translated">'inherit' 선언에는 'as' 바인딩을 지정할 수 없습니다. 메서드를 재정의할 때 기본 클래스의 멤버에 액세스하려면 'base.SomeMember' 구문을 사용할 수 있습니다. 'base'는 키워드입니다. 이 'as' 바인딩을 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalHere">
        <source>Attributes are not allowed here</source>
        <target state="translated">특성은 여기에 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for type abbreviations</source>
        <target state="translated">액세스 가능성 한정자는 형식 약어에 대해 이 위치에 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumTypesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for enum types</source>
        <target state="translated">액세스 가능성 한정자는 열거형 형식에 대해 이 위치에 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAllEnumFieldsRequireValues">
        <source>All enum fields must be given values</source>
        <target state="translated">모든 열거형 필드에는 값을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInlineAssemblyCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on inline assembly code types</source>
        <target state="translated">액세스 가능성 한정자는 인라인 어셈블리 코드 형식에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIdentifier">
        <source>Unexpected identifier: '{0}'</source>
        <target state="translated">예기치 않은 식별자입니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnionCasesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">액세스 가능성 한정자는 공용 구조체 케이스에서 허용되지 않습니다. 표현 전체에 액세스 가능성을 지정하려면 'type U = internal ...' 또는 'type U = private ...'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on enumeration fields</source>
        <target state="translated">액세스 가능성 한정자는 열거형 필드에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsConsiderUsingSeparateRecordType">
        <source>Consider using a separate record type instead</source>
        <target state="translated">대신 별도의 레코드 형식을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsRecordFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">액세스 가능성 한정자는 레코드 필드에서 허용되지 않습니다. 표현 전체에 액세스 가능성을 지정하려면 'type R = internal ...' 또는 'type R = private ...'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsLetAndForNonRecBindings">
        <source>The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings</source>
        <target state="translated">비재귀적 바인딩을 위한 선언 형식 'let ... and ...'는 F# 코드에서 사용되지 않습니다. 대신 'let' 바인딩 시퀀스를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedParen">
        <source>Unmatched '('</source>
        <target state="translated">'('의 짝이 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessivePatternsShouldBeSpacedOrTupled">
        <source>Successive patterns should be separated by spaces or tupled</source>
        <target state="translated">연속된 패턴은 공백으로 구분하거나 튜플해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoMatchingInForLet">
        <source>No matching 'in' found for this 'let'</source>
        <target state="translated">이 'let'과 짝이 맞는 'in'을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorInReturnForLetIncorrectIndentation">
        <source>Error in the return expression for this 'let'. Possible incorrect indentation.</source>
        <target state="translated">이 'let'에 대한 반환 식에 오류가 있습니다. 들여쓰기가 잘못되었을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterLet">
        <source>The block following this '{0}' is unfinished. Every code block is an expression and must have a result. '{1}' cannot be the final code element in a block. Consider giving this block an explicit result.</source>
        <target state="translated">이 '{0}' 뒤에 오는 블록이 완료되지 않았습니다. 모든 코드 블록은 식이며 결과가 있어야 합니다. '{1}'이(가) 블록의 최종 코드 요소가 될 수 없습니다. 이 블록에 명시적 결과를 제공하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIncompleteIf">
        <source>Incomplete conditional. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">조건이 잘못되었습니다. 'if &lt;expr&gt; then &lt;expr&gt;' 또는 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAssertIsNotFirstClassValue">
        <source>'assert' may not be used as a first class value. Use 'assert &lt;expr&gt;' instead.</source>
        <target state="translated">'assert'는 첫 번째 클래스 값으로 사용할 수 없습니다. 대신 'assert &lt;expr&gt;'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">식별자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInOrEqualExpected">
        <source>'in' or '=' expected</source>
        <target state="translated">'in' 또는 '='가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsArrowUseIsLimited">
        <source>The use of '-&gt;' in sequence and computation expressions is limited to the form 'for pat in expr -&gt; expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions.</source>
        <target state="translated">'-&gt;'를 시퀀스 및 계산 식에 사용할 때는 'for pat in expr -&gt; expr' 형식을 사용해야 합니다. 'for ... in ... do ... yield...' 구문을 사용하면 보다 복잡한 시퀀스 식에서 요소를 생성할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessiveArgsShouldBeSpacedOrTupled">
        <source>Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized</source>
        <target state="translated">연속된 인수는 공백으로 구분하거나 튜플해야 하며 함수 또는 메서드 적용과 관련된 인수는 괄호로 묶어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracket">
        <source>Unmatched '['</source>
        <target state="translated">'['의 짝이 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingQualificationAfterDot">
        <source>Missing qualification after '.'</source>
        <target state="translated">'.' 뒤에 한정자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsParenFormIsForML">
        <source>In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array</source>
        <target state="translated">F# 코드에서는 'expr.[expr]'을 사용할 수 있습니다. 첫 번째 식이 배열임을 나타내기 위해 형식 주석이 필요할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuote">
        <source>Mismatched quotation, beginning with '{0}'</source>
        <target state="translated">짝이 맞지 않는 인용구('{0}'(으)로 시작)입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatched">
        <source>Unmatched '{0}'</source>
        <target state="translated">'{0}'의 짝이 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracketBar">
        <source>Unmatched '[|'</source>
        <target state="translated">'[|'의 짝이 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBrace">
        <source>Unmatched '{{'</source>
        <target state="translated">'{{'의 짝이 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsFieldBinding">
        <source>Field bindings must have the form 'id = expr;'</source>
        <target state="translated">필드 바인딩의 형식은 'id = expr;'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMemberIllegalInObjectImplementation">
        <source>This member is not permitted in an object implementation</source>
        <target state="translated">이 멤버는 개체 구현에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingFunctionBody">
        <source>Missing function body</source>
        <target state="translated">함수 본문이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxErrorInLabeledType">
        <source>Syntax error in labelled type argument</source>
        <target state="translated">레이블이 지정된 형식 인수에 구문 오류가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedInfixOperator">
        <source>Unexpected infix operator in type expression</source>
        <target state="translated">형식 식에 예기치 않은 중위 연산자가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultiArgumentGenericTypeFormDeprecated">
        <source>The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident&lt;typ,...,typ&gt;' instead</source>
        <target state="translated">'(typ,...,typ) ident' 구문은 F# 코드에서 사용되지 않습니다. 대신 'ident&lt;typ,...,typ&gt;'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidLiteralInType">
        <source>Invalid literal in type</source>
        <target state="translated">형식의 리터럴이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedOperatorForUnitOfMeasure">
        <source>Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'.</source>
        <target state="translated">측정 단위 식에 예기치 않은 중위 연산자가 있습니다. 올바른 연산자는 '*', '/' 및 '^'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIntegerLiteralForUnitOfMeasure">
        <source>Unexpected integer literal in unit-of-measure expression</source>
        <target state="translated">측정 단위 식에 예기치 않은 정수 리터럴이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedTypeParameter">
        <source>Syntax error: unexpected type parameter specification</source>
        <target state="translated">구문 오류: 예기치 않은 형식 매개 변수 지정입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuotationName">
        <source>Mismatched quotation operator name, beginning with '{0}'</source>
        <target state="translated">짝이 맞지 않는 인용구 연산자 이름('{0}'(으)로 시작)입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseMustBeginWithUpperCase">
        <source>Active pattern case identifiers must begin with an uppercase letter</source>
        <target state="translated">활성 패턴 케이스 식별자는 대문자로 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseContainsPipe">
        <source>The '|' character is not permitted in active pattern case identifiers</source>
        <target state="translated">'|' 문자는 활성 패턴 케이스 식별자에 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalDenominatorForMeasureExponent">
        <source>Denominator must not be 0 in unit-of-measure exponent</source>
        <target state="translated">측정 단위 지수에서 분모는 0일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoEqualShouldFollowNamespace">
        <source>No '=' symbol should follow a 'namespace' declaration</source>
        <target state="translated">'namespace' 선언 뒤에 '=' 기호가 오면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleStructEndDeprecated">
        <source>The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">'module ... = struct .. end' 구문은 F# 코드에서 사용되지 않습니다. 'module ... = begin .. end'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleSigEndDeprecated">
        <source>The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">'module ... : sig .. end' 구문은 F# 코드에서 사용되지 않습니다. 'module ... = begin .. end'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticFieldUsedWhenInstanceFieldExpected">
        <source>A static field was used where an instance field is expected</source>
        <target state="translated">인스턴스 필드가 필요한데 정적 필드가 사용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodNotAccessible">
        <source>Method '{0}' is not accessible from this code location</source>
        <target state="translated">'{0}' 메서드는 이 코드 위치에서 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplicitMeasureFollowingSlash">
        <source>Implicit product of measures following /</source>
        <target state="translated">/ 다음의 측정값에 대한 암시적 곱입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedMeasureAnon">
        <source>Unexpected SynMeasure.Anon</source>
        <target state="translated">예기치 않은 SynMeasure.Anon입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonZeroConstantCannotHaveGenericUnit">
        <source>Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.</source>
        <target state="translated">0이 아닌 상수에는 제네릭 단위를 지정할 수 없습니다. 제네릭 0을 사용하려면 0.0&lt;_&gt;을 작성하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSeqResultsUseYield">
        <source>In sequence expressions, results are generated using 'yield'</source>
        <target state="translated">시퀀스 식에서는 'yield'를 사용하여 결과가 생성됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedBigRationalConstant">
        <source>Unexpected big rational constant</source>
        <target state="translated">예기치 않은 큰 유리 상수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForUnitsOfMeasure">
        <source>Units-of-measure are only supported on float, float32, decimal, and integer types.</source>
        <target state="translated">측정 단위는 float, float32, decimal 및 부호 있는 정수 형식에 대해서만 지원됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstUint16Array">
        <source>Unexpected Const_uint16array</source>
        <target state="translated">예기치 않은 Const_uint16array입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstByteArray">
        <source>Unexpected Const_bytearray</source>
        <target state="translated">예기치 않은 Const_bytearray입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterRequiresName">
        <source>A parameter with attributes must also be given a name, e.g. '[&lt;Attribute&gt;] Name : Type'</source>
        <target state="translated">특성이 지정된 매개 변수에는 이름도 지정해야 합니다(예: '[&lt;Attribute&gt;] Name : Type').</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnValuesCannotHaveNames">
        <source>Return values cannot have names</source>
        <target state="translated">반환 값에는 이름을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberKindPropertyGetSetNotExpected">
        <source>MemberKind.PropertyGetSet only expected in parse trees</source>
        <target state="translated">MemberKind.PropertyGetSet은 구문 분석 트리에만 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainValues">
        <source>Namespaces cannot contain values. Consider using a module to hold your value declarations.</source>
        <target state="translated">네임스페이스에는 값을 포함할 수 없습니다. 모듈을 사용하여 값 선언을 저장하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainExtensionMembers">
        <source>Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.</source>
        <target state="translated">형식이 정의된 것과 같은 파일 및 네임스페이스 선언 그룹을 제외하고 네임스페이스는 확장 멤버를 포함할 수 없습니다. 모듈을 사용하여 확장 멤버의 선언을 저장하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributes">
        <source>Multiple visibility attributes have been specified for this identifier</source>
        <target state="translated">이 식별자에 대해 다중 표시 유형 특성이 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributesWithLet">
        <source>Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions.</source>
        <target state="translated">이 식별자에 대해 다중 표시 유형 특성이 지정되었습니다. 클래스의 'let' 바인딩은 식 안의 모든 'let' 바인딩과 마찬가지로 항상 Private입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForRelationalOperator">
        <source>The name '({0})' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">이름 '({0})'은(는) 멤버 이름으로 사용하면 안 됩니다. 형식에 대한 비교 의미 체계를 정의하려면 'System.IComparable' 인터페이스를 구현하세요. 다른 CLI 언어를 통해 사용할 정적 멤버를 정의하는 경우에는 이름 '{1}'을(를) 대신 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForEquality">
        <source>The name '({0})' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">이름 '({0})'은(는) 멤버 이름으로 사용하면 안 됩니다. 형식에 대한 같음 의미 체계를 정의하려면 'Object.Equals' 멤버를 재정의하세요. 다른 CLI 언어를 통해 사용할 정적 멤버를 정의하는 경우에는 이름 '{1}'을(를) 대신 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberName">
        <source>The name '({0})' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">이름 '({0})'은(는) 멤버 이름으로 사용하면 안 됩니다. 다른 CLI 언어를 통해 사용할 정적 멤버를 정의하는 경우에는 이름 '{1}'을(를) 대신 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameFixedTypes">
        <source>The name '({0})' should not be used as a member name because it is given a standard definition in the F# library over fixed types</source>
        <target state="translated">이름 '({0})'에는 고정 형식에 대한 F# 라이브러리의 표준 정의가 지정되어 있으므로 해당 이름을 멤버 이름으로 사용하면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionRelational">
        <source>The '{0}' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type.</source>
        <target state="translated">'{0}' 연산자는 일반적으로 다시 정의하면 안 됩니다. 특정 형식에 대한 오버로드된 비교 의미 체계를 정의하려면 해당 형식의 정의에서 'System.IComparable' 인터페이스를 구현하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionEquality">
        <source>The '{0}' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type.</source>
        <target state="translated">'{0}' 연산자는 일반적으로 다시 정의하면 안 됩니다. 형식에 대한 같음 의미 체계를 정의하려면 해당 형식의 정의에서 'Object.Equals' 멤버를 재정의하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinition">
        <source>The '{0}' operator should not normally be redefined. Consider using a different operator name</source>
        <target state="translated">'{0}' 연산자는 일반적으로 다시 정의하면 안 됩니다. 다른 연산자 이름을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexOperatorDefinition">
        <source>The '{0}' operator cannot be redefined. Consider using a different operator name</source>
        <target state="translated">'{0}' 연산자를 다시 정의할 수 없습니다. 다른 연산자 이름을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectModuleOrNamespaceParent">
        <source>Expected module or namespace parent {0}</source>
        <target state="translated">모듈 또는 네임스페이스 부모 {0}이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">구조체, 레코드 또는 공용 구조체 형식 '{0}'은(는) 'System.IComparable' 인터페이스를 명시적으로 구현합니다. 형식에 'CustomComparison' 특성을 적용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsGenericIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable&lt;_&gt;' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.</source>
        <target state="translated">구조체, 레코드 또는 공용 구조체 형식 '{0}'은(는) 'System.IComparable&lt;_&gt;' 인터페이스를 명시적으로 구현합니다. 형식에 'CustomComparison' 특성을 적용하고 제네릭이 아닌 인터페이스 System.IComparable에 대한 일관된 구현도 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">구조체, 레코드 또는 공용 구조체 형식 '{0}'은(는) 'System.IStructuralComparable' 인터페이스를 명시적으로 구현합니다. 형식에 'CustomComparison' 특성을 적용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordFieldInconsistentTypes">
        <source>This record contains fields from inconsistent types</source>
        <target state="translated">이 레코드에는 일관성이 없는 형식의 필드가 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportStubsCannotBeInlined">
        <source>DLLImport stubs cannot be inlined</source>
        <target state="translated">DLLImport 스텁은 인라인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCanOnlyBindThisAtMemberDeclaration">
        <source>Structs may only bind a 'this' parameter at member declarations</source>
        <target state="translated">구조체는 멤버 선언에서만 'this' 매개 변수를 바인딩할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedExprAtRecInfPoint">
        <source>Unexpected expression at recursive inference point</source>
        <target state="translated">재귀적 유추 지점에 예기치 않은 식이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLessGenericBecauseOfAnnotation">
        <source>This code is less generic than required by its annotations because the explicit type variable '{0}' could not be generalized. It was constrained to be '{1}'.</source>
        <target state="translated">명시적 형식 변수 '{0}'을(를) 일반화할 수 없으므로 이 코드는 해당 주석에 필요한 것보다 일반적이지 않습니다. 해당 변수는 '{1}'(으)로 제한되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstrainedTypeVariableCannotBeGeneralized">
        <source>One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types</source>
        <target state="translated">이 바인딩에 대한 하나 이상의 명시적 클래스 또는 함수 형식 변수가 다른 형식의 제약을 받으므로 해당 변수를 일반화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericParameterHasBeenConstrained">
        <source>A generic type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">제네릭 형식 매개 변수가 항상 '{0}'이(가) 되도록 제한하는 방식으로 해당 매개 변수가 사용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterHasBeenConstrained">
        <source>This type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">이 형식 매개 변수가 항상 '{0}'이(가) 되도록 제한하는 방식으로 해당 매개 변수가 사용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParametersInferredAreNotStable">
        <source>The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</source>
        <target state="translated">이 값에 대해 유추된 형식 매개 변수는 형식 약어를 지울 경우 불안정한 상태가 됩니다. 이는 형식 매개 변수를 삭제 또는 다시 정렬하는 형식 약어를 사용했기 때문입니다(예: \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a).\n이 값에 대한 형식 매개 변수를 명시적으로 선언하세요(예: \n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x)).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeParameterInvalid">
        <source>Explicit type parameters may only be used on module or member bindings</source>
        <target state="translated">명시적 형식 매개 변수는 모듈 또는 멤버 바인딩에 대해서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridingMethodRequiresAllOrNoTypeParameters">
        <source>You must explicitly declare either all or no type parameters when overriding a generic abstract method</source>
        <target state="translated">제네릭 추상 메서드를 재정의할 때는 모든 형식 매개 변수를 명시적으로 선언하거나 형식 매개 변수를 선언하지 않아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldsDoNotDetermineUniqueRecordType">
        <source>The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type</source>
        <target state="translated">이 레코드 식 또는 패턴의 필요한 형식 및 필드 레이블이 해당하는 레코드 형식을 고유하게 확인하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldAppearsTwiceInRecord">
        <source>The field '{0}' appears twice in this record expression or pattern</source>
        <target state="translated">'{0}' 필드가 이 레코드 식 또는 패턴에 두 번 나타납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnknownUnion">
        <source>Unknown union case</source>
        <target state="translated">알 수 없는 공용 구조체 케이스입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotSufficientlyGenericBecauseOfScope">
        <source>This code is not sufficiently generic. The type variable {0} could not be generalized because it would escape its scope.</source>
        <target state="translated">이 코드는 충분히 일반적이지 않습니다. 형식 변수 {0}을(를) 일반화하면 범위를 벗어나게 되므로 일반화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyRequiresExplicitTypeParameters">
        <source>A property cannot have explicit type parameters. Consider using a method instead.</source>
        <target state="translated">속성에는 명시적 형식 매개 변수를 지정할 수 없습니다. 대신 메서드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorCannotHaveTypeParameters">
        <source>A constructor cannot have explicit type parameters. Consider using a static construction method instead.</source>
        <target state="translated">생성자에는 명시적 형식 매개 변수를 지정할 수 없습니다. 대신 정적 생성 메서드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInstanceMemberRequiresTarget">
        <source>This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'.</source>
        <target state="translated">이 인스턴스 멤버에는 호출하는 개체를 나타내는 매개 변수가 필요합니다. 멤버를 정적 요소로 만들거나 'member x.Member(args) = ...' 표기법을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertyInSyntaxTree">
        <source>Unexpected source-level property specification in syntax tree</source>
        <target state="translated">구문 트리에 예기치 않은 소스 수준 속성 지정이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializerRequiresArgument">
        <source>A static initializer requires an argument</source>
        <target state="translated">정적 이니셜라이저를 사용하려면 인수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorRequiresArgument">
        <source>An object constructor requires an argument</source>
        <target state="translated">개체 생성자를 사용하려면 인수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticMemberShouldNotHaveThis">
        <source>This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'.</source>
        <target state="translated">이 정적 멤버에는 'this' 매개 변수가 있으면 안 됩니다. 'member Member(args) = ...' 표기법을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitStaticInitializerSyntax">
        <source>An explicit static initializer should use the syntax 'static new(args) = expr'</source>
        <target state="translated">명시적 정적 이니셜라이저는 'static new(args) = expr' 구문을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitObjectConstructorSyntax">
        <source>An explicit object constructor should use the syntax 'new(args) = expr'</source>
        <target state="translated">명시적 개체 생성자는 'new(args) = expr' 구문을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertySpec">
        <source>Unexpected source-level property specification</source>
        <target state="translated">예기치 않은 소스 수준 속성 지정입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionFormDeprecated">
        <source>This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions.</source>
        <target state="translated">이러한 형식의 개체 식은 F#에서 사용되지 않습니다. 'member this.MemberName ... = ...'을 사용하여 개체 식에 멤버 구현을 정의하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDeclaration">
        <source>Invalid declaration</source>
        <target state="translated">선언이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesInvalidInPatterns">
        <source>Attributes are not allowed within patterns</source>
        <target state="translated">특성은 패턴 내에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitTypeArguments">
        <source>The generic function '{0}' must be given explicit type argument(s)</source>
        <target state="translated">제네릭 함수 '{0}'에는 명시적 형식 인수를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoesNotAllowExplicitTypeArguments">
        <source>The method or function '{0}' should not be given explicit type argument(s) because it does not declare its type parameters explicitly</source>
        <target state="translated">'{0}' 메서드 또는 함수는 해당 형식 매개 변수를 명시적으로 선언하지 않으므로 이 함수에 명시적 형식 인수를 지정하면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterArityMismatch">
        <source>This value, type or method expects {0} type parameter(s) but was given {1}</source>
        <target state="translated">이 값, 형식 또는 메서드에는 {0}개의 형식 매개 변수가 필요한데 {1}개를 받았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultStructConstructorCall">
        <source>The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization</source>
        <target state="translated">구조체 형식의 기본 0 초기화 생성자는 구조체 형식의 모든 필드가 기본 초기화를 허용하는 경우에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindIDisposable">
        <source>Couldn't find Dispose on IDisposable, or it was overloaded</source>
        <target state="translated">IDisposable에서 Dispose를 찾을 수 없거나 Dispose가 오버로드되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonLiteralCannotBeUsedInPattern">
        <source>This value is not a literal and cannot be used in a pattern</source>
        <target state="translated">이 값은 리터럴이 아니며 패턴에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsReadonly">
        <source>This field is readonly</source>
        <target state="translated">이 필드는 읽기 전용입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameArgumentsMustAppearLast">
        <source>Named arguments must appear after all other arguments</source>
        <target state="translated">명명된 인수는 다른 모든 인수 뒤에 나타나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitLambda">
        <source>This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking {0} arguments.</source>
        <target state="translated">이 함수 값은 시그니처에 byref 인수가 포함된 대리자 형식을 생성하는 데 사용되고 있습니다. {0}개의 인수를 사용하는 명시적 람다 식을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCannotBeEnumerated">
        <source>The type '{0}' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method</source>
        <target state="translated">'{0}' 형식은 이 구문을 사용하여 열거할 수 있는 값을 포함하는 형식이 아닙니다. 즉, seq&lt;_&gt;, IEnumerable&lt;_&gt; 또는 IEnumerable과 호환되지 않으며 GetEnumerator 메서드를 가지지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMixtureOfRecursiveForms">
        <source>This recursive binding uses an invalid mixture of recursive forms</source>
        <target state="translated">이 재귀적 바인딩은 잘못된 재귀적 형식 조합을 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectConstructionExpression">
        <source>This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.</source>
        <target state="translated">올바른 개체 생성 식이 아닙니다. 명시적 개체 생성자에서는 대체 생성자를 호출하거나 개체의 모든 필드를 초기화한 후 상위 클래스 생성자에 대한 호출을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraint">
        <source>Invalid constraint</source>
        <target state="translated">제약 조건이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraintTypeSealed">
        <source>Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution</source>
        <target state="translated">제약 조건이 잘못되었습니다. 제약 조건에 사용된 형식이 봉인되었습니다. 즉, 최대 하나의 솔루션을 통해서만 해당 제약 조건을 만족시킬 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumConstraint">
        <source>An 'enum' constraint must be of the form 'enum&lt;type&gt;'</source>
        <target state="translated">'enum' 제약 조건의 형식은 'enum&lt;type&gt;'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNewConstraint">
        <source>'new' constraints must take one argument of type 'unit' and return the constructed type</source>
        <target state="translated">'new' 제약 조건은 'unit' 형식의 인수 하나를 사용하고 생성된 형식을 반환해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPropertyType">
        <source>This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -&gt; ty3'. Properties returning functions should have types of the form '(ty1 -&gt; ty2)'.</source>
        <target state="translated">이 속성에는 잘못된 형식이 있습니다. 다중 인덱서 인수를 사용하는 속성에는 'ty1 * ty2 -&gt; ty3'과 같은 형식이 있어야 합니다. 함수를 반환하는 속성에는 '(ty1 -&gt; ty2)'와 같은 형식이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureMarkWithAttribute">
        <source>Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.</source>
        <target state="translated">형식 매개 변수가 아니라 측정 단위 매개 변수가 필요합니다. 명시적 측정 단위 매개 변수는 [&lt;Measure&gt;] 특성으로 표시해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeParameter">
        <source>Expected type parameter, not unit-of-measure parameter</source>
        <target state="translated">측정 단위 매개 변수가 아니라 형식 매개 변수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeNotUnitOfMeasure">
        <source>Expected type, not unit-of-measure</source>
        <target state="translated">측정 단위가 아니라 형식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureNotType">
        <source>Expected unit-of-measure, not type</source>
        <target state="translated">형식이 아니라 측정 단위가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUnitsOfMeasurePrefix">
        <source>Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.</source>
        <target state="translated">측정 단위는 형식에 대한 접두사 인수로 사용할 수 없습니다. 꺾쇠 괄호 안에 후위 인수로 다시 작성하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnitsOfMeasureInvalidInTypeConstructor">
        <source>Unit-of-measure cannot be used in type constructor application</source>
        <target state="translated">측정 단위는 형식 생성자 적용 시 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireBuilderMethod">
        <source>This control construct may only be used if the computation expression builder defines a '{0}' method</source>
        <target state="translated">계산 식 작성기가 '{0}' 메서드를 정의하는 경우에만 이 제어 구문을 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoNestedTypes">
        <source>This type has no nested types</source>
        <target state="translated">이 형식에는 중첩 형식이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSymbolInTypeExpression">
        <source>Unexpected {0} in type expression</source>
        <target state="translated">형식 식에 예기치 않은 {0}이(가) 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterInvalidAsTypeConstructor">
        <source>Type parameter cannot be used as type constructor</source>
        <target state="translated">형식 매개 변수는 형식 생성자로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalSyntaxInTypeExpression">
        <source>Illegal syntax in type expression</source>
        <target state="translated">형식 식의 구문이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousUnitsOfMeasureCannotBeNested">
        <source>Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression</source>
        <target state="translated">익명 측정 단위는 다른 측정 단위 식 내에 중첩할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousTypeInvalidInDeclaration">
        <source>Anonymous type variables are not permitted in this declaration</source>
        <target state="translated">익명 형식 변수는 이 선언에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSlashInType">
        <source>Unexpected / in type</source>
        <target state="translated">형식에 예기치 않은 /가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedTypeArguments">
        <source>Unexpected type arguments</source>
        <target state="translated">예기치 않은 형식 인수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsOnlyOnMembers">
        <source>Optional arguments are only permitted on type members</source>
        <target state="translated">선택적 인수는 형식 멤버에 대해서만 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameNotBoundInPattern">
        <source>Name '{0}' not bound in pattern context</source>
        <target state="translated">이름 '{0}'은(는) 패턴 컨텍스트에 바인딩되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNonPrimitiveLiteralInPatternMatch">
        <source>Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when &lt;variable&gt; = &lt;constant&gt;' at the end of the match clause.</source>
        <target state="translated">기본 형식이 아닌 숫자 리터럴 상수는 NumericLiteral 모듈을 사용하여 다양한 형식에 매핑될 수 있으므로 패턴 일치에 사용할 수 없습니다. 변수로 바꾸고 일치 절의 끝에 'when &lt;variable&gt; = &lt;constant&gt;'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentUsage">
        <source>Type arguments cannot be specified here</source>
        <target state="translated">형식 인수는 여기에 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireActivePatternWithOneResult">
        <source>Only active patterns returning exactly one result may accept arguments</source>
        <target state="translated">하나의 결과를 반환하는 활성 패턴만 인수를 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidArgForParameterizedPattern">
        <source>Invalid argument to parameterized pattern label</source>
        <target state="translated">매개 변수가 있는 패턴 레이블에 대한 인수가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexIntoActivePatternArray">
        <source>Internal error. Invalid index into active pattern array</source>
        <target state="translated">내부 오류입니다. 활성 패턴 배열에 대한 인덱스가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseDoesNotTakeArguments">
        <source>This union case does not take arguments</source>
        <target state="translated">이 공용 구조체 케이스는 인수를 사용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseRequiresOneArgument">
        <source>This union case takes one argument</source>
        <target state="translated">이 공용 구조체 케이스는 하나의 인수를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseExpectsTupledArguments">
        <source>This union case expects {0} arguments in tupled form</source>
        <target state="translated">이 공용 구조체 케이스에는 튜플된 형식의 인수 {0}개가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotStatic">
        <source>Field '{0}' is not static</source>
        <target state="translated">'{0}'은(는) 정적 필드가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNotLiteralCannotBeUsedInPattern">
        <source>This field is not a literal and cannot be used in a pattern</source>
        <target state="translated">이는 리터럴 필드가 아니며 패턴에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireVarConstRecogOrLiteral">
        <source>This is not a variable, constant, active recognizer or literal</source>
        <target state="translated">변수, 상수, 활성 인식기 또는 리터럴이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPattern">
        <source>This is not a valid pattern</source>
        <target state="translated">올바른 패턴이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseWhenPatternGuard">
        <source>Character range matches have been removed in F#. Consider using a 'when' pattern guard instead.</source>
        <target state="translated">문자 범위 일치는 F#에서 제거되었습니다. 대신 'when' 패턴 가드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalPattern">
        <source>Illegal pattern</source>
        <target state="translated">패턴이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxErrorUnexpectedQMark">
        <source>Syntax error - unexpected '?' symbol</source>
        <target state="translated">구문 오류 - 예기치 않은 '?' 기호입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionCountMisMatch">
        <source>Expected {0} expressions, got {1}</source>
        <target state="translated">{0}개의 식이 필요한데 {1}개를 받았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExprUndelayed">
        <source>TcExprUndelayed: delayed</source>
        <target state="translated">TcExprUndelayed: 지연되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionRequiresSequence">
        <source>This expression form may only be used in sequence and computation expressions</source>
        <target state="translated">이 식 형식은 시퀀스 및 계산 식에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectExpressionSyntaxForm">
        <source>Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.</source>
        <target state="translated">개체 식이 잘못되었습니다. 재정의 또는 인터페이스가 없는 개체는 중괄호 없이 식 형식 'new Type(args)'을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectSequenceOrRecordExpression">
        <source>Invalid object, sequence or record expression</source>
        <target state="translated">개체, 시퀀스 또는 레코드 식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSequenceExpressionSyntaxForm">
        <source>Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq {{ ... }}'</source>
        <target state="translated">레코드, 시퀀스 또는 계산 식이 잘못되었습니다. 시퀀스 식의 형식은 'seq {{ ... }}'여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionWithIfRequiresParenthesis">
        <source>This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression</source>
        <target state="translated">이 목록 또는 배열 식에는 'if ... then ... else' 형식의 요소가 포함되어 있습니다. 식이 목록 또는 배열의 개별 요소임을 나타내고 이를 시퀀스 식을 사용하여 생성된 목록과 구분하려면 이 식을 괄호로 묶으세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseFormatString">
        <source>Unable to parse format string '{0}'</source>
        <target state="translated">서식 문자열 '{0}'을(를) 구문 분석할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcListLiteralMaxSize">
        <source>This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.</source>
        <target state="translated">이 목록 식은 목록 리터럴의 최대 크기를 초과합니다. 보다 큰 리터럴을 위한 배열을 사용하고 Array.ToList를 호출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresObjectConstructor">
        <source>The expression form 'expr then expr' may only be used as part of an explicit object constructor</source>
        <target state="translated">식 형식 'expr then expr'은 명시적 개체 생성자의 일부로만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentsCannotBeUsedInMemberTraits">
        <source>Named arguments cannot be given to member trait calls</source>
        <target state="translated">명명된 인수는 멤버 특성 호출에 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotValidEnumCaseName">
        <source>This is not a valid name for an enumeration case</source>
        <target state="translated">열거형 케이스에 대한 올바른 이름이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotMutable">
        <source>This field is not mutable</source>
        <target state="translated">이 필드는 변경할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresListArrayOrSequence">
        <source>This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq {{ ... }}', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements</source>
        <target state="translated">이 생성자는 목록, 배열 및 시퀀스 식 내에서만 사용할 수 있습니다(예: 'seq {{ ... }}', '[ ... ]' 또는 '[| ... |]' 형식의 식). 이러한 식은 'for ... in ... do ... yield...' 구문을 사용하여 요소를 생성합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpressions">
        <source>This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'.</source>
        <target state="translated">이 생성자는 계산 식 내에서만 사용할 수 있습니다. 일반 함수에서 값을 반환하려면 단순히 'return' 없이 식을 작성하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresSequenceOrComputations">
        <source>This construct may only be used within sequence or computation expressions</source>
        <target state="translated">이 생성자는 시퀀스 또는 계산 식 내에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpression">
        <source>This construct may only be used within computation expressions</source>
        <target state="translated">이 생성자는 계산 식 내에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexerExpression">
        <source>Invalid indexer expression</source>
        <target state="translated">인덱서 식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
        <source>The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints</source>
        <target state="translated">'expr.[idx]' 연산자가 이 프로그램 지점 전의 정보를 기반으로 하는 확인할 수 없는 형식의 개체에 사용되었습니다. 형식 제약 조건을 더 추가해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromVariableType">
        <source>Cannot inherit from a variable type</source>
        <target state="translated">변수 형식에서 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsOnTypeParametersCannotTakeArguments">
        <source>Calls to object constructors on type parameters cannot be given arguments</source>
        <target state="translated">형식 매개 변수의 개체 생성자에 대한 호출에는 인수를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCompiledNameAttributeMisused">
        <source>The 'CompiledName' attribute cannot be used with this language element</source>
        <target state="translated">'CompiledName' 특성은 이 언어 요소에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedTypeRequired">
        <source>'{0}' may only be used with named types</source>
        <target state="translated">'{0}'은(는) 명명된 형식에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritCannotBeUsedOnInterfaceType">
        <source>'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead.</source>
        <target state="translated">'inherit'은 인터페이스 형식에 대해 사용할 수 없습니다. 대신 'interface ... with ... end'를 사용하여 인터페이스를 구현하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewCannotBeUsedOnInterfaceType">
        <source>'new' cannot be used on interface types. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">'new'는 인터페이스 형식에 대해 사용할 수 없습니다. 대신 개체 식 '{{ new ... with ... }}'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractTypeCannotBeInstantiated">
        <source>Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">이 형식의 인스턴스가 abstract로 표시되었거나 메서드 중 일부에 구현이 지정되지 않았으므로 해당 인스턴스를 만들 수 없습니다. 대신 개체 식 '{{ new ... with ... }}'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIDisposableTypeShouldUseNew">
        <source>It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value</source>
        <target state="translated">IDisposable 인터페이스를 지원하는 개체는 생성 값이 리소스를 소유할 수도 있다는 것을 표시하기 위해 생성자를 나타내는 함수 값으로 'Type(args)' 또는 'Type'이 아니라 'new Type(args)' 구문을 사용하여 만드는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxCanOnlyBeUsedToCreateObjectTypes">
        <source>'{0}' may only be used to construct object types</source>
        <target state="translated">'{0}'은(는) 개체 형식을 생성하는 데에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresCall">
        <source>Constructors for the type '{0}' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.</source>
        <target state="translated">'{0}' 형식에 대한 생성자는 직접 또는 간접적으로 해당 암시적 개체 생성자를 호출해야 합니다. 레코드 식 대신 암시적 개체 생성자에 대한 호출을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUndefinedField">
        <source>The field '{0}' has been given a value, but is not present in the type '{1}'</source>
        <target state="translated">{0}' 필드에 값이 지정되었지만 해당 필드가 '{1}' 형식에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresAssignment">
        <source>No assignment given for field '{0}' of type '{1}'</source>
        <target state="translated">{1}' 형식의 '{0}' 필드에 대해 지정된 할당이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExtraneousFieldsGivenValues">
        <source>Extraneous fields have been given values</source>
        <target state="translated">잘못 사용된 필드에 값이 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
        <source>Only overrides of abstract and virtual members may be specified in object expressions</source>
        <target state="translated">추상 및 가상 멤버의 재정의만 개체 식에 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoAbstractOrVirtualMemberFound">
        <source>The member '{0}' does not correspond to any abstract or virtual method available to override or implement.</source>
        <target state="translated">'{0}' 멤버는 재정의 또는 구현할 수 있는 어떠한 추상 또는 가상 메서드에도 해당하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberFoundIsNotAbstractOrVirtual">
        <source>The type {0} contains the member '{1}' but it is not a virtual or abstract method that is available to override or implement.</source>
        <target state="translated">{0} 형식에 '{1}' 멤버가 포함되어 있지만 이 멤버는 재정의 또는 구현할 수 있는 가상 또는 추상 메서드가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatch">
        <source>The member '{0}' does not accept the correct number of arguments. {1} argument(s) are expected, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">{0}' 멤버가 올바른 수의 인수를 적용하지 않습니다. {1}개의 인수가 필요하지만 {2}개 지정되었습니다. 필요한 시그니처는 '{3}'입니다.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatchOneOverload">
        <source>The member '{0}' does not accept the correct number of arguments. One overload accepts {1} arguments, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">{0}' 멤버가 올바른 수의 인수를 받지 못했습니다. 하나의 오버로드는 {1}개의 인수를 받지만 {2}개가 주어졌습니다. 필요한 시그니처는 '{3}'입니다.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSimpleMethodNameRequired">
        <source>A simple method name is required here</source>
        <target state="translated">단순 메서드 이름이 여기에 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPredefinedTypeCannotBeUsedAsSuperType">
        <source>The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class</source>
        <target state="translated">System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate 및 System.Array 형식은 개체 식 또는 클래스에서 상위 형식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMustBeUsedWithNamedType">
        <source>'new' must be used with a named type</source>
        <target state="translated">'new'는 명명된 형식에 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCreateExtensionOfSealedType">
        <source>Cannot create an extension of a sealed type</source>
        <target state="translated">봉인된 형식의 확장을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoArgumentsForRecordValue">
        <source>No arguments may be given when constructing a record value</source>
        <target state="translated">레코드 값을 생성할 때는 인수를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoInterfaceImplementationForConstructionExpression">
        <source>Interface implementations cannot be given on construction expressions</source>
        <target state="translated">인터페이스 구현은 생성 식에서 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionCanOnlyBeUsedInClassTypes">
        <source>Object construction expressions may only be used to implement constructors in class types</source>
        <target state="translated">개체 생성 식은 클래스 형식의 생성자를 구현하는 데에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
        <source>Only simple bindings of the form 'id = expr' can be used in construction expressions</source>
        <target state="translated">'id = expr' 형식의 단순 바인딩만 생성 식에 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectsMustBeInitializedWithObjectExpression">
        <source>Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field</source>
        <target state="translated">개체는 상속된 개체 생성자를 호출하고 각 필드에 값을 할당하는 개체 생성 식으로 초기화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedInterfaceType">
        <source>Expected an interface type</source>
        <target state="translated">인터페이스 형식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorForInterfacesDoNotTakeArguments">
        <source>Constructor expressions for interfaces do not take arguments</source>
        <target state="translated">인터페이스에 대한 생성자 식에는 인수가 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresArguments">
        <source>This object constructor requires arguments</source>
        <target state="translated">이 개체 생성자에는 인수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewRequiresObjectConstructor">
        <source>'new' may only be used with object constructors</source>
        <target state="translated">'new'는 개체 생성자에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAtLeastOneOverrideIsInvalid">
        <source>At least one override did not correctly implement its corresponding abstract member</source>
        <target state="translated">하나 이상의 재정의가 해당하는 추상 멤버를 올바르게 구현하지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNumericLiteralRequiresModule">
        <source>This numeric literal requires that a module '{0}' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope</source>
        <target state="translated">이 숫자 리터럴을 사용하려면 FromZero, FromOne, FromInt32, FromInt64 및 FromString 함수를 정의하는 '{0}' 모듈이 범위 내에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRecordConstruction">
        <source>Invalid record construction</source>
        <target state="translated">레코드 생성이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresRecordTypes">
        <source>The expression form {{ expr with ... }} may only be used with record types. To build object types use {{ new Type(...) with ... }}</source>
        <target state="translated">식 형식 {{ expr with ... }}는 레코드 형식에만 사용할 수 있습니다. 개체 형식을 빌드하려면 {{ new Type(...) with ... }}를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritedTypeIsNotObjectModelType">
        <source>The inherited type is not an object model type</source>
        <target state="translated">상속된 형식이 개체 모델 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
        <source>Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors</source>
        <target state="translated">개체 생성 식, 즉 상속 지정이 있는 레코드 식은 개체 모델 형식의 생성자를 구현하는 데에만 사용할 수 있습니다. 'new ObjectType(args)'을 사용하여 생성자 외부에 개체 모델 형식의 인스턴스를 생성하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyRecordInvalid">
        <source>'{{ }}' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.</source>
        <target state="translated">'{{ }}'는 유효한 식이 아닙니다. 레코드에는 하나 이상의 필드를 포함해야 합니다. 빈 시퀀스는 Seq.empty 또는 빈 목록 '[]'를 사용하여 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordTypeNeedConstructor">
        <source>This type is not a record type. Values of class and struct types must be created using calls to object constructors.</source>
        <target state="translated">이 형식은 레코드 형식이 아닙니다. 클래스 및 구조체 형식의 값은 개체 생성자에 대한 호출을 사용하여 만들어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordType">
        <source>This type is not a record type</source>
        <target state="translated">이 형식은 레코드 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInComputationExpression">
        <source>This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder {{ ... }}'.</source>
        <target state="translated">이 구문은 계산 식의 일부로서 모호합니다. 중첩 식은 'let _ = (...)', 중첩 계산은 'let! res = builder {{ ... }}'를 사용하여 작성할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInSequenceExpression">
        <source>This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {{... }}'.</source>
        <target state="translated">이 구문은 시퀀스 식의 일부로서 모호합니다. 중첩 식은 'let _ = (...)', 중첩 시퀀스는 'yield! seq {{... }}'를 사용하여 작성할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoBangIllegalInSequenceExpression">
        <source>'do!' cannot be used within sequence expressions</source>
        <target state="translated">'do!'는 시퀀스 식 내에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseForInSequenceExpression">
        <source>The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead.</source>
        <target state="translated">'let! x = coll'은 시퀀스 식에 사용할 수 없습니다. 대신 'for x in coll'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryIllegalInSequenceExpression">
        <source>'try'/'with' cannot be used within sequence expressions</source>
        <target state="translated">'try'/'with'는 시퀀스 식 내에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseYieldBangForMultipleResults">
        <source>In sequence expressions, multiple results are generated using 'yield!'</source>
        <target state="translated">시퀀스 식에서는 'yield!'를 사용하여 다중 결과가 생성됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAssignment">
        <source>Invalid assignment</source>
        <target state="translated">할당이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfTypeName">
        <source>Invalid use of a type name</source>
        <target state="translated">형식 이름을 잘못 사용했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoAccessibleConstructor">
        <source>This type has no accessible object constructors</source>
        <target state="translated">이 형식에는 액세스 가능한 개체 생성자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfInterfaceType">
        <source>Invalid use of an interface type</source>
        <target state="translated">인터페이스 형식을 잘못 사용했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfDelegate">
        <source>Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'.</source>
        <target state="translated">대리 생성자를 잘못 사용했습니다. 'new Type(args)' 구문을 사용하거나 'Type(args)'만 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotStatic">
        <source>Property '{0}' is not static</source>
        <target state="translated">'{0}'은(는) 정적 속성이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotReadable">
        <source>Property '{0}' is not readable</source>
        <target state="translated">'{0}' 속성은 읽을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLookupMayNotBeUsedHere">
        <source>This lookup cannot be used here</source>
        <target state="translated">이 조회는 여기에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsStatic">
        <source>Property '{0}' is static</source>
        <target state="translated">'{0}'은(는) 정적 속성입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet1">
        <source>Property '{0}' cannot be set</source>
        <target state="translated">'{0}' 속성은 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsCannotBeFirstClassValues">
        <source>Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</source>
        <target state="translated">생성자는 인수에 적용해야 하며 첫 번째 클래스 값으로 사용할 수 없습니다. 필요한 경우 익명 함수 '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
        <source>The syntax 'expr.id' may only be used with record labels, properties and fields</source>
        <target state="translated">'expr.id' 구문은 레코드 레이블, 속성 및 필드에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsStatic">
        <source>Event '{0}' is static</source>
        <target state="translated">'{0}'은(는) 정적 이벤트입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsNotStatic">
        <source>Event '{0}' is not static</source>
        <target state="translated">'{0}'은(는) 정적 이벤트가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentDidNotMatch">
        <source>The named argument '{0}' did not match any argument or mutable property</source>
        <target state="translated">명명된 인수 '{0}'이(가) 어떠한 인수 또는 변경할 수 있는 속성과도 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverloadsCannotHaveCurriedArguments">
        <source>One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.</source>
        <target state="translated">이 메서드에 대한 하나 이상의 오버로드에 커리된 인수가 있습니다. 튜플된 형식의 인수를 사용하려면 이러한 멤버를 다시 디자인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnnamedArgumentsDoNotFormPrefix">
        <source>The unnamed arguments do not form a prefix of the arguments of the method called</source>
        <target state="translated">명명되지 않은 인수는 호출된 메서드의 인수에 대한 접두사를 형성하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
        <source>Static optimization conditionals are only for use within the F# library</source>
        <target state="translated">정적 최적화 조건은 F# 라이브러리 내에서만 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFormalArgumentIsNotOptional">
        <source>The corresponding formal argument is not optional</source>
        <target state="translated">해당하는 형식 인수는 필수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOptionalAssignmentToPropertyOrField">
        <source>Invalid optional assignment to a property or field</source>
        <target state="translated">속성 또는 필드에 대한 선택적 할당이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegateConstructorMustBePassed">
        <source>A delegate constructor must be passed a single function value</source>
        <target state="translated">대리 생성자에는 단일 함수 값을 전달해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindingCannotBeUseAndRec">
        <source>A binding cannot be marked both 'use' and 'rec'</source>
        <target state="translated">바인딩을 'use'와 'rec' 모두로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileOnlyOnClassLetBindings">
        <source>The 'VolatileField' attribute may only be used on 'let' bindings in classes</source>
        <target state="translated">'VolatileField' 특성은 클래스의 'let' 바인딩에 대해서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesAreNotPermittedOnLetBindings">
        <source>Attributes are not permitted on 'let' bindings in expressions</source>
        <target state="translated">특성은 식의 'let' 바인딩에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultValueAttributeRequiresVal">
        <source>The 'DefaultValue' attribute may only be used on 'val' declarations</source>
        <target state="translated">'DefaultValue' 특성은 'val' 선언에 대해서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeRequiresMembers">
        <source>The 'ConditionalAttribute' attribute may only be used on members</source>
        <target state="translated">'ConditionalAttribute' 특성은 멤버에 대해서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidActivePatternName">
        <source>This is not a valid name for an active pattern</source>
        <target state="translated">활성 패턴에 대한 올바른 이름이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEntryPointAttributeRequiresFunctionInModule">
        <source>The 'EntryPointAttribute' attribute may only be used on function definitions in modules</source>
        <target state="translated">'EntryPointAttribute' 특성은 모듈의 함수 정의에 대해서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesCannotBeInline">
        <source>Mutable values cannot be marked 'inline'</source>
        <target state="translated">변경할 수 있는 값은 'inline'으로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesMayNotHaveGenericParameters">
        <source>Mutable values cannot have generic parameters</source>
        <target state="translated">변경할 수 있는 값에는 제네릭 매개 변수를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesSyntax">
        <source>Mutable function values should be written 'let mutable f = (fun args -&gt; ...)'</source>
        <target state="translated">변경할 수 있는 함수 값은 'let mutable f = (fun args -&gt; ...)'로 작성해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyFunctionsCanBeInline">
        <source>Only functions may be marked 'inline'</source>
        <target state="translated">함수만 'inline'으로 표시할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalAttributesForLiteral">
        <source>A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes</source>
        <target state="translated">리터럴 값에는 [&lt;ThreadStatic&gt;] 또는 [&lt;ContextStatic&gt;] 특성을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeMutable">
        <source>A literal value cannot be marked 'mutable'</source>
        <target state="translated">리터럴 값은 'mutable'로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeInline">
        <source>A literal value cannot be marked 'inline'</source>
        <target state="translated">리터럴 값은 'inline'으로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotHaveGenericParameters">
        <source>Literal values cannot have generic parameters</source>
        <target state="translated">리터럴 값에는 제네릭 매개 변수를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstantExpression">
        <source>This is not a valid constant expression</source>
        <target state="translated">올바른 상수 식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsInaccessible">
        <source>This type is not accessible from this code location</source>
        <target state="translated">이 형식은 이 코드 위치에서 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConditionInImportedAssembly">
        <source>Unexpected condition in imported assembly: failed to decode AttributeUsage attribute</source>
        <target state="translated">가져온 어셈블리에 예기치 않은 상황이 발생했습니다. AttributeUsage 특성을 디코딩하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedAttributeTarget">
        <source>Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</source>
        <target state="translated">인식할 수 없는 특성 대상입니다. 올바른 특성 대상은 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElementUseDo">
        <source>This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module.</source>
        <target state="translated">이 특성은 이 언어 요소에 사용할 수 없습니다. 어셈블리 특성은 필요한 경우 F# 모듈 내에서 'do ()' 선언에 연결해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElement">
        <source>This attribute is not valid for use on this language element</source>
        <target state="translated">이 특성은 이 언어 요소에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgumentsCannotBeUsedInCustomAttribute">
        <source>Optional arguments cannot be used in custom attributes</source>
        <target state="translated">선택적 인수는 사용자 지정 특성에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet0">
        <source>This property cannot be set</source>
        <target state="translated">이 속성은 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyOrFieldNotFoundInAttribute">
        <source>This property or field was not found on this custom attribute type</source>
        <target state="translated">이 속성 또는 필드를 이 사용자 지정 특성 형식에서 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustBeReferenceType">
        <source>A custom attribute must be a reference type</source>
        <target state="translated">사용자 지정 특성은 참조 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeArgumentMismatch">
        <source>The number of args for a custom attribute does not match the expected number of args for the attribute constructor</source>
        <target state="translated">사용자 지정 특성에 대한 인수 수가 특성 생성자에 필요한 인수 수와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustInvokeConstructor">
        <source>A custom attribute must invoke an object constructor</source>
        <target state="translated">사용자 지정 특성은 개체 생성자를 호출해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeExpressionsMustBeConstructorCalls">
        <source>Attribute expressions must be calls to object constructors</source>
        <target state="translated">특성 식은 개체 생성자에 대한 호출이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedAttribute">
        <source>This attribute cannot be used in this version of F#</source>
        <target state="translated">이 특성은 이 버전의 F#에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidInlineSpecification">
        <source>Invalid inline specification</source>
        <target state="translated">인라인 지정이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBinding">
        <source>'use' bindings must be of the form 'use &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">'use' 바인딩은 'use &lt;var&gt; = &lt;expr&gt;' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractMembersIllegalInAugmentation">
        <source>Abstract members are not permitted in an augmentation - they must be defined as part of the type itself</source>
        <target state="translated">추상 멤버는 확대에서 허용되지 않으며 형식 자체의 일부로 정의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodOverridesIllegalHere">
        <source>Method overrides and interface implementations are not permitted here</source>
        <target state="translated">메서드 재정의 및 인터페이스 구현은 여기에 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoMemberFoundForOverride">
        <source>No abstract or interface member was found that corresponds to this override</source>
        <target state="translated">이 재정의에 해당하는 추상 또는 인터페이스 멤버를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverrideArityMismatch">
        <source>This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:{0}</source>
        <target state="translated">이 재정의는 해당하는 추상 멤버와 다른 수의 인수를 사용합니다. 다음 추상 멤버를 찾았습니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationAlreadyExists">
        <source>This method already has a default implementation</source>
        <target state="translated">이 메서드에 이미 기본 구현이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultAmbiguous">
        <source>The method implemented by this default is ambiguous</source>
        <target state="translated">이 기본값으로 구현된 메서드가 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoPropertyFoundForOverride">
        <source>No abstract property was found that corresponds to this override</source>
        <target state="translated">이 재정의에 해당하는 추상 속성을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractPropertyMissingGetOrSet">
        <source>This property overrides or implements an abstract property but the abstract property doesn't have a corresponding {0}</source>
        <target state="translated">이 속성은 추상 속성을 재정의하거나 구현하지만 추상 속성에 해당하는 {0}이(가) 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSignatureForSet">
        <source>Invalid signature for set member</source>
        <target state="translated">집합 멤버의 시그니처가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMember">
        <source>This new member hides the abstract member '{0}'. Rename the member or use 'override' instead.</source>
        <target state="translated">이 새 멤버는 추상 멤버 '{0}'을(를) 숨깁니다. 멤버의 이름을 바꾸거나 대신 'override'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMemberWithSuffix">
        <source>This new member hides the abstract member '{0}' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead.</source>
        <target state="translated">이 새 멤버는 튜플, 함수, 측정 단위 및/또는 제공된 형식이 지워지면 추상 멤버 '{0}'을(를) 숨깁니다. 멤버의 이름을 바꾸거나 대신 'override'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializersIllegalInInterface">
        <source>Interfaces cannot contain definitions of static initializers</source>
        <target state="translated">인터페이스에는 정적 이니셜라이저의 정의를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsIllegalInInterface">
        <source>Interfaces cannot contain definitions of object constructors</source>
        <target state="translated">인터페이스에는 개체 생성자의 정의를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOverridesIllegalInInterface">
        <source>Interfaces cannot contain definitions of member overrides</source>
        <target state="translated">인터페이스에는 멤버 재정의의 정의를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConcreteMembersIllegalInInterface">
        <source>Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.</source>
        <target state="translated">인터페이스에는 구체적인 멤버의 정의를 포함할 수 없습니다. 사용자 형식에 대한 생성자를 정의하여 해당 형식이 클래스임을 나타내야 할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsDisallowedInExceptionAugmentation">
        <source>Constructors cannot be specified in exception augmentations</source>
        <target state="translated">생성자는 예외 확대에 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCannotHaveConstructorWithNoArguments">
        <source>Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.</source>
        <target state="translated">구조체에는 인수가 없는 개체 생성자를 지정할 수 없습니다. 이는 구조체가 기본 생성자를 자동으로 지원하기 때문에 모든 CLI 언어에 적용되는 제한입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalForThisType">
        <source>Constructors cannot be defined for this type</source>
        <target state="translated">생성자는 이 형식에 대해 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
        <source>Recursive bindings that include member specifications can only occur as a direct augmentation of a type</source>
        <target state="translated">멤버 지정을 포함하는 재귀적 바인딩은 형식의 직접 확대로만 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimplePatternsInLetRec">
        <source>Only simple variable patterns can be bound in 'let rec' constructs</source>
        <target state="translated">단순 변수 패턴만 'let rec' 구문에 바인딩할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
        <source>Mutable 'let' bindings can't be recursive or defined in recursive modules or namespaces</source>
        <target state="translated">변경이 가능한 'let' 바인딩을 반복하거나 재귀 모듈 또는 네임스페이스에서 정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberIsNotSufficientlyGeneric">
        <source>This member is not sufficiently generic</source>
        <target state="translated">이 멤버는 충분히 일반적이지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralAttributeRequiresConstantValue">
        <source>A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. 'val x : int = 1'</source>
        <target state="translated">상수 값도 지정된 경우(예: 'val x : int = 1')에만 선언은 [&lt;Literal&gt;] 특성일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcValueInSignatureRequiresLiteralAttribute">
        <source>A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute</source>
        <target state="translated">[&lt;Literal&gt;] 특성이 있는 경우에만 선언의 시그니처에 값을 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThreadStaticAndContextStaticMustBeStatic">
        <source>Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread</source>
        <target state="translated">Thread 정적 및 Context 정적 변수는 정적이어야 하며 값이 각 새 스레드에서 기본값으로 초기화됨을 나타내기 위해 [&lt;DefaultValue&gt;] 특성을 가져야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileFieldsMustBeMutable">
        <source>Volatile fields must be marked 'mutable' and cannot be thread-static</source>
        <target state="translated">volatile 필드는 'mutable'로 표시해야 하며 Thread 정적일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUninitializedValFieldsMustBeMutable">
        <source>Uninitialized 'val' fields must be mutable and marked with the '[&lt;DefaultValue&gt;]' attribute. Consider using a 'let' binding instead of a 'val' field.</source>
        <target state="translated">초기화되지 않은 'val' 필드는 변경할 수 있어야 하며 '[&lt;DefaultValue&gt;]' 특성으로 표시되어야 합니다. 'val' 필드 대신 'let' 바인딩을 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticValFieldsMustBeMutableAndPrivate">
        <source>Static 'val' fields in types must be mutable, private and marked with the '[&lt;DefaultValue&gt;]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type.</source>
        <target state="translated">형식의 정적 'val' 필드는 변경할 수 있어야 하고 Private이어야 하며 '[&lt;DefaultValue&gt;]' 특성으로 표시되어야 합니다. 이러한 필드는 해당 형식에 맞게 'null' 또는 '0' 값으로 초기화됩니다. 클래스 형식에 'static let mutable' 바인딩도 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresName">
        <source>This field requires a name</source>
        <target state="translated">이 필드에는 이름이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNamespaceModuleTypeUnionName">
        <source>Invalid namespace, module, type or union case name</source>
        <target state="translated">네임스페이스, 모듈, 형식 또는 공용 구조체 케이스 이름이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalFormForExplicitTypeDeclaration">
        <source>Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -&gt; resTy'. Parentheses may be required around 'resTy'</source>
        <target state="translated">생성자에 대한 명시적 형식 선언의 형식은 'ty1 * ... * tyN -&gt; resTy'여야 합니다. 'resTy'를 괄호로 묶어야 할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnTypesForUnionMustBeSameAsType">
        <source>Return types of union cases must be identical to the type being defined, up to abbreviations</source>
        <target state="translated">공용 구조체 케이스의 반환 형식은 약어까지 정의 대상 형식과 동일해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumerationLiteral">
        <source>This is not a valid value for an enumeration literal</source>
        <target state="translated">열거형 리터럴에 대한 올바른 값이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType1">
        <source>The type '{0}' is not an interface type</source>
        <target state="translated">'{0}' 형식은 인터페이스 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDuplicateSpecOfInterface">
        <source>Duplicate specification of an interface</source>
        <target state="translated">인터페이스가 중복 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldValIllegalHere">
        <source>A field/val declaration is not permitted here</source>
        <target state="translated">필드/val 선언은 여기에 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritIllegalHere">
        <source>A inheritance declaration is not permitted here</source>
        <target state="translated">상속 선언은 여기에 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleRequiresQualifiedAccess">
        <source>This declaration opens the module '{0}', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.</source>
        <target state="translated">이 선언은 'RequireQualifiedAccess'로 표시된 '{0}' 모듈을 엽니다. 대신 모듈의 요소에 대해 한정된 참조를 사용하도록 코드를 조정하십시오(예: 'map' 대신 'List.map'). 이렇게 변경하면 라이브러리에 새 구문이 추가될 때 코드가 견고성을 잃지 않게 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenUsedWithPartiallyQualifiedPath">
        <source>This declaration opens the namespace or module '{0}' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.</source>
        <target state="translated">이 선언은 부분적으로 정규화된 경로를 통해 '{0}' 네임스페이스 또는 모듈을 엽니다. 네임스페이스의 전체 경로가 사용되도록 이 코드를 조정하세요. 이렇게 변경하면 F# 및 CLI 라이브러리에 새 구문이 추가될 때 코드가 더 견고해집니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLocalClassBindingsCannotBeInline">
        <source>Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.</source>
        <target state="translated">지역 클래스 바인딩은 inline으로 표시할 수 없습니다. 정의를 클래스 밖으로 이동하거나 inline으로 표시하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsMayNotHaveMembers">
        <source>Type abbreviations cannot have members</source>
        <target state="translated">형식 약어에는 멤버를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCheckedAtCompileTime">
        <source>As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.</source>
        <target state="translated">F# 4.1부터 형식 약어의 액세스 가능성은 컴파일 시간에 확인합니다. 형식 약어의 액세스 가능성을 변경하세요. 이 경고를 무시하면 런타임 오류가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsMayNotHaveMembers">
        <source>Enumerations cannot have members</source>
        <target state="translated">열거형에는 멤버를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembers">
        <source>Measure declarations may have only static members</source>
        <target state="translated">측정값 선언에는 정적 멤버만 있을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainDoBindings">
        <source>Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings</source>
        <target state="translated">구조체의 기본 생성자는 이러한 바인딩을 실행하지 않으므로 구조체에는 'do' 바인딩을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainLetBindings">
        <source>Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.</source>
        <target state="translated">구조체의 기본 생성자는 이러한 바인딩을 실행하지 않으므로 구조체에는 값 정의를 포함할 수 없습니다. 형식의 주 생성자에 인수를 더 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticLetBindingsRequireClassesWithImplicitConstructors">
        <source>Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">정적 값 정의는 기본 생성자가 포함된 형식에서만 사용할 수 있습니다. 'type X(args) = ...'와 같이 형식 정의에 인수를 추가해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembersNotConstructors">
        <source>Measure declarations may have only static members: constructors are not available</source>
        <target state="translated">측정값 선언에는 정적 멤버만 있을 수 있습니다. 생성자는 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberAndLocalClassBindingHaveSameName">
        <source>A member and a local class binding both have the name '{0}'</source>
        <target state="translated">멤버와 지역 클래스 바인딩 모두에 이름 '{0}'이(가) 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
        <source>Type abbreviations cannot have interface declarations</source>
        <target state="translated">형식 약어에는 인터페이스 선언을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsCannotHaveInterfaceDeclaration">
        <source>Enumerations cannot have interface declarations</source>
        <target state="translated">열거형에는 인터페이스 선언을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType0">
        <source>This type is not an interface type</source>
        <target state="translated">이 형식은 인터페이스 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllImplementedInterfacesShouldBeDeclared">
        <source>All implemented interfaces should be declared on the initial declaration of the type</source>
        <target state="translated">구현된 모든 인터페이스는 초기 형식 선언 시 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
        <source>A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type</source>
        <target state="translated">형식을 정의할 때 인터페이스의 명시적 구현이 지정되지 않았으므로 이 인터페이스의 기본 구현이 이미 추가되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberNotPermittedInInterfaceImplementation">
        <source>This member is not permitted in an interface implementation</source>
        <target state="translated">이 멤버는 인터페이스 구현에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclarationElementNotPermittedInAugmentation">
        <source>This declaration element is not permitted in an augmentation</source>
        <target state="translated">이 선언 요소는 확대에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotContainNestedTypes">
        <source>Types cannot contain nested type definitions</source>
        <target state="translated">형식에는 중첩 형식 정의를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeExceptionOrModule">
        <source>type, exception or module</source>
        <target state="translated">형식, 예외 또는 모듈입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeOrModule">
        <source>type or module</source>
        <target state="translated">형식 또는 모듈입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type.</source>
        <target state="translated">구조체, 레코드 또는 공용 구조체 형식 '{0}'은(는) 'System.IStructuralEquatable' 인터페이스를 명시적으로 구현합니다. 형식에 'CustomEquality' 특성을 적용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IEquatable&lt;_&gt;' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'.</source>
        <target state="translated">구조체, 레코드 또는 공용 구조체 형식 '{0}'은(는) 'System.IEquatable&lt;_&gt;' 인터페이스를 명시적으로 구현합니다. 형식에 'CustomEquality' 특성을 적용하고 제네릭이 아닌 재정의 'System.Object.Equals(obj)'에 대한 일관된 구현을 제공하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
        <source>Explicit type specifications cannot be used for exception constructors</source>
        <target state="translated">명시적 형식 지정은 예외 생성자에 대해 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsShouldNotHaveArgumentList">
        <source>Exception abbreviations should not have argument lists</source>
        <target state="translated">예외 약어에는 인수 목록을 지정하면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
        <source>Abbreviations for Common IL exceptions cannot take arguments</source>
        <target state="translated">공통 IL 예외에 대한 약어에는 인수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsMustReferToValidExceptions">
        <source>Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception</source>
        <target state="translated">예외 약어는 기존 예외 또는 System.Exception에서 파생되는 F# 형식을 참조해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
        <source>Abbreviations for Common IL exception types must have a matching object constructor</source>
        <target state="translated">공통 IL 예외 형식에 대한 약어에는 일치하는 개체 생성자가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotAnException">
        <source>Not an exception</source>
        <target state="translated">예외가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidModuleName">
        <source>Invalid module name</source>
        <target state="translated">모듈 이름이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeExtension">
        <source>Invalid type extension</source>
        <target state="translated">형식 확장이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesOfTypeSpecifyMultipleKindsForType">
        <source>The attributes of this type specify multiple kinds for the type</source>
        <target state="translated">이 형식의 특성은 형식에 대한 많은 종류를 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcKindOfTypeSpecifiedDoesNotMatchDefinition">
        <source>The kind of the type specified by its attributes does not match the kind implied by its definition</source>
        <target state="translated">해당 특성으로 지정된 형식의 종류가 해당 정의에 의해 암시된 종류와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDefinitionsCannotHaveTypeParameters">
        <source>Measure definitions cannot have type parameters</source>
        <target state="translated">측정값 정의에는 형식 매개 변수를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeRequiresDefinition">
        <source>This type requires a definition</source>
        <target state="translated">이 형식을 사용하려면 정의가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationHasTypeParametersMissingOnType">
        <source>This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C&lt;'a&gt; = C of ...'.</source>
        <target state="translated">이 형식 약어에는 간략화되는 형식에 나타나지 않는 하나 이상의 선언된 형식 매개 변수가 있습니다. 형식 약어는 간략화되는 형식에 있는 모든 선언된 형식 매개 변수를 사용해야 합니다. 하나 이상의 형식 매개 변수를 제거하거나 내부 형식을 래핑하는 구체적인 형식 정의(예: 'type C&lt;'a&gt; = C of ...'.)를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
        <source>Structs, interfaces, enums and delegates cannot inherit from other types</source>
        <target state="translated">구조체, 인터페이스, 열거형 및 대리자는 다른 형식에서 상속될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotInheritFromMultipleConcreteTypes">
        <source>Types cannot inherit from multiple concrete types</source>
        <target state="translated">형식은 여러 구체적인 형식에서 상속될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
        <source>Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute</source>
        <target state="translated">레코드, 공용 구조체, 약어 및 구조체 형식에는 'AllowNullLiteral' 특성을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
        <source>Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal</source>
        <target state="translated">'AllowNullLiteral' 특성이 지정된 형식은 null 리터럴도 사용할 수 있는 형식을 구현하거나 이 형식에서 상속되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericTypesCannotHaveStructLayout">
        <source>Generic types cannot be given the 'StructLayout' attribute</source>
        <target state="translated">제네릭 형식에는 'StructLayout' 특성을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyStructsCanHaveStructLayout">
        <source>Only structs and classes without primary constructors may be given the 'StructLayout' attribute</source>
        <target state="translated">기본 생성자가 없는 구조체 및 클래스에만 'StructLayout' 특성을 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRepresentationOfTypeHiddenBySignature">
        <source>The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.</source>
        <target state="translated">이 형식의 표현은 시그니처에 의해 숨겨져 있습니다. 형식의 특징을 나타내기 위해 이 형식에는 [&lt;Sealed&gt;], [&lt;Class&gt;] 또는 [&lt;Interface&gt;]와 같은 특성을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyClassesCanHaveAbstract">
        <source>Only classes may be given the 'AbstractClass' attribute</source>
        <target state="translated">클래스에만 'AbstractClass' 특성을 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
        <source>Only types representing units-of-measure may be given the 'Measure' attribute</source>
        <target state="translated">측정 단위를 나타내는 형식에만 'Measure' 특성을 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on overrides or interface implementations</source>
        <target state="translated">액세스 가능성 한정자는 재정의 또는 인터페이스 구현에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDU">
        <source>Discriminated union types are always sealed</source>
        <target state="translated">구분된 공용 구조체 형식은 항상 봉인됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedRecord">
        <source>Record types are always sealed</source>
        <target state="translated">레코드 형식은 항상 봉인됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedAssemblyCode">
        <source>Assembly code types are always sealed</source>
        <target state="translated">어셈블리 코드 형식은 항상 봉인됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedStruct">
        <source>Struct types are always sealed</source>
        <target state="translated">구조체 형식은 항상 봉인됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDelegate">
        <source>Delegate types are always sealed</source>
        <target state="translated">대리자 형식은 항상 봉인됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedEnum">
        <source>Enum types are always sealed</source>
        <target state="translated">열거형 형식은 항상 봉인됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesAndDelegatesCannotContainFields">
        <source>Interface types and delegate types cannot contain fields</source>
        <target state="translated">인터페이스 형식 및 대리자 형식에는 필드를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviatedTypesCannotBeSealed">
        <source>Abbreviated types cannot be given the 'Sealed' attribute</source>
        <target state="translated">간략화된 형식에는 'Sealed' 특성을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromSealedType">
        <source>Cannot inherit a sealed type</source>
        <target state="translated">봉인된 형식을 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromInterfaceType">
        <source>Cannot inherit from interface type. Use interface ... with instead.</source>
        <target state="translated">인터페이스 형식에서 상속할 수 없습니다. 대신 interface ... with를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructTypesCannotContainAbstractMembers">
        <source>Struct types cannot contain abstract members</source>
        <target state="translated">구조체 형식에는 추상 멤버를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesCannotBeSealed">
        <source>Interface types cannot be sealed</source>
        <target state="translated">인터페이스 형식은 봉인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDelegateSpecification">
        <source>Delegate specifications must be of the form 'typ -&gt; typ'</source>
        <target state="translated">대리자 지정의 형식은 'typ -&gt; typ'여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegatesCannotBeCurried">
        <source>Delegate specifications must not be curried types. Use 'typ * ... * typ -&gt; typ' for multi-argument delegates, and 'typ -&gt; (typ -&gt; typ)' for delegates returning function values.</source>
        <target state="translated">대리자 지정은 커리된 형식이어서는 안 됩니다. 다중 인수 대리자의 경우 'typ * ... * typ -&gt; typ', 함수 값을 반환하는 대리자의 경우 'typ -&gt; (typ -&gt; typ)'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForLiteralEnumeration">
        <source>Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char</source>
        <target state="translated">리터럴 열거형의 형식은 int, uint, int16, uint16, int64, uint64, byte, sbyte 또는 char이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclic">
        <source>This type definition involves an immediate cyclic reference through an abbreviation</source>
        <target state="translated">이 형식 정의에는 약어를 통해 직접 순환 참조가 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclicThroughInheritance">
        <source>This type definition involves an immediate cyclic reference through a struct field or inheritance relation</source>
        <target state="translated">이 형식 정의에는 구조체 필드 또는 상속 관계를 통해 직접 순환 참조가 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReservedSyntaxForAugmentation">
        <source>The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[&lt;Sealed&gt;] attribute to the type definition in the signature</source>
        <target state="translated">구문은 확대를 위해 예약되었습니다. 표현이 숨겨져 있지만 멤버를 가지고 있는 형식은 이제 'type X = ...'를 사용하여 시그니처에 선언됩니다. 시그니처에 있는 형식 정의에 '[&lt;Sealed&gt;] 특성을 추가해야 할 수도 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
        <source>Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.</source>
        <target state="translated">인터페이스, 대리자 또는 열거형 형식을 확장하는 멤버는 형식의 정의와 별도로 모듈에 배치해야 합니다. 이 모듈은 확장 멤버를 범위 내로 가져오기 위해 AutoOpen 특성을 가지거나 클라이언트 코드를 통해 명시적으로 열어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal">
        <source>One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '{0}'</source>
        <target state="translated">이 형식 확장에 대해 선언된 하나 이상의 형식 매개 변수에 형식 제약 조건이 없거나 잘못되어 '{0}'의 원본 형식 제약 조건과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
        <source>Type definitions may only have one 'inherit' specification and it must be the first declaration</source>
        <target state="translated">형식 정의에는 하나의 'inherit' 지정만 있을 수 있으며 이것이 첫 번째 선언이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
        <source>'let' and 'do' bindings must come before member and interface definitions in type definitions</source>
        <target state="translated">'let' 및 'do' 바인딩은 형식 정의에서 멤버 및 인터페이스 정의 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritDeclarationMissingArguments">
        <source>This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'.</source>
        <target state="translated">이 'inherit' 선언은 상속된 형식을 지정하지만 인수는 지정하지 않습니다. 인수를 제공하십시오(예: 'inherit BaseType(args)').</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritConstructionCallNotPartOfImplicitSequence">
        <source>This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">이 'inherit' 선언은 인수를 포함하지만 기본 생성자가 포함된 형식이 아닙니다. 'type X(args) = ...'와 같이 형식 정의에 인수를 추가해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLetAndDoRequiresImplicitConstructionSequence">
        <source>This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">이 정의는 기본 생성자가 포함된 형식에서만 사용할 수 있습니다. 'type X(args) = ...'와 같이 형식 정의에 인수를 추가해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveAugmentations">
        <source>Type abbreviations cannot have augmentations</source>
        <target state="translated">형식 약어에는 확대를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbreviationForNamespace">
        <source>The path '{0}' is a namespace. A module abbreviation may not abbreviate a namespace.</source>
        <target state="translated">'{0}' 경로가 네임스페이스입니다. 모듈 약어가 네임스페이스의 약어가 아닐 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeUsedInInvalidWay">
        <source>The type '{0}' is used in an invalid way. A value prior to '{1}' has an inferred type involving '{2}', which is an invalid forward reference.</source>
        <target state="translated">{0}' 형식이 잘못된 방식으로 사용되었습니다. '{1}' 앞에 있는 값에 '{2}'을(를) 사용하는 유추 형식이 있습니다. 이는 잘못된 전방 참조입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to the definition of '{2}', which is an invalid forward reference.</source>
        <target state="translated">{0}' 멤버가 잘못된 방식으로 사용되었습니다. '{2}'이(가) 정의되기 전에 '{1}'의 사용이 유추되었습니다. 이는 잘못된 전방 참조입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeAutoOpenWasIgnored">
        <source>The attribute 'AutoOpen(\"{0}\")' in the assembly '{1}' did not refer to a valid module or namespace in that assembly and has been ignored</source>
        <target state="translated">{1}' 어셈블리의 특성 'AutoOpen(\"{0}\")'이 해당 어셈블리의 올바른 모듈 또는 네임스페이스를 참조하지 않아 무시되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUndefinedValue">
        <source>Undefined value '{0}'</source>
        <target state="translated">정의되지 않은 값 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLabelNotFound">
        <source>Label {0} not found</source>
        <target state="translated">{0} 레이블을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilIncorrectNumberOfTypeArguments">
        <source>Incorrect number of type arguments to local call</source>
        <target state="translated">로컬 호출에 대한 형식 인수 수가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDynamicInvocationNotSupported">
        <source>Dynamic invocation of {0} is not supported</source>
        <target state="translated">{0}을(를) 동적으로 호출하는 작업은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfLiteralFieldIsInvalid">
        <source>Taking the address of a literal field is invalid</source>
        <target state="translated">리터럴 필드의 주소를 사용하는 것은 올바르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfValueHereIsInvalid">
        <source>This operation involves taking the address of a value '{0}' represented using a local variable or other special representation. This is invalid.</source>
        <target state="translated">이 작업을 수행하려면 지역 변수 또는 기타 특수 표현을 사용하여 표시된 값 '{0}'의 주소를 사용해야 합니다. 이는 올바르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilCustomMarshallersCannotBeUsedInFSharp">
        <source>Custom marshallers cannot be specified in F# code. Consider using a C# helper function.</source>
        <target state="translated">사용자 지정 마샬러는 F# 코드에 지정할 수 없습니다. C# 도우미 함수를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMarshalAsAttributeCannotBeDecoded">
        <source>The MarshalAs attribute could not be decoded</source>
        <target state="translated">MarshalAs 특성을 디코딩할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignatureForExternalFunctionContainsTypeParameters">
        <source>The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.</source>
        <target state="translated">이 외부 함수의 시그니처에 형식 매개 변수가 포함되어 있습니다. 인수 및 반환 형식을 제한하여 해당하는 C 함수의 형식을 나타내세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDllImportAttributeCouldNotBeDecoded">
        <source>The DllImport attribute could not be decoded</source>
        <target state="translated">DllImport 특성을 디코딩할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLiteralFieldsCannotBeSet">
        <source>Literal fields cannot be set</source>
        <target state="translated">리터럴 필드를 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStaticMethodIsNotLambda">
        <source>GenSetStorage: {0} was represented as a static method but was not an appropriate lambda expression</source>
        <target state="translated">GenSetStorage: {0}이(가) 정적 메서드로 표시되었지만 적절한 람다 식이 아니었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMutableVariablesCannotEscapeMethod">
        <source>Mutable variables cannot escape their method</source>
        <target state="translated">변경할 수 있는 변수는 해당 메서드를 벗어날 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedUnrealizedValue">
        <source>Compiler error: unexpected unrealized value</source>
        <target state="translated">컴파일러 오류: 예기치 않은 구현되지 않은 값이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMainModuleEmpty">
        <source>Main module of program is empty: nothing will happen when it is run</source>
        <target state="translated">프로그램의 주 모듈이 비어 있습니다. 프로그램 실행 시 아무 작업도 수행되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilTypeCannotBeUsedForLiteralField">
        <source>This type cannot be used for a literal field</source>
        <target state="translated">이 형식은 리터럴 필드에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedGetSetAnnotation">
        <source>Unexpected GetSet annotation on a property</source>
        <target state="translated">속성에 예기치 않은 GetSet 주석이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldOffsetAttributeCouldNotBeDecoded">
        <source>The FieldOffset attribute could not be decoded</source>
        <target state="translated">FieldOffset 특성을 디코딩할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStructLayoutAttributeCouldNotBeDecoded">
        <source>The StructLayout attribute could not be decoded</source>
        <target state="translated">StructLayout 특성을 디코딩할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDefaultAugmentationAttributeCouldNotBeDecoded">
        <source>The DefaultAugmentation attribute could not be decoded</source>
        <target state="translated">DefaultAugmentation 특성을 디코딩할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilReflectedDefinitionsCannotUseSliceOperator">
        <source>Reflected definitions cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">반영된 정의에는 접두사 스플라이스 연산자 '%'을(를) 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsProblemWithCodepage">
        <source>Problem with codepage '{0}': {1}</source>
        <target state="translated">코드 페이지 '{0}'에 문제가 있습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyright">
        <source>Copyright (c) Microsoft Corporation. All Rights Reserved.</source>
        <target state="translated">Copyright (C) Microsoft Corporation. All rights reserved.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyrightCommunity">
        <source>Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</source>
        <target state="translated">MIT 오픈 소스 라이선스에 따라 무료로 배포되었습니다. https://github.com/Microsoft/visualfsharp/blob/master/License.txt</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNameOfOutputFile">
        <source>Name of the output file (Short form: -o)</source>
        <target state="translated">출력 파일의 이름입니다(약식: -o).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildConsole">
        <source>Build a console executable</source>
        <target state="translated">콘솔 실행 파일을 빌드합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildWindows">
        <source>Build a Windows executable</source>
        <target state="translated">Windows 실행 파일을 빌드합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildLibrary">
        <source>Build a library (Short form: -a)</source>
        <target state="translated">라이브러리를 빌드합니다(약식: -a).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildModule">
        <source>Build a module that can be added to another assembly</source>
        <target state="translated">다른 어셈블리에 추가될 수 있는 모듈을 빌드합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDelaySign">
        <source>Delay-sign the assembly using only the public portion of the strong name key</source>
        <target state="translated">강력한 이름 키의 공개 부분만 사용하여 어셈블리 서명을 연기합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPublicSign">
        <source>Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed</source>
        <target state="translated">강력한 이름 키의 공개 부분만 사용하여 어셈블리를 공개 서명하고, 어셈블리를 서명됨으로 표시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWriteXml">
        <source>Write the xmldoc of the assembly to the given file</source>
        <target state="translated">지정한 파일에 어셈블리의 xmldoc를 씁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyFile">
        <source>Specify a strong name key file</source>
        <target state="translated">강력한 이름의 키 파일을 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyContainer">
        <source>Specify a strong name key container</source>
        <target state="translated">강력한 이름의 키 컨테이너를 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPlatform">
        <source>Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.</source>
        <target state="translated">이 코드를 실행할 수 있는 플랫폼을 x86, Itanium, x64, anycpu32bitpreferred 또는 anycpu로 제한합니다. 기본값은 anycpu입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoOpt">
        <source>Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.</source>
        <target state="translated">인라인 구문을 구현하는 데 반드시 필요한 최적화 정보만 포함합니다. 크로스 모듈 인라인 처리가 금지되지만 이진 호환성은 개선됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoInterface">
        <source>Don't add a resource to the generated assembly containing F#-specific metadata</source>
        <target state="translated">F# 관련 메타데이터를 포함하는 생성 어셈블리에 리소스를 추가하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSig">
        <source>Print the inferred interface of the assembly to a file</source>
        <target state="translated">어셈블리의 유추된 인터페이스를 파일에 출력합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsReference">
        <source>Reference an assembly (Short form: -r)</source>
        <target state="translated">어셈블리를 참조합니다(약식: -r).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32res">
        <source>Specify a Win32 resource file (.res)</source>
        <target state="translated">Win32 리소스 파일(.res)을 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32manifest">
        <source>Specify a Win32 manifest file</source>
        <target state="translated">Win32 매니페스트 파일을 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowin32manifest">
        <source>Do not include the default Win32 manifest</source>
        <target state="translated">기본 Win32 매니페스트를 포함하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedAllSource">
        <source>Embed all source files in the portable PDB file</source>
        <target state="translated">이식 가능한 PDB 파일에 모든 소스 파일 포함</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedSource">
        <source>Embed specific source files in the portable PDB file</source>
        <target state="translated">이식 가능한 PDB 파일에 특정 소스 파일을 포함합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLink">
        <source>Source link information file to embed in the portable PDB file</source>
        <target state="translated">이식 가능한 PDB 파일에 포함할 소스 링크 정보 파일</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbeddedSourceRequirePortablePDBs">
        <source>--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">--embed 스위치는 이식 가능한 PDB를 내보낼 때만 지원됩니다(--debug:portable 또는 --debug:embedded).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLinkRequirePortablePDBs">
        <source>--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">--sourcelink 스위치는 이식 가능한 PDB를 내보낼 때만 지원됩니다(--debug:portable 또는 --debug:embedded).</target>
        <note />
      </trans-unit>
      <trans-unit id="srcFileTooLarge">
        <source>Source file is too large to embed in a portable PDB</source>
        <target state="translated">소스 파일이 너무 커서 이식 가능한 PDB에 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResource">
        <source>Embed the specified managed resource</source>
        <target state="translated">지정한 관리되는 리소스를 포함합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLinkresource">
        <source>Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]</source>
        <target state="translated">resinfo 형식이 &lt;file&gt;[,&lt;string name&gt;[,public|private]]인 경우 지정한 리소스를 이 어셈블리에 연결합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebugPM">
        <source>Emit debug information (Short form: -g)</source>
        <target state="translated">디버그 정보를 내보냅니다(약식: -g).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebug">
        <source>Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file).</source>
        <target state="translated">디버깅 형식(full, portable, embedded, pdbonly)을 지정합니다. '{0}'은(는) 디버깅 형식을 지정하지 않은 경우 기본값이며 디버거를 실행 중인 프로그램에 연결할 수 있습니다. 'portable'은 플랫폼 간 형식이고, 'embedded'는 출력 파일에 포함된 플랫폼 간 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsOptimize">
        <source>Enable optimizations (Short form: -O)</source>
        <target state="translated">최적화를 사용합니다(약식: -O).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTailcalls">
        <source>Enable or disable tailcalls</source>
        <target state="translated">마무리 호출을 사용하거나 사용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDeterministic">
        <source>Produce a deterministic assembly (including module version GUID and timestamp)</source>
        <target state="translated">결정적 어셈블리(모듈 버전 GUID 및 타임스탬프 포함) 생성</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCrossoptimize">
        <source>Enable or disable cross-module optimizations</source>
        <target state="translated">크로스 모듈을 최적화하거나 최적화하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserrorPM">
        <source>Report all warnings as errors</source>
        <target state="translated">모든 경고를 오류로 보고합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserror">
        <source>Report specific warnings as errors</source>
        <target state="translated">특정 경고를 오류로 보고합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarn">
        <source>Set a warning level (0-5)</source>
        <target state="translated">경고 수준(0-5)을 설정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowarn">
        <source>Disable specific warning messages</source>
        <target state="translated">특정 경고 메시지를 사용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnOn">
        <source>Enable specific warnings that may be off by default</source>
        <target state="translated">특정 경고 사용(기본적으로 해제됨)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecked">
        <source>Generate overflow checks</source>
        <target state="translated">오버플로 검사를 생성합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDefine">
        <source>Define conditional compilation symbols (Short form: -d)</source>
        <target state="translated">조건부 컴파일 기호를 정의합니다(약식: -d).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsMlcompatibility">
        <source>Ignore ML compatibility warnings</source>
        <target state="translated">ML 호환성 경고를 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNologo">
        <source>Suppress compiler copyright message</source>
        <target state="translated">컴파일러 저작권 메시지를 표시하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelp">
        <source>Display this usage message (Short form: -?)</source>
        <target state="translated">이 사용법 메시지를 표시합니다(약식: -?).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFile">
        <source>Read response file for more options</source>
        <target state="translated">추가 옵션을 보려면 지시 파일을 읽으세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCodepage">
        <source>Specify the codepage used to read source files</source>
        <target state="translated">소스 파일을 읽는 데 사용되는 코드 페이지를 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUtf8output">
        <source>Output messages in UTF-8 encoding</source>
        <target state="translated">UTF-8 인코딩으로 메시지를 출력합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsFullpaths">
        <source>Output messages with fully qualified paths</source>
        <target state="translated">정규화된 경로를 사용하여 메시지를 출력합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLib">
        <source>Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)</source>
        <target state="translated">소스 파일 및 어셈블리를 확인하는 데 사용되는 포함 경로의 디렉터리를 지정합니다(약식: -I).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBaseaddress">
        <source>Base address for the library to be built</source>
        <target state="translated">빌드할 라이브러리의 기준 주소</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoframework">
        <source>Do not reference the default CLI assemblies by default</source>
        <target state="translated">기본 CLI 어셈블리를 기본적으로 참조하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStandalone">
        <source>Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated</source>
        <target state="translated">F# 라이브러리 및 이 라이브러리에 종속된 모든 참조 DLL을 생성되는 어셈블리에 정적으로 링크합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStaticlink">
        <source>Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.</source>
        <target state="translated">지정한 어셈블리 및 이 어셈블리에 종속된 모든 참조 DLL을 정적으로 링크합니다. DLL 이름이 아니라 어셈블리 이름을 사용하십시오(예: mylib).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResident">
        <source>Use a resident background compilation service to improve compiler startup times.</source>
        <target state="translated">컴파일러 시작 시간을 단축하기 위해 상주 백그라운드 컴파일 서비스를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPdb">
        <source>Name the output debug file</source>
        <target state="translated">출력 디버그 파일의 이름입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSimpleresolution">
        <source>Resolve assembly references using directory-based rules rather than MSBuild resolution</source>
        <target state="translated">MSBuild 확인이 아니라 디렉터리 기반의 규칙을 사용하여 어셈블리 참조를 확인합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedTarget">
        <source>Unrecognized target '{0}', expected 'exe', 'winexe', 'library' or 'module'</source>
        <target state="translated">인식할 수 없는 대상 '{0}'입니다. 'exe', 'winexe', 'library' 또는 'module'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedDebugType">
        <source>Unrecognized debug type '{0}', expected 'pdbonly' or 'full'</source>
        <target state="translated">인식할 수 없는 디버그 형식 '{0}'입니다. 'pdbonly' 또는 'full'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidWarningLevel">
        <source>Invalid warning level '{0}'</source>
        <target state="translated">경고 수준 '{0}'이(가) 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsShortFormOf">
        <source>Short form of '{0}'</source>
        <target state="translated">'{0}'의 약식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDeprecatedMsg">
        <source>The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.</source>
        <target state="translated">명령줄 옵션 '--cliroot'는 사용되지 않습니다. mscorlib.dll의 특정 복사본에 대한 명시적 참조를 대신 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDescription">
        <source>Use to override where the compiler looks for mscorlib.dll and framework components</source>
        <target state="translated">컴파일러가 mscorlib.dll 및 프레임워크 구성 요소를 찾는 위치를 재정의하는 데 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerOutputFiles">
        <source>- OUTPUT FILES -</source>
        <target state="translated">- 출력 파일 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerInputFiles">
        <source>- INPUT FILES -</source>
        <target state="translated">- 입력 파일 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerResources">
        <source>- RESOURCES -</source>
        <target state="translated">- 리소스 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerCodeGen">
        <source>- CODE GENERATION -</source>
        <target state="translated">- 코드 생성 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerAdvanced">
        <source>- ADVANCED -</source>
        <target state="translated">- 고급 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerMisc">
        <source>- MISCELLANEOUS -</source>
        <target state="translated">- 기타 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerLanguage">
        <source>- LANGUAGE -</source>
        <target state="translated">- 언어 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerErrsAndWarns">
        <source>- ERRORS AND WARNINGS -</source>
        <target state="translated">- 오류 및 경고 -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownArgumentToTheTestSwitch">
        <source>Unknown --test argument: '{0}'</source>
        <target state="translated">알 수 없는 --test 인수입니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownPlatform">
        <source>Unrecognized platform '{0}', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'</source>
        <target state="translated">인식할 수 없는 플랫폼 '{0}'입니다. 올바른 값은 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred' 및 'anycpu'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInternalNoDescription">
        <source>The command-line option '{0}' is for test purposes only</source>
        <target state="translated">명령줄 옵션 '{0}'은(는) 테스트를 위해서만 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLONoDescription">
        <source>The command-line option '{0}' has been deprecated</source>
        <target state="translated">명령줄 옵션 '{0}'은(는) 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLODeprecatedSuggestAlternative">
        <source>The command-line option '{0}' has been deprecated. Use '{1}' instead.</source>
        <target state="translated">명령줄 옵션 '{0}'은(는) 사용되지 않습니다. 대신 '{1}'을(를) 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLOHtmlDoc">
        <source>The command-line option '{0}' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.</source>
        <target state="translated">명령줄 옵션 '{0}'은(는) 사용되지 않습니다. HTML 문서 생성은 이제 FsHtmlDoc.exe를 통해 F# Power Pack에 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsConsoleColors">
        <source>Output warning and error messages in color</source>
        <target state="translated">경고 및 오류 메시지를 색으로 구분하여 출력</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUseHighEntropyVA">
        <source>Enable high-entropy ASLR</source>
        <target state="translated">높은 엔트로피 ASLR 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSubSystemVersion">
        <source>Specify subsystem version of this assembly</source>
        <target state="translated">이 어셈블리의 하위 시스템 버전을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTargetProfile">
        <source>Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib</source>
        <target state="translated">이 어셈블리의 대상 프레임워크 프로필을 지정하세요. 올바른 값은 mscorlib, netcore 또는 netstandard입니다. 기본값은 - mscorlib입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmitDebugInfoInQuotations">
        <source>Emit debug information in quotations</source>
        <target state="translated">인용구의 디버그 정보를 내보냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPreferredUiLang">
        <source>Specify the preferred output language culture name (e.g. es-ES, ja-JP)</source>
        <target state="translated">기본 출력 언어 문화권 이름 지정(예: es-ES, ja-JP)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoCopyFsharpCore">
        <source>Don't copy FSharp.Core.dll along the produced binaries</source>
        <target state="translated">FSharp.Core.dll을 생성된 바이너리와 함께 복사하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidSubSystemVersion">
        <source>Invalid version '{0}' for '--subsystemversion'. The version must be 4.00 or greater.</source>
        <target state="translated">'--subsystemversion'의 버전 '{0}'이(가) 잘못되었습니다. 버전은 4.00 이상이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidTargetProfile">
        <source>Invalid value '{0}' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.</source>
        <target state="translated">'--targetprofile'에 대한 값 '{0}'이(가) 잘못되었습니다. 올바른 값은 'mscorlib', 'netcore' 또는 'netstandard'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFullName">
        <source>Full name</source>
        <target state="translated">전체 이름</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoOtherOverloads">
        <source>and {0} other overloads</source>
        <target state="translated">및 기타 오버로드 {0}개</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoUnionCase">
        <source>union case</source>
        <target state="translated">공용 구조체 케이스</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActivePatternResult">
        <source>active pattern result</source>
        <target state="translated">활성 패턴 결과</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActiveRecognizer">
        <source>active recognizer</source>
        <target state="translated">활성 인식기</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoField">
        <source>field</source>
        <target state="translated">필드</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoEvent">
        <source>event</source>
        <target state="translated">이벤트</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoProperty">
        <source>property</source>
        <target state="translated">속성</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoExtension">
        <source>extension</source>
        <target state="translated">확장</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCustomOperation">
        <source>custom operation</source>
        <target state="translated">사용자 지정 연산</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoArgument">
        <source>argument</source>
        <target state="translated">인수</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoPatternVariable">
        <source>patvar</source>
        <target state="translated">patvar</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespace">
        <source>namespace</source>
        <target state="translated">네임스페이스</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoModule">
        <source>module</source>
        <target state="translated">모듈</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespaceOrModule">
        <source>namespace/module</source>
        <target state="translated">네임스페이스/모듈</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromFirst">
        <source>from {0}</source>
        <target state="translated">소스: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromNext">
        <source>also from {0}</source>
        <target state="translated">공동 소스: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedProperty">
        <source>generated property</source>
        <target state="translated">생성된 속성</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedType">
        <source>generated type</source>
        <target state="translated">생성된 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersKey">
        <source>Found by AssemblyFolders registry key</source>
        <target state="translated">AssemblyFolders 레지스트리 키로 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersExKey">
        <source>Found by AssemblyFoldersEx registry key</source>
        <target state="translated">AssemblyFoldersEx 레지스트리 키로 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionNetFramework">
        <source>.NET Framework</source>
        <target state="translated">.NET Framework</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionGAC">
        <source>Global Assembly Cache</source>
        <target state="translated">전역 어셈블리 캐시</target>
        <note />
      </trans-unit>
      <trans-unit id="recursiveClassHierarchy">
        <source>Recursive class hierarchy in type '{0}'</source>
        <target state="translated">'{0}' 형식에 재귀적 클래스 계층 구조가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRecursiveReferenceToAbstractSlot">
        <source>Invalid recursive reference to an abstract slot</source>
        <target state="translated">추상 슬롯에 대한 재귀 참조가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="eventHasNonStandardType">
        <source>The event '{0}' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit {1} and {2} methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent&lt;_&gt;' or 'IEvent&lt;_,_&gt;'.</source>
        <target state="translated">'{0}' 이벤트에 비표준 형식이 있습니다. 이 이벤트가 다른 CLI 언어로 선언된 경우 이벤트에 대한 명시적 {1} 및 {2} 메서드를 사용하여 이 이벤트에 액세스해야 할 수 있습니다. 이 이벤트가 F#으로 선언된 경우에는 이벤트의 형식을 'IDelegateEvent&lt;_&gt;' 또는 'IEvent&lt;_,_&gt;'의 인스턴스로 만드세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeIsNotAccessible">
        <source>The type '{0}' is not accessible from this code location</source>
        <target state="translated">'{0}' 형식은 이 코드 위치에서 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCasesAreNotAccessible">
        <source>The union cases or fields of the type '{0}' are not accessible from this code location</source>
        <target state="translated">'{0}' 형식의 공용 구조체 케이스 또는 필드는 이 코드 위치에서 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="valueIsNotAccessible">
        <source>The value '{0}' is not accessible from this code location</source>
        <target state="translated">값 '{0}'은(는) 이 코드 위치에서 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCaseIsNotAccessible">
        <source>The union case '{0}' is not accessible from this code location</source>
        <target state="translated">공용 구조체 케이스 '{0}'은(는) 이 코드 위치에서 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fieldIsNotAccessible">
        <source>The record, struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">레코드, 구조체 또는 클래스 필드 '{0}'은(는) 이 코드 위치에서 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="structOrClassFieldIsNotAccessible">
        <source>The struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">구조체 또는 클래스 필드 '{0}'은(는) 이 코드 위치에서 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="experimentalConstruct">
        <source>This construct is experimental</source>
        <target state="translated">이 구문은 실험적입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="noInvokeMethodsFound">
        <source>No Invoke methods found for delegate type</source>
        <target state="translated">대리자 형식에 대해 Invoke 메서드를 찾지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="moreThanOneInvokeMethodFound">
        <source>More than one Invoke method found for delegate type</source>
        <target state="translated">대리자 형식에 대해 둘 이상의 Invoke 메서드를 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="delegatesNotAllowedToHaveCurriedSignatures">
        <source>Delegates are not allowed to have curried signatures</source>
        <target state="translated">대리자는 커리된 시그니처를 가질 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrUnexpectedTExpr">
        <source>Unexpected Expr.TyChoose</source>
        <target state="translated">예기치 않은 Expr.TyChoose입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrLambdaLiftingOptimizationsNotApplied">
        <source>Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.</source>
        <target state="translated">참고: 로컬 제약 조건이 있는 이 제네릭 함수를 첫 번째 클래스 값으로 사용했으므로 람다 리프팅 최적화가 적용되지 않았습니다. 형식 제약 조건을 추가하면 이 상황이 해결될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifiersContainingAtSymbolReserved">
        <source>Identifiers containing '@' are reserved for use in F# code generation</source>
        <target state="translated">'@'을 포함하는 식별자는 F# 코드 생성에 사용할 수 있도록 예약되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifierReserved">
        <source>The identifier '{0}' is reserved for future use by F#</source>
        <target state="translated">'{0}' 식별자는 F#에서 나중에 사용할 수 있도록 예약되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="patcMissingVariable">
        <source>Missing variable '{0}'</source>
        <target state="translated">'{0}' 변수가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="patcPartialActivePatternsGenerateOneResult">
        <source>Partial active patterns may only generate one result</source>
        <target state="translated">부분 활성 패턴은 하나의 결과만 생성할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="impTypeRequiredUnavailable">
        <source>The type '{0}' is required here and is unavailable. You must add a reference to assembly '{1}'.</source>
        <target state="translated">{0}' 형식이 여기에 필요하지만 사용할 수 없습니다. '{1}' 어셈블리에 대한 참조를 추가해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferencedTypeCouldNotBeFoundInAssembly">
        <source>A reference to the type '{0}' in assembly '{1}' was found, but the type could not be found in that assembly</source>
        <target state="translated">{1}' 어셈블리에서 '{0}' 형식에 대한 참조를 찾았지만 이 어셈블리에서 해당 형식을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="impNotEnoughTypeParamsInScopeWhileImporting">
        <source>Internal error or badly formed metadata: not enough type parameters were in scope while importing</source>
        <target state="translated">내부 오류 또는 잘못된 형식의 메타데이터: 가져오기 작업을 수행하는 동안 범위 내의 형식 매개 변수가 부족했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferenceToDllRequiredByAssembly">
        <source>A reference to the DLL {0} is required by assembly {1}. The imported type {2} is located in the first assembly and could not be resolved.</source>
        <target state="translated">{1} 어셈블리에 {0} DLL에 대한 참조가 필요합니다. 가져온 형식 {2}은(는) 첫 번째 어셈블리에 있으며 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="impImportedAssemblyUsesNotPublicType">
        <source>An imported assembly uses the type '{0}' but that type is not public</source>
        <target state="translated">가져온 어셈블리가 '{0}' 형식을 사용하지만 해당 형식이 public이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButIncomplete">
        <source>The value '{0}' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible</source>
        <target state="translated">값 '{0}'이(가) inline으로 표시되었지만 해당 구현이 충분히 액세스할 수 없는 내부 또는 개인 함수를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButWasNotBoundInTheOptEnv">
        <source>The value '{0}' was marked inline but was not bound in the optimization environment</source>
        <target state="translated">값 '{0}'이(가) inline으로 표시되었지만 최적화 환경에 바인딩되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optLocalValueNotFoundDuringOptimization">
        <source>Local value {0} not found during optimization</source>
        <target state="translated">최적화하는 동안 로컬 값 {0}을(를) 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineHasUnexpectedValue">
        <source>A value marked as 'inline' has an unexpected value</source>
        <target state="translated">'inline'으로 표시된 값에 예기치 않은 값이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineCouldNotBeInlined">
        <source>A value marked as 'inline' could not be inlined</source>
        <target state="translated">'inline'으로 표시된 값은 인라인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optFailedToInlineValue">
        <source>Failed to inline the value '{0}' marked 'inline', perhaps because a recursive value was marked 'inline'</source>
        <target state="translated">'inline'으로 표시된 값 '{0}'을(를) 인라인하지 못했습니다. 재귀 값이 'inline'으로 표시된 것 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optRecursiveValValue">
        <source>Recursive ValValue {0}</source>
        <target state="translated">재귀 ValValue {0}입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltIncorrentIndentationOfIn">
        <source>The indentation of this 'in' token is incorrect with respect to the corresponding 'let'</source>
        <target state="translated">이 'in' 토큰의 들여쓰기가 해당하는 'let'과 관련하여 올바르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltTokenIsOffsideOfContextStartedEarlier">
        <source>Possible incorrect indentation: this token is offside of context started at position {0}. Try indenting this token further or using standard formatting conventions.</source>
        <target state="translated">들여쓰기가 잘못되었을 수 있습니다. 이 토큰은 {0} 위치에서 시작된 컨텍스트를 벗어납니다. 이 토큰을 더 들여쓰거나 표준 서식 규칙을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltSeparatorTokensOfPatternMatchMisaligned">
        <source>The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.</source>
        <target state="translated">이 패턴 일치의 규칙을 구분하는 '|' 토큰의 한 열이 잘못 맞춤되어 있습니다. 코드를 다시 맞추거나 들여쓰기를 더 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidModuleExprType">
        <source>Invalid module/expression/type</source>
        <target state="translated">모듈/식/형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationNeededToDisambiguateTypesWithSameName">
        <source>Multiple types exist called '{0}', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '{1}'.</source>
        <target state="translated">{0}'(이)라는 형식이 여러 개 있으며 이러한 형식에 서로 다른 수의 제네릭 매개 변수가 사용되고 있습니다. 형식 확인을 구분하기 위한 형식 인스턴스를 제공하십시오(예: '{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationIsMissingAndCouldNotBeInferred">
        <source>The instantiation of the generic type '{0}' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '{1}'.</source>
        <target state="translated">제네릭 형식 '{0}'의 인스턴스가 없으며 이 멤버의 반환 형식 또는 인수로부터 해당 인스턴스를 유추할 수 없습니다. 이 형식에 액세스할 때 형식 인스턴스를 제공하십시오(예: '{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="nrGlobalUsedOnlyAsFirstName">
        <source>'global' may only be used as the first name in a qualified path</source>
        <target state="translated">'global'은 정규화된 경로에서 첫 번째 이름으로만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrIsNotConstructorOrLiteral">
        <source>This is not a constructor or literal, or a constructor is being used incorrectly</source>
        <target state="translated">생성자 또는 리터럴이 아니거나 생성자가 잘못된 방식으로 사용되고 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnexpectedEmptyLongId">
        <source>Unexpected empty long identifier</source>
        <target state="translated">예기치 않은 빈 긴 식별자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordDoesNotContainSuchLabel">
        <source>The record type '{0}' does not contain a label '{1}'.</source>
        <target state="translated">레코드 종류 '{0}'에 '{1}' 레이블이 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidFieldLabel">
        <source>Invalid field label</source>
        <target state="translated">필드 레이블이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidExpression">
        <source>Invalid expression '{0}'</source>
        <target state="translated">'{0}' 식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrNoConstructorsAvailableForType">
        <source>No constructors are available for the type '{0}'</source>
        <target state="translated">'{0}' 형식에 대해 사용할 수 있는 생성자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnionTypeNeedsQualifiedAccess">
        <source>The union type for union case '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('{1}') in the name you are using.</source>
        <target state="translated">공용 구조체 케이스 '{0}'에 대한 공용 구조체 형식은 RequireQualifiedAccessAttribute로 정의됩니다. 사용 중인 이름에 공용 구조체 형식('{1}') 이름을 포함하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordTypeNeedsQualifiedAccess">
        <source>The record type for the record field '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('{1}') in the name you are using.</source>
        <target state="translated">레코드 필드 '{0}'에 대한 레코드 타입은 RequireQualifiedAccessAttribute로 정의됩니다. 사용 중인 이름에 레코드 타입('{1}') 이름을 포함하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingPdb">
        <source>Unexpected error creating debug information file '{0}'</source>
        <target state="translated">디버그 정보 파일 '{0}'을(를) 만드는 동안 예기치 않은 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideIntegerRange">
        <source>This number is outside the allowable range for this integer type</source>
        <target state="translated">이 숫자는 이 정수 형식에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexCharNotAllowedInOperatorNames">
        <source>'{0}' is not permitted as a character in operator names and is reserved for future use</source>
        <target state="translated">'{0}'은(는) 연산자 이름에서 허용되는 문자가 아니며 나중에 사용할 수 있도록 예약되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexUnexpectedChar">
        <source>Unexpected character '{0}'</source>
        <target state="translated">예기치 않은 '{0}' 문자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteArrayCannotEncode">
        <source>This byte array literal contains characters that do not encode as a single byte</source>
        <target state="translated">이 바이트 배열 리터럴에는 단일 바이트로 인코딩되지 않는 문자가 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIdentEndInMarkReserved">
        <source>Identifiers followed by '{0}' are reserved for future use</source>
        <target state="translated">식별자 다음에 '{0}'이(가) 있는 형식은 나중에 사용할 수 있도록 예약되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSigned">
        <source>This number is outside the allowable range for 8-bit signed integers</source>
        <target state="translated">이 숫자는 부호 있는 8비트 정수에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSignedHex">
        <source>This number is outside the allowable range for hexadecimal 8-bit signed integers</source>
        <target state="translated">이 숫자는 부호 있는 16진수 8비트 정수에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitUnsigned">
        <source>This number is outside the allowable range for 8-bit unsigned integers</source>
        <target state="translated">이 숫자는 부호 없는 8비트 정수에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitSigned">
        <source>This number is outside the allowable range for 16-bit signed integers</source>
        <target state="translated">이 숫자는 부호 있는 16비트 정수에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitUnsigned">
        <source>This number is outside the allowable range for 16-bit unsigned integers</source>
        <target state="translated">이 숫자는 부호 없는 16비트 정수에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitSigned">
        <source>This number is outside the allowable range for 32-bit signed integers</source>
        <target state="translated">이 숫자는 부호 있는 32비트 정수에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitUnsigned">
        <source>This number is outside the allowable range for 32-bit unsigned integers</source>
        <target state="translated">이 숫자는 부호 없는 32비트 정수에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitSigned">
        <source>This number is outside the allowable range for 64-bit signed integers</source>
        <target state="translated">이 숫자는 부호 있는 64비트 정수에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitUnsigned">
        <source>This number is outside the allowable range for 64-bit unsigned integers</source>
        <target state="translated">이 숫자는 부호 없는 64비트 정수에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeSigned">
        <source>This number is outside the allowable range for signed native integers</source>
        <target state="translated">이 숫자는 부호 있는 원시 정수에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeUnsigned">
        <source>This number is outside the allowable range for unsigned native integers</source>
        <target state="translated">이 숫자는 부호 없는 원시 정수에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidFloat">
        <source>Invalid floating point number</source>
        <target state="translated">부동 소수점 수가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideDecimal">
        <source>This number is outside the allowable range for decimal literals</source>
        <target state="translated">이 숫자는 10진 리터럴에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideThirtyTwoBitFloat">
        <source>This number is outside the allowable range for 32-bit floats</source>
        <target state="translated">이 숫자는 32비트 부동 수에 대해 허용 가능한 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidNumericLiteral">
        <source>This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0o1, 0b1, 1l (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</source>
        <target state="translated">유효한 숫자 리터럴이 아닙니다. 유효한 숫자 리터럴로는 1, 0x1, 0o1, 0b1, 1l(int), 1u(uint32), 1L(int64), 1UL(uint64), 1s(int16), 1y(sbyte), 1uy(byte), 1.0(float), 1.0f(float32), 1.0m(decimal), 1I(BigInteger) 등이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidByteLiteral">
        <source>This is not a valid byte literal</source>
        <target state="translated">올바른 바이트 리터럴이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidCharLiteral">
        <source>This is not a valid character literal</source>
        <target state="translated">올바른 문자 리터럴이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexThisUnicodeOnlyInStringLiterals">
        <source>This Unicode encoding is only valid in string literals</source>
        <target state="translated">이 유니코드 인코딩은 문자열 리터럴에서만 올바릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTokenReserved">
        <source>This token is reserved for future use</source>
        <target state="translated">이 토큰은 나중에 사용할 수 있도록 예약되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTabsNotAllowed">
        <source>TABs are not allowed in F# code unless the #indent \"off\" option is used</source>
        <target state="translated">#indent \"off\" 옵션을 사용하지 않는 한 TAB은 F# 코드에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidLineNumber">
        <source>Invalid line number: '{0}'</source>
        <target state="translated">줄 번호가 잘못되었습니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustBeFirst">
        <source>#if directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">#if 지시문은 줄에서 공백이 아닌 첫 번째 문자로 나타나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseNoMatchingIf">
        <source>#else has no matching #if</source>
        <target state="translated">#else와 짝이 맞는 #if가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifRequiredForElse">
        <source>#endif required for #else</source>
        <target state="translated">#endif에 #else가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseMustBeFirst">
        <source>#else directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">#else 지시문은 줄에서 공백이 아닌 첫 번째 문자로 나타나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndingNoMatchingIf">
        <source>#endif has no matching #if</source>
        <target state="translated">#endif와 짝이 맞는 #if가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifMustBeFirst">
        <source>#endif directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">#endif 지시문은 줄에서 공백이 아닌 첫 번째 문자로 나타나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustHaveIdent">
        <source>#if directive should be immediately followed by an identifier</source>
        <target state="translated">#if 바로 다음에는 식별자가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexWrongNestedHashEndif">
        <source>Syntax error. Wrong nested #endif, unexpected tokens before it.</source>
        <target state="translated">구문 오류입니다. 잘못된 중첩 #endif가 있으며 이 앞에 예기치 않은 토큰이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashBangMustBeFirstInFile">
        <source>#! may only appear as the first line at the start of a file.</source>
        <target state="translated">#!는 파일 시작의 첫 번째 줄에만 나타날 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexExpectedSingleLineComment">
        <source>Expected single line comment or end of line</source>
        <target state="translated">한 줄로 된 주석이나 줄 끝이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNoArguments">
        <source>Infix operator member '{0}' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">중위 연산자 멤버 '{0}'에 인수가 없습니다. 2개 인수의 튜플이 필요합니다(예: 정적 멤버 (+) (x,y) = ...).</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonPairArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">중위 연산자 멤버 '{0}'에 {1}개의 초기 인수가 있습니다. 2개 인수의 튜플이 필요합니다(예: 정적 멤버 (+) (x,y) = ...).</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithCurriedArguments">
        <source>Infix operator member '{0}' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">중위 연산자 멤버 '{0}'에 커리된 추가 인수가 있습니다. 2개 인수의 튜플이 필요합니다(예: 정적 멤버 (+) (x,y) = ...).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFSharpCoreRequiresExplicit">
        <source>All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'</source>
        <target state="translated">FSharp.Core.dll의 레코드, 공용 구조체 및 구조체 형식에는 'StructuralComparison' 또는 'NoComparison'을 사용하여 명시적으로 레이블을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the type parameter '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter</source>
        <target state="translated">구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'StructuralComparison' 특성이 있지만 형식 매개 변수 '{1}'이(가) 'comparison' 제약 조건을 만족하지 않습니다. 형식 매개 변수에 'comparison' 제약 조건을 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the component type '{1}' does not satisfy the 'comparison' constraint</source>
        <target state="translated">구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'StructuralComparison' 특성이 있지만 구성 요소 형식 '{1}'이(가) 'comparison' 제약 조건을 만족하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded1">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type parameter {1} does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">형식 매개 변수 {1}이(가) 'comparison' 제약 조건을 만족하지 않으므로 구조체, 레코드 또는 공용 구조체 형식 '{0}'을(를) 구조적으로 비교할 수 없습니다. '{2}' 형식에 'NoComparison' 특성을 추가하여 해당 형식을 비교할 수 없음을 명확히 하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded2">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">{1}' 형식이 'comparison' 제약 조건을 만족하지 않으므로 구조체, 레코드 또는 공용 구조체 형식 '{0}'을(를) 구조적으로 비교할 수 없습니다. '{2}' 형식에 'NoComparison' 특성을 추가하여 해당 형식을 비교할 수 없음을 명확히 하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded1">
        <source>The struct, record or union type '{0}' does not support structural equality because the type parameter {1} does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">형식 매개 변수 {1}이(가) 'equality' 제약 조건을 만족하지 않으므로 구조체, 레코드 또는 공용 구조체 형식 '{0}'이(가) 구조적 같음을 지원하지 않습니다. '{2}' 형식에 'NoEquality' 특성을 추가하여 해당 형식이 구조적 같음을 지원하지 않음을 명확히 하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded2">
        <source>The struct, record or union type '{0}' does not support structural equality because the type '{1}' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">{1}' 형식이 'equality' 제약 조건을 만족하지 않으므로 구조체, 레코드 또는 공용 구조체 형식 '{0}'이(가) 구조적 같음을 지원하지 않습니다. '{2}' 형식에 'NoEquality' 특성을 추가하여 해당 형식이 구조적 같음을 지원하지 않음을 명확히 하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the type parameter '{1}' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter</source>
        <target state="translated">구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'StructuralEquality' 특성이 있지만 형식 매개 변수 '{1}'이(가) 'equality' 제약 조건을 만족하지 않습니다. 형식 매개 변수에 'equality' 제약 조건을 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the component type '{1}' does not satisfy the 'equality' constraint</source>
        <target state="translated">구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'StructuralEquality' 특성이 있지만 구성 요소 형식 '{1}'이(가) 'equality' 제약 조건을 만족하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
        <source>Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct.</source>
        <target state="translated">구조체의 주 생성자에 대한 각 인수에는 형식을 지정해야 합니다(예: 'type S(x1:int, x2: int) = ...'). 이러한 인수는 구조체의 필드를 결정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedValue">
        <source>The value '{0}' is unused</source>
        <target state="translated">값 '{0}'을(를) 사용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedThisVariable">
        <source>The recursive object reference '{0}' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.</source>
        <target state="translated">재귀적 개체 참조 '{0}'을(를) 사용하지 않습니다. 재귀적 개체 참조가 있으면 이 형식 및 파생 형식의 멤버에 대한 런타임 초기화 검사가 추가됩니다. 이 재귀적 개체 참조를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterAtMostOneArgument">
        <source>A getter property may have at most one argument group</source>
        <target state="translated">getter 속성에는 인수 그룹이 최대 하나만 있을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetterAtMostTwoArguments">
        <source>A setter property may have at most two argument groups</source>
        <target state="translated">setter 속성에는 최대 2개의 인수 그룹이 있을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidProperty">
        <source>Invalid property getter or setter</source>
        <target state="translated">속성 getter 또는 setter가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIndexerPropertyRequiresAtLeastOneArgument">
        <source>An indexer property must be given at least one argument</source>
        <target state="translated">인덱서 속성에는 하나 이상의 인수가 지정되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidAddressOfMutableAcrossAssemblyBoundary">
        <source>This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation</source>
        <target state="translated">이 작업은 다른 어셈블리에 정의된 변경할 수 있는 최상위 값에 지원되지 않는 방식으로 액세스합니다. 이 값은 해당 주소를 통해 액세스할 수 없습니다. 식을 변경할 수 있는 로컬 변수로 복사하고(예: 'let mutable x = ...') 필요한 경우 작업이 완료된 후에 값을 다시 할당하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTypars">
        <source>Remove spaces between the type name and type parameter, e.g. \"type C&lt;'T&gt;\", not type \"C   &lt;'T&gt;\". Type parameters must be placed directly adjacent to the type name.</source>
        <target state="translated">형식 이름과 형식 매개 변수 사이의 공백을 제거하세요(예: type \"C   &lt;'T&gt;\"가 아니라 \"type C&lt;'T&gt;\"). 형식 매개 변수는 형식 이름 바로 옆에 배치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTyargs">
        <source>Remove spaces between the type name and type parameter, e.g. \"C&lt;'T&gt;\", not \"C &lt;'T&gt;\". Type parameters must be placed directly adjacent to the type name.</source>
        <target state="translated">형식 이름과 형식 매개 변수 사이의 공백을 제거하세요(예: \"C &lt;'T&gt;\"가 아니라 \"C&lt;'T&gt;\"). 형식 매개 변수는 형식 이름 바로 옆에 배치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAtomicType">
        <source>The use of the type syntax 'int C' and 'C  &lt;int&gt;' is not permitted here. Consider adjusting this type to be written in the form 'C&lt;int&gt;'</source>
        <target state="translated">형식 구문 'int C' 및 'C  &lt;int&gt;'는 여기에 허용되지 않습니다. 이 형식이 'C&lt;int&gt;' 형식으로 작성되도록 조정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespace">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the module/namespace '{2}'</source>
        <target state="translated">컴파일 단위 '{1}'의 '{0}' 모듈/네임스페이스에 '{2}' 모듈/네임스페이스가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefVal">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the val '{2}'</source>
        <target state="translated">컴파일 단위 '{1}'의 '{0}' 모듈/네임스페이스에 val '{2}'이(가) 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespaceType">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the namespace, module or type '{2}'</source>
        <target state="translated">컴파일 단위 '{1}'의 '{0}' 모듈/네임스페이스에 '{2}' 네임스페이스, 모듈 또는 형식이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseNullAsTrueValue">
        <source>The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case</source>
        <target state="translated">'UseNullAsTrueValue' 특성 플래그는 하나의 nullary 케이스와 하나 이상의 nullary가 아닌 케이스를 포함하는 공용 구조체 형식에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterInferredByref">
        <source>The parameter '{0}' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref&lt;int&gt;'. When used, a byref parameter is implicitly dereferenced.</source>
        <target state="translated">'{0}' 매개 변수가 byref 형식으로 유추되었습니다. byref 형식의 매개 변수에는 명시적인 형식 주석(예: 'x1: byref&lt;int&gt;')이 지정되어야 합니다. byref 매개 변수는 사용될 경우 암시적으로 역참조됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonUniformMemberUse">
        <source>The generic member '{0}' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.</source>
        <target state="translated">제네릭 멤버 '{0}'이(가) 이 프로그램 지점 전의 비균일 인스턴스화에 사용되었습니다. 이 멤버가 처음에 오도록 멤버들을 다시 정렬해 보세요. 또는, 인수 형식, 반환 형식 및 추가 제네릭 매개 변수와 제약 조건을 포함한 멤버의 전체 형식을 명시적으로 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttribArgsDiffer">
        <source>The attribute '{0}' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.</source>
        <target state="translated">'{0}' 특성이 구현과 시그니처 모두에 나타나지만 특성 인수가 다릅니다. 컴파일된 코드에는 시그니처에 있는 특성만 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallAbstractBaseMember">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">추상 기본 멤버를 호출할 수 없습니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInUnmanaged">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position</source>
        <target state="translated">이 위치 또는 이 위치 근처에서 'unmanaged' 제약 조건을 사용하여 제네릭 구문 사용의 모호성을 해결할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="mlCompatMessage">
        <source>This construct is for ML compatibility. {0}. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'.</source>
        <target state="translated">이 구문은 ML 호환성을 위해 사용됩니다. {0}. 이 경고가 나타나지 않게 하려면 '--mlcompatibility' 또는 '--nowarn:62'를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldDoesNotHaveValidOffsetForStructureLayout">
        <source>The type '{0}' has been marked as having an Explicit layout, but the field '{1}' has not been marked with the 'FieldOffset' attribute</source>
        <target state="translated">{0}' 형식이 명시적 레이아웃을 포함한다고 표시되어 있지만 '{1}' 필드가 'FieldOffset' 특성으로 표시되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfacesShouldUseInheritNotInterface">
        <source>Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'</source>
        <target state="translated">다른 인터페이스에서 상속된 인터페이스는 'interface ...' 대신 'inherit ...'를 사용하여 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperator">
        <source>Invalid prefix operator</source>
        <target state="translated">잘못된 전위 연산자</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperatorDefinition">
        <source>Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.</source>
        <target state="translated">잘못된 연산자 정의입니다. 전위 연산자 정의에서는 유효한 전위 연산자 이름을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCompilingExtensionIsForML">
        <source>The file extensions '.ml' and '.mli' are for ML compatibility</source>
        <target state="translated">파일 확장명 '.ml' 및 '.mli'는 ML 호환성을 위한 것입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIndentOffForML">
        <source>Consider using a file with extension '.ml' or '.mli' instead</source>
        <target state="translated">대신 확장명이 '.ml' 또는 '.mli'인 파일을 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternIdentIsNotFunctionTyped">
        <source>Active pattern '{0}' is not a function</source>
        <target state="translated">활성 패턴 '{0}'이(가) 함수가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternChoiceHasFreeTypars">
        <source>Active pattern '{0}' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</source>
        <target state="translated">활성 패턴 '{0}'에 입력으로 확인되지 않는 형식 변수가 포함된 결과 형식이 있습니다. 이는 일반적으로 결과 케이스가 지정되지 않은 경우 발생합니다(예 'let (|A|B|) (x:int) = A x'). 이 문제는 형식 제약 조건을 지정하여 해결할 수 있습니다(예: 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x').</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldHasOffsetForSequentialLayout">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">FieldOffset 특성은 StructLayout(LayoutKind.Explicit)으로 표시된 형식의 멤버에만 배치할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsMustComeAfterNonOptionalArgs">
        <source>Optional arguments must come at the end of the argument list, after any non-optional arguments</source>
        <target state="translated">선택적 인수는 비선택적 인수 다음의 인수 목록 끝에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeUsage">
        <source>Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes</source>
        <target state="translated">'System.Diagnostics.ConditionalAttribute' 특성은 메서드 또는 특성 클래스에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOperatorDefinitionInExtrinsic">
        <source>Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.</source>
        <target state="translated">확장 멤버가 연산자 오버로드를 제공할 수 없습니다.  대신 연산자를 형식 정의의 일부분으로 정의하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBFileNameCannotBeChangedWarning">
        <source>The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.</source>
        <target state="translated">MDB 파일의 이름은 &lt;어셈블리 파일 이름&gt;.mdb여야 합니다. --pdb 옵션은 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBMemberMissing">
        <source>MDB generation failed. Could not find compatible member {0}</source>
        <target state="translated">MDB를 생성하지 못했습니다. 호환 멤버 {0}을(를) 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingMdb">
        <source>Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly.</source>
        <target state="translated">MDB 디버그 정보를 생성할 수 없습니다. 'Mono.CompilerServices.SymbolWriter.dll' 어셈블리에서 'MonoSymbolWriter' 형식을 로드하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseNameConflictsWithGeneratedType">
        <source>The union case named '{0}' conflicts with the generated type '{1}'</source>
        <target state="translated">이름이 '{0}'인 공용 구조체가 생성된 형식 '{1}'과(와) 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoReflectedDefinitionOnStructMember">
        <source>ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter</source>
        <target state="translated">ReflectedDefinitionAttribute를 구조체 형식 인스턴스 멤버에 적용할 수 없습니다. 해당 인스턴스 멤버가 암시적 'this' byref 매개 변수를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportNotAllowed">
        <source>DLLImport bindings must be static members in a class or function definitions in a module</source>
        <target state="translated">DLLImport 바인딩은 모듈의 클래스 또는 함수 정의에서 정적 멤버여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedSigdataFile">
        <source>FSharp.Core.sigdata not found alongside FSharp.Core. File expected in {0}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">FSharp.Core에서 FSharp.Core.sigdata를 찾을 수 없습니다. 파일이 {0}에 있어야 합니다. 이 파일이 더 이상 필요하지 않은 최신 버전의 FSharp.Core로의 업그레이드를 고려해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedFileAlongSideFSharpCore">
        <source>File '{0}' not found alongside FSharp.Core. File expected in {1}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">FSharp.Core에서 '{0}' 파일을 찾을 수 없습니다. 파일이 {1}에 있어야 합니다. 이 파일이 더 이상 필요하지 않은 최신 버전의 FSharp.Core로의 업그레이드를 고려해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedFileNameCharacter">
        <source>Filename '{0}' contains invalid character '{1}'</source>
        <target state="translated">파일 이름 '{0}'에 잘못된 문자('{1}')가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBinding">
        <source>'use!' bindings must be of the form 'use! &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">'use!' 바인딩은 'use! &lt;var&gt; = &lt;expr&gt;' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoInnerGenericsInQuotations">
        <source>Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.</source>
        <target state="translated">내부 제네릭 함수는 따옴표 붙은 식에 허용되지 않습니다. 이 함수가 더 이상 제네릭 형식이 아닐 때까지 형식 제약 조건을 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumTypeCannotBeEnumerated">
        <source>The type '{0}' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property</source>
        <target state="translated">'{0}' 형식은 올바른 열거자 형식이 아닙니다(예: 부울을 반환하는 'MoveNext()' 메서드와 'Current' 속성이 포함되어 있지 않음).</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteString">
        <source>End of file in triple-quote string begun at or before here</source>
        <target state="translated">3중 따옴표 문자열의 파일 끝이 여기나 그 앞에서 시작됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteStringInComment">
        <source>End of file in triple-quote string embedded in comment begun at or before here</source>
        <target state="translated">주석에 포함된 3중 따옴표 문자열의 파일 끝이 여기나 그 앞에서 시작됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLosesMeasures">
        <source>This type test or downcast will ignore the unit-of-measure '{0}'</source>
        <target state="translated">이 형식 테스트 또는 다운캐스트는 '{0}' 측정 단위를 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingTypeArgs">
        <source>Expected type argument or static argument</source>
        <target state="translated">형식 인수 또는 정적 인수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingGreaterThan">
        <source>Unmatched '&lt;'. Expected closing '&gt;'</source>
        <target state="translated">'&lt;'의 짝이 맞지 않습니다. 닫는 '&gt;'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
        <source>Unexpected quotation operator '&lt;@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '&lt;' and '@' characters.</source>
        <target state="translated">형식 정의에 예기치 않은 인용구 연산자 '&lt;@'가 있습니다. 축자 문자열을 정적 인수로 형식 공급자에 전달하려면 '&lt;'와 '@' 문자 사이에 공백을 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorParsingAsOperatorName">
        <source>Attempted to parse this as an operator name, but failed</source>
        <target state="translated">이 항목을 연산자 이름으로 구문 분석하려고 했지만 실패했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidUnicodeLiteral">
        <source>\U{0} is not a valid Unicode character escape sequence</source>
        <target state="translated">\U{0}은(는) 유효한 유니코드 문자 이스케이프 시퀀스가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoWrongType">
        <source>'{0}' must be applied to an argument of type '{1}', but has been applied to an argument of type '{2}'</source>
        <target state="translated">'{0}'은(는) '{1}' 형식의 인수에 적용되어야 하지만 '{2}' 형식의 인수에 적용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoNotOptional">
        <source>'{0}' can only be applied to optional arguments</source>
        <target state="translated">'{0}'은(는) 선택적 인수에만 적용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="toolLocationHelperUnsupportedFrameworkVersion">
        <source>The specified .NET Framework version '{0}' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
        <target state="translated">지정한 .NET Framework 버전 "{0}"은(는) 지원되지 않습니다. Microsoft.Build.Utilities.TargetDotNetFrameworkVersion 열거형의 값을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidMagicValue">
        <source>Invalid Magic value in CLR Header</source>
        <target state="translated">CLR 헤더의 잘못된 매직 값</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignBadImageFormat">
        <source>Bad image format</source>
        <target state="translated">잘못된 이미지 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignPrivateKeyExpected">
        <source>Private key expected</source>
        <target state="translated">개인 키가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignRsaKeyExpected">
        <source>RSA key expected</source>
        <target state="translated">RSA 키가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidBitLen">
        <source>Invalid bit Length</source>
        <target state="translated">잘못된 비트 길이</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidRSAParams">
        <source>Invalid RSAParameters structure - '{{0}}' expected</source>
        <target state="translated">잘못된 RSAParameters 구조 - '{{0}}'이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidAlgId">
        <source>Invalid algId - 'Exponent' expected</source>
        <target state="translated">잘못된 algId - '지수'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidSignatureSize">
        <source>Invalid signature size</source>
        <target state="translated">잘못된 서명 크기</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignNoSignatureDirectory">
        <source>No signature directory</source>
        <target state="translated">서명 디렉터리가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidPKBlob">
        <source>Invalid Public Key blob</source>
        <target state="translated">잘못된 공개 키 Blob</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTooManyErrors">
        <source>Exiting - too many errors</source>
        <target state="translated">끝내는 중 - 오류가 너무 많습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="docfileNoXmlSuffix">
        <source>The documentation file has no .xml suffix</source>
        <target state="translated">문서 파일에 .xml 접미사가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscNoImplementationFiles">
        <source>No implementation files specified</source>
        <target state="translated">지정된 구현 파일이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscBadAssemblyVersion">
        <source>The attribute {0} specified version '{1}', but this value is invalid and has been ignored</source>
        <target state="translated">특성 {0}이(가) 버전 '{1}'을(를) 지정했지만, 이 값이 잘못되어 무시되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTwoResourceManifests">
        <source>Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used.</source>
        <target state="translated">지정된 옵션 'win32manifest'와 'win32res'가 충돌합니다. 둘 중 하나만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking">
        <source>The code in assembly '{0}' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">어셈블리 '{0}'의 코드에서 따옴표로 묶인 리터럴을 사용합니다. 정적 링크에서는 모든 어셈블리가 최소 F# 4.0으로 컴파일된 경우가 아니라면 따옴표로 묶인 리터럴을 사용하는 구성 요소를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking0">
        <source>Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">이 어셈블리의 코드에서 따옴표로 묶인 리터럴을 사용합니다. 정적 링크에서는 모든 어셈블리가 최소 F# 4.0으로 컴파일된 경우가 아니라면 따옴표로 묶인 리터럴을 사용하는 구성 요소를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoEXE">
        <source>Static linking may not include a .EXE</source>
        <target state="translated">정적 링크에는 .EXE를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoMixedDLL">
        <source>Static linking may not include a mixed managed/unmanaged DLL</source>
        <target state="translated">정적 링크에는 관리되는/관리되지 않는 형식이 혼합된 DLL을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscIgnoringMixedWhenLinking">
        <source>Ignoring mixed managed/unmanaged assembly '{0}' during static linking</source>
        <target state="translated">정적 링크 중에 관리되는/관리되지 않는 어셈블리가 혼합된 '{0}'을(를) 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssumeStaticLinkContainsNoDependencies">
        <source>Assembly '{0}' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.</source>
        <target state="translated">어셈블리 '{0}'이(가) 타동적으로 참조되었으며 어셈블리를 자동으로 확인할 수 없습니다. 정적 링크에서는 이 DLL에 F# 라이브러리나 다른 정적 링크 DLL에 대한 종속성이 없다고 가정합니다. 이 DLL에 대한 명시적 참조를 추가하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyNotFoundInDependencySet">
        <source>Assembly '{0}' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.</source>
        <target state="translated">대상 이진 파일의 종속성 집합에서 어셈블리 '{0}'을(를) 찾지 못했습니다. 정적으로 링크된 루트는 DLL 또는 EXE 확장명이 없는 상태로 어셈블리 이름을 사용하여 지정해야 합니다. 이 어셈블리가 명시적으로 참조된 경우 생성된 이진 파일에서 실제로 필요하지 않을 수 있습니다. 이런 경우에는 정적으로 링크하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileCouldNotBeOpened">
        <source>The key file '{0}' could not be opened</source>
        <target state="translated">키 파일 '{0}'을(를) 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscProblemWritingBinary">
        <source>A problem occurred writing the binary '{0}': {1}</source>
        <target state="translated">이진 파일 '{0}'을(를) 쓰는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyVersionAttributeIgnored">
        <source>The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option</source>
        <target state="translated">명령줄 옵션을 사용하여 버전을 지정했기 때문에 'AssemblyVersionAttribute'가 무시되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyCultureAttributeError">
        <source>Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'</source>
        <target state="translated">'System.Reflection.AssemblyCultureAttribute' 특성을 내보내는 동안 오류 발생 -- '실행 파일은 위성 어셈블리일 수 없습니다. 문화권은 항상 비어 있어야 합니다.'</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDelaySignWarning">
        <source>Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module</source>
        <target state="translated">'--delaysign' 옵션은 소스 파일이나 추가 모듈에 지정된 'System.Reflection.AssemblyDelaySignAttribute' 특성을 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileWarning">
        <source>Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module</source>
        <target state="translated">'--keyfile' 옵션은 소스 파일 또는 추가 모듈에 지정된 'System.Reflection.AssemblyKeyFileAttribute' 특성을 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyNameWarning">
        <source>Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module</source>
        <target state="translated">'--keycontainer' 옵션은 소스 파일이나 추가 모듈에 지정된 'System.Reflection.AssemblyNameAttribute' 특성을 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscReferenceOnCommandLine">
        <source>The assembly '{0}' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'.</source>
        <target state="translated">'{0}' 어셈블리가 명령줄에 나열되어 있습니다. '-r'과 같은 명령줄 플래그를 사용하여 어셈블리를 참조해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscRemotingError">
        <source>The resident compilation service was not used because a problem occured in communicating with the server.</source>
        <target state="translated">서버와 통신하는 동안 문제가 발생하여 상주 컴파일 서비스를 사용하지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="pathIsInvalid">
        <source>Problem with filename '{0}': Illegal characters in path.</source>
        <target state="translated">파일 이름 '{0}'에 문제가 있습니다. 경로에 잘못된 문자가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscResxSourceFileDeprecated">
        <source>Passing a .resx file ({0}) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.</source>
        <target state="translated">더 이상 .resx 파일({0})이 컴파일러에 소스 파일로 전달되지 않습니다. resgen.exe를 사용하여 .resx 파일을 .resources 파일로 변환해 --resource 옵션으로 전달하세요. MSBuild를 사용하는 경우 .fsproj 프로젝트 파일의 &lt;EmbeddedResource&gt; 항목을 통해 이 작업을 수행할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoProfileMismatches">
        <source>Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).</source>
        <target state="translated">System.Runtime을 참조하는 어셈블리(예: .NET Core 또는 이식 가능한 어셈블리)를 생성할 때 mscorlib를 참조하는 어셈블리(예: .NET Framework 어셈블리)에서 정적 링크를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyWildcardAndDeterminism">
        <source>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</source>
        <target state="translated">{0}이(가) '{1}' 버전을 지정했지만, 이 값은 와일드카드인데 사용자가 결정적 빌드를 요청하여 문제가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDeterministicDebugRequiresPortablePdb">
        <source>Deterministic builds only support portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">결정적 빌드는 이식 가능한 PDB만 지원합니다(--debug:portable 또는 --debug:embedded).</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInNamespaceName">
        <source>Character '{0}' is not allowed in provided namespace name '{1}'</source>
        <target state="translated">제공된 네임스페이스 이름 '{1}'에는 '{0}' 문자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullOrEmptyMemberName">
        <source>The provided type '{0}' returned a member with a null or empty member name</source>
        <target state="translated">제공된 '{0}' 형식에서 멤버 이름이 비어 있거나 null인 멤버를 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMember">
        <source>The provided type '{0}' returned a null member</source>
        <target state="translated">제공된 '{0}' 형식에서 null 멤버를 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringType">
        <source>The provided type '{0}' member info '{1}' has null declaring type</source>
        <target state="translated">제공된 '{0}' 형식의 멤버 정보('{1}')에 null 선언 형식이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringTypeDifferentFromProvidedType">
        <source>The provided type '{0}' has member '{1}' which has declaring type '{2}'. Expected declaring type to be the same as provided type.</source>
        <target state="translated">제공된 '{0}' 형식에 포함된 멤버 '{1}'의 선언 형식이 '{2}'입니다. 제공된 형식과 같은 선언 형식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etHostingAssemblyFoundWithoutHosts">
        <source>Referenced assembly '{0}' has assembly level attribute '{1}' but no public type provider classes were found</source>
        <target state="translated">참조된 '{0}' 어셈블리에 어셈블리 수준 특성 '{1}'이(가) 있지만 공용 형식 공급자 클래스는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceOfTypeNotAllowed">
        <source>Type '{0}' from type provider '{1}' has an empty namespace. Use 'null' for the global namespace.</source>
        <target state="translated">형식 공급자 '{1}' 의 형식 '{0}'에 빈 네임스페이스가 있습니다. 전역 네임스페이스에 대해 'null'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceNotAllowed">
        <source>Empty namespace found from the type provider '{0}'. Use 'null' for the global namespace.</source>
        <target state="translated">형식 공급자 '{0}'에 빈 네임스페이스가 있습니다. 전역 네임스페이스에 대해 'null'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeGeneric">
        <source>Provided type '{0}' has 'IsGenericType' as true, but generic types are not supported.</source>
        <target state="translated">제공된 '{0}' 형식의 'IsGenericType'이 true인데 제네릭 형식이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeAnArray">
        <source>Provided type '{0}' has 'IsArray' as true, but array types are not supported.</source>
        <target state="translated">제공된 '{0}' 형식의 'IsArray'가 true인데 배열 형식이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMethodHasRequirements">
        <source>Invalid member '{0}' on provided type '{1}'. Provided type members must be public, and not be generic, virtual, or abstract.</source>
        <target state="translated">제공된 '{1}' 형식에 잘못된 멤버('{0}')가 있습니다. 제공된 형식 멤버는 공용이어야 하며 제네릭, 가상 또는 추상 멤버여서는 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedMemberKind">
        <source>Invalid member '{0}' on provided type '{1}'. Only properties, methods and constructors are allowed</source>
        <target state="translated">제공된 형식 '{1}'의 '{0}' 멤버가 잘못되었습니다. 속성, 메서드 및 생성자만 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanReadButHasNoGetter">
        <source>Property '{0}' on provided type '{1}' has CanRead=true but there was no value from GetGetMethod()</source>
        <target state="translated">제공된 '{1}' 형식의 '{0}' 속성에서 CanRead=true인데 GetGetMethod()의 값이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasGetterButNoCanRead">
        <source>Property '{0}' on provided type '{1}' has CanRead=false but GetGetMethod() returned a method</source>
        <target state="translated">제공된 '{1}' 형식의 '{0}' 속성에서 CanRead=false인데 GetGetMethod()에서 메서드를 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanWriteButHasNoSetter">
        <source>Property '{0}' on provided type '{1}' has CanWrite=true but there was no value from GetSetMethod()</source>
        <target state="translated">제공된 '{1}' 형식의 '{0}' 속성에서 CanWrite=true인데 GetSetMethod()의 값이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasSetterButNoCanWrite">
        <source>Property '{0}' on provided type '{1}' has CanWrite=false but GetSetMethod() returned a method</source>
        <target state="translated">제공된 '{1}' 형식의 '{0}' 속성에서 CanWrite=fa인데 GetSetMethod()에서 메서드를 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
        <source>One or more errors seen during provided type setup</source>
        <target state="translated">제공된 형식을 설정하는 동안 하나 이상의 오류가 확인되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedTypeMember">
        <source>Unexpected exception from provided type '{0}' member '{1}': {2}</source>
        <target state="translated">제공된 형식 '{0}' 멤버 '{1}'에서 예기치 않은 예외가 발생했습니다. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedConstantType">
        <source>Unsupported constant type '{0}'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal.</source>
        <target state="translated">지원되지 않는 상수 형식 '{0}'입니다. 형식 공급자가 제공하는 인용에는 간단한 상수만 포함될 수 있습니다. 인용구 리터럴 내에서 'let' 바인딩이 되려면 선언된 값을 제공된 인용구 리터럴 밖으로 이동시켜 형식 공급자의 구현을 조정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedProvidedExpression">
        <source>Unsupported expression '{0}' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.</source>
        <target state="translated">형식 공급자의 '{0}' 식은 지원되지 않습니다. 이 형식 공급자의 작성자인 경우 제공된 다른 식을 제공하도록 조정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedName">
        <source>Expected provided type named '{0}' but provided type has 'Name' with value '{1}'</source>
        <target state="translated">이름이 '{0}'인 제공된 형식이 필요한데 제공된 형식의 'Name' 값은 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoAdd">
        <source>Event '{0}' on provided type '{1}' has no value from GetAddMethod()</source>
        <target state="translated">제공된 형식 '{1}'에 대한 이벤트 '{0}'에 GetAddMethod()의 값이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoRemove">
        <source>Event '{0}' on provided type '{1}' has no value from GetRemoveMethod()</source>
        <target state="translated">제공된 형식 '{1}'에 대한 이벤트 '{0}'에 GetRemoveMethod()의 값이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssembly">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded from path '{2}'. The exception reported was: {3} - {4}</source>
        <target state="translated">어셈블리 특성 '{0}'은(는) '{2}' 경로에서 로드할 수 없는 디자이너 어셈블리 '{1}'을(를) 참조합니다. 보고된 예외: {3} - {4}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderDoesNotHaveValidConstructor">
        <source>The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected.</source>
        <target state="translated">형식 공급자에 올바른 생성자가 없습니다. 인수를 사용하지 않거나 'TypeProviderConfig' 형식의 인수 하나를 사용하는 생성자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderError">
        <source>The type provider '{0}' reported an error: {1}</source>
        <target state="translated">{0}' 형식 공급자가 오류를 보고했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectParameterExpression">
        <source>The type provider '{0}' used an invalid parameter in the ParameterExpression: {1}</source>
        <target state="translated">{0}' 형식 공급자가 ParameterExpression에서 잘못된 매개 변수를 사용했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedMethod">
        <source>The type provider '{0}' provided a method with a name '{1}' and metadata token '{2}', which is not reported among its methods of its declaring type '{3}'</source>
        <target state="translated">{0}' 형식 공급자가 이름이 '{1}'이고 메타데이터 토큰이 '{2}'인 메서드를 제공했는데, 이는 해당 선언 형식 '{3}'의 메서드에서 보고되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedConstructor">
        <source>The type provider '{0}' provided a constructor which is not reported among the constructors of its declaring type '{1}'</source>
        <target state="translated">선언 형식('{1}')의 생성자로부터 보고되지 않은 생성자를 형식 공급자 '{0}'에서 제공했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etDirectReferenceToGeneratedTypeNotAllowed">
        <source>A direct reference to the generated type '{0}' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = &lt;path&gt;'. This indicates that a type provider adds generated types to your assembly.</source>
        <target state="translated">생성된 형식 '{0}'을(를) 직접 참조할 수는 없습니다. 대신 형식 정의를 사용하세요(예: 'type TypeAlias = &lt;path&gt;'). 이 정의는 형식 공급자가 생성된 형식을 어셈블리에 추가함을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedPath">
        <source>Expected provided type with path '{0}' but provided type has path '{1}'</source>
        <target state="translated">경로가 '{0}'인 제공된 형식이 필요한데 제공된 형식의 경로는 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedNullFromProvidedTypeMember">
        <source>Unexpected 'null' return value from provided type '{0}' member '{1}'</source>
        <target state="translated">제공된 형식 '{0}' 멤버 '{1}'에 예기치 않은 'null' 반환 값이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedMemberMember">
        <source>Unexpected exception from member '{0}' of provided type '{1}' member '{2}': {3}</source>
        <target state="translated">제공된 형식 '{1}' 멤버 '{2}'의 멤버 '{0}'에서 예기치 않은 예외가 발생했습니다. {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
        <source>Nested provided types do not take static arguments or generic parameters</source>
        <target state="translated">제공된 중첩 형식은 정적 인수 또는 제네릭 매개 변수를 사용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidStaticArgument">
        <source>Invalid static argument to provided type. Expected an argument of kind '{0}'.</source>
        <target state="translated">제공된 형식에 대한 정적 인수가 잘못되었습니다. '{0}' 종류의 인수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToType">
        <source>An error occured applying the static arguments to a provided type</source>
        <target state="translated">제공된 형식에 정적 인수를 적용하는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnknownStaticArgumentKind">
        <source>Unknown static argument kind '{0}' when resolving a reference to a provided type or method '{1}'</source>
        <target state="translated">제공된 형식 또는 메서드 '{1}'에 대한 참조를 확인할 때 알 수 없는 정적 인수 종류('{0}')가 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidNamespaceForProvidedType">
        <source>invalid namespace for provided type</source>
        <target state="translated">제공된 형식의 네임스페이스가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidFullNameForProvidedType">
        <source>invalid full name for provided type</source>
        <target state="translated">제공된 형식의 전체 이름이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderReturnedNull">
        <source>The type provider returned 'null', which is not a valid return value from '{0}'</source>
        <target state="translated">형식 공급자가 'null'을 반환했습니다. 이 값은 '{0}'(으)로부터의 올바른 반환 값이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTypeProviderConstructorException">
        <source>The type provider constructor has thrown an exception: {0}</source>
        <target state="translated">형식 공급자 생성자에서 예외가 발생했습니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullProvidedExpression">
        <source>Type provider '{0}' returned null from GetInvokerExpression.</source>
        <target state="translated">'{0}' 형식 공급자가 GetInvokerExpression에서 null을 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedTypeHadWrongName">
        <source>The type provider '{0}' returned an invalid type from 'ApplyStaticArguments'. A type with name '{1}' was expected, but a type with name '{2}' was returned.</source>
        <target state="translated">형식 공급자 '{0}'이(가) 'ApplyStaticArguments'에서 잘못된 형식을 반환했습니다. 이름이 '{1}'인 형식이 필요한데 이름이 '{2}'인 형식이 반환되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedMethodHadWrongName">
        <source>The type provider '{0}' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '{1}' was expected, but a method with name '{2}' was returned.</source>
        <target state="translated">{0}' 형식 공급자가 잘못된 메서드를 'ApplyStaticArgumentsForMethod'에서 반환했습니다. '{1}'라는 메서드를 예상했지만 '{2}'라는 메서드가 반환되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLossy">
        <source>This type test or downcast will erase the provided type '{0}' to the type '{1}'</source>
        <target state="translated">이 형식 테스트 또는 다운캐스트는 제공된 '{0}' 형식을 '{1}' 형식으로 지웁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCastErased">
        <source>This downcast will erase the provided type '{0}' to the type '{1}'.</source>
        <target state="translated">이 다운캐스트는 제공된 '{0}' 형식을 '{1}' 형식으로 지웁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestErased">
        <source>This type test with a provided type '{0}' is not allowed because this provided type will be erased to '{1}' at runtime.</source>
        <target state="translated">제공된 형식 '{0}'이(가) 포함된 이 형식 테스트는 허용되지 않습니다. 이 제공된 형식은 런타임에 '{1}'(으)로 지워집니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromErasedType">
        <source>Cannot inherit from erased provided type</source>
        <target state="translated">지워진 제공된 형식에는 상속될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidTypeProviderAssemblyName">
        <source>Assembly '{0}' hase TypeProviderAssembly attribute with invalid value '{1}'. The value should be a valid assembly name</source>
        <target state="translated">{0}' 어셈블리에 포함된 TypeProviderAssembly 특성의 값('{1}')이 잘못되었습니다. 값은 올바른 어셈블리 이름이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameCtor">
        <source>Invalid member name. Members may not have name '.ctor' or '.cctor'</source>
        <target state="translated">멤버 이름이 잘못되었습니다. 멤버 이름은 '.ctor' 또는 '.cctor'일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInferredGenericTypeGivesRiseToInconsistency">
        <source>The function or member '{0}' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '{1}'.</source>
        <target state="translated">{0}' 함수 또는 멤버는 유추된 형식의 일관성을 유지하기 위해 해당 정의에서 형식 주석을 더 추가해야 하는 방식으로 사용됩니다. 유추된 서명은 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentCount">
        <source>The number of type arguments did not match: '{0}' given, '{1}' expected. This may be related to a previously reported error.</source>
        <target state="translated">형식 인수의 수가 일치하지 않습니다. '{0}'개가 제공되었는데 '{1}'개가 필요합니다. 이전에 보고된 오류와 관련된 현상일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotOverrideSealedMethod">
        <source>Cannot override inherited member '{0}' because it is sealed</source>
        <target state="translated">상속된 '{0}' 멤버는 봉인되어 있으므로 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderErrorWithContext">
        <source>The type provider '{0}' reported an error in the context of provided type '{1}', member '{2}'. The error: {3}</source>
        <target state="translated">{0}' 형식 공급자가 제공된 형식 '{1}', 멤버 '{2}'의 컨텍스트에서 오류를 보고했습니다. 오류는 {3}입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNameException">
        <source>An exception occurred when accessing the '{0}' of a provided type: {1}</source>
        <target state="translated">제공된 형식 {1}의 '{0}'에 액세스하는 동안 예외가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNullOrEmptyName">
        <source>The '{0}' of a provided type was null or empty.</source>
        <target state="translated">제공된 형식의 '{0}'이 null이거나 비어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInTypeName">
        <source>Character '{0}' is not allowed in provided type name '{1}'</source>
        <target state="translated">제공된 형식 이름 '{1}'에는 '{0}' 문자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcJoinMustUseSimplePattern">
        <source>In queries, '{0}' must use a simple pattern</source>
        <target state="translated">쿼리에서 '{0}'은(는) 단순 패턴을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMissingCustomOperation">
        <source>A custom query operation for '{0}' is required but not specified</source>
        <target state="translated">'{0}'에 대한 사용자 지정 쿼리 연산이 필요한데 지정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etBadUnnamedStaticArgs">
        <source>Named static arguments must come after all unnamed static arguments</source>
        <target state="translated">명명되지 않은 모든 정적 인수 뒤에는 명명된 정적 인수가 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterRequiresAValue">
        <source>The static parameter '{0}' of the provided type or method '{1}' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '{2}&lt;{3}=...&gt;'.</source>
        <target state="translated">제공된 형식 또는 메서드 '{1}'의 정적 매개 변수 '{0}'에 값이 필요합니다. 명명된 인수(예: '{2}&lt;{3}=...&gt;')를 사용하여 형식 공급자에 대한 정적 매개 변수를 선택적으로 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNoStaticParameterWithName">
        <source>No static parameter exists with name '{0}'</source>
        <target state="translated">이름이 '{0}'인 정적 매개 변수가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterAlreadyHasValue">
        <source>The static parameter '{0}' has already been given a value</source>
        <target state="translated">정적 매개 변수 '{0}'에 이미 값이 제공되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMultipleStaticParameterWithName">
        <source>Multiple static parameters exist with name '{0}'</source>
        <target state="translated">이름이 '{0}'인 정적 매개 변수가 여러 개 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
        <source>A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression</source>
        <target state="translated">사용자 지정 연산은 이 계산 식의 다른 부분에 있는 값이 아니거나 재귀적인 'let' 바인딩과 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedHere">
        <source>A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression</source>
        <target state="translated">이 계산 식 내에서 사용자 지정 연산을 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' 연산자와 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeOverloaded">
        <source>The custom operation '{0}' refers to a method which is overloaded. The implementations of custom operations may not be overloaded.</source>
        <target state="translated">사용자 지정 연산 '{0}'에서 오버로드된 메서드를 참조합니다. 사용자 지정 연산의 구현은 오버로드될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIfThenElseMayNotBeUsedWithinQueries">
        <source>An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.</source>
        <target state="translated">if/then/else 식은 쿼리 내에서 사용할 수 없습니다. 대신 if/then 식을 사용하거나 시퀀스 식을 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
        <source>Invalid argument to 'methodhandleof' during codegen</source>
        <target state="translated">코드 생성 중에 'methodhandleof'에 대한 잘못된 인수가 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceMissingArgument">
        <source>A reference to a provided type was missing a value for the static parameter '{0}'. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">제공된 형식에 대한 참조에서 정적 매개 변수 '{0}'의 값이 누락되었습니다. 참조되는 어셈블리를 하나 이상 다시 컴파일해야 할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceInvalidText">
        <source>A reference to a provided type had an invalid value '{0}' for a static parameter. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">제공된 형식에 대한 참조의 값('{0}')이 정적 매개 변수에 대해 잘못되었습니다. 참조되는 어셈블리를 하나 이상 다시 컴파일해야 할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly">
        <source>'{0}' is not used correctly. This is a custom operation in this query or computation expression.</source>
        <target state="translated">'{0}'이(가) 잘못 사용되었습니다. 이 항목은 이 쿼리 또는 계산 식의 사용자 지정 연산입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly2">
        <source>'{0}' is not used correctly. Usage: {1}. This is a custom operation in this query or computation expression.</source>
        <target state="translated">'{0}'이(가) 잘못 사용되었습니다. 사용법: {1}. 이 항목은 이 쿼리 또는 계산 식의 사용자 지정 연산입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeJoin">
        <source>{0} var in collection {1} (outerKey = innerKey). Note that parentheses are required after '{2}'</source>
        <target state="translated">{0} var in collection {1} (outerKey = innerKey). '{2}' 뒤에 괄호가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeGroupJoin">
        <source>{0} var in collection {1} (outerKey = innerKey) into group. Note that parentheses are required after '{2}'</source>
        <target state="translated">그룹에 {0} var in collection {1} (outerKey = innerKey). '{2}' 다음에 괄호가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeZip">
        <source>{0} var in collection</source>
        <target state="translated">{0} var in collection</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresVariable">
        <source>'{0}' must be followed by a variable name. Usage: {1}.</source>
        <target state="translated">'{0}' 뒤에는 변수 이름이 와야 합니다. 사용법: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorIncorrectSyntax">
        <source>Incorrect syntax for '{0}'. Usage: {1}.</source>
        <target state="translated">{0}' 구문이 잘못되었습니다. 사용법: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresBody">
        <source>'{0}' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... {1} ...</source>
        <target state="translated">'{0}' 앞에는 'for' 선택 절이 와야 하고 뒤에는 나머지 쿼리 부분이 와야 합니다. 구문: ... {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationHasIncorrectArgCount">
        <source>'{0}' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected {1} argument(s), but given {2}.</source>
        <target state="translated">'{0}'에 사용된 인수의 수가 잘못되었습니다. 이 항목은 이 쿼리나 계산 식의 사용자 지정 연산입니다. {1}개의 인수가 필요한데 {2}개가 제공되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterToken">
        <source>Expected an expression after this point</source>
        <target state="translated">이 지점 뒤에 식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedTypeAfterToken">
        <source>Expected a type after this point</source>
        <target state="translated">이 지점 뒤에 형식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLBrackLess">
        <source>Unmatched '[&lt;'. Expected closing '&gt;]'</source>
        <target state="translated">'[&lt;'의 짝이 맞지 않습니다. 닫는 '&gt;]'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileMatch">
        <source>Unexpected end of input in 'match' expression. Expected 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</source>
        <target state="translated">'match' 식에 예기치 않은 입력의 끝이 있습니다. 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTry">
        <source>Unexpected end of input in 'try' expression. Expected 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;'.</source>
        <target state="translated">'try' 식에 예기치 않은 입력의 끝이 있습니다. 'try &lt;expr&gt; with &lt;rules&gt;' 또는 'try &lt;expr&gt; finally &lt;expr&gt;'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWhile">
        <source>Unexpected end of input in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'while' 식에 예기치 않은 입력의 끝이 있습니다. 'while &lt;expr&gt; do &lt;expr&gt;'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFor">
        <source>Unexpected end of input in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'for' 식에 예기치 않은 입력 끝이 있습니다. 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWith">
        <source>Unexpected end of input in 'match' or 'try' expression</source>
        <target state="translated">'match' 또는 'try' 식에 예기치 않은 입력의 끝이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileThen">
        <source>Unexpected end of input in 'then' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">조건식의 'then' 분기에 예기치 않은 입력의 끝이 있습니다. 'if &lt;expr&gt; then &lt;expr&gt;' 또는 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileElse">
        <source>Unexpected end of input in 'else' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">조건식의 'else' 분기에 예기치 않은 입력의 끝이 있습니다. 'if &lt;expr&gt; then &lt;expr&gt;' 또는 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFunBody">
        <source>Unexpected end of input in body of lambda expression. Expected 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</source>
        <target state="translated">람다 식 본문에 예기치 않은 입력의 끝이 있습니다. 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeArgs">
        <source>Unexpected end of input in type arguments</source>
        <target state="translated">형식 인수에 예기치 않은 입력의 끝이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeSignature">
        <source>Unexpected end of input in type signature</source>
        <target state="translated">형식 서명에 예기치 않은 입력의 끝이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeDefinition">
        <source>Unexpected end of input in type definition</source>
        <target state="translated">형식 정의에 예기치 않은 입력의 끝이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileObjectMembers">
        <source>Unexpected end of input in object members</source>
        <target state="translated">개체 멤버에 예기치 않은 입력의 끝이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileDefinition">
        <source>Unexpected end of input in value, function or member definition</source>
        <target state="translated">값, 함수 또는 멤버 정의에 예기치 않은 입력의 끝이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileExpression">
        <source>Unexpected end of input in expression</source>
        <target state="translated">식에 예기치 않은 입력의 끝이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedNameAfterToken">
        <source>Unexpected end of type. Expected a name after this point.</source>
        <target state="translated">예기치 않은 형식의 끝입니다. 이 지점 뒤에 이름이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLet">
        <source>Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.</source>
        <target state="translated">값 또는 함수 정의가 불완전합니다. 해당 항목이 식인 경우 식 본문을 'let' 키워드와 같은 열로 들여써야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLetBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword.</source>
        <target state="translated">값 정의가 불완전합니다. 해당 항목이 식인 경우 식 본문을 'let!' 키워드와 같은 열로 들여써야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUseBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword.</source>
        <target state="translated">값 정의가 불완전합니다. 해당 항목이 식인 경우 식 본문을 'use!' 키워드와 같은 열로 들여써야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUse">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword.</source>
        <target state="translated">값 정의가 불완전합니다. 해당 항목이 식인 경우 식 본문을 'use' 키워드와 같은 열로 들여써야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsWhileDoExpected">
        <source>Missing 'do' in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'while' 식에서 'do'가 누락되었습니다. 'while &lt;expr&gt; do &lt;expr&gt;'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsForDoExpected">
        <source>Missing 'do' in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'for' 식에서 'do'가 누락되었습니다. 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRelationInJoin">
        <source>Invalid join relation in '{0}'. Expected 'expr &lt;op&gt; expr', where &lt;op&gt; is =, =?, ?= or ?=?.</source>
        <target state="translated">'{0}'의 조인 관계가 잘못되었습니다. 'expr &lt;op&gt; expr'이 필요합니다. 여기서 &lt;op&gt;는 =, =?, ?= 또는 ?=?입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCallsWord">
        <source>Calls</source>
        <target state="translated">호출</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidNumberOfGenericArguments">
        <source>Invalid number of generic arguments to type '{0}' in provided type. Expected '{1}' arguments, given '{2}'.</source>
        <target state="translated">제공된 형식에서 '{0}' 형식에 대한 제네릭 인수의 수가 잘못되었습니다. '{1}'개의 인수가 필요한데 '{2}'개가 제공되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument1">
        <source>Invalid value '{0}' for unit-of-measure parameter '{1}'</source>
        <target state="translated">측정 단위 매개 변수 '{1}'의 값 '{0}'이(가) 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument2">
        <source>Invalid value unit-of-measure parameter '{0}'</source>
        <target state="translated">측정 단위 매개 변수 '{0}'의 값이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyNeedsCanWriteOrCanRead">
        <source>Property '{0}' on provided type '{1}' is neither readable nor writable as it has CanRead=false and CanWrite=false</source>
        <target state="translated">제공된 '{1}' 형식의 '{0}' 속성은 CanRead=false이고 CanWrite=false이므로 읽거나 쓸 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIntoNeedsRestOfQuery">
        <source>A use of 'into' must be followed by the remainder of the computation</source>
        <target state="translated">'into'를 사용하는 경우 뒤에 나머지 계산 부분이 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorDoesntAcceptInto">
        <source>The operator '{0}' does not accept the use of 'into'</source>
        <target state="translated">'{0}' 연산자에서는 'into'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationInvalid">
        <source>The definition of the custom operator '{0}' does not use a valid combination of attribute flags</source>
        <target state="translated">사용자 지정 연산자 '{0}'의 정의에서 올바른 특성 플래그 조합을 사용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisTypeMayNotHaveACLIMutableAttribute">
        <source>This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute.</source>
        <target state="translated">이 형식 정의는 'CLIMutable' 특성을 포함할 수 없습니다. 레코드 형식만 이 특성을 포함할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAutoPropertyRequiresImplicitConstructionSequence">
        <source>'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">'member val' 정의는 기본 생성자가 포함된 형식에서만 허용됩니다. 'type X(args) = ...'와 같이 형식 정의에 인수를 추가해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSet">
        <source>Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">속성 정의는 mutable로 선언할 수 없습니다. 이 속성을 설정할 수 있도록 표시하려면 'member val PropertyName = expr with get,set'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
        <source>To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">이 속성을 설정할 수 있도록 표시하려면 'member val PropertyName = expr with get,set'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefsOfByrefs">
        <source>Type '{0}' is illegal because in byref&lt;T&gt;, T cannot contain byref types.</source>
        <target state="translated">'{0}' 형식은 byref&lt;T&gt;에서 안에 있을 수 없습니다. T는 byref 형식을 포함할 수 없기 때문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastopsMaxArrayThirtyTwo">
        <source>F# supports array ranks between 1 and 32. The value {0} is not allowed.</source>
        <target state="translated">F#에서는 1에서 32까지의 배열 순위를 지원합니다. {0} 값은 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoIntegerForLoopInQuery">
        <source>In queries, use the form 'for x in n .. m do ...' for ranging over integers</source>
        <target state="translated">쿼리에서 정수 범위를 지정하려면 'for x in n .. m do ...' 형식을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoWhileInQuery">
        <source>'while' expressions may not be used in queries</source>
        <target state="translated">'while' 식은 쿼리에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoTryFinallyInQuery">
        <source>'try/finally' expressions may not be used in queries</source>
        <target state="translated">'try/finally' 식은 쿼리에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseMayNotBeUsedInQueries">
        <source>'use' expressions may not be used in queries</source>
        <target state="translated">'use' 식은 쿼리에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindMayNotBeUsedInQueries">
        <source>'let!', 'use!' and 'do!' expressions may not be used in queries</source>
        <target state="translated">'let!', 'use!' 및 'do!' 식은 쿼리에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnMayNotBeUsedInQueries">
        <source>'return' and 'return!' may not be used in queries</source>
        <target state="translated">'return' 및 'return!'은 쿼리에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryOperator">
        <source>This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type.</source>
        <target state="translated">알려진 쿼리 연산자가 아닙니다. 쿼리 연산자는 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' 및 'averageBy' 등의 식별자로, 'QueryBuilder' 형식에서 해당하는 메서드를 사용하여 정의됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryWithMayNotBeUsedInQueries">
        <source>'try/with' expressions may not be used in queries</source>
        <target state="translated">'try/with' 식은 쿼리에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonSimpleLetBindingInQuery">
        <source>This 'let' definition may not be used in a query. Only simple value definitions may be used in queries.</source>
        <target state="translated">이 'let' 정의는 쿼리에서 사용할 수 없습니다. 단순 값 정의만 쿼리에서 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTooManyStaticParameters">
        <source>Too many static parameters. Expected at most {0} parameters, but got {1} unnamed and {2} named parameters.</source>
        <target state="translated">정적 매개 변수가 너무 많습니다. 최대 {0}개의 매개 변수가 필요한데 명명되지 않은 매개 변수 {1}개와 명명된 매개 변수 {2}개가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="infosInvalidProvidedLiteralValue">
        <source>Invalid provided literal value '{0}'</source>
        <target state="translated">제공된 '{0}' 리터럴 값이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidPlatformTarget">
        <source>The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead.</source>
        <target state="translated">'anycpu32bitpreferred' 플랫폼은 EXE 대상에만 사용할 수 있습니다. 대신 'anycpu'를 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisValueMayNotBeInlined">
        <source>This member, function or value declaration may not be declared 'inline'</source>
        <target state="translated">이 멤버, 함수 또는 값 선언은 'inline'으로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErasedTypeUsedInGeneration">
        <source>The provider '{0}' returned a non-generated type '{1}' in the context of a set of generated types. Consider adjusting the type provider to only return generated types.</source>
        <target state="translated">{0}' 공급자가 생성된 형식 컨텍스트에 생성되지 않은 형식 '{1}'을(를) 반환했습니다. 생성된 형식만 반환하도록 형식 공급자를 조정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryBinaryOperator">
        <source>Arguments to query operators may require parentheses, e.g. 'where (x &gt; y)' or 'groupBy (x.Length / 10)'</source>
        <target state="translated">쿼리 연산자의 인수에는 'where (x &gt; y)' 또는 'groupBy (x.Length / 10)'과 같이 괄호가 필요할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoSetOfHole">
        <source>A quotation may not involve an assignment to or taking the address of a captured local variable</source>
        <target state="translated">인용구에 할당을 포함하거나 캡처된 로컬 변수의 주소를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloads1">
        <source>+ 1 overload</source>
        <target state="translated">+1개 오버로드</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloadsN">
        <source>+ {0} overloads</source>
        <target state="translated">+ {0} 오버로드</target>
        <note />
      </trans-unit>
      <trans-unit id="erasedTo">
        <source>Erased to</source>
        <target state="translated">지운 시간</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnfinishedExpression">
        <source>Unexpected token '{0}' or incomplete expression</source>
        <target state="translated">예기치 않은 토큰 '{0}' 또는 불완전한 식</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributeOnIncompleteCode">
        <source>Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.</source>
        <target state="translated">이 특성에 대한 코드 대상을 찾을 수 없습니다. 특성 뒤의 코드가 완료되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeNameCannotBeEmpty">
        <source>Type name cannot be empty.</source>
        <target state="translated">형식 이름은 비워 둘 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemReadingAssembly">
        <source>Problem reading assembly '{0}': {1}</source>
        <target state="translated">{0}' 어셈블리를 읽는 중 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTPFieldMustBeLiteral">
        <source>Invalid provided field. Provided fields of erased provided types must be literals.</source>
        <target state="translated">제공된 필드가 잘못되었습니다. 지워진 제공된 형식의 제공된 필드는 리터럴이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="loadingDescription">
        <source>(loading description...)</source>
        <target state="translated">(설명 로드 중...)</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionUnavailable">
        <source>(description unavailable...)</source>
        <target state="translated">(설명 없음...)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTyparMultipleClassConstraints">
        <source>A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.</source>
        <target state="translated">형식 변수가 여러 클래스 형식에 의해 제약을 받습니다. 형식 변수의 클래스 제약 조건은 하나여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMatchMayNotBeUsedWithQuery">
        <source>'match' expressions may not be used in queries</source>
        <target state="translated">'match' 식은 쿼리에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonTripleArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 3 arguments</source>
        <target state="translated">중위 연산자 멤버 '{0}'에 {1}개의 초기 인수가 있습니다. 3개 인수의 튜플이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="cannotResolveNullableOperators">
        <source>The operator '{0}' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">'{0}' 연산자를 확인할 수 없습니다. 'Microsoft.FSharp.Linq.NullableOperators' 모듈을 열어 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorRequiresIn">
        <source>'{0}' must be followed by 'in'. Usage: {1}.</source>
        <target state="translated">'{0}' 뒤에는 'in'이 와야 합니다. 사용법: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalMemberVarInObjectImplementation">
        <source>Neither 'member val' nor 'override val' definitions are permitted in object expressions.</source>
        <target state="translated">개체 식에는 'member val' 또는 'override val' 정의를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyCopyAndUpdateRecordInvalid">
        <source>Copy-and-update record expressions must include at least one field.</source>
        <target state="translated">레코드 복사 및 업데이트 식에는 적어도 하나의 필드가 포함되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnderscoreInvalidFieldName">
        <source>'_' cannot be used as field name</source>
        <target state="translated">필드 이름에는 '_'을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGeneratedTypesShouldBeInternalOrPrivate">
        <source>The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'.</source>
        <target state="translated">이런 방법으로 형식 공급자를 사용하여 생성된 제공된 형식은 다른 F# 어셈블리에서 사용할 수 없으므로 내부 또는 개인 형식으로 표시해야 합니다. 'type internal TypeName = ...' 또는 'type private TypeName = ...'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterAndSetterHaveSamePropertyType">
        <source>A property's getter and setter must have the same type. Property '{0}' has getter of type '{1}' but setter of type '{2}'.</source>
        <target state="translated">속성의 getter 및 setter는 형식이 같아야 합니다. '{0}' 속성의 getter 형식은 '{1}'인데 setter 형식은 '{2}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRuntimeSuppliedMethodCannotBeUsedInUserCode">
        <source>Array method '{0}' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.</source>
        <target state="translated">배열 메서드 '{0}'은(는) 런타임에서 제공되며 코드에 직접 사용할 수 없습니다. 배열 요소를 사용하는 작업에서는 LanguagePrimitives.IntrinsicFunctions 모듈의 GetArray/SetArray 함수 패밀리를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName">
        <source>The union case '{0}' does not have a field named '{1}'.</source>
        <target state="translated">공용 구조체 케이스 '{0}'에 '{1}' 필드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseFieldCannotBeUsedMoreThanOnce">
        <source>Union case/exception field '{0}' cannot be used more than once.</source>
        <target state="translated">공용 구조체 케이스/예외 필드 '{0}'은(는) 두 번 이상 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameIsUsedModeThanOnce">
        <source>Named field '{0}' is used more than once.</source>
        <target state="translated">명명된 필드 {0}이(가) 두 번 이상 사용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameConflictsWithGeneratedNameForAnonymousField">
        <source>Named field '{0}' conflicts with autogenerated name for anonymous field.</source>
        <target state="translated">명명된 필드 '{0}'이(가) 자동 생성된 익명 필드 이름과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConstantExpressionOverflow">
        <source>This literal expression or attribute argument results in an arithmetic overflow.</source>
        <target state="translated">이 리터럴 식 또는 특성 인수를 사용하면 산술 연산 오버플로가 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalStructTypeForConstantExpression">
        <source>This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.</source>
        <target state="translated">유효한 리터럴 식이 아닙니다. [&lt;Literal&gt;] 특성은 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscSystemRuntimeInteropServicesIsRequired">
        <source>System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.</source>
        <target state="translated">UnknownWrapper\DispatchWrapper 클래스를 사용하려면 System.Runtime.InteropServices 어셈블리가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="abImplicitHeapAllocation">
        <source>The mutable local '{0}' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.</source>
        <target state="translated">변경할 수 있는 로컬 '{0}'이(가) 암시적으로 참조 셀로 할당되었습니다. 닫기에서 캡처되었기 때문입니다. 이 경고는 정보 제공 목적으로만 발생하며 암시적 할당이 수행되는 위치에 나타납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="estApplyStaticArgumentsForMethodNotImplemented">
        <source>A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid</source>
        <target state="translated">형식 공급자는 GetStaticParametersForMethod를 구현하지만 ApplyStaticArgumentsForMethod는 구현되지 않거나 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToMethod">
        <source>An error occured applying the static arguments to a provided method</source>
        <target state="translated">제공된 메서드에 정적 인수를 적용하는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexUnexpectedChar">
        <source>Unexpected character '{0}' in preprocessor expression</source>
        <target state="translated">전처리기 식에 예기치 않은 문자 '{0}'이(가) 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsUnexpectedToken">
        <source>Unexpected token '{0}' in preprocessor expression</source>
        <target state="translated">전처리기 식에 예기치 않은 토큰 '{0}'이(가) 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsIncompleteExpression">
        <source>Incomplete preprocessor expression</source>
        <target state="translated">전처리기 식이 불완전합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsMissingToken">
        <source>Missing token '{0}' in preprocessor expression</source>
        <target state="translated">전처리기 식에 토큰 '{0}'이(가) 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleMissingDefinition">
        <source>An error occurred while reading the F# metadata node at position {0} in table '{1}' of assembly '{2}'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.</source>
        <target state="translated">어셈블리 '{2}' 테이블 '{1}'의 {0} 위치에서 F# 메타데이터 노드를 읽는 중 오류가 발생했습니다. 노드에 일치하는 선언이 없습니다. 이 경고를 보고해 주세요. 사용하고 있는 F# 어셈블리를 다시 컴파일해야 할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScope">
        <source>Type inference caused the type variable {0} to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.</source>
        <target state="translated">형식 유추로 인해 형식 변수 {0}이(가) 범위를 벗어났습니다. 명시적인 형식 매개 변수 선언을 추가하거나 덜 일반적인 코드로 조정해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScopeAnon">
        <source>Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.</source>
        <target state="translated">형식 유추로 인해 유추 형식 변수가 범위를 벗어났습니다. 형식 주석을 추가하여 덜 일반적인 코드로 만들어 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkRaiseFamilyFunctionArgumentCount">
        <source>Redundant arguments are being ignored in function '{0}'. Expected {1} but got {2} arguments.</source>
        <target state="translated">중복 인수는 함수 '{0}'에서 무시되고 있습니다. {1}(을)를 예상했으나 {2} 인수를 받았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkLowercaseLiteralBindingInPattern">
        <source>Lowercase literal '{0}' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.</source>
        <target state="translated">소문자 리터럴 '{0}'이(가) 이름이 같은 새 패턴에서 섀도 처리되고 있습니다. 모듈이 접두사로 붙은 대문자 리터럴만 명명된 패턴으로 사용될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralDoesNotTakeArguments">
        <source>This literal pattern does not take arguments</source>
        <target state="translated">이 리터럴 패턴은 인수를 사용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalInAugmentation">
        <source>Constructors are not permitted as extension members - they must be defined as part of the original definition of the type</source>
        <target state="translated">생성자는 확장 멤버로 사용할 수 없으며 원래 형식 정의의 일부로 정의되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidResponseFile">
        <source>Invalid response file '{0}' ( '{1}' )</source>
        <target state="translated">잘못된 지시 파일 '{0}'('{1}')</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNotFound">
        <source>Response file '{0}' not found in '{1}'</source>
        <target state="translated">{1}'에서 지시 파일 '{0}'을(를) 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNameInvalid">
        <source>Response file name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">지시 파일 이름 '{0}'이(가) 비어 있거나, 잘못된 문자를 포함하거나, 드라이브 사양에 절대 경로가 없거나, 길이가 너무 깁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fsharpCoreNotFoundToBeCopied">
        <source>Cannot find FSharp.Core.dll in compiler's directory</source>
        <target state="translated">컴파일러의 디렉터리에서 FSharp.Core.dll을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleStructMismatch">
        <source>One tuple type is a struct tuple, the other is a reference tuple</source>
        <target state="translated">한 튜플 형식은 구조체 튜플이고 다른 튜플 형식은 참조 튜플입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMissingStaticArgumentsToMethod">
        <source>This provided method requires static parameters</source>
        <target state="translated">이 제공된 메서드는 정적 매개 변수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcast">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'.</source>
        <target state="translated">{0}에서 {1}(으)로의 변환은 컴파일 시간에 안전한 업캐스트이며 다운캐스트가 아닙니다. '다운캐스트'가 아닌 '업캐스트'를 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcastOperator">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.</source>
        <target state="translated">{0}에서 {1}(으)로의 변환은 컴파일 시간에 안전한 업캐스트이며 다운캐스트가 아닙니다. :?&gt; (다운캐스트) 연산자가 아닌 :?&gt; (업캐스트) 연산자를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecImplied">
        <source>The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored</source>
        <target state="translated">이 모듈에 대한 'rec'는 외부 'rec' 선언에 의해 암시되며 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenFirstInMutRec">
        <source>In a recursive declaration group, 'open' declarations must come first in each module</source>
        <target state="translated">재귀 선언 그룹에서 'open' 선언은 각 모듈에서 맨 앞에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbrevFirstInMutRec">
        <source>In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations</source>
        <target state="translated">재귀 선언 그룹에서 모듈 약어는 모든 'open' 선언의 뒤에 있으면서 다른 선언의 앞에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedMutRecDecl">
        <source>This declaration is not supported in recursive declaration groups</source>
        <target state="translated">이 선언은 재귀 선언 그룹에서는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidUseOfRec">
        <source>Invalid use of 'rec' keyword</source>
        <target state="translated">'rec' 키워드를 잘못 사용했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructUnionMultiCaseDistinctFields">
        <source>If a union type has more than one case and is a struct, then all fields within the union type must be given unique names.</source>
        <target state="translated">공용 구조체 형식이 둘 이상의 case를 포함하고 구조체인 경우 공용 구조체 형식 내의 모든 필드에 고유한 이름을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerMemberNameIsOverriden">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">{0}' 매개 변수에 적용되는 CallerMemberNameAttribute는 효과가 없습니다. CallerFilePathAttribute에서 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFixedNotAllowed">
        <source>Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'</source>
        <target state="translated">'fixed'를 잘못 사용했습니다. 'fixed'는 식이 배열, 필드의 주소, 배열 요소 또는 문자열의 주소인 경우 'use x = fixed expr' 형식의 선언에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindOffsetToStringData">
        <source>Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression.</source>
        <target state="translated">'fixed' 식을 빌드할 때 참조에서 System.Runtime.CompilerServices.OffsetToStringData 메서드를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedActivePattern">
        <source>{0} is an active pattern and cannot be treated as a discriminated union case with named fields.</source>
        <target state="translated">{0}은(는) 활성 패턴이며 명명된 필드가 있는 구분된 공용 구조체 케이스로 처리될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultParameterValueNotAppropriateForArgument">
        <source>The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'.</source>
        <target state="translated">기본값에 인수와 같은 형식이 없습니다. DefaultParameterValue 특성 및 모든 Optional 특성은 무시됩니다. 참고: 'null'은 올바른 형식으로 주석이 추가되어야 합니다(예: 'DefaultParameterValue(null:obj)').</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGlobalsSystemTypeNotFound">
        <source>The system type '{0}' was required but no referenced system DLL contained this type</source>
        <target state="translated">시스템 형식 '{0}'이(가) 필요했지만, 참조된 시스템 DLL에 이 형식이 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberHasMultiplePossibleDispatchSlots">
        <source>The member '{0}' matches multiple overloads of the same method.\nPlease restrict it to one of the following:{1}.</source>
        <target state="translated">{0}' 멤버는 동일한 메서드의 여러 오버로드와 일치합니다.\n다음 중 하나로 제한하세요. {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="methodIsNotStatic">
        <source>Method or object constructor '{0}' is not static</source>
        <target state="translated">메서드 또는 개체 생성자 '{0}'이(가) 정적이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolEqualsInsteadOfIn">
        <source>Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?</source>
        <target state="translated">식에 예기치 않은 '=' 기호가 있습니다. 대신 'for x in y .. z do'를 사용하려고 했나요?</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAbstract">
        <source>Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</source>
        <target state="translated">선언된 형식에 구현이 없는 메서드 또는 기본 구현이 있는 가상 메서드를 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keyworkDescriptionAnd">
        <source>Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</source>
        <target state="translated">상호 재귀적 바인딩과 속성 선언에 사용되며 제네릭 매개 변수의 여러 제약 조건과 함께 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAs">
        <source>Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</source>
        <target state="translated">현재 클래스 개체 및 개체 이름을 제공하는 데 사용됩니다. 패턴 일치 내의 전체 패턴에 이름을 제공하는 데에도 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAssert">
        <source>Used to verify code during debugging.</source>
        <target state="translated">디버그 중 코드를 확인하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBase">
        <source>Used as the name of the base class object.</source>
        <target state="translated">기본 클래스 개체의 이름으로 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBegin">
        <source>In verbose syntax, indicates the start of a code block.</source>
        <target state="translated">자세한 구문에서 코드 블록의 시작을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionClass">
        <source>In verbose syntax, indicates the start of a class definition.</source>
        <target state="translated">자세한 구문에서 클래스 정의의 시작을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDefault">
        <source>Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</source>
        <target state="translated">추상 메서드의 구현을 나타냅니다. 추상 메서드 선언과 함께 사용하여 가상 메서드를 만듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDelegate">
        <source>Used to declare a delegate.</source>
        <target state="translated">대리자를 선언하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDo">
        <source>Used in looping constructs or to execute imperative code.</source>
        <target state="translated">루프 구문에 사용되거나 명령형 코드를 실행하기 위해 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDone">
        <source>In verbose syntax, indicates the end of a block of code in a looping expression.</source>
        <target state="translated">자세한 구문에서 루프 식의 코드 블록 끝을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDowncast">
        <source>Used to convert to a type that is lower in the inheritance chain.</source>
        <target state="translated">상속 체인에서 더 낮은 형식으로 변환하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDownto">
        <source>In a for expression, used when counting in reverse.</source>
        <target state="translated">for 식에서 역으로 계산할 때 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElif">
        <source>Used in conditional branching. A short form of else if.</source>
        <target state="translated">조건부 분기에 사용됩니다. else if의 약식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElse">
        <source>Used in conditional branching.</source>
        <target state="translated">조건부 분기에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionEnd">
        <source>In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</source>
        <target state="translated">형식 정의 및 형식 확장에서 멤버 정의 섹션의 끝을 나타냅니다. 자세한 구문에서 begin 키워드로 시작하는 코드 블록의 끝을 지정하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionException">
        <source>Used to declare an exception type.</source>
        <target state="translated">예외 형식을 선언하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionExtern">
        <source>Indicates that a declared program element is defined in another binary or assembly.</source>
        <target state="translated">선언된 프로그램 요소가 다른 이진 또는 어셈블리에 정의됨을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTrueFalse">
        <source>Used as a Boolean literal.</source>
        <target state="translated">부울 리터럴로 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFinally">
        <source>Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</source>
        <target state="translated">예외 발생 여부에 상관없이 실행되는 코드 블록을 지정하기 위해 try와 함께 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFor">
        <source>Used in looping constructs.</source>
        <target state="translated">루프 구문에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFun">
        <source>Used in lambda expressions, also known as anonymous functions.</source>
        <target state="translated">익명 함수라고도 하는 람다 식에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFunction">
        <source>Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</source>
        <target state="translated">단일 인수에 패턴 일치가 있는 람다 식에서 fun 키워드 및 일치 식에 대한 간단한 대체로 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionGlobal">
        <source>Used to reference the top-level .NET namespace.</source>
        <target state="translated">최상위 .NET 네임스페이스를 참조하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIf">
        <source>Used in conditional branching constructs.</source>
        <target state="translated">조건부 분기 구문에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIn">
        <source>Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</source>
        <target state="translated">바인딩에서 식을 구분하기 위해 시퀀스 식과 자세한 구문에서 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInherit">
        <source>Used to specify a base class or base interface.</source>
        <target state="translated">기본 클래스 또는 기본 인터페이스를 지정하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInline">
        <source>Used to indicate a function that should be integrated directly into the caller's code.</source>
        <target state="translated">호출자의 코드로 바로 통합되어야 하는 함수를 나타내는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInterface">
        <source>Used to declare and implement interfaces.</source>
        <target state="translated">인터페이스를 선언하고 구현하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInternal">
        <source>Used to specify that a member is visible inside an assembly but not outside it.</source>
        <target state="translated">멤버가 어셈블리 안에서는 보이지만 어셈블리 밖에서는 보이지 않도록 지정하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLazy">
        <source>Used to specify a computation that is to be performed only when a result is needed.</source>
        <target state="translated">결과가 필요한 경우에만 수행되는 계산을 지정하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLet">
        <source>Used to associate, or bind, a name to a value or function.</source>
        <target state="translated">값 또는 함수에 이름을 연결하거나 바인딩하기 위해 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLetBang">
        <source>Used in computation expressions to bind a name to the result of another computation expression.</source>
        <target state="translated">계산 식에 사용되어 다른 계산 식 결과에 이름을 바인딩합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatch">
        <source>Used to branch by comparing a value to a pattern.</source>
        <target state="translated">패턴에 대한 값을 비교하여 분기하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMember">
        <source>Used to declare a property or method in an object type.</source>
        <target state="translated">개체 형식에서 속성 또는 메서드를 선언하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionModule">
        <source>Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</source>
        <target state="translated">관련 형식, 값 및 함수 그룹과 이름을 연결하기 위해 사용되며, 다른 코드와 논리적으로 구별하기 위해 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMutable">
        <source>Used to declare a variable, that is, a value that can be changed.</source>
        <target state="translated">변경될 수 있는 값인 변수를 선언하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNamespace">
        <source>Used to associate a name with a group of related types and modules, to logically separate it from other code.</source>
        <target state="translated">관련 형식 및 모듈 그룹과 이름을 연결하기 위해 사용되며, 다른 코드와 논리적으로 구별하기 위해 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNew">
        <source>Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.</source>
        <target state="translated">개체를 생성하거나 생성할 수 있는 생성자를 선언하거나 정의하거나 호출하는 데 사용됩니다. 형식에 특정 생성자가 있어야 함을 나타내기 위해 제네릭 매개 변수 제약 조건에서도 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNot">
        <source>Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</source>
        <target state="translated">실제로 키워드가 아니지만, 조합의 not struct는 제네릭 매개 변수 제약 조건으로 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNull">
        <source>Indicates the absence of an object. Also used in generic parameter constraints.</source>
        <target state="translated">개체가 없음을 나타냅니다. 제네릭 매개 변수 제약 조건에서도 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOf">
        <source>Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</source>
        <target state="translated">구분된 공용 구조체에 사용되어 값 범주의 형식을 나타내고, 대리자 및 예외 선언에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOpen">
        <source>Used to make the contents of a namespace or module available without qualification.</source>
        <target state="translated">한정자 없이 사용할 수 있는 네임스페이스 또는 모듈의 콘텐츠를 만드는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOr">
        <source>Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.</source>
        <target state="translated">부울 또는 연산자로 부울 조건과 함께 사용됩니다. ||와 같습니다. 멤버 제약 조건에도 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOverride">
        <source>Used to implement a version of an abstract or virtual method that differs from the base version.</source>
        <target state="translated">기본 버전과 다른, 추상 메서드 또는 가상 메서드의 버전을 구현하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPrivate">
        <source>Restricts access to a member to code in the same type or module.</source>
        <target state="translated">동일한 형식 또는 모듈에서 코딩하기 위해 멤버에 대한 액세스를 제한합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPublic">
        <source>Allows access to a member from outside the type.</source>
        <target state="translated">형식 외부에서 멤버에 대한 액세스를 허용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRec">
        <source>Used to indicate that a function is recursive.</source>
        <target state="translated">함수가 재귀적임을 나타내는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturn">
        <source>Used to provide a value for the result of the containing computation expression.</source>
        <target state="translated">포함하는 계산 식의 결과에 대한 값을 제공하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturnBang">
        <source>Used to provide a value for the result of the containing computation expression, where that value itself comes from the result another computation expression.</source>
        <target state="translated">포함하는 계산 식의 결과에 대한 값을 제공하는 데 사용되지만, 값 자체는 다른 계산 식의 결과에서 가져온 것입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionSelect">
        <source>Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</source>
        <target state="translated">추출할 필드 또는 열을 지정하기 위해 쿼리 식에 사용됩니다. 이것은 상황별 키워드입니다. 즉 실제로 예약어가 아니며, 적절한 컨텍스트에서 키워드처럼만 작동합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStatic">
        <source>Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</source>
        <target state="translated">형식의 인스턴스 없이 호출될 수 있는 메서드나 속성, 또는 모든 형식의 인스턴스 간 공유되는 값 멤버를 나타내는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStruct">
        <source>Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions.</source>
        <target state="translated">구조체 형식을 선언하는 데 사용됩니다. 제네릭 매개 변수 제약 조건에서도 사용됩니다. 모듈 정의에서 OCaml 호환성에 대해 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionThen">
        <source>Used in conditional expressions. Also used to perform side effects after object construction.</source>
        <target state="translated">조건식에 사용됩니다. 또한 개체 생성 후 파생 작업을 수행하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTo">
        <source>Used in for loops to indicate a range.</source>
        <target state="translated">범위를 나타내기 위해 루프에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTry">
        <source>Used to introduce a block of code that might generate an exception. Used together with with or finally.</source>
        <target state="translated">예외를 생성할 수 있는 코드 블록을 지정하는 데 사용됩니다. with 또는 finally와 함께 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionType">
        <source>Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</source>
        <target state="translated">클래스, 레코드, 구조체, 구분된 공용 구조체, 열거형 형식, 측정 단위 또는 형식 약어를 선언하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUpcast">
        <source>Used to convert to a type that is higher in the inheritance chain.</source>
        <target state="translated">상속 체인에서 더 높은 형식으로 변환하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUse">
        <source>Used instead of let for values that implement IDisposable</source>
        <target state="translated">IDisposable을 구현하는 값에 let 대신 사용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUseBang">
        <source>Used instead of let! in computation expressions for computation expression results that implement IDisposable.</source>
        <target state="translated">IDisposable을 구현하는 계산 식 결과를 위해 계산 식에서 let! 대신 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVal">
        <source>Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</source>
        <target state="translated">시그니처에 사용되어 값을 나타내거나 형식에 사용되어 제한된 상황에서 멤버를 선언합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVoid">
        <source>Indicates the .NET void type. Used when interoperating with other .NET languages.</source>
        <target state="translated">.NET void 형식을 나타냅니다. 다른 .NET 언어와 상호 운용할 때 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhen">
        <source>Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.</source>
        <target state="translated">패턴 일치의 부울 조건(가드 시)으로 사용되며, 제네릭 형식 매개 변수에 대한 제약 조건 절을 지정하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhile">
        <source>Introduces a looping construct.</source>
        <target state="translated">루프 구문을 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWith">
        <source>Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</source>
        <target state="translated">패턴 일치 식에서 일치 키워드와 함께 사용됩니다. 또한 개체 식, 레코드 복사 식, 형식 확장에 사용되어 멤버 정의를 지정하고 예외 처리기를 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYield">
        <source>Used in a sequence expression to produce a value for a sequence.</source>
        <target state="translated">시퀀스에 대한 값을 생성하기 위해 시퀀스 식에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYieldBang">
        <source>Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</source>
        <target state="translated">포함하는 계산 식의 결과 모음에 제공된 계산 식의 결과를 추가하기 위해, 계산 식에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRightArrow">
        <source>In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions</source>
        <target state="translated">함수 형식에서 인수와 반환 값을 구분합니다. 시퀀스 식에서 식을 만들며, yield 키워드와 동일합니다. 일치 식에서 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLeftArrow">
        <source>Assigns a value to a variable.</source>
        <target state="translated">변수에 값을 할당합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionCast">
        <source>Converts a type to type that is higher in the hierarchy.</source>
        <target state="translated">계층 구조에서 더 높은 형식으로 형식을 변환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDynamicCast">
        <source>Converts a type to a type that is lower in the hierarchy.</source>
        <target state="translated">계층 구조에서 더 낮은 형식으로 형식을 변환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTypedQuotation">
        <source>Delimits a typed code quotation.</source>
        <target state="translated">형식이 지정된 코드 인용을 구분합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUntypedQuotation">
        <source>Delimits a untyped code quotation.</source>
        <target state="translated">형식이 지정되지 않은 코드 인용을 구분합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundDuringDynamicCodeGen">
        <source>{0} '{1}' not found in assembly '{2}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{2}' 어셈블리에서 {0} '{1}'을(를) 찾을 수 없습니다. 가능한 원인은 버전이 호환되지 않기 때문일 수 있습니다. 참조된 모든 구성 요소에서 올바른 버전을 사용할 수 있게 하려면 이 어셈블리의 올바른 버전을 명시적으로 참조해야 할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundInTypeDuringDynamicCodeGen">
        <source>{0} '{1}' not found in type '{2}' from assembly '{3}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{3}' 어셈블리의 '{2}' 형식에서 {0} '{1}'을(를) 찾을 수 없습니다. 가능한 원인은 버전이 호환되지 않기 때문일 수 있습니다. 참조된 모든 구성 요소에서 올바른 버전을 사용할 수 있게 하려면 이 어셈블리의 올바른 버전을 명시적으로 참조해야 할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionWordIs">
        <source>is</source>
        <target state="translated">은(는)</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunction">
        <source>This value is not a function and cannot be applied.</source>
        <target state="translated">이 값은 함수가 아니며 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexerWithName">
        <source>This value is not a function and cannot be applied. Did you intend to access the indexer via {0}.[index] instead?</source>
        <target state="translated">이 식은 함수가 아니며 적용할 수 없습니다. 대신 {0}.[index]를 통해 인덱서에 액세스하려고 했나요?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexer">
        <source>This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?</source>
        <target state="translated">이 식은 함수가 아니며 적용할 수 없습니다. 대신 expr.[index]를 통해 인덱서에 액세스하려고 했나요?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeDeclaration">
        <source>This value is not a function and cannot be applied. Did you forget to terminate a declaration?</source>
        <target state="translated">이 값은 함수가 아니며 적용할 수 없습니다. 선언을 종료해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentsInSigAndImplMismatch">
        <source>The argument names in the signature '{0}' and implementation '{1}' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling.</source>
        <target state="translated">시그니처 '{0}'과(와) 구현 '{1}'의 인수 이름이 일치하지 않습니다. 시그니처 파일의 인수 이름이 사용됩니다. 이로 인해 디버깅 또는 프로파일링 시 문제가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleUnexpectedNonZero">
        <source>An error occurred while reading the F# metadata of assembly '{0}'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct.</source>
        <target state="translated">'{0}' 어셈블리의 F# 메타데이터를 읽는 동안 오류가 발생했습니다. 예약 구문이 활용되었습니다. F# 컴파일러를 업그레이드하거나 특정 구문을 사용하지 않는 이전 버전의 어셈블리를 사용해야 할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleMemberNotNormallyUsed">
        <source>This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.</source>
        <target state="translated">이 메서드 또는 속성은 일반적으로 F# 코드에서 사용되지 않습니다. 대신 분해에 대해 명시적 튜플 패턴을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'.</source>
        <target state="translated">이 식은 '{0}' 형식의 값을 반환하지만 암시적으로 삭제됩니다. 'let'을 사용하여 결과를 이름에 바인딩하세요(예: 'let result = expression'). 식을 시퀀스의 값으로 사용하려면 명시적 'yield'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedSequenceInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'.</source>
        <target state="translated">이 식은 '{0}' 형식의 값을 반환하지만 암시적으로 삭제됩니다. 'let'을 사용하여 결과를 이름에 바인딩하세요(예: 'let result = expression'). 식을 시퀀스의 값으로 사용하려면 명시적 'yield!'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatchBang">
        <source>Used in computation expressions to pattern match directly over the result of another computation expression.</source>
        <target state="translated">다른 계산 식의 결과에 대해 직접적으로 패턴 일치에 대한 계산 식에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilreadFileChanged">
        <source>The file '{0}' changed on disk unexpectedly, please reload.</source>
        <target state="translated">'{0}' 파일이 디스크에서 예기치 않게 변경되었습니다. 다시 로드하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="writeToReadOnlyByref">
        <source>The byref pointer is readonly, so this write is not permitted.</source>
        <target state="translated">byref 포인터는 읽기 전용이므로 이 쓰기가 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeMutable">
        <source>A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'</source>
        <target state="translated">내용을 변경하거나 값 형식의 주소를 사용하려면 값을 변경할 수 있어야 합니다(예: 'let mutable x = ...').</target>
        <note />
      </trans-unit>
      <trans-unit id="readOnlyAttributeOnStructWithMutableField">
        <source>A ReadOnly attribute has been applied to a struct type with a mutable field.</source>
        <target state="translated">변경할 수 있는 필드가 있는 구조체 형식에 ReadOnly 특성이 적용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByrefReturnImplicitlyDereferenced">
        <source>A byref pointer returned by a function or method is implicitly dereferenced as of F# 4.5. To acquire the return value as a pointer, use the address-of operator, e.g. '&amp;f(x)' or '&amp;obj.Method(arg1, arg2)'.</source>
        <target state="translated">함수 또는 메서드에 의해 반환된 byref 포인터가 F# 4.5부터 암시적으로 역참조됩니다. 포인터로 반환 값을 가져오려면 address-of 연산자를 사용하세요(예: '&amp;f(x)' 또는 '&amp;obj.Method(arg1, arg2)').</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByRefLikeNotStruct">
        <source>A type annotated with IsByRefLike must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.</source>
        <target state="translated">IsByRefLike로 주석이 추가된 형식은 구조체여야 합니다. 형식에 [&lt;Struct&gt;] 특성을 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAddressOfLocal">
        <source>The address of the variable '{0}' or a related expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">지금은 '{0}' 변수의 주소 또는 관련 식을 사용할 수 없습니다. 로컬 값의 주소가 범위를 벗어나지 않도록 하기 위한 것입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoWriteToLimitedSpan">
        <source>This value can't be assigned because the target '{0}' may refer to non-stack-local memory, while the expression being assigned is assessed to potentially refer to stack-local memory. This is to help prevent pointers to stack-bound memory escaping their scope.</source>
        <target state="translated">'{0}' 대상이 비스택 로컬 메모리를 참조할 수 있는데, 할당되는 식은 잠재적으로 스택 로컬 메모리를 참조하도록 평가되므로 이 값을 할당할 수 없습니다. 스택에 바인딩된 메모리에 대한 포인터가 범위를 벗어나지 않도록 하기 위한 것입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeLocal">
        <source>A value defined in a module must be mutable in order to take its address, e.g. 'let mutable x = ...'</source>
        <target state="translated">해당 주소를 사용하려면 모듈에 정의된 값이 변경 가능해야 합니다(예: 'let mutable x = ...').</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIsReadOnlyNotStruct">
        <source>A type annotated with IsReadOnly must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.</source>
        <target state="translated">IsReadOnly로 주석이 추가된 형식은 구조체여야 합니다. 형식에 [&lt;Struct&gt;] 특성을 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkStructsMayNotReturnAddressesOfContents">
        <source>Struct members cannot return the address of fields of the struct by reference</source>
        <target state="translated">구조체 멤버는 구조체의 필드 주소를 참조로 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefLikeFunctionCall">
        <source>The function or method call cannot be used at this point, because one argument that is a byref of a non-stack-local Span or IsByRefLike type is used with another argument that is a stack-local Span or IsByRefLike type. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">비스택 로컬 Span 또는 IsByRefLike 형식의 byref인 한 인수가 스택 로컬 Span 또는 IsByRefLike 형식인 다른 인수와 함께 사용되므로 지금은 함수 또는 메서드 호출을 사용할 수 없습니다. 로컬 값의 주소가 범위를 벗어나지 않도록 하기 위한 것입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAddressOfValueFromExpression">
        <source>The address of a value returned from the expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">지금은 식에서 반환된 값의 주소를 사용할 수 없습니다. 로컬 값의 주소가 범위를 벗어나지 않도록 하기 위한 것입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoSpanLikeVariable">
        <source>The Span or IsByRefLike variable '{0}' cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">지금은 Span 또는 IsByRefLike 변수 '{0}'을(를) 사용할 수 없습니다. 로컬 값의 주소가 범위를 벗어나지 않도록 하기 위한 것입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoSpanLikeValueFromExpression">
        <source>A Span or IsByRefLike value returned from the expression cannot be used at ths point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">지금은 식에서 반환된 Span 또는 IsByRefLike 값을 사용할 수 없습니다. 로컬 값의 주소가 범위를 벗어나지 않도록 하기 위한 것입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastCantTakeAddressOfExpression">
        <source>Cannot take the address of the value returned from the expression. Assign the returned value to a let-bound value before taking the address.</source>
        <target state="translated">식에서 반환된 값의 주소를 가져올 수 없습니다. 주소를 가져오기 전에 반환된 값을 let 바인딩 값에 할당하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBraceBar">
        <source>Unmatched '{{|'</source>
        <target state="translated">'{{|'의 짝이 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoAnonRecdField">
        <source>anonymous record field</source>
        <target state="translated">무명 레코드 필드</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionConstructorDoesNotHaveFieldWithGivenName">
        <source>The exception '{0}' does not have a field named '{1}'.</source>
        <target state="translated">'{0}' 예외에 '{1}'(이)라는 필드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcActivePatternsDoNotHaveFields">
        <source>Active patterns do not have fields. This syntax is invalid.</source>
        <target state="translated">활성 패턴에 필드가 없습니다. 이 구문은 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorDoesNotHaveFieldWithGivenName">
        <source>The constructor does not have a field named '{0}'.</source>
        <target state="translated">생성자에 '{0}'(이)라는 필드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdCcuMismatch">
        <source>Two anonymous record types are from different assemblies '{0}' and '{1}'</source>
        <target state="translated">두 무명 레코드 형식은 서로 다른 어셈블리 '{0}' 및 '{1}'에서 가져왔습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameMismatch">
        <source>This anonymous record does not exactly match the expected shape. Add the missing fields {0} and remove the extra fields {1}.</source>
        <target state="translated">이 익명 레코드는 필요한 도형과 정확하게 일치하지 않습니다. 누락된 필드 {0}을(를) 추가하고 추가 필드 {1}을(를) 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallExtensionMethodInrefToByref">
        <source>Cannot call the byref extension method '{0}. The first parameter requires the value to be mutable or a non-readonly byref type.</source>
        <target state="translated">byref 확장 메서드 '{0}'을(를) 호출할 수 없습니다. 첫 번째 매개 변수는 변경할 수 있거나 읽기 전용이 아닌 byref 형식인 값이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByrefsMayNotHaveTypeExtensions">
        <source>Byref types are not allowed to have optional type extensions.</source>
        <target state="translated">byref 형식에는 선택적 형식 확장을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotPartiallyApplyExtensionMethodForByref">
        <source>Cannot partially apply the extension method '{0}' because the first parameter is a byref type.</source>
        <target state="translated">첫 번째 매개 변수가 byref 형식이므로 '{0}' 확장 메서드를 부분적으로 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDoesNotInheritAttribute">
        <source>This type does not inherit Attribute, it will not work correctly with other .NET languages.</source>
        <target state="translated">이 형식을 특성을 상속하지 않으므로 다른 .NET 언어에서 올바로 작동하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidAnonRecdExpr">
        <source>Invalid anonymous record expression</source>
        <target state="translated">잘못된 무명 레코드 식</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidAnonRecdType">
        <source>Invalid anonymous record type</source>
        <target state="translated">잘못된 무명 레코드 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCopyAndUpdateNeedsRecordType">
        <source>The input to a copy-and-update expression that creates an anonymous record must be either an anonymous record or a record</source>
        <target state="translated">무명 레코드를 만드는 복사 및 업데이트 식의 입력은 무명 레코드이거나 레코드여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidFunctionParameterType">
        <source>The parameter '{0}' has an invalid type '{1}'. This is not permitted by the rules of Common IL.</source>
        <target state="translated">'{0}' 매개 변수에 잘못된 형식 '{1}'이(가) 있습니다. 이 형식은 공통 IL의 규칙에서 허용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidFunctionReturnType">
        <source>The function or method has an invalid return type '{0}'. This is not permitted by the rules of Common IL.</source>
        <target state="translated">함수 또는 메서드에 잘못된 반환 형식 '{0}'이(가) 있습니다. 이는 공통 IL의 규칙에서 허용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveral">
        <source>No implementation was given for those members: {0}</source>
        <target state="translated">멤버 {0}에 지정된 구현이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralWithSuggestion">
        <source>No implementation was given for those members: {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">멤버 {0}에 지정된 구현이 없습니다. 모든 인터페이스 멤버가 구현되어 적절한 'interface' 선언에 나열되어야 합니다(예: 'interface ... with member ...').</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralTruncated">
        <source>No implementation was given for those members (some results omitted): {0}</source>
        <target state="translated">멤버 {0}에 지정된 구현이 없습니다(일부 결과는 생략됨).</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralTruncatedWithSuggestion">
        <source>No implementation was given for those members (some results omitted): {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">멤버 {0}에 지정된 구현이 없습니다(일부 결과는 생략됨). 모든 인터페이스 멤버가 구현되어 적절한 'interface' 선언에 나열되어야 합니다(예: 'interface ... with member ...').</target>
        <note />
      </trans-unit>
      <trans-unit id="expressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">식에 이름이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassNameOf">
        <source>Using the 'nameof' operator as a first-class function value is not permitted.</source>
        <target state="translated">'nameof' 연산자는 첫 번째 클래스 함수 값으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPathMap">
        <source>Maps physical paths to source path names output by the compiler</source>
        <target state="translated">컴파일러에서 실제 경로를 소스 경로 이름 출력에 매핑합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscPathMapDebugRequiresPortablePdb">
        <source>--pathmap can only be used with portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">--pathmap은 이식 가능한 PDB에만 사용할 수 있습니다(--debug:portable 또는 --debug:embedded).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidPathMapFormat">
        <source>Invalid path map. Mappings must be comma separated and of the format 'path=sourcePath'</source>
        <target state="translated">잘못된 경로 맵입니다. 매핑은 쉼표로 구분되어야 하며 'path=sourcePath' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCompilerTool">
        <source>Reference an assembly or directory containing a design time tool (Short form: -t)</source>
        <target state="translated">디자인 타임 도구를 포함하는 어셈블리 또는 디렉터리를 참조합니다(약식: -t).</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagerUnknown">
        <source>Package manager key '{0}' was not registered in {1}. Currently registered: {2}</source>
        <target state="translated">패키지 관리자 키 '{0}'이(가) {1}에 등록되지 않았습니다. 현재 {2}이(가) 등록되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagerError">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="couldNotLoadDependencyManagerExtension">
        <source>The dependency manager extension {0} could not be loaded. Message: {1}</source>
        <target state="translated">종속성 관리자 확장 {0}을(를) 로드할 수 없습니다. 메시지: {1}</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>