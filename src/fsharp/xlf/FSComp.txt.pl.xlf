<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pl" original="../FSComp.resx">
    <body>
      <trans-unit id="chkFeatureNotLanguageSupported">
        <source>Feature '{0}' is not available in F# {1}. Please use language version {2} or greater.</source>
        <target state="translated">Funkcja „{0}” nie jest dostępna w języku F# {1}. Użyj języka w wersji {2} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFeatureNotRuntimeSupported">
        <source>Feature '{0}' is not supported by target runtime.</source>
        <target state="translated">Funkcja „{0}” nie jest obsługiwana przez docelowe środowisko uruchomieniowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFeatureNotSupportedInLibrary">
        <source>Feature '{0}' requires the F# library for language version {1} or greater.</source>
        <target state="translated">Funkcja „{0}” wymaga biblioteki języka F# dla wersji językowej {1} lub nowszej.</target>
        <note />
      </trans-unit>
      <trans-unit id="csAvailableOverloads">
        <source>Available overloads:\n{0}</source>
        <target state="translated">Dostępne przeciążenia:\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructOrReferenceConstraint">
        <source>A generic construct requires that a generic type parameter be known as a struct or reference type. Consider adding a type annotation.</source>
        <target state="translated">Konstrukcja ogólna wymaga, aby parametr typu ogólnego był znany jako struktura lub typ referencyjny. Rozważ dodanie adnotacji typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundArgumentsPrefixPlural">
        <source>Known types of arguments: {0}</source>
        <target state="translated">Znane typy argumentów: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundArgumentsPrefixSingular">
        <source>Known type of argument: {0}</source>
        <target state="translated">Znany typ argumentu: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundReturnType">
        <source>Known return type: {0}</source>
        <target state="translated">Znany zwracany typ: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundTypeParametersPrefixPlural">
        <source>Known type parameters: {0}</source>
        <target state="translated">Parametry znanego typu: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundTypeParametersPrefixSingular">
        <source>Known type parameter: {0}</source>
        <target state="translated">Parametr znanego typu: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csOverloadCandidateIndexedArgumentTypeMismatch">
        <source>Argument at index {0} doesn't match</source>
        <target state="translated">Argument pod indeksem {0} nie jest zgodny</target>
        <note />
      </trans-unit>
      <trans-unit id="csOverloadCandidateNamedArgumentTypeMismatch">
        <source>Argument '{0}' doesn't match</source>
        <target state="translated">Argument „{0}” nie jest zgodny</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasDesignerAssemblyDependency">
        <source>The type provider designer assembly '{0}' could not be loaded from folder '{1}' because a dependency was missing or could not loaded. All dependencies of the type provider designer assembly must be located in the same folder as that assembly. The exception reported was: {2} - {3}</source>
        <target state="translated">Nie można załadować zestawu projektanta dostawców typów „{0}” z folderu „{1}”, ponieważ brakuje zależności lub nie można jej załadować. Wszystkie zależności zestawu projektanta dostawców typów muszą znajdować się w tym samym folderze co ten zestaw. Zgłoszony wyjątek: {2} — {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasDesignerAssemblyException">
        <source>The type provider designer assembly '{0}' could not be loaded from folder '{1}'. The exception reported was: {2} - {3}</source>
        <target state="translated">Nie można załadować zestawu projektanta dostawców typów „{0}” z folderu „{1}”. Zgłoszony wyjątek: {2} — {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssemblyNoPath">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded or doesn't exist. The exception reported was: {2} - {3}</source>
        <target state="translated">Atrybut zestawu „{0}” odwołuje się do zestawu projektanta „{1}”, którego nie można załadować lub który nie istnieje. Zgłoszony wyjątek: {2} — {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="featureAndBang">
        <source>applicative computation expressions</source>
        <target state="translated">praktyczne wyrażenia obliczeniowe</target>
        <note />
      </trans-unit>
      <trans-unit id="featureDefaultInterfaceMemberConsumption">
        <source>default interface member consumption</source>
        <target state="translated">domyślne użycie składowej interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="featureDotlessFloat32Literal">
        <source>dotless float32 literal</source>
        <target state="translated">bezkropkowy literał float32</target>
        <note />
      </trans-unit>
      <trans-unit id="featureExpandedMeasurables">
        <source>more types support units of measure</source>
        <target state="new">more types support units of measure</target>
        <note />
      </trans-unit>
      <trans-unit id="featureFixedIndexSlice3d4d">
        <source>fixed-index slice 3d/4d</source>
        <target state="translated">część o stałym indeksie 3d/4d</target>
        <note />
      </trans-unit>
      <trans-unit id="featureFromEndSlicing">
        <source>from-end slicing</source>
        <target state="translated">wycinanie od końca</target>
        <note />
      </trans-unit>
      <trans-unit id="featureImplicitYield">
        <source>implicit yield</source>
        <target state="translated">niejawne słowo kluczowe yield</target>
        <note />
      </trans-unit>
      <trans-unit id="featureInterfacesWithMultipleGenericInstantiation">
        <source>interfaces with multiple generic instantiation</source>
        <target state="translated">interfejsy z wieloma ogólnymi wystąpieniami</target>
        <note />
      </trans-unit>
      <trans-unit id="featureNameOf">
        <source>nameof</source>
        <target state="translated">nameof</target>
        <note />
      </trans-unit>
      <trans-unit id="featureNullableOptionalInterop">
        <source>nullable optional interop</source>
        <target state="translated">opcjonalna międzyoperacyjność dopuszczająca wartość null</target>
        <note />
      </trans-unit>
      <trans-unit id="featureOpenTypeDeclaration">
        <source>open type declaration</source>
        <target state="translated">deklaracja typu otwartego</target>
        <note />
      </trans-unit>
      <trans-unit id="featureOverloadsForCustomOperations">
        <source>overloads for custom operations</source>
        <target state="translated">przeciążenia dla operacji niestandardowych</target>
        <note />
      </trans-unit>
      <trans-unit id="featurePackageManagement">
        <source>package management</source>
        <target state="translated">zarządzanie pakietami</target>
        <note />
      </trans-unit>
      <trans-unit id="featureRelaxWhitespace">
        <source>whitespace relexation</source>
        <target state="translated">rozluźnianie reguł dotyczących odstępów</target>
        <note />
      </trans-unit>
      <trans-unit id="featureSingleUnderscorePattern">
        <source>single underscore pattern</source>
        <target state="translated">wzorzec z pojedynczym podkreśleniem</target>
        <note />
      </trans-unit>
      <trans-unit id="featureStringInterpolation">
        <source>string interpolation</source>
        <target state="translated">interpolacja ciągu</target>
        <note />
      </trans-unit>
      <trans-unit id="featureWildCardInForLoop">
        <source>wild card in for loop</source>
        <target state="translated">symbol wieloznaczny w pętli for</target>
        <note />
      </trans-unit>
      <trans-unit id="featureWitnessPassing">
        <source>witness passing for trait constraints in F# quotations</source>
        <target state="translated">monitor, który przekazuje ograniczenia cech języka F#</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated">
        <source>Interpolated strings may not use '%' format specifiers unless each is given an expression, e.g. '%d{{1+1}}'.</source>
        <target state="translated">W interpolowanych ciągach nie można używać specyfikatorów formatu „%”, chyba że każdemu z nich odpowiada wyrażenie, na przykład „%d{{1+1}}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated2">
        <source>.NET-style format specifiers such as '{{x,3}}' or '{{x:N5}}' may not be mixed with '%' format specifiers.</source>
        <target state="translated">Specyfikatory formatu w stylu platformy .NET, takie jak „{{x,3}}” lub „{{x:N5}}”, nie mogą być mieszane ze specyfikatorami formatu „%”.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated3">
        <source>The '%P' specifier may not be used explicitly.</source>
        <target state="translated">Specyfikator „%P” nie może być używany jawnie.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated4">
        <source>Interpolated strings used as type IFormattable or type FormattableString may not use '%' specifiers, only .NET-style interpolands such as '{{expr}}', '{{expr,3}}' or '{{expr:N5}}' may be used.</source>
        <target state="translated">W interpolowanych ciągach używanych jako typ IFormattable lub FormattableString nie można używać specyfikatorów „%”. Można używać tylko operatorów interpolacji, takich jak „{{expr}}”, „{{expr,3}}” lub „{{expr:N5}}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="formatDashItem">
        <source> - {0}</source>
        <target state="translated"> — {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="fromEndSlicingRequiresVFive">
        <source>From the end slicing with requires language version 5.0, use /langversion:preview.</source>
        <target state="translated">Wycinanie od końca wymaga języka w wersji 5.0, użyj parametru /langversion:preview.</target>
        <note />
      </trans-unit>
      <trans-unit id="fsiInvalidDirective">
        <source>Invalid directive '#{0} {1}'</source>
        <target state="translated">Nieprawidłowa dyrektywa „#{0} {1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionConst">
        <source>Keyword to specify a constant literal as a type parameter argument in Type Providers.</source>
        <target state="translated">Słowo kluczowe na potrzeby określania literału stałej jako argumentu parametru typu w przypadku dostawców typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteStringMayNotBeInterpolated">
        <source>a byte string may not be interpolated</source>
        <target state="translated">ciąg bajtowy nie może być interpolowany</target>
        <note />
      </trans-unit>
      <trans-unit id="lexRBraceInInterpolatedString">
        <source>A '}}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">W przypadku znaku „}}” należy zastosować ucieczkę (przez wpisanie dwóch takich znaków) w ciągu interpolowanym.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexSingleQuoteInSingleQuote">
        <source>Invalid interpolated string. Single quote or verbatim string literals may not be used in interpolated expressions in single quote or verbatim strings. Consider using an explicit 'let' binding for the interpolation expression or use a triple quote string as the outer string literal.</source>
        <target state="translated">Nieprawidłowy ciąg interpolowany. Literały z pojedynczymi cudzysłowami lub literały ciągów dosłownych nie mogą być używane w wyrażeniach interpolowanych w ciągach z pojedynczymi cudzysłowami lub ciągach dosłownych. Rozważ użycie jawnego powiązania „let” dla wyrażenia interpolacji lub użycie ciągu z potrójnymi cudzysłowami jako zewnętrznego literału ciągu.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTripleQuoteInTripleQuote">
        <source>Invalid interpolated string. Triple quote string literals may not be used in interpolated expressions. Consider using an explicit 'let' binding for the interpolation expression.</source>
        <target state="translated">Nieprawidłowy ciąg interpolowany. Literały ciągów z potrójnymi cudzysłowami nie mogą być używane w wyrażeniach interpolowanych. Rozważ użycie jawnego powiązania „let” dla wyrażenia interpolacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="nativeResourceFormatError">
        <source>Stream does not begin with a null resource and is not in '.RES' format.</source>
        <target state="translated">Strumień nie zaczyna się od zasobu o wartości null i nie jest w formacie „.RES”.</target>
        <note />
      </trans-unit>
      <trans-unit id="nativeResourceHeaderMalformed">
        <source>Resource header beginning at offset {0} is malformed.</source>
        <target state="translated">Nagłówek zasobu rozpoczynający się od przesunięcia {0} jest nieprawidłowo sformułowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLangVersion">
        <source>Display the allowed values for language version, specify language version such as 'latest' or 'preview'</source>
        <target state="translated">Wyświetl dozwolone wartości dla wersji językowej; określ wersję językową, np. „latest” lub „preview”</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSupportedLangVersions">
        <source>Supported language versions:</source>
        <target state="translated">Obsługiwane wersje językowe:</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedLanguageVersion">
        <source>Unrecognized value '{0}' for --langversion use --langversion:? for complete list</source>
        <target state="translated">Nierozpoznana wartość „{0}” dla parametru –langversion; podaj parametr –langversion:?, aby uzyskać pełną listę</target>
        <note />
      </trans-unit>
      <trans-unit id="optsVersion">
        <source>Display compiler version banner and exit</source>
        <target state="new">Display compiler version banner and exit</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagementRequiresVFive">
        <source>The package management feature requires language version 5.0 use /langversion:preview</source>
        <target state="translated">Funkcja zarządzania pakietami wymaga języka w wersji 5.0, użyj parametru /langversion:preview</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyFillInInterpolatedString">
        <source>Invalid interpolated string. This interpolated string expression fill is empty, an expression was expected.</source>
        <target state="translated">Nieprawidłowy ciąg interpolowany. Wyrażenie ciągu interpolowanego nie jest wypełnione, a jest oczekiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedString">
        <source>Incomplete interpolated string begun at or before here</source>
        <target state="translated">Niekompletny ciąg interpolowany rozpoczęty w tym miejscu lub wcześniej</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedStringFill">
        <source>Incomplete interpolated string expression fill begun at or before here</source>
        <target state="translated">Niekompletne wypełnienie wyrażenia interpolowanego ciągu rozpoczęte w tym miejscu lub wcześniej</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedTripleQuoteString">
        <source>Incomplete interpolated triple-quote string begun at or before here</source>
        <target state="translated">Niekompletny interpolowany ciąg z potrójnym cudzysłowem rozpoczęty w tym miejscu lub wcześniej</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedVerbatimString">
        <source>Incomplete interpolated verbatim string begun at or before here</source>
        <target state="translated">Niekompletny interpolowany dosłowny ciąg rozpoczęty w tym miejscu lub wcześniej</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEqualsMissingInTypeDefinition">
        <source>Unexpected token in type definition. Expected '=' after the type '{0}'.</source>
        <target state="new">Unexpected token in type definition. Expected '=' after the type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolDot">
        <source>Unexpected symbol '.' in member definition. Expected 'with', '=' or other token.</source>
        <target state="translated">Nieoczekiwany symbol „.” w definicji składowej. Oczekiwano ciągu „with”, znaku „=” lub innego tokenu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecksumAlgorithm">
        <source>Specify algorithm for calculating source file checksum stored in PDB. Supported values are: SHA1 or SHA256 (default)</source>
        <target state="translated">Określ algorytm obliczania sumy kontrolnej pliku źródłowego przechowywanej w pliku PDB. Obsługiwane wartości to SHA1 lub SHA256 (domyślnie)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">Algorytm „{0}” nie jest obsługiwany</target>
        <note />
      </trans-unit>
      <trans-unit id="poundiNotSupportedByRegisteredDependencyManagers">
        <source>#i is not supported by the registered PackageManagers</source>
        <target state="translated">Element #i nie jest obsługiwany przez zarejestrowanych menedżerów pakietów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAndBangNotSupported">
        <source>This feature is not supported in this version of F#. You may need to add /langversion:preview to use this feature.</source>
        <target state="translated">Ta funkcja nie jest obsługiwana w tej wersji języka F#. Aby korzystać z tej funkcji, może być konieczne dodanie parametru /langversion:preview.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameDifferent">
        <source>This is the wrong anonymous record. It should have the fields {0}.</source>
        <target state="translated">To jest nieprawidłowy rekord anonimowy. Powinien zawierać pola {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameSubset">
        <source>This anonymous record does not have enough fields. Add the missing fields {0}.</source>
        <target state="translated">Ten rekord anonimowy nie ma wystarczającej liczby pól. Dodaj brakujące pola {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameSuperset">
        <source>This anonymous record has too many fields. Remove the extra fields {0}.</source>
        <target state="translated">Ten rekord anonimowy ma za dużo pól. Usuń dodatkowe pola {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdInvalid">
        <source>Invalid Anonymous Record type declaration.</source>
        <target state="translated">Nieprawidłowa deklaracja typu rekordu anonimowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAugmentationsCannotHaveAttributes">
        <source>Attributes cannot be applied to type extensions.</source>
        <target state="translated">Atrybutów nie można stosować do rozszerzeń typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalByrefsInOpenTypeDeclaration">
        <source>Byref types are not allowed in an open type declaration.</source>
        <target state="translated">Typy ByRef są niedozwolone w deklaracji typu otwartego.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterpolationMixedWithPercent">
        <source>Mismatch in interpolated string. Interpolated strings may not use '%' format specifiers unless each is given an expression, e.g. '%d{{1+1}}'</source>
        <target state="translated">Niezgodność w interpolowanym ciągu. W interpolowanych ciągach nie można używać specyfikatorów formatu „%”, chyba że każdemu z nich odpowiada wyrażenie, na przykład „%d{{1+1}}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAlignmentInInterpolatedString">
        <source>Invalid alignment in interpolated string</source>
        <target state="translated">Nieprawidłowe wyrównanie w ciągu interpolowanym</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBindingNoAndBangs">
        <source>use! may not be combined with and!</source>
        <target state="translated">Elementu use! nie można łączyć z elementem and!</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralFieldAssignmentNoArg">
        <source>Cannot assign a value to another value marked literal</source>
        <target state="translated">Nie można przypisać wartości do innej wartości oznaczonej jako literał</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralFieldAssignmentWithArg">
        <source>Cannot assign '{0}' to a value marked literal</source>
        <target state="translated">Nie można przypisać elementu „{0}” do wartości oznaczonej jako literał</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireMergeSourcesOrBindN">
        <source>The 'let! ... and! ...' construct may only be used if the computation expression builder defines either a '{0}' method or appropriate 'MergeSource' and 'Bind' methods</source>
        <target state="translated">Konstrukcji „let! ... and! ...” można użyć tylko wtedy, gdy konstruktor wyrażeń obliczeniowych definiuje metodę „{0}” lub odpowiednie metody „MergeSource” i „Bind”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseInterpolatedString">
        <source>Invalid interpolated string. {0}</source>
        <target state="translated">Nieprawidłowy ciąg interpolowany. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceMemberNoMostSpecificImplementation">
        <source>Interface member '{0}' does not have a most specific implementation.</source>
        <target state="translated">Składowa interfejsu „{0}” nie ma najbardziej specyficznej implementacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceWithConcreteAndVariable">
        <source>'{0}' cannot implement the interface '{1}' with the two instantiations '{2}' and '{3}' because they may unify.</source>
        <target state="translated">Element „{0}” nie może implementować interfejsu „{1}” z dwoma wystąpieniami „{2}” i „{3}”, ponieważ mogą one się ujednolicić.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceWithConcreteAndVariableObjectExpression">
        <source>You cannot implement the interface '{0}' with the two instantiations '{1}' and '{2}' because they may unify.</source>
        <target state="translated">Nie możesz zaimplementować interfejsu „{0}” przy użyciu dwóch wystąpień „{1}” i „{2}”, ponieważ mogą one się ujednolicić.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMemberWhenTypeIsKnown">
        <source>The type '{0}' does not define the field, constructor or member '{1}'.</source>
        <target state="translated">Typ „{0}” nie definiuje pola, konstruktora lub składowej „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespace">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano przestrzeni nazw „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespaceOrModule">
        <source>The namespace or module '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano przestrzeni nazw lub modułu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMember">
        <source>The field, constructor or member '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano pola, konstruktora lub elementu członkowskiego „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueConstructorNamespaceOrType">
        <source>The value, constructor, namespace or type '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano wartości, konstruktora, przestrzeni nazw lub typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueOfConstructor">
        <source>The value or constructor '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano wartości lub konstruktora „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueNamespaceTypeOrModule">
        <source>The value, namespace, type or module '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano wartości, przestrzeni nazw, typu lub modułu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameConstructorModuleOrNamespace">
        <source>The constructor, module or namespace '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano konstruktora, modułu lub przestrzeni nazw „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameType">
        <source>The type '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeIn">
        <source>The type '{0}' is not defined in '{1}'.</source>
        <target state="translated">Typ „{0}” nie jest zdefiniowany w elemencie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabelOrNamespace">
        <source>The record label or namespace '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano etykiety rekordu lub przestrzeni nazw „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabel">
        <source>The record label '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano etykiety rekordu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameSuggestionsIntro">
        <source>Maybe you want one of the following:</source>
        <target state="translated">Możliwe, że chcesz wykonać jedną z następujących czynności:</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeParameter">
        <source>The type parameter {0} is not defined.</source>
        <target state="translated">Nie zdefiniowano parametru typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNamePatternDiscriminator">
        <source>The pattern discriminator '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano rozróżniacza wzorców „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="replaceWithSuggestion">
        <source>Replace with '{0}'</source>
        <target state="translated">Zamień na element „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="addIndexerDot">
        <source>Add . for indexer access.</source>
        <target state="translated">Dodaj znak . na potrzeby dostępu indeksatora.</target>
        <note />
      </trans-unit>
      <trans-unit id="listElementHasWrongType">
        <source>All elements of a list must be of the same type as the first element, which here is '{0}'. This element has type '{1}'.</source>
        <target state="translated">Wszystkie elementy wyrażenia konstruktora listy muszą mieć ten sam typ. Oczekiwano, że to wyrażenie będzie miało typ „{0}”, ale tutaj ma typ „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="arrayElementHasWrongType">
        <source>All elements of an array must be of the same type as the first element, which here is '{0}'. This element has type '{1}'.</source>
        <target state="translated">Wszystkie elementy wyrażenia konstruktora tablicy muszą mieć ten sam typ. Oczekiwano, że to wyrażenie będzie miało typ „{0}”, ale tutaj ma typ „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="missingElseBranch">
        <source>This 'if' expression is missing an 'else' branch. Because 'if' is an expression, and not a statement, add an 'else' branch which also returns a value of type '{0}'.</source>
        <target state="translated">W wyrażeniu „if” brakuje gałęzi „else”. Gałąź „then” ma typ „{0}”. Jako że „if” jest wyrażeniem, a nie instrukcją, dodaj gałąź „else”, która będzie zwracać wartość tego samego typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ifExpression">
        <source>The 'if' expression needs to have type '{0}' to satisfy context type requirements. It currently has type '{1}'.</source>
        <target state="translated">Wyrażenie „if” musi mieć typ „{0}”, aby spełnić wymagania typu kontekstu. Obecny typ: „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="elseBranchHasWrongType">
        <source>All branches of an 'if' expression must return values of the same type as the first branch, which here is '{0}'. This branch returns a value of type '{1}'.</source>
        <target state="translated">Wszystkie gałęzie wyrażenia „if” muszą mieć ten sam typ. Oczekiwano, że to wyrażenie będzie miało typ „{0}”, ale tutaj ma typ „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="followingPatternMatchClauseHasWrongType">
        <source>All branches of a pattern match expression must return values of the same type as the first branch, which here is '{0}'. This branch returns a value of type '{1}'.</source>
        <target state="translated">Wszystkie gałęzie wyrażenia dopasowania do wzorca muszą zwracać wartości tego samego typu. Pierwsza gałąź zwróciła wartość typu „{0}”, ale ta gałąź zwróciła wartość typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="patternMatchGuardIsNotBool">
        <source>A pattern match guard must be of type 'bool', but this 'when' expression is of type '{0}'.</source>
        <target state="translated">Zabezpieczenie dopasowania do wzorca musi mieć typ „bool”, ale to wyrażenie „when” ma typ „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="commaInsteadOfSemicolonInRecord">
        <source>A ';' is used to separate field values in records. Consider replacing ',' with ';'.</source>
        <target state="translated">Znak „;” jest używany do rozdzielania wartości pól w rekordach. Rozważ zastąpienie znaku „,” znakiem „;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="derefInsteadOfNot">
        <source>The '!' operator is used to dereference a ref cell. Consider using 'not expr' here.</source>
        <target state="translated">Operator „!” umożliwia wyłuskanie komórki odwołania. Rozważ użycie tutaj elementu „not expr”.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedTypeArgs">
        <source>The non-generic type '{0}' does not expect any type arguments, but here is given {1} type argument(s)</source>
        <target state="translated">Typ inny niż ogólny „{0}” nie oczekuje żadnych argumentów typu, ale tutaj podano następującą liczbę argumentów typu: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="returnUsedInsteadOfReturnBang">
        <source>Consider using 'return!' instead of 'return'.</source>
        <target state="translated">Rozważ użycie polecenia „return!” zamiast „return”.</target>
        <note />
      </trans-unit>
      <trans-unit id="useSdkRefs">
        <source>Use reference assemblies for .NET framework references when available (Enabled by default).</source>
        <target state="translated">Użyj zestawów odwołań dla odwołań do programu .NET Framework, gdy są dostępne (domyślnie włączone).</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocBadlyFormed">
        <source>This XML comment is invalid: '{0}'</source>
        <target state="translated">Ten komentarz XML jest nieprawidłowy: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocDuplicateParameter">
        <source>This XML comment is invalid: multiple documentation entries for parameter '{0}'</source>
        <target state="translated">Ten komentarz XML jest nieprawidłowy: wiele wpisów dokumentacji dla parametru „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocInvalidParameterName">
        <source>This XML comment is invalid: unknown parameter '{0}'</source>
        <target state="translated">Ten komentarz XML jest nieprawidłowy: nieznany parametr „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingCrossReference">
        <source>This XML comment is invalid: missing 'cref' attribute for cross-reference</source>
        <target state="translated">Ten komentarz XML jest nieprawidłowy: brak atrybutu „cref” dla odsyłacza</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingParameter">
        <source>This XML comment is incomplete: no documentation for parameter '{0}'</source>
        <target state="translated">Ten komentarz XML jest niekompletny: brak dokumentacji dla parametru „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingParameterName">
        <source>This XML comment is invalid: missing 'name' attribute for parameter or parameter reference</source>
        <target state="translated">Ten komentarz XML jest nieprawidłowy: brak atrybutu „name” dla parametru lub odwołania parametru</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocUnresolvedCrossReference">
        <source>This XML comment is invalid: unresolved cross-reference '{0}'</source>
        <target state="translated">Ten komentarz XML jest nieprawidłowy: nierozpoznany odsyłacz „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="yieldUsedInsteadOfYieldBang">
        <source>Consider using 'yield!' instead of 'yield'.</source>
        <target state="translated">Rozważ użycie polecenia „yield!” zamiast „yield”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tupleRequiredInAbstractMethod">
        <source>\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.</source>
        <target state="translated">\nDla co najmniej jednego argumentu jest wymagany typ krotki. Rozważ ujęcie danych argumentów w dodatkowy nawias lub przejrzenie definicji interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidWarningNumber">
        <source>Invalid warning number '{0}'</source>
        <target state="translated">Nieprawidłowy numer ostrzeżenia „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionString">
        <source>Invalid version string '{0}'</source>
        <target state="translated">Nieprawidłowy ciąg wersji „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionFile">
        <source>Invalid version file '{0}'</source>
        <target state="translated">Nieprawidłowy plik wersji „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemWithFilename">
        <source>Problem with filename '{0}': {1}</source>
        <target state="translated">Problem z nazwą pliku „{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildNoInputsSpecified">
        <source>No inputs specified</source>
        <target state="translated">Nie określono danych wejściowych</target>
        <note />
      </trans-unit>
      <trans-unit id="buildPdbRequiresDebug">
        <source>The '--pdb' option requires the '--debug' option to be used</source>
        <target state="translated">Opcja „--pdb” wymaga użycia opcji „--debug”</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSearchDirectory">
        <source>The search directory '{0}' is invalid</source>
        <target state="translated">Katalog wyszukiwania „{0}” jest nieprawidłowy</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSearchDirectoryNotFound">
        <source>The search directory '{0}' could not be found</source>
        <target state="translated">Nie można znaleźć katalogu wyszukiwania „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidFilename">
        <source>'{0}' is not a valid filename</source>
        <target state="translated">Nazwa „{0}” nie jest prawidłową nazwą pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidAssemblyName">
        <source>'{0}' is not a valid assembly name</source>
        <target state="translated">Nazwa „{0}” nie jest prawidłową nazwą zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidPrivacy">
        <source>Unrecognized privacy setting '{0}' for managed resource, valid options are 'public' and 'private'</source>
        <target state="translated">Nierozpoznane ustawienie prywatności „{0}” dla zasobu zarządzanego. Prawidłowe opcje to „public” i „private”</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCannotReadAssembly">
        <source>Unable to read assembly '{0}'</source>
        <target state="translated">Nie można odczytać zestawu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="buildAssemblyResolutionFailed">
        <source>Assembly resolution failure at or near this location</source>
        <target state="translated">Niepowodzenie rozpoznania zestawu w tej lokalizacji lub w jej pobliżu</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplicitModuleIsNotLegalIdentifier">
        <source>The declarations in this file will be placed in an implicit module '{0}' based on the file name '{1}'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file.</source>
        <target state="translated">Deklaracje w tym pliku będą umieszczane w niejawnym module „{0}” na podstawie nazwy pliku „{1}”. Nie jest to jednak prawidłowy identyfikator języka F#, dlatego zawartość nie będzie dostępna z innych plików. Rozważ zmianę nazwy pliku lub dodanie deklaracji „module” lub „namespace” na początku pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultiFileRequiresNamespaceOrModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration.</source>
        <target state="translated">Pliki w bibliotekach lub aplikacjach z wieloma plikami muszą rozpoczynać się od deklaracji przestrzeni nazw lub modułu (np. „namespace PrzestrzenNazw.PodrzednaPrzestrzenNazw” lub „module PrzestrzenNazw.Modul”). Taka deklaracja może zostać pominięta tylko w ostatnim pliku źródłowym aplikacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="noEqualSignAfterModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.</source>
        <target state="translated">Pliki w bibliotekach lub aplikacje złożone z wielu plików muszą rozpoczynać się od deklaracji przestrzeni nazw lub modułu. W przypadku użycia deklaracji modułu na początku pliku nie dopuszcza się zastosowania znaku „=”. Jeśli jest to moduł najwyższego poziomu, rozważ usunięcie znaku = w celu usunięcia tego błędu.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleToplevelModules">
        <source>This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules.</source>
        <target state="translated">Ten plik zawiera wiele deklaracji w postaci „module PrzestrzeńNazw.Moduł”. W pliku dozwolona jest tylko jedna deklaracja o takiej postaci. Zmień plik w celu użycia początkowej deklaracji przestrzeni nazw i/lub zastosuj konstrukcję „module NazwaModułu = ...” do zdefiniowania własnych modułów.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildOptionRequiresParameter">
        <source>Option requires parameter: {0}</source>
        <target state="translated">Opcja wymaga parametru: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotFindSourceFile">
        <source>Source file '{0}' could not be found</source>
        <target state="translated">Nie można znaleźć pliku źródłowego „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSourceFileExtension">
        <source>The file extension of '{0}' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.</source>
        <target state="translated">Rozszerzenie pliku „{0}” nie zostało rozpoznane. Pliki źródłowe muszą mieć rozszerzenie fs, fsi, fsx, fsscript, ml lub mli.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssembly">
        <source>Could not resolve assembly '{0}'</source>
        <target state="translated">Nie można rozpoznać zestawu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssemblyRequiredByFile">
        <source>Could not resolve assembly '{0}' required by '{1}'</source>
        <target state="translated">Nie można rozpoznać zestawu „{0}” wymaganego przez „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="buildErrorOpeningBinaryFile">
        <source>Error opening binary file '{0}': {1}</source>
        <target state="translated">Błąd podczas otwierania pliku binarnego „{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDifferentVersionMustRecompile">
        <source>The F#-compiled DLL '{0}' needs to be recompiled to be used with this version of F#</source>
        <target state="translated">Biblioteka DLL „{0}” skompilowana przy użyciu języka F# wymaga ponownego skompilowania, aby została użyta z tą wersją języka F#</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashIDirective">
        <source>Invalid directive. Expected '#I \"&lt;path&gt;\"'.</source>
        <target state="translated">Nieprawidłowa dyrektywa. Oczekiwano dyrektywy „#I \"&lt;ścieżka&gt;\"”.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashrDirective">
        <source>Invalid directive. Expected '#r \"&lt;file-or-assembly&gt;\"'.</source>
        <target state="translated">Nieprawidłowa dyrektywa. Oczekiwano dyrektywy „#r \"&lt;plik-lub-zestaw&gt;\"”.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashloadDirective">
        <source>Invalid directive. Expected '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</source>
        <target state="translated">Nieprawidłowa dyrektywa. Oczekiwano dyrektywy „#load \"&lt;plik&gt;\" ... \"&lt;plik&gt;\"”.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashtimeDirective">
        <source>Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'.</source>
        <target state="translated">Nieprawidłowa dyrektywa. Oczekiwano „#time”, „#time \"on\"” lub „#time \"off\"”.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDirectivesInModulesAreIgnored">
        <source>Directives inside modules are ignored</source>
        <target state="translated">Dyrektywy wewnątrz modułów są ignorowane</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureAlreadySpecified">
        <source>A signature for the file or module '{0}' has already been specified</source>
        <target state="translated">Sygnatura dla pliku lub modułu „{0}” została już określona</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGivenDetail">
        <source>An implementation of file or module '{0}' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.</source>
        <target state="translated">Implementacja pliku lub modułu „{0}” została już podana. Kolejność kompilacji jest istotna w języku F# z powodu wnioskowania o typie. Może być wymagane dostosowanie kolejności plików w celu umieszczenia pliku sygnatury przed implementacją. W programie Visual Studio kontrola typów jest wykonywana dla plików w kolejności ich występowania w pliku projektu; kolejność ta może być edytowana ręcznie lub dostosowywana przy użyciu Eksploratora rozwiązań.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGiven">
        <source>An implementation of the file or module '{0}' has already been given</source>
        <target state="translated">Implementacja pliku lub modułu „{0}” została już podana</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureWithoutImplementation">
        <source>The signature file '{0}' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match.</source>
        <target state="translated">Plik sygnatury „{0}” nie ma odpowiedniego pliku implementacji. Jeśli plik implementacji istnieje, sprawdź, czy istnieją zgodne deklaracje „module” i „namespace” w plikach sygnatury i implementacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidInt">
        <source>'{0}' is not a valid integer argument</source>
        <target state="translated">Argument „{0}” nie jest prawidłowym argumentem liczby całkowitej</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidFloat">
        <source>'{0}' is not a valid floating point argument</source>
        <target state="translated">Argument „{0}” nie jest prawidłowym argumentem liczby zmiennoprzecinkowej</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnrecognizedOption">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">Nierozpoznana opcja: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidModuleOrNamespaceName">
        <source>Invalid module or namespace name</source>
        <target state="translated">Nieprawidłowa nazwa modułu lub przestrzeni nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleErrorReadingWritingMetadata">
        <source>Error reading/writing metadata for the F# compiled DLL '{0}'. Was the DLL compiled with an earlier version of the F# compiler? (error: '{1}').</source>
        <target state="translated">Błąd podczas odczytywania/zapisywania metadanych skompilowanej biblioteki DLL języka F# „{0}”. Czy biblioteka DLL została skompilowana przy użyciu wcześniejszej wersji kompilatora języka F#? (Błąd: „{1}”).</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeOrModuleNotConcrete">
        <source>The type/module '{0}' is not a concrete module or type</source>
        <target state="translated">Typ/moduł „{0}” nie jest konkretnym modułem lub typem</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeHasAssemblyCodeRepresentation">
        <source>The type '{0}' has an inline assembly code representation</source>
        <target state="translated">Typ „{0}” ma reprezentację śródwierszowego kodu zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNamespaceAndModuleWithSameNameInAssembly">
        <source>A namespace and a module named '{0}' both occur in two parts of this assembly</source>
        <target state="translated">Przestrzeń nazw i moduł o nazwie „{0}” występują w dwóch częściach tego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTwoModulesWithSameNameInAssembly">
        <source>Two modules named '{0}' occur in two parts of this assembly</source>
        <target state="translated">Moduły o nazwie „{0}” występują w dwóch częściach tego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="tastDuplicateTypeDefinitionInAssembly">
        <source>Two type definitions named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">Dwie definicje typów o nazwie „{0}” występują w przestrzeni nazw „{1}” w dwóch częściach tego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConflictingModuleAndTypeDefinitionInAssembly">
        <source>A module and a type definition named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">Moduł i definicja typu o nazwie „{0}” występują w przestrzeni nazw „{1}” w dwóch częściach tego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMemberSignature">
        <source>Invalid member signature encountered because of an earlier error</source>
        <target state="translated">Napotkano nieprawidłową sygnaturę elementu członkowskiego z powodu wcześniejszego błędu</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueDoesNotHaveSetterType">
        <source>This value does not have a valid property setter type</source>
        <target state="translated">Ta wartość nie ma prawidłowego typu metody ustawiającej właściwość</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertyGetter">
        <source>Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax.</source>
        <target state="translated">Nieprawidłowa postać metody pobierającej właściwość. W przypadku używania jawnej składni jest wymagany co najmniej jeden argument „()”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertySetter">
        <source>Invalid form for a property setter. At least one argument is required.</source>
        <target state="translated">Nieprawidłowa forma metody ustawiającej właściwości. Wymagany jest co najmniej jeden argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedByRef">
        <source>Unexpected use of a byref-typed variable</source>
        <target state="translated">Nieoczekiwane użycie zmiennej typu byref</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMutationOfConstant">
        <source>Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'.</source>
        <target state="translated">Nieprawidłowa mutacja wyrażenia stałej. Rozważ skopiowanie wyrażenia do modyfikowalnej wartości lokalnej, na przykład „let mutable x = ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueHasBeenCopied">
        <source>The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed</source>
        <target state="translated">Wartość została skopiowana w celu zagwarantowania, że oryginalna wartość nie zostanie zmodyfikowana przez tę operację, lub ponieważ kopia jest niejawna, gdy podczas zwracania struktury z elementu członkowskiego nastąpi otwarcie innego elementu członkowskiego.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeInConstructionOfTuple">
        <source>Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding</source>
        <target state="translated">Wartości zdefiniowane cyklicznie nie mogą występować bezpośrednio jako część konstrukcji wartości krotki w powiązaniu cyklicznym</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotAppearInConstructionOfType">
        <source>Recursive values cannot appear directly as a construction of the type '{0}' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.</source>
        <target state="translated">Wartości cykliczne nie mogą występować bezpośrednio jako konstrukcja typu „{0}” w powiązaniu cyklicznym. Ta funkcja została usunięta z języka F#. Zamiast tego rozważ użycie rekordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeAssignedToNonMutableField">
        <source>Recursive values cannot be directly assigned to the non-mutable field '{0}' of the type '{1}' within a recursive binding. Consider using a mutable field instead.</source>
        <target state="translated">Wartości cykliczne nie mogą być przypisywane bezpośrednio do niezmienialnego pola „{0}” typu „{1}” w powiązaniu cyklicznym. Zamiast tego rozważ użycie pola modyfikowalnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfAutoOpenAttribute">
        <source>Unexpected decode of AutoOpenAttribute</source>
        <target state="translated">Nieoczekiwane dekodowanie elementu AutoOpenAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInternalsVisibleToAttribute">
        <source>Unexpected decode of InternalsVisibleToAttribute</source>
        <target state="translated">Nieoczekiwane dekodowanie elementu InternalsVisibleToAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
        <source>Unexpected decode of InterfaceDataVersionAttribute</source>
        <target state="translated">Nieoczekiwane dekodowanie elementu InterfaceDataVersionAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastActivePatternsLimitedToSeven">
        <source>Active patterns cannot return more than 7 possibilities</source>
        <target state="translated">Aktywne wzorce nie mogą zwracać więcej niż 7 możliwości</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNotAConstantExpression">
        <source>This is not a valid constant expression or custom attribute value</source>
        <target state="translated">To nie jest prawidłowe wyrażenie stałej lub prawidłowa niestandardowa wartość atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAttributesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe mutability attributes differ</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nAtrybuty modyfikowalności są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe names differ</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nNazwy są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityCompiledNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled names differ</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nNazwy skompilowane są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDisplayNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe display names differ</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nNazwy wyświetlane są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAccessibilityMore">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nDostępność określona w sygnaturze jest większa od określonej w implementacji</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInlineFlagsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe inline flags differ</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nFlagi śródwierszowe są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityLiteralConstantValuesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe literal constant values and/or attributes differ</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nWartości i/lub atrybuty stałych literału są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsTypeFunction">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest funkcją typu, a drugi nie. Sygnatura wymaga jawnych parametrów typu, jeśli są obecne w implementacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityParameterCountsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe respective type parameter counts differ</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nOdpowiednie liczby parametrów typu są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityTypesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe types differ</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nTypy są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityExtensionsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is an extension member and the other is not</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest elementem członkowskim rozszerzenia, a drugi nie</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityArityNotInferred">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nAn arity was not inferred for this value</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nLiczba argumentów nie została wywnioskowana dla tej wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe number of generic parameters in the signature and implementation differ (the signature declares {3} but the implementation declares {4}</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nLiczba parametrów ogólnych w sygnaturze i implementacji jest różna (sygnatura deklaruje {3}, ale implementacja deklaruje {4})</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersAreDifferentKinds">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego podpis określa element\n    {2}    \nParametry ogólne w podpisie i implementacji są różnego rodzaju. Być może brakuje atrybutu [&lt;Measure&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAritiesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe arities in the signature and implementation differ. The signature specifies that '{3}' is function definition or lambda expression accepting at least {4} argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int.</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego podpis określa element\n    {2}    \nLiczby argumentów w podpisie i implementacji są różne. Podpis określa, że „{3}” to definicja funkcji lub wyrażenie lambda akceptujące liczbę argumentów wynoszącą co najmniej {4}, ale implementacja jest obliczaną wartością funkcji. Aby zadeklarować, że obliczana wartość funkcji to dozwolona implementacja, po prostu w podpisie umieść jej typ w nawiasie, np.\n\tval {5}: int -&gt; (int -&gt; int)\nzamiast\n\tval {6}: int -&gt; int -&gt; int.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDotNetNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe CLI member names differ</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nNazwy elementów członkowskich infrastruktury CLI są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is static and the other isn't</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest elementem statycznym, a drugi nie</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityVirtualsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is virtual and the other isn't</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest elementem wirtualnym, a drugi nie</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAbstractsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is abstract and the other isn't</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest abstrakcyjny, a drugi nie</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityFinalsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is final and the other isn't</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest elementem finalnym, a drugi nie</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOverridesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is marked as an override and the other isn't</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest oznaczony jako przesłonięcie, a drugi nie</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsConstructor">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a constructor/property and the other is not</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest konstruktorem/właściwością, a drugi nie</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticButInstance">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nReprezentacja skompilowana tej metody ma postać statycznego elementu członkowskiego, ale sygnatura wskazuje, że jego reprezentacja skompilowana ma postać elementu członkowskiego wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInstanceButStatic">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member</source>
        <target state="translated">Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nReprezentacja skompilowana tej metody ma postać elementu członkowskiego wystąpienia, ale sygnatura wskazuje, że jego reprezentacja skompilowana ma postać statycznego elementu członkowskiego</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNamesDiffer">
        <source>The {0} definitions in the signature and implementation are not compatible because the names differ. The type is called '{1}' in the signature file but '{2}' in implementation.</source>
        <target state="translated">Definicje {0} w sygnaturze i implementacji są niezgodne, ponieważ nazwy są różne. Typ w pliku sygnatury ma nazwę „{1}”, a w implementacji „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ odpowiednie liczby parametrów typu są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ dostępność określona w sygnaturze jest większa od określonej w implementacji</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleMissingInterface">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature requires that the type supports the interface {2} but the interface has not been implemented</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura wymaga, aby typ obsługiwał interfejs {2}, ale interfejs nie został zaimplementowany</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ implementacja wskazuje, że ten typ może używać wartości null jako reprezentacji, ale sygnatura tego nie wskazuje</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ implementacja wskazuje, że ten typ może używać wartości null jako dodatkowej wartości, ale sygnatura tego nie wskazuje</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura wskazuje, że ten typ może używać wartości null jako reprezentacji, ale implementacja tego nie wskazuje</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura wskazuje, że ten typ może używać wartości null jako dodatkowej wartości, ale implementacja tego nie wskazuje</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.</source>
        <target state="translated">Definicje {0} dla typu „{1}” w podpisie i implementacji są niezgodne, ponieważ typ implementacji jest zapieczętowany, ale podpis sugeruje, że nie jest zapieczętowany. Rozważ dodanie atrybutu [&lt;Sealed&gt;] do podpisu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.</source>
        <target state="translated">Definicje {0} dla typu „{1}” w podpisie i implementacji są niezgodne, ponieważ typ implementacji nie jest zapieczętowany, ale sygnatura sugeruje, że jest zapieczętowany. Rozważ dodanie atrybutu [&lt;Sealed&gt;] do implementacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.</source>
        <target state="translated">Definicje {0} dla typu „{1}” w podpisie i implementacji są niezgodne, ponieważ implementacja jest klasą abstrakcyjną, a podpis nie. Rozważ dodanie atrybutu [&lt;AbstractClass&gt;] do podpisu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.</source>
        <target state="translated">Definicje {0} typu „{1}” w podpisie i implementacji są niezgodne, ponieważ podpis jest klasą abstrakcyjną, a implementacja nią nie jest. Rozważ dodanie atrybutu [&lt;AbstractClass&gt;] do implementacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types have different base types</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ typy mają różne typy podstawowe</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNumbersDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the number of {2}s differ</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ liczba elementów {2} jest różna</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature defines the {2} '{3}' but the implementation does not (or does, but not in the same order)</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura definiuje element {2} „{3}”, ale implementacja nie (albo definiuje w innej kolejności)</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines the {2} '{3}' but the signature does not (or does, but not in the same order)</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ implementacja definiuje element {2} „{3}”, ale sygnatura nie (albo definiuje w innej kolejności)</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ implementacja definiuje strukturę, ale sygnatura definiuje typ z ukrytą reprezentacją</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ reprezentacja typu infrastruktury CLI jest ukrywana przez sygnaturę</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a type representation is being hidden by a signature</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ reprezentacja typu jest ukrywana przez sygnaturę</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types are of different kinds</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ typy są różnego rodzaju</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleILDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the IL representations differ</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne z powodu różnych reprezentacji obiektu IL</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the representations differ</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ reprezentacje są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldWasPresent">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was present in the implementation but not in the signature</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ pole {2} było obecne w implementacji, ale nie w sygnaturze</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne z powodu różnej kolejności pól w sygnaturze i implementacji</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was required by the signature but was not specified by the implementation</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ pole {2} było wymagane przez sygnaturę, ale nie zostało określone przez implementację</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field '{2}' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'.</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ pole „{2}” było obecne w implementacji, ale nie w sygnaturze. Typy struktury muszą teraz udostępniać swoje pola w sygnaturze dla typu, chociaż pola nadal mogą mieć etykietę „private” lub „internal”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was required by the signature but was not specified by the implementation</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ abstrakcyjny element członkowski „{2}” był wymagany przez sygnaturę, ale nie został określony przez implementację</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was present in the implementation but not in the signature</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ abstrakcyjny element członkowski „{2}” był obecny w implementacji, ale nie w sygnaturze</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature declares a {2} while the implementation declares a {3}</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura deklaruje element {2}, natomiast implementacja deklaruje element {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abbreviations differ: {2} versus {3}</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ skróty są różne: {2} i {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ skrót jest ukrywany przez sygnaturę. Skrót musi być widoczny dla innych języków infrastruktury CLI. Rozważ zapewnienie widoczności skrótu w sygnaturze.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not</source>
        <target state="translated">Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura ma skrót, a implementacja go nie ma</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButNamesDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">Moduł zawiera konstruktora\n    {0},    \nale jego sygnatura określa\n    {1}    \nNazwy są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButDataFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe respective number of data fields differ</source>
        <target state="translated">Moduł zawiera konstruktora\n    {0},    \nale jego sygnatura określa\n    {1}    \nOdpowiednia liczba pól danych jest różna</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButTypesOfFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe types of the fields differ</source>
        <target state="translated">Moduł zawiera konstruktora\n    {0},    \nale jego sygnatura określa\n    {1}    \nTypy pól są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButAccessibilityDiffers">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Moduł zawiera konstruktora\n    {0},    \nale jego sygnatura określa\n    {1}    \nDostępność określona w sygnaturze jest większa od określonej w implementacji</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedNamesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">Moduł zawiera pole\n    {0},    \nale jego sygnatura określa\n    {1}    \nNazwy są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedAccessibilitiesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Moduł zawiera pole\n    {0},    \nale jego sygnatura określa\n    {1}    \nDostępność określona w sygnaturze jest większa od określonej w implementacji</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedStaticsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'static' modifiers differ</source>
        <target state="translated">Moduł zawiera pole\n    {0},    \nale jego sygnatura określa\n    {1}    \nModyfikatory „static” są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedMutablesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'mutable' modifiers differ</source>
        <target state="translated">Moduł zawiera pole\n    {0},    \nale jego sygnatura określa\n    {1}    \nModyfikatory „mutable” są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedLiteralsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'literal' modifiers differ</source>
        <target state="translated">Moduł zawiera pole\n    {0},    \nale jego sygnatura określa\n    {1}    \nModyfikatory „literal” są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedTypesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe types differ</source>
        <target state="translated">Moduł zawiera pole\n    {0},    \nale jego sygnatura określa\n    {1}    \nTypy są różne</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveImplicitGenericInstantiation">
        <source>The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '{0}' and '{1}'. Consider using type annotations to resolve the ambiguity</source>
        <target state="translated">Nie można rozpoznać niejawnego wystąpienia konstrukcji ogólnej w tym miejscu lub w jego pobliżu, ponieważ może to spowodować powstanie wielu niepowiązanych typów, na przykład „{0}” i „{1}”. Rozważ użycie adnotacji typu w celu rozwiązania niejednoznaczności</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInPrintf">
        <source>Could not resolve the ambiguity inherent in the use of a 'printf'-style format string</source>
        <target state="translated">Nie można usunąć niejednoznaczności spowodowanej użyciem ciągu formatu „printf”</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInEnum">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position</source>
        <target state="translated">Nie można usunąć niejednoznaczności w przypadku użycia konstrukcji ogólnej z ograniczeniem „enum” w tym miejscu lub w jego pobliżu</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInDelegate">
        <source>Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position</source>
        <target state="translated">Nie można usunąć niejednoznaczności w przypadku użycia konstrukcji ogólnej z ograniczeniem „delegate” w tym miejscu lub w jego pobliżu.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInvalidValue">
        <source>Invalid value</source>
        <target state="translated">Nieprawidłowa wartość</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleParamCountsDiffer">
        <source>The signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">Sygnatura i implementacja nie są zgodne z powodu różnej liczby odpowiednich parametrów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
        <source>The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation</source>
        <target state="translated">Sygnatura i implementacja nie są zgodne, ponieważ parametr typu w klasie/sygnaturze ma inne wymaganie dotyczące czasu kompilacji niż parametr w elemencie członkowskim/implementacji</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDiffer">
        <source>The signature and implementation are not compatible because the declaration of the type parameter '{0}' requires a constraint of the form {1}</source>
        <target state="translated">Sygnatura i implementacja nie są zgodne, ponieważ deklaracja parametru typu „{0}” wymaga ograniczenia w postaci {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDifferRemove">
        <source>The signature and implementation are not compatible because the type parameter '{0}' has a constraint of the form {1} but the implementation does not. Either remove this constraint from the signature or add it to the implementation.</source>
        <target state="translated">Sygnatura i implementacja nie są zgodne, ponieważ parametr typu „{0}” ma ograniczenie w postaci {1}, ale nie ma go implementacja. Usuń to ograniczenie z sygnatury lub dodaj je do implementacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableShouldOverrideObjectEquals">
        <source>The type '{0}' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'</source>
        <target state="translated">Typ „{0}” zawiera implementację elementu „System.IComparable”. Rozważ również dodanie jawnego przesłonięcia elementu „Object.Equals”</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableDefaultObjectEqualsProvided">
        <source>The type '{0}' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly</source>
        <target state="translated">Typ „{0}” zawiera jawną implementację elementu „System.IComparable”, ale nie dostarcza odpowiedniego przesłonięcia elementu „Object.Equals”. Implementacja elementu „Object.Equals” została automatycznie dostarczona (implementacja za pośrednictwem elementu „System.IComparable”). Rozważ jawne zaimplementowanie przesłonięcia elementu „Object.Equals”</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCodeOrEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” ma jawną implementację elementu „Object.GetHashCode” lub „Object.Equals”. Musisz zastosować atrybut „CustomEquality” do typu</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCode">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” ma jawną implementację elementu „Object.GetHashCode”. Rozważ zaimplementowanie zgodnego przesłonięcia dla elementu „Object.Equals(obiekt)”</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” ma jawną implementację elementu „Object.Equals”. Rozważ zaimplementowanie zgodnego przesłonięcia dla elementu „Object.GetHashCode()”</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleHiddenBySignature">
        <source>The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">Definicje wyjątku są niezgodne, ponieważ mapowanie wyjątków infrastruktury CLI jest ukrywane przez sygnaturę. Mapowanie wyjątków musi być widoczne dla innych modułów. Moduł zawiera definicję wyjątku\n    {0},    \nale jego sygnatura określa\n\t{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer">
        <source>The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">Definicje wyjątku są niezgodne, ponieważ reprezentacje infrastruktury CLI są różne. Moduł zawiera definicję wyjątku\n    {0},    \nale jego sygnatura określa\n\t{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature">
        <source>The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Definicje wyjątku są niezgodne, ponieważ skrót wyjątku jest ukrywany przez sygnaturę. Skrót musi być widoczny dla innych języków infrastruktury CLI. Rozważ zapewnienie widoczności skrótu w sygnaturze. Moduł zawiera definicję wyjątku\n    {0},    \nale jego sygnatura określa\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleSignaturesDiffer">
        <source>The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Definicje wyjątków są niezgodne, ponieważ różnią się skróty wyjątków w sygnaturze i implementacji. Moduł zawiera definicję wyjątku\n    {0},    \nale jego sygnatura określa\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer">
        <source>The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Definicje wyjątku są niezgodne, ponieważ deklaracje wyjątku są różne. Moduł zawiera definicję wyjątku\n    {0},    \nale jego sygnatura określa\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInSigButNotImpl">
        <source>The exception definitions are not compatible because the field '{0}' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">Definicje wyjątku są niezgodne, ponieważ pole „{0}” było wymagane przez sygnaturę, ale nie zostało określone przez implementację. Moduł zawiera definicję wyjątku\n    {1},    \nale jego sygnatura określa\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInImplButNotSig">
        <source>The exception definitions are not compatible because the field '{0}' was present in the implementation but not in the signature. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">Definicje wyjątku są niezgodne, ponieważ pole „{0}” było obecne w implementacji, ale nie w sygnaturze. Moduł zawiera definicję wyjątku\n    {1},    \nale jego sygnatura określa\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldOrderDiffers">
        <source>The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Definicje wyjątku są niezgodne z powodu różnej kolejności pól w sygnaturze i implementacji. Moduł zawiera definicję wyjątku\n    {0},    \nale jego sygnatura określa\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelModuleNamespaceAttributesDifferInSigAndImpl">
        <source>The namespace or module attributes differ between signature and implementation</source>
        <target state="translated">Atrybuty przestrzeni nazw lub modułu w sygnaturze i implementacji nie są zgodne</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsOverconstrained">
        <source>This method is over-constrained in its type parameters</source>
        <target state="translated">Ta metoda ma zbyt wiele ograniczeń w parametrach typu</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverloadNotFound">
        <source>No implementations of '{0}' had the correct number of arguments and type parameters. The required signature is '{1}'.</source>
        <target state="translated">Żadna implementacja elementu „{0}” nie zawiera poprawnej liczby argumentów i parametrów typu. Wymagana sygnatura: „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideWasAmbiguous">
        <source>The override for '{0}' was ambiguous</source>
        <target state="translated">Przesłonięcie elementu „{0}” jest niejednoznaczne</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMoreThenOneOverride">
        <source>More than one override implements '{0}'</source>
        <target state="translated">Więcej niż jedno przesłonięcie zawiera implementację elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsSealed">
        <source>The method '{0}' is sealed and cannot be overridden</source>
        <target state="translated">Metoda „{0}” jest zapieczętowana i nie można jej przesłonić</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideImplementsMoreThenOneSlot">
        <source>The override '{0}' implements more than one abstract slot, e.g. '{1}' and '{2}'</source>
        <target state="translated">Przesłonięcie „{0}” zawiera implementację więcej niż jednego miejsca abstrakcyjnego, na przykład „{1}” i „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelDuplicateInterface">
        <source>Duplicate or redundant interface</source>
        <target state="translated">Zduplikowany lub nadmiarowy interfejs</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNeedExplicitImplementation">
        <source>The interface '{0}' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.</source>
        <target state="translated">Interfejs „{0}” występuje w wielu jawnie zaimplementowanych typach interfejsów. Dodaj jawną implementację tego interfejsu.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNamedArgumentHasBeenAssignedMoreThenOnce">
        <source>The named argument '{0}' has been assigned more than one value</source>
        <target state="translated">Do nazwanego argumentu „{0}” przypisano więcej niż jedną wartość</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGiven">
        <source>No implementation was given for '{0}'</source>
        <target state="translated">Nie określono implementacji elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenWithSuggestion">
        <source>No implementation was given for '{0}'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Nie określono implementacji elementu „{0}”. Wszystkie elementy członkowskie interfejsu muszą zostać zaimplementowane i występować w odpowiedniej deklaracji „interface”, na przykład „interface ... with member ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfArguments">
        <source>The member '{0}' does not have the correct number of arguments. The required signature is '{1}'.</source>
        <target state="translated">Element członkowski „{0}” nie zawiera poprawnej liczby argumentów. Wymagana sygnatura: „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters">
        <source>The member '{0}' does not have the correct number of method type parameters. The required signature is '{1}'.</source>
        <target state="translated">Element członkowski „{0}” nie zawiera poprawnej liczby parametrów typu metody. Wymagana sygnatura: „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters">
        <source>The member '{0}' does not have the correct kinds of generic parameters. The required signature is '{1}'.</source>
        <target state="translated">Element członkowski „{0}” nie zawiera poprawnych rodzajów parametrów ogólnych. Wymagana sygnatura: „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberCannotImplement">
        <source>The member '{0}' cannot be used to implement '{1}'. The required signature is '{2}'.</source>
        <target state="translated">Nie można zaimplementować elementu „{1}” przy użyciu elementu członkowskiego „{0}”. Wymagana sygnatura: „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILError">
        <source>Error while parsing embedded IL</source>
        <target state="translated">Błąd podczas analizowania osadzonego obiektu IL</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILTypeError">
        <source>Error while parsing embedded IL type</source>
        <target state="translated">Błąd podczas analizowania typu osadzonego obiektu IL</target>
        <note />
      </trans-unit>
      <trans-unit id="astDeprecatedIndexerNotation">
        <source>This indexer notation has been removed from the F# language</source>
        <target state="translated">Ta notacja indeksatora została usunięta z języka F#</target>
        <note />
      </trans-unit>
      <trans-unit id="astInvalidExprLeftHandOfAssignment">
        <source>Invalid expression on left of assignment</source>
        <target state="translated">Nieprawidłowe wyrażenie po lewej stronie przypisania</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoRefEqualsOnStruct">
        <source>The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'.</source>
        <target state="translated">Atrybut „ReferenceEquality” nie może być używany w strukturach. Rozważ użycie atrybutu „StructuralEquality” lub implementację przesłonięcia metody „System.Object.Equals(obiekt)”.</target>
        <note />
      </trans-unit>
      <trans-unit id="augInvalidAttrs">
        <source>This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'</source>
        <target state="translated">Ten typ używa nieprawidłowej kombinacji atrybutów „NoEquality”, „ReferenceEquality”, „StructuralEquality”, „NoComparison” i „StructuralComparison”</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqualityNeedsNoComparison">
        <source>The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute</source>
        <target state="translated">Atrybut „NoEquality” musi być używany w połączeniu z atrybutem „NoComparison”</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructCompNeedsStructEquality">
        <source>The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute</source>
        <target state="translated">Atrybut „StructuralComparison” musi być używany w połączeniu z atrybutem „StructuralEquality”</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructEqNeedsNoCompOrStructComp">
        <source>The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes</source>
        <target state="translated">Atrybut „StructuralEquality” musi być używany w połączeniu z atrybutami „NoComparison” lub „StructuralComparison”</target>
        <note />
      </trans-unit>
      <trans-unit id="augTypeCantHaveRefEqAndStructAttrs">
        <source>A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes</source>
        <target state="translated">Typ nie może mieć jednocześnie atrybutu „ReferenceEquality” i atrybutów „StructuralEquality” lub „StructuralComparison”</target>
        <note />
      </trans-unit>
      <trans-unit id="augOnlyCertainTypesCanHaveAttrs">
        <source>Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes</source>
        <target state="translated">Za pomocą atrybutów „ReferenceEquality”, „StructuralEquality” i „StructuralComparison” mogą być rozszerzane tylko typy rekordu, unii, wyjątku i struktury</target>
        <note />
      </trans-unit>
      <trans-unit id="augRefEqCantHaveObjEquals">
        <source>A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">Typ z atrybutem „ReferenceEquality” nie może mieć jawnej implementacji metody „Object.Equals(obiekt)”, interfejsu „System.IEquatable&lt;_&gt;” ani interfejsu „System.Collections.IStructuralEquatable”</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsObjEquals">
        <source>A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">Typ z atrybutem „CustomEquality” musi mieć jawną implementację co najmniej jednego z następujących elementów: metody „Object.Equals(obiekt)”, interfejsu „System.IEquatable&lt;_&gt;” lub interfejsu „System.Collections.IStructuralEquatable”</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomCompareNeedsIComp">
        <source>A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'</source>
        <target state="translated">Typ z atrybutem „CustomComparison” musi mieć jawną implementację co najmniej jednego z następujących interfejsów: „System.IComparable” lub „System.Collections.IStructuralComparable”</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqNeedsNoObjEquals">
        <source>A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">Typ z atrybutem „NoEquality” nie powinien zwykle mieć jawnej implementacji metody„Object.Equals(obiekt)”. Wyłącz to ostrzeżenie, jeśli jest to zamierzone do celów związanych z międzyoperacyjnością</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoCompCantImpIComp">
        <source>A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable&lt;_&gt;' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">Typ z atrybutem „NoComparison” nie powinien zwykle mieć jawnej implementacji interfejsu „System.IComparable”, interfejsu „System.IComparable&lt;_&gt;” ani interfejsu „System.Collections.IStructuralComparable”. Wyłącz to ostrzeżenie, jeśli jest to zamierzone na potrzeby współdziałania</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsNoCompOrCustomComp">
        <source>The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes</source>
        <target state="translated">Atrybut „CustomEquality” musi być używany w połączeniu z atrybutami „NoComparison” lub „CustomComparison”</target>
        <note />
      </trans-unit>
      <trans-unit id="forPositionalSpecifiersNotPermitted">
        <source>Positional specifiers are not permitted in format strings</source>
        <target state="translated">Specyfikatory pozycyjne są niedozwolone w ciągach formatu</target>
        <note />
      </trans-unit>
      <trans-unit id="forMissingFormatSpecifier">
        <source>Missing format specifier</source>
        <target state="translated">Brak specyfikatora formatu</target>
        <note />
      </trans-unit>
      <trans-unit id="forFlagSetTwice">
        <source>'{0}' flag set twice</source>
        <target state="translated">Dwukrotnie ustawiono flagę „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrefixFlagSpacePlusSetTwice">
        <source>Prefix flag (' ' or '+') set twice</source>
        <target state="translated">Dwukrotnie ustawiono flagę prefiksu („ ” lub „+”)</target>
        <note />
      </trans-unit>
      <trans-unit id="forHashSpecifierIsInvalid">
        <source>The # formatting modifier is invalid in F#</source>
        <target state="translated">Modyfikator formatu # jest nieprawidłowy w języku F#</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadPrecision">
        <source>Bad precision in format specifier</source>
        <target state="translated">Zła dokładność w specyfikatorze formatu</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadWidth">
        <source>Bad width in format specifier</source>
        <target state="translated">Zła szerokość w specyfikatorze formatu</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportZeroFlag">
        <source>'{0}' format does not support '0' flag</source>
        <target state="translated">Format „{0}” nie obsługuje flagi „0”</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrecisionMissingAfterDot">
        <source>Precision missing after the '.'</source>
        <target state="translated">Brak dokładności po znaku „.”</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatDoesntSupportPrecision">
        <source>'{0}' format does not support precision</source>
        <target state="translated">Format „{0}” nie obsługuje dokładności</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifier">
        <source>Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Zły specyfikator formatu (po l lub L): oczekiwano ld,li,lo,lu,lx lub lX. W kodzie języka F# można zamiast tego używać specyfikatorów %d, %x, %o lub %u, które są przeciążone w celu współpracy z wszystkimi podstawowymi typami liczb całkowitych.</target>
        <note />
      </trans-unit>
      <trans-unit id="forLIsUnnecessary">
        <source>The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Litera „l” lub „L” w tym specyfikatorze formatu jest niepotrzebna. W kodzie języka F# można zamiast tego używać specyfikatorów %d, %x, %o lub %u, które są przeciążone w celu współpracy z wszystkimi podstawowymi typami liczb całkowitych.</target>
        <note />
      </trans-unit>
      <trans-unit id="forHIsUnnecessary">
        <source>The 'h' or 'H' in this format specifier is unnecessary. You can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Litera „h” lub „H” w tym specyfikatorze formatu jest niepotrzebna. Można zamiast tego używać specyfikatora %d, %x, %o lub %u, które są przeciążone w celu współdziałania ze wszystkimi podstawowymi typami liczb całkowitych.</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportPrefixFlag">
        <source>'{0}' does not support prefix '{1}' flag</source>
        <target state="translated">Element „{0}” nie obsługuje flagi „{1}” prefiksu</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifierGeneral">
        <source>Bad format specifier: '{0}'</source>
        <target state="translated">Zły specyfikator formatu: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="elSysEnvExitDidntExit">
        <source>System.Environment.Exit did not exit</source>
        <target state="translated">Metoda System.Environment.Exit nie została zakończona</target>
        <note />
      </trans-unit>
      <trans-unit id="elDeprecatedOperator">
        <source>The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined</source>
        <target state="translated">Ten operator jest teraz obsługiwany bezpośrednio przez kompilator języka F# i nie można ponownie zdefiniować jego znaczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="chkProtectedOrBaseCalled">
        <source>A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope.</source>
        <target state="translated">Wywołano chroniony element członkowski lub używane jest słowo kluczowe „base”. Jest to dozwolone tylko w bezpośredniej implementacji elementów członkowskich, ponieważ mogą one wykraczać poza swój zakres obiektu</target>
        <note />
      </trans-unit>
      <trans-unit id="chkByrefUsedInInvalidWay">
        <source>The byref-typed variable '{0}' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.</source>
        <target state="translated">Zmienna z podanym typem byref „{0}” jest używana w nieprawidłowy sposób. Tego typu zmienne nie mogą być przechwytywane przez zamknięcia lub przekazywane do funkcji wewnętrznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkBaseUsedInInvalidWay">
        <source>The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.</source>
        <target state="translated">Słowo kluczowe „base” jest używane w nieprawidłowy sposób. Wywołania elementów podstawowych nie mogą być używane w zamknięciach. Rozważ użycie prywatnego elementu członkowskiego na potrzeby wywołań elementów podstawowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkVariableUsedInInvalidWay">
        <source>The variable '{0}' is used in an invalid way</source>
        <target state="translated">Zmienna „{0}” jest używana w nieprawidłowy sposób</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTypeLessAccessibleThanType">
        <source>The type '{0}' is less accessible than the value, member or type '{1}' it is used in.</source>
        <target state="translated">Typ „{0}” jest mniej dostępny niż wartość, element członkowski lub typ „{1}”, w którym jest używany.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSystemVoidOnlyInTypeof">
        <source>'System.Void' can only be used as 'typeof&lt;System.Void&gt;' in F#</source>
        <target state="translated">Typ „System.Void” może być używany w języku F# tylko w postaci „typeof&lt;System.Void&gt;”</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorUseOfByref">
        <source>A type instantiation involves a byref type. This is not permitted by the rules of Common IL.</source>
        <target state="translated">Tworzenie wystąpienia typu obejmuje typ byref. Nie jest to dozwolone przez reguły języka Common IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorContainsCallToRethrow">
        <source>Calls to 'reraise' may only occur directly in a handler of a try-with</source>
        <target state="translated">Wywołania „reraise” mogą występować tylko bezpośrednio w procedurze obsługi instrukcji try-with</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSplicingOnlyInQuotations">
        <source>Expression-splicing operators may only be used within quotations</source>
        <target state="translated">Operatory łączenia wyrażenia mogą być używane tylko w cudzysłowach</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassSplicing">
        <source>First-class uses of the expression-splicing operator are not permitted</source>
        <target state="translated">Pierwszoklasowe użycia operatora łączenia wyrażenia są niedozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassAddressOf">
        <source>First-class uses of the address-of operators are not permitted</source>
        <target state="translated">Pierwszoklasowe użycia operatorów adresu są niedozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassRethrow">
        <source>First-class uses of the 'reraise' function is not permitted</source>
        <target state="translated">Pierwszoklasowe użycia funkcji „reraise” są niedozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAtThisPoint">
        <source>The byref typed value '{0}' cannot be used at this point</source>
        <target state="translated">Wartość z podanym typem byref „{0}” nie może być używana w tym momencie</target>
        <note />
      </trans-unit>
      <trans-unit id="chkLimitationsOfBaseKeyword">
        <source>'base' values may only be used to make direct calls to the base implementations of overridden members</source>
        <target state="translated">Wartości „base” mogą być używane tylko w celu bezpośrednich wywołań, które dotyczą podstawowych implementacji przesłoniętych elementów członkowskich</target>
        <note />
      </trans-unit>
      <trans-unit id="chkObjCtorsCantUseExceptionHandling">
        <source>Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.</source>
        <target state="translated">Konstruktory obiektów nie mogą bezpośrednio używać instrukcji try/with i try/finally przed zainicjowaniem obiektu. Obejmuje to takie konstrukcje, jak „for x in ...”, które mogą skutkować użyciem takich konstrukcji. Jest to ograniczenie nałożone przez język Common IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfAtThisPoint">
        <source>The address of the variable '{0}' cannot be used at this point</source>
        <target state="translated">Nie można użyć adresu zmiennej „{0}” w tym momencie</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressStaticFieldAtThisPoint">
        <source>The address of the static field '{0}' cannot be used at this point</source>
        <target state="translated">Nie można użyć adresu pola statycznego „{0}” w tym momencie</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressFieldAtThisPoint">
        <source>The address of the field '{0}' cannot be used at this point</source>
        <target state="translated">Adres pola „{0}” nie może być używany w tym momencie</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfArrayElementAtThisPoint">
        <source>The address of an array element cannot be used at this point</source>
        <target state="translated">Nie można użyć adresu elementu tablicy w tym momencie</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFirstClassFuncNoByref">
        <source>The type of a first-class function cannot contain byrefs</source>
        <target state="translated">Typ funkcji pierwszoklasowej nie może zawierać typów byref</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReturnTypeNoByref">
        <source>A method return type would contain byrefs which is not permitted</source>
        <target state="translated">Zwracany typ metody może zawierać wartości typu byref, co jest niedozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidCustAttrVal">
        <source>Invalid custom attribute value (not a constant or literal)</source>
        <target state="translated">Nieprawidłowa wartość atrybutu niestandardowego (nie jest to stała ani literał)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkAttrHasAllowMultiFalse">
        <source>The attribute type '{0}' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element.</source>
        <target state="translated">Typ atrybutu „{0}” zawiera wartość „AllowMultiple=false”. Do pojedynczego elementu języka nie można dołączyć wielu wystąpień tego atrybutu.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to its definition at or near '{2}'. This is an invalid forward reference.</source>
        <target state="translated">Element członkowski „{0}” jest używany w nieprawidłowy sposób. Użycie „{1}” zostało wywnioskowane przed jego definicją w „{2}” lub w pobliżu tego miejsca. Jest to nieprawidłowe odwołanie w przód.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAsTopValue">
        <source>A byref typed value would be stored here. Top-level let-bound byref values are not permitted.</source>
        <target state="translated">Może tutaj być przechowywana wartość typu byref. Wartości typu byref najwyższego poziomu wiązane słowem kluczowym let są niedozwolone.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReflectedDefCantSplice">
        <source>[&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">W warunkach [&lt;ReflectedDefinition&gt;] nie można używać operatora łączenia prefiksu „%”</target>
        <note />
      </trans-unit>
      <trans-unit id="chkEntryPointUsage">
        <source>A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence.</source>
        <target state="translated">Funkcja z etykietą i atrybutem „EntryPointAttribute” musi być ostatnią deklaracją w ostatnim pliku sekwencji kompilacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseCompiledForm">
        <source>compiled form of the union case</source>
        <target state="translated">skompilowanej postaci przypadku unii</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseDefaultAugmentation">
        <source>default augmentation of the union case</source>
        <target state="translated">domyślnym rozszerzeniu przypadku unii</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameMethod">
        <source>The property '{0}' has the same name as a method in type '{1}'.</source>
        <target state="translated">Właściwość „{0}” ma taką samą nazwę co metoda w typie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterSetterDoNotMatchAbstract">
        <source>The property '{0}' of type '{1}' has a getter and a setter that do not match. If one is abstract then the other must be as well.</source>
        <target state="translated">Właściwość „{0}” typu „{1}” ma metodę pobierającą i metodę ustawiającą, które są niezgodne. Jeśli jedna z nich jest abstrakcyjna, druga również musi taka być.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameIndexer">
        <source>The property '{0}' has the same name as another property in type '{1}', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.</source>
        <target state="translated">Właściwość „{0}” ma taką samą nazwę co inna właściwość w typie „{1}”, ale pobiera argumenty indeksatora, których druga właściwość nie pobiera. Być może brakuje argumentu indeksatora jednej z właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCantStoreByrefValue">
        <source>A type would store a byref typed value. This is not permitted by Common IL.</source>
        <target state="translated">Typ będzie przechowywać wartość typu byref. Nie jest to dozwolone przez język Common IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethod">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}'.</source>
        <target state="translated">Zduplikowana metoda. Metoda „{0}” ma taką samą nazwę i sygnaturę co inna metoda w typie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodWithSuffix">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Zduplikowana metoda. Metoda „{0}” ma taką samą nazwę i sygnaturę co inna metoda w typie „{1}” po wymazaniu krotek, funkcji, jednostek miary i/lub udostępnionych typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodCurried">
        <source>The method '{0}' has curried arguments but has the same name as another method in type '{1}'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.</source>
        <target state="translated">Metoda „{0}” ma argumenty curried i taką samą nazwę co inna metoda w typie „{1}”. Nie można przeciążać metod z argumentami curried. Rozważ użycie metody pobierającej argumenty w postaci krotki.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCurriedMethodsCantHaveOutParams">
        <source>Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments</source>
        <target state="translated">Metody z argumentami curried nie mogą deklarować argumentu „out”, „ParamArray”, „optional”, „ReflectedDefinition”, „byref”, „CallerLineNumber”, „CallerMemberName” lub „CallerFilePath”</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateProperty">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}'.</source>
        <target state="translated">Zduplikowana właściwość. Właściwość „{0}” ma taką samą nazwę i sygnaturę co inna właściwość w typie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicatePropertyWithSuffix">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Zduplikowana właściwość. Właściwość „{0}” ma taką samą nazwę i sygnaturę co inna właściwość w typie „{1}” po wymazaniu krotek, funkcji, jednostek miary i/lub udostępnionych typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedType">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type.</source>
        <target state="translated">Zduplikowana metoda. Metoda abstrakcyjna „{0}” ma taką samą nazwę i sygnaturę co metoda abstrakcyjna w typie dziedziczonym.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedTypeWithSuffix">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Zduplikowana metoda. Metoda abstrakcyjna „{0}” ma taką samą nazwę i sygnaturę co metoda abstrakcyjna w typie dziedziczonym po wymazaniu krotek, funkcji, jednostek miary i/lub udostępnionych typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMultipleGenericInterfaceInstantiations">
        <source>This type implements the same interface at different generic instantiations '{0}' and '{1}'. This is not permitted in this version of F#.</source>
        <target state="translated">Ten typ implementuje ten sam interfejs w różnych ogólnych utworzonych wystąpieniach „{0}” i „{1}”. Nie jest to dozwolone w tej wersji języka F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkValueWithDefaultValueMustHaveDefaultValue">
        <source>The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check</source>
        <target state="translated">Typ pola używający atrybutu „DefaultValue” musi przyjąć domyślne inicjowanie (np. mieć wartość „null” jako poprawną wartość lub być typem struktury, którego wszystkie pola przyjmują domyślne inicjowanie). Aby wyłączyć to sprawdzenie, można użyć atrybutu „DefaultValue(false)”</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefInTypeAbbrev">
        <source>The type abbreviation contains byrefs. This is not permitted by F#.</source>
        <target state="translated">Skrót typu zawiera typy byref. Jest to niedozwolone w języku F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefBoundVarUsedInSplice">
        <source>The variable '{0}' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.</source>
        <target state="translated">Zmienna „{0}” jest powiązana w wyrażeniu cytowanym, ale jest używana jako część połączonego wyrażenia. Jest to niedozwolone, ponieważ może spowodować wykroczenie zmiennej poza jej zakres.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericExprs">
        <source>Quotations cannot contain uses of generic expressions</source>
        <target state="translated">Wyrażenia cytowane nie mogą używać wyrażeń ogólnych</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericFunctions">
        <source>Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.</source>
        <target state="translated">Wyrażenia cytowane nie mogą zawierać definicji funkcji, które są wnioskowane lub deklarowane jako ogólne. Rozważ dodanie ograniczeń typów w celu zapewnienia poprawności tego wyrażenia cytowanego.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainObjExprs">
        <source>Quotations cannot contain object expressions</source>
        <target state="translated">Wyrażenia cytowane nie mogą zawierać wyrażeń obiektu</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainAddressOf">
        <source>Quotations cannot contain expressions that take the address of a field</source>
        <target state="translated">Konstrukcje w cudzysłowie nie mogą zawierać wyrażeń, które pobierają adres pola</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainStaticFieldRef">
        <source>Quotations cannot contain expressions that fetch static fields</source>
        <target state="translated">Wyrażenia cytowane nie mogą zawierać wyrażeń, które pobierają pola statyczne</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainInlineIL">
        <source>Quotations cannot contain inline assembly code or pattern matching on arrays</source>
        <target state="translated">Konstrukcje w cudzysłowie nie mogą zawierać wbudowanego kodu zestawu lub dopasowania wzorca w tablicach</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainDescendingForLoops">
        <source>Quotations cannot contain descending for loops</source>
        <target state="translated">Konstrukcje w cudzysłowie nie mogą zawierać malejących pętli for</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantFetchUnionIndexes">
        <source>Quotations cannot contain expressions that fetch union case indexes</source>
        <target state="translated">Wyrażenia cytowane nie mogą zawierać wyrażeń, które pobierają indeksy przypadku unii</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetUnionFields">
        <source>Quotations cannot contain expressions that set union case fields</source>
        <target state="translated">Konstrukcje w cudzysłowie nie mogą zawierać wyrażeń, które ustawiają pola przypadku unii</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetExceptionFields">
        <source>Quotations cannot contain expressions that set fields in exception values</source>
        <target state="translated">Konstrukcje w cudzysłowie nie mogą zawierać wyrażeń, które ustawiają pola w wartościach wyjątku</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantRequireByref">
        <source>Quotations cannot contain expressions that require byref pointers</source>
        <target state="translated">Konstrukcje w cudzysłowie nie mogą zawierać wyrażeń, które wymagają wskaźników byref</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantCallTraitMembers">
        <source>Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call</source>
        <target state="translated">Konstrukcja w cudzysłowie nie mogą zawierać wyrażeń, które tworzą wywołania ograniczenia elementu członkowskiego, lub używać operatorów niejawnie rozpoznawanych jako wywołanie ograniczenia elementu członkowskiego</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisConstant">
        <source>Quotations cannot contain this kind of constant</source>
        <target state="translated">Wyrażenia cytowane nie mogą zawierać tego rodzaju stałej</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisPatternMatch">
        <source>Quotations cannot contain this kind of pattern match</source>
        <target state="translated">Wyrażenia cytowane nie mogą zawierać tego rodzaju dopasowania wzorca</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainArrayPatternMatching">
        <source>Quotations cannot contain array pattern matching</source>
        <target state="translated">Konstrukcje w cudzysłowie nie mogą zawierać dopasowania wzorca tablicy</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisType">
        <source>Quotations cannot contain this kind of type</source>
        <target state="translated">Wyrażenia cytowane nie mogą zawierać tego rodzaju typu</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeCannotBeResolvedAtCompileTime">
        <source>The declared type parameter '{0}' cannot be used here since the type parameter cannot be resolved at compile time</source>
        <target state="translated">Zadeklarowany parametr typu „{0}” nie może być tutaj używany, ponieważ nie można rozpoznać parametru typu w czasie kompilacji</target>
        <note />
      </trans-unit>
      <trans-unit id="csCodeLessGeneric">
        <source>This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'.</source>
        <target state="translated">Ten kod jest mniej ogólny, niż wskazują na to jego adnotacje. Jednostka miary podana przy użyciu konstrukcji „_” została określona jako „1” (czyli bez wymiaru). Rozważ zapewnienie ogólności kodu lub zrezygnowanie z użycia konstrukcji „_”.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInferenceMaxDepth">
        <source>Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.</source>
        <target state="translated">Problem wnioskowania o typie jest zbyt złożony (osiągnięto maksymalną głębokość iteracji). Rozważ dodanie dodatkowych adnotacji typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectedArguments">
        <source>Expected arguments to an instance member</source>
        <target state="translated">Oczekiwano argumentów elementu członkowskiego wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="csIndexArgumentMismatch">
        <source>This indexer expects {0} arguments but is here given {1}</source>
        <target state="translated">Ten indeksator oczekuje argumentów w liczbie {0}, ale podano tutaj argumenty w liczbie {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenFunction">
        <source>Expecting a type supporting the operator '{0}' but given a function type. You may be missing an argument to a function.</source>
        <target state="translated">Oczekiwany jest typ obsługujący operator „{0}”, ale podano typ funkcji. Być może brakuje argumentu funkcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenTuple">
        <source>Expecting a type supporting the operator '{0}' but given a tuple type</source>
        <target state="translated">Oczekiwany jest typ obsługujący operator „{0}”, ale podano typ krotki</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperator">
        <source>None of the types '{0}' support the operator '{1}'</source>
        <target state="translated">Żaden z typów „{0}” nie obsługuje operatora „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperator">
        <source>The type '{0}' does not support the operator '{1}'</source>
        <target state="translated">Typ „{0}” nie obsługuje operatora „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperatorNullable">
        <source>None of the types '{0}' support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Żaden z typów „{0}” nie obsługuje operatora „{1}”. Rozważ otwarcie modułu „Microsoft.FSharp.Linq.NullableOperators”.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperatorNullable">
        <source>The type '{0}' does not support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Typ „{0}” nie obsługuje operatora „{1}”. Rozważ otwarcie modułu „Microsoft.FSharp.Linq.NullableOperators”.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportConversion">
        <source>The type '{0}' does not support a conversion to the type '{1}'</source>
        <target state="translated">Typ „{0}” nie obsługuje konwersji do typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is static</source>
        <target state="translated">Typ „{0}” ma metodę „{1}” (pełna nazwa „{2}”), ale metoda jest statyczna</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsNotStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is not static</source>
        <target state="translated">Typ „{0}” ma metodę „{1}” (pełna nazwa „{2}”), ale metoda nie jest statyczna</target>
        <note />
      </trans-unit>
      <trans-unit id="csStructConstraintInconsistent">
        <source>The constraints 'struct' and 'not struct' are inconsistent</source>
        <target state="translated">Ograniczenia „struct” i „not struct” nie są spójne</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value</source>
        <target state="translated">Typ „{0}” nie ma wartości „null” jako właściwej wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="csNullableTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'.</source>
        <target state="translated">Typ „{0}” nie ma wartości „null” jako właściwej wartości. Aby utworzyć wartość null dla typu Nullable, użyj wartości „System.Nullable()”.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison1">
        <source>The type '{0}' does not support the 'comparison' constraint because it has the 'NoComparison' attribute</source>
        <target state="translated">Typ „{0}” nie obsługuje ograniczenia „comparison”, ponieważ ma on atrybut „NoComparison”</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison2">
        <source>The type '{0}' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface</source>
        <target state="translated">Typ „{0}” nie obsługuje ograniczenia „comparison”. Na przykład typ nie obsługuje interfejsu „System.IComparable”</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison3">
        <source>The type '{0}' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison</source>
        <target state="translated">Typ „{0}” nie obsługuje ograniczenia „comparison”, ponieważ jest rekordem, unią lub strukturą z co najmniej jednym typem elementu strukturalnego, który nie obsługuje ograniczenia „comparison”. Unikaj używania porównania z tym typem lub dodaj atrybut „StructuralComparison” do typu w celu ustalenia, jaki typ pola nie obsługuje porównania</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality1">
        <source>The type '{0}' does not support the 'equality' constraint because it has the 'NoEquality' attribute</source>
        <target state="translated">Typ „{0}” nie obsługuje ograniczenia „equality”, ponieważ ma on atrybut „NoEquality”</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality2">
        <source>The type '{0}' does not support the 'equality' constraint because it is a function type</source>
        <target state="translated">Typ „{0}” nie obsługuje ograniczenia „equality”, ponieważ ma on typ funkcji</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality3">
        <source>The type '{0}' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality</source>
        <target state="translated">Typ „{0}” nie obsługuje ograniczenia „equality”, ponieważ jest rekordem, unią lub strukturą z co najmniej jednym typem elementu strukturalnego, który nie obsługuje ograniczenia „equality”. Unikaj używania równości z tym typem lub dodaj atrybut „StructuralEquality” do typu w celu ustalenia, jaki typ pola nie obsługuje równości</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotEnumType">
        <source>The type '{0}' is not a CLI enum type</source>
        <target state="translated">Typ „{0}” nie jest typem wyliczeniowym infrastruktury CLI</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeHasNonStandardDelegateType">
        <source>The type '{0}' has a non-standard delegate type</source>
        <target state="translated">Typ „{0}” ma niestandardowy typ delegata.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotDelegateType">
        <source>The type '{0}' is not a CLI delegate type</source>
        <target state="translated">Typ „{0}” nie jest typem delegata infrastruktury CLI.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeParameterCannotBeNullable">
        <source>This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values.</source>
        <target state="translated">Dla tego parametru typu nie można utworzyć wystąpienia jako „Nullable”. Jest to ograniczenie nałożone w celu zapewnienia, że znaczenie wartości „null” w niektórych językach infrastruktury CLI nie zostanie niewłaściwie określone podczas używania w połączeniu z wartościami „Nullable”.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructType">
        <source>A generic construct requires that the type '{0}' is a CLI or F# struct type</source>
        <target state="translated">Ogólna konstrukcja wymaga, aby typ „{0}” był typem struktury infrastruktury CLI lub języka F#</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresUnmanagedType">
        <source>A generic construct requires that the type '{0}' is an unmanaged type</source>
        <target state="translated">Ogólna konstrukcja wymaga, aby typ „{0}” był typem niezarządzanym</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeNotCompatibleBecauseOfPrintf">
        <source>The type '{0}' is not compatible with any of the types {1}, arising from the use of a printf-style format string</source>
        <target state="translated">Typ „{0}” nie jest zgodny z żadnym z typów {1}, co wynika z użycia ciągu formatu w stylu funkcji printf</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresReferenceSemantics">
        <source>A generic construct requires that the type '{0}' have reference semantics, but it does not, i.e. it is a struct</source>
        <target state="translated">Konstrukcja ogólna wymaga, aby typ „{0}” miał semantykę odwołania, ale tak nie jest, ponieważ jest on strukturą</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresNonAbstract">
        <source>A generic construct requires that the type '{0}' be non-abstract</source>
        <target state="translated">Ogólna konstrukcja wymaga, aby typ „{0}” nie był typem abstrakcyjnym</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresPublicDefaultConstructor">
        <source>A generic construct requires that the type '{0}' have a public default constructor</source>
        <target state="translated">Ogólna konstrukcja wymaga, aby typ „{0}” miał publiczny konstruktor domyślny</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInstantiationLengthMismatch">
        <source>Type instantiation length mismatch</source>
        <target state="translated">Niezgodność długości tworzenia wystąpienia typu</target>
        <note />
      </trans-unit>
      <trans-unit id="csOptionalArgumentNotPermittedHere">
        <source>Optional arguments not permitted here</source>
        <target state="translated">Argumenty opcjonalne nie są tutaj dozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotStatic">
        <source>{0} is not a static member</source>
        <target state="translated">Element {0} nie jest statycznym elementem członkowskim</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotInstance">
        <source>{0} is not an instance member</source>
        <target state="translated">Element {0} nie jest elementem członkowskim wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentLengthMismatch">
        <source>Argument length mismatch</source>
        <target state="translated">Niezgodność długości argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentTypesDoNotMatch">
        <source>The argument types don't match</source>
        <target state="translated">Typy argumentu są niezgodne</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodExpectsParams">
        <source>This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument</source>
        <target state="translated">Ta metoda oczekuje parametru „params” infrastruktury CLI na tej pozycji. Parametr „params” umożliwia przekazywanie zmiennej liczby argumentów metodzie w językach takich jak C#. Rozważ przekazanie tablicy dla tego argumentu</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible">
        <source>The member or object constructor '{0}' is not {1}</source>
        <target state="translated">Konstruktor elementu członkowskiego lub obiektu „{0}” nie jest {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible2">
        <source>The member or object constructor '{0}' is not {1}. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.</source>
        <target state="translated">Element członkowski lub konstruktor obiektów „{0}” nie jest {1}. Prywatne elementy członkowskie mogą być dostępne tylko w obrębie typu deklarującego. Chronione elementy członkowskie mogą być dostępne tylko z poziomu typu rozszerzającego. Nie można uzyskać do nich dostępu z poziomu wewnętrznych wyrażeń lambda.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAStaticMethod">
        <source>{0} is not a static method</source>
        <target state="translated">Metoda {0} nie jest metodą statyczną</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAnInstanceMethod">
        <source>{0} is not an instance method</source>
        <target state="translated">Metoda {0} nie jest metodą wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberHasNoArgumentOrReturnProperty">
        <source>The member or object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">Element członkowski lub konstruktor obiektów „{0}” nie ma argumentu lub ustawialnej właściwości zwracanej „{1}”. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorHasNoArgumentOrReturnProperty">
        <source>The object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">Konstruktor obiektu „{0}” nie ma argumentu lub konfigurowalnej właściwości zwracania „{1}”. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csRequiredSignatureIs">
        <source>The required signature is {0}</source>
        <target state="translated">Wymagana sygnatura to {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'.</source>
        <target state="translated">Element członkowski lub konstruktor obiektów „{0}” wymaga argumentów w liczbie {1}. Wymagana sygnatura to „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch2">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'.</source>
        <target state="translated">Element członkowski lub konstruktor obiektów „{0}” wymaga dodatkowych argumentów w liczbie {1}. Wymagana sygnatura to „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch3">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">Element członkowski lub konstruktor obiektów „{0}” wymaga argumentów w liczbie {1}. Wymagana sygnatura to „{2}”. Niektóre nazwy brakujących argumentów to: {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch4">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">Konstruktor elementu członkowskiego lub obiektu „{0}” wymaga dodatkowych argumentów w liczbie {1}. Wymagana sygnatura to „{2}”. Niektóre nazwy brakujących argumentów to: {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityNamed">
        <source>The member or object constructor '{0}' requires {1} argument(s) but is here given {2} unnamed and {3} named argument(s). The required signature is '{4}'.</source>
        <target state="translated">Konstruktor elementu członkowskiego lub obiektu „{0}” wymaga argumentów w liczbie {1}, ale podano tutaj nienazwane i nazwane argumenty w liczbie wynoszącej odpowiednio {2} i {3}. Wymagana sygnatura to „{4}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArity">
        <source>The member or object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Konstruktor elementu członkowskiego lub obiektu „{0}” pobiera argumenty w liczbie {1}, ale podano tutaj {2}. Wymagana sygnatura to „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArity">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Konstruktor obiektu „{0}” przyjmuje argumenty {1}, ale tutaj podano {2}. Wymagany podpis to „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArityProp">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',').</source>
        <target state="translated">Konstruktor obiektu „{0}” przyjmuje argumenty {1}, ale tutaj podano {2}. Wymagany podpis to „{3}”. Jeśli niektóre z argumentów mają przypisywać wartości do właściwości, rozważ rozdzielenie tych argumentów za pomocą przecinka („,”).</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityType">
        <source>The member or object constructor '{0}' takes {1} type argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Element członkowski lub konstruktor obiektów „{0}” pobiera argumenty typu w liczbie {1}, ale podano tutaj {2}. Wymagana sygnatura to „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberNotAccessible">
        <source>A member or object constructor '{0}' taking {1} arguments is not accessible from this code location. All accessible versions of method '{2}' take {3} arguments.</source>
        <target state="translated">Konstruktor elementu członkowskiego lub obiektu „{0}” pobiera argumenty, których liczba to {1} i które są niedostępne w tej lokalizacji kodu. Wszystkie dostępne wersje metody „{2}” pobierają argumenty o następującej liczbie: {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csIncorrectGenericInstantiation">
        <source>Incorrect generic instantiation. No {0} member named '{1}' takes {2} generic arguments.</source>
        <target state="translated">Niepoprawne ogólne tworzenie wystąpienia. Żaden element członkowski {0} o nazwie „{1}” nie pobiera {2} argumentów ogólnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberOverloadArityMismatch">
        <source>The member or object constructor '{0}' does not take {1} argument(s). An overload was found taking {2} arguments.</source>
        <target state="translated">Konstruktor elementu członkowskiego lub obiektu „{0}” nie pobiera argumentów w liczbie {1}. Znaleziono przeciążenie pobierające argumenty o następującej liczbie: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments</source>
        <target state="translated">Żaden element członkowski {0} lub konstruktor obiektu o nazwie „{1}” nie pobiera następującej liczby argumentów: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments2">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. Note the call to this member also provides {3} named arguments.</source>
        <target state="translated">Żaden element członkowski {0} lub konstruktor obiektu o nazwie „{1}” nie pobiera następującej liczby argumentów: {2}. Zauważ, że wywołanie tego elementu członkowskiego udostępnia również argumenty nazwane o następującej liczbie: {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments3">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. The named argument '{3}' doesn't correspond to any argument or settable return property for any overload.</source>
        <target state="translated">Żaden element członkowski {0} lub konstruktor obiektów o nazwie „{1}” nie pobiera następującej liczby argumentów: {2}. Argument nazwany „{3}” nie odpowiada żadnemu argumentowi lub ustawialnej właściwości zwracanej w żadnym przeciążeniu.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodNotFound">
        <source>Method or object constructor '{0}' not found</source>
        <target state="translated">Nie znaleziono metody lub konstruktora obiektów „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFound">
        <source>No overloads match for method '{0}'.</source>
        <target state="translated">Brak przeciążeń zgodnych z metodą „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsOverloaded">
        <source>A unique overload for method '{0}' could not be determined based on type information prior to this program point. A type annotation may be needed.</source>
        <target state="translated">Nie można określić unikatowego przeciążenia dla metody „{0}” na podstawie informacji o typach przed tym punktem programu. Może być wymagana adnotacja typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCandidates">
        <source>Candidates:\n{0}</source>
        <target state="translated">Kandydaci:\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="parsDoCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on 'do' bindings, but '{0}' was given.</source>
        <target state="translated">Modyfikatory dostępności są niedozwolone w powiązaniach „do”, ale podano element „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInHashIf">
        <source>End of file in #if section begun at or after here</source>
        <target state="translated">Koniec pliku w sekcji #if rozpoczętej w tym miejscu lub za nim</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInString">
        <source>End of file in string begun at or before here</source>
        <target state="translated">Koniec pliku w ciągu rozpoczętym w tym miejscu lub przed nim</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimString">
        <source>End of file in verbatim string begun at or before here</source>
        <target state="translated">Koniec pliku w ciągu dosłownego wyrażenia rozpoczętym w tym miejscu lub przed nim</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInComment">
        <source>End of file in comment begun at or before here</source>
        <target state="translated">Koniec pliku w komentarzu rozpoczętym w tym miejscu lub przed nim</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInStringInComment">
        <source>End of file in string embedded in comment begun at or before here</source>
        <target state="translated">Koniec pliku w ciągu osadzonym w komentarzu rozpoczętym w tym miejscu lub przed nim</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimStringInComment">
        <source>End of file in verbatim string embedded in comment begun at or before here</source>
        <target state="translated">Koniec pliku w ciągu dosłownego wyrażenia osadzonym w komentarzu rozpoczętym w tym miejscu lub przed nim</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInIfOcaml">
        <source>End of file in IF-OCAML section begun at or before here</source>
        <target state="translated">Koniec pliku w sekcji IF-OCAML rozpoczętej w tym miejscu lub przed nim</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInDirective">
        <source>End of file in directive begun at or before here</source>
        <target state="translated">Koniec pliku w dyrektywie rozpoczętej w tym miejscu lub przed nim</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoHashEndIfFound">
        <source>No #endif found for #if or #else</source>
        <target state="translated">Nie znaleziono dyrektywy #endif dla dyrektywy #if lub #else</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIgnored">
        <source>Attributes have been ignored in this construct</source>
        <target state="translated">Atrybuty zostały zignorowane w tej konstrukcji</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInImplicitClassConstructors">
        <source>'use' bindings are not permitted in primary constructors</source>
        <target state="translated">Powiązania „use” nie są dozwolone w konstruktorach podstawowych</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInModules">
        <source>'use' bindings are not permitted in modules and are treated as 'let' bindings</source>
        <target state="translated">Powiązania „use” nie są dozwolone w modułach i są traktowane jak powiązania „let”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIntegerForLoopRequiresSimpleIdentifier">
        <source>An integer for loop must use a simple identifier</source>
        <target state="translated">Pętla for z liczbami całkowitymi musi używać prostego identyfikatora</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyOneWithAugmentationAllowed">
        <source>At most one 'with' augmentation is permitted</source>
        <target state="translated">Dozwolone jest najwyżej jedno rozszerzenie „with”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSemicolon">
        <source>A semicolon is not expected at this point</source>
        <target state="translated">Średnik nie jest oczekiwany w tym miejscu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFile">
        <source>Unexpected end of input</source>
        <target state="translated">Nieoczekiwany koniec danych wejściowych</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedVisibilityDeclaration">
        <source>Accessibility modifiers are not permitted here, but '{0}' was given.</source>
        <target state="translated">Modyfikatory dostępności nie są tutaj dozwolone, ale podano element „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyHashDirectivesAllowed">
        <source>Only '#' compiler directives may occur prior to the first 'namespace' declaration</source>
        <target state="translated">Tylko dyrektywy kompilatora „#” mogą występować przed pierwszą deklaracją „namespace”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityDeclarationsShouldComePriorToIdentifier">
        <source>Accessibility modifiers should come immediately prior to the identifier naming a construct</source>
        <target state="translated">Modyfikatory dostępności powinny występować bezpośrednio przed identyfikatorem konstrukcji</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNamespaceOrModuleNotBoth">
        <source>Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'</source>
        <target state="translated">Pliki powinny rozpoczynać się od deklaracji przestrzeni nazw lub modułu (np. „namespace PrzestrzeńNazw.PodrzędnaPrzestrzeńNazw” lub „module PrzestrzeńNazw.Moduł”), ale nie od obu. Aby zdefiniować moduł w przestrzeni nazw, użyj konstrukcji „module Moduł = ...”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleAbbreviationMustBeSimpleName">
        <source>A module abbreviation must be a simple name, not a path</source>
        <target state="translated">Skrót modułu musi być prostą nazwą, a nie ścieżką</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviation">
        <source>Ignoring attributes on module abbreviation</source>
        <target state="translated">Ignorowanie atrybutów w skrócie modułu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">Atrybut dostępności „{0}” nie jest dozwolony w skrócie modułu. Skróty modułu zawsze są prywatne.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">Atrybut widoczności „{0}” nie jest dozwolony w skrócie modułu. Skróty modułu zawsze są prywatne.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnClosedBlockInHashLight">
        <source>Unclosed block</source>
        <target state="translated">Niezamknięty blok</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBeginOrStruct">
        <source>Unmatched 'begin' or 'struct'</source>
        <target state="translated">Niedopasowany element „begin” lub „struct”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleDefnMustBeSimpleName">
        <source>A module name must be a simple name, not a path</source>
        <target state="translated">Nazwa modułu musi być prostą nazwą, a nie ścieżką</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEmptyModuleDefn">
        <source>Unexpected empty type moduleDefn list</source>
        <target state="translated">Nieoczekiwana pusta lista typu moduleDefn</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesMustComeBeforeVal">
        <source>Attributes should be placed before 'val'</source>
        <target state="translated">Atrybuty powinny być umieszczone przed elementem „val”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesAreNotPermittedOnInterfaceImplementations">
        <source>Attributes are not permitted on interface implementations</source>
        <target state="translated">Atrybuty są niedozwolone w implementacjach interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxError">
        <source>Syntax error</source>
        <target state="translated">błąd składni</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAugmentationsIllegalOnDelegateType">
        <source>Augmentations are not permitted on delegate type moduleDefns</source>
        <target state="translated">Rozszerzenia są niedozwolone w typie delegata moduleDefns.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedClassInterfaceOrStruct">
        <source>Unmatched 'class', 'interface' or 'struct'</source>
        <target state="translated">Niedopasowany element „class”, „interface” lub „struct”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyTypeDefinition">
        <source>A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'.</source>
        <target state="translated">Definicja typu wymaga co najmniej jednego elementu członkowskiego lub innych deklaracji. Jeśli zamierzasz zdefiniować pustą klasę, strukturę lub interfejs, użyj konstrukcji „type ... = class end”, „interface end” lub „struct end”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedWith">
        <source>Unmatched 'with' or badly formatted 'with' block</source>
        <target state="translated">Niedopasowany blok „with” lub niepoprawnie sformatowany blok „with”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetOrSetRequired">
        <source>'get', 'set' or 'get,set' required</source>
        <target state="translated">Wymagana instrukcja „get”, „set” lub „get,set”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyClassCanTakeValueArguments">
        <source>Only class types may take value arguments</source>
        <target state="translated">Tylko typy klasy mogą pobierać argumenty wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBegin">
        <source>Unmatched 'begin'</source>
        <target state="translated">Niedopasowany element „begin”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidDeclarationSyntax">
        <source>Invalid declaration syntax</source>
        <target state="translated">Nieprawidłowa składnia deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetAndOrSetRequired">
        <source>'get' and/or 'set' required</source>
        <target state="translated">wymagane słowa „get” i/lub „set”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAnnotationsOnGetSet">
        <source>Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'</source>
        <target state="translated">Adnotacje typu w metodach ustawiających i pobierających właściwości muszą być podane po metodzie „get()” lub „set(v)” (np. „with get() : string = ...”)</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterMustHaveAtLeastOneArgument">
        <source>A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'</source>
        <target state="translated">Oczekiwano, że właściwość metody pobierającej będzie funkcją, np. „get() = ...” lub „get(indeks) = ...”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultipleAccessibilitiesForGetSet">
        <source>Multiple accessibilities given for property getter or setter</source>
        <target state="translated">Podano wiele dostępności dla metody ustawiającej lub metody pobierającej właściwość</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetSyntax">
        <source>Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '</source>
        <target state="translated">Metody ustawiające właściwości muszą być definiowane przy użyciu konstrukcji „set wartość = ”, „set indeks wartość = ” lub „set (indeks1,...,indeksN) wartość = ... ”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInterfacesHaveSameVisibilityAsEnclosingType">
        <source>Interfaces always have the same visibility as the enclosing type</source>
        <target state="translated">Interfejsy zawsze mają taką samą widoczność jak typ otaczający</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAccessibilityModsIllegalForAbstract">
        <source>Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.</source>
        <target state="translated">Modyfikatory dostępności są niedozwolone w tym elemencie członkowskim. Miejsca abstrakcyjne zawsze mają taką samą widoczność co typ otaczający.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalOnInherit">
        <source>Attributes are not permitted on 'inherit' declarations</source>
        <target state="translated">Atrybuty są niedozwolone w deklaracjach „inherit”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityIllegalOnInherit">
        <source>Accessibility modifiers are not permitted on an 'inherits' declaration</source>
        <target state="translated">Modyfikatory dostępności nie są dozwolone w deklaracji „inherits”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInheritDeclarationsCannotHaveAsBindings">
        <source>'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding.</source>
        <target state="translated">Deklaracje „inherit” nie mogą mieć powiązań „as”. Aby uzyskać dostęp do elementów członkowskich klasy podstawowej podczas przesłaniania metody, można użyć składni „base.ElementCzłonkowski”. „base” to słowo kluczowe. Usuń to powiązanie „as”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalHere">
        <source>Attributes are not allowed here</source>
        <target state="translated">Atrybuty są tutaj niedozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for type abbreviations</source>
        <target state="translated">Modyfikatory dostępności są niedozwolone w tej pozycji dla skrótów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumTypesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for enum types</source>
        <target state="translated">Modyfikatory dostępności są niedozwolone w tej pozycji dla typów wyliczeniowych</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAllEnumFieldsRequireValues">
        <source>All enum fields must be given values</source>
        <target state="translated">Dla wszystkich pól wyliczeń muszą zostać podane wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInlineAssemblyCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on inline assembly code types</source>
        <target state="translated">Modyfikatory dostępności nie są dozwolone w typach śródwierszowego kodu zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIdentifier">
        <source>Unexpected identifier: '{0}'</source>
        <target state="translated">Nieoczekiwany identyfikator: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnionCasesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Modyfikatory dostępności nie są dozwolone w przypadkach unii. Użyj ciągu type U = internal ...” lub „type U = private ...”, aby dodać dostępność do całej reprezentacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on enumeration fields</source>
        <target state="translated">Modyfikatory dostępności są niedozwolone w polach wyliczeń</target>
        <note />
      </trans-unit>
      <trans-unit id="parsConsiderUsingSeparateRecordType">
        <source>Consider using a separate record type instead</source>
        <target state="translated">Rozważ użycie osobnego typu rekordu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsRecordFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Modyfikatory dostępności są niedozwolone w polach rekordu. Użyj konstrukcji „type R = internal ...” lub „type R = private ...”, aby zapewnić dostępność całej reprezentacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsLetAndForNonRecBindings">
        <source>The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings</source>
        <target state="translated">Postać deklaracji „let ... and ...” dla powiązań innych niż cykliczne nie jest używana w kodzie języka F#. Rozważ użycie sekwencji powiązań „let”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedParen">
        <source>Unmatched '('</source>
        <target state="translated">Niedopasowany element „(”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessivePatternsShouldBeSpacedOrTupled">
        <source>Successive patterns should be separated by spaces or tupled</source>
        <target state="translated">Kolejne wzorce powinny być oddzielone spacjami lub mieć postać krotek</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoMatchingInForLet">
        <source>No matching 'in' found for this 'let'</source>
        <target state="translated">Nie znaleziono zgodnego tokenu „in” dla tego tokenu „let”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorInReturnForLetIncorrectIndentation">
        <source>Error in the return expression for this 'let'. Possible incorrect indentation.</source>
        <target state="translated">Błąd w wyrażeniu zwracanym dla tego słowa kluczowego „let”. Możliwe niepoprawne wcięcie.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterLet">
        <source>The block following this '{0}' is unfinished. Every code block is an expression and must have a result. '{1}' cannot be the final code element in a block. Consider giving this block an explicit result.</source>
        <target state="translated">Blok następujący po elemencie „{0}” jest niezakończony. Każdy blok kodu jest wyrażeniem i musi mieć wynik. Element „{1}” nie może być ostatnim elementem kodu w bloku. Rozważ zastosowanie jawnego wyniku w tym bloku.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIncompleteIf">
        <source>Incomplete conditional. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Niekompletne wyrażenie warunkowe. Oczekiwano konstrukcji „if &lt;wyrażenie&gt; then &lt;wyrażenie&gt;” lub „if &lt;wyrażenie&gt; then &lt;wyrażenie&gt; else &lt;wyrażenie&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAssertIsNotFirstClassValue">
        <source>'assert' may not be used as a first class value. Use 'assert &lt;expr&gt;' instead.</source>
        <target state="translated">Element „assert” nie może być używany jako wartość pierwszej klasy. Zamiast tego użyj elementu „assert &lt;wyrażenie&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">Oczekiwano identyfikatora</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInOrEqualExpected">
        <source>'in' or '=' expected</source>
        <target state="translated">Oczekiwano konstrukcji „in” lub „=”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsArrowUseIsLimited">
        <source>The use of '-&gt;' in sequence and computation expressions is limited to the form 'for pat in expr -&gt; expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions.</source>
        <target state="translated">Użycie konstrukcji „-&gt;” w wyrażeniach obliczeń i sekwencji jest ograniczone do postaci „for wzorzec in wyrażenie -&gt; wyrażenie”. Użyj składni „for ... in ... do ... yield...”, aby wygenerować elementy w bardziej złożonych wyrażeniach sekwencji.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessiveArgsShouldBeSpacedOrTupled">
        <source>Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized</source>
        <target state="translated">Kolejne argumenty powinny być oddzielone spacjami lub mieć postać krotek, a argumenty obejmujące aplikacje metody lub funkcji powinny być umieszczone w nawiasach okrągłych</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracket">
        <source>Unmatched '['</source>
        <target state="translated">Niedopasowany element „[”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingQualificationAfterDot">
        <source>Missing qualification after '.'</source>
        <target state="translated">Brak kwalifikacji po znaku „.”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsParenFormIsForML">
        <source>In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array</source>
        <target state="translated">W kodzie języka F# możesz użyć konstrukcji „wyrażenie.[wyrażenie]”. Adnotacja typu może być wymagana do wskazania, że pierwsze wyrażenie to tablica</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuote">
        <source>Mismatched quotation, beginning with '{0}'</source>
        <target state="translated">Niezgodny cytat, począwszy od „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatched">
        <source>Unmatched '{0}'</source>
        <target state="translated">Niedopasowany element „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracketBar">
        <source>Unmatched '[|'</source>
        <target state="translated">Niedopasowany element „[|”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBrace">
        <source>Unmatched '{{'</source>
        <target state="translated">Niedopasowany element „{{”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsFieldBinding">
        <source>Field bindings must have the form 'id = expr;'</source>
        <target state="translated">Powiązania pól muszą mieć postać „identyfikator = wyrażenie;”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMemberIllegalInObjectImplementation">
        <source>This member is not permitted in an object implementation</source>
        <target state="translated">Ten element członkowski jest niedozwolony w implementacji obiektu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingFunctionBody">
        <source>Missing function body</source>
        <target state="translated">Brak treści funkcji</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxErrorInLabeledType">
        <source>Syntax error in labelled type argument</source>
        <target state="translated">Błąd składni w argumencie typu z etykietą</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedInfixOperator">
        <source>Unexpected infix operator in type expression</source>
        <target state="translated">Nieoczekiwany operator infiksu w wyrażeniu typu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultiArgumentGenericTypeFormDeprecated">
        <source>The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident&lt;typ,...,typ&gt;' instead</source>
        <target state="translated">Składnia „(typ,...,typ) identyfikator” nie jest używana w kodzie F#. Rozważ użycie zamiast tego składni „identyfikator&lt;typ,...,typ&gt;”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidLiteralInType">
        <source>Invalid literal in type</source>
        <target state="translated">Nieprawidłowy literał w typie</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedOperatorForUnitOfMeasure">
        <source>Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'.</source>
        <target state="translated">Nieoczekiwany operator infiksu w wyrażeniu jednostki miary. Dozwolone operatory: „*”, „/” i „^”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIntegerLiteralForUnitOfMeasure">
        <source>Unexpected integer literal in unit-of-measure expression</source>
        <target state="translated">Nieoczekiwany literał całkowity w wyrażeniu jednostki miary</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedTypeParameter">
        <source>Syntax error: unexpected type parameter specification</source>
        <target state="translated">Błąd składni: nieoczekiwana specyfikacja parametru typu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuotationName">
        <source>Mismatched quotation operator name, beginning with '{0}'</source>
        <target state="translated">Niezgodna nazwa operatora cytatu, począwszy od „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseMustBeginWithUpperCase">
        <source>Active pattern case identifiers must begin with an uppercase letter</source>
        <target state="translated">Aktywne identyfikatory przypadku wzorca muszą się rozpoczynać od wielkiej litery</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseContainsPipe">
        <source>The '|' character is not permitted in active pattern case identifiers</source>
        <target state="translated">Znak „|” nie jest dozwolony w identyfikatorach przypadku aktywnego wzorca</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalDenominatorForMeasureExponent">
        <source>Denominator must not be 0 in unit-of-measure exponent</source>
        <target state="translated">Mianownik w wykładniku jednostki miary nie może być równy 0</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoEqualShouldFollowNamespace">
        <source>No '=' symbol should follow a 'namespace' declaration</source>
        <target state="translated">Symbol „=” nie może następować po deklaracji „namespace”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleStructEndDeprecated">
        <source>The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">Składnia „module ... = struct .. end” nie jest używana w kodzie języka F#. Rozważ użycie składni „module ... = begin .. end”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleSigEndDeprecated">
        <source>The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">Składnia „module ... : sig .. end” nie jest używana w kodzie języka F#. Rozważ użycie składni „module ... = begin .. end”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticFieldUsedWhenInstanceFieldExpected">
        <source>A static field was used where an instance field is expected</source>
        <target state="translated">Użyto pola statycznego w miejscu, w którym jest oczekiwane pole wystąpienia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodNotAccessible">
        <source>Method '{0}' is not accessible from this code location</source>
        <target state="translated">Nie można uzyskać dostępu do tej metody „{0}” z tej lokalizacji kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplicitMeasureFollowingSlash">
        <source>Implicit product of measures following /</source>
        <target state="translated">Niejawny iloczyn miar poprzedzony znakiem /</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedMeasureAnon">
        <source>Unexpected SynMeasure.Anon</source>
        <target state="translated">Nieoczekiwany element SynMeasure.Anon</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonZeroConstantCannotHaveGenericUnit">
        <source>Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.</source>
        <target state="translated">Stałe inne niż zero nie mogą mieć jednostek ogólnych. W przypadku ogólnej wartości zero użyj formy 0.0&lt;_&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSeqResultsUseYield">
        <source>In sequence expressions, results are generated using 'yield'</source>
        <target state="translated">W wyrażeniach sekwencji wyniki są generowane przy użyciu elementu „yield”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedBigRationalConstant">
        <source>Unexpected big rational constant</source>
        <target state="translated">Nieoczekiwana duża stała wymierna</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForUnitsOfMeasure">
        <source>Units-of-measure are only supported on float, float32, decimal, and integer types.</source>
        <target state="translated">Jednostki miary są obsługiwane tylko w przypadku typów float, float32, decimal i signed integer</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstUint16Array">
        <source>Unexpected Const_uint16array</source>
        <target state="translated">Nieoczekiwana wartość Const_uint16array</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstByteArray">
        <source>Unexpected Const_bytearray</source>
        <target state="translated">Nieoczekiwana wartość Const_bytearray</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterRequiresName">
        <source>A parameter with attributes must also be given a name, e.g. '[&lt;Attribute&gt;] Name : Type'</source>
        <target state="translated">Parametrowi z atrybutami należy również nadać nazwę, np. „[&lt;atrybut&gt;] nazwa : typ”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnValuesCannotHaveNames">
        <source>Return values cannot have names</source>
        <target state="translated">Zwracane wartości nie mogą mieć nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberKindPropertyGetSetNotExpected">
        <source>MemberKind.PropertyGetSet only expected in parse trees</source>
        <target state="translated">Element MemberKind.PropertyGetSet jest oczekiwany tylko w drzewach analizy</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainValues">
        <source>Namespaces cannot contain values. Consider using a module to hold your value declarations.</source>
        <target state="translated">Przestrzenie nazw nie mogą zawierać wartości. Rozważ użycie modułu zawierającego deklaracje wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainExtensionMembers">
        <source>Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.</source>
        <target state="translated">Przestrzenie nazw nie mogą zawierać elementów członkowskich rozszerzeń, z wyjątkiem grupy deklaracji pliku i przestrzeni nazw, w których zdefiniowano dany typ. Rozważ użycie modułu zawierającego deklaracje elementów członkowskich rozszerzeń.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributes">
        <source>Multiple visibility attributes have been specified for this identifier</source>
        <target state="translated">Określono wiele atrybutów widoczności dla tego identyfikatora</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributesWithLet">
        <source>Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions.</source>
        <target state="translated">Określono wiele atrybutów widoczności dla tego identyfikatora. Powiązania „let” w klasach są zawsze prywatne, tak jak powiązania „let” w wyrażeniach.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForRelationalOperator">
        <source>The name '({0})' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">Nazwa „({0})” nie powinna być używana jako nazwa elementu członkowskiego. Aby zdefiniować semantykę porównania dla typu, zaimplementuj interfejs „System.IComparable”. W przypadku definiowania statycznego elementu członkowskiego do użycia z innych języków infrastruktury CLI użyj nazwy „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForEquality">
        <source>The name '({0})' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">Nazwa „({0})” nie powinna być używana jako nazwa elementu członkowskiego. Aby zdefiniować semantykę równości dla typu, przesłoń element członkowski „Object.Equals”. W przypadku definiowania statycznego elementu członkowskiego do użycia z innych języków infrastruktury CLI użyj nazwy „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberName">
        <source>The name '({0})' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">Nazwa „({0})” nie powinna być używana jako nazwa elementu członkowskiego. W przypadku definiowania statycznego elementu członkowskiego do użycia z innych języków CLI użyj nazwy „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameFixedTypes">
        <source>The name '({0})' should not be used as a member name because it is given a standard definition in the F# library over fixed types</source>
        <target state="translated">Nazwa „({0})” nie powinna być używana jako nazwa elementu członkowskiego, ponieważ ma standardową definicję w bibliotece języka F# dla typów stałych</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionRelational">
        <source>The '{0}' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type.</source>
        <target state="translated">Zwykle nie należy ponownie definiować operatora „{0}”. Aby zdefiniować semantykę porównania z przeciążeniem dla określonego typu, zaimplementuj interfejs „System.IComparable” w definicji tego typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionEquality">
        <source>The '{0}' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type.</source>
        <target state="translated">Zwykle nie należy ponownie definiować operatora „{0}”. Aby zdefiniować semantykę równości dla typu, przesłoń element członkowski „Object.Equals” w definicji tego typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinition">
        <source>The '{0}' operator should not normally be redefined. Consider using a different operator name</source>
        <target state="translated">Zwykle nie należy ponownie definiować operatora „{0}”. Rozważ użycie innej nazwy operatora</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexOperatorDefinition">
        <source>The '{0}' operator cannot be redefined. Consider using a different operator name</source>
        <target state="translated">Nie można ponownie zdefiniować operatora „{0}”. Rozważ użycie innej nazwy operatora</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectModuleOrNamespaceParent">
        <source>Expected module or namespace parent {0}</source>
        <target state="translated">Oczekiwano elementu nadrzędnego modułu lub przestrzeni nazw {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” zawiera jawną implementację interfejsu „System.IComparable”. Musisz zastosować atrybut „CustomComparison” do typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsGenericIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable&lt;_&gt;' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” zawiera jawną implementację interfejsu „System.IComparable&lt;_&gt;”. Musisz zastosować atrybut „CustomComparison” do typu i określić spójną implementację nieogólnego interfejsu System.IComparable.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” zawiera jawną implementację interfejsu „System.IStructuralComparable”. Zastosuj atrybut „CustomComparison” do typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordFieldInconsistentTypes">
        <source>This record contains fields from inconsistent types</source>
        <target state="translated">Ten rekord zawiera pola niespójnych typów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportStubsCannotBeInlined">
        <source>DLLImport stubs cannot be inlined</source>
        <target state="translated">Klasy zastępcze DLLImport nie mogą być śródwierszowe</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCanOnlyBindThisAtMemberDeclaration">
        <source>Structs may only bind a 'this' parameter at member declarations</source>
        <target state="translated">Struktury mogą tylko tworzyć powiązanie parametru „this” w deklaracjach elementów członkowskich</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedExprAtRecInfPoint">
        <source>Unexpected expression at recursive inference point</source>
        <target state="translated">Nieoczekiwane wyrażenie w punkcie wnioskowania cyklicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLessGenericBecauseOfAnnotation">
        <source>This code is less generic than required by its annotations because the explicit type variable '{0}' could not be generalized. It was constrained to be '{1}'.</source>
        <target state="translated">Ten kod jest mniej ogólny niż jest to wymagane przez jego adnotacje, ponieważ nie można uogólnić jawnej zmiennej typu „{0}”. Została ona ograniczona do postaci „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstrainedTypeVariableCannotBeGeneralized">
        <source>One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types</source>
        <target state="translated">Nie można uogólnić co najmniej jednej zmiennej jawnej klasy lub typu funkcji dla tego powiązania, ponieważ są one ograniczone do innych typów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericParameterHasBeenConstrained">
        <source>A generic type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Parametr typu ogólnego został użyty w sposób ograniczający go tak, aby zawsze miał postać „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterHasBeenConstrained">
        <source>This type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Ten parametr typu został użyty w sposób ograniczający go tak, aby zawsze miał postać „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParametersInferredAreNotStable">
        <source>The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</source>
        <target state="translated">Parametry typu wywnioskowane dla tej wartości nie są stabilne po wymazaniu skrótów typu. Jest to spowodowane przez użycie skrótów typu, które porzucają parametry typu lub zmieniają ich kolejność, na przykład \n\ttype taggedInt&lt;'a&gt; = int lub\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nRozważ jawne zadeklarowanie parametrów typu dla tej wartości, na przykład\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeParameterInvalid">
        <source>Explicit type parameters may only be used on module or member bindings</source>
        <target state="translated">Jawne parametry typu mogą być używane tylko w powiązaniach modułów lub elementów członkowskich</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridingMethodRequiresAllOrNoTypeParameters">
        <source>You must explicitly declare either all or no type parameters when overriding a generic abstract method</source>
        <target state="translated">W przypadku przesłaniania ogólnej metody abstrakcyjnej musisz jawnie zadeklarować wszystkie parametry typu lub brak parametrów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldsDoNotDetermineUniqueRecordType">
        <source>The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type</source>
        <target state="translated">Etykiety pól i oczekiwany typ tego wyrażenia rekordu lub wzorca nie określają jednoznacznie odpowiedniego typu rekordu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldAppearsTwiceInRecord">
        <source>The field '{0}' appears twice in this record expression or pattern</source>
        <target state="translated">Pole „{0}” występuje dwa razy w tym wyrażeniu rekordu lub wzorcu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnknownUnion">
        <source>Unknown union case</source>
        <target state="translated">Nieznany przypadek unii</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotSufficientlyGenericBecauseOfScope">
        <source>This code is not sufficiently generic. The type variable {0} could not be generalized because it would escape its scope.</source>
        <target state="translated">Ten kod nie jest wystarczająco ogólny. Nie można uogólnić zmiennej typu {0}, ponieważ wykroczy ona poza swój zakres.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyRequiresExplicitTypeParameters">
        <source>A property cannot have explicit type parameters. Consider using a method instead.</source>
        <target state="translated">Właściwość nie może zawierać jawnych parametrów typu. Zamiast tego rozważ użycie metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorCannotHaveTypeParameters">
        <source>A constructor cannot have explicit type parameters. Consider using a static construction method instead.</source>
        <target state="translated">Konstruktor nie może zawierać jawnych parametrów typu. Zamiast tego rozważ użycie statycznej metody konstrukcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInstanceMemberRequiresTarget">
        <source>This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'.</source>
        <target state="translated">Ten element członkowski wystąpienia wymaga parametru, aby mógł reprezentować wywoływany obiekt. Ustaw element członkowski jako element statyczny lub użyj notacji „member x.Member(args) = ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertyInSyntaxTree">
        <source>Unexpected source-level property specification in syntax tree</source>
        <target state="translated">Nieoczekiwana specyfikacja właściwości poziomu źródła w drzewie składni</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializerRequiresArgument">
        <source>A static initializer requires an argument</source>
        <target state="translated">Inicjator statyczny wymaga argumentu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorRequiresArgument">
        <source>An object constructor requires an argument</source>
        <target state="translated">Konstruktor obiektów wymaga argumentu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticMemberShouldNotHaveThis">
        <source>This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'.</source>
        <target state="translated">Ten statyczny element członkowski nie powinien mieć parametru „this”. Rozważ użycie notacji „member ElementCzłonkowski(argumenty) = ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitStaticInitializerSyntax">
        <source>An explicit static initializer should use the syntax 'static new(args) = expr'</source>
        <target state="translated">Jawny inicjator statyczny powinien używać składni „static new(args) = expr”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitObjectConstructorSyntax">
        <source>An explicit object constructor should use the syntax 'new(args) = expr'</source>
        <target state="translated">Jawny konstruktor obiektów powinien używać składni „new(args) = expr”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertySpec">
        <source>Unexpected source-level property specification</source>
        <target state="translated">Nieoczekiwana specyfikacja właściwości poziomu źródła</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionFormDeprecated">
        <source>This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions.</source>
        <target state="translated">Ta postać wyrażenia obiektu nie jest używana w języku F#. Aby zdefiniować implementacje elementów członkowskich w wyrażeniach obiektów, użyj konstrukcji „member this.MemberName ... = ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDeclaration">
        <source>Invalid declaration</source>
        <target state="translated">Nieprawidłowa deklaracja</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesInvalidInPatterns">
        <source>Attributes are not allowed within patterns</source>
        <target state="translated">Atrybuty nie są dozwolone we wzorcach</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitTypeArguments">
        <source>The generic function '{0}' must be given explicit type argument(s)</source>
        <target state="translated">Ogólna funkcja „{0}” musi mieć jawne argumenty typów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoesNotAllowExplicitTypeArguments">
        <source>The method or function '{0}' should not be given explicit type argument(s) because it does not declare its type parameters explicitly</source>
        <target state="translated">Dla metody lub funkcji „{0}” nie powinny być podawane jawne argumenty typu, ponieważ nie deklaruje ona jawnie swoich parametrów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterArityMismatch">
        <source>This value, type or method expects {0} type parameter(s) but was given {1}</source>
        <target state="translated">Ta wartość, ten typ lub ta metoda oczekuje następującej liczby parametrów typów: {0}. Podana liczba parametrów: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultStructConstructorCall">
        <source>The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization</source>
        <target state="translated">Domyślny konstruktor typu struktury inicjujący wartość zero może być używany tylko wtedy, gdy wszystkie pola typu struktury akceptują domyślną inicjalizację</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindIDisposable">
        <source>Couldn't find Dispose on IDisposable, or it was overloaded</source>
        <target state="translated">Nie można odnaleźć elementu Dispose w interfejsie IDisposable lub jest on przeciążony</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonLiteralCannotBeUsedInPattern">
        <source>This value is not a literal and cannot be used in a pattern</source>
        <target state="translated">Ta wartość nie jest literałem i nie można jej użyć we wzorcu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsReadonly">
        <source>This field is readonly</source>
        <target state="translated">To pole jest tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameArgumentsMustAppearLast">
        <source>Named arguments must appear after all other arguments</source>
        <target state="translated">Nazwane argumenty muszą występować po wszystkich pozostałych argumentach</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitLambda">
        <source>This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking {0} arguments.</source>
        <target state="translated">Ta wartość funkcji jest używana do utworzenia typu delegata, którego sygnatura zawiera argument byref. Musisz użyć jawnego wyrażenia lambda pobierającego następującą liczbę argumentów: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCannotBeEnumerated">
        <source>The type '{0}' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method</source>
        <target state="translated">Typ „{0}” nie jest typem, którego wartości mogą być wyliczane przy użyciu tej składni. Oznacza to, że nie jest on zgodny z elementem seq&lt;_&gt;, IEnumerable&lt;_&gt; ani IEnumerable i nie ma metody GetEnumerator</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMixtureOfRecursiveForms">
        <source>This recursive binding uses an invalid mixture of recursive forms</source>
        <target state="translated">Powiązanie cykliczne używa nieprawidłowej kombinacji form cyklicznych</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectConstructionExpression">
        <source>This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.</source>
        <target state="translated">To nie jest prawidłowe wyrażenie konstrukcji obiektu. Jawne konstruktory obiektów muszą wywoływać konstruktora alternatywnego lub inicjować wszystkie pola obiektu i określić wywołanie konstruktora superklasy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraint">
        <source>Invalid constraint</source>
        <target state="translated">Nieprawidłowe ograniczenie</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraintTypeSealed">
        <source>Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution</source>
        <target state="translated">Nieprawidłowe ograniczenie: typ użyty dla ograniczenia jest zapieczętowany, co oznacza, że ograniczenie może spełnić maksymalnie jedno rozwiązanie</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumConstraint">
        <source>An 'enum' constraint must be of the form 'enum&lt;type&gt;'</source>
        <target state="translated">Ograniczenie „enum” musi mieć postać „enum&lt;typ&gt;”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNewConstraint">
        <source>'new' constraints must take one argument of type 'unit' and return the constructed type</source>
        <target state="translated">Ograniczenia „new” muszą pobierać jeden argument typu „unit” i zwracać utworzony typ</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPropertyType">
        <source>This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -&gt; ty3'. Properties returning functions should have types of the form '(ty1 -&gt; ty2)'.</source>
        <target state="translated">Ta właściwość ma nieprawidłowy typ. Właściwości z wieloma argumentami indeksatora powinny mieć typy w postaci „ty1 * ty2 -&gt; ty3”. Właściwości zwracające funkcje powinny mieć typy w postaci „(ty1 -&gt; ty2)”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureMarkWithAttribute">
        <source>Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.</source>
        <target state="translated">Oczekiwano parametru jednostki miary, a nie parametru typu. Jawne parametry jednostki miary muszą być oznaczone atrybutem [&lt;Measure&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeParameter">
        <source>Expected type parameter, not unit-of-measure parameter</source>
        <target state="translated">Oczekiwano parametru typu, a nie parametru jednostki miary</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeNotUnitOfMeasure">
        <source>Expected type, not unit-of-measure</source>
        <target state="translated">Oczekiwano typu, a nie jednostki miary</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureNotType">
        <source>Expected unit-of-measure, not type</source>
        <target state="translated">Oczekiwano jednostki miary, a nie typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUnitsOfMeasurePrefix">
        <source>Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.</source>
        <target state="translated">Jednostki miary nie mogą być używane jako argumenty prefiksu typu. Zapisz je ponownie jako argumenty postfiksowe w nawiasach ostrych.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnitsOfMeasureInvalidInTypeConstructor">
        <source>Unit-of-measure cannot be used in type constructor application</source>
        <target state="translated">Jednostka miary nie może być używana w aplikacji konstruktora typów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireBuilderMethod">
        <source>This control construct may only be used if the computation expression builder defines a '{0}' method</source>
        <target state="translated">Ta konstrukcja kontrolna może być używana tylko wtedy, gdy konstruktor wyrażeń obliczeń definiuje metodę „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoNestedTypes">
        <source>This type has no nested types</source>
        <target state="translated">Ten typ nie ma typów zagnieżdżonych</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSymbolInTypeExpression">
        <source>Unexpected {0} in type expression</source>
        <target state="translated">Nieoczekiwany symbol {0} w wyrażeniu typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterInvalidAsTypeConstructor">
        <source>Type parameter cannot be used as type constructor</source>
        <target state="translated">Nie można użyć parametru typu jako konstruktora typów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalSyntaxInTypeExpression">
        <source>Illegal syntax in type expression</source>
        <target state="translated">Niedozwolona składnia w wyrażeniu typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousUnitsOfMeasureCannotBeNested">
        <source>Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression</source>
        <target state="translated">Anonimowa jednostka miary nie może być zagnieżdżona w innym wyrażeniu jednostki miary</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousTypeInvalidInDeclaration">
        <source>Anonymous type variables are not permitted in this declaration</source>
        <target state="translated">Zmienne typów anonimowych nie są dozwolone w tej deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSlashInType">
        <source>Unexpected / in type</source>
        <target state="translated">Nieoczekiwany znak / w typie</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedTypeArguments">
        <source>Unexpected type arguments</source>
        <target state="translated">Nieoczekiwane argumenty typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsOnlyOnMembers">
        <source>Optional arguments are only permitted on type members</source>
        <target state="translated">Argumenty opcjonalne są dozwolone tylko w przypadku elementów członkowskich typów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameNotBoundInPattern">
        <source>Name '{0}' not bound in pattern context</source>
        <target state="translated">Nazwa „{0}” nie jest powiązana w kontekście wzorca</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNonPrimitiveLiteralInPatternMatch">
        <source>Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when &lt;variable&gt; = &lt;constant&gt;' at the end of the match clause.</source>
        <target state="translated">Niepierwotne stałe literałów liczbowych nie mogą być używane w dopasowaniach wzorców, ponieważ mogą być mapowane na wiele różnych typów przez użycie modułu NumericLiteral. Zamiast tego rozważ użycie zmiennej i użyj konstrukcji „when &lt;zmienna&gt; = &lt;stała&gt;” na końcu klauzuli dopasowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentUsage">
        <source>Type arguments cannot be specified here</source>
        <target state="translated">Nie można tutaj określać argumentów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireActivePatternWithOneResult">
        <source>Only active patterns returning exactly one result may accept arguments</source>
        <target state="translated">Tylko aktywne wzorce zwracające dokładnie jeden wynik mogą akceptować argumenty</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidArgForParameterizedPattern">
        <source>Invalid argument to parameterized pattern label</source>
        <target state="translated">Nieprawidłowy argument etykiety wzorca z parametrami</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexIntoActivePatternArray">
        <source>Internal error. Invalid index into active pattern array</source>
        <target state="translated">Błąd wewnętrzny. Nieprawidłowy indeks w tablicy aktywnego wzorca</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseDoesNotTakeArguments">
        <source>This union case does not take arguments</source>
        <target state="translated">Ten przypadek unii nie akceptuje argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseRequiresOneArgument">
        <source>This union case takes one argument</source>
        <target state="translated">Ten przypadek unii akceptuje jeden argument</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseExpectsTupledArguments">
        <source>This union case expects {0} arguments in tupled form</source>
        <target state="translated">Ten przypadek unii oczekuje {0} argumentów w postaci spójnej kolekcji</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotStatic">
        <source>Field '{0}' is not static</source>
        <target state="translated">Pole „{0}” nie jest statyczne</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNotLiteralCannotBeUsedInPattern">
        <source>This field is not a literal and cannot be used in a pattern</source>
        <target state="translated">To pole nie jest literałem i nie można go użyć we wzorcu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireVarConstRecogOrLiteral">
        <source>This is not a variable, constant, active recognizer or literal</source>
        <target state="translated">To nie jest zmienna, stała, aktywny aparat rozpoznawania ani literał</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPattern">
        <source>This is not a valid pattern</source>
        <target state="translated">To nie jest prawidłowy wzorzec</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseWhenPatternGuard">
        <source>Character range matches have been removed in F#. Consider using a 'when' pattern guard instead.</source>
        <target state="translated">Dopasowania zakresu znaków zostały usunięte w języku F#. Zamiast tego rozważ użycie ograniczenia wzorca „when”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalPattern">
        <source>Illegal pattern</source>
        <target state="translated">Niedozwolony wzorzec</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxErrorUnexpectedQMark">
        <source>Syntax error - unexpected '?' symbol</source>
        <target state="translated">Błąd składni — nieoczekiwany symbol „?”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionCountMisMatch">
        <source>Expected {0} expressions, got {1}</source>
        <target state="translated">Oczekiwano wyrażeń w liczbie {0}; otrzymano: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExprUndelayed">
        <source>TcExprUndelayed: delayed</source>
        <target state="translated">TcExprUndelayed: opóźnione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionRequiresSequence">
        <source>This expression form may only be used in sequence and computation expressions</source>
        <target state="translated">Ta postać wyrażenia może być używana tylko w wyrażeniach sekwencji i obliczeń</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectExpressionSyntaxForm">
        <source>Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.</source>
        <target state="translated">Nieprawidłowe wyrażenie obiektu. Obiekty bez przesłonięć lub interfejsy powinny używać wyrażenia w postaci „new Typ(argumenty)” bez nawiasów.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectSequenceOrRecordExpression">
        <source>Invalid object, sequence or record expression</source>
        <target state="translated">Nieprawidłowe wyrażenie obiektu, sekwencji lub rekordu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSequenceExpressionSyntaxForm">
        <source>Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq {{ ... }}'</source>
        <target state="translated">Nieprawidłowe wyrażenie rekordu, sekwencji lub obliczenia. Wyrażenia sekwencji powinny mieć postać „seq {{ ... }}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionWithIfRequiresParenthesis">
        <source>This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression</source>
        <target state="translated">To wyrażenie listy lub tablicy zawiera element „if ... then ... else”. Ujmij to wyrażenie w nawiasy, aby określić, że jest to pojedynczy element listy lub tablicy, w celu odróżnienia go od listy wygenerowanej przy użyciu wyrażenia sekwencji</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseFormatString">
        <source>Unable to parse format string '{0}'</source>
        <target state="translated">Nie można przeanalizować ciągu formatu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcListLiteralMaxSize">
        <source>This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.</source>
        <target state="translated">To wyrażenie listy przekracza maksymalny rozmiar literałów list. W przypadku większych literałów użyj tablicy i wywołaj element Array.ToList.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresObjectConstructor">
        <source>The expression form 'expr then expr' may only be used as part of an explicit object constructor</source>
        <target state="translated">Wyrażenie w postaci „wyrażenie then wyrażenie” może być używane tylko jako część jawnego konstruktora obiektów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentsCannotBeUsedInMemberTraits">
        <source>Named arguments cannot be given to member trait calls</source>
        <target state="translated">Nazwane argumenty nie mogą być określane dla wywołań cech elementów członkowskich</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotValidEnumCaseName">
        <source>This is not a valid name for an enumeration case</source>
        <target state="translated">To nie jest prawidłowa nazwa przypadku wyliczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotMutable">
        <source>This field is not mutable</source>
        <target state="translated">Nie można modyfikować tego pola</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresListArrayOrSequence">
        <source>This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq {{ ... }}', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements</source>
        <target state="translated">Ta konstrukcja może być używana tylko w wyrażeniach list, tablic i sekwencji, na przykład w wyrażeniach „seq {{ ... }}”, „[ ... ]” lub „[| ... |]”. Generują one elementy za pomocą składni „for ... in ... do ... yield...”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpressions">
        <source>This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'.</source>
        <target state="translated">Ta konstrukcja może być używana tylko w wyrażeniach obliczeń. Aby zwrócić wartość ze zwykłej funkcji, wpisz wyrażenie bez wyrazu „return”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresSequenceOrComputations">
        <source>This construct may only be used within sequence or computation expressions</source>
        <target state="translated">Ta konstrukcja może być używana tylko w wyrażeniach sekwencji lub obliczeń</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpression">
        <source>This construct may only be used within computation expressions</source>
        <target state="translated">Ta konstrukcja może być używana tylko w wyrażeniach obliczeń</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexerExpression">
        <source>Invalid indexer expression</source>
        <target state="translated">Nieprawidłowe wyrażenie indeksatora</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
        <source>The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints</source>
        <target state="translated">Operator „wyrażenie.[indeks]” został użyty w obiekcie nieokreślonego typu na podstawie informacji przed tym punktem programu. Rozważ dodanie kolejnych ograniczeń typów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromVariableType">
        <source>Cannot inherit from a variable type</source>
        <target state="translated">Nie można dziedziczyć po typie zmiennej</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsOnTypeParametersCannotTakeArguments">
        <source>Calls to object constructors on type parameters cannot be given arguments</source>
        <target state="translated">Wywołania konstruktorów obiektów w parametrach typu nie mogą mieć argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCompiledNameAttributeMisused">
        <source>The 'CompiledName' attribute cannot be used with this language element</source>
        <target state="translated">Nie można użyć atrybutu „CompiledName” z tym elementem języka</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedTypeRequired">
        <source>'{0}' may only be used with named types</source>
        <target state="translated">Element „{0}” może być używany tylko z nazwanymi typami</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritCannotBeUsedOnInterfaceType">
        <source>'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead.</source>
        <target state="translated">Deklaracja „inherit” nie może być używana w typach interfejsu. Zamiast tego rozważ zaimplementowanie interfejsu za pomocą konstrukcji „interface ... with ... end”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewCannotBeUsedOnInterfaceType">
        <source>'new' cannot be used on interface types. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">Element „new” nie może być używany w typach interfejsów. Zamiast tego rozważ użycie wyrażenia obiektu „{{ new ... with ... }}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractTypeCannotBeInstantiated">
        <source>Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">Nie można utworzyć wystąpień tego typu, ponieważ został on oznaczony jako abstrakcyjny lub nie wszystkie metody mają implementacje. Zamiast tego rozważ użycie wyrażenia obiektu „{{ new ... with ... }}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIDisposableTypeShouldUseNew">
        <source>It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value</source>
        <target state="translated">Zaleca się, aby obiekty obsługujące interfejs IDisposable były tworzone przy użyciu składni „new Type(args)”, a nie „Type(args)” lub „Type” jako wartości funkcji reprezentującej konstruktor, w celu określenia, że zasoby mogą należeć do wygenerowanej wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxCanOnlyBeUsedToCreateObjectTypes">
        <source>'{0}' may only be used to construct object types</source>
        <target state="translated">Składnia „{0}” może być używana tylko w celu tworzenia typów obiektów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresCall">
        <source>Constructors for the type '{0}' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.</source>
        <target state="translated">Konstruktory typu „{0}” muszą bezpośrednio lub pośrednio wywoływać swojego niejawnego konstruktora obiektów. Użyj wywołania niejawnego konstruktora obiektów zamiast wyrażenia rekordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUndefinedField">
        <source>The field '{0}' has been given a value, but is not present in the type '{1}'</source>
        <target state="translated">Pole „{0}” ma określoną wartość, ale nie występuje w typie „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresAssignment">
        <source>No assignment given for field '{0}' of type '{1}'</source>
        <target state="translated">Brak przypisania dla pola „{0}” typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExtraneousFieldsGivenValues">
        <source>Extraneous fields have been given values</source>
        <target state="translated">Określono wartości dodatkowych pól</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
        <source>Only overrides of abstract and virtual members may be specified in object expressions</source>
        <target state="translated">W wyrażeniach obiektów można określić tylko przesłonięcia abstrakcyjnych i wirtualnych elementów członkowskich</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoAbstractOrVirtualMemberFound">
        <source>The member '{0}' does not correspond to any abstract or virtual method available to override or implement.</source>
        <target state="translated">Element członkowski „{0}” nie odpowiada żadnej metodzie abstrakcyjnej ani wirtualnej dostępnej do przesłonięcia lub zaimplementowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberFoundIsNotAbstractOrVirtual">
        <source>The type {0} contains the member '{1}' but it is not a virtual or abstract method that is available to override or implement.</source>
        <target state="translated">Typ {0} zawiera element członkowski „{1}”, ale nie jest metodą wirtualną lub abstrakcyjną, która jest dostępna do przesłonięcia lub zaimplementowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatch">
        <source>The member '{0}' does not accept the correct number of arguments. {1} argument(s) are expected, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">Element członkowski „{0}” nie akceptuje poprawnej liczby argumentów. Oczekiwana liczba argumentów: {1}, podano argumentów: {2}. Wymagany podpis to „{3}”.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatchOneOverload">
        <source>The member '{0}' does not accept the correct number of arguments. One overload accepts {1} arguments, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">Element członkowski „{0}” nie akceptuje poprawnej liczby argumentów. Jedno przeciążenie akceptuje następującą liczbę argumentów: {1}, podano argumentów: {2}. Wymagany podpis to „{3}”.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSimpleMethodNameRequired">
        <source>A simple method name is required here</source>
        <target state="translated">W tym miejscu jest wymagana prosta nazwa metody</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPredefinedTypeCannotBeUsedAsSuperType">
        <source>The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class</source>
        <target state="translated">Typy System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate i System.Array nie mogą być używane jako supertypy w wyrażeniu obiektu lub klasie.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMustBeUsedWithNamedType">
        <source>'new' must be used with a named type</source>
        <target state="translated">Element „new” musi być używany z nazwanym typem</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCreateExtensionOfSealedType">
        <source>Cannot create an extension of a sealed type</source>
        <target state="translated">Nie można utworzyć rozszerzenia zapieczętowanego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoArgumentsForRecordValue">
        <source>No arguments may be given when constructing a record value</source>
        <target state="translated">Podczas tworzenia wartości rekordu nie można określić żadnych argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoInterfaceImplementationForConstructionExpression">
        <source>Interface implementations cannot be given on construction expressions</source>
        <target state="translated">Implementacje interfejsów nie mogą być określane w wyrażeniach konstrukcji</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionCanOnlyBeUsedInClassTypes">
        <source>Object construction expressions may only be used to implement constructors in class types</source>
        <target state="translated">Wyrażenia konstrukcji obiektów mogą być używane tylko do implementowania konstruktorów w typach klas</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
        <source>Only simple bindings of the form 'id = expr' can be used in construction expressions</source>
        <target state="translated">W wyrażeniach konstrukcji mogą być używane tylko proste powiązania w postaci „identyfikator = wyrażenie”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectsMustBeInitializedWithObjectExpression">
        <source>Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field</source>
        <target state="translated">Obiekty muszą być inicjowane przez wyrażenie konstrukcji obiektu, które wywołuje dziedziczonego konstruktora obiektów i przypisuje wartość do każdego pola</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedInterfaceType">
        <source>Expected an interface type</source>
        <target state="translated">Oczekiwano typu interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorForInterfacesDoNotTakeArguments">
        <source>Constructor expressions for interfaces do not take arguments</source>
        <target state="translated">Wyrażenia konstruktora interfejsów nie akceptują argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresArguments">
        <source>This object constructor requires arguments</source>
        <target state="translated">Ten konstruktor obiektów wymaga argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewRequiresObjectConstructor">
        <source>'new' may only be used with object constructors</source>
        <target state="translated">Element „new” może być używany tylko z konstruktorami obiektów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAtLeastOneOverrideIsInvalid">
        <source>At least one override did not correctly implement its corresponding abstract member</source>
        <target state="translated">Co najmniej jedno przesłonięcie nie zawiera poprawnej implementacji odpowiadającego mu abstrakcyjnego elementu członkowskiego</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNumericLiteralRequiresModule">
        <source>This numeric literal requires that a module '{0}' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope</source>
        <target state="translated">Ten literał liczbowy wymaga, aby moduł „{0}” definiujący funkcje FromZero, FromOne, FromInt32, FromInt64 i FromString mieścił się w zakresie</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRecordConstruction">
        <source>Invalid record construction</source>
        <target state="translated">Nieprawidłowa konstrukcja rekordu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresRecordTypes">
        <source>The expression form {{ expr with ... }} may only be used with record types. To build object types use {{ new Type(...) with ... }}</source>
        <target state="translated">Wyrażenie w postaci {{ wyrażenie with ... }} może być używane tylko z typami rekordów. Aby utworzyć typy obiektów, użyj wyrażenia {{ new Typ(...) with ... }}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritedTypeIsNotObjectModelType">
        <source>The inherited type is not an object model type</source>
        <target state="translated">Dziedziczony typ nie jest typem modelu obiektów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
        <source>Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors</source>
        <target state="translated">Wyrażenia konstrukcji obiektów (czyli wyrażenia rekordów ze specyfikacjami dziedziczenia) mogą być używane w celu implementowania konstruktorów w typach modeli obiektów. Aby utworzyć wystąpienia typów modeli obiektów poza konstruktorami, użyj wyrażenia „new ObjectType(args)”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyRecordInvalid">
        <source>'{{ }}' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.</source>
        <target state="translated">„{{ }}” nie jest prawidłowym wyrażeniem. Rekordy muszą zawierać co najmniej jedno pole. Puste sekwencje są określane przy użyciu elementu Seq.empty lub pustej listy „[]”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordTypeNeedConstructor">
        <source>This type is not a record type. Values of class and struct types must be created using calls to object constructors.</source>
        <target state="translated">Ten typ nie jest typem rekordu. Wartości typów klas i struktur muszą zostać utworzone przy użyciu wywołań konstruktorów obiektów.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordType">
        <source>This type is not a record type</source>
        <target state="translated">Ten typ nie jest typem rekordu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInComputationExpression">
        <source>This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder {{ ... }}'.</source>
        <target state="translated">Ta konstrukcja jest niejednoznaczna jako część wyrażenia obliczenia. Zagnieżdżone wyrażenia mogą zawierać ciąg „let _ = (...)”, a zagnieżdżone obliczenia mogą zawierać ciąg „let! wynik = konstruktor {{ ... }}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInSequenceExpression">
        <source>This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {{... }}'.</source>
        <target state="translated">Ta konstrukcja jest niejednoznaczna jako część wyrażenia sekwencji. Zagnieżdżone wyrażenia mogą zawierać ciąg „let _ = (...)”, a zagnieżdżone sekwencje mogą zawierać ciąg „yield! seq {{... }}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoBangIllegalInSequenceExpression">
        <source>'do!' cannot be used within sequence expressions</source>
        <target state="translated">Wyrażenie „do!” nie może być używane w wyrażeniach sekwencji</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseForInSequenceExpression">
        <source>The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead.</source>
        <target state="translated">Używanie ciągu „let! x = coll” w wyrażeniach sekwencji jest niedozwolone. Zamiast tego użyj ciągu „for x in coll”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryIllegalInSequenceExpression">
        <source>'try'/'with' cannot be used within sequence expressions</source>
        <target state="translated">Wyrażenia „try”/„with” nie mogą być używane w wyrażeniach sekwencji</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseYieldBangForMultipleResults">
        <source>In sequence expressions, multiple results are generated using 'yield!'</source>
        <target state="translated">W wyrażeniach sekwencji wiele wyników jest generowanych przy użyciu elementu „yield!”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAssignment">
        <source>Invalid assignment</source>
        <target state="translated">Nieprawidłowe przypisanie</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfTypeName">
        <source>Invalid use of a type name</source>
        <target state="translated">Nieprawidłowe użycie nazwy typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoAccessibleConstructor">
        <source>This type has no accessible object constructors</source>
        <target state="translated">Ten typ nie ma dostępnych konstruktorów obiektów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfInterfaceType">
        <source>Invalid use of an interface type</source>
        <target state="translated">Nieprawidłowe użycie typu interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfDelegate">
        <source>Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'.</source>
        <target state="translated">Nieprawidłowe użycie konstruktora delegatów. Użyj składni „new Typ(argumenty)” lub „Typ(argumenty)”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotStatic">
        <source>Property '{0}' is not static</source>
        <target state="translated">Właściwość „{0}” nie jest statyczna</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotReadable">
        <source>Property '{0}' is not readable</source>
        <target state="translated">Nie można odczytać właściwości „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLookupMayNotBeUsedHere">
        <source>This lookup cannot be used here</source>
        <target state="translated">Nie można tutaj użyć tego odnośnika</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsStatic">
        <source>Property '{0}' is static</source>
        <target state="translated">Właściwość „{0}” jest statyczna</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet1">
        <source>Property '{0}' cannot be set</source>
        <target state="translated">Nie można ustawić właściwości „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsCannotBeFirstClassValues">
        <source>Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</source>
        <target state="translated">Konstruktory muszą być stosowane do argumentów i nie mogą być używane jako wartości pierwszej klasy. Jeśli to konieczne, użyj funkcji anonimowej „(fun argument1 ... argumentN -&gt; new Type(argument1,...,argumentN))”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
        <source>The syntax 'expr.id' may only be used with record labels, properties and fields</source>
        <target state="translated">Składnia „wyrażenie.identyfikator” może być używana tylko z etykietami rekordów, właściwościami i polami</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsStatic">
        <source>Event '{0}' is static</source>
        <target state="translated">Zdarzenie „{0}” jest statyczne</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsNotStatic">
        <source>Event '{0}' is not static</source>
        <target state="translated">Zdarzenie „{0}” nie jest statyczne</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentDidNotMatch">
        <source>The named argument '{0}' did not match any argument or mutable property</source>
        <target state="translated">Nazwany argument „{0}” nie jest zgodny z żadnym argumentem ani z żadną właściwością modyfikowalną</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverloadsCannotHaveCurriedArguments">
        <source>One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.</source>
        <target state="translated">Co najmniej jedno przeciążenie tej metody ma argumenty curried. Rozważ zmodyfikowanie tych elementów członkowskich tak, aby akceptowały argumenty w postaci spójnej kolekcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnnamedArgumentsDoNotFormPrefix">
        <source>The unnamed arguments do not form a prefix of the arguments of the method called</source>
        <target state="translated">Nienazwane argumenty nie tworzą prefiksu argumentów wywołanej metody</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
        <source>Static optimization conditionals are only for use within the F# library</source>
        <target state="translated">Statyczne wyrażenia warunkowe optymalizacji mogą być używane tylko w bibliotece języka F#</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFormalArgumentIsNotOptional">
        <source>The corresponding formal argument is not optional</source>
        <target state="translated">Odpowiedni argument formalny nie jest opcjonalny</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOptionalAssignmentToPropertyOrField">
        <source>Invalid optional assignment to a property or field</source>
        <target state="translated">Nieprawidłowe opcjonalne przypisanie do właściwości lub pola</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegateConstructorMustBePassed">
        <source>A delegate constructor must be passed a single function value</source>
        <target state="translated">Do konstruktora delegatów musi zostać przekazana jedna wartość funkcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindingCannotBeUseAndRec">
        <source>A binding cannot be marked both 'use' and 'rec'</source>
        <target state="translated">Powiązanie nie może być oznaczone zarówno jako „use”, jak i „rec”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileOnlyOnClassLetBindings">
        <source>The 'VolatileField' attribute may only be used on 'let' bindings in classes</source>
        <target state="translated">Atrybut „VolatileField” może być używany tylko w powiązaniach „let” w klasach</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesAreNotPermittedOnLetBindings">
        <source>Attributes are not permitted on 'let' bindings in expressions</source>
        <target state="translated">Atrybuty nie są dozwolone w powiązaniach „let” w wyrażeniach</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultValueAttributeRequiresVal">
        <source>The 'DefaultValue' attribute may only be used on 'val' declarations</source>
        <target state="translated">Atrybut „DefaultValue” może być używany tylko z deklaracjami „val”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeRequiresMembers">
        <source>The 'ConditionalAttribute' attribute may only be used on members</source>
        <target state="translated">Atrybut „ConditionalAttribute” może być używany tylko z elementami członkowskimi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidActivePatternName">
        <source>This is not a valid name for an active pattern</source>
        <target state="translated">To nie jest prawidłowa nazwa aktywnego wzorca</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEntryPointAttributeRequiresFunctionInModule">
        <source>The 'EntryPointAttribute' attribute may only be used on function definitions in modules</source>
        <target state="translated">Atrybut „EntryPointAttribute” może być używany tylko w definicjach funkcji w modułach</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesCannotBeInline">
        <source>Mutable values cannot be marked 'inline'</source>
        <target state="translated">Wartości modyfikowalne nie mogą być oznaczone jako „inline”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesMayNotHaveGenericParameters">
        <source>Mutable values cannot have generic parameters</source>
        <target state="translated">Wartości modyfikowalne nie mogą mieć parametrów ogólnych</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesSyntax">
        <source>Mutable function values should be written 'let mutable f = (fun args -&gt; ...)'</source>
        <target state="translated">Modyfikowalne wartości funkcji powinny mieć postać „let mutable f = (fun argumenty -&gt; ...)”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyFunctionsCanBeInline">
        <source>Only functions may be marked 'inline'</source>
        <target state="translated">Tylko funkcje mogą być oznaczone jako „inline”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalAttributesForLiteral">
        <source>A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes</source>
        <target state="translated">Wartości literału nie można przypisać atrybutu [&lt;ThreadStatic&gt;] ani [&lt;ContextStatic&gt;]</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeMutable">
        <source>A literal value cannot be marked 'mutable'</source>
        <target state="translated">Wartość literału nie może być oznaczona jako „mutable”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeInline">
        <source>A literal value cannot be marked 'inline'</source>
        <target state="translated">Wartość literału nie może być oznaczona jako „inline”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotHaveGenericParameters">
        <source>Literal values cannot have generic parameters</source>
        <target state="translated">Wartości literałów nie mogą mieć parametrów ogólnych</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstantExpression">
        <source>This is not a valid constant expression</source>
        <target state="translated">To nie jest prawidłowe wyrażenie stałej</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsInaccessible">
        <source>This type is not accessible from this code location</source>
        <target state="translated">Ten typ nie jest dostępny z tej lokalizacji kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConditionInImportedAssembly">
        <source>Unexpected condition in imported assembly: failed to decode AttributeUsage attribute</source>
        <target state="translated">Nieoczekiwany warunek w zaimportowanym zestawie: nie można zdekodować atrybutu AttributeUsage</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedAttributeTarget">
        <source>Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</source>
        <target state="translated">Nierozpoznany element docelowy atrybutu. Prawidłowe elementy docelowe atrybutu: „assembly”, „module”, „type”, „method”, „property”, „return”, „param”, „field”, „event”, „constructor”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElementUseDo">
        <source>This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module.</source>
        <target state="translated">Ten atrybut jest nieprawidłowy do użycia w tym elemencie języka. Atrybuty zestawu powinny być dołączone do deklaracji „do ()” (w module języka F#, jeśli to konieczne).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElement">
        <source>This attribute is not valid for use on this language element</source>
        <target state="translated">Ten atrybut jest nieprawidłowy do użycia w tym elemencie języka</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgumentsCannotBeUsedInCustomAttribute">
        <source>Optional arguments cannot be used in custom attributes</source>
        <target state="translated">Argumenty opcjonalne nie mogą być używane w atrybutach niestandardowych</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet0">
        <source>This property cannot be set</source>
        <target state="translated">Nie można ustawić tej właściwości</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyOrFieldNotFoundInAttribute">
        <source>This property or field was not found on this custom attribute type</source>
        <target state="translated">Nie odnaleziono tej właściwości pola w tym niestandardowym typie atrybutu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustBeReferenceType">
        <source>A custom attribute must be a reference type</source>
        <target state="translated">Atrybut niestandardowy musi mieć typ odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeArgumentMismatch">
        <source>The number of args for a custom attribute does not match the expected number of args for the attribute constructor</source>
        <target state="translated">Liczba argumentów atrybutu niestandardowego nie jest zgodna z oczekiwaną liczbą argumentów konstruktora atrybutów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustInvokeConstructor">
        <source>A custom attribute must invoke an object constructor</source>
        <target state="translated">Atrybut niestandardowy musi wywoływać konstruktora obiektów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeExpressionsMustBeConstructorCalls">
        <source>Attribute expressions must be calls to object constructors</source>
        <target state="translated">Wyrażenia atrybutów muszą być wywołaniami konstruktorów obiektów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedAttribute">
        <source>This attribute cannot be used in this version of F#</source>
        <target state="translated">Ten atrybut nie może być używany w tej wersji języka F#</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidInlineSpecification">
        <source>Invalid inline specification</source>
        <target state="translated">Nieprawidłowa wbudowana specyfikacja</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBinding">
        <source>'use' bindings must be of the form 'use &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">Powiązania „use” muszą mieć postać „use &lt;zmienna&gt; = &lt;wyrażenie&gt;”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractMembersIllegalInAugmentation">
        <source>Abstract members are not permitted in an augmentation - they must be defined as part of the type itself</source>
        <target state="translated">Abstrakcyjne elementy członkowskie nie są dozwolone w rozszerzeniu — muszą być zdefiniowane w ramach samego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodOverridesIllegalHere">
        <source>Method overrides and interface implementations are not permitted here</source>
        <target state="translated">Przesłonięcia metod i implementacje interfejsów nie są tutaj dozwolone</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoMemberFoundForOverride">
        <source>No abstract or interface member was found that corresponds to this override</source>
        <target state="translated">Nie odnaleziono abstrakcyjnych elementów członkowskich lub elementów członkowskich interfejsu odpowiadających temu przesłonięciu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverrideArityMismatch">
        <source>This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:{0}</source>
        <target state="translated">To przesłonięcie pobiera inną liczbę argumentów niż odpowiedni abstrakcyjny element członkowski. Znaleziono następujące abstrakcyjne elementy członkowskie: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationAlreadyExists">
        <source>This method already has a default implementation</source>
        <target state="translated">Ta metoda ma już domyślną implementację</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultAmbiguous">
        <source>The method implemented by this default is ambiguous</source>
        <target state="translated">Metoda zaimplementowana w tym elemencie jest niejednoznaczna</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoPropertyFoundForOverride">
        <source>No abstract property was found that corresponds to this override</source>
        <target state="translated">Nie odnaleziono żadnej właściwości abstrakcyjnej odpowiadającej temu przesłonięciu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractPropertyMissingGetOrSet">
        <source>This property overrides or implements an abstract property but the abstract property doesn't have a corresponding {0}</source>
        <target state="translated">Ta właściwość przesłania właściwość abstrakcyjną lub zawiera jej implementację, ale właściwość abstrakcyjna nie ma odpowiedniego elementu {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSignatureForSet">
        <source>Invalid signature for set member</source>
        <target state="translated">Nieprawidłowa sygnatura elementu członkowskiego ustawiania</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMember">
        <source>This new member hides the abstract member '{0}'. Rename the member or use 'override' instead.</source>
        <target state="translated">Ten nowy element członkowski ukrywa abstrakcyjny element członkowski „{0}”. Zmień nazwę elementu członkowskiego lub użyj elementu „override”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMemberWithSuffix">
        <source>This new member hides the abstract member '{0}' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead.</source>
        <target state="translated">Ten nowy element członkowski ukrywa abstrakcyjny element członkowski „{0}” po wymazaniu krotek, funkcji, jednostek miary i/lub udostępnionych typów. Zmień nazwę elementu członkowskiego lub użyj elementu „override”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializersIllegalInInterface">
        <source>Interfaces cannot contain definitions of static initializers</source>
        <target state="translated">Interfejsy nie mogą zawierać definicji inicjatorów statycznych</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsIllegalInInterface">
        <source>Interfaces cannot contain definitions of object constructors</source>
        <target state="translated">Interfejsy nie mogą zawierać definicji konstruktorów obiektów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOverridesIllegalInInterface">
        <source>Interfaces cannot contain definitions of member overrides</source>
        <target state="translated">Interfejsy nie mogą zawierać definicji przesłonięć elementów członkowskich</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConcreteMembersIllegalInInterface">
        <source>Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.</source>
        <target state="translated">Interfejsy nie mogą zawierać definicji konkretnych elementów członkowskich. Może być konieczne zdefiniowanie konstruktora w typie, aby określić, że typ to klasa.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsDisallowedInExceptionAugmentation">
        <source>Constructors cannot be specified in exception augmentations</source>
        <target state="translated">Nie można określać konstruktorów w rozszerzeniach wyjątków</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCannotHaveConstructorWithNoArguments">
        <source>Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.</source>
        <target state="translated">Struktury nie mogą mieć konstruktora obiektów bez argumentów. To ograniczenie dotyczy wszystkich języków CLI, ponieważ struktury automatycznie obsługują konstruktor domyślny.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalForThisType">
        <source>Constructors cannot be defined for this type</source>
        <target state="translated">Nie można definiować konstruktorów dla tego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
        <source>Recursive bindings that include member specifications can only occur as a direct augmentation of a type</source>
        <target state="translated">Powiązania cykliczne zawierające specyfikacje elementów członkowskich mogą występować tylko jako bezpośrednie powiększenie typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimplePatternsInLetRec">
        <source>Only simple variable patterns can be bound in 'let rec' constructs</source>
        <target state="translated">Tylko proste wzorce zmiennych mogą być powiązane w konstrukcjach „let rec”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
        <source>Mutable 'let' bindings can't be recursive or defined in recursive modules or namespaces</source>
        <target state="translated">Modyfikowalne powiązania „let” nie mogą być rekurencyjne ani definiowane w modułach rekurencyjnych lub przestrzeniach nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberIsNotSufficientlyGeneric">
        <source>This member is not sufficiently generic</source>
        <target state="translated">Ten element członkowski nie jest wystarczająco ogólny</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralAttributeRequiresConstantValue">
        <source>A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. 'val x : int = 1'</source>
        <target state="translated">Deklaracja może być atrybutem [&lt;Literal&gt;] tylko wtedy, gdy zostanie również podana wartość stała, np. „val x : int = 1”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcValueInSignatureRequiresLiteralAttribute">
        <source>A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute</source>
        <target state="translated">Deklaracja może otrzymać wartość w podpisie tylko wtedy, gdy ma atrybut [&lt;Literal&gt;]</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThreadStaticAndContextStaticMustBeStatic">
        <source>Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread</source>
        <target state="translated">Zmienne statyczne dla wątku i kontekstu muszą być określone jako statyczne i mieć atrybut [&lt;DefaultValue&gt;] w celu wskazania, że wartość jest inicjowana w każdym nowym wątku przy użyciu wartości domyślnej</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileFieldsMustBeMutable">
        <source>Volatile fields must be marked 'mutable' and cannot be thread-static</source>
        <target state="translated">Pola nietrwałe muszą być oznaczone jako „mutable” i nie mogą być statyczne dla wątku</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUninitializedValFieldsMustBeMutable">
        <source>Uninitialized 'val' fields must be mutable and marked with the '[&lt;DefaultValue&gt;]' attribute. Consider using a 'let' binding instead of a 'val' field.</source>
        <target state="translated">Niezainicjowane pola „val” muszą być modyfikowalne i oznaczone przy użyciu atrybutu „[&lt;DefaultValue&gt;]”. Rozważ użycie powiązania „let” zamiast pola „val”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticValFieldsMustBeMutableAndPrivate">
        <source>Static 'val' fields in types must be mutable, private and marked with the '[&lt;DefaultValue&gt;]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type.</source>
        <target state="translated">Statyczne pola „val” w typach muszą być modyfikowalne, prywatne i oznaczone przy użyciu atrybutu „[&lt;DefaultValue&gt;]”. Są one inicjowane dla swoich typów przy użyciu wartości „null” lub „zero”. Rozważ też użycie powiązania „static let mutable” w typie klasy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresName">
        <source>This field requires a name</source>
        <target state="translated">To pole wymaga nazwy</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNamespaceModuleTypeUnionName">
        <source>Invalid namespace, module, type or union case name</source>
        <target state="translated">Nieprawidłowa nazwa przestrzeni nazw, modułu, typu lub przypadku unii</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalFormForExplicitTypeDeclaration">
        <source>Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -&gt; resTy'. Parentheses may be required around 'resTy'</source>
        <target state="translated">Jawne deklaracje typów w przypadku konstruktorów muszą mieć postać „ty1 * ... * tyN -&gt; resTy”. Może być konieczne ujęcie ciągu „resTy” w nawias</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnTypesForUnionMustBeSameAsType">
        <source>Return types of union cases must be identical to the type being defined, up to abbreviations</source>
        <target state="translated">Zwracane typy przypadków unii muszą być identyczne z definiowanym typem, łącznie ze skrótami</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumerationLiteral">
        <source>This is not a valid value for an enumeration literal</source>
        <target state="translated">To nie jest prawidłowa wartość literału wyliczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType1">
        <source>The type '{0}' is not an interface type</source>
        <target state="translated">Typ „{0}” nie jest typem interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDuplicateSpecOfInterface">
        <source>Duplicate specification of an interface</source>
        <target state="translated">Zduplikowana specyfikacja interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldValIllegalHere">
        <source>A field/val declaration is not permitted here</source>
        <target state="translated">Deklaracja pola/wartości nie jest tutaj dozwolona</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritIllegalHere">
        <source>A inheritance declaration is not permitted here</source>
        <target state="translated">Deklaracja dziedziczenia nie jest tutaj dozwolona</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleRequiresQualifiedAccess">
        <source>This declaration opens the module '{0}', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.</source>
        <target state="translated">Ta deklaracja powoduje otwarcie modułu „{0}”, który jest oznaczony jako „RequireQualifiedAccess”. Dostosuj kod, aby używał odwołań kwalifikowanych do elementów modułu, na przykład „List.map” zamiast „map”. Ta zmiana pozwoli zagwarantować niezawodność kodu, gdy do bibliotek zostaną dodane nowe konstrukcje.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenUsedWithPartiallyQualifiedPath">
        <source>This declaration opens the namespace or module '{0}' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.</source>
        <target state="translated">Ta deklaracja powoduje otwarcie przestrzeni nazw lub modułu „{0}” za pośrednictwem częściowo kwalifikowanej ścieżki. Dostosuj ten kod, aby używał pełnej ścieżki przestrzeni nazw. Dzięki tej zmianie kod będzie bardziej niezawodny, gdy do bibliotek języka F# i infrastruktury CLI zostaną dodane nowe konstrukcje.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLocalClassBindingsCannotBeInline">
        <source>Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.</source>
        <target state="translated">Lokalne powiązania klas nie mogą być oznaczone jako śródwierszowe. Rozważ przeniesienie definicji poza klasę lub nie oznaczaj jej jako śródwierszowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsMayNotHaveMembers">
        <source>Type abbreviations cannot have members</source>
        <target state="translated">Skróty typów nie mogą mieć elementów członkowskich</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCheckedAtCompileTime">
        <source>As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.</source>
        <target state="translated">Począwszy od wersji F# 4.1, dostępność skrótów typów jest sprawdzana w czasie kompilacji. Rozważ sprawdzenie dostępności skrótu typu. Zignorowanie tego ostrzeżenia może prowadzić do błędów w czasie wykonywania.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsMayNotHaveMembers">
        <source>Enumerations cannot have members</source>
        <target state="translated">Wyliczenia nie mogą zawierać elementów członkowskich</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembers">
        <source>Measure declarations may have only static members</source>
        <target state="translated">Deklaracje miary mogą mieć tylko statyczne elementy członkowskie</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainDoBindings">
        <source>Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings</source>
        <target state="translated">Struktury nie mogą zawierać powiązań „do”, ponieważ domyślny konstruktor struktur nie wykona tych powiązań</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainLetBindings">
        <source>Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.</source>
        <target state="translated">Struktury nie mogą zawierać definicji wartości, ponieważ domyślny konstruktor konstrukcji nie wykona tych powiązań. Rozważ dodanie kolejnych argumentów do podstawowego konstruktora typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticLetBindingsRequireClassesWithImplicitConstructors">
        <source>Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Definicje wartości statycznych mogą być używane tylko w przypadku typów z konstruktorem podstawowym. Rozważ dodanie argumentów do definicji typu, na przykład „type X(argumenty) = ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembersNotConstructors">
        <source>Measure declarations may have only static members: constructors are not available</source>
        <target state="translated">Deklaracje miary mogą mieć tylko statyczne elementy członkowskie: konstruktory są niedostępne</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberAndLocalClassBindingHaveSameName">
        <source>A member and a local class binding both have the name '{0}'</source>
        <target state="translated">Element członkowski i lokalne powiązanie klasy mają tę samą nazwę („{0}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
        <source>Type abbreviations cannot have interface declarations</source>
        <target state="translated">Skróty typów nie mogą mieć deklaracji interfejsów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsCannotHaveInterfaceDeclaration">
        <source>Enumerations cannot have interface declarations</source>
        <target state="translated">Wyliczenia nie mogą zawierać deklaracji interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType0">
        <source>This type is not an interface type</source>
        <target state="translated">Ten typ nie jest typem interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllImplementedInterfacesShouldBeDeclared">
        <source>All implemented interfaces should be declared on the initial declaration of the type</source>
        <target state="translated">Wszystkie zaimplementowane interfejsy powinny zostać zadeklarowane w początkowej deklaracji typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
        <source>A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type</source>
        <target state="translated">Dodano już domyślną implementację tego interfejsu, ponieważ nie określono jawnej implementacji interfejsu w definicji typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberNotPermittedInInterfaceImplementation">
        <source>This member is not permitted in an interface implementation</source>
        <target state="translated">Ten element członkowski nie jest dozwolony w implementacji interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclarationElementNotPermittedInAugmentation">
        <source>This declaration element is not permitted in an augmentation</source>
        <target state="translated">Ten element deklaracji nie jest dozwolony w rozszerzeniu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotContainNestedTypes">
        <source>Types cannot contain nested type definitions</source>
        <target state="translated">Typy nie mogą zawierać definicji typów zagnieżdżonych</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeExceptionOrModule">
        <source>type, exception or module</source>
        <target state="translated">typ, wyjątek lub moduł</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeOrModule">
        <source>type or module</source>
        <target state="translated">typ lub moduł</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type.</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” zawiera jawną implementację interfejsu „System.IStructuralEquatable”. Zastosuj atrybut „CustomEquality” do typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IEquatable&lt;_&gt;' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'.</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” zawiera jawną implementację interfejsu „System.IEquatable&lt;_&gt;”. Zastosuj atrybut „CustomEquality” do typu i określ spójną implementację nieogólnego przesłonięcia „System.Object.Equals(obiekt)”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
        <source>Explicit type specifications cannot be used for exception constructors</source>
        <target state="translated">Jawne specyfikacje typów nie mogą być używane w przypadku konstruktorów wyjątków</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsShouldNotHaveArgumentList">
        <source>Exception abbreviations should not have argument lists</source>
        <target state="translated">Skróty wyjątków nie powinny zawierać list argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
        <source>Abbreviations for Common IL exceptions cannot take arguments</source>
        <target state="translated">Skróty wyjątków Common IL nie mogą pobierać argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsMustReferToValidExceptions">
        <source>Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception</source>
        <target state="translated">Skróty wyjątków muszą odwoływać się do istniejących wyjątków lub typów języka F# pochodzących od elementu System.Exception</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
        <source>Abbreviations for Common IL exception types must have a matching object constructor</source>
        <target state="translated">Skróty typów wyjątków Common IL muszą mieć zgodnego konstruktora obiektów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotAnException">
        <source>Not an exception</source>
        <target state="translated">To nie jest wyjątek</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidModuleName">
        <source>Invalid module name</source>
        <target state="translated">Nieprawidłowa nazwa modułu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeExtension">
        <source>Invalid type extension</source>
        <target state="translated">Nieprawidłowe rozszerzenie typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesOfTypeSpecifyMultipleKindsForType">
        <source>The attributes of this type specify multiple kinds for the type</source>
        <target state="translated">Atrybuty tego typu określają wiele rodzajów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcKindOfTypeSpecifiedDoesNotMatchDefinition">
        <source>The kind of the type specified by its attributes does not match the kind implied by its definition</source>
        <target state="translated">Rodzaj typu określony przez jego atrybuty nie jest zgodny z rodzajem implikowanym przez jego definicję</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDefinitionsCannotHaveTypeParameters">
        <source>Measure definitions cannot have type parameters</source>
        <target state="translated">Definicje miary nie mogą mieć parametrów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeRequiresDefinition">
        <source>This type requires a definition</source>
        <target state="translated">Ten typ wymaga definicji</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationHasTypeParametersMissingOnType">
        <source>This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C&lt;'a&gt; = C of ...'.</source>
        <target state="translated">Ten skrót typu zawiera co najmniej jeden zadeklarowany parametr typu, który nie występuje w skracanym typie. Skróty typu muszą używać wszystkich zadeklarowanych parametrów typu w skracanym typie. Rozważ usunięcie co najmniej jednego parametru typu lub użyj konkretnej definicji typu, która opakowuje typ podstawowy, na przykład „type C&lt;'a&gt; = C of ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
        <source>Structs, interfaces, enums and delegates cannot inherit from other types</source>
        <target state="translated">Struktury, interfejsy, wyliczenia i delegaty nie mogą dziedziczyć po innych typach.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotInheritFromMultipleConcreteTypes">
        <source>Types cannot inherit from multiple concrete types</source>
        <target state="translated">Typy nie mogą dziedziczyć po wielu konkretnych typach</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
        <source>Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute</source>
        <target state="translated">Typy rekordów, unii, skrótów i struktur nie mogą zawierać atrybutu „AllowNullLiteral”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
        <source>Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal</source>
        <target state="translated">Typy z atrybutem „AllowNullLiteral” mogą dziedziczyć tylko po typach, które również zezwalają na używanie literału o wartości null, lub zawierać ich implementację</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericTypesCannotHaveStructLayout">
        <source>Generic types cannot be given the 'StructLayout' attribute</source>
        <target state="translated">Typy ogólne nie mogą mieć atrybutu „StructLayout”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyStructsCanHaveStructLayout">
        <source>Only structs and classes without primary constructors may be given the 'StructLayout' attribute</source>
        <target state="translated">Tylko struktury i klasy bez konstruktorów podstawowych mogą mieć atrybut „StructLayout”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRepresentationOfTypeHiddenBySignature">
        <source>The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.</source>
        <target state="translated">Reprezentacja tego typu została ukryta przez podpis. W celu wskazania charakterystyki typu musi ona zawierać atrybut, taki jak [&lt;Sealed&gt;], [&lt;Class&gt;] lub [&lt;Interface&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyClassesCanHaveAbstract">
        <source>Only classes may be given the 'AbstractClass' attribute</source>
        <target state="translated">Tylko klasy mogą mieć atrybut „AbstractClass”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
        <source>Only types representing units-of-measure may be given the 'Measure' attribute</source>
        <target state="translated">Tylko typy reprezentujące jednostkę miary mogą mieć atrybut „Measure”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on overrides or interface implementations</source>
        <target state="translated">Modyfikatory dostępności nie są dozwolone w przypadku przesłonięć lub implementacji interfejsów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDU">
        <source>Discriminated union types are always sealed</source>
        <target state="translated">Typy unii rozłącznych są zawsze zapieczętowane</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedRecord">
        <source>Record types are always sealed</source>
        <target state="translated">Typy rekordów są zawsze zapieczętowane</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedAssemblyCode">
        <source>Assembly code types are always sealed</source>
        <target state="translated">Typy kodu zestawu są zawsze zapieczętowane</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedStruct">
        <source>Struct types are always sealed</source>
        <target state="translated">Typy struktur są zawsze zapieczętowane</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDelegate">
        <source>Delegate types are always sealed</source>
        <target state="translated">Typy delegatów są zawsze zapieczętowane.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedEnum">
        <source>Enum types are always sealed</source>
        <target state="translated">Typy wyliczeniowe są zawsze zapieczętowane</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesAndDelegatesCannotContainFields">
        <source>Interface types and delegate types cannot contain fields</source>
        <target state="translated">Typy interfejsów i delegatów nie mogą zawierać pól</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviatedTypesCannotBeSealed">
        <source>Abbreviated types cannot be given the 'Sealed' attribute</source>
        <target state="translated">Skrócone typy nie mogą mieć atrybutu „Sealed”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromSealedType">
        <source>Cannot inherit a sealed type</source>
        <target state="translated">Nie można odziedziczyć zapieczętowanego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromInterfaceType">
        <source>Cannot inherit from interface type. Use interface ... with instead.</source>
        <target state="translated">Nie można dziedziczyć po typie interfejsu. Zamiast tego użyj konstrukcji interface ... with.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructTypesCannotContainAbstractMembers">
        <source>Struct types cannot contain abstract members</source>
        <target state="translated">Typy struktur nie mogą zawierać abstrakcyjnych elementów członkowskich</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesCannotBeSealed">
        <source>Interface types cannot be sealed</source>
        <target state="translated">Typy interfejsów nie mogą być zapieczętowane</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDelegateSpecification">
        <source>Delegate specifications must be of the form 'typ -&gt; typ'</source>
        <target state="translated">Specyfikacje delegatów muszą mieć postać „typ -&gt; typ”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegatesCannotBeCurried">
        <source>Delegate specifications must not be curried types. Use 'typ * ... * typ -&gt; typ' for multi-argument delegates, and 'typ -&gt; (typ -&gt; typ)' for delegates returning function values.</source>
        <target state="translated">Specyfikacje delegatów nie mogą być typu curried. Użyj konstrukcji „typ * ... * typ -&gt; typ” w przypadku delegatów z wieloma argumentami i konstrukcji „typ -&gt; (typ -&gt; typ)” w przypadku delegatów zwracających wartości funkcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForLiteralEnumeration">
        <source>Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char</source>
        <target state="translated">Wyliczenia literałów muszą być typu int, uint, int16, uint16, int64, uint64, byte, sbyte lub char</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclic">
        <source>This type definition involves an immediate cyclic reference through an abbreviation</source>
        <target state="translated">Ta definicja typu zawiera bezpośrednie odwołanie cykliczne za pośrednictwem skrótu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclicThroughInheritance">
        <source>This type definition involves an immediate cyclic reference through a struct field or inheritance relation</source>
        <target state="translated">Ta definicja typu zawiera bezpośrednie odwołanie cykliczne za pośrednictwem pola struktury lub relacji dziedziczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReservedSyntaxForAugmentation">
        <source>The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[&lt;Sealed&gt;] attribute to the type definition in the signature</source>
        <target state="translated">Składnia „type X with ...” jest zarezerwowana dla rozszerzeń. Typy, które mają ukryte reprezentacje, ale zawierają składowe, są obecnie deklarowane w podpisach przy użyciu składni „type X = ...”. Może być też konieczne dodanie atrybutu [&lt;Sealed&gt;] do definicji typu w podpisie</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
        <source>Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.</source>
        <target state="translated">Elementy członkowskie stanowiące rozszerzenie typu interfejsu, delegata lub wyliczenia muszą znajdować się w innym module niż ten, w którym znajduje się definicja typu. Ten moduł musi mieć atrybut AutoOpen lub musi zostać jawnie otwarty przez kod klienta w celu uwzględnienia elementów członkowskich rozszerzeń w zakresie.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal">
        <source>One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '{0}'</source>
        <target state="translated">Co najmniej jeden zadeklarowany parametr typu dla tego rozszerzenia typu nie ma ograniczenia typu lub ograniczenie typu jest nieprawidłowe i niezgodne z oryginalnymi ograniczeniami typu w elemencie „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
        <source>Type definitions may only have one 'inherit' specification and it must be the first declaration</source>
        <target state="translated">Definicje typów mogą zawierać tylko jedną specyfikację „inherit”, która musi być pierwszą deklaracją</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
        <source>'let' and 'do' bindings must come before member and interface definitions in type definitions</source>
        <target state="translated">Powiązania „let” i „do” muszą występować przed definicjami elementów członkowskich i interfejsów w definicjach typów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritDeclarationMissingArguments">
        <source>This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'.</source>
        <target state="translated">Ta deklaracja „inherit” określa dziedziczony typ, ale nie określa argumentów. Rozważ określenie argumentów, na przykład „inherit TypPodstawowy(argumenty)”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritConstructionCallNotPartOfImplicitSequence">
        <source>This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Ta deklaracja „inherit” zawiera argumenty, ale nie należy do typu z konstruktorem podstawowym. Rozważ dodanie argumentów do definicji typu, na przykład „type X(argumenty) = ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLetAndDoRequiresImplicitConstructionSequence">
        <source>This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Ta definicja może być używana tylko w typie z konstruktorem podstawowym. Rozważ dodanie argumentów do definicji typu, na przykład „type X(args) = ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveAugmentations">
        <source>Type abbreviations cannot have augmentations</source>
        <target state="translated">Skróty typów nie mogą mieć rozszerzeń</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbreviationForNamespace">
        <source>The path '{0}' is a namespace. A module abbreviation may not abbreviate a namespace.</source>
        <target state="translated">Ścieżka „{0}” jest przestrzenią nazw. Skrót modułu nie może zawierać skrótu przestrzeni nazw.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeUsedInInvalidWay">
        <source>The type '{0}' is used in an invalid way. A value prior to '{1}' has an inferred type involving '{2}', which is an invalid forward reference.</source>
        <target state="translated">Typ „{0}” jest używany w nieprawidłowy sposób. Wartość przed elementem „{1}” ma wywnioskowany typ dotyczący elementu „{2}”, który jest nieprawidłowym odwołaniem w przód.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to the definition of '{2}', which is an invalid forward reference.</source>
        <target state="translated">Element członkowski „{0}” jest używany w nieprawidłowy sposób. Użycie elementu „{1}” zostało wywnioskowane przed definicją elementu „{2}”, co jest nieprawidłowym odwołaniem w przód.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeAutoOpenWasIgnored">
        <source>The attribute 'AutoOpen(\"{0}\")' in the assembly '{1}' did not refer to a valid module or namespace in that assembly and has been ignored</source>
        <target state="translated">Atrybut „AutoOpen(\"{0}\")” w zestawie „{1}” nie odwołuje się do prawidłowego modułu lub prawidłowej przestrzeni nazw w tym zestawie i został zignorowany</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUndefinedValue">
        <source>Undefined value '{0}'</source>
        <target state="translated">Niezdefiniowana wartość „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLabelNotFound">
        <source>Label {0} not found</source>
        <target state="translated">Nie znaleziono etykiety {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ilIncorrectNumberOfTypeArguments">
        <source>Incorrect number of type arguments to local call</source>
        <target state="translated">Niepoprawna liczba argumentów typu dla wywołania lokalnego</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDynamicInvocationNotSupported">
        <source>Dynamic invocation of {0} is not supported</source>
        <target state="translated">Dynamiczne wywołanie {0} nie jest obsługiwane</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfLiteralFieldIsInvalid">
        <source>Taking the address of a literal field is invalid</source>
        <target state="translated">Pobieranie adresu pola literału jest nieprawidłowe</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfValueHereIsInvalid">
        <source>This operation involves taking the address of a value '{0}' represented using a local variable or other special representation. This is invalid.</source>
        <target state="translated">Ta operacja obejmuje pobieranie adresu wartości „{0}” reprezentowanej przy użyciu zmiennej lokalnej lub innej specjalnej reprezentacji. Jest to nieprawidłowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilCustomMarshallersCannotBeUsedInFSharp">
        <source>Custom marshallers cannot be specified in F# code. Consider using a C# helper function.</source>
        <target state="translated">Nie można określać niestandardowych organizatorów w kodzie języka F#. Rozważ użycie pomocniczej funkcji języka C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMarshalAsAttributeCannotBeDecoded">
        <source>The MarshalAs attribute could not be decoded</source>
        <target state="translated">Nie można zdekodować atrybutu MarshalAs</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignatureForExternalFunctionContainsTypeParameters">
        <source>The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.</source>
        <target state="translated">Sygnatura dla tej funkcji zewnętrznej zawiera parametry typu. Ogranicz typy argumentów i zwracane typy, tak aby wskazywały typy odpowiedniej funkcji języka C.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDllImportAttributeCouldNotBeDecoded">
        <source>The DllImport attribute could not be decoded</source>
        <target state="translated">Nie można zdekodować atrybutu DllImport</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLiteralFieldsCannotBeSet">
        <source>Literal fields cannot be set</source>
        <target state="translated">Nie można ustawić pól literału</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStaticMethodIsNotLambda">
        <source>GenSetStorage: {0} was represented as a static method but was not an appropriate lambda expression</source>
        <target state="translated">GenSetStorage: Element {0} był reprezentowany jako metoda statyczna, ale nie był odpowiednim wyrażeniem lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMutableVariablesCannotEscapeMethod">
        <source>Mutable variables cannot escape their method</source>
        <target state="translated">Zmienne modyfikowalne nie mogą opuścić swojej metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedUnrealizedValue">
        <source>Compiler error: unexpected unrealized value</source>
        <target state="translated">Błąd kompilatora: nieoczekiwana niezrealizowana wartość</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMainModuleEmpty">
        <source>Main module of program is empty: nothing will happen when it is run</source>
        <target state="translated">Główny moduł programu jest pusty: nic się nie wydarzy po jego uruchomieniu</target>
        <note />
      </trans-unit>
      <trans-unit id="ilTypeCannotBeUsedForLiteralField">
        <source>This type cannot be used for a literal field</source>
        <target state="translated">Ten typ nie może być używany dla pola literału</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedGetSetAnnotation">
        <source>Unexpected GetSet annotation on a property</source>
        <target state="translated">Nieoczekiwana adnotacja GetSet dla właściwości</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldOffsetAttributeCouldNotBeDecoded">
        <source>The FieldOffset attribute could not be decoded</source>
        <target state="translated">Nie można zdekodować atrybutu FieldOffset</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStructLayoutAttributeCouldNotBeDecoded">
        <source>The StructLayout attribute could not be decoded</source>
        <target state="translated">Nie można zdekodować atrybutu StructLayout</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDefaultAugmentationAttributeCouldNotBeDecoded">
        <source>The DefaultAugmentation attribute could not be decoded</source>
        <target state="translated">Nie można zdekodować atrybutu DefaultAugmentation</target>
        <note />
      </trans-unit>
      <trans-unit id="ilReflectedDefinitionsCannotUseSliceOperator">
        <source>Reflected definitions cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">Odbite definicje nie mogą używać operatora łączenia prefiksu „%”</target>
        <note />
      </trans-unit>
      <trans-unit id="optsProblemWithCodepage">
        <source>Problem with codepage '{0}': {1}</source>
        <target state="translated">Problem ze stroną kodową „{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyright">
        <source>Copyright (c) Microsoft Corporation. All Rights Reserved.</source>
        <target state="translated">Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyrightCommunity">
        <source>Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</source>
        <target state="translated">Udostępniane bezpłatnie w ramach licencji open source MIT.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNameOfOutputFile">
        <source>Name of the output file (Short form: -o)</source>
        <target state="translated">Nazwa pliku wyjściowego (krótka wersja: -o)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildConsole">
        <source>Build a console executable</source>
        <target state="translated">Kompiluj plik wykonywalny konsoli</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildWindows">
        <source>Build a Windows executable</source>
        <target state="translated">Kompiluj plik wykonywalny systemu Windows</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildLibrary">
        <source>Build a library (Short form: -a)</source>
        <target state="translated">Kompiluj bibliotekę (krótka wersja: -a)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildModule">
        <source>Build a module that can be added to another assembly</source>
        <target state="translated">Kompiluj moduł, który można będzie dodać do innego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDelaySign">
        <source>Delay-sign the assembly using only the public portion of the strong name key</source>
        <target state="translated">Podpisz zestaw z opóźnieniem, używając tylko publicznej części klucza o silnej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPublicSign">
        <source>Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed</source>
        <target state="translated">Podpisz zestaw na użytek publiczny za pomocą tylko publicznej części klucza o silnej nazwie i oznacz zestaw jako podpisany</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWriteXml">
        <source>Write the xmldoc of the assembly to the given file</source>
        <target state="translated">Zapisz dokument XML zestawu w podanym pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyFile">
        <source>Specify a strong name key file</source>
        <target state="translated">Określ plik klucza o silnej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyContainer">
        <source>Specify a strong name key container</source>
        <target state="translated">Określ kontener kluczy o silnej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPlatform">
        <source>Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.</source>
        <target state="translated">Ogranicz platformy, na jakich można uruchomić ten kod: x86, Itanium, x64, anycpu32bitpreferred lub anycpu. Domyślna platforma to anycpu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoOpt">
        <source>Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.</source>
        <target state="translated">Dołącz tylko informacje o optymalizacji, które są istotne dla implementacji konstrukcji śródwierszowych. Uniemożliwia używanie konstrukcji śródwierszowych między modułami, ale zwiększa zgodność binarną.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoInterface">
        <source>Don't add a resource to the generated assembly containing F#-specific metadata</source>
        <target state="translated">Nie dodawaj zasobu do wygenerowanego zestawu zawierającego metadane specyficzne dla języka F#</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSig">
        <source>Print the inferred interface of the assembly to a file</source>
        <target state="translated">Zapisz w pliku wnioskowany interfejs zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="optsReference">
        <source>Reference an assembly (Short form: -r)</source>
        <target state="translated">Utwórz odwołanie do zestawu (krótka wersja: -r)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32res">
        <source>Specify a Win32 resource file (.res)</source>
        <target state="translated">Określ plik zasobów Win32 (.res)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32manifest">
        <source>Specify a Win32 manifest file</source>
        <target state="translated">Określ plik manifestu biblioteki Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowin32manifest">
        <source>Do not include the default Win32 manifest</source>
        <target state="translated">Nie dołączaj domyślnego manifestu Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedAllSource">
        <source>Embed all source files in the portable PDB file</source>
        <target state="translated">Osadź wszystkie pliki źródłowe w przenośnym pliku PDB</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedSource">
        <source>Embed specific source files in the portable PDB file</source>
        <target state="translated">Osadź określone pliki źródłowe w przenośnym pliku PDB</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLink">
        <source>Source link information file to embed in the portable PDB file</source>
        <target state="translated">Plik informacji o linku kodu źródłowego do osadzenia w przenośnym pliku PDB</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbeddedSourceRequirePortablePDBs">
        <source>--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">Przełącznik --embed jest obsługiwany tylko dla emitowania przenośnego pliku PDB (--debug:portable lub --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLinkRequirePortablePDBs">
        <source>--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">Przełącznik --sourcelink jest obsługiwany tylko dla emitowania przenośnego pliku PDB (--debug:portable lub --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="srcFileTooLarge">
        <source>Source file is too large to embed in a portable PDB</source>
        <target state="translated">Plik źródłowy jest za duży, aby osadzić go w przenośnym pliku PDB</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResource">
        <source>Embed the specified managed resource</source>
        <target state="translated">Osadź określony zasób zarządzany</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLinkresource">
        <source>Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]</source>
        <target state="translated">Połącz określony zasób z tym zestawem, gdzie format informacji o zasobie to &lt;plik&gt;[,&lt;nazwa ciągu&gt;[,public|private]]</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebugPM">
        <source>Emit debug information (Short form: -g)</source>
        <target state="translated">Emituj informacje debugowania (krótka wersja: -g)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebug">
        <source>Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file).</source>
        <target state="translated">Określ typ debugowania: full, portable, pdbonly. Wartość „{0}” jest wartością domyślną, jeśli nie określono typu debugowania, i umożliwia dołączenie debugera do działającego programu. Wartość „portable” określa format międzyplatformowy. Wartość „embedded” określa format międzyplatformowy osadzony w pliku wyjściowym.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsOptimize">
        <source>Enable optimizations (Short form: -O)</source>
        <target state="translated">Włącz optymalizacje (krótka wersja: -O)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTailcalls">
        <source>Enable or disable tailcalls</source>
        <target state="translated">Włącz lub wyłącz wywołania tail</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDeterministic">
        <source>Produce a deterministic assembly (including module version GUID and timestamp)</source>
        <target state="translated">Utwórz zestaw deterministyczny (łącznie z sygnaturą czasową i identyfikatorem GUID wersji modułu)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCrossoptimize">
        <source>Enable or disable cross-module optimizations</source>
        <target state="translated">Włącz lub wyłącz optymalizacje między modułami</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserrorPM">
        <source>Report all warnings as errors</source>
        <target state="translated">Raportuj wszystkie ostrzeżenia jako błędy</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserror">
        <source>Report specific warnings as errors</source>
        <target state="translated">Raportuj określone ostrzeżenia jako błędy</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarn">
        <source>Set a warning level (0-5)</source>
        <target state="translated">Ustaw poziom ostrzeżeń (0-5)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowarn">
        <source>Disable specific warning messages</source>
        <target state="translated">Wyłącz określone komunikaty ostrzegawcze</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnOn">
        <source>Enable specific warnings that may be off by default</source>
        <target state="translated">Włącz określone ostrzeżenia, które domyślnie mogą być wyłączone</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecked">
        <source>Generate overflow checks</source>
        <target state="translated">Generuj operacje sprawdzenia przepełnienia</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDefine">
        <source>Define conditional compilation symbols (Short form: -d)</source>
        <target state="translated">Definiuj symbole kompilacji warunkowej (krótka wersja: -d)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsMlcompatibility">
        <source>Ignore ML compatibility warnings</source>
        <target state="translated">Ignoruj ostrzeżenia dotyczące zgodności z językiem ML</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNologo">
        <source>Suppress compiler copyright message</source>
        <target state="translated">Pomiń komunikat kompilatora o prawach autorskich</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelp">
        <source>Display this usage message (Short form: -?)</source>
        <target state="translated">Wyświetl ten komunikat dotyczący składni (krótka wersja: -?)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFile">
        <source>Read response file for more options</source>
        <target state="translated">Przeczytaj plik odpowiedzi, aby uzyskać informacje na temat kolejnych opcji</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCodepage">
        <source>Specify the codepage used to read source files</source>
        <target state="translated">Określ stronę kodową używaną do odczytu plików źródłowych</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUtf8output">
        <source>Output messages in UTF-8 encoding</source>
        <target state="translated">Wypisz komunikaty w kodowaniu UTF-8</target>
        <note />
      </trans-unit>
      <trans-unit id="optsFullpaths">
        <source>Output messages with fully qualified paths</source>
        <target state="translated">Komunikaty z w pełni kwalifikowanymi ścieżkami</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLib">
        <source>Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)</source>
        <target state="translated">Określ katalog dla ścieżki dołączenia, która służy do rozpoznawania plików źródłowych i zestawów (krótka wersja: -I)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBaseaddress">
        <source>Base address for the library to be built</source>
        <target state="translated">Adres podstawowy biblioteki, która ma zostać skompilowana</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoframework">
        <source>Do not reference the default CLI assemblies by default</source>
        <target state="translated">Domyślnie nie odwołuj się do domyślnych zestawów infrastruktury CLI</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStandalone">
        <source>Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated</source>
        <target state="translated">Połącz statycznie bibliotekę języka F# i wszystkie przywoływane biblioteki DLL w generowanym zestawie</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStaticlink">
        <source>Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.</source>
        <target state="translated">Statycznie połącz podany zestaw i wszystkie przywoływane biblioteki DLL, które zależą od tego zestawu. Użyj nazwy zestawu (np. mojabiblioteka), a nie nazwy biblioteki DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResident">
        <source>Use a resident background compilation service to improve compiler startup times.</source>
        <target state="translated">Użyj rezydentnej usługi kompilacji działającej w tle w celu poprawienia czasów uruchamiania kompilatora.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPdb">
        <source>Name the output debug file</source>
        <target state="translated">Nazwa wyjściowego pliku debugowania</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSimpleresolution">
        <source>Resolve assembly references using directory-based rules rather than MSBuild resolution</source>
        <target state="translated">Rozpoznaj odwołania do zestawu przy użyciu reguł opartych na katalogu, a nie rozpoznawania narzędzia MSBuild</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedTarget">
        <source>Unrecognized target '{0}', expected 'exe', 'winexe', 'library' or 'module'</source>
        <target state="translated">Nierozpoznany cel „{0}”. Oczekiwano celu „exe”, „winexe”, „library” lub „module”</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedDebugType">
        <source>Unrecognized debug type '{0}', expected 'pdbonly' or 'full'</source>
        <target state="translated">Nierozpoznany typ debugowania „{0}”. Oczekiwano typu „pdbonly” lub „full”</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidWarningLevel">
        <source>Invalid warning level '{0}'</source>
        <target state="translated">Nieprawidłowy poziom ostrzeżenia „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="optsShortFormOf">
        <source>Short form of '{0}'</source>
        <target state="translated">Krótka wersja dla „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDeprecatedMsg">
        <source>The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.</source>
        <target state="translated">Opcja wiersza polecenia „--cliroot” jest przestarzała. Użyj odwołania jawnego do konkretnej kopii pliku mscorlib.dll.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDescription">
        <source>Use to override where the compiler looks for mscorlib.dll and framework components</source>
        <target state="translated">Użyj do przesłonięcia miejsca, w którym kompilator szuka pliku mscorlib.dll i składników struktury</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerOutputFiles">
        <source>- OUTPUT FILES -</source>
        <target state="translated">- PLIKI WYJŚCIOWE -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerInputFiles">
        <source>- INPUT FILES -</source>
        <target state="translated">- PLIKI WEJŚCIOWE -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerResources">
        <source>- RESOURCES -</source>
        <target state="translated">- ZASOBY -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerCodeGen">
        <source>- CODE GENERATION -</source>
        <target state="translated">- GENEROWANIE KODU -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerAdvanced">
        <source>- ADVANCED -</source>
        <target state="translated">- ZAAWANSOWANE -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerMisc">
        <source>- MISCELLANEOUS -</source>
        <target state="translated">- RÓŻNE -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerLanguage">
        <source>- LANGUAGE -</source>
        <target state="translated">- JĘZYK -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerErrsAndWarns">
        <source>- ERRORS AND WARNINGS -</source>
        <target state="translated">- BŁĘDY I OSTRZEŻENIA -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownArgumentToTheTestSwitch">
        <source>Unknown --test argument: '{0}'</source>
        <target state="translated">Nieznany argument --test: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownPlatform">
        <source>Unrecognized platform '{0}', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'</source>
        <target state="translated">Nierozpoznana platforma „{0}”. Prawidłowe wartości to „x86”, „x64”, „Itanium”, „anycpu32bitpreferred” i „anycpu”</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInternalNoDescription">
        <source>The command-line option '{0}' is for test purposes only</source>
        <target state="translated">Opcja wiersza polecenia „{0}” jest tylko do celów testowych</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLONoDescription">
        <source>The command-line option '{0}' has been deprecated</source>
        <target state="translated">Opcja wiersza polecenia „{0}” jest przestarzała</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLODeprecatedSuggestAlternative">
        <source>The command-line option '{0}' has been deprecated. Use '{1}' instead.</source>
        <target state="translated">Opcja wiersza polecenia „{0}” jest przestarzała. Użyj opcji „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLOHtmlDoc">
        <source>The command-line option '{0}' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.</source>
        <target state="translated">Opcja wiersza polecenia „{0}” jest przestarzała. Generowanie dokumentów HTML jest teraz częścią pakietu Power Pack języka F# i jest wykonywane za pośrednictwem narzędzia FsHtmlDoc.exe.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsConsoleColors">
        <source>Output warning and error messages in color</source>
        <target state="translated">Ostrzeżenia i komunikaty o błędzie wyróżnione kolorem</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUseHighEntropyVA">
        <source>Enable high-entropy ASLR</source>
        <target state="translated">Włącz losowe generowanie układu przestrzeni adresowej o wysokiej entropii</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSubSystemVersion">
        <source>Specify subsystem version of this assembly</source>
        <target state="translated">Określi wersję podsystemu tego zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTargetProfile">
        <source>Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib</source>
        <target state="translated">Określ profil platformy docelowej tego zestawu. Prawidłowe wartości to mscorlib, netcore lub netstandard. Wartość domyślna to mscorlib</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmitDebugInfoInQuotations">
        <source>Emit debug information in quotations</source>
        <target state="translated">Emituj informacje debugowania w cudzysłowach</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPreferredUiLang">
        <source>Specify the preferred output language culture name (e.g. es-ES, ja-JP)</source>
        <target state="translated">Określ nazwę kultury preferowanego języka wyjściowego (np. es-ES, ja-JP)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoCopyFsharpCore">
        <source>Don't copy FSharp.Core.dll along the produced binaries</source>
        <target state="translated">Nie kopiuj pliku FSharp.Core.dll wraz z utworzonymi plikami binarnymi</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidSubSystemVersion">
        <source>Invalid version '{0}' for '--subsystemversion'. The version must be 4.00 or greater.</source>
        <target state="translated">Nieprawidłowa wersja „{0}” dla opcji „--subsystemversion”. Wymagana jest wersja 4.00 lub nowsza.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidTargetProfile">
        <source>Invalid value '{0}' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.</source>
        <target state="translated">Nieprawidłowa wartość „{0}” dla opcji „--targetprofile”. Prawidłowe wartości to „mscorlib”, „netcore” lub „netstandard”.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFullName">
        <source>Full name</source>
        <target state="translated">Pełna nazwa</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoOtherOverloads">
        <source>and {0} other overloads</source>
        <target state="translated">i inne przeciążenia ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoUnionCase">
        <source>union case</source>
        <target state="translated">przypadek unii</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActivePatternResult">
        <source>active pattern result</source>
        <target state="translated">wynik aktywnego wzorca</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActiveRecognizer">
        <source>active recognizer</source>
        <target state="translated">aktywny aparat rozpoznawania</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoField">
        <source>field</source>
        <target state="translated">pole</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoEvent">
        <source>event</source>
        <target state="translated">zdarzenie</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoProperty">
        <source>property</source>
        <target state="translated">właściwość</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoExtension">
        <source>extension</source>
        <target state="translated">rozszerzenie</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCustomOperation">
        <source>custom operation</source>
        <target state="translated">operacja niestandardowa</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoArgument">
        <source>argument</source>
        <target state="translated">Argument</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoPatternVariable">
        <source>patvar</source>
        <target state="translated">zmienna wzorca</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespace">
        <source>namespace</source>
        <target state="translated">przestrzeń nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoModule">
        <source>module</source>
        <target state="translated">moduł</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespaceOrModule">
        <source>namespace/module</source>
        <target state="translated">przestrzeń nazw/moduł</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromFirst">
        <source>from {0}</source>
        <target state="translated">z {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromNext">
        <source>also from {0}</source>
        <target state="translated">również z {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedProperty">
        <source>generated property</source>
        <target state="translated">wygenerowana właściwość</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedType">
        <source>generated type</source>
        <target state="translated">wygenerowany typ</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersKey">
        <source>Found by AssemblyFolders registry key</source>
        <target state="translated">Znalezione przez klucz rejestru AssemblyFolders</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersExKey">
        <source>Found by AssemblyFoldersEx registry key</source>
        <target state="translated">Znalezione przez klucz rejestru AssemblyFoldersEx</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionNetFramework">
        <source>.NET Framework</source>
        <target state="translated">.NET Framework</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionGAC">
        <source>Global Assembly Cache</source>
        <target state="translated">Globalna pamięć podręczna zestawów</target>
        <note />
      </trans-unit>
      <trans-unit id="recursiveClassHierarchy">
        <source>Recursive class hierarchy in type '{0}'</source>
        <target state="translated">Cykliczna hierarchia klas w typie „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRecursiveReferenceToAbstractSlot">
        <source>Invalid recursive reference to an abstract slot</source>
        <target state="translated">Nieprawidłowe odwołanie cykliczne do miejsca abstrakcyjnego</target>
        <note />
      </trans-unit>
      <trans-unit id="eventHasNonStandardType">
        <source>The event '{0}' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit {1} and {2} methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent&lt;_&gt;' or 'IEvent&lt;_,_&gt;'.</source>
        <target state="translated">Zdarzenie „{0}” ma niestandardowy typ. Jeśli to zdarzenie zadeklarowano w innym języku interfejsu CLI, może być konieczne uzyskanie dostępu do tego zdarzenia przy użyciu jawnych metod {1} i {2} zdarzenia. Jeśli to zdarzenie zadeklarowano w języku F#, określ typ zdarzenia jako wystąpienie interfejsu „IDelegateEvent&lt;_&gt;” lub „IEvent&lt;_,_&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeIsNotAccessible">
        <source>The type '{0}' is not accessible from this code location</source>
        <target state="translated">Nie można uzyskać dostępu do typu „{0}” z tej lokalizacji kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCasesAreNotAccessible">
        <source>The union cases or fields of the type '{0}' are not accessible from this code location</source>
        <target state="translated">Nie można uzyskać dostępu do przypadków unii lub pól typu „{0}” z tej lokalizacji kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="valueIsNotAccessible">
        <source>The value '{0}' is not accessible from this code location</source>
        <target state="translated">Nie można uzyskać dostępu do wartości „{0}” z tej lokalizacji kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCaseIsNotAccessible">
        <source>The union case '{0}' is not accessible from this code location</source>
        <target state="translated">Nie można uzyskać dostępu do przypadku unii „{0}” z tej lokalizacji kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="fieldIsNotAccessible">
        <source>The record, struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">Pole rekordu, struktury lub klasy „{0}” jest niedostępne w tej lokalizacji kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="structOrClassFieldIsNotAccessible">
        <source>The struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">Nie można uzyskać dostępu do pola struktury lub klasy „{0}” z tej lokalizacji kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="experimentalConstruct">
        <source>This construct is experimental</source>
        <target state="translated">Ta konstrukcja jest eksperymentalna</target>
        <note />
      </trans-unit>
      <trans-unit id="noInvokeMethodsFound">
        <source>No Invoke methods found for delegate type</source>
        <target state="translated">Dla typu delegata nie znaleziono metod Invoke.</target>
        <note />
      </trans-unit>
      <trans-unit id="moreThanOneInvokeMethodFound">
        <source>More than one Invoke method found for delegate type</source>
        <target state="translated">Dla typu delegata znaleziono więcej niż jedną metodę Invoke.</target>
        <note />
      </trans-unit>
      <trans-unit id="delegatesNotAllowedToHaveCurriedSignatures">
        <source>Delegates are not allowed to have curried signatures</source>
        <target state="translated">Delegaty nie mogą mieć sygnatur typu curried.</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrUnexpectedTExpr">
        <source>Unexpected Expr.TyChoose</source>
        <target state="translated">Nieoczekiwany element Expr.TyChoose</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrLambdaLiftingOptimizationsNotApplied">
        <source>Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.</source>
        <target state="translated">Uwaga: Nie zastosowano optymalizacji przenoszenia elementu lambda, ponieważ ta lokalna funkcja ogólna z ograniczeniami została użyta jako wartość pierwszoklasowa. Dodanie ograniczeń typów może rozwiązać ten problem.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifiersContainingAtSymbolReserved">
        <source>Identifiers containing '@' are reserved for use in F# code generation</source>
        <target state="translated">Identyfikatory zawierające znak „@” są zarezerwowane do użytku podczas generowania kodu języka F#</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifierReserved">
        <source>The identifier '{0}' is reserved for future use by F#</source>
        <target state="translated">Identyfikator „{0}” jest zarezerwowany do użytku w przyszłości przez język F#</target>
        <note />
      </trans-unit>
      <trans-unit id="patcMissingVariable">
        <source>Missing variable '{0}'</source>
        <target state="translated">Brak zmiennej „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="patcPartialActivePatternsGenerateOneResult">
        <source>Partial active patterns may only generate one result</source>
        <target state="translated">Częściowe aktywne wzorce mogą generować tylko jeden wynik</target>
        <note />
      </trans-unit>
      <trans-unit id="impTypeRequiredUnavailable">
        <source>The type '{0}' is required here and is unavailable. You must add a reference to assembly '{1}'.</source>
        <target state="translated">Typ „{0}” jest tutaj wymagany i niedostępny. Musisz dodać odwołanie do zestawu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferencedTypeCouldNotBeFoundInAssembly">
        <source>A reference to the type '{0}' in assembly '{1}' was found, but the type could not be found in that assembly</source>
        <target state="translated">Znaleziono odwołanie do typu „{0}” w zestawie „{1}”, ale nie można znaleźć typu w tym zestawie</target>
        <note />
      </trans-unit>
      <trans-unit id="impNotEnoughTypeParamsInScopeWhileImporting">
        <source>Internal error or badly formed metadata: not enough type parameters were in scope while importing</source>
        <target state="translated">Błąd wewnętrzny lub źle sformułowane metadane: podczas importowania w zakresie była niewystarczająca liczba parametrów typu</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferenceToDllRequiredByAssembly">
        <source>A reference to the DLL {0} is required by assembly {1}. The imported type {2} is located in the first assembly and could not be resolved.</source>
        <target state="translated">Odwołanie do biblioteki DLL {0} jest wymagane przez zestaw {1}. Zaimportowany typ {2} znajduje się w pierwszym zestawie i nie można go rozpoznać.</target>
        <note />
      </trans-unit>
      <trans-unit id="impImportedAssemblyUsesNotPublicType">
        <source>An imported assembly uses the type '{0}' but that type is not public</source>
        <target state="translated">Zaimportowany zestaw używa typu „{0}”, który nie jest publiczny</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButIncomplete">
        <source>The value '{0}' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible</source>
        <target state="translated">Wartość „{0}” została oznaczona jako śródwierszowa, ale jej implementacja używa funkcji wewnętrznej lub prywatnej, która jest niewystarczająco dostępna</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButWasNotBoundInTheOptEnv">
        <source>The value '{0}' was marked inline but was not bound in the optimization environment</source>
        <target state="translated">Wartość „{0}” została oznaczona jako śródwierszowa, ale nie powiązano jej w środowisku optymalizacji</target>
        <note />
      </trans-unit>
      <trans-unit id="optLocalValueNotFoundDuringOptimization">
        <source>Local value {0} not found during optimization</source>
        <target state="translated">Nie znaleziono wartości lokalnej {0} podczas optymalizacji</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineHasUnexpectedValue">
        <source>A value marked as 'inline' has an unexpected value</source>
        <target state="translated">Wartość oznaczona jako „inline” ma nieoczekiwaną wartość</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineCouldNotBeInlined">
        <source>A value marked as 'inline' could not be inlined</source>
        <target state="translated">Nie można użyć konstrukcji śródwierszowej dla wartości oznaczonej jako „inline”</target>
        <note />
      </trans-unit>
      <trans-unit id="optFailedToInlineValue">
        <source>Failed to inline the value '{0}' marked 'inline', perhaps because a recursive value was marked 'inline'</source>
        <target state="translated">Nie powiodło się użycie śródwierszowej wartości „{0}” oznaczonej jako „inline” prawdopodobnie z powodu oznaczenia wartości cyklicznej jako „inline”</target>
        <note />
      </trans-unit>
      <trans-unit id="optRecursiveValValue">
        <source>Recursive ValValue {0}</source>
        <target state="translated">Cykliczny element ValValue {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltIncorrentIndentationOfIn">
        <source>The indentation of this 'in' token is incorrect with respect to the corresponding 'let'</source>
        <target state="translated">Wcięcie tego tokenu „in” jest niepoprawne w odniesieniu do odpowiadającego tokenu „let”</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltTokenIsOffsideOfContextStartedEarlier">
        <source>Possible incorrect indentation: this token is offside of context started at position {0}. Try indenting this token further or using standard formatting conventions.</source>
        <target state="translated">Możliwe niepoprawne wcięcie: ten token jest poza kontekstem rozpoczynającym się w pozycji {0}. Spróbuj użyć dodatkowego wcięcia dla tego tokenu lub standardowych konwencji formatowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltSeparatorTokensOfPatternMatchMisaligned">
        <source>The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.</source>
        <target state="translated">Reguły oddzielające tokeny „|” tego dopasowania wzorca są niewłaściwie wyrównane o jedną kolumnę. Rozważ ponowne wyrównanie kodu lub użycie dodatkowego wcięcia.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidModuleExprType">
        <source>Invalid module/expression/type</source>
        <target state="translated">Nieprawidłowy moduł/wyrażenie/typ</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationNeededToDisambiguateTypesWithSameName">
        <source>Multiple types exist called '{0}', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '{1}'.</source>
        <target state="translated">Istnieje wiele typów o nazwie „{0}”, które pobierają różne liczby parametrów ogólnych. Udostępnij wystąpienie typu w celu odróżnienia rozpoznawania typu (np. „{1}”).</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationIsMissingAndCouldNotBeInferred">
        <source>The instantiation of the generic type '{0}' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '{1}'.</source>
        <target state="translated">Brak wystąpienia typu ogólnego „{0}” i nie można wywnioskować wystąpienia przy użyciu argumentów lub zwracanego typu tego elementu członkowskiego. Rozważ udostępnienie wystąpienia typu podczas uzyskiwania dostępu do tego typu (np. „{1}”).</target>
        <note />
      </trans-unit>
      <trans-unit id="nrGlobalUsedOnlyAsFirstName">
        <source>'global' may only be used as the first name in a qualified path</source>
        <target state="translated">Elementu „global” można używać tylko jako pierwszej nazwy w kwalifikowanej ścieżce</target>
        <note />
      </trans-unit>
      <trans-unit id="nrIsNotConstructorOrLiteral">
        <source>This is not a constructor or literal, or a constructor is being used incorrectly</source>
        <target state="translated">Nie jest to konstruktor ani literał albo konstruktor jest niepoprawnie używany</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnexpectedEmptyLongId">
        <source>Unexpected empty long identifier</source>
        <target state="translated">Nieoczekiwany pusty długi identyfikator</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordDoesNotContainSuchLabel">
        <source>The record type '{0}' does not contain a label '{1}'.</source>
        <target state="translated">Typ rekordu „{0}” nie zawiera etykiety „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidFieldLabel">
        <source>Invalid field label</source>
        <target state="translated">Nieprawidłowa etykieta pola</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidExpression">
        <source>Invalid expression '{0}'</source>
        <target state="translated">Nieprawidłowe wyrażenie „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="nrNoConstructorsAvailableForType">
        <source>No constructors are available for the type '{0}'</source>
        <target state="translated">Brak konstruktorów dostępnych dla typu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnionTypeNeedsQualifiedAccess">
        <source>The union type for union case '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('{1}') in the name you are using.</source>
        <target state="translated">Typ unii dla przypadku unii „{0}” został zdefiniowany z użyciem wartości RequireQualifiedAccessAttribute. Uwzględnij nazwę typu unii („{1}”) w używanej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordTypeNeedsQualifiedAccess">
        <source>The record type for the record field '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('{1}') in the name you are using.</source>
        <target state="translated">Typ rekordu dla pola rekordu „{0}” został zdefiniowany z użyciem wartości RequireQualifiedAccessAttribute. Uwzględnij nazwę typu rekordu („{1}”) w używanej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingPdb">
        <source>Unexpected error creating debug information file '{0}'</source>
        <target state="translated">Nieoczekiwany błąd podczas tworzenia pliku informacji o debugowaniu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideIntegerRange">
        <source>This number is outside the allowable range for this integer type</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem tego typu liczb całkowitych</target>
        <note />
      </trans-unit>
      <trans-unit id="lexCharNotAllowedInOperatorNames">
        <source>'{0}' is not permitted as a character in operator names and is reserved for future use</source>
        <target state="translated">Znak „{0}” jest niedozwolony w nazwach operatora i zarezerwowany do użytku w przyszłości</target>
        <note />
      </trans-unit>
      <trans-unit id="lexUnexpectedChar">
        <source>Unexpected character '{0}'</source>
        <target state="translated">Nieoczekiwany znak „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteArrayCannotEncode">
        <source>This byte array literal contains characters that do not encode as a single byte</source>
        <target state="translated">Ten literał tablicy bajtowej zawiera znaki, które nie są kodowane jako pojedynczy bajt</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIdentEndInMarkReserved">
        <source>Identifiers followed by '{0}' are reserved for future use</source>
        <target state="translated">Identyfikatory, po których następuje „{0}”, są zarezerwowane do użytku w przyszłości</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSigned">
        <source>This number is outside the allowable range for 8-bit signed integers</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem 8-bitowych liczb całkowitych ze znakiem</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSignedHex">
        <source>This number is outside the allowable range for hexadecimal 8-bit signed integers</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem szesnastkowych, 8-bitowych liczb całkowitych ze znakiem</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitUnsigned">
        <source>This number is outside the allowable range for 8-bit unsigned integers</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem 8-bitowych liczb całkowitych bez znaku</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitSigned">
        <source>This number is outside the allowable range for 16-bit signed integers</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem 16-bitowych liczb całkowitych ze znakiem</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitUnsigned">
        <source>This number is outside the allowable range for 16-bit unsigned integers</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem 16-bitowych liczb całkowitych bez znaku</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitSigned">
        <source>This number is outside the allowable range for 32-bit signed integers</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem 32-bitowych liczb całkowitych ze znakiem</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitUnsigned">
        <source>This number is outside the allowable range for 32-bit unsigned integers</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem 32-bitowych liczb całkowitych bez znaku</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitSigned">
        <source>This number is outside the allowable range for 64-bit signed integers</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem 64-bitowych liczb całkowitych ze znakiem</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitUnsigned">
        <source>This number is outside the allowable range for 64-bit unsigned integers</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem 64-bitowych liczb całkowitych bez znaku</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeSigned">
        <source>This number is outside the allowable range for signed native integers</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem natywnych liczb całkowitych ze znakiem</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeUnsigned">
        <source>This number is outside the allowable range for unsigned native integers</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem natywnych liczb całkowitych bez znaku</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidFloat">
        <source>Invalid floating point number</source>
        <target state="translated">Nieprawidłowa liczba zmiennoprzecinkowa</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideDecimal">
        <source>This number is outside the allowable range for decimal literals</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem literałów dziesiętnych</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideThirtyTwoBitFloat">
        <source>This number is outside the allowable range for 32-bit floats</source>
        <target state="translated">Ta liczba jest poza dozwolonym zakresem 32-bitowych liczb zmiennoprzecinkowych</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidNumericLiteral">
        <source>This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0o1, 0b1, 1l (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</source>
        <target state="translated">Jest to nieprawidłowy literał liczbowy. Do prawidłowych literałów liczbowych należą: 1, 0x1, 0o1, 0b1, 1l (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidByteLiteral">
        <source>This is not a valid byte literal</source>
        <target state="translated">Nie jest to prawidłowy literał bajtowy</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidCharLiteral">
        <source>This is not a valid character literal</source>
        <target state="translated">Nie jest to prawidłowy literał znakowy</target>
        <note />
      </trans-unit>
      <trans-unit id="lexThisUnicodeOnlyInStringLiterals">
        <source>This Unicode encoding is only valid in string literals</source>
        <target state="translated">To kodowanie Unicode jest prawidłowe tylko w literałach ciągu</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTokenReserved">
        <source>This token is reserved for future use</source>
        <target state="translated">Ten token jest zarezerwowany do użytku w przyszłości</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTabsNotAllowed">
        <source>TABs are not allowed in F# code unless the #indent \"off\" option is used</source>
        <target state="translated">Znaki TAB są niedozwolone w kodzie języka F#, chyba że użyto opcji #indent \"off\"</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidLineNumber">
        <source>Invalid line number: '{0}'</source>
        <target state="translated">Nieprawidłowy numer wiersza: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustBeFirst">
        <source>#if directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">Dyrektywa #if musi występować jako pierwszy znak wiersza, który nie jest odstępem</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseNoMatchingIf">
        <source>#else has no matching #if</source>
        <target state="translated">Dyrektywa #else nie jest zgodna z dyrektywą #if</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifRequiredForElse">
        <source>#endif required for #else</source>
        <target state="translated">Dyrektywa #endif jest wymagana dla dyrektywy #else</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseMustBeFirst">
        <source>#else directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">Dyrektywa #else musi występować jako pierwszy znak wiersza, który nie jest odstępem</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndingNoMatchingIf">
        <source>#endif has no matching #if</source>
        <target state="translated">Dyrektywa #endif nie ma zgodnej dyrektywy #if</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifMustBeFirst">
        <source>#endif directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">Dyrektywa #endif musi występować jako pierwszy znak wiersza, który nie jest odstępem</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustHaveIdent">
        <source>#if directive should be immediately followed by an identifier</source>
        <target state="translated">Po dyrektywie #if powinien od razu następować identyfikator</target>
        <note />
      </trans-unit>
      <trans-unit id="lexWrongNestedHashEndif">
        <source>Syntax error. Wrong nested #endif, unexpected tokens before it.</source>
        <target state="translated">Błąd składni. Niewłaściwie zagnieżdżona dyrektywa #endif, przed którą występują nieoczekiwane tokeny.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashBangMustBeFirstInFile">
        <source>#! may only appear as the first line at the start of a file.</source>
        <target state="translated">Element #! może występować tylko jako pierwszy wiersz na początku pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexExpectedSingleLineComment">
        <source>Expected single line comment or end of line</source>
        <target state="translated">Oczekiwano jednowierszowego komentarza lub końca wiersza</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNoArguments">
        <source>Infix operator member '{0}' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Element członkowski operatora infiksu „{0}” nie ma argumentów. Oczekiwano krotka liczącej 2 argumenty, np. static member (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonPairArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Element członkowski operatora infiksu „{0}” ma następującą liczbę argumentów początkowych: {1}. Oczekiwano krotki liczącej 2 argumenty, np. static member (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithCurriedArguments">
        <source>Infix operator member '{0}' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Element członkowski operatora infiksu „{0}” ma dodatkowe argumenty curried. Oczekiwano krotki liczącej 2 argumenty, np. static member (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFSharpCoreRequiresExplicit">
        <source>All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'</source>
        <target state="translated">Wszystkie typy rekordów, unii i struktur w pliku FSharp.Core.dll muszą mieć jawną etykietę „StructuralComparison” lub „NoComparison”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the type parameter '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” zawiera atrybut „StructuralComparison”, ale parametr typu „{1}” nie spełnia ograniczenia „comparison”. Rozważ dodanie ograniczenia „comparison” do parametru typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the component type '{1}' does not satisfy the 'comparison' constraint</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” zawiera atrybut „StructuralComparison”, ale typ składnika „{1}” nie spełnia ograniczenia „comparison”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded1">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type parameter {1} does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">Nie można porównać struktury typu struktury, rekordu lub unii „{0}”, ponieważ parametr typu {1} nie spełnia ograniczenia „comparison”. Rozważ dodanie atrybutu „NoComparison” do typu „{2}” w celu określenia, że typu nie można porównywać</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded2">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">Nie można porównać struktury typu struktury, rekordu lub unii „{0}”, ponieważ typ „{1}” nie spełnia ograniczenia „comparison”. Rozważ dodanie atrybutu „NoComparison” do typu „{2}” w celu określenia, że typu nie można porównywać</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded1">
        <source>The struct, record or union type '{0}' does not support structural equality because the type parameter {1} does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” nie obsługuje równości strukturalnej, ponieważ parametr typu {1} nie spełnia ograniczenia „equality”. Rozważ dodanie atrybutu „NoEquality” do typu „{2}” w celu określenia, że typ nie obsługuje równości strukturalnej</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded2">
        <source>The struct, record or union type '{0}' does not support structural equality because the type '{1}' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” nie obsługuje równości strukturalnej, ponieważ typ „{1}” nie spełnia ograniczenia „equality”. Rozważ dodanie atrybutu „NoEquality” do typu „{2}” w celu określenia, że typ nie obsługuje równości strukturalnej</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the type parameter '{1}' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” zawiera atrybut „StructuralEquality”, ale parametr typu „{1}” nie spełnia ograniczenia „equality”. Rozważ dodanie ograniczenia „equality” do parametru typu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the component type '{1}' does not satisfy the 'equality' constraint</source>
        <target state="translated">Typ struktury, rekordu lub unii „{0}” zawiera atrybut „StructuralEquality”, ale typ składnika „{1}” nie spełnia ograniczenia „equality”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
        <source>Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct.</source>
        <target state="translated">Każdy argument podstawowego konstruktora struktury musi mieć określony typ, na przykład „type S(x1:int, x2:int) = ...”. Te argumenty określają pola struktury.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedValue">
        <source>The value '{0}' is unused</source>
        <target state="translated">Wartość „{0}” nie jest używana</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedThisVariable">
        <source>The recursive object reference '{0}' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.</source>
        <target state="translated">Cykliczne odwołanie do obiektu „{0}” nie jest używane. Obecność cyklicznego odwołania do obiektu powoduje dodanie kontroli inicjowania środowiska uruchomieniowego do elementów członkowskich w tym typie i typach pochodnych. Rozważ usunięcie tego cyklicznego odwołania do obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterAtMostOneArgument">
        <source>A getter property may have at most one argument group</source>
        <target state="translated">Właściwość metody pobierającej może mieć najwyżej jedną grupę argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetterAtMostTwoArguments">
        <source>A setter property may have at most two argument groups</source>
        <target state="translated">Właściwość metody ustawiającej może mieć co najwyżej dwie grupy argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidProperty">
        <source>Invalid property getter or setter</source>
        <target state="translated">Nieprawidłowa metoda ustawiająca lub metoda pobierająca właściwość</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIndexerPropertyRequiresAtLeastOneArgument">
        <source>An indexer property must be given at least one argument</source>
        <target state="translated">Wymagane jest podanie co najmniej jednego argumentu dla właściwości indeksatora</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidAddressOfMutableAcrossAssemblyBoundary">
        <source>This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation</source>
        <target state="translated">Ta operacja uzyskuje dostęp do modyfikowalnej wartości najwyższego poziomu zdefiniowanej w innym zestawie w nieobsługiwany sposób. Nie można uzyskiwać dostępu do wartości za pośrednictwem jej adresu. Rozważ skopiowanie wyrażenia do modyfikowalnej wartości lokalnej, na przykład „let mutable x = ...”, i w razie potrzeby ponowne przypisanie wartości po ukończeniu operacji</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTypars">
        <source>Remove spaces between the type name and type parameter, e.g. \"type C&lt;'T&gt;\", not type \"C   &lt;'T&gt;\". Type parameters must be placed directly adjacent to the type name.</source>
        <target state="translated">Usuń spacje między nazwą i parametrem typu, np. \"type C&lt;'T&gt;\", a nie type \"C   &lt;'T&gt;\". Parametry typów muszą bezpośrednio przylegać do nazw typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTyargs">
        <source>Remove spaces between the type name and type parameter, e.g. \"C&lt;'T&gt;\", not \"C &lt;'T&gt;\". Type parameters must be placed directly adjacent to the type name.</source>
        <target state="translated">Usuń spacje między nazwą i parametrem typu, np. \"C&lt;'T&gt;\", a nie \"C &lt;'T&gt;\". Parametry typów muszą bezpośrednio przylegać do nazw typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAtomicType">
        <source>The use of the type syntax 'int C' and 'C  &lt;int&gt;' is not permitted here. Consider adjusting this type to be written in the form 'C&lt;int&gt;'</source>
        <target state="translated">Użycie składni typu „int C” i „C  &lt;int&gt;” nie jest tutaj dozwolone. Rozważ dopasowanie tego typu w celu zapisania go w postaci „C&lt;int&gt;”</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespace">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the module/namespace '{2}'</source>
        <target state="translated">Moduł/przestrzeń nazw „{0}” z jednostki kompilacji „{1}” nie zawiera modułu/przestrzeni nazw „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefVal">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the val '{2}'</source>
        <target state="translated">Moduł/przestrzeń nazw „{0}” z jednostki kompilacji „{1}” nie zawiera wartości „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespaceType">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the namespace, module or type '{2}'</source>
        <target state="translated">Moduł/przestrzeń nazw „{0}” z jednostki kompilacji „{1}” nie zawiera modułu, przestrzeni nazw lub typu „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseNullAsTrueValue">
        <source>The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case</source>
        <target state="translated">Flaga atrybutu „UseNullAsTrueValue” może być używana tylko z typami unii, które mają jeden przypadek o wartości null i co najmniej jeden przypadek o wartości innej niż null</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterInferredByref">
        <source>The parameter '{0}' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref&lt;int&gt;'. When used, a byref parameter is implicitly dereferenced.</source>
        <target state="translated">Wywnioskowano, że parametr „{0}” ma typ byref. Parametry typu byref muszą mieć jawną adnotację typu, na przykład „x1: byref&lt;int&gt;”. Parametr typu byref zostanie niejawnie wyłuskany, jeśli zostanie użyty.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonUniformMemberUse">
        <source>The generic member '{0}' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.</source>
        <target state="translated">Ogólny element członkowski „{0}” został użyty w niejednolitym utworzeniu wystąpienia przed tym punktem programu. Rozważ zmianę kolejności elementów członkowskich, aby ten element członkowski występował jako pierwszy. Możesz też jawnie określić pełny typ elementu członkowskiego, łącznie z typami argumentów, zwracanym typem i wszelkimi dodatkowymi ogólnymi parametrami i ograniczeniami.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttribArgsDiffer">
        <source>The attribute '{0}' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.</source>
        <target state="translated">Atrybut „{0}” występuje w implementacji i sygnaturze, ale argumenty atrybutu różnią się między sobą. W kompilowanym kodzie zostanie uwzględniony tylko atrybut z sygnatury.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallAbstractBaseMember">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">Nie można wywołać abstrakcyjnego podstawowego elementu członkowskiego: „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInUnmanaged">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position</source>
        <target state="translated">Nie można usunąć niejednoznaczności w przypadku użycia konstrukcji ogólnej z ograniczeniem „unmanaged” w tym miejscu lub w jego pobliżu</target>
        <note />
      </trans-unit>
      <trans-unit id="mlCompatMessage">
        <source>This construct is for ML compatibility. {0}. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'.</source>
        <target state="translated">Ta konstrukcja zapewnia zgodność z językiem ML. {0}. Możesz wyłączyć to ostrzeżenie, używając opcji „--mlcompatibility” lub opcji „--nowarn:62”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldDoesNotHaveValidOffsetForStructureLayout">
        <source>The type '{0}' has been marked as having an Explicit layout, but the field '{1}' has not been marked with the 'FieldOffset' attribute</source>
        <target state="translated">Typ „{0}” został oznaczony jako mający układ Explicit, ale pole „{1}” nie zostało oznaczone za pomocą atrybutu „FieldOffset”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfacesShouldUseInheritNotInterface">
        <source>Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'</source>
        <target state="translated">Interfejsy dziedziczone przez inne interfejsy powinny być deklarowane przy użyciu ciągu „inherit ...” zamiast ciągu „interface ...”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperator">
        <source>Invalid prefix operator</source>
        <target state="translated">Nieprawidłowy operator prefiksu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperatorDefinition">
        <source>Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.</source>
        <target state="translated">Nieprawidłowa definicja operatora. Definicje operatora prefiksu muszą używać prawidłowej nazwy operatora prefiksu.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCompilingExtensionIsForML">
        <source>The file extensions '.ml' and '.mli' are for ML compatibility</source>
        <target state="translated">Rozszerzenia pliku „ml” i „mli” są używane na potrzeby zgodności z językiem ML</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIndentOffForML">
        <source>Consider using a file with extension '.ml' or '.mli' instead</source>
        <target state="translated">Rozważ użycie pliku z rozszerzeniem „ml” lub „mli”</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternIdentIsNotFunctionTyped">
        <source>Active pattern '{0}' is not a function</source>
        <target state="translated">Aktywny wzorzec „{0}” nie jest funkcją</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternChoiceHasFreeTypars">
        <source>Active pattern '{0}' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</source>
        <target state="translated">Aktywny wzorzec „{0}” ma typ wyniku zawierający zmienne typu, które nie są określone przez dane wejściowe. Częstą przyczyną jest brak podanego przypadku wyniku, np. „let (|A|B|) (x:int) = A x”. Można to naprawić za pomocą ograniczenia typu, np. „let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x”</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldHasOffsetForSequentialLayout">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">Atrybut FieldOffset można umieścić tylko w składowych o typie oznaczonym przy użyciu atrybutu StructLayout(LayoutKind.Explicit).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsMustComeAfterNonOptionalArgs">
        <source>Optional arguments must come at the end of the argument list, after any non-optional arguments</source>
        <target state="translated">Argumenty opcjonalne muszą występować na końcu listy argumentów po argumentach nieopcjonalnych</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeUsage">
        <source>Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes</source>
        <target state="translated">Atrybut „System.Diagnostics.ConditionalAttribute” jest prawidłowy tylko w przypadku metod lub klas atrybutów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOperatorDefinitionInExtrinsic">
        <source>Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.</source>
        <target state="translated">Elementy członkowskie rozszerzeń nie mogą udostępniać przeciążeń operatorów. Zamiast tego rozważ zdefiniowanie operatora jako części definicji typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBFileNameCannotBeChangedWarning">
        <source>The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.</source>
        <target state="translated">Plik MDB musi mieć nazwę &lt;nazwa-pliku-zestawu&gt;.mdb. Opcja --pdb zostanie zignorowana.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBMemberMissing">
        <source>MDB generation failed. Could not find compatible member {0}</source>
        <target state="translated">Generowanie pliku MDB nie powiodło się. Nie można znaleźć zgodnego elementu członkowskiego {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingMdb">
        <source>Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly.</source>
        <target state="translated">Nie można wygenerować informacji o debugowaniu pliku MDB. Nie można załadować typu „MonoSymbolWriter” z zestawu „Mono.CompilerServices.SymbolWriter.dll”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseNameConflictsWithGeneratedType">
        <source>The union case named '{0}' conflicts with the generated type '{1}'</source>
        <target state="translated">Przypadek unii o nazwie „{0}” powoduje konflikt z wygenerowanym typem „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoReflectedDefinitionOnStructMember">
        <source>ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter</source>
        <target state="translated">Atrybut ReflectedDefinitionAttribute nie może być stosowany do elementu członkowskiego wystąpienia w typie struktury, ponieważ element członkowski wystąpienia pobiera niejawny parametr „this” typu byref</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportNotAllowed">
        <source>DLLImport bindings must be static members in a class or function definitions in a module</source>
        <target state="translated">Powiązania DLLImport muszą być statycznymi elementami członkowskimi w definicjach klas lub funkcji w module</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedSigdataFile">
        <source>FSharp.Core.sigdata not found alongside FSharp.Core. File expected in {0}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">Nie znaleziono zasobu FSharp.Core.sigdata z plikiem FSharp.Core. Plik oczekiwany w {0}. Rozważ uaktualnienie do nowszej wersji pliku FSharp.Core, w której ten plik nie jest już wymagany.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedFileAlongSideFSharpCore">
        <source>File '{0}' not found alongside FSharp.Core. File expected in {1}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">Nie znaleziono pliku „{0}” z plikiem FSharp.Core. Plik oczekiwany w {1}. Rozważ uaktualnienie do nowszej wersji pliku FSharp.Core, w której ten plik nie jest już wymagany.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedFileNameCharacter">
        <source>Filename '{0}' contains invalid character '{1}'</source>
        <target state="translated">Nazwa pliku „{0}” zawiera nieprawidłowy znak „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBinding">
        <source>'use!' bindings must be of the form 'use! &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">Powiązania „use!” muszą mieć format „use! &lt;zmienna&gt; = &lt;wyrażenie&gt;”</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoInnerGenericsInQuotations">
        <source>Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.</source>
        <target state="translated">Wewnętrzne funkcje ogólne są niedozwolone w wyrażeniach cytowanych. Rozważ dodanie ograniczeń typów, tak aby ta funkcja nie była już ogólna.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumTypeCannotBeEnumerated">
        <source>The type '{0}' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property</source>
        <target state="translated">Typ „{0}” nie jest prawidłowym typem modułu wyliczającego, czyli nie zawiera metody „MoveNext()” zwracającej wartość logiczną i właściwości „Current”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteString">
        <source>End of file in triple-quote string begun at or before here</source>
        <target state="translated">Koniec pliku w ciągu z potrójnym cudzysłowem rozpoczętym w tym miejscu lub przed nim</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteStringInComment">
        <source>End of file in triple-quote string embedded in comment begun at or before here</source>
        <target state="translated">Koniec pliku w ciągu z potrójnym cudzysłowem osadzonym w komentarzu rozpoczętym w tym miejscu lub przed nim</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLosesMeasures">
        <source>This type test or downcast will ignore the unit-of-measure '{0}'</source>
        <target state="translated">Ten test typu lub to przypisanie elementu podrzędnego zignoruje jednostkę miary „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingTypeArgs">
        <source>Expected type argument or static argument</source>
        <target state="translated">Oczekiwano argumentu typu lub argumentu statycznego</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingGreaterThan">
        <source>Unmatched '&lt;'. Expected closing '&gt;'</source>
        <target state="translated">Niedopasowany znak „&lt;”. Oczekiwano znaku zamykającego „&gt;”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
        <source>Unexpected quotation operator '&lt;@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '&lt;' and '@' characters.</source>
        <target state="translated">Nieoczekiwany operator cytatu „&lt;@” w definicji typu. Jeśli chcesz przekazać ciąg dosłownego wyrażenia jako argument statyczny do dostawcy typów, wstaw odstęp między znakami „&lt;” i „@”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorParsingAsOperatorName">
        <source>Attempted to parse this as an operator name, but failed</source>
        <target state="translated">Podjęto próbę analizy tego elementu jako nazwy operatora, ale analiza nie powiodła się</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidUnicodeLiteral">
        <source>\U{0} is not a valid Unicode character escape sequence</source>
        <target state="translated">\U{0} nie jest prawidłową sekwencją znaku ucieczki Unicode</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoWrongType">
        <source>'{0}' must be applied to an argument of type '{1}', but has been applied to an argument of type '{2}'</source>
        <target state="translated">Element „{0}” należy zastosować do argumentu typu „{1}”, jednak został on zastosowany do argumentu typu „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoNotOptional">
        <source>'{0}' can only be applied to optional arguments</source>
        <target state="translated">Element „{0}” można stosować tylko do argumentów opcjonalnych</target>
        <note />
      </trans-unit>
      <trans-unit id="toolLocationHelperUnsupportedFrameworkVersion">
        <source>The specified .NET Framework version '{0}' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
        <target state="translated">Określona wersja platformy .NET Framework „{0}” nie jest obsługiwana. Określ wartość z wyliczenia Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidMagicValue">
        <source>Invalid Magic value in CLR Header</source>
        <target state="translated">Nieprawidłowa wartość magiczna w nagłówku CLR</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignBadImageFormat">
        <source>Bad image format</source>
        <target state="translated">Nieprawidłowy format obrazu</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignPrivateKeyExpected">
        <source>Private key expected</source>
        <target state="translated">Oczekiwano klucza prywatnego</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignRsaKeyExpected">
        <source>RSA key expected</source>
        <target state="translated">Oczekiwano klucza RSA</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidBitLen">
        <source>Invalid bit Length</source>
        <target state="translated">Nieprawidłowa długość bitowa</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidRSAParams">
        <source>Invalid RSAParameters structure - '{{0}}' expected</source>
        <target state="translated">Nieprawidłowa struktura elementu RSAParameters — oczekiwano „{{0}}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidAlgId">
        <source>Invalid algId - 'Exponent' expected</source>
        <target state="translated">Nieprawidłowy element algId — oczekiwano wartości „Exponent”</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidSignatureSize">
        <source>Invalid signature size</source>
        <target state="translated">Nieprawidłowy rozmiar sygnatury</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignNoSignatureDirectory">
        <source>No signature directory</source>
        <target state="translated">Nie ma katalogu sygnatury</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidPKBlob">
        <source>Invalid Public Key blob</source>
        <target state="translated">Nieprawidłowy obiekt blob klucza publicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTooManyErrors">
        <source>Exiting - too many errors</source>
        <target state="translated">Zakończenie — zbyt wiele błędów</target>
        <note />
      </trans-unit>
      <trans-unit id="docfileNoXmlSuffix">
        <source>The documentation file has no .xml suffix</source>
        <target state="translated">Plik dokumentacji nie ma sufiksu xml</target>
        <note />
      </trans-unit>
      <trans-unit id="fscNoImplementationFiles">
        <source>No implementation files specified</source>
        <target state="translated">Nie określono żadnych plików implementacji</target>
        <note />
      </trans-unit>
      <trans-unit id="fscBadAssemblyVersion">
        <source>The attribute {0} specified version '{1}', but this value is invalid and has been ignored</source>
        <target state="translated">Atrybut {0} określił wersję „{1}”, ale ta wartość jest nieprawidłowa i została zignorowana</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTwoResourceManifests">
        <source>Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used.</source>
        <target state="translated">Podano opcje powodujące konflikt: „win32manifest” i „win32res”. Może zostać użyta tylko jedna z nich.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking">
        <source>The code in assembly '{0}' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">Kod w zestawie „{0}” używa literałów cytatu. Statyczne połączenie nie może obejmować składników, które używają literałów cytatu, chyba że wszystkie zestawy są kompilowane przy użyciu języka F# w wersji co najmniej 4.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking0">
        <source>Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">Kod w tym zestawie używa literałów cytatu. Statyczne połączenie nie może obejmować składników, które używają literałów cytatu, chyba że wszystkie zestawy są kompilowane przy użyciu języka F# w wersji co najmniej 4.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoEXE">
        <source>Static linking may not include a .EXE</source>
        <target state="translated">Łączenie statyczne nie może obejmować pliku EXE</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoMixedDLL">
        <source>Static linking may not include a mixed managed/unmanaged DLL</source>
        <target state="translated">Statyczne łączenie nie może obejmować mieszanej biblioteki zarządzanej/niezarządzanej DLL</target>
        <note />
      </trans-unit>
      <trans-unit id="fscIgnoringMixedWhenLinking">
        <source>Ignoring mixed managed/unmanaged assembly '{0}' during static linking</source>
        <target state="translated">Ignorowanie mieszanego zestawu zarządzanego/niezarządzanego „{0}” podczas statycznego łączenia</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssumeStaticLinkContainsNoDependencies">
        <source>Assembly '{0}' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.</source>
        <target state="translated">Do zestawu „{0}” wystąpiło odwołanie przechodnie i nie można automatycznie rozpoznać zestawu. W przypadku statycznego łączenia zostanie przyjęte, że ta biblioteka DLL nie ma żadnych zależności od biblioteki języka F# lub innych statycznie połączonych bibliotek DLL. Rozważ dodanie jawnego odwołania do tej biblioteki DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyNotFoundInDependencySet">
        <source>Assembly '{0}' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.</source>
        <target state="translated">Nie znaleziono zestawu „{0}” w zestawie zależności docelowych danych binarnych. Statycznie połączone elementy główne powinny być określone przy użyciu nazwy zestawu bez rozszerzenia DLL lub EXE. Jeśli do tego zestawu wystąpiło jawne odwołanie, możliwe jest, że zestaw nie był w rzeczywistości wymagany przez wygenerowane dane binarne. W takim przypadku nie powinny być statycznie połączone.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileCouldNotBeOpened">
        <source>The key file '{0}' could not be opened</source>
        <target state="translated">Nie można otworzyć pliku klucza „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="fscProblemWritingBinary">
        <source>A problem occurred writing the binary '{0}': {1}</source>
        <target state="translated">Wystąpił problem podczas zapisywania danych binarnych „{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyVersionAttributeIgnored">
        <source>The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option</source>
        <target state="translated">Element „AssemblyVersionAttribute” został zignorowany, ponieważ wersję podano przy użyciu opcji wiersza polecenia</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyCultureAttributeError">
        <source>Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'</source>
        <target state="translated">Błąd podczas emitowania atrybutu „System.Reflection.AssemblyCultureAttribute” -- „Pliki wykonywalne nie mogą być zestawami satelickimi. Kultura zawsze powinna być pusta”</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDelaySignWarning">
        <source>Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module</source>
        <target state="translated">Opcja „--delaysign” przesłania atrybut „System.Reflection.AssemblyDelaySignAttribute” podany w pliku źródłowym lub dodanym module</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileWarning">
        <source>Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module</source>
        <target state="translated">Opcja „--keyfile” przesłania atrybut „System.Reflection.AssemblyKeyFileAttribute” podany w pliku źródłowym lub dodanym module</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyNameWarning">
        <source>Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module</source>
        <target state="translated">Opcja „--keycontainer” przesłania atrybut „System.Reflection.AssemblyNameAttribute” podany w pliku źródłowym lub dodanym module</target>
        <note />
      </trans-unit>
      <trans-unit id="fscReferenceOnCommandLine">
        <source>The assembly '{0}' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'.</source>
        <target state="translated">Zestaw „{0}” wyszczególniono w wierszu polecenia. Odwołania do zestawów powinny być tworzone przy użyciu flagi wiersza polecenia, takiej jak „-r”.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscRemotingError">
        <source>The resident compilation service was not used because a problem occured in communicating with the server.</source>
        <target state="translated">Rezydentna usługa kompilacji nie została użyta, ponieważ wystąpił problem z komunikowaniem się z serwerem.</target>
        <note />
      </trans-unit>
      <trans-unit id="pathIsInvalid">
        <source>Problem with filename '{0}': Illegal characters in path.</source>
        <target state="translated">Problem z nazwą pliku „{0}”: niedozwolone znaki w ścieżce.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscResxSourceFileDeprecated">
        <source>Passing a .resx file ({0}) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.</source>
        <target state="translated">Przekazywanie pliku resx ({0}) jako pliku źródłowego do kompilatora jest przestarzałe. Użyj programu resgen.exe, aby przekształcić plik resx w plik resources w celu przekazania go w opcji --resource. Jeśli używasz narzędzia MSBuild, można to zrobić za pośrednictwem elementu &lt;EmbeddedResource&gt; w pliku projektu fsproj.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoProfileMismatches">
        <source>Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).</source>
        <target state="translated">Nie można użyć łączenia statycznego w przypadku zestawu przywołującego bibliotekę mscorlib (np. zestaw programu .NET Framework) podczas generowania zestawu przywołującego element System.Runtime (np. zestaw programu .NET Core lub przenośny).</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyWildcardAndDeterminism">
        <source>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</source>
        <target state="translated">Element {0} określił wersję „{1}”, ale wartość jest symbolem wieloznacznym. Żądano kompilacji deterministycznej. Te wartości powodują konflikt.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDeterministicDebugRequiresPortablePdb">
        <source>Deterministic builds only support portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">Deterministyczne kompilacje obsługują tylko przenośne pliki PDB (--debug:portable lub --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInNamespaceName">
        <source>Character '{0}' is not allowed in provided namespace name '{1}'</source>
        <target state="translated">Znak „{0}” jest niedozwolony w podanej nazwie przestrzeni nazw „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullOrEmptyMemberName">
        <source>The provided type '{0}' returned a member with a null or empty member name</source>
        <target state="translated">Udostępniony typ „{0}” zwrócił element członkowski z wartością null lub pustą nazwą elementu członkowskiego</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMember">
        <source>The provided type '{0}' returned a null member</source>
        <target state="translated">Udostępniony typ „{0}” zwrócił element członkowski o wartości null</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringType">
        <source>The provided type '{0}' member info '{1}' has null declaring type</source>
        <target state="translated">Informacje elementu członkowskiego „{1}” udostępnionego typu „{0}” mają typ deklarujący o wartości null</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringTypeDifferentFromProvidedType">
        <source>The provided type '{0}' has member '{1}' which has declaring type '{2}'. Expected declaring type to be the same as provided type.</source>
        <target state="translated">Udostępniony typ „{0}” ma element członkowski „{1}” z typem deklarującym „{2}”. Oczekiwano, że typ deklarujący będzie taki sam jak udostępniony typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="etHostingAssemblyFoundWithoutHosts">
        <source>Referenced assembly '{0}' has assembly level attribute '{1}' but no public type provider classes were found</source>
        <target state="translated">Zestaw „{0}”, którego dotyczy odwołanie, ma atrybut poziomu zestawu „{1}”, ale nie znaleziono publicznych klas dostawcy typów</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceOfTypeNotAllowed">
        <source>Type '{0}' from type provider '{1}' has an empty namespace. Use 'null' for the global namespace.</source>
        <target state="translated">Typ „{0}” od dostawcy typów „{1}” ma pustą przestrzeń nazw. Użyj wartości „null” dla globalnej przestrzeni nazw.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceNotAllowed">
        <source>Empty namespace found from the type provider '{0}'. Use 'null' for the global namespace.</source>
        <target state="translated">Znaleziono pustą przestrzeń nazw od dostawcy typów „{0}”. Użyj wartości „null” dla globalnej przestrzeni nazw.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeGeneric">
        <source>Provided type '{0}' has 'IsGenericType' as true, but generic types are not supported.</source>
        <target state="translated">Udostępniony typ „{0}” ma właściwość „IsGenericType” o wartości true, ale typy ogólne nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeAnArray">
        <source>Provided type '{0}' has 'IsArray' as true, but array types are not supported.</source>
        <target state="translated">Udostępniony typ „{0}” ma właściwość „IsArray” o wartości true, ale typy tablicy nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMethodHasRequirements">
        <source>Invalid member '{0}' on provided type '{1}'. Provided type members must be public, and not be generic, virtual, or abstract.</source>
        <target state="translated">Nieprawidłowy element członkowski „{0}” w udostępnionym typie „{1}”. Elementy członkowskie udostępnionego typu muszą być publiczne, a nie ogólne, wirtualne lub abstrakcyjne.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedMemberKind">
        <source>Invalid member '{0}' on provided type '{1}'. Only properties, methods and constructors are allowed</source>
        <target state="translated">Nieprawidłowy element członkowski „{0}” w udostępnionym typie „{1}”. Dozwolone są tylko właściwości, metody i konstruktory</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanReadButHasNoGetter">
        <source>Property '{0}' on provided type '{1}' has CanRead=true but there was no value from GetGetMethod()</source>
        <target state="translated">Właściwość „{0}” w udostępnionym typie „{1}” ma właściwość CanRead=true, ale brakuje wartości z metody GetGetMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasGetterButNoCanRead">
        <source>Property '{0}' on provided type '{1}' has CanRead=false but GetGetMethod() returned a method</source>
        <target state="translated">Właściwość „{0}” w udostępnionym typie „{1}” ma właściwość CanRead=false, ale metoda GetGetMethod() zwróciła metodę</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanWriteButHasNoSetter">
        <source>Property '{0}' on provided type '{1}' has CanWrite=true but there was no value from GetSetMethod()</source>
        <target state="translated">Właściwość „{0}” w udostępnionym typie „{1}” ma właściwość CanWrite=true, ale brakuje wartości z metody GetSetMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasSetterButNoCanWrite">
        <source>Property '{0}' on provided type '{1}' has CanWrite=false but GetSetMethod() returned a method</source>
        <target state="translated">Właściwość „{0}” w udostępnionym typie „{1}” ma właściwość CanWrite=false, ale metoda GetSetMethod() zwróciła metodę</target>
        <note />
      </trans-unit>
      <trans-unit id="etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
        <source>One or more errors seen during provided type setup</source>
        <target state="translated">Podczas konfigurowania udostępnionych typów napotkano co najmniej jeden błąd</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedTypeMember">
        <source>Unexpected exception from provided type '{0}' member '{1}': {2}</source>
        <target state="translated">Nieoczekiwany wyjątek udostępnionego typu „{0}”. Element członkowski: „{1}”: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedConstantType">
        <source>Unsupported constant type '{0}'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal.</source>
        <target state="translated">Nieobsługiwany typ stałej „{0}”. Cytowania udostępniane przez dostawców typu mogą zawierać tylko proste stałe. Implementacja dostawcy typu może wymagać dostosowania przez przeniesienie wartości zadeklarowanej poza udostępnionym literałem cytowania w celu utworzenia powiązania typu „let” wewnątrz literału cytowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedProvidedExpression">
        <source>Unsupported expression '{0}' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.</source>
        <target state="translated">Nieobsługiwane wyrażenie „{0}” z dostawcy typów. Jeśli ten dostawca typów jest Twojego autorstwa, rozważ dostosowanie go w celu zapewnienia innego udostępnionego wyrażenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedName">
        <source>Expected provided type named '{0}' but provided type has 'Name' with value '{1}'</source>
        <target state="translated">Oczekiwano udostępnionego typu o nazwie „{0}”, ale udostępniony typ ma właściwość Name o wartości „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoAdd">
        <source>Event '{0}' on provided type '{1}' has no value from GetAddMethod()</source>
        <target state="translated">Zdarzenie „{0}” w udostępnionym typie „{1}” nie ma wartości z metody GetAddMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoRemove">
        <source>Event '{0}' on provided type '{1}' has no value from GetRemoveMethod()</source>
        <target state="translated">Zdarzenie „{0}” w udostępnionym typie „{1}” nie ma wartości z metody GetRemoveMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssembly">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded from path '{2}'. The exception reported was: {3} - {4}</source>
        <target state="translated">Atrybut zestawu „{0}” odwołuje się do zestawu projektanta „{1}”, którego nie można załadować ze ścieżki „{2}”. Zgłoszony wyjątek: {3} — {4}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderDoesNotHaveValidConstructor">
        <source>The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected.</source>
        <target state="translated">Dostawca typów nie ma prawidłowego konstruktora. Oczekiwano konstruktora, który nie pobiera argumentów lub pobiera jeden argument typu „TypeProviderConfig”.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderError">
        <source>The type provider '{0}' reported an error: {1}</source>
        <target state="translated">Dostawca typów „{0}” zgłosił błąd: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectParameterExpression">
        <source>The type provider '{0}' used an invalid parameter in the ParameterExpression: {1}</source>
        <target state="translated">Dostawca typów „{0}” użył nieprawidłowego parametru w elemencie ParameterExpression: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedMethod">
        <source>The type provider '{0}' provided a method with a name '{1}' and metadata token '{2}', which is not reported among its methods of its declaring type '{3}'</source>
        <target state="translated">Dostawca typów „{0}” udostępnił metodę o nazwie „{1}” i token metadanych „{2}”, które nie zostały zgłoszone wśród metod dostawcy jego typu deklarującego „{3}”</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedConstructor">
        <source>The type provider '{0}' provided a constructor which is not reported among the constructors of its declaring type '{1}'</source>
        <target state="translated">Dostawca typów „{0}” udostępnił konstruktor, który nie został zgłoszony wśród konstruktorów jego typu deklarującego „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="etDirectReferenceToGeneratedTypeNotAllowed">
        <source>A direct reference to the generated type '{0}' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = &lt;path&gt;'. This indicates that a type provider adds generated types to your assembly.</source>
        <target state="translated">Bezpośrednie odwołanie do wygenerowanego typu „{0}” nie jest dozwolone. Zamiast tego użyj definicji typu, np. „type TypeAlias = &lt;ścieżka&gt;”. Wskazuje to, że dostawca typów dodaje wygenerowane typy do używanego zestawu.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedPath">
        <source>Expected provided type with path '{0}' but provided type has path '{1}'</source>
        <target state="translated">Oczekiwano udostępnionego typu ze ścieżką „{0}”, ale udostępniony typ ma ścieżkę „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedNullFromProvidedTypeMember">
        <source>Unexpected 'null' return value from provided type '{0}' member '{1}'</source>
        <target state="translated">Nieoczekiwana wartość zwracana „null” udostępnionego typu „{0}”. Element członkowski: „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedMemberMember">
        <source>Unexpected exception from member '{0}' of provided type '{1}' member '{2}': {3}</source>
        <target state="translated">Nieoczekiwany wyjątek elementu członkowskiego „{0}” udostępnionego typu „{1}”. Element członkowski: „{2}”: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
        <source>Nested provided types do not take static arguments or generic parameters</source>
        <target state="translated">Udostępnione typy zagnieżdżone nie pobierają argumentów statycznych lub parametrów ogólnych</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidStaticArgument">
        <source>Invalid static argument to provided type. Expected an argument of kind '{0}'.</source>
        <target state="translated">Nieprawidłowy argument statyczny udostępnionego typu. Oczekiwano argumentu rodzaju: „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToType">
        <source>An error occured applying the static arguments to a provided type</source>
        <target state="translated">Wystąpił błąd podczas stosowania argumentów statycznych do udostępnionego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnknownStaticArgumentKind">
        <source>Unknown static argument kind '{0}' when resolving a reference to a provided type or method '{1}'</source>
        <target state="translated">Nieznany rodzaj argumentu statycznego „{0}” podczas rozpoznawania odwołania do podanego typu lub podanej metody „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidNamespaceForProvidedType">
        <source>invalid namespace for provided type</source>
        <target state="translated">nieprawidłowa przestrzeń nazw udostępnionego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidFullNameForProvidedType">
        <source>invalid full name for provided type</source>
        <target state="translated">nieprawidłowa pełna nazwa udostępnionego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderReturnedNull">
        <source>The type provider returned 'null', which is not a valid return value from '{0}'</source>
        <target state="translated">Dostawca typów zwrócił wartość „null”, która nie jest prawidłową wartością zwracaną z „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="etTypeProviderConstructorException">
        <source>The type provider constructor has thrown an exception: {0}</source>
        <target state="translated">Konstruktor dostawcy typów zgłosił wyjątek: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullProvidedExpression">
        <source>Type provider '{0}' returned null from GetInvokerExpression.</source>
        <target state="translated">Dostawca typów „{0}” zwrócił wartość null z metody GetInvokerExpression.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedTypeHadWrongName">
        <source>The type provider '{0}' returned an invalid type from 'ApplyStaticArguments'. A type with name '{1}' was expected, but a type with name '{2}' was returned.</source>
        <target state="translated">Dostawca typów „{0}” zwrócił nieprawidłowy typ z metody „ApplyStaticArguments”. Oczekiwano typu o nazwie „{1}”, ale został zwrócony typ o nazwie „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedMethodHadWrongName">
        <source>The type provider '{0}' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '{1}' was expected, but a method with name '{2}' was returned.</source>
        <target state="translated">Dostawca typów „{0}” zwrócił nieprawidłową metodę z funkcji „ApplyStaticArgumentsForMethod”. Oczekiwano metody o nazwie „{1}”, lecz zwrócono metodę o nazwie „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLossy">
        <source>This type test or downcast will erase the provided type '{0}' to the type '{1}'</source>
        <target state="translated">Ten test typu lub to przypisanie elementu podrzędnego spowoduje wymazanie podanego typu „{0}” w typie „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCastErased">
        <source>This downcast will erase the provided type '{0}' to the type '{1}'.</source>
        <target state="translated">To przypisanie elementu podrzędnego spowoduje wymazanie podanego typu „{0}” w typie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestErased">
        <source>This type test with a provided type '{0}' is not allowed because this provided type will be erased to '{1}' at runtime.</source>
        <target state="translated">Ten test typu z udostępnionym typem „{0}” nie jest dozwolony, ponieważ ten udostępniony typ zostanie wymazany do typu „{1}” w środowisku uruchomieniowym.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromErasedType">
        <source>Cannot inherit from erased provided type</source>
        <target state="translated">Nie można dziedziczyć po dostarczonym wymazanym typie</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidTypeProviderAssemblyName">
        <source>Assembly '{0}' hase TypeProviderAssembly attribute with invalid value '{1}'. The value should be a valid assembly name</source>
        <target state="translated">Zestaw „{0}” ma atrybut TypeProviderAssembly z nieprawidłową wartością „{1}”. Wartość powinna być prawidłową nazwą zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameCtor">
        <source>Invalid member name. Members may not have name '.ctor' or '.cctor'</source>
        <target state="translated">Nieprawidłowa nazwa elementu członkowskiego. Elementy członkowskie nie mogą mieć nazw „.ctor” i „.cctor”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInferredGenericTypeGivesRiseToInconsistency">
        <source>The function or member '{0}' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '{1}'.</source>
        <target state="translated">Element członkowski funkcji „{0}” jest używany w sposób wymagający dodatkowych adnotacji typów w definicji w celu zapewnienia spójności wywnioskowanych typów. Wywnioskowana sygnatura: „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentCount">
        <source>The number of type arguments did not match: '{0}' given, '{1}' expected. This may be related to a previously reported error.</source>
        <target state="translated">Liczba argumentów typu nie jest zgodna. Podana liczba: „{0}”; oczekiwana liczba: „{1}”. Może to być związane z wcześniej zgłoszonym błędem.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotOverrideSealedMethod">
        <source>Cannot override inherited member '{0}' because it is sealed</source>
        <target state="translated">Nie można przesłonić dziedziczonego elementu członkowskiego „{0}”, ponieważ jest on zapieczętowany</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderErrorWithContext">
        <source>The type provider '{0}' reported an error in the context of provided type '{1}', member '{2}'. The error: {3}</source>
        <target state="translated">Dostawca typów „{0}” zgłosił błąd w kontekście udostępnionego typu „{1}”. Element członkowski: „{2}”. Błąd: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNameException">
        <source>An exception occurred when accessing the '{0}' of a provided type: {1}</source>
        <target state="translated">Wystąpił wyjątek podczas uzyskiwania dostępu do elementu „{0}” udostępnionego typu: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNullOrEmptyName">
        <source>The '{0}' of a provided type was null or empty.</source>
        <target state="translated">Nazwa „{0}” udostępnionego typu miała wartość null lub była pusta.</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInTypeName">
        <source>Character '{0}' is not allowed in provided type name '{1}'</source>
        <target state="translated">Znak „{0}” jest niedozwolony w nazwie udostępnionego typu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcJoinMustUseSimplePattern">
        <source>In queries, '{0}' must use a simple pattern</source>
        <target state="translated">W zapytaniach element „{0}” musi używać prostego wzorca</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMissingCustomOperation">
        <source>A custom query operation for '{0}' is required but not specified</source>
        <target state="translated">Wymagana jest niestandardowa operacja zapytania „{0}”, ale jej nie określono</target>
        <note />
      </trans-unit>
      <trans-unit id="etBadUnnamedStaticArgs">
        <source>Named static arguments must come after all unnamed static arguments</source>
        <target state="translated">Nazwane argumenty statyczne muszą następować po wszystkich nienazwanych argumentach statycznych</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterRequiresAValue">
        <source>The static parameter '{0}' of the provided type or method '{1}' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '{2}&lt;{3}=...&gt;'.</source>
        <target state="translated">Parametr statyczny „{0}” podanego typu lub podanej metody „{1}” wymaga wartości. Parametry statyczne dostawców typów mogą być opcjonalnie określane przy użyciu argumentów nazwanych, np. „{2}&lt;{3}=...&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNoStaticParameterWithName">
        <source>No static parameter exists with name '{0}'</source>
        <target state="translated">Nie istnieje parametr statyczny o nazwie „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterAlreadyHasValue">
        <source>The static parameter '{0}' has already been given a value</source>
        <target state="translated">Została już podana wartość parametru statycznego „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="etMultipleStaticParameterWithName">
        <source>Multiple static parameters exist with name '{0}'</source>
        <target state="translated">Istnieje wiele parametrów statycznych o nazwie „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
        <source>A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression</source>
        <target state="translated">Operacja niestandardowa nie może być używana razem z powiązaniem „let” bez wartości lub cyklicznym powiązaniem „let” w innej części tego wyrażenia obliczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedHere">
        <source>A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression</source>
        <target state="translated">Operacja niestandardowa nie może być używana razem z operatorem „use”, „try/with”, „try/finally”, „if/then/else” lub „match” w tym wyrażeniu obliczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeOverloaded">
        <source>The custom operation '{0}' refers to a method which is overloaded. The implementations of custom operations may not be overloaded.</source>
        <target state="translated">Operacja niestandardowa „{0}” odwołuje się do przeciążonej metody. Implementacje operacji niestandardowych nie mogą być przeciążone.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIfThenElseMayNotBeUsedWithinQueries">
        <source>An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.</source>
        <target state="translated">Wyrażenie if/then/else nie może być używane w zapytaniach. Zamiast tego rozważ użycie wyrażenia if/then lub wyrażenia sekwencji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
        <source>Invalid argument to 'methodhandleof' during codegen</source>
        <target state="translated">Nieprawidłowy argument dla „methodhandleof” podczas generowania kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceMissingArgument">
        <source>A reference to a provided type was missing a value for the static parameter '{0}'. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">W odwołaniu do udostępnionego typu brakuje wartości parametru statycznego „{0}”. Może być konieczne ponowne skompilowanie co najmniej jednego zestawu, do którego występuje odwołanie.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceInvalidText">
        <source>A reference to a provided type had an invalid value '{0}' for a static parameter. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">Odwołanie do udostępnionego typu miało nieprawidłową wartość „{0}” parametru statycznego. Może być konieczne ponowne skompilowanie co najmniej jednego zestawu, do którego występuje odwołanie.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly">
        <source>'{0}' is not used correctly. This is a custom operation in this query or computation expression.</source>
        <target state="translated">Operacja „{0}” nie jest używana poprawnie. Jest to operacja niestandardowa w tym zapytaniu lub wyrażeniu obliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly2">
        <source>'{0}' is not used correctly. Usage: {1}. This is a custom operation in this query or computation expression.</source>
        <target state="translated">Operacja „{0}” nie jest używana poprawnie. Użycie: {1}. Jest to operacja niestandardowa w tym zapytaniu lub wyrażeniu obliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeJoin">
        <source>{0} var in collection {1} (outerKey = innerKey). Note that parentheses are required after '{2}'</source>
        <target state="translated">{0} zmienna in kolekcja {1} (klucz_zewnętrzny = klucz_wewnętrzny). Pamiętaj, że po „{2}” wymagane są nawiasy.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeGroupJoin">
        <source>{0} var in collection {1} (outerKey = innerKey) into group. Note that parentheses are required after '{2}'</source>
        <target state="translated">{0} zmienna in kolekcja {1} (klucz_zewnętrzny = klucz_wewnętrzny) into grupa. Pamiętaj, że po „{2}” wymagane są nawiasy.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeZip">
        <source>{0} var in collection</source>
        <target state="translated">{0} zmienna in kolekcja</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresVariable">
        <source>'{0}' must be followed by a variable name. Usage: {1}.</source>
        <target state="translated">Element „{0}” musi występować przed nazwą zmiennej. Użycie: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorIncorrectSyntax">
        <source>Incorrect syntax for '{0}'. Usage: {1}.</source>
        <target state="translated">Niepoprawna składnia operatora „{0}”. Użycie: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresBody">
        <source>'{0}' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... {1} ...</source>
        <target state="translated">Element „{0}” musi występować po klauzuli wyboru „for” i przed pozostałą częścią zapytania. Składnia: ... {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationHasIncorrectArgCount">
        <source>'{0}' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected {1} argument(s), but given {2}.</source>
        <target state="translated">Element „{0}” jest używany z niepoprawną liczbą argumentów. Jest to niestandardowa operacja w tym zapytaniu lub wyrażeniu obliczenia. Oczekiwana liczba argumentów: {1}. Rzeczywista liczba argumentów: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterToken">
        <source>Expected an expression after this point</source>
        <target state="translated">Oczekiwano wyrażenia po tym punkcie</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedTypeAfterToken">
        <source>Expected a type after this point</source>
        <target state="translated">Oczekiwano typu po tym punkcie</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLBrackLess">
        <source>Unmatched '[&lt;'. Expected closing '&gt;]'</source>
        <target state="translated">Niedopasowany element „[&lt;”. Oczekiwano elementu zamykającego „&gt;]”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileMatch">
        <source>Unexpected end of input in 'match' expression. Expected 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</source>
        <target state="translated">Nieoczekiwane zakończenie danych wejściowych w wyrażeniu „match”. Oczekiwano konstrukcji „match &lt;wyrażenie&gt; with | &lt;wzorzec&gt; -&gt; &lt;wyrażenie&gt; | &lt;wzorzec&gt; -&gt; &lt;wyrażenie&gt; ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTry">
        <source>Unexpected end of input in 'try' expression. Expected 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;'.</source>
        <target state="translated">Nieoczekiwane zakończenie danych wejściowych w wyrażeniu „try”. Oczekiwano konstrukcji „try &lt;wyrażenie&gt; with &lt;reguły&gt;” lub „try &lt;wyrażenie&gt; finally &lt;wyrażenie&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWhile">
        <source>Unexpected end of input in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Nieoczekiwane zakończenie danych wejściowych w wyrażeniu „while”. Oczekiwano konstrukcji „while &lt;wyrażenie&gt; do &lt;wyrażenie&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFor">
        <source>Unexpected end of input in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Nieoczekiwane zakończenie danych wejściowych w wyrażeniu „for”. Oczekiwano konstrukcji „for &lt;wzorzec&gt; in &lt;wyrażenie&gt; do &lt;wyrażenie&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWith">
        <source>Unexpected end of input in 'match' or 'try' expression</source>
        <target state="translated">Nieoczekiwane zakończenie danych wejściowych w wyrażeniu „match” lub „try”</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileThen">
        <source>Unexpected end of input in 'then' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Nieoczekiwane zakończenie danych wejściowych w gałęzi „then” wyrażenia warunkowego. Oczekiwano konstrukcji „if &lt;wyrażenie&gt; then &lt;wyrażenie&gt;” lub „if &lt;wyrażenie&gt; then &lt;wyrażenie&gt; else &lt;wyrażenie&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileElse">
        <source>Unexpected end of input in 'else' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Nieoczekiwane zakończenie danych wejściowych w gałęzi „else” wyrażenia warunkowego. Oczekiwano konstrukcji „if &lt;wyrażenie&gt; then &lt;wyrażenie&gt;” lub „if &lt;wyrażenie&gt; then &lt;wyrażenie&gt; else &lt;wyrażenie&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFunBody">
        <source>Unexpected end of input in body of lambda expression. Expected 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</source>
        <target state="translated">Nieoczekiwane zakończenie danych wejściowych w treści wyrażenia lambda. Oczekiwano konstrukcji „fun &lt;wzorzec&gt; ... &lt;wzorzec&gt; -&gt; &lt;wyrażenie&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeArgs">
        <source>Unexpected end of input in type arguments</source>
        <target state="translated">Nieoczekiwane zakończenie danych wejściowych w argumentach typu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeSignature">
        <source>Unexpected end of input in type signature</source>
        <target state="translated">Nieoczekiwane zakończenie danych wejściowych w sygnaturze typu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeDefinition">
        <source>Unexpected end of input in type definition</source>
        <target state="translated">Nieoczekiwane zakończenie danych wejściowych w definicji typu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileObjectMembers">
        <source>Unexpected end of input in object members</source>
        <target state="translated">Nieoczekiwane zakończenie danych wejściowych w elementach członkowskich obiektu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileDefinition">
        <source>Unexpected end of input in value, function or member definition</source>
        <target state="translated">Nieoczekiwany koniec danych wejściowych w definicji wartości, funkcji lub elementu członkowskiego</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileExpression">
        <source>Unexpected end of input in expression</source>
        <target state="translated">Nieoczekiwany koniec danych wejściowych w wyrażeniu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedNameAfterToken">
        <source>Unexpected end of type. Expected a name after this point.</source>
        <target state="translated">Nieoczekiwany koniec typu. Oczekiwano nazwy po tym punkcie.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLet">
        <source>Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.</source>
        <target state="translated">Niepełna definicja wartości lub funkcji. Jeśli jest to wyrażenie, treść wyrażenia musi być wcięta w tej samej kolumnie co słowo kluczowe „let”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLetBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword.</source>
        <target state="translated">Niepełna definicja wartości. Jeśli jest to wyrażenie, treść wyrażenia musi być wcięta w tej samej kolumnie co słowo kluczowe „let!”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUseBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword.</source>
        <target state="translated">Niepełna definicja wartości. Jeśli jest to wyrażenie, treść wyrażenia musi być wcięta w tej samej kolumnie co słowo kluczowe „use!”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUse">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword.</source>
        <target state="translated">Niepełna definicja wartości. Jeśli jest to wyrażenie, treść wyrażenia musi być wcięta w tej samej kolumnie co słowo kluczowe „use”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsWhileDoExpected">
        <source>Missing 'do' in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Brak instrukcji „do” w wyrażeniu „while”. Oczekiwano konstrukcji „while &lt;wyrażenie&gt; do &lt;wyrażenie&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsForDoExpected">
        <source>Missing 'do' in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Brak powiązania „do” w wyrażeniu „for”. Oczekiwano konstrukcji „for &lt;wzorzec&gt; in &lt;wyrażenie&gt; do &lt;wyrażenie&gt;”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRelationInJoin">
        <source>Invalid join relation in '{0}'. Expected 'expr &lt;op&gt; expr', where &lt;op&gt; is =, =?, ?= or ?=?.</source>
        <target state="translated">Nieprawidłowa relacja sprzężenia w elemencie „{0}”. Oczekiwano konstrukcji „wyrażenie &lt;operator&gt; wyrażenie”, gdzie &lt;operator&gt; to =, =?, ?= lub ?=?.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCallsWord">
        <source>Calls</source>
        <target state="translated">Wywołania</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidNumberOfGenericArguments">
        <source>Invalid number of generic arguments to type '{0}' in provided type. Expected '{1}' arguments, given '{2}'.</source>
        <target state="translated">Nieprawidłowa liczba ogólnych argumentów typu „{0}” w udostępnionym typie. Oczekiwano następującej liczby argumentów: „{1}”. Podano: „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument1">
        <source>Invalid value '{0}' for unit-of-measure parameter '{1}'</source>
        <target state="translated">Nieprawidłowa wartość „{0}” parametru „{1}” jednostki miary</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument2">
        <source>Invalid value unit-of-measure parameter '{0}'</source>
        <target state="translated">Nieprawidłowa wartość parametru „{0}” jednostki miary</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyNeedsCanWriteOrCanRead">
        <source>Property '{0}' on provided type '{1}' is neither readable nor writable as it has CanRead=false and CanWrite=false</source>
        <target state="translated">Właściwość „{0}” w udostępnionym typie „{1}” nie jest ani odczytywalna ani zapisywalna, ponieważ ma właściwości CanRead=false i CanWrite=false</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIntoNeedsRestOfQuery">
        <source>A use of 'into' must be followed by the remainder of the computation</source>
        <target state="translated">Po elemencie „into” należy użyć pozostałej części obliczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorDoesntAcceptInto">
        <source>The operator '{0}' does not accept the use of 'into'</source>
        <target state="translated">Operator „{0}” nie akceptuje elementu „into”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationInvalid">
        <source>The definition of the custom operator '{0}' does not use a valid combination of attribute flags</source>
        <target state="translated">Definicja operatora niestandardowego „{0}” nie używa prawidłowej kombinacji flag atrybutów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisTypeMayNotHaveACLIMutableAttribute">
        <source>This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute.</source>
        <target state="translated">Ta definicja typu może nie zawierać atrybutu „CLIMutable”. Tylko typy rekordów mogą zawierać ten atrybut.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAutoPropertyRequiresImplicitConstructionSequence">
        <source>'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Definicje „member val” są dozwolone tylko w typach z podstawowym konstruktorem. Rozważ dodanie argumentów do definicji typu, na przykład „type X(args) = ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSet">
        <source>Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Definicje właściwości nie mogą być deklarowane jako modyfikowalne. Aby wskazać, że można ustawić tę właściwość, użyj konstrukcji „member val NazwaWłaściwości = wyrażenie with get,set”.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
        <source>To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Aby wskazać, że można ustawić tę właściwość, użyj konstrukcji „member val NazwaWłaściwości = wyrażenie with get,set”.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefsOfByrefs">
        <source>Type '{0}' is illegal because in byref&lt;T&gt;, T cannot contain byref types.</source>
        <target state="translated">Typ „{0}” jest niedozwolony, ponieważ w konstrukcji byref&lt;T&gt; typ T nie może zawierać typów byref.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastopsMaxArrayThirtyTwo">
        <source>F# supports array ranks between 1 and 32. The value {0} is not allowed.</source>
        <target state="translated">Język F# obsługuje rangi tablicy między 1 i 32. Wartość {0} jest niedozwolona.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoIntegerForLoopInQuery">
        <source>In queries, use the form 'for x in n .. m do ...' for ranging over integers</source>
        <target state="translated">W zapytaniach użyj formy „for x in n .. m do ...” w celu określenia zakresu liczb całkowitych</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoWhileInQuery">
        <source>'while' expressions may not be used in queries</source>
        <target state="translated">Wyrażenia „while” nie mogą być używane w zapytaniach</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoTryFinallyInQuery">
        <source>'try/finally' expressions may not be used in queries</source>
        <target state="translated">Wyrażenia „try/finally” nie mogą być używane w zapytaniach</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseMayNotBeUsedInQueries">
        <source>'use' expressions may not be used in queries</source>
        <target state="translated">Wyrażenia „use” nie mogą być używane w zapytaniach</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindMayNotBeUsedInQueries">
        <source>'let!', 'use!' and 'do!' expressions may not be used in queries</source>
        <target state="translated">Nie można używać wyrażeń „let!”, „use!” i „do!” w zapytaniach</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnMayNotBeUsedInQueries">
        <source>'return' and 'return!' may not be used in queries</source>
        <target state="translated">Elementy „return” i „return!” nie mogą być używane w zapytaniach</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryOperator">
        <source>This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type.</source>
        <target state="translated">To nie jest znany operator zapytania. Do operatorów zapytań należą takie identyfikatory jak „select”, „where”, „sortBy”, „thenBy”, „groupBy”, „groupValBy”, „join”, „groupJoin”, „sumBy” i „averageBy” zdefiniowane przy użyciu odpowiednich metod typu „QueryBuilder”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryWithMayNotBeUsedInQueries">
        <source>'try/with' expressions may not be used in queries</source>
        <target state="translated">Wyrażenia „try/with” nie mogą być używane w zapytaniach</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonSimpleLetBindingInQuery">
        <source>This 'let' definition may not be used in a query. Only simple value definitions may be used in queries.</source>
        <target state="translated">Nie można użyć tej definicji „let” w zapytaniu. W zapytaniach mogą być używane tylko proste definicje wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTooManyStaticParameters">
        <source>Too many static parameters. Expected at most {0} parameters, but got {1} unnamed and {2} named parameters.</source>
        <target state="translated">Zbyt wiele parametrów statycznych. Oczekiwano co najwyżej następującej liczby parametrów: {0}, ale uzyskano następującą liczbę parametrów nienazwanych i nazwanych: {1} i {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="infosInvalidProvidedLiteralValue">
        <source>Invalid provided literal value '{0}'</source>
        <target state="translated">Nieprawidłowa udostępniona wartość literału „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidPlatformTarget">
        <source>The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead.</source>
        <target state="translated">Flaga platformy „anycpu32bitpreferred” może być używana tylko z obiektami docelowymi EXE. Należy zamiast tego użyć flagi „anycpu”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisValueMayNotBeInlined">
        <source>This member, function or value declaration may not be declared 'inline'</source>
        <target state="translated">Ta deklaracja elementu członkowskiego, funkcji lub wartości nie może być zadeklarowana jako „inline”</target>
        <note />
      </trans-unit>
      <trans-unit id="etErasedTypeUsedInGeneration">
        <source>The provider '{0}' returned a non-generated type '{1}' in the context of a set of generated types. Consider adjusting the type provider to only return generated types.</source>
        <target state="translated">Dostawca „{0}” zwrócił niegenerowany typ „{1}” w kontekście zestawu wygenerowanych typów. Rozważ dostosowanie dostawcy typów tak, aby zwracał tylko wygenerowane typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryBinaryOperator">
        <source>Arguments to query operators may require parentheses, e.g. 'where (x &gt; y)' or 'groupBy (x.Length / 10)'</source>
        <target state="translated">Argumenty operatorów zapytań mogą wymagać nawiasów, np. „where (x &gt; y)” lub „groupBy (x.Length / 10)”</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoSetOfHole">
        <source>A quotation may not involve an assignment to or taking the address of a captured local variable</source>
        <target state="translated">Wyrażenie cytowane nie może obejmować przypisania lub pobrania adresu przechwyconej zmiennej lokalnej</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloads1">
        <source>+ 1 overload</source>
        <target state="translated">+ 1 przeciążenie</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloadsN">
        <source>+ {0} overloads</source>
        <target state="translated">+ przeciążenia ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="erasedTo">
        <source>Erased to</source>
        <target state="translated">Wymazano do postaci</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnfinishedExpression">
        <source>Unexpected token '{0}' or incomplete expression</source>
        <target state="translated">Nieoczekiwany token „{0}” lub niepełne wyrażenie</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributeOnIncompleteCode">
        <source>Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.</source>
        <target state="translated">Nie można znaleźć celu kodu dla tego atrybutu, ponieważ kod po atrybucie jest niekompletny.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeNameCannotBeEmpty">
        <source>Type name cannot be empty.</source>
        <target state="translated">Nazwa typu nie może być pusta.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemReadingAssembly">
        <source>Problem reading assembly '{0}': {1}</source>
        <target state="translated">Problem z odczytem zestawu „{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTPFieldMustBeLiteral">
        <source>Invalid provided field. Provided fields of erased provided types must be literals.</source>
        <target state="translated">Nieprawidłowe podane pole. Podane pola wymazanych podanych typów muszą być literałami.</target>
        <note />
      </trans-unit>
      <trans-unit id="loadingDescription">
        <source>(loading description...)</source>
        <target state="translated">(trwa ładowanie opisu...)</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionUnavailable">
        <source>(description unavailable...)</source>
        <target state="translated">(niedostępny opis...)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTyparMultipleClassConstraints">
        <source>A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.</source>
        <target state="translated">Zmienna typu została ograniczona przez wiele różnych typów klasy. Zmienna typu może mieć tylko jedno ograniczenie klasy.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMatchMayNotBeUsedWithQuery">
        <source>'match' expressions may not be used in queries</source>
        <target state="translated">Wyrażenia „match” nie mogą być używane w zapytaniach</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonTripleArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 3 arguments</source>
        <target state="translated">Element członkowski operatora infiksu „{0}” ma następującą liczbę argumentów początkowych: {1}. Oczekiwano krotki liczącej 3 argumenty</target>
        <note />
      </trans-unit>
      <trans-unit id="cannotResolveNullableOperators">
        <source>The operator '{0}' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Nie można rozpoznać operatora „{0}”. Rozważ otwarcie modułu „Microsoft.FSharp.Linq.NullableOperators”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorRequiresIn">
        <source>'{0}' must be followed by 'in'. Usage: {1}.</source>
        <target state="translated">Po operatorze „{0}” musi występować element „in”. Użycie: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalMemberVarInObjectImplementation">
        <source>Neither 'member val' nor 'override val' definitions are permitted in object expressions.</source>
        <target state="translated">W wyrażeniach obiektu nie są dozwolone definicje „member val” ani definicje „override val”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyCopyAndUpdateRecordInvalid">
        <source>Copy-and-update record expressions must include at least one field.</source>
        <target state="translated">Wyrażenia rekordów kopiowania i aktualizowania muszą zawierać co najmniej jedno pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnderscoreInvalidFieldName">
        <source>'_' cannot be used as field name</source>
        <target state="translated">Znak „_” nie może być używany jako nazwa pola</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGeneratedTypesShouldBeInternalOrPrivate">
        <source>The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'.</source>
        <target state="translated">Podane typy wygenerowane w ramach tego użycia dostawcy typów nie mogą być używane z innych zestawów języka F# i powinny być oznaczone jako wewnętrzne lub prywatne. Rozważ użycie ciągu „type internal TypeName = ...” lub „type private TypeName = ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterAndSetterHaveSamePropertyType">
        <source>A property's getter and setter must have the same type. Property '{0}' has getter of type '{1}' but setter of type '{2}'.</source>
        <target state="translated">Metoda pobierająca i metoda ustawiająca właściwość muszą mieć taki sam typ. Właściwość „{0}” ma metodę pobierającą typu „{1}”, a metodę ustawiającą typu „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRuntimeSuppliedMethodCannotBeUsedInUserCode">
        <source>Array method '{0}' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.</source>
        <target state="translated">Metoda tablicy „{0}” jest dostarczana przez środowisko uruchomieniowe i nie może być używane bezpośrednio w kodzie. W przypadku operacji z elementami tablic rozważ użycie rodziny funkcji GetArray/SetArray z modułu LanguagePrimitives.IntrinsicFunctions.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName">
        <source>The union case '{0}' does not have a field named '{1}'.</source>
        <target state="translated">Przypadek unii „{0}” nie ma pola o nazwie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseFieldCannotBeUsedMoreThanOnce">
        <source>Union case/exception field '{0}' cannot be used more than once.</source>
        <target state="translated">Pole przypadku unii/wyjątku „{0}” nie może zostać użyte więcej niż raz.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameIsUsedModeThanOnce">
        <source>Named field '{0}' is used more than once.</source>
        <target state="translated">Nazwane pole „{0}” jest używane więcej niż raz.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameConflictsWithGeneratedNameForAnonymousField">
        <source>Named field '{0}' conflicts with autogenerated name for anonymous field.</source>
        <target state="translated">Nazwane pole „{0}” powoduje konflikt z automatycznie generowaną nazwą pola anonimowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConstantExpressionOverflow">
        <source>This literal expression or attribute argument results in an arithmetic overflow.</source>
        <target state="translated">Wynikiem tego wyrażenia literału lub argumentu atrybutu jest przepełnienie arytmetyczne.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalStructTypeForConstantExpression">
        <source>This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.</source>
        <target state="translated">To nie jest prawidłowe wyrażenie literału. Atrybut [&lt;Literal&gt;] zostanie zignorowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscSystemRuntimeInteropServicesIsRequired">
        <source>System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.</source>
        <target state="translated">Do korzystania z klas UnknownWrapper\DispatchWrapper jest wymagany zestaw System.Runtime.InteropServices.</target>
        <note />
      </trans-unit>
      <trans-unit id="abImplicitHeapAllocation">
        <source>The mutable local '{0}' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.</source>
        <target state="translated">Modyfikowalna wartość lokalna „{0}” jest niejawnie przydzielona jako komórka odwołania, ponieważ została przechwycona przez zamknięcie. To ostrzeżenie informuje tylko o miejscach, w których są wykonane niejawne operacje przydzielania.</target>
        <note />
      </trans-unit>
      <trans-unit id="estApplyStaticArgumentsForMethodNotImplemented">
        <source>A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid</source>
        <target state="translated">Dostawca typów zaimplementował funkcję GetStaticParametersForMethod, lecz funkcja ApplyStaticArgumentsForMethod nie jest zaimplementowana lub jest nieprawidłowa</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToMethod">
        <source>An error occured applying the static arguments to a provided method</source>
        <target state="translated">Wystąpił błąd podczas stosowania argumentów statycznych dla podanej metody</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexUnexpectedChar">
        <source>Unexpected character '{0}' in preprocessor expression</source>
        <target state="translated">Nieoczekiwany znak „{0}” w wyrażeniu preprocesora</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsUnexpectedToken">
        <source>Unexpected token '{0}' in preprocessor expression</source>
        <target state="translated">Nieoczekiwany token „{0}” w wyrażeniu preprocesora</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsIncompleteExpression">
        <source>Incomplete preprocessor expression</source>
        <target state="translated">Niepełne wyrażenie preprocesora</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsMissingToken">
        <source>Missing token '{0}' in preprocessor expression</source>
        <target state="translated">Brak tokenu „{0}” w wyrażeniu preprocesora</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleMissingDefinition">
        <source>An error occurred while reading the F# metadata node at position {0} in table '{1}' of assembly '{2}'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.</source>
        <target state="translated">Wystąpił błąd podczas odczytu węzła metadanych F# w pozycji {0} tabeli „{1}” zestawu „{2}”. Węzeł nie ma pasującej deklaracji. Zgłoś wystąpienie tego ostrzeżenia. Może być konieczne ponowne skompilowanie używanego zestawu F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScope">
        <source>Type inference caused the type variable {0} to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.</source>
        <target state="translated">Wnioskowanie typu spowodowało wyjście zmiennej {0} poza jej zakres. Rozważ dodanie jawnej deklaracji parametru typu lub skorygowanie kodu tak, aby był mniej ogólny.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScopeAnon">
        <source>Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.</source>
        <target state="translated">Wnioskowanie typu spowodowało wyjście zmiennej typu wnioskowania poza jej zakres. Rozważ dodanie adnotacji typu w celu uczynienia kodu mniej ogólnym.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkRaiseFamilyFunctionArgumentCount">
        <source>Redundant arguments are being ignored in function '{0}'. Expected {1} but got {2} arguments.</source>
        <target state="translated">Nadmiarowe argumenty są ignorowane w funkcji „{0}”. Oczekiwana liczba argumentów: {1}, rzeczywista liczba argumentów: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkLowercaseLiteralBindingInPattern">
        <source>Lowercase literal '{0}' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.</source>
        <target state="translated">Literał pisany małymi literami „{0}” jest zasłaniany przez nowy wzorzec o tej samej nazwie. Tylko literały pisane wielkimi literami i literały z prefiksem modułu mogą być używane jako wzorce nazwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralDoesNotTakeArguments">
        <source>This literal pattern does not take arguments</source>
        <target state="translated">Ten wzorzec literału nie przyjmuje argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalInAugmentation">
        <source>Constructors are not permitted as extension members - they must be defined as part of the original definition of the type</source>
        <target state="translated">Używanie konstruktorów jako elementów członkowskich rozszerzenia jest niedozwolone — należy je zdefiniować w ramach oryginalnej definicji typu</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidResponseFile">
        <source>Invalid response file '{0}' ( '{1}' )</source>
        <target state="translated">Nieprawidłowy plik odpowiedzi „{0}” („{1}”)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNotFound">
        <source>Response file '{0}' not found in '{1}'</source>
        <target state="translated">Nie można znaleźć pliku odpowiedzi „{0}” w lokalizacji „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNameInvalid">
        <source>Response file name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">Nazwa pliku odpowiedzi „{0}” jest pusta, zawiera nieprawidłowe znaki, ma oznaczenie dysku bez ścieżki bezwzględnej lub jest zbyt długa</target>
        <note />
      </trans-unit>
      <trans-unit id="fsharpCoreNotFoundToBeCopied">
        <source>Cannot find FSharp.Core.dll in compiler's directory</source>
        <target state="translated">Nie można znaleźć pliku FSharp.Core.dll w katalogu kompilatora</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleStructMismatch">
        <source>One tuple type is a struct tuple, the other is a reference tuple</source>
        <target state="translated">Jednym typem krotki jest krotka struktury, innym — krotka odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="etMissingStaticArgumentsToMethod">
        <source>This provided method requires static parameters</source>
        <target state="translated">Ta udostępniona metoda wymaga parametrów statycznych</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcast">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'.</source>
        <target state="translated">Konwersja z {0} do {1} jest przypisaniem elementu nadrzędnego bezpiecznym w czasie kompilacji, a nie przypisaniem elementu podrzędnego. Rozważ użycie słowa kluczowego „upcast” zamiast „downcast”.</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcastOperator">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.</source>
        <target state="translated">Konwersja z {0} do {1} jest przypisaniem elementu nadrzędnego bezpiecznym w czasie kompilacji, a nie przypisaniem elementu podrzędnego. Rozważ użycie operatora :&gt; (przypisanie elementu nadrzędnego) zamiast :?&gt; (przypisanie elementu podrzędnego).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecImplied">
        <source>The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored</source>
        <target state="translated">Deklaracja „rec” tego modułu jest określona niejawnie przez zewnętrzną deklarację „rec” i zostanie zignorowana</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenFirstInMutRec">
        <source>In a recursive declaration group, 'open' declarations must come first in each module</source>
        <target state="translated">W cyklicznej grupie deklaracji deklaracje „open” muszą występować jako pierwsze w każdym module</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbrevFirstInMutRec">
        <source>In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations</source>
        <target state="translated">W cyklicznej grupie deklaracji skróty modułu muszą następować po wszystkich deklaracjach „open” i przed innymi deklaracjami</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedMutRecDecl">
        <source>This declaration is not supported in recursive declaration groups</source>
        <target state="translated">Ta deklaracja nie jest obsługiwana w cyklicznych grupach deklaracji</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidUseOfRec">
        <source>Invalid use of 'rec' keyword</source>
        <target state="translated">Nieprawidłowe użycie słowa kluczowego „rec”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructUnionMultiCaseDistinctFields">
        <source>If a union type has more than one case and is a struct, then all fields within the union type must be given unique names.</source>
        <target state="translated">Jeśli typ unii ma więcej niż jeden przypadek i jest strukturą, wszystkim polom w typie unii należy nadać unikatowe nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerMemberNameIsOverriden">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">Zastosowanie elementu CallerMemberNameAttribute do parametru „{0}” nie odniesie żadnego skutku. Jest on przesłaniany przez element CallerFilePathAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFixedNotAllowed">
        <source>Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'</source>
        <target state="translated">Nieprawidłowe użycie wyrażenia „fixed”. Wyrażenia „fixed” można użyć tylko w deklaracji w postaci „use x = fixed expr”, gdzie wyrażenie jest tablicą, adresem pola, adresem elementu tablicy lub ciągiem</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindOffsetToStringData">
        <source>Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression.</source>
        <target state="translated">Nie można odnaleźć metody System.Runtime.CompilerServices.OffsetToStringData w odwołaniach podczas kompilowania wyrażenia „fixed”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedActivePattern">
        <source>{0} is an active pattern and cannot be treated as a discriminated union case with named fields.</source>
        <target state="translated">{0} jest wzorcem aktywnym i nie można go traktować jako przypadku unii rozłącznej z nazwanymi polami.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultParameterValueNotAppropriateForArgument">
        <source>The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'.</source>
        <target state="translated">Wartość domyślna nie ma takiego samego typu jak argument. Atrybut DefaultParameterValue i wszelkie atrybuty Optional zostaną zignorowane. Uwaga: dla wartości „null” należy użyć adnotacji z poprawnym typem, np. „DefaultParameterValue(null:obj)”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGlobalsSystemTypeNotFound">
        <source>The system type '{0}' was required but no referenced system DLL contained this type</source>
        <target state="translated">Typ systemowy „{0}” był wymagany, ale żadna z przywoływanych systemowych bibliotek DLL nie zawierała tego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberHasMultiplePossibleDispatchSlots">
        <source>The member '{0}' matches multiple overloads of the same method.\nPlease restrict it to one of the following:{1}.</source>
        <target state="translated">Element członkowski „{0}” pasuje do wielu przeciążeń tej samej metody.\nOgranicz go do jednej z następujących opcji: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="methodIsNotStatic">
        <source>Method or object constructor '{0}' is not static</source>
        <target state="translated">Metoda nie jest statyczna lub konstruktor obiektu „{0}” nie jest statyczny</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolEqualsInsteadOfIn">
        <source>Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?</source>
        <target state="translated">Nieoczekiwany symbol „=” w wyrażeniu. Czy w zamian planowano użycie instrukcji „for x in y .. z do”?</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAbstract">
        <source>Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</source>
        <target state="translated">Wskazuje metodę, która nie ma implementacji w typie, w którym została zadeklarowana, lub jest wirtualna i ma implementację domyślną.</target>
        <note />
      </trans-unit>
      <trans-unit id="keyworkDescriptionAnd">
        <source>Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</source>
        <target state="translated">Używane w powiązaniach wzajemnie cyklicznych, deklaracjach właściwości oraz z wieloma ograniczeniami parametrów ogólnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAs">
        <source>Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</source>
        <target state="translated">Używane do nadawania nazwy bieżącemu obiektowi klasy oraz do nadawania nazwy całemu wzorcowi w obrębie dopasowania wzorca.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAssert">
        <source>Used to verify code during debugging.</source>
        <target state="translated">Używane do weryfikowania kodu podczas debugowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBase">
        <source>Used as the name of the base class object.</source>
        <target state="translated">Używane jako nazwa obiektu klasy podstawowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBegin">
        <source>In verbose syntax, indicates the start of a code block.</source>
        <target state="translated">W składni pełnej wskazuje początek bloku kodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionClass">
        <source>In verbose syntax, indicates the start of a class definition.</source>
        <target state="translated">W składni pełnej wskazuje początek definicji klasy.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDefault">
        <source>Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</source>
        <target state="translated">Wskazuje implementację metody abstrakcyjnej; używane razem z deklaracją metody abstrakcyjnej do tworzenia metody wirtualnej.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDelegate">
        <source>Used to declare a delegate.</source>
        <target state="translated">Używane do deklarowania delegata.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDo">
        <source>Used in looping constructs or to execute imperative code.</source>
        <target state="translated">Używane w konstrukcjach zapętlenia lub do wykonywania kodu imperatywnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDone">
        <source>In verbose syntax, indicates the end of a block of code in a looping expression.</source>
        <target state="translated">W składni pełnej wskazuje koniec bloku kodu w wyrażeniu zapętlenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDowncast">
        <source>Used to convert to a type that is lower in the inheritance chain.</source>
        <target state="translated">Używane do konwertowania na typ znajdujący się niżej w łańcuchu dziedziczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDownto">
        <source>In a for expression, used when counting in reverse.</source>
        <target state="translated">W wyrażeniu for używane podczas liczenia w kolejności odwrotnej.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElif">
        <source>Used in conditional branching. A short form of else if.</source>
        <target state="translated">Używane w rozgałęzianiu warunkowym. Krótka postać instrukcji else if.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElse">
        <source>Used in conditional branching.</source>
        <target state="translated">Używane w rozgałęzianiu warunkowym.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionEnd">
        <source>In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</source>
        <target state="translated">W definicjach typu i rozszerzeniach typu wskazuje koniec sekcji definicji elementów członkowskich. W składni pełnej używane do określania końca bloku kodu rozpoczynającego się słowem kluczowym begin.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionException">
        <source>Used to declare an exception type.</source>
        <target state="translated">Używane do deklarowania typu wyjątku.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionExtern">
        <source>Indicates that a declared program element is defined in another binary or assembly.</source>
        <target state="translated">Wskazuje, że zadeklarowany element programu został zdefiniowany w innym pliku binarnym lub zestawie.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTrueFalse">
        <source>Used as a Boolean literal.</source>
        <target state="translated">Używane jako literał wartości logicznej.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFinally">
        <source>Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</source>
        <target state="translated">Używane razem ze słowem kluczowym try do wprowadzania bloku kodu, który jest wykonywany bez względu na to, czy wystąpi wyjątek.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFor">
        <source>Used in looping constructs.</source>
        <target state="translated">Używane w konstrukcjach zapętlenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFun">
        <source>Used in lambda expressions, also known as anonymous functions.</source>
        <target state="translated">Używane w wyrażeniach lambda, znane również jako funkcje anonimowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFunction">
        <source>Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</source>
        <target state="translated">Używane jako krótsza alternatywa słowa kluczowego fun i wyrażenie dopasowania w wyrażeniu lambda, które ma wzorzec pasujący do pojedynczego argumentu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionGlobal">
        <source>Used to reference the top-level .NET namespace.</source>
        <target state="translated">Używane do tworzenia odwołania do przestrzeni nazw najwyższego poziomu w technologii .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIf">
        <source>Used in conditional branching constructs.</source>
        <target state="translated">Używane w konstrukcjach rozgałęziania warunkowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIn">
        <source>Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</source>
        <target state="translated">Używane na potrzeby wyrażeń sekwencji oraz — w składni pełnej — do oddzielania wyrażeń od powiązań.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInherit">
        <source>Used to specify a base class or base interface.</source>
        <target state="translated">Używane do określania klasy podstawowej lub interfejsu podstawowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInline">
        <source>Used to indicate a function that should be integrated directly into the caller's code.</source>
        <target state="translated">Używane do wskazywania funkcji, która powinna zostać zintegrowana bezpośrednio z kodem funkcji wywołującej.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInterface">
        <source>Used to declare and implement interfaces.</source>
        <target state="translated">Używane do deklarowania i implementowania interfejsów.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInternal">
        <source>Used to specify that a member is visible inside an assembly but not outside it.</source>
        <target state="translated">Używane do wskazywania, że element członkowski jest widoczny wewnątrz zestawu, ale nie poza nim.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLazy">
        <source>Used to specify a computation that is to be performed only when a result is needed.</source>
        <target state="translated">Używane do określania obliczenia, które ma być wykonywane tylko, jeśli potrzebny jest wynik.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLet">
        <source>Used to associate, or bind, a name to a value or function.</source>
        <target state="translated">Używane do kojarzenia lub powiązywania nazwy z wartością lub funkcją.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLetBang">
        <source>Used in computation expressions to bind a name to the result of another computation expression.</source>
        <target state="translated">Używane w wyrażeniach obliczeń, aby powiązać nazwę z wynikiem innego wyrażenia obliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatch">
        <source>Used to branch by comparing a value to a pattern.</source>
        <target state="translated">Używane do rozgałęziania przez porównanie wartości z wzorcem.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMember">
        <source>Used to declare a property or method in an object type.</source>
        <target state="translated">Używane do deklarowania właściwości lub metody w typie obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionModule">
        <source>Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</source>
        <target state="translated">Używane do kojarzenia nazwy z grupą powiązanych typów, wartości i funkcji w celu jej logicznego oddzielenia od innego kodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMutable">
        <source>Used to declare a variable, that is, a value that can be changed.</source>
        <target state="translated">Używane do deklarowania zmiennej, czyli wartości, która może się zmienić.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNamespace">
        <source>Used to associate a name with a group of related types and modules, to logically separate it from other code.</source>
        <target state="translated">Używane do kojarzenia nazwy z grupą powiązanych typów i modułów w celu jej logicznego oddzielenia od innego kodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNew">
        <source>Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.</source>
        <target state="translated">Używane do deklarowania, definiowania lub wywoływania konstruktora, który tworzy lub może utworzyć obiekt. Używane również w ograniczeniach parametrów ogólnych do wskazywania, że typ musi mieć określonego konstruktora.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNot">
        <source>Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</source>
        <target state="translated">To nie jest naprawdę słowo kluczowe. Struktura not w kombinacji jest jednak używana w ograniczeniach parametrów ogólnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNull">
        <source>Indicates the absence of an object. Also used in generic parameter constraints.</source>
        <target state="translated">Wskazuje brak obiektu. Używane również w ograniczeniach parametrów ogólnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOf">
        <source>Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</source>
        <target state="translated">Używane w uniach rozłącznych do wskazywania typów kategorii wartości oraz w deklaracjach delegowania i wyjątków.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOpen">
        <source>Used to make the contents of a namespace or module available without qualification.</source>
        <target state="translated">Używane do udostępniania zawartości przestrzeni nazw lub modułu bez kwalifikacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOr">
        <source>Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.</source>
        <target state="translated">Używane z warunkami wartości logicznej jako wartość logiczna lub operator. Odpowiednik symbolu ||. Używane również w ograniczeniach elementu członkowskiego.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOverride">
        <source>Used to implement a version of an abstract or virtual method that differs from the base version.</source>
        <target state="translated">Używane do implementowania wersji metody abstrakcyjnej lub wirtualnej, która różni się od wersji podstawowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPrivate">
        <source>Restricts access to a member to code in the same type or module.</source>
        <target state="translated">Ogranicza dostęp do elementu członkowskiego kodu w tym samym typie lub module.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPublic">
        <source>Allows access to a member from outside the type.</source>
        <target state="translated">Umożliwia dostęp do elementu członkowskiego spoza typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRec">
        <source>Used to indicate that a function is recursive.</source>
        <target state="translated">Używane do wskazywania, że funkcja jest cykliczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturn">
        <source>Used to provide a value for the result of the containing computation expression.</source>
        <target state="translated">Używane do udostępniania wartości dla wyniku zawierającego wyrażenia obliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturnBang">
        <source>Used to provide a value for the result of the containing computation expression, where that value itself comes from the result another computation expression.</source>
        <target state="translated">Używane do udostępniania wyniku zawierającego wyrażenia obliczenia, gdy ta wartość pochodzi z wyniku innego wyrażenia obliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionSelect">
        <source>Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</source>
        <target state="translated">Używane w wyrażeniach zapytania do określania, które pola lub kolumny będą wyodrębniane. Należy pamiętać, że jest to kontekstowe słowo kluczowe, co oznacza, że nie jest to naprawdę słowo zastrzeżone i działa jako słowo kluczowe tylko w odpowiednim kontekście.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStatic">
        <source>Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</source>
        <target state="translated">Używane do wskazywania metody lub właściwości, którą można wywołać bez wystąpienia typu, lub elementu członkowskiego wartości, który jest udostępniany wszystkich wystąpieniom typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStruct">
        <source>Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions.</source>
        <target state="translated">Używane do deklarowania typu struktury, w ograniczeniach parametrów ogólnych oraz na potrzeby zgodności OCami w definicjach modułu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionThen">
        <source>Used in conditional expressions. Also used to perform side effects after object construction.</source>
        <target state="translated">Używane w wyrażeniach warunkowych oraz do wykonywania efektów ubocznych po skonstruowaniu obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTo">
        <source>Used in for loops to indicate a range.</source>
        <target state="translated">Używane w pętlach do wskazywania zakresu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTry">
        <source>Used to introduce a block of code that might generate an exception. Used together with with or finally.</source>
        <target state="translated">Używane do wprowadzania bloku kodu, który może generować wyjątek. Używane razem ze słowem kluczowym with lub finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionType">
        <source>Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</source>
        <target state="translated">Używane do deklarowania klasy, rekordu, struktury, unii rozłącznej, typu wyliczeniowego, jednostki miary lub skrótu typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUpcast">
        <source>Used to convert to a type that is higher in the inheritance chain.</source>
        <target state="translated">Używane do konwertowania na typ znajdujący się wyżej w łańcuchu dziedziczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUse">
        <source>Used instead of let for values that implement IDisposable</source>
        <target state="translated">Używane zamiast powiązania let dla wartości implementujących interfejs IDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUseBang">
        <source>Used instead of let! in computation expressions for computation expression results that implement IDisposable.</source>
        <target state="translated">Używane zamiast powiązania let! w wyrażeniach obliczeń, aby uzyskać wyniki wyrażenia obliczeń implementujące interfejs IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVal">
        <source>Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</source>
        <target state="translated">Używane w podpisie do wskazywania wartości lub w typie do deklarowania elementu członkowskiego w pewnych określonych sytuacjach.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVoid">
        <source>Indicates the .NET void type. Used when interoperating with other .NET languages.</source>
        <target state="translated">Wskazuje typ void technologii .NET. Używane w przypadku współdziałania z innymi językami .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhen">
        <source>Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.</source>
        <target state="translated">Używane na potrzeby warunków wartości logicznych (strażników when) w dopasowaniach wzorca oraz w celu wprowadzenia klauzuli ograniczenia dla parametru typu ogólnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhile">
        <source>Introduces a looping construct.</source>
        <target state="translated">Wprowadza konstrukcję zapętlenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWith">
        <source>Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</source>
        <target state="translated">Używane razem ze słowem kluczowym match w wyrażeniach dopasowania wzorca. Używane również w wyrażeniach obiektu, wyrażeniach kopiowania rekordu oraz wyrażeniach typu do wprowadzania definicji elementów członkowskich i obsługi wyjątków.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYield">
        <source>Used in a sequence expression to produce a value for a sequence.</source>
        <target state="translated">Używane w wyrażeniu sekwencji do tworzenia wartości sekwencji.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYieldBang">
        <source>Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</source>
        <target state="translated">Używane w wyrażeniach obliczenia do dołączania wyniku danego wyrażenia obliczenia do kolekcji wyników dla zawartego wyrażenia obliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRightArrow">
        <source>In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions</source>
        <target state="translated">W typach funkcji ogranicza argumenty i wartości zwracane. Implikuje wyrażenie (w wyrażeniach sekwencji); odpowiednik słowa kluczowego yield. Używane w wyrażeniach dopasowania</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLeftArrow">
        <source>Assigns a value to a variable.</source>
        <target state="translated">Przydziela wartość do zmiennej.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionCast">
        <source>Converts a type to type that is higher in the hierarchy.</source>
        <target state="translated">Konwertuje typ na typ znajdujący się wyżej w hierarchii.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDynamicCast">
        <source>Converts a type to a type that is lower in the hierarchy.</source>
        <target state="translated">Konwertuje typ na typ znajdujący się niżej w hierarchii.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTypedQuotation">
        <source>Delimits a typed code quotation.</source>
        <target state="translated">Ogranicza typizowany cytat kodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUntypedQuotation">
        <source>Delimits a untyped code quotation.</source>
        <target state="translated">Ogranicza nietypizowany cytat kodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundDuringDynamicCodeGen">
        <source>{0} '{1}' not found in assembly '{2}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">Nie znaleziono elementu {0} „{1}” w zestawie „{2}”. Możliwa przyczyna to niezgodność wersji. Być może trzeba jawnie odwołać się do prawidłowej wersji tego zestawu, aby zezwolić wszystkim przywoływanym składnikom na użycie prawidłowej wersji.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundInTypeDuringDynamicCodeGen">
        <source>{0} '{1}' not found in type '{2}' from assembly '{3}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">Nie znaleziono elementu {0} „{1}” w typie „{2}” z zestawu „{3}”. Możliwa przyczyna to niezgodność wersji. Być może trzeba jawnie odwołać się do prawidłowej wersji tego zestawu, aby zezwolić wszystkim przywoływanym składnikom na użycie prawidłowej wersji.</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionWordIs">
        <source>is</source>
        <target state="translated">jest</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunction">
        <source>This value is not a function and cannot be applied.</source>
        <target state="translated">Ta wartość nie jest funkcją i nie można jej zastosować.</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexerWithName">
        <source>This value is not a function and cannot be applied. Did you intend to access the indexer via {0}.[index] instead?</source>
        <target state="translated">Ta wartość nie jest funkcją i nie można jej zastosować. Czy zamiast tego zamierzano uzyskać dostęp do indeksatora przy użyciu formatu {0}.[indeks]?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexer">
        <source>This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?</source>
        <target state="translated">To wyrażenie nie jest funkcją i nie można go zastosować. Czy zamiast tego zamierzano uzyskać dostęp do indeksatora przy użyciu formatu wyrażenie.[indeks]?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeDeclaration">
        <source>This value is not a function and cannot be applied. Did you forget to terminate a declaration?</source>
        <target state="translated">Ta wartość nie jest funkcją i nie można jej zastosować. Czy deklaracja została zakończona?</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentsInSigAndImplMismatch">
        <source>The argument names in the signature '{0}' and implementation '{1}' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling.</source>
        <target state="translated">Nazwy argumentów w podpisie „{0}” i implementacji „{1}” nie są zgodne. Używana będzie nazwa argumentu z pliku podpisu. Może to spowodować problemy podczas debugowania lub profilowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleUnexpectedNonZero">
        <source>An error occurred while reading the F# metadata of assembly '{0}'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct.</source>
        <target state="translated">Wystąpił błąd podczas odczytu metadanych języka F# z zestawu „{0}”. Została wykorzystana zarezerwowana konstrukcja. Może być konieczne uaktualnienie kompilatora języka F# lub użycie wcześniejszej wersji zestawu, która nie wykorzystuje określonej konstrukcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleMemberNotNormallyUsed">
        <source>This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.</source>
        <target state="translated">Ta metoda lub właściwość nie jest zwykle używana z kodu języka F#. Zamiast tego do dekonstrukcji użyj jawnego wzorca krotki.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'.</source>
        <target state="translated">To wyrażenie zwraca wartość typu „{0}”, ale jest niejawnie odrzucane. Rozważ użycie instrukcji „let” do powiązania wyniku z nazwą, np. „let wynik = wyrażenie”. Jeśli chcesz użyć tego wyrażenia jako wartości w sekwencji, użyj jawnej instrukcji „yield”.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedSequenceInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'.</source>
        <target state="translated">To wyrażenie zwraca wartość typu „{0}”, ale jest niejawnie odrzucane. Rozważ użycie instrukcji „let” do powiązania wyniku z nazwą, np. „let wynik = wyrażenie”. Jeśli chcesz użyć tego wyrażenia jako wartości w sekwencji, użyj jawnej instrukcji „yield!”.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatchBang">
        <source>Used in computation expressions to pattern match directly over the result of another computation expression.</source>
        <target state="translated">Używane w wyrażeniach obliczenia do dopasowania do wzorca bezpośrednio w wyniku innego wyrażenia obliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilreadFileChanged">
        <source>The file '{0}' changed on disk unexpectedly, please reload.</source>
        <target state="translated">Plik „{0}” nieoczekiwanie uległ zmianie na dysku. Załaduj go ponownie.</target>
        <note />
      </trans-unit>
      <trans-unit id="writeToReadOnlyByref">
        <source>The byref pointer is readonly, so this write is not permitted.</source>
        <target state="translated">Wskaźnik byref jest tylko do odczytu, więc ten zapis nie jest dozwolony.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeMutable">
        <source>A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'</source>
        <target state="translated">Aby można było zmodyfikować zawartość lub pobrać adres typu wartości, wartość musi być modyfikowalna, na przykład „let mutable x = ...”</target>
        <note />
      </trans-unit>
      <trans-unit id="readOnlyAttributeOnStructWithMutableField">
        <source>A ReadOnly attribute has been applied to a struct type with a mutable field.</source>
        <target state="translated">Atrybut ReadOnly został zastosowany do typu struktury z polem modyfikowalnym.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByrefReturnImplicitlyDereferenced">
        <source>A byref pointer returned by a function or method is implicitly dereferenced as of F# 4.5. To acquire the return value as a pointer, use the address-of operator, e.g. '&amp;f(x)' or '&amp;obj.Method(arg1, arg2)'.</source>
        <target state="translated">Wskaźnik byref zwracany przez funkcję lub metodę jest niejawnie wyłuskiwany w języku F# 4.5 i nowszych. Aby uzyskać wartość zwracaną jako wskaźnik, użyj operatora address-of, np. „&amp;f(x)” lub „&amp;obj.Method(argument1, argument2)”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByRefLikeNotStruct">
        <source>A type annotated with IsByRefLike must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.</source>
        <target state="translated">Typ z adnotacją IsByRefLike musi być również strukturą. Rozważ dodanie atrybutu [&lt;Struct&gt;] do typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAddressOfLocal">
        <source>The address of the variable '{0}' or a related expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">W tym miejscu nie można użyć adresu zmiennej „{0}” ani powiązanego wyrażenia. Ma to na celu uniemożliwienie adresowi wartości lokalnej wykroczenia poza zakres.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoWriteToLimitedSpan">
        <source>This value can't be assigned because the target '{0}' may refer to non-stack-local memory, while the expression being assigned is assessed to potentially refer to stack-local memory. This is to help prevent pointers to stack-bound memory escaping their scope.</source>
        <target state="translated">Ta wartość nie może zostać przypisana, ponieważ element docelowy „{0}” może odwoływać się do pamięci innej niż pamięć lokalna dla stosu, natomiast przypisywane wyrażenie może potencjalnie odwoływać się do pamięci lokalnej dla stosu. Dzięki temu łatwiej uniemożliwić wskaźnikom do pamięci powiązanej ze stosem wykroczenie poza ich zakres.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeLocal">
        <source>A value defined in a module must be mutable in order to take its address, e.g. 'let mutable x = ...'</source>
        <target state="translated">Wartość zdefiniowana w module musi być modyfikowalna w celu uzyskania jej adresu, np. „let mutable x = ...”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIsReadOnlyNotStruct">
        <source>A type annotated with IsReadOnly must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.</source>
        <target state="translated">Typ z adnotacją IsReadOnly musi również być strukturą. Rozważ dodanie atrybutu [&lt;Struct&gt;] do typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkStructsMayNotReturnAddressesOfContents">
        <source>Struct members cannot return the address of fields of the struct by reference</source>
        <target state="translated">Składowe struktury nie mogą zwracać adresów pól struktury przez odwołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefLikeFunctionCall">
        <source>The function or method call cannot be used at this point, because one argument that is a byref of a non-stack-local Span or IsByRefLike type is used with another argument that is a stack-local Span or IsByRefLike type. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">W tym miejscu nie można użyć wywołania funkcji lub metody, ponieważ jeden argument, który jest elementem byref typu Span lub IsByRefLike innego niż lokalnego dla stosu, został użyty z innym argumentem, który jest typem Span lub IsByRefLike lokalnym dla stosu. Ma to na celu zapewnienie, że adres wartości lokalnej nie wykracza poza swój zakres.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAddressOfValueFromExpression">
        <source>The address of a value returned from the expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">W tym miejscu nie można użyć adresu wartości zwróconej z wyrażenia. Ma to na celu uniemożliwienie adresowi wartości lokalnej wykroczenia poza zakres.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoSpanLikeVariable">
        <source>The Span or IsByRefLike variable '{0}' cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">W tym miejscu nie można użyć zmiennej Span lub IsByRefLike „{0}”. Ma to na celu uniemożliwienie adresowi wartości lokalnej wykroczenia poza zakres.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoSpanLikeValueFromExpression">
        <source>A Span or IsByRefLike value returned from the expression cannot be used at ths point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">W tym miejscu nie można użyć wartości Span lub IsByRefLike zwróconej z wyrażenia. Ma to na celu uniemożliwienie adresowi wartości lokalnej wykroczenia poza zakres.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastCantTakeAddressOfExpression">
        <source>Cannot take the address of the value returned from the expression. Assign the returned value to a let-bound value before taking the address.</source>
        <target state="translated">Nie można uzyskać adresu wartości zwróconej przez wyrażenie. Przypisz zwróconą wartość do wartości powiązanej za pomocą instrukcji let przed uzyskaniem adresu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBraceBar">
        <source>Unmatched '{{|'</source>
        <target state="translated">Niedopasowany element „{{|”</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoAnonRecdField">
        <source>anonymous record field</source>
        <target state="translated">pole rekordu anonimowego</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionConstructorDoesNotHaveFieldWithGivenName">
        <source>The exception '{0}' does not have a field named '{1}'.</source>
        <target state="translated">Wyjątek „{0}” nie ma pola o nazwie „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcActivePatternsDoNotHaveFields">
        <source>Active patterns do not have fields. This syntax is invalid.</source>
        <target state="translated">Aktywne wzorce nie mają pól. Składnia jest nieprawidłowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorDoesNotHaveFieldWithGivenName">
        <source>The constructor does not have a field named '{0}'.</source>
        <target state="translated">Konstruktor nie ma pola o nazwie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdCcuMismatch">
        <source>Two anonymous record types are from different assemblies '{0}' and '{1}'</source>
        <target state="translated">Dwa typy rekordów anonimowych pochodzą z różnych zestawów: „{0}” i „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameMismatch">
        <source>This anonymous record does not exactly match the expected shape. Add the missing fields {0} and remove the extra fields {1}.</source>
        <target state="translated">Ten rekord anonimowy nie jest dokładnie zgodny z oczekiwanym kształtem. Dodaj brakujące pola {0} i usuń dodatkowe pola {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallExtensionMethodInrefToByref">
        <source>Cannot call the byref extension method '{0}. The first parameter requires the value to be mutable or a non-readonly byref type.</source>
        <target state="translated">Nie można wywołać metody rozszerzenia byref „{0}”. Pierwszy parametr wymaga, aby wartość była typem byref zmiennym lub innym niż tylko do odczytu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByrefsMayNotHaveTypeExtensions">
        <source>Byref types are not allowed to have optional type extensions.</source>
        <target state="translated">Typy Byref nie mogą mieć opcjonalnych rozszerzeń typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotPartiallyApplyExtensionMethodForByref">
        <source>Cannot partially apply the extension method '{0}' because the first parameter is a byref type.</source>
        <target state="translated">Nie można częściowo zastosować metody rozszerzenia „{0}”, ponieważ pierwszy parametr jest typu byref.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDoesNotInheritAttribute">
        <source>This type does not inherit Attribute, it will not work correctly with other .NET languages.</source>
        <target state="translated">Ten typ nie dziedziczy atrybutu, więc nie będzie działać prawidłowo z innymi językami .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidAnonRecdExpr">
        <source>Invalid anonymous record expression</source>
        <target state="translated">Nieprawidłowe wyrażenie rekordu anonimowego</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidAnonRecdType">
        <source>Invalid anonymous record type</source>
        <target state="translated">Nieprawidłowy typ rekordu anonimowego</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCopyAndUpdateNeedsRecordType">
        <source>The input to a copy-and-update expression that creates an anonymous record must be either an anonymous record or a record</source>
        <target state="translated">Dane wejściowe wyrażenia kopiowania i aktualizowania, które tworzy rekord anonimowy, muszą być rekordem lub rekordem anonimowym</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidFunctionParameterType">
        <source>The parameter '{0}' has an invalid type '{1}'. This is not permitted by the rules of Common IL.</source>
        <target state="translated">Parametr „{0}” ma nieprawidłowy typ „{1}”. Nie jest to dozwolone przez reguły języka Common IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidFunctionReturnType">
        <source>The function or method has an invalid return type '{0}'. This is not permitted by the rules of Common IL.</source>
        <target state="translated">Funkcja lub metoda ma nieprawidłowy zwracany typ „{0}”. Nie jest to dozwolone przez reguły języka Common IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveral">
        <source>No implementation was given for those members: {0}</source>
        <target state="translated">Nie podano implementacji dla tych składowych: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralWithSuggestion">
        <source>No implementation was given for those members: {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Nie podano implementacji dla tych składowych: {0}Pamiętaj, że wszystkie składowe interfejsu muszą być zaimplementowane i wymienione w ramach odpowiedniej deklaracji „interface”, np. „interface ... with member ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralTruncated">
        <source>No implementation was given for those members (some results omitted): {0}</source>
        <target state="translated">Nie podano implementacji dla tych składowych (niektóre wyniki zostały pominięte): {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralTruncatedWithSuggestion">
        <source>No implementation was given for those members (some results omitted): {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Nie podano implementacji dla tych składowych (niektóre wyniki zostały pominięte): {0}Pamiętaj, że wszystkie składowe interfejsów muszą być zaimplementowane i wymienione w ramach odpowiedniej deklaracji „interface” np. „interface ... with member ...”.</target>
        <note />
      </trans-unit>
      <trans-unit id="expressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">Wyrażenie nie ma nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassNameOf">
        <source>Using the 'nameof' operator as a first-class function value is not permitted.</source>
        <target state="translated">Używanie operatora „nameof” jako pierwszoklasowej wartości funkcji nie jest dozwolone.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPathMap">
        <source>Maps physical paths to source path names output by the compiler</source>
        <target state="translated">Mapuje ścieżki fizyczne na wyjściowe nazwy ścieżek źródłowych z kompilatora</target>
        <note />
      </trans-unit>
      <trans-unit id="fscPathMapDebugRequiresPortablePdb">
        <source>--pathmap can only be used with portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">Argumentu --pathmap można używać tylko z przenośnymi plikami PDB (--debug:portable lub --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidPathMapFormat">
        <source>Invalid path map. Mappings must be comma separated and of the format 'path=sourcePath'</source>
        <target state="translated">Nieprawidłowe mapowanie ścieżek. Mapowania muszą być rozdzielone przecinkami i mieć format „path=sourcePath”</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCompilerTool">
        <source>Reference an assembly or directory containing a design time tool (Short form: -t)</source>
        <target state="translated">Odwołuje się do zestawu lub katalogu zawierającego narzędzie czasu projektowania (krótka wersja: -t)</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagerUnknown">
        <source>Package manager key '{0}' was not registered in {1}. Currently registered: {2}</source>
        <target state="translated">Klucz menedżera pakietów „{0}” nie został zarejestrowany w elemencie {1}. Obecnie zarejestrowane: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagerError">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="couldNotLoadDependencyManagerExtension">
        <source>The dependency manager extension {0} could not be loaded. Message: {1}</source>
        <target state="translated">Nie można załadować rozszerzenia menedżera zależności {0}. Komunikat: {1}</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>