<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pt-BR" original="../FSComp.resx">
    <body>
      <trans-unit id="undefinedNameNamespace">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">O namespace '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespaceOrModule">
        <source>The namespace or module '{0}' is not defined.</source>
        <target state="translated">O namespace ou o módulo '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMember">
        <source>The field, constructor or member '{0}' is not defined.</source>
        <target state="translated">O campo, o construtor ou o membro '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueConstructorNamespaceOrType">
        <source>The value, constructor, namespace or type '{0}' is not defined.</source>
        <target state="translated">O valor, o construtor, o namespace ou o tipo '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueOfConstructor">
        <source>The value or constructor '{0}' is not defined.</source>
        <target state="translated">O valor ou o construtor '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueNamespaceTypeOrModule">
        <source>The value, namespace, type or module '{0}' is not defined.</source>
        <target state="translated">O valor, o namespace, o tipo ou o módulo '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameConstructorModuleOrNamespace">
        <source>The constructor, module or namespace '{0}' is not defined.</source>
        <target state="translated">O construtor, o módulo ou o namespace '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameType">
        <source>The type '{0}' is not defined.</source>
        <target state="translated">O tipo '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeIn">
        <source>The type '{0}' is not defined in '{1}'.</source>
        <target state="translated">O tipo '{0}' não está definido em '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabelOrNamespace">
        <source>The record label or namespace '{0}' is not defined.</source>
        <target state="translated">O rótulo de registro ou o namespace '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabel">
        <source>The record label '{0}' is not defined.</source>
        <target state="translated">O rótulo do registro '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameSuggestionsIntro">
        <source>Maybe you want one of the following:</source>
        <target state="translated">Talvez você queira um dos seguintes:</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeParameter">
        <source>The type parameter {0} is not defined.</source>
        <target state="translated">O parâmetro de tipo '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNamePatternDiscriminator">
        <source>The pattern discriminator '{0}' is not defined.</source>
        <target state="translated">O discriminador de padrão '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="replaceWithSuggestion">
        <source>Replace with '{0}'</source>
        <target state="translated">Substituir por '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="addIndexerDot">
        <source>Add . for indexer access.</source>
        <target state="translated">Adicione um . para obter acesso ao indexador.</target>
        <note />
      </trans-unit>
      <trans-unit id="listElementHasWrongType">
        <source>All elements of a list must be of the same type as the first element, which here is '{0}'. This element has type '{1}'.</source>
        <target state="translated">Todos os elementos de uma expressão do construtor de lista devem ter o mesmo tipo. Essa expressão deveria ter o tipo '{0}', mas aqui tem o tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="arrayElementHasWrongType">
        <source>All elements of an array must be of the same type as the first element, which here is '{0}'. This element has type '{1}'.</source>
        <target state="translated">Todos os elementos de uma expressão do construtor de matriz devem ter o mesmo tipo. Essa expressão deveria ter o tipo '{0}', mas aqui tem o tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="missingElseBranch">
        <source>This 'if' expression is missing an 'else' branch. Because 'if' is an expression, and not a statement, add an 'else' branch which also returns a value of type '{0}'.</source>
        <target state="translated">A expressão 'if' está sem uma ramificação 'else'. A ramificação 'then' tem tipo '{0}'. Como 'if' é uma expressão e não uma instrução, adicione uma ramificação 'else' que retorna um valor do mesmo tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ifExpression">
        <source>The 'if' expression needs to have type '{0}' to satisfy context type requirements. It currently has type '{1}'.</source>
        <target state="translated">A expressão 'if' precisa ter o tipo '{0}' para atender aos requisitos do tipo de contexto. No momento, ela tem o tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="elseBranchHasWrongType">
        <source>All branches of an 'if' expression must return values of the same type as the first branch, which here is '{0}'. This branch returns a value of type '{1}'.</source>
        <target state="translated">Todas as ramificações de uma expressão 'if' devem ter o mesmo tipo. Essa expressão deveria ter o tipo '{0}', mas aqui tem o tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="followingPatternMatchClauseHasWrongType">
        <source>All branches of a pattern match expression must return values of the same type as the first branch, which here is '{0}'. This branch returns a value of type '{1}'.</source>
        <target state="translated">Todos os branches de uma expressão correspondente ao padrão precisam retornar valores do mesmo tipo. O primeiro branch retornou um valor do tipo '{0}', mas este branch retornou um valor do tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="patternMatchGuardIsNotBool">
        <source>A pattern match guard must be of type 'bool', but this 'when' expression is of type '{0}'.</source>
        <target state="translated">A proteção da correspondência de padrão deve ser do tipo 'bool', mas esta expressão 'when' é do tipo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="commaInsteadOfSemicolonInRecord">
        <source>A ';' is used to separate field values in records. Consider replacing ',' with ';'.</source>
        <target state="translated">Um ';' é usado para separar os valores de campo nos registros. Considere substituir ',' por ';'.</target>
        <note />
      </trans-unit>
      <trans-unit id="derefInsteadOfNot">
        <source>The '!' operator is used to dereference a ref cell. Consider using 'not expr' here.</source>
        <target state="translated">O operador '!' é usado para desreferenciar uma célula de referência. Considere usar 'not expr' aqui.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedTypeArgs">
        <source>The non-generic type '{0}' does not expect any type arguments, but here is given {1} type argument(s)</source>
        <target state="translated">O tipo não genérico '{0}' não espera nenhum argumento de tipo, mas aqui são dados argumentos do tipo {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="returnUsedInsteadOfReturnBang">
        <source>Consider using 'return!' instead of 'return'.</source>
        <target state="translated">Considere usar 'return!' em vez de 'return'.</target>
        <note />
      </trans-unit>
      <trans-unit id="useSdkRefs">
        <source>Use reference assemblies for DotNET framework references when available (Enabled by default)).</source>
        <target state="new">Use reference assemblies for DotNET framework references when available (Enabled by default)).</target>
        <note />
      </trans-unit>
      <trans-unit id="yieldUsedInsteadOfYieldBang">
        <source>Consider using 'yield!' instead of 'yield'.</source>
        <target state="translated">Considere usar 'yield!' em vez de 'yield'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tupleRequiredInAbstractMethod">
        <source>\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.</source>
        <target state="translated">\nUm tipo de tupla é exigido para um ou mais argumentos. Considere agrupar os argumentos fornecidos em parênteses adicionais ou revisar a definição da interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidWarningNumber">
        <source>Invalid warning number '{0}'</source>
        <target state="translated">Número de aviso inválido '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionString">
        <source>Invalid version string '{0}'</source>
        <target state="translated">Cadeia de caracteres de versão inválida '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionFile">
        <source>Invalid version file '{0}'</source>
        <target state="translated">Arquivo de versão inválida '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProductName">
        <source>Microsoft (R) F# Compiler version {0}</source>
        <target state="translated">Compilador Microsoft (R) F# versão {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProductNameCommunity">
        <source>F# Compiler for F# {0}</source>
        <target state="translated">Compilador F# para F# {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemWithFilename">
        <source>Problem with filename '{0}': {1}</source>
        <target state="translated">Problema com nome de arquivo '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildNoInputsSpecified">
        <source>No inputs specified</source>
        <target state="translated">Nenhuma entrada especificada</target>
        <note />
      </trans-unit>
      <trans-unit id="buildPdbRequiresDebug">
        <source>The '--pdb' option requires the '--debug' option to be used</source>
        <target state="translated">A opção '--pdb' requer que seja usada a opção '--debug'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSearchDirectory">
        <source>The search directory '{0}' is invalid</source>
        <target state="translated">O diretório de pesquisa '{0}' é inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSearchDirectoryNotFound">
        <source>The search directory '{0}' could not be found</source>
        <target state="translated">Não foi possível encontrar o diretório de pesquisa '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidFilename">
        <source>'{0}' is not a valid filename</source>
        <target state="translated">'{0}' não é um nome de arquivo válido</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidAssemblyName">
        <source>'{0}' is not a valid assembly name</source>
        <target state="translated">'{0}' não é um nome de assembly válido</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidPrivacy">
        <source>Unrecognized privacy setting '{0}' for managed resource, valid options are 'public' and 'private'</source>
        <target state="translated">A configuração de privacidade '{0}' não foi reconhecida pelo recurso gerenciado, as opções válidas são 'public' e 'private'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleReferencesNotAllowed">
        <source>Multiple references to '{0}.dll' are not permitted</source>
        <target state="translated">As referências múltiplas '{0}.dll' não são permitidas</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCannotReadAssembly">
        <source>Unable to read assembly '{0}'</source>
        <target state="translated">Não é possível ler o assembly '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildAssemblyResolutionFailed">
        <source>Assembly resolution failure at or near this location</source>
        <target state="translated">Falha na resolução do assembly neste local ou próximo a ele</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplicitModuleIsNotLegalIdentifier">
        <source>The declarations in this file will be placed in an implicit module '{0}' based on the file name '{1}'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file.</source>
        <target state="translated">As declarações neste arquivo serão localizadas em um módulo implícito '{0}' com base no nome do arquivo '{1}'. Entretanto este não é um identificador F# válido, de maneira que os conteúdos não estarão acessíveis de outros arquivos. Considere renomear o arquivo ou adicionar uma declaração 'module' ou 'namespace' na parte superior do arquivo.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultiFileRequiresNamespaceOrModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration.</source>
        <target state="translated">Arquivos em bibliotecas ou aplicativos com arquivos múltiplos devem começar com uma declaração de namespace ou módulo, por exemplo, 'namespace SomeNamespace.SubNamespace' ou 'module SomeNamespace.SomeModule'. Somente o último arquivo de origem de um aplicativo pode omitir tal declaração.</target>
        <note />
      </trans-unit>
      <trans-unit id="noEqualSignAfterModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.</source>
        <target state="translated">Arquivos em bibliotecas ou aplicativos de múltiplos arquivos devem começar com um namespace ou declaração de módulo. Ao usar uma declaração de módulo no início de um arquivo, o sinal '=' não é permitido. Se esse for um módulo de nível superior, considere remover o = para resolver esse erro.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleToplevelModules">
        <source>This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules.</source>
        <target state="translated">Este arquivo possui declarações múltiplas da forma 'module SomeNamespace.SomeModule'. Apenas uma declaração deste forma é permitida no arquivo. Modifique seu arquivo para usar declaração de namespace inicial e/ou use 'module ModuleName = ...' para definir seus módulos.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildOptionRequiresParameter">
        <source>Option requires parameter: {0}</source>
        <target state="translated">A opção requer o parâmetro: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotFindSourceFile">
        <source>Source file '{0}' could not be found</source>
        <target state="translated">O arquivo de origem '{0}' não pôde ser localizado</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSourceFileExtension">
        <source>The file extension of '{0}' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.</source>
        <target state="translated">A extensão de arquivo de '{0}' não é reconhecida. Arquivos de origem devem ter extensão .fs, .fsi, .fsx, .fsscript, .ml ou .mli.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssembly">
        <source>Could not resolve assembly '{0}'</source>
        <target state="translated">Não foi possível resolver o assembly '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssemblyRequiredByFile">
        <source>Could not resolve assembly '{0}' required by '{1}'</source>
        <target state="translated">Não foi possível resolver o assembly '{0}' requerido por '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildErrorOpeningBinaryFile">
        <source>Error opening binary file '{0}': {1}</source>
        <target state="translated">Erro ao abrir o arquivo binário '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDifferentVersionMustRecompile">
        <source>The F#-compiled DLL '{0}' needs to be recompiled to be used with this version of F#</source>
        <target state="translated">O DDL '{0}', que foi compilado por F#, precisa ser recompilado para ser usado com esta versão do F#</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashIDirective">
        <source>Invalid directive. Expected '#I \"&lt;path&gt;\"'.</source>
        <target state="translated">Diretiva inválida. Esperado '#I \"&lt;path&gt;\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashrDirective">
        <source>Invalid directive. Expected '#r \"&lt;file-or-assembly&gt;\"'.</source>
        <target state="translated">Diretiva inválida. Esperado '#r \"&lt;file-or-assembly&gt;\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashloadDirective">
        <source>Invalid directive. Expected '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</source>
        <target state="translated">Diretiva inválida. Esperado '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashtimeDirective">
        <source>Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'.</source>
        <target state="translated">Diretiva inválida. '#time', '#time \"on\"' ou '#time \"off\"' era esperado.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDirectivesInModulesAreIgnored">
        <source>Directives inside modules are ignored</source>
        <target state="translated">Diretivas dentro de módulos são ignoradas</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureAlreadySpecified">
        <source>A signature for the file or module '{0}' has already been specified</source>
        <target state="translated">A assinatura para o arquivo ou módulo '{0}' já tinha sido especificada</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGivenDetail">
        <source>An implementation of file or module '{0}' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.</source>
        <target state="translated">Uma implementação de arquivo ou módulo '{0}' já foi fornecida. A ordem de compilação é significativa em F# devido à inferência de tipo. Talvez você precise ajustar a ordem dos arquivos para colocar o arquivo de assinatura antes da implementação. No Visual Studio, os arquivos são tipo verificado na ordem em que aparecem no arquivo de projeto, que pode ser editada manualmente ou ajustada por meio do gerenciador de soluções.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGiven">
        <source>An implementation of the file or module '{0}' has already been given</source>
        <target state="translated">Uma implementação de arquivo ou módulo '{0}' já foi fornecida</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureWithoutImplementation">
        <source>The signature file '{0}' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match.</source>
        <target state="translated">O arquivo de assinatura '{0}' não possui um arquivo de implementação correspondente. Se houver um arquivo de implementação, você deverá verificar as declarações de 'módulo' e 'namespace' na assinatura e a correspondência de arquivos de implementação.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidInt">
        <source>'{0}' is not a valid integer argument</source>
        <target state="translated">'{0}' não é um argumento inteiro válido</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidFloat">
        <source>'{0}' is not a valid floating point argument</source>
        <target state="translated">'{0}' não é um argumento de ponto flutuante válido</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnrecognizedOption">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">Opção não reconhecida: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidModuleOrNamespaceName">
        <source>Invalid module or namespace name</source>
        <target state="translated">Nome de módulo ou namespace inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleErrorReadingWritingMetadata">
        <source>Error reading/writing metadata for the F# compiled DLL '{0}'. Was the DLL compiled with an earlier version of the F# compiler? (error: '{1}').</source>
        <target state="translated">Erro na leitura/gravação do metadado no DLL '{0}', que foi compilado por F#. O DLL foi compilado com uma versão inferior ao compilador F#? (erro: '{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeOrModuleNotConcrete">
        <source>The type/module '{0}' is not a concrete module or type</source>
        <target state="translated">O tipo/módulo '{0}' não é um módulo ou tipo concreto</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeHasAssemblyCodeRepresentation">
        <source>The type '{0}' has an inline assembly code representation</source>
        <target state="translated">O tipo '{0}' possui uma representação de código de assembly embutida</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNamespaceAndModuleWithSameNameInAssembly">
        <source>A namespace and a module named '{0}' both occur in two parts of this assembly</source>
        <target state="translated">Um namespace e um módulo chamado '{0}' ocorrem em duas partes deste assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTwoModulesWithSameNameInAssembly">
        <source>Two modules named '{0}' occur in two parts of this assembly</source>
        <target state="translated">Dois módulos chamados '{0}' ocorrem em duas partes deste assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="tastDuplicateTypeDefinitionInAssembly">
        <source>Two type definitions named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">Dois tipos de definição chamados '{0}' ocorreram no namespace '{1}' em duas partes deste assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConflictingModuleAndTypeDefinitionInAssembly">
        <source>A module and a type definition named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">Uma definição de módulo e tipo chamada '{0}' ocorreu no namespace '{1}' em duas partes deste assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMemberSignature">
        <source>Invalid member signature encountered because of an earlier error</source>
        <target state="translated">Assinatura de membro inválida encontrada devido a um erro anterior</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueDoesNotHaveSetterType">
        <source>This value does not have a valid property setter type</source>
        <target state="translated">Este valor não possui um tipo de setter de propriedade válido</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertyGetter">
        <source>Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax.</source>
        <target state="translated">Forma inválida para um getter de propriedade. Pelo menos um argumento '()' é necessário quando a sintaxe explícita é usada.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertySetter">
        <source>Invalid form for a property setter. At least one argument is required.</source>
        <target state="translated">Forma inválida para um setter de propriedade. Pelo menos um argumento é necessário.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedByRef">
        <source>Unexpected use of a byref-typed variable</source>
        <target state="translated">Uso inesperado de uma variável do tipo byref</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMutationOfConstant">
        <source>Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'.</source>
        <target state="translated">Mutação inválida de uma expressão constante. Considere copiar a expressão para um local mutável, por exemplo: 'let mutable x = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueHasBeenCopied">
        <source>The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed</source>
        <target state="translated">O valor que foi copiado para assegurar que o original não seja mudado por esta operação ou porque a cópia está implícita ao retornar o struct de um membro e outro membro é acessado</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeInConstructionOfTuple">
        <source>Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding</source>
        <target state="translated">Valores definidos recursivamente não podem aparecer diretamente como parte da construção de um valor tupla em uma associação recursiva</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotAppearInConstructionOfType">
        <source>Recursive values cannot appear directly as a construction of the type '{0}' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.</source>
        <target state="translated">Valores recursivos não podem aparecer diretamente como uma construção do tipo '{0}' em uma associação recursiva. Este recurso foi removido da linguagem F#. Considere usar um registro em seu lugar.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeAssignedToNonMutableField">
        <source>Recursive values cannot be directly assigned to the non-mutable field '{0}' of the type '{1}' within a recursive binding. Consider using a mutable field instead.</source>
        <target state="translated">Valores recursivos não podem ser atribuídos diretamente ao campo não mutável '{0}' do tipo '{1}' em uma associação recursiva. Considere usar um registro em vez disso.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfAutoOpenAttribute">
        <source>Unexpected decode of AutoOpenAttribute</source>
        <target state="translated">Decodificação de AutoOpenAttribute inesperada</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInternalsVisibleToAttribute">
        <source>Unexpected decode of InternalsVisibleToAttribute</source>
        <target state="translated">Decodificação de InternalsVisibleToAttribute inesperada</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
        <source>Unexpected decode of InterfaceDataVersionAttribute</source>
        <target state="translated">Decodificação de InterfaceDataVersionAttribute inesperada</target>
        <note />
      </trans-unit>
      <trans-unit id="tastActivePatternsLimitedToSeven">
        <source>Active patterns cannot return more than 7 possibilities</source>
        <target state="translated">Padrões ativos não podem retornar mais que 7 possibilidades</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNotAConstantExpression">
        <source>This is not a valid constant expression or custom attribute value</source>
        <target state="translated">Esta não é uma expressão constante ou um valor de atributo personalizado válido</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAttributesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe mutability attributes differ</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs atributos de mutabilidade são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe names differ</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs nomes são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityCompiledNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled names differ</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs nomes compilados são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDisplayNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe display names differ</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs nomes para exibição são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAccessibilityMore">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \ n, mas sua assinatura especifica\n    {2}    \nA acessibilidade especificada na assinatura é maior que a especificada na implementação</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInlineFlagsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe inline flags differ</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs sinalizadores embutidos são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityLiteralConstantValuesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe literal constant values and/or attributes differ</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs valores de constantes literais e/ou atributos são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsTypeFunction">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é função de tipo e o outro não. A assinatura requer parâmetros de tipo explícito caso estejam presentes na implementação.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityParameterCountsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe respective type parameter counts differ</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nAs respectivas contagens de parâmetro de tipo são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityTypesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe types differ</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs tipos são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityExtensionsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is an extension member and the other is not</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é membro de extensão e o outro não</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityArityNotInferred">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nAn arity was not inferred for this value</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUma aridade não foi inferida para este valor</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe number of generic parameters in the signature and implementation differ (the signature declares {3} but the implementation declares {4}</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs números de parâmetros genéricos na assinatura e na implementação são diferentes (a assinatura declara {3} mas sua implementação declara {4}</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersAreDifferentKinds">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.</source>
        <target state="translated">O módulo '{0}' contém\n {1} \nmas sua assinatura especifica\n {2} \nOs parâmetros genéricos na assinatura e na implementação apresentam tipos diferentes. Talvez haja um atributo [&lt;Measure&gt;] ausente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAritiesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe arities in the signature and implementation differ. The signature specifies that '{3}' is function definition or lambda expression accepting at least {4} argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int.</source>
        <target state="translated">O módulo '{0}' contém\n {1} \n,mas sua assinatura especifica\n {2} \nAs aridades diferem na assinatura e na implementação. A assinatura especifica que '{3}' é definição de função ou expressão lambda aceitando pelo menos {4} argumentos, mas a implementação é um valor de função computado. Para declarar que um valor de função computado é uma implementação permitida, basta colocar seu tipo entre parênteses na assinatura, por exemplo,\n\tval {5}: int -&gt; (int -&gt; int)\nem vez de\n\tval {6}: int -&gt; int -&gt; int.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDotNetNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe CLI member names differ</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs nomes de membros CLI são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is static and the other isn't</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é estático e o outro não</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityVirtualsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is virtual and the other isn't</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é virtual e o outro não</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAbstractsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is abstract and the other isn't</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é abstrato e outro não</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityFinalsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is final and the other isn't</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é final e o outro não</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOverridesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is marked as an override and the other isn't</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é marcado como uma substituição e o outro não</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsConstructor">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a constructor/property and the other is not</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é construtor/propriedade e o outro não</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticButInstance">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nA representação compilada deste método é como um membro estático, mas a assinatura indica que sua representação compilada seria como um membro de instância</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInstanceButStatic">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member</source>
        <target state="translated">O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nA representação compilada deste método é como um membro de instância, mas a assinatura indica que sua representação compilada seria como um membro estático</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNamesDiffer">
        <source>The {0} definitions in the signature and implementation are not compatible because the names differ. The type is called '{1}' in the signature file but '{2}' in implementation.</source>
        <target state="translated">As definições {0} na assinatura e implementação não são compatíveis, pois os nomes são diferentes. O tipo é chamado de '{1}' no arquivo de assinatura, mas de '{2}' na implementação.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois as respectivas contagens de parâmetro de tipo são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a acessibilidade especificada na assinatura é maior que a especificada na implementação</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleMissingInterface">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature requires that the type supports the interface {2} but the interface has not been implemented</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura requer que o tipo dê suporte a interface {2}, mas esta não foi implementada</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a implementação diz que este tipo pode usar nulos como uma representação, mas a assinatura não</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a implementação diz que este tipo pode usar nulos como um valor adicional, mas a assinatura não</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura diz que este tipo pode usar nulos como uma representação, mas a implementação não</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura diz que este tipo pode usar nulos como um valor adicional, mas a implementação não</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.</source>
        <target state="translated">As definições de {0} para o tipo '{1}' na assinatura e na implementação não são compatíveis, porque o tipo de implementação é selado, mas a assinatura implica que não é. Adicione o atributo [&lt;Sealed&gt;] à assinatura.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.</source>
        <target state="translated">As definições de {0} para o tipo '{1}' na assinatura e na implementação não são compatíveis, porque o tipo de implementação não é selado, mas a assinatura implica que é. Adicione o atributo [&lt;Sealed&gt;] à implementação.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.</source>
        <target state="translated">As definições de {0} para o tipo '{1}' na assinatura e na implementação não são compatíveis, porque a implementação é uma classe abstrata, mas a assinatura não é. Adicione o atributo [&lt; AbstractClass&gt;] para a assinatura.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.</source>
        <target state="translated">As definições de {0} para o tipo '{1}' na assinatura e na implementação não são compatíveis, porque a assinatura é uma classe abstrata, mas a implementação não é. Adicione o atributo [&lt;AbstractClass&gt;] à implementação.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types have different base types</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois os tipos têm bases diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNumbersDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the number of {2}s differ</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o número de {2}s são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature defines the {2} '{3}' but the implementation does not (or does, but not in the same order)</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura define {2} '{3}', mas a implementação não (ou define em uma ordem diferente)</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines the {2} '{3}' but the signature does not (or does, but not in the same order)</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a implementação define {2} '{3}', mas a assinatura não (ou define em ordem diferente)</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a implementação define um struct, mas a assinatura define um tipo com representação oculta</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois uma representação do tipo CLI foi ocultada pela assinatura</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a type representation is being hidden by a signature</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois uma representação de tipo está sendo ocultada por uma assinatura</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types are of different kinds</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois os tipos são de diferentes tipos</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleILDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the IL representations differ</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois as representações de nível de integridade são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the representations differ</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois as representações são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldWasPresent">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was present in the implementation but not in the signature</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o campo {2} estava presente na implementação, mas não na assinatura</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a ordem dos campos está diferente na assinatura e na implementação</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was required by the signature but was not specified by the implementation</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o campo {2} foi solicitado pela assinatura, mas não foi especificado pela implementação</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field '{2}' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'.</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o campo '{2}' estava presente na implementação, mas não na assinatura. Os tipos struct agora devem revelar seus campos na assinatura para o tipo, embora os campos ainda possam ser rotulados como 'private' ou 'internal'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was required by the signature but was not specified by the implementation</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o membro abstrato '{2}' foi requerido pela assinatura, mas não foi especificado pela implementação</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was present in the implementation but not in the signature</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o membro abstrato '{2}' estava presente na implementação, mas não na assinatura</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature declares a {2} while the implementation declares a {3}</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura declara um {2} enquanto a implementação declara um {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abbreviations differ: {2} versus {3}</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois as abreviações são diferentes: {2} versus {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois uma abreviação está sendo ocultada por uma assinatura. A abreviação deve estar visível a outras linguagens CLIs. Considere deixar a abreviação visível na assinatura.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not</source>
        <target state="translated">As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura foi uma abreviação enquanto a implementação não</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButNamesDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">O módulo contém o construtor\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs nomes diferem</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButDataFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe respective number of data fields differ</source>
        <target state="translated">O módulo contém o construtor\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs respectivos números de campos de dados diferem</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButTypesOfFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe types of the fields differ</source>
        <target state="translated">O módulo contém o construtor\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs tipos dos campos são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButAccessibilityDiffers">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">O módulo contém o construtor\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nA acessibilidade especificada na assinatura é maior que a especificada na implementação</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedNamesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">O módulo contém o campo\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs nomes são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedAccessibilitiesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">O módulo contém o campo\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nA acessibilidade especificada na assinatura é maior que a especificada na implementação</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedStaticsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'static' modifiers differ</source>
        <target state="translated">O módulo contém o campo\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs modificadores 'static' são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedMutablesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'mutable' modifiers differ</source>
        <target state="translated">O módulo contém o campo\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs modificares 'mutable' são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedLiteralsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'literal' modifiers differ</source>
        <target state="translated">O módulo contém o campo\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs modificadores 'literal' são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedTypesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe types differ</source>
        <target state="translated">O módulo contém o campo\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs tipos são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveImplicitGenericInstantiation">
        <source>The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '{0}' and '{1}'. Consider using type annotations to resolve the ambiguity</source>
        <target state="translated">A instanciação implícita do constructo genérico neste ponto ou próximo a ele não pode ser resolvida porque ele conseguiu resolver tipos não relacionados múltiplos, por exemplo '{0}' e '{1}'. Considere usar anotações de tipo para resolver a ambiguidade</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInPrintf">
        <source>Could not resolve the ambiguity inherent in the use of a 'printf'-style format string</source>
        <target state="translated">Não foi possível resolver a ambiguidade inerente ao uso de uma cadeia de caracteres com formato de estilo 'printf'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInEnum">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position</source>
        <target state="translated">Não foi possível resolver a ambiguidade no uso de um construtor genérico com uma restrição 'enum' nesta posição ou próximo a ela</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInDelegate">
        <source>Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position</source>
        <target state="translated">Não foi possível resolver a ambiguidade no uso de um construtor genérico com uma restrição 'delegate' nesta posição ou próximo a ela</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInvalidValue">
        <source>Invalid value</source>
        <target state="translated">Valor inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleParamCountsDiffer">
        <source>The signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">A assinatura e implementação não são compatíveis porque as contagens de parâmetros de tipo respectivas são diferentes</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
        <source>The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation</source>
        <target state="translated">A assinatura e implementação não são compatíveis porque o parâmetro de tipo na classe/assinatura tem um requisito em tempo de compilação diferente de um membro/implementação</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDiffer">
        <source>The signature and implementation are not compatible because the declaration of the type parameter '{0}' requires a constraint of the form {1}</source>
        <target state="translated">A assinatura e implementação não são compatíveis porque a declaração do parâmetro de tipo '{0}' requer uma restrição da forma {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDifferRemove">
        <source>The signature and implementation are not compatible because the type parameter '{0}' has a constraint of the form {1} but the implementation does not. Either remove this constraint from the signature or add it to the implementation.</source>
        <target state="translated">A assinatura e implementação não são compatíveis porque o parâmetro de tipo '{0}' possui uma restrição da forma {1}, mas a implementação não. Remova esta restrição da assinatura ou a adicione à implementação.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableShouldOverrideObjectEquals">
        <source>The type '{0}' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'</source>
        <target state="translated">O tipo '{0}' implementa o 'System.IComparable'. Considere também adicionar uma substituição explícita para 'Object.Equals'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableDefaultObjectEqualsProvided">
        <source>The type '{0}' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly</source>
        <target state="translated">O tipo '{0}' implementa explicitamente o 'System.IComparable', mas não fornece nenhuma substituição correspondente para 'Object.Equals'. Uma implementação de 'Object.Equals' foi automaticamente fornecida e implementada via 'System.IComparable'. Considere implementar a substituição explícita 'Object.Equals'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCodeOrEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type</source>
        <target state="translated">O tipo struct, registro ou união '{0}' tem uma implementação explícita de 'Object.GetHashCode' ou 'Object.Equals'. Você deve aplicar o atributo 'CustomEquality' ao tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCode">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'</source>
        <target state="translated">O tipo struct, registro ou união '{0}' tem uma implementação explícita de 'Object.GetHashCode'. Considere implementar uma substituição correspondente para 'Object.Equals(obj)'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'</source>
        <target state="translated">O tipo struct, registro ou união '{0}' tem uma implementação explícita de 'Object.Equals'. Considere implementar uma substituição correspondente para 'Object.GetHashCode()'</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleHiddenBySignature">
        <source>The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">As definições de exceções não são compatíveis, pois um mapeamento de exceção CLI está sendo ocultado pela assinatura. O mapeamento de exceção deve ser visível a outros módulos. O módulo contém a definição da exceção\n    {0}    \n, mas sua assinatura especifica\n\t{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer">
        <source>The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">As definições de exceções não são compatíveis, pois as representações CLI são diferentes. O módulo contém a definição da exceção\n    {0}    \n, mas a sua assinatura especifica\n\t{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature">
        <source>The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">As definições de exceções não são compatíveis, pois a abreviação de exceção está ocultada pela assinatura. A abreviação deve ser visível a outras linguagens CLI. Considere deixar a abreviação visível na assinatura. O módulo contém a definição de assinatura\n    {0}    \nmas sua assinatura especifica\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleSignaturesDiffer">
        <source>The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">As definições de exceções não são compatíveis, pois as abreviações de exceções na assinatura e implementação são diferentes. O módulo contém a definição da exceção\n    {0}    \n, mas sua assinatura especifica\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer">
        <source>The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">As definições de exceções não são compatíveis, pois as declarações de exceções diferem. O módulo contém a definição da exceção\n    {0}    \n, mas sua assinatura especifica\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInSigButNotImpl">
        <source>The exception definitions are not compatible because the field '{0}' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">As definições de exceções não são compatíveis, pois o campo '{0}' foi requerido pela assinatura, mas não foi especificado na implementação. O módulo contém a definição da exceção\n    {1}    \n, mas sua assinatura especifica\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInImplButNotSig">
        <source>The exception definitions are not compatible because the field '{0}' was present in the implementation but not in the signature. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">As definições de exceções não são compatíveis, pois o campo '{0}' estava presente na implementação, mas não na assinatura. O módulo contém a definição da exceção\n    {1}    \n, mas sua assinatura especifica\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldOrderDiffers">
        <source>The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">As definições de exceções não são compatíveis, pois a ordem dos campos é diferente na assinatura e na implementação. O módulo contém a definição da exceção\n    {0}    \n, mas sua assinatura especifica\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelModuleNamespaceAttributesDifferInSigAndImpl">
        <source>The namespace or module attributes differ between signature and implementation</source>
        <target state="translated">Os atributos de namespace ou módulo diferem entre assinatura e implementação</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsOverconstrained">
        <source>This method is over-constrained in its type parameters</source>
        <target state="translated">Este método possui muitas restrições em seus parâmetros de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverloadNotFound">
        <source>No implementations of '{0}' had the correct number of arguments and type parameters. The required signature is '{1}'.</source>
        <target state="translated">Nenhuma implementação de '{0}' tinha o número correto de argumentos e parâmetros de tipo. A assinatura necessária é '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideWasAmbiguous">
        <source>The override for '{0}' was ambiguous</source>
        <target state="translated">A substituição para '{0}' foi ambígua</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMoreThenOneOverride">
        <source>More than one override implements '{0}'</source>
        <target state="translated">Mais de uma substituição implementa '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsSealed">
        <source>The method '{0}' is sealed and cannot be overridden</source>
        <target state="translated">O método '{0}' está selado não pode ser substituído</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideImplementsMoreThenOneSlot">
        <source>The override '{0}' implements more than one abstract slot, e.g. '{1}' and '{2}'</source>
        <target state="translated">A substituição '{0}' implementa mais de um slot abstrato, por exemplo '{1}' e '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelDuplicateInterface">
        <source>Duplicate or redundant interface</source>
        <target state="translated">Interface duplicada ou redundante</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNeedExplicitImplementation">
        <source>The interface '{0}' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.</source>
        <target state="translated">A interface '{0}' está incluída em múltiplos tipos de interface explicitamente implementada. Adicione uma implementação explícita desta interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNamedArgumentHasBeenAssignedMoreThenOnce">
        <source>A named argument has been assigned more than one value</source>
        <target state="translated">Foi atribuído mais de um valor a um argumento nomeado</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGiven">
        <source>No implementation was given for '{0}'</source>
        <target state="translated">Nenhuma implementação foi dada por '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenWithSuggestion">
        <source>No implementation was given for '{0}'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Nenhuma implementação foi dada por '{0}'. Note que todos membros de interface devem ser implementados e listados sob uma declaração apropriada 'interface', por exemplo 'interface ... with member ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfArguments">
        <source>The member '{0}' does not have the correct number of arguments. The required signature is '{1}'.</source>
        <target state="translated">O membro '{0}' não possui o número correto de argumentos. A assinatura necessária é '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters">
        <source>The member '{0}' does not have the correct number of method type parameters. The required signature is '{1}'.</source>
        <target state="translated">O membro '{0}' não possui o número correto de parâmetros de tipo de método. A assinatura necessária é '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters">
        <source>The member '{0}' does not have the correct kinds of generic parameters. The required signature is '{1}'.</source>
        <target state="translated">O membro '{0}' não possui os tipos corretos de parâmetros genéricos. A assinatura necessária é '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberCannotImplement">
        <source>The member '{0}' cannot be used to implement '{1}'. The required signature is '{2}'.</source>
        <target state="translated">O membro '{0}' não pode ser usado para implementar '{1}'. A assinatura necessária é '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILError">
        <source>Error while parsing embedded IL</source>
        <target state="translated">Erro ao analisar IL incorporado</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILTypeError">
        <source>Error while parsing embedded IL type</source>
        <target state="translated">Erro ao analisar tipo de IL embutido</target>
        <note />
      </trans-unit>
      <trans-unit id="astDeprecatedIndexerNotation">
        <source>This indexer notation has been removed from the F# language</source>
        <target state="translated">Esta notação de indexador foi removida do idioma F#</target>
        <note />
      </trans-unit>
      <trans-unit id="astInvalidExprLeftHandOfAssignment">
        <source>Invalid expression on left of assignment</source>
        <target state="translated">Expressão inválida à esquerda da atribuição</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoRefEqualsOnStruct">
        <source>The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'.</source>
        <target state="translated">O atributo 'ReferenceEquality' não pode ser usado em structs. Considere usar o atributo 'StructuralEquality' em seu lugar, ou implemente uma substituição para 'System.Object.Equals(obj)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="augInvalidAttrs">
        <source>This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'</source>
        <target state="translated">Este tipo usa uma combinação inválida dos atributos 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' e 'StructuralComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqualityNeedsNoComparison">
        <source>The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute</source>
        <target state="translated">O atributo 'NoEquality' deve ser usado em conjunto com o atributo 'NoComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructCompNeedsStructEquality">
        <source>The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute</source>
        <target state="translated">O atributo 'StructuralComparison' deve ser usado em conjunto com o atributo 'StructuralEquality'</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructEqNeedsNoCompOrStructComp">
        <source>The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes</source>
        <target state="translated">O atributo 'StructuralEquality' deve ser usado junto com os atributos 'NoComparison' ou 'StructuralComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="augTypeCantHaveRefEqAndStructAttrs">
        <source>A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes</source>
        <target state="translated">Um tipo não pode ter, ao mesmo tempo, os atributos 'ReferenceEquality' e 'StructuralEquality' ou 'StructuralComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="augOnlyCertainTypesCanHaveAttrs">
        <source>Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes</source>
        <target state="translated">Somente tipos registro, união, exceção e struct podem ser aumentados com os atributos 'ReferenceEquality', 'StructuralEquality' e 'StructuralComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="augRefEqCantHaveObjEquals">
        <source>A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">Um tipo com o atributo 'ReferenceEquality' não pode ter uma implementação explícita de 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' ou 'System.Collections.IStructuralEquatable'</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsObjEquals">
        <source>A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">Um tipo com o atributo 'CustomEquality' deve ter uma implementação explícita de pelo menos um dos 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' ou 'System.Collections.IStructuralEquatable'</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomCompareNeedsIComp">
        <source>A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'</source>
        <target state="translated">Um tipo com atributo 'CustomComparison' deve ter uma implementação explícita de pelo menos 'System.IComparable' ou 'System.Collections.IStructuralComparable'</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqNeedsNoObjEquals">
        <source>A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">Geralmente um tipo com atributo 'NoEquality' não deve ter uma implementação explícita de 'Object.Equals(obj)'. Desabilite este aviso caso a intenção seja obter interoperabilidade</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoCompCantImpIComp">
        <source>A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable&lt;_&gt;' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">Um tipo com o atributo 'NoComparison' não deve normalmente ter uma implementação explícita de 'System.IComparable', 'System.IComparable&lt;_&gt;' ou 'System.Collections.IStructuralComparable'. Desabilite esse aviso se isso for intencional para fins de interoperabilidade</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsNoCompOrCustomComp">
        <source>The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes</source>
        <target state="translated">O atributo 'CustomEquality' deve ser usado na conjunção com atributos 'NoComparison' ou 'CustomComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="forPositionalSpecifiersNotPermitted">
        <source>Positional specifiers are not permitted in format strings</source>
        <target state="translated">Não são permitidos especificadores posicionais em cadeias de caracteres de formato</target>
        <note />
      </trans-unit>
      <trans-unit id="forMissingFormatSpecifier">
        <source>Missing format specifier</source>
        <target state="translated">Especificador de formato ausente</target>
        <note />
      </trans-unit>
      <trans-unit id="forFlagSetTwice">
        <source>'{0}' flag set twice</source>
        <target state="translated">O sinalizador '{0}' foi definido duas vezes</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrefixFlagSpacePlusSetTwice">
        <source>Prefix flag (' ' or '+') set twice</source>
        <target state="translated">Sinalizador de prefixo (' ' ou '+') definido duas vezes</target>
        <note />
      </trans-unit>
      <trans-unit id="forHashSpecifierIsInvalid">
        <source>The # formatting modifier is invalid in F#</source>
        <target state="translated">O modificador de formatação # é inválido em F#</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadPrecision">
        <source>Bad precision in format specifier</source>
        <target state="translated">Especificador de formato com pouca precisão</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadWidth">
        <source>Bad width in format specifier</source>
        <target state="translated">Especificador de formato com largura ruim</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportZeroFlag">
        <source>'{0}' format does not support '0' flag</source>
        <target state="translated">O formato '{0}' não suporta sinalizador '0'</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrecisionMissingAfterDot">
        <source>Precision missing after the '.'</source>
        <target state="translated">Precisão após o '.' ausente</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatDoesntSupportPrecision">
        <source>'{0}' format does not support precision</source>
        <target state="translated">O sinalizador '{0}' não suporta precisão</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifier">
        <source>Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Especificador de formato inválido (após l ou L): esperado: ld,li,lo,lu,lx ou lX. No código F#, você pode usar %d, %x, %o ou %u no lugar, os quais estão sobrecarregados para trabalhar com todos os tipos básicos de inteiro.</target>
        <note />
      </trans-unit>
      <trans-unit id="forLIsUnnecessary">
        <source>The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">O 'l' nem 'L' são necessários neste especificador de formato. No código F#, você pode usar %d, %x, %o ou %u no lugar, os quais estão sobrecarregados para trabalhar com todos os tipos básicos de inteiro.</target>
        <note />
      </trans-unit>
      <trans-unit id="forHIsUnnecessary">
        <source>The 'h' or 'H' in this format specifier is unnecessary. You can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">O 'h' ou 'H' é desnecessário neste especificador de formato. Você pode usar %d, %x, %o ou %u em seu lugar, que estão sobrecarregados para trabalhar com todos os tipos básicos de inteiro.</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportPrefixFlag">
        <source>'{0}' does not support prefix '{1}' flag</source>
        <target state="translated">O '{0}' não dá suporte ao sinalizador '{1}' de prefixo</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifierGeneral">
        <source>Bad format specifier: '{0}'</source>
        <target state="translated">Especificador de formato incorreto: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="elSysEnvExitDidntExit">
        <source>System.Environment.Exit did not exit</source>
        <target state="translated">System.Environment.Exit não foi finalizado</target>
        <note />
      </trans-unit>
      <trans-unit id="elDeprecatedOperator">
        <source>The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined</source>
        <target state="translated">O tratamento deste operador agora é manipulado diretamente pelo compilador F# e seu significado não pode ser redefinido</target>
        <note />
      </trans-unit>
      <trans-unit id="chkProtectedOrBaseCalled">
        <source>A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope.</source>
        <target state="translated">Um membro protegido é chamado ou a 'base' está sendo usada. Isso só é permitido na implementação direta dos membros, uma vez que eles poderiam escapar do escopo de seus objetos.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkByrefUsedInInvalidWay">
        <source>The byref-typed variable '{0}' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.</source>
        <target state="translated">A variável do tipo byref '{0}' é usada de forma inválida. Byrefs não podem ser capturados por fechamentos ou transmitidos para funções de interiores.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkBaseUsedInInvalidWay">
        <source>The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.</source>
        <target state="translated">A palavra-chave 'base' é usada de forma incorreta. Chamadas de base não podem ser usadas em fechamentos. Considere utilizar um membro particular para fazer chamadas de base.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkVariableUsedInInvalidWay">
        <source>The variable '{0}' is used in an invalid way</source>
        <target state="translated">A variável '{0}' é usada de forma incorreta</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTypeLessAccessibleThanType">
        <source>The type '{0}' is less accessible than the value, member or type '{1}' it is used in.</source>
        <target state="translated">O tipo '{0}' é menos acessível que o valor, membro ou tipo '{1}' no qual ele é usado.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSystemVoidOnlyInTypeof">
        <source>'System.Void' can only be used as 'typeof&lt;System.Void&gt;' in F#</source>
        <target state="translated">'System.Void' só pode ser usado como 'typeof&lt;System.Void&gt;' em F#</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorUseOfByref">
        <source>A type instantiation involves a byref type. This is not permitted by the rules of Common IL.</source>
        <target state="translated">Uma instanciação de tipo inclui um tipo de byref. Isto não é permitido pelas regras do IL Comum.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorContainsCallToRethrow">
        <source>Calls to 'reraise' may only occur directly in a handler of a try-with</source>
        <target state="translated">Chamadas para 'reraise' só podem ocorrer diretamente em um manipulador de um try-with</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSplicingOnlyInQuotations">
        <source>Expression-splicing operators may only be used within quotations</source>
        <target state="translated">Operadores da união de expressão só podem ser usados entre aspas</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassSplicing">
        <source>First-class uses of the expression-splicing operator are not permitted</source>
        <target state="translated">Não são permitidos usos de primeira classe do operador da união de expressão</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassAddressOf">
        <source>First-class uses of the address-of operators are not permitted</source>
        <target state="translated">Utilizações de primeira classe dos operadores de endereço não são permitidas</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassRethrow">
        <source>First-class uses of the 'reraise' function is not permitted</source>
        <target state="translated">Não são permitidos usos de primeira classe da função 'reraise'</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAtThisPoint">
        <source>The byref typed value '{0}' cannot be used at this point</source>
        <target state="translated">O valor do tipo byref '{0}' não pode ser usado neste ponto</target>
        <note />
      </trans-unit>
      <trans-unit id="chkLimitationsOfBaseKeyword">
        <source>'base' values may only be used to make direct calls to the base implementations of overridden members</source>
        <target state="translated">Valores 'base' só podem ser usados para fazer chamadas diretas às implementações de base de membros substituídos</target>
        <note />
      </trans-unit>
      <trans-unit id="chkObjCtorsCantUseExceptionHandling">
        <source>Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.</source>
        <target state="translated">Construtores de objeto não podem usar try/with nem try/finally antes da inicialização do objeto. O que inclui construções como ' x in... ' que podem elaborar usos dessas construções. Esta é uma limitação imposta pelo IL Comum.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfAtThisPoint">
        <source>The address of the variable '{0}' cannot be used at this point</source>
        <target state="translated">O endereço da variável '{0}' não pode ser usado neste ponto</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressStaticFieldAtThisPoint">
        <source>The address of the static field '{0}' cannot be used at this point</source>
        <target state="translated">O endereço do campo estático '{0}' não pode ser usado neste ponto</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressFieldAtThisPoint">
        <source>The address of the field '{0}' cannot be used at this point</source>
        <target state="translated">O endereço do campo '{0}' não pode ser usado neste ponto</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfArrayElementAtThisPoint">
        <source>The address of an array element cannot be used at this point</source>
        <target state="translated">O endereço de um elemento de matriz não pode ser usado neste ponto</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFirstClassFuncNoByref">
        <source>The type of a first-class function cannot contain byrefs</source>
        <target state="translated">O tipo de uma função de primeira classe não pode conter byrefs</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReturnTypeNoByref">
        <source>A method return type would contain byrefs which is not permitted</source>
        <target state="translated">Um tipo de retorno de método conteria byrefs que não são permitidos</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidCustAttrVal">
        <source>Invalid custom attribute value (not a constant or literal)</source>
        <target state="translated">Valor do atributo personalizado inválido (não é uma constante ou um literal)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkAttrHasAllowMultiFalse">
        <source>The attribute type '{0}' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element.</source>
        <target state="translated">O tipo de atributo '{0}' possui 'AllowMultiple=false'. Instâncias múltiplas deste atributo não podem ser conectadas a um elemento de linguagem simples.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to its definition at or near '{2}'. This is an invalid forward reference.</source>
        <target state="translated">O membro '{0}' é usado de uma forma inválida. Um uso de '{1}' foi inferido anteriormente para sua definição em '{2}' ou próximo a ele. Esta é uma referência de encaminhamento inválida.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAsTopValue">
        <source>A byref typed value would be stored here. Top-level let-bound byref values are not permitted.</source>
        <target state="translated">Um valor do tipo byref seria armazenado aqui. Não são permitidos valores de alto nível associados a let byref.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReflectedDefCantSplice">
        <source>[&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">Termos [&lt;ReflectedDefinition&gt;] não podem conter usos de operador da união pré-fixo '%'</target>
        <note />
      </trans-unit>
      <trans-unit id="chkEntryPointUsage">
        <source>A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence.</source>
        <target state="translated">Uma função rotulada com o atributo 'EntryPointAttribute' deve ser a última declaração no último arquivo na sequência de compilação.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseCompiledForm">
        <source>compiled form of the union case</source>
        <target state="translated">forma compilada do caso união</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseDefaultAugmentation">
        <source>default augmentation of the union case</source>
        <target state="translated">aumento padrão do caso união</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameMethod">
        <source>The property '{0}' has the same name as a method in type '{1}'.</source>
        <target state="translated">A propriedade '{0}' tem o mesmo nome que um método no tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterSetterDoNotMatchAbstract">
        <source>The property '{0}' of type '{1}' has a getter and a setter that do not match. If one is abstract then the other must be as well.</source>
        <target state="translated">A propriedade '{0}' do tipo '{1}' tem um getter e um setter que não são correspondentes. Se um deles for abstrato, o outro também deverá ser.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameIndexer">
        <source>The property '{0}' has the same name as another property in type '{1}', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.</source>
        <target state="translated">A propriedade '{0}' tem o mesmo nome que outra propriedade no tipo '{1}', mas uma tem argumentos de indexador e a outra não. Talvez você precise de um argumento de indexador para uma das suas propriedades.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCantStoreByrefValue">
        <source>A type would store a byref typed value. This is not permitted by Common IL.</source>
        <target state="translated">Um tipo armazenaria um valor do tipo byref. Isso não é permitido pelo IL Comum.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethod">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}'.</source>
        <target state="translated">Método duplicado. O método '{0}' tem o mesmo nome e assinatura que outro método no tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodWithSuffix">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Método duplicado. O método '{0}' tem o mesmo nome e assinatura que outro método no tipo '{1}' assim que tuplas, funções, unidades de medida e/ou tipos fornecidos são apagados.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodCurried">
        <source>The method '{0}' has curried arguments but has the same name as another method in type '{1}'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.</source>
        <target state="translated">O método '{0}' tem argumentos na forma curried, mas tem o mesmo nome que outro método no tipo '{1}'. Os métodos com argumentos na forma curried não podem estar sobrecarregados. Considere usar um método que tenha argumentos na forma de tupla.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCurriedMethodsCantHaveOutParams">
        <source>Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments</source>
        <target state="translated">Os métodos com argumentos via currying não podem declarar os argumentos 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName' ou 'CallerFilePath'</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateProperty">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}'.</source>
        <target state="translated">Propriedade duplicada. A propriedade '{0}' tem o mesmo nome e assinatura que outra propriedade no tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicatePropertyWithSuffix">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Propriedade duplicada. A propriedade '{0}' tem o mesmo nome e assinatura que outra propriedade no tipo '{1}' assim que tuplas, funções, unidades de medida e/ou tipos fornecidos são apagados.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedType">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type.</source>
        <target state="translated">Método duplicado. O método abstrato '{0}' possui o mesmo nome e assinatura que um método abstrato em um tipo herdado.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedTypeWithSuffix">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Método duplicado. O método abstrato '{0}' possui mesmo nome e assinatura que um método abstrato em um tipo herdado assim que tuplas, funções, unidades de medida e/ou tipos fornecidos são apagados.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMultipleGenericInterfaceInstantiations">
        <source>This type implements the same interface at different generic instantiations '{0}' and '{1}'. This is not permitted in this version of F#.</source>
        <target state="translated">Este tipo implementa a mesma interface em instanciações genéricas diferentes '{0}' e '{1}'. Isto não é permitido nesta versão de F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkValueWithDefaultValueMustHaveDefaultValue">
        <source>The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check</source>
        <target state="translated">O tipo de um campo que usa o atributo 'DefaultValue' deve admitir inicialização padrão, ou seja, possuir 'null' como valor adequado, ou ser um tipo struct cujos todos campos admitem inicialização padrão. Você pode usar 'DefaultValue(false)' para desabilitar esta verificação</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefInTypeAbbrev">
        <source>The type abbreviation contains byrefs. This is not permitted by F#.</source>
        <target state="translated">A abreviação de tipo contém byrefs. Isto não é permitido por F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefBoundVarUsedInSplice">
        <source>The variable '{0}' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.</source>
        <target state="translated">A variável '{0}' está associada a uma cotação, mas é usada como parte de uma expressão de união. Isso não é permitido, pois pode sair do escopo.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericExprs">
        <source>Quotations cannot contain uses of generic expressions</source>
        <target state="translated">Cotações não podem conter utilizações de expressões genéricas</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericFunctions">
        <source>Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.</source>
        <target state="translated">Cotações não podem conter definições de funções que foram deduzidas ou declaradas como genéricas. Considere adicionar algumas restrições para fazer desta uma expressão cotada válida.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainObjExprs">
        <source>Quotations cannot contain object expressions</source>
        <target state="translated">Cotações não podem conter expressões de objeto </target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainAddressOf">
        <source>Quotations cannot contain expressions that take the address of a field</source>
        <target state="translated">Cotações não podem conter expressões que obtêm o endereço de um campo</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainStaticFieldRef">
        <source>Quotations cannot contain expressions that fetch static fields</source>
        <target state="translated">Cotações não podem conter expressões que buscam campos estáticos </target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainInlineIL">
        <source>Quotations cannot contain inline assembly code or pattern matching on arrays</source>
        <target state="translated">Cotações não podem conter código de assembly embutido ou padrões coincidentes em matrizes</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainDescendingForLoops">
        <source>Quotations cannot contain descending for loops</source>
        <target state="translated">Cotações não podem conter decrescentes para loops</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantFetchUnionIndexes">
        <source>Quotations cannot contain expressions that fetch union case indexes</source>
        <target state="translated">Cotações não podem conter expressões que busquem índices de casos união</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetUnionFields">
        <source>Quotations cannot contain expressions that set union case fields</source>
        <target state="translated">Cotações não podem conter expressões que definem campos de casos união</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetExceptionFields">
        <source>Quotations cannot contain expressions that set fields in exception values</source>
        <target state="translated">Cotações não podem conter expressões que definem campos nos valores de exceção</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantRequireByref">
        <source>Quotations cannot contain expressions that require byref pointers</source>
        <target state="translated">Cotações não podem conter expressões que requerem ponteiros byref</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantCallTraitMembers">
        <source>Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call</source>
        <target state="translated">As cotações não podem conter expressões que façam chamadas de restrição de membros ou usem operadores que resolvem implicitamente uma chamada de restrição de membro</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisConstant">
        <source>Quotations cannot contain this kind of constant</source>
        <target state="translated">Cotações não podem conter este tipo de constante</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisPatternMatch">
        <source>Quotations cannot contain this kind of pattern match</source>
        <target state="translated">Cotações não podem conter este tipo de correspondência de padrão</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainArrayPatternMatching">
        <source>Quotations cannot contain array pattern matching</source>
        <target state="translated">Cotações não podem conter correspondências de padrão de matriz</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisType">
        <source>Quotations cannot contain this kind of type</source>
        <target state="translated">Cotações não podem conter esta espécie de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeCannotBeResolvedAtCompileTime">
        <source>The declared type parameter '{0}' cannot be used here since the type parameter cannot be resolved at compile time</source>
        <target state="translated">O parâmetro do tipo declarado '{0}' não pode ser usado aqui, uma vez que o parâmetro de tipo não pode ser resolvido no tempo de compilação</target>
        <note />
      </trans-unit>
      <trans-unit id="csCodeLessGeneric">
        <source>This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'.</source>
        <target state="translated">Este código é menos genérico que o indicado pelas suas anotações. Uma unidade de medida especificada com uso de '_' foi determinada como '1', ou seja, sem dimensão. Considere tornar o código genérico ou remover a utilização de '_'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInferenceMaxDepth">
        <source>Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.</source>
        <target state="translated">Problema de inferência de tipo excessivamente complicado (profundidade de iteração máxima atingida). Considere adicionar mais anotações de tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectedArguments">
        <source>Expected arguments to an instance member</source>
        <target state="translated">Argumentos esperados para um membro de instância</target>
        <note />
      </trans-unit>
      <trans-unit id="csIndexArgumentMismatch">
        <source>This indexer expects {0} arguments but is here given {1}</source>
        <target state="translated">Este indexador espera argumentos {0}, mas aqui é dado {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenFunction">
        <source>Expecting a type supporting the operator '{0}' but given a function type. You may be missing an argument to a function.</source>
        <target state="translated">Um tipo que suporte o operador '{0}' era esperado, mas um tipo de função foi recebido. Pode estar faltando um argumento para alguma função.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenTuple">
        <source>Expecting a type supporting the operator '{0}' but given a tuple type</source>
        <target state="translated">Um tipo que suporte o operador '{0}' era esperado, mas um tipo de tupla foi recebido.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperator">
        <source>None of the types '{0}' support the operator '{1}'</source>
        <target state="translated">Nenhum dos tipos '{0}' oferece suporte ao operador '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperator">
        <source>The type '{0}' does not support the operator '{1}'</source>
        <target state="translated">O tipo '{0}' não oferece suporte ao operador '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperatorNullable">
        <source>None of the types '{0}' support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Nenhum dos tipos '{0}' oferece suporte ao operador '{1}'. Considere abrir o módulo 'Microsoft.FSharp.Linq.NullableOperators'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperatorNullable">
        <source>The type '{0}' does not support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">O tipo '{0}' não oferece suporte ao operador '{1}'. Considere abrir o módulo 'Microsoft.FSharp.Linq.NullableOperators'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportConversion">
        <source>The type '{0}' does not support a conversion to the type '{1}'</source>
        <target state="translated">O tipo '{0}' não suporta conversão para o tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is static</source>
        <target state="translated">O tipo '{0}' possui um método '{1}' (nome completo '{2}'), mas o método é estático</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsNotStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is not static</source>
        <target state="translated">O tipo '{0}' possui um método '{1}' (nome completo '{2}'), mas o método não é estático</target>
        <note />
      </trans-unit>
      <trans-unit id="csStructConstraintInconsistent">
        <source>The constraints 'struct' and 'not struct' are inconsistent</source>
        <target state="translated">As restrições 'struct' e 'not struct' são inconsistentes</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value</source>
        <target state="translated">O tipo '{0}' não possui 'null' como valor adequado</target>
        <note />
      </trans-unit>
      <trans-unit id="csNullableTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'.</source>
        <target state="translated">O tipo '{0}' não possui 'null' como valor adequado. Para criar um valor nulo para um tipo Nullable, use 'System.Nullable()'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison1">
        <source>The type '{0}' does not support the 'comparison' constraint because it has the 'NoComparison' attribute</source>
        <target state="translated">O tipo '{0}' não suporta a restrição 'comparison' porque ela não possui o atributo 'NoComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison2">
        <source>The type '{0}' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface</source>
        <target state="translated">O tipo '{0}' não suporta a restrição 'comparison'. Por exemplo, ele não suporta a interface 'System.IComparable'</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison3">
        <source>The type '{0}' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison</source>
        <target state="translated">O tipo '{0}' não suporta a restrição 'comparison' porque é um registro, união ou struct com um ou mais tipos de elementos estruturais que não suportam a restrição 'comparison'. Evite usar comparação com este tipo, a não ser que você adicione o atributo 'StructuralComparison' ao tipo para determinar qual tipo de campo não suporta comparação</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality1">
        <source>The type '{0}' does not support the 'equality' constraint because it has the 'NoEquality' attribute</source>
        <target state="translated">O tipo '{0}' não suporta a restrição 'equality' porque possui o atributo 'NoEquality'</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality2">
        <source>The type '{0}' does not support the 'equality' constraint because it is a function type</source>
        <target state="translated">O tipo '{0}' não suporta a restrição 'equality' porque ele é um tipo de função</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality3">
        <source>The type '{0}' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality</source>
        <target state="translated">O tipo '{0}' não suporta a restrição 'equality' porque é um registro, união ou struct com um ou mais tipos de elementos estruturais que não suportam a restrição 'equality'. Evite usar igualdade com este tipo, a não ser que você adicione o atributo 'StructuralEquality' ao tipo para determinar qual tipo de campo não suportará a igualdade</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotEnumType">
        <source>The type '{0}' is not a CLI enum type</source>
        <target state="translated">O tipo '{0}' não é um tipo enum CLI</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeHasNonStandardDelegateType">
        <source>The type '{0}' has a non-standard delegate type</source>
        <target state="translated">O tipo '{0}' tem um tipo delegado não padrão</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotDelegateType">
        <source>The type '{0}' is not a CLI delegate type</source>
        <target state="translated">O tipo '{0}' não é um tipo delegado CLI</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeParameterCannotBeNullable">
        <source>This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values.</source>
        <target state="translated">Esse parâmetro de tipo não pode ser instanciado como 'Nullable'. Esta é uma restrição imposta para assegurar que o significado de 'null' em algumas linguagens CLI não seja confuso quando usado em conjunto com valores 'Nullable'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructType">
        <source>A generic construct requires that the type '{0}' is a CLI or F# struct type</source>
        <target state="translated">Uma construção genérica requer que o tipo '{0}' seja um CLI ou tipo struct F#</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresUnmanagedType">
        <source>A generic construct requires that the type '{0}' is an unmanaged type</source>
        <target state="translated">Uma construção genérica requer que o tipo '{0}' seja um tipo não gerenciado</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeNotCompatibleBecauseOfPrintf">
        <source>The type '{0}' is not compatible with any of the types {1}, arising from the use of a printf-style format string</source>
        <target state="translated">O tipo '{0}' não é compatível com qualquer um dos tipos {1}, decorrentes da utilização de uma cadeia de caracteres do formato estilo printf</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresReferenceSemantics">
        <source>A generic construct requires that the type '{0}' have reference semantics, but it does not, i.e. it is a struct</source>
        <target state="translated">Uma construção genérica requer que o tipo '{0}' tenha semânticas de referência, mas ele não tem, ou seja, é um struct</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresNonAbstract">
        <source>A generic construct requires that the type '{0}' be non-abstract</source>
        <target state="translated">Uma construção genérica requer que o tipo '{0}' não seja abstrato</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresPublicDefaultConstructor">
        <source>A generic construct requires that the type '{0}' have a public default constructor</source>
        <target state="translated">Uma construção genérica requer que o tipo '{0}' tenha um construtor padrão público</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInstantiationLengthMismatch">
        <source>Type instantiation length mismatch</source>
        <target state="translated">Incompatibilidade de comprimento de instanciação de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="csOptionalArgumentNotPermittedHere">
        <source>Optional arguments not permitted here</source>
        <target state="translated">Argumentos opcionais não são permitidos aqui</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotStatic">
        <source>{0} is not a static member</source>
        <target state="translated">{0} não é um membro estático</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotInstance">
        <source>{0} is not an instance member</source>
        <target state="translated">{0} não é um membro de instância</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentLengthMismatch">
        <source>Argument length mismatch</source>
        <target state="translated">Incompatibilidade de comprimento do argumento</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentTypesDoNotMatch">
        <source>The argument types don't match</source>
        <target state="translated">Os tipos de argumento não coincidem</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodExpectsParams">
        <source>This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument</source>
        <target state="translated">Este método espera um parâmetro CLI 'params' nesta posição. 'params' é uma forma de transmitir um número de variável de argumentos para um método em linguagens como C#. Considere transmitir uma matriz para este argumento</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible">
        <source>The member or object constructor '{0}' is not {1}</source>
        <target state="translated">O construtor de membro ou objeto '{0}' não é {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible2">
        <source>The member or object constructor '{0}' is not {1}. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.</source>
        <target state="translated">O construtor de membro ou objeto '{0}' não é {1}. Membros particulares só podem ser acessados no tipo de declaração. Membros protegidos só podem ser acessados em um tipo de extensão e não podem ser acessados em expressões lambda internas.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAStaticMethod">
        <source>{0} is not a static method</source>
        <target state="translated">{0} não é um método estático</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAnInstanceMethod">
        <source>{0} is not an instance method</source>
        <target state="translated">{0} não é um método de instância</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberHasNoArgumentOrReturnProperty">
        <source>The member or object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">O construtor de membro ou objeto '{0}' não possui argumento ou propriedade de retorno configurável '{1}'. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorHasNoArgumentOrReturnProperty">
        <source>The object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">O construtor de objeto '{0}' não tem argumento ou propriedade de retorno configurável '{1}'. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csRequiredSignatureIs">
        <source>The required signature is {0}</source>
        <target state="translated">A assinatura requerida é {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'.</source>
        <target state="translated">O construtor de membro ou objeto '{0}' requer {1} argumentos. A assinatura requerida é '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch2">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'.</source>
        <target state="translated">O construtor de membro ou objeto '{0}' requer {1} argumentos adicionais. A assinatura requerida é '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch3">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">O construtor de membro ou objeto '{0}' requer {1} argumentos. A assinatura requerida é '{2}'. Alguns nomes dos argumentos em falta são {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch4">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">O construtor de membro ou objeto '{0}' requer {1} argumentos adicionais. A assinatura requerida é '{2}'. Alguns nomes dos argumentos em falta são {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityNamed">
        <source>The member or object constructor '{0}' requires {1} argument(s) but is here given {2} unnamed and {3} named argument(s). The required signature is '{4}'.</source>
        <target state="translated">O construtor de membro ou objeto '{0}' requer {1} argumentos, mas aqui são fornecidos os argumentos sem nome {2} e nomeado {3}. A assinatura requerida é '{4}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArity">
        <source>The member or object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">O construtor de membro ou objeto '{0}' obtém {1} argumentos, mas aqui são fornecidos {2}. A assinatura requerida é '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArity">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">O construtor de objeto '{0}' obtém {1} argumentos, mas aqui são fornecidos {2}. A assinatura requerida é '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArityProp">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',').</source>
        <target state="translated">O construtor de objeto '{0}' obtém {1} argumentos, mas aqui são fornecidos {2}. A assinatura requerida é '{3}'. Se alguns dos argumentos tiver que atribuir valores a propriedades, considere separar esses argumentos com uma vírgula (',').</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityType">
        <source>The member or object constructor '{0}' takes {1} type argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">O construtor de membro ou objeto '{0}' obtém argumentos de tipo {1}, mas aqui é dado {2}. A assinatura requerida é '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberNotAccessible">
        <source>A member or object constructor '{0}' taking {1} arguments is not accessible from this code location. All accessible versions of method '{2}' take {3} arguments.</source>
        <target state="translated">O construtor de objeto ou de membro '{0}' que obtém {1} argumentos não é acessível por meio desta localização do código. Todas as versões acessíveis do método '{2}' obtêm {3} argumentos.</target>
        <note />
      </trans-unit>
      <trans-unit id="csIncorrectGenericInstantiation">
        <source>Incorrect generic instantiation. No {0} member named '{1}' takes {2} generic arguments.</source>
        <target state="translated">Instanciação genérica incorreta. Nenhum membro {0} chamado '{1}' obtém argumentos genéricos {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberOverloadArityMismatch">
        <source>The member or object constructor '{0}' does not take {1} argument(s). An overload was found taking {2} arguments.</source>
        <target state="translated">O construtor de membro ou objeto '{0}' não obtém argumentos {1}. Uma sobrecarga foi encontrada ao obter argumentos {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments</source>
        <target state="translated">Nenhum membro {0} ou construtor de objeto com nome '{1}' obtém argumentos {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments2">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. Note the call to this member also provides {3} named arguments.</source>
        <target state="translated">Nenhum membro {0} ou construtor de objeto com nome '{1}' obtém argumentos {2}. Observe que a chamada para este membro também fornece argumentos com nome {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments3">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. The named argument '{3}' doesn't correspond to any argument or settable return property for any overload.</source>
        <target state="translated">Nenhum membro {0} ou construtor de objeto com nome '{1}' obtém argumentos {2}. O argumento nomeado '{3}' não corresponde a nenhum argumento ou propriedade de retorno configurável para qualquer sobrecarga.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodNotFound">
        <source>Method or object constructor '{0}' not found</source>
        <target state="translated">O método ou construtor de objeto '{0}' não foi encontrado</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFound">
        <source>No overloads match for method '{0}'.</source>
        <target state="translated">Nenhuma sobrecarga corresponde ao método '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsOverloaded">
        <source>A unique overload for method '{0}' could not be determined based on type information prior to this program point. A type annotation may be needed.</source>
        <target state="translated">Não foi possível determinar uma sobrecarga única para o método '{0}' com base nas informações de tipo anteriores a este ponto do programa. Uma anotação de tipo pode ser necessária.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCandidates">
        <source>Candidates: {0}</source>
        <target state="translated">Candidatos: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csSeeAvailableOverloads">
        <source>The available overloads are shown below.</source>
        <target state="translated">As sobrecargas disponíveis são mostradas abaixo.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsDoCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on 'do' bindings, but '{0}' was given.</source>
        <target state="translated">Os modificadores de acessibilidade não são permitidos em associações 'do', mas '{0}' foi fornecido.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInHashIf">
        <source>End of file in #if section begun at or after here</source>
        <target state="translated">Fim de arquivo na seção #if iniciada aqui ou anteriormente</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInString">
        <source>End of file in string begun at or before here</source>
        <target state="translated">Fim de arquivo na cadeia de caracteres iniciada aqui ou anteriormente</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimString">
        <source>End of file in verbatim string begun at or before here</source>
        <target state="translated">Fim de arquivo na cadeia de caracteres textual iniciada aqui ou anteriormente</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInComment">
        <source>End of file in comment begun at or before here</source>
        <target state="translated">Fim de arquivo no comentário iniciado aqui ou anteriormente</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInStringInComment">
        <source>End of file in string embedded in comment begun at or before here</source>
        <target state="translated">Fim de arquivo na cadeia de caracteres inserida no comentário iniciado aqui ou anteriormente</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimStringInComment">
        <source>End of file in verbatim string embedded in comment begun at or before here</source>
        <target state="translated">Fim de arquivo na cadeia de caracteres textual inserida no comentário iniciado aqui ou anteriormente</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInIfOcaml">
        <source>End of file in IF-OCAML section begun at or before here</source>
        <target state="translated">Fim de arquivo na seção de IF-OCAML iniciada aqui ou anteriormente</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInDirective">
        <source>End of file in directive begun at or before here</source>
        <target state="translated">Fim de arquivo na diretiva iniciada aqui ou anteriormente</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoHashEndIfFound">
        <source>No #endif found for #if or #else</source>
        <target state="translated">Nenhum #endif encontrado para #if ou #else</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIgnored">
        <source>Attributes have been ignored in this construct</source>
        <target state="translated">Os atributos foram ignorados neste constructo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInImplicitClassConstructors">
        <source>'use' bindings are not permitted in primary constructors</source>
        <target state="translated">As associações 'use' não são permitidas em construtores primários</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInModules">
        <source>'use' bindings are not permitted in modules and are treated as 'let' bindings</source>
        <target state="translated">Não são permitidas associações 'use' em módulos e são tratadas como ligações 'let'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIntegerForLoopRequiresSimpleIdentifier">
        <source>An integer for loop must use a simple identifier</source>
        <target state="translated">Um inteiro para um loop precisa usar um identificador simples</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyOneWithAugmentationAllowed">
        <source>At most one 'with' augmentation is permitted</source>
        <target state="translated">No máximo um aumento 'with' é permitido</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSemicolon">
        <source>A semicolon is not expected at this point</source>
        <target state="translated">Não é esperado ponto-e-vírgula neste ponto</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFile">
        <source>Unexpected end of input</source>
        <target state="translated">Final da entrada inesperado</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedVisibilityDeclaration">
        <source>Accessibility modifiers are not permitted here, but '{0}' was given.</source>
        <target state="translated">Os modificadores de acessibilidade não são permitidos aqui, mas '{0}' foi fornecido.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyHashDirectivesAllowed">
        <source>Only '#' compiler directives may occur prior to the first 'namespace' declaration</source>
        <target state="translated">Apenas diretivas de compilador '#' podem ficar antes da primeira declaração de 'namespace'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityDeclarationsShouldComePriorToIdentifier">
        <source>Accessibility modifiers should come immediately prior to the identifier naming a construct</source>
        <target state="translated">Modificadores de acessibilidade devem vir imediatamente antes do identificador na nomeação de um constructo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNamespaceOrModuleNotBoth">
        <source>Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'</source>
        <target state="translated">Os arquivos devem começar com a declaração de um namespace ou de um módulo, como 'namespace SomeNamespace.SubNamespace' ou 'module SomeNamespace.SomeModule', mas não ambos. Para definir um módulo dentro de um namespace, use 'module SomeModule =...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleAbbreviationMustBeSimpleName">
        <source>A module abbreviation must be a simple name, not a path</source>
        <target state="translated">Uma abreviação de módulo precisa ser um nome simples, não um caminho</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviation">
        <source>Ignoring attributes on module abbreviation</source>
        <target state="translated">Ignorando atributos em abreviação de módulo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">O atributo de acessibilidade '{0}' não é permitido na abreviação de módulo. As abreviações de módulo são sempre particulares.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">O atributo de visibilidade '{0}' não é permitido na abreviação de módulo. As abreviações de módulo são sempre particulares.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnClosedBlockInHashLight">
        <source>Unclosed block</source>
        <target state="translated">Bloco não foi fechado</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBeginOrStruct">
        <source>Unmatched 'begin' or 'struct'</source>
        <target state="translated">'begin' ou 'struct' incompatível</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleDefnMustBeSimpleName">
        <source>A module name must be a simple name, not a path</source>
        <target state="translated">Um nome de módulo precisa ser um nome simples, não um caminho</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEmptyModuleDefn">
        <source>Unexpected empty type moduleDefn list</source>
        <target state="translated">Lista de moduleDefn do tipo vazio inesperada</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesMustComeBeforeVal">
        <source>Attributes should be placed before 'val'</source>
        <target state="translated">Atributos devem ser localizados antes de 'val'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesAreNotPermittedOnInterfaceImplementations">
        <source>Attributes are not permitted on interface implementations</source>
        <target state="translated">Os atributos não são permitidos em implementações de interface</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxError">
        <source>Syntax error</source>
        <target state="translated">erro de sintaxe</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAugmentationsIllegalOnDelegateType">
        <source>Augmentations are not permitted on delegate type moduleDefns</source>
        <target state="translated">Aumentos não são permitidos no tipo delegado moduleDefns</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedClassInterfaceOrStruct">
        <source>Unmatched 'class', 'interface' or 'struct'</source>
        <target state="translated">'class', 'interface' ou 'struct' incompatível</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyTypeDefinition">
        <source>A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'.</source>
        <target state="translated">Uma definição de tipo requer um ou mais membros ou outras declarações. Se você pretende definir uma classe vazia, struct ou interface, então use 'type ... = class end', 'interface end' ou 'struct end'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedWith">
        <source>Unmatched 'with' or badly formatted 'with' block</source>
        <target state="translated">'with' incompatível ou bloco 'with' mal formatado</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetOrSetRequired">
        <source>'get', 'set' or 'get,set' required</source>
        <target state="translated">'get', 'set' ou 'get,set' necessários</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyClassCanTakeValueArguments">
        <source>Only class types may take value arguments</source>
        <target state="translated">Apenas tipos de classe podem ter argumentos de valor</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBegin">
        <source>Unmatched 'begin'</source>
        <target state="translated">'begin' incompatível</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidDeclarationSyntax">
        <source>Invalid declaration syntax</source>
        <target state="translated">Declaração de sintaxe inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetAndOrSetRequired">
        <source>'get' and/or 'set' required</source>
        <target state="translated">'get' e/ou 'set' necessários</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAnnotationsOnGetSet">
        <source>Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'</source>
        <target state="translated">Anotações de tipo em getters e setters de propriedade devem ser fornecidas após o 'get()' ou 'set(v)', por exemplo: 'with get() : string = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterMustHaveAtLeastOneArgument">
        <source>A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'</source>
        <target state="translated">Espera-se que uma propriedade getter seja uma função, por exemplo, 'get() = ...' ou 'get(índice) = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultipleAccessibilitiesForGetSet">
        <source>Multiple accessibilities given for property getter or setter</source>
        <target state="translated">Acessibilidades múltiplas fornecidas para getter ou setter de propriedade</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetSyntax">
        <source>Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '</source>
        <target state="translated">Setters de propriedade devem ser definidos com o uso de 'set value = ', 'set idx value = ' ou 'set (idx1,...,idxN) value = ... '</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInterfacesHaveSameVisibilityAsEnclosingType">
        <source>Interfaces always have the same visibility as the enclosing type</source>
        <target state="translated">Interfaces sempre possuem a mesma visibilidade que o tipo de delimitador</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAccessibilityModsIllegalForAbstract">
        <source>Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.</source>
        <target state="translated">Modificadores de acessibilidade não são permitidos neste membro. Slots abstratos sempre têm a mesma visibilidade que o tipo de delimitador.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalOnInherit">
        <source>Attributes are not permitted on 'inherit' declarations</source>
        <target state="translated">Não são permitidos atributos em declarações 'inherit'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityIllegalOnInherit">
        <source>Accessibility modifiers are not permitted on an 'inherits' declaration</source>
        <target state="translated">Modificadores de acessibilidade não são permitidos em uma declaração 'inherits'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInheritDeclarationsCannotHaveAsBindings">
        <source>'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding.</source>
        <target state="translated">Declarações 'inherit' não podem ter associações 'as'. Para acessar membros de classe base quando um método estiver sendo substituído pode se usar a sintaxe 'base.SomeMember'; 'base' é uma palavra-chave. Remova essa associação 'as'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalHere">
        <source>Attributes are not allowed here</source>
        <target state="translated">Não são permitidos atributos aqui</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for type abbreviations</source>
        <target state="translated">Modificadores de acessibilidade não são permitidos nesta posição para abreviações do tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumTypesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for enum types</source>
        <target state="translated">Modificadores de acessibilidade não são permitidos nesta posição para tipos enum</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAllEnumFieldsRequireValues">
        <source>All enum fields must be given values</source>
        <target state="translated">Todos campos enum devem ser valores especificados</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInlineAssemblyCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on inline assembly code types</source>
        <target state="translated">Modificadores de acessibilidade não são permitidos em tipo de código de assembly embutido</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIdentifier">
        <source>Unexpected identifier: '{0}'</source>
        <target state="translated">Identificador inesperado: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnionCasesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Modificadores de acessibilidade não são permitidos em casos união. Use ' type U = internal... ' ou ' type U = private... ' para dar uma acessibilidade à representação inteira.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on enumeration fields</source>
        <target state="translated">Modificadores de acessibilidade não são permitidos em campos de enumeração</target>
        <note />
      </trans-unit>
      <trans-unit id="parsConsiderUsingSeparateRecordType">
        <source>Consider using a separate record type instead</source>
        <target state="translated">Considere usar um tipo de registro separado em vez disso</target>
        <note />
      </trans-unit>
      <trans-unit id="parsRecordFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Modificadores de acessibilidade não são permitidos nos campos de registros. Use 'type R = internal ...' ou 'type R = private ...' para dar uma acessibilidade à representação inteira.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsLetAndForNonRecBindings">
        <source>The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings</source>
        <target state="translated">A forma de declaração 'let ... and ...' para associações não recursivas não são usadas em código F#. Considere usar uma sequência de associações 'let'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedParen">
        <source>Unmatched '('</source>
        <target state="translated">'(' incompatível</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessivePatternsShouldBeSpacedOrTupled">
        <source>Successive patterns should be separated by spaces or tupled</source>
        <target state="translated">Padrões sucessivos devem ser separados por espaços ou serem tuplas.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoMatchingInForLet">
        <source>No matching 'in' found for this 'let'</source>
        <target state="translated">Nenhum 'in' correspondente encontrado para 'let'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorInReturnForLetIncorrectIndentation">
        <source>Error in the return expression for this 'let'. Possible incorrect indentation.</source>
        <target state="translated">Erro na expressão de retorno para este 'let'. Possível recuo incorreto.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterLet">
        <source>The block following this '{0}' is unfinished. Every code block is an expression and must have a result. '{1}' cannot be the final code element in a block. Consider giving this block an explicit result.</source>
        <target state="translated">O bloco após '{0}' está inacabado. Cada bloco de código é uma expressão e deve ter um resultado. '{1}' não pode ser o elemento de código final em um bloco. Considere dar a este bloco um resultado explícito.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIncompleteIf">
        <source>Incomplete conditional. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Condicional incompleta. Esperado 'if &lt;expr&gt; then &lt;expr&gt;' ou 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAssertIsNotFirstClassValue">
        <source>'assert' may not be used as a first class value. Use 'assert &lt;expr&gt;' instead.</source>
        <target state="translated">'assert' não pode ser usado como um valor de primeira classe. Use 'assert &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">Identificador esperado</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInOrEqualExpected">
        <source>'in' or '=' expected</source>
        <target state="translated">'in' ou '=' esperado</target>
        <note />
      </trans-unit>
      <trans-unit id="parsArrowUseIsLimited">
        <source>The use of '-&gt;' in sequence and computation expressions is limited to the form 'for pat in expr -&gt; expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions.</source>
        <target state="translated">O uso de '-&gt;' em expressões de computação e sequência é limitado ao formulário 'for pat in expr -&gt; expr'. Use a sintaxe 'for... in... do... yield...' para gerar elementos em expressões mais complexas de sequência.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessiveArgsShouldBeSpacedOrTupled">
        <source>Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized</source>
        <target state="translated">Argumentos sucessivos devem ser separados por espaços ou serem tuplas; argumentos envolvendo aplicações de função ou de método devem estar entre parênteses</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracket">
        <source>Unmatched '['</source>
        <target state="translated">'[' incompatível</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingQualificationAfterDot">
        <source>Missing qualification after '.'</source>
        <target state="translated">Qualificação após '.' ausente</target>
        <note />
      </trans-unit>
      <trans-unit id="parsParenFormIsForML">
        <source>In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array</source>
        <target state="translated">No código F#, é possível usar o 'expr.[expr]'. Uma anotação de tipo pode ser necessária para indicar que a primeira expressão é uma matriz</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuote">
        <source>Mismatched quotation, beginning with '{0}'</source>
        <target state="translated">Cotação incompatível, começando com '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatched">
        <source>Unmatched '{0}'</source>
        <target state="translated">'{0}' incompatível</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracketBar">
        <source>Unmatched '[|'</source>
        <target state="translated">'[|' incompatível</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBrace">
        <source>Unmatched '{{'</source>
        <target state="translated">'{{' incompatível</target>
        <note />
      </trans-unit>
      <trans-unit id="parsFieldBinding">
        <source>Field bindings must have the form 'id = expr;'</source>
        <target state="translated">Associações de campo devem ter a forma ' id = expr; '</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMemberIllegalInObjectImplementation">
        <source>This member is not permitted in an object implementation</source>
        <target state="translated">Este membro não é permitido em uma implementação do objeto</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingFunctionBody">
        <source>Missing function body</source>
        <target state="translated">Corpo de função ausente</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxErrorInLabeledType">
        <source>Syntax error in labelled type argument</source>
        <target state="translated">Erro de sintaxe no argumento de tipo rotulado</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedInfixOperator">
        <source>Unexpected infix operator in type expression</source>
        <target state="translated">Operador infixo inesperado na expressão de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultiArgumentGenericTypeFormDeprecated">
        <source>The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident&lt;typ,...,typ&gt;' instead</source>
        <target state="translated">A sintaxe '(typ,...,typ) ident' não é usada no código F#. Use 'ident&lt;typ,...,typ&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidLiteralInType">
        <source>Invalid literal in type</source>
        <target state="translated">Literal inválido no tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedOperatorForUnitOfMeasure">
        <source>Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'.</source>
        <target state="translated">Operador infixo inesperado na expressão de unidade de medida. Os operadores válidos são '*','/' e '^'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIntegerLiteralForUnitOfMeasure">
        <source>Unexpected integer literal in unit-of-measure expression</source>
        <target state="translated">Literal de inteiro inesperado na expressão de unidade de medida</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedTypeParameter">
        <source>Syntax error: unexpected type parameter specification</source>
        <target state="translated">Erro de sintaxe: especificação de parâmetro de tipo inesperada</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuotationName">
        <source>Mismatched quotation operator name, beginning with '{0}'</source>
        <target state="translated">Nome de operador de cotação incompatível, começando com '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseMustBeginWithUpperCase">
        <source>Active pattern case identifiers must begin with an uppercase letter</source>
        <target state="translated">Identificadores de caso de padrão ativo precisam ser iniciados com uma letra maiúscula</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseContainsPipe">
        <source>The '|' character is not permitted in active pattern case identifiers</source>
        <target state="translated">O caractere '|' não é permitido em identificadores de caso de padrão ativo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalDenominatorForMeasureExponent">
        <source>Denominator must not be 0 in unit-of-measure exponent</source>
        <target state="translated">O denominador não deve ser 0 no expoente de unidade de medida</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoEqualShouldFollowNamespace">
        <source>No '=' symbol should follow a 'namespace' declaration</source>
        <target state="translated">Nenhum símbolo '=' deve seguir uma declaração 'namespace'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleStructEndDeprecated">
        <source>The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">A sintaxe 'module ... = struct .. end' não é usada no código F#. Considere usar 'module ... = begin .. end'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleSigEndDeprecated">
        <source>The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">A sintaxe 'module ... : sig .. end' não é usada no código F#. Considere usar 'module ... = begin .. end'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticFieldUsedWhenInstanceFieldExpected">
        <source>A static field was used where an instance field is expected</source>
        <target state="translated">Um campo estático foi usado onde era esperado um campo de instância</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodNotAccessible">
        <source>Method '{0}' is not accessible from this code location</source>
        <target state="translated">O método '{0}' não é acessível no local deste código</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplicitMeasureFollowingSlash">
        <source>Implicit product of measures following /</source>
        <target state="translated">Produto de medida implícito seguindo /</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedMeasureAnon">
        <source>Unexpected SynMeasure.Anon</source>
        <target state="translated">SynMeasure.Anon Inesperado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonZeroConstantCannotHaveGenericUnit">
        <source>Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.</source>
        <target state="translated">Constantes não nulas não podem ter unidades genéricas. Para um zero genérico, grave 0.0&lt;_&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSeqResultsUseYield">
        <source>In sequence expressions, results are generated using 'yield'</source>
        <target state="translated">Em expressões de sequência, os resultados são gerados com o uso de 'yield'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedBigRationalConstant">
        <source>Unexpected big rational constant</source>
        <target state="translated">Constante racional grande inesperada</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForUnitsOfMeasure">
        <source>Units-of-measure supported only on float, float32, decimal and signed integer types</source>
        <target state="translated">Unidades de medida só são suportadas em tipos float, float32, decimal e inteiro com sinal</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstUint16Array">
        <source>Unexpected Const_uint16array</source>
        <target state="translated">Const_uint16array inesperado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstByteArray">
        <source>Unexpected Const_bytearray</source>
        <target state="translated">Const_bytearray inesperado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterRequiresName">
        <source>A parameter with attributes must also be given a name, e.g. '[&lt;Attribute&gt;] Name : Type'</source>
        <target state="translated">Um parâmetro com atributos também deve receber um nome, ex.: '[&lt;Attribute&gt;] Name : Type'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnValuesCannotHaveNames">
        <source>Return values cannot have names</source>
        <target state="translated">Valores retornados não podem ter nomes</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberKindPropertyGetSetNotExpected">
        <source>MemberKind.PropertyGetSet only expected in parse trees</source>
        <target state="translated">MemberKind.PropertyGetSet só é esperado em árvores de análise</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainValues">
        <source>Namespaces cannot contain values. Consider using a module to hold your value declarations.</source>
        <target state="translated">Namespaces não podem conter valores. Considere usar um módulo para isentar suas declarações de valores.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainExtensionMembers">
        <source>Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.</source>
        <target state="translated">Namespaces não podem conter membros de extensão, exceto no mesmo arquivo e grupo de declaração de namespace, em que o tipo é definido. Considere o uso de um módulo para reter declarações de membros de extensão.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributes">
        <source>Multiple visibility attributes have been specified for this identifier</source>
        <target state="translated">Atributos de visibilidade múltipla foram especificados por este identificador</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributesWithLet">
        <source>Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions.</source>
        <target state="translated">Atributos de visibilidade múltipla foram especificados por este identificador. Associações 'let' em classes são sempre privadas, como quaisquer associações 'let' nestas expressões.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForRelationalOperator">
        <source>The name '({0})' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">O nome '({0})' não deve ser usado como um nome de membro. Para definir semânticas de comparação para um tipo, implemente a interface 'System.IComparable'. Se for definir um membro estático para uso em outras linguagens CLI use o nome '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForEquality">
        <source>The name '({0})' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">O nome '({0})' não deve ser usado como um nome de membro. Para definir a semântica de igualdade substitua o membro 'Object.Equals'. Se for definir um membro estático para uso em outras linguagens CLI, use o nome '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberName">
        <source>The name '({0})' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">O nome '({0})' não deve ser usado como um nome de membro. Se for definir um membro estático para uso em outras linguagens CLI, use o nome '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameFixedTypes">
        <source>The name '({0})' should not be used as a member name because it is given a standard definition in the F# library over fixed types</source>
        <target state="translated">O nome '({0})' não deve ser usado como um nome de membro porque ele é dado a uma definição padrão na biblioteca F# sobre tipos fixos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionRelational">
        <source>The '{0}' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type.</source>
        <target state="translated">O operador '{0}' não deve ser referenciado normalmente. Para definir semânticas de comparação sobrecarregadas para um tipo particular, implemente a interface 'System.IComparable' na definição deste tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionEquality">
        <source>The '{0}' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type.</source>
        <target state="translated">O operador '{0}' não deve ser referenciado normalmente. Para definir semânticas de igualdade para um tipo, substitua o membro 'Object.Equals' na definição deste tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinition">
        <source>The '{0}' operator should not normally be redefined. Consider using a different operator name</source>
        <target state="translated">O operador '{0}' não deve ser referenciado normalmente. Considere usar um nome de operador diferente</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexOperatorDefinition">
        <source>The '{0}' operator cannot be redefined. Consider using a different operator name</source>
        <target state="translated">O operador '{0}' não pode ser redefinido. Considere usar um nome de operador diferente</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectModuleOrNamespaceParent">
        <source>Expected module or namespace parent {0}</source>
        <target state="translated">Pai de módulo ou namespace {0} esperado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">O tipo struct, registro ou união '{0}' implementa explicitamente a interface 'System.IComparable'. Você deve aplicar o atributo 'CustomComparison' ao tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsGenericIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable&lt;_&gt;' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.</source>
        <target state="translated">O struct, registro ou tipo de união '{0}' implementa a interface 'System.IComparable&lt;_&gt;' explicitamente. Você deve aplicar o atributo 'CustomComparison' ao tipo e fornecer uma implementação consistente da interface não genérica System.IComparable.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">O tipo de struct, registro ou união '{0}' implementa explicitamente a interface 'System.IStructuralComparable'. Aplique o atributo 'CustomComparison' ao tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordFieldInconsistentTypes">
        <source>This record contains fields from inconsistent types</source>
        <target state="translated">Este registro contém campos de tipos inconsistentes</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportStubsCannotBeInlined">
        <source>DLLImport stubs cannot be inlined</source>
        <target state="translated">Stubs DLLImport não podem ser embutidos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCanOnlyBindThisAtMemberDeclaration">
        <source>Structs may only bind a 'this' parameter at member declarations</source>
        <target state="translated">Os structs só podem vincular um parâmetro 'this' em declarações de membros</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedExprAtRecInfPoint">
        <source>Unexpected expression at recursive inference point</source>
        <target state="translated">Expressão inesperada no ponto de inferência recursiva</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLessGenericBecauseOfAnnotation">
        <source>This code is less generic than required by its annotations because the explicit type variable '{0}' could not be generalized. It was constrained to be '{1}'.</source>
        <target state="translated">Este código é menos genérico que o requerido por suas anotações porque não foi possível gerar a variável de tipo explícito '{0}'. Ela foi restrita para ser '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstrainedTypeVariableCannotBeGeneralized">
        <source>One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types</source>
        <target state="translated">Uma ou mais classes explícitas ou variáveis de tipo função explícita para essa associação não puderam ser geradas, porque foram restritas a outros tipos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericParameterHasBeenConstrained">
        <source>A generic type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Um parâmetro de tipo genérico foi usado de modo que ficou restrito a ser sempre '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterHasBeenConstrained">
        <source>This type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Este parâmetro de tipo foi usado de forma que fique restrito a ser sempre '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParametersInferredAreNotStable">
        <source>The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</source>
        <target state="translated">Os parâmetros de tipo inferidos para este valor não são estáveis sob o apagamento das abreviações de tipo. Isto é devido ao uso de abreviações de tipo que soltam ou reordenem parâmetros de tipo, ex.: \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nDeclare os parâmetros de tipo para este valor explicitamente, ex.:\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeParameterInvalid">
        <source>Explicit type parameters may only be used on module or member bindings</source>
        <target state="translated">Parâmetros de tipo explícitos só podem ser usados em associações de módulo ou membro</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridingMethodRequiresAllOrNoTypeParameters">
        <source>You must explicitly declare either all or no type parameters when overriding a generic abstract method</source>
        <target state="translated">Você deve declarar explicitamente todos ou nenhum parâmetro de tipo quando for substituir um método abstrato genérico</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldsDoNotDetermineUniqueRecordType">
        <source>The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type</source>
        <target state="translated">Os rótulos de campo e tipo esperado desta expressão ou padrão de registro não determinam exclusivamente um tipo de registro correspondente</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldAppearsTwiceInRecord">
        <source>The field '{0}' appears twice in this record expression or pattern</source>
        <target state="translated">O campo '{0}' aparece duas vezes nesta expressão de registro ou padrão</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnknownUnion">
        <source>Unknown union case</source>
        <target state="translated">Caso união desconhecido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotSufficientlyGenericBecauseOfScope">
        <source>This code is not sufficiently generic. The type variable {0} could not be generalized because it would escape its scope.</source>
        <target state="translated">Este código não é suficientemente genérico. A variável de tipo {0} não pode ser gerada porque ela escaparia de seu escopo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyRequiresExplicitTypeParameters">
        <source>A property cannot have explicit type parameters. Consider using a method instead.</source>
        <target state="translated">Uma propriedade não pode ter parâmetros de tipo explícito. Considere usar um método.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorCannotHaveTypeParameters">
        <source>A constructor cannot have explicit type parameters. Consider using a static construction method instead.</source>
        <target state="translated">Um construtor não pode ter parâmetros de tipo explícitos. Considere usar um método de construção estática.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInstanceMemberRequiresTarget">
        <source>This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'.</source>
        <target state="translated">Este membro de instância precisa de um parâmetro para representar um objeto a ser chamado. Deixe o membro estático ou use a notação 'membro x.Membro(argumentos) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertyInSyntaxTree">
        <source>Unexpected source-level property specification in syntax tree</source>
        <target state="translated">Especificação de propriedade em nível de código inesperada na árvore de sintaxe</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializerRequiresArgument">
        <source>A static initializer requires an argument</source>
        <target state="translated">Um inicializador estático requer um argumento</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorRequiresArgument">
        <source>An object constructor requires an argument</source>
        <target state="translated">Um construtor de objeto requer um argumento</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticMemberShouldNotHaveThis">
        <source>This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'.</source>
        <target state="translated">Este membro estático não deve ter um parâmetro 'this'. Considere usar a notação 'member Member(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitStaticInitializerSyntax">
        <source>An explicit static initializer should use the syntax 'static new(args) = expr'</source>
        <target state="translated">Um inicializador estático explícito deve usar a sintaxe 'static new(args) = expr'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitObjectConstructorSyntax">
        <source>An explicit object constructor should use the syntax 'new(args) = expr'</source>
        <target state="translated">Um construtor de objeto explícito deve usar a sintaxe 'new(args) = expr'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertySpec">
        <source>Unexpected source-level property specification</source>
        <target state="translated">Especificação de propriedade no nível da origem inesperada</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionFormDeprecated">
        <source>This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions.</source>
        <target state="translated">Esta forma de expressão de objeto não é usada em F#. Use 'member this.MemberName ... = ...' para definir implementações de membros em expressões de objetos.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDeclaration">
        <source>Invalid declaration</source>
        <target state="translated">Declaração inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesInvalidInPatterns">
        <source>Attributes are not allowed within patterns</source>
        <target state="translated">Atributos não são permitidos em padrões</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitTypeArguments">
        <source>The generic function '{0}' must be given explicit type argument(s)</source>
        <target state="translated">Argumentos de tipo explícito devem ser dados à função genérica '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoesNotAllowExplicitTypeArguments">
        <source>The method or function '{0}' should not be given explicit type argument(s) because it does not declare its type parameters explicitly</source>
        <target state="translated">O método ou função '{0}' não deverá receber argumentos de tipo explícito porque eles não declaram explicitamente seus parâmetros de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterArityMismatch">
        <source>This value, type or method expects {0} type parameter(s) but was given {1}</source>
        <target state="translated">Este valor, tipo ou método espera parâmetros de tipo {0}, mas foi dado {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultStructConstructorCall">
        <source>The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization</source>
        <target state="translated">O construtor padrão de um tipo struct iniciado com zero só pode ser usado se todos os campos do tipo struct admitirem inicialização padrão</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindIDisposable">
        <source>Couldn't find Dispose on IDisposable, or it was overloaded</source>
        <target state="translated">Não foi possível localizar Dispose em IDisposable, ou ele estava sobrecarregado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonLiteralCannotBeUsedInPattern">
        <source>This value is not a literal and cannot be used in a pattern</source>
        <target state="translated">Este valor não é um literal e não pode ser usado em um padrão</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsReadonly">
        <source>This field is readonly</source>
        <target state="translated">Este campo é somente leitura</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameArgumentsMustAppearLast">
        <source>Named arguments must appear after all other arguments</source>
        <target state="translated">Argumentos nomeados devem aparecer depois de todos os argumentos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitLambda">
        <source>This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking {0} arguments.</source>
        <target state="translated">Este valor de função está sendo usado para construir um tipo delegado cuja assinatura inclui argumento byref. Você deve usar uma expressão lambda que obtenha argumentos {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCannotBeEnumerated">
        <source>The type '{0}' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method</source>
        <target state="translated">O tipo '{0}' não é um tipo cujos valores podem ser enumerados com esta sintaxe, ou seja, não é compatível com seq&lt;_&gt;, IEnumerable&lt;_&gt; nem IEnumerable e não tem um método GetEnumerator</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMixtureOfRecursiveForms">
        <source>This recursive binding uses an invalid mixture of recursive forms</source>
        <target state="translated">Esta associação recursiva usa uma mistura inválida de formas recursivas</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectConstructionExpression">
        <source>This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.</source>
        <target state="translated">Esta não é uma expressão de construção de objeto válida. Construtores de objeto explícitos devem chamar um construtor alternativo ou então iniciar todos os campos do objeto e especificar uma chamada para um construtor de superclasse.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraint">
        <source>Invalid constraint</source>
        <target state="translated">Restrição inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraintTypeSealed">
        <source>Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution</source>
        <target state="translated">Restrição inválida: o tipo usado para restrição está selado, o que significa que a restrição só pode ser satisfeita por no máximo uma solução</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumConstraint">
        <source>An 'enum' constraint must be of the form 'enum&lt;type&gt;'</source>
        <target state="translated">Uma restrição 'enum' deve ser da forma 'enum&lt;type&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNewConstraint">
        <source>'new' constraints must take one argument of type 'unit' and return the constructed type</source>
        <target state="translated">Restrições 'new' devem pegar um argumento do tipo 'unit' e retornar o tipo construído</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPropertyType">
        <source>This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -&gt; ty3'. Properties returning functions should have types of the form '(ty1 -&gt; ty2)'.</source>
        <target state="translated">Essa propriedade tem um tipo inválido. Propriedades que usam vários argumentos do indexador devem ter tipos da forma 'ty1 * ty2 -&gt; ty3'. Propriedades retornando funções devem ter tipos da forma '(ty1 -&gt; ty2)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureMarkWithAttribute">
        <source>Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.</source>
        <target state="translated">Um parâmetro de unidade de medida é esperado, não um parâmetro de tipo. Parâmetros de unidade de medida explícitos devem ser marcados com o atributo [&lt;Measure&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeParameter">
        <source>Expected type parameter, not unit-of-measure parameter</source>
        <target state="translated">Um parâmetro de tipo é esperado, não um parâmetro de unidade de medida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeNotUnitOfMeasure">
        <source>Expected type, not unit-of-measure</source>
        <target state="translated">Tipo esperado, não unidade de medida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureNotType">
        <source>Expected unit-of-measure, not type</source>
        <target state="translated">Unidade de medida esperada, não tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUnitsOfMeasurePrefix">
        <source>Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.</source>
        <target state="translated">As unidades de medida não podem ser usadas como argumentos de prefixo para um tipo. Reescreva como argumentos de sufixo entre colchetes.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnitsOfMeasureInvalidInTypeConstructor">
        <source>Unit-of-measure cannot be used in type constructor application</source>
        <target state="translated">A unidade de medida não pode ser usada em aplicativos de construtor de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireBuilderMethod">
        <source>This control construct may only be used if the computation expression builder defines a '{0}' method</source>
        <target state="translated">Esta construção de controle só é usada se o compilador de expressões de computação definir um método '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoNestedTypes">
        <source>This type has no nested types</source>
        <target state="translated">Este tipo não possui tipos aninhados</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSymbolInTypeExpression">
        <source>Unexpected {0} in type expression</source>
        <target state="translated">{0} inesperado na expressão de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterInvalidAsTypeConstructor">
        <source>Type parameter cannot be used as type constructor</source>
        <target state="translated">O parâmetro de tipo não pode ser usado como construtor de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalSyntaxInTypeExpression">
        <source>Illegal syntax in type expression</source>
        <target state="translated">Sintaxe inválida na expressão de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousUnitsOfMeasureCannotBeNested">
        <source>Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression</source>
        <target state="translated">Uma medida de unidade anônima não poder ser aninhada dentro de outra expressão de unidade de medida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousTypeInvalidInDeclaration">
        <source>Anonymous type variables are not permitted in this declaration</source>
        <target state="translated">Variáveis de tipos anônimos não são permitidas nesta declaração </target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSlashInType">
        <source>Unexpected / in type</source>
        <target state="translated">Inesperado / em tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedTypeArguments">
        <source>Unexpected type arguments</source>
        <target state="translated">Argumentos de tipo inesperados</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsOnlyOnMembers">
        <source>Optional arguments are only permitted on type members</source>
        <target state="translated">Argumentos opcionais somente são permitidos em membros do tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameNotBoundInPattern">
        <source>Name '{0}' not bound in pattern context</source>
        <target state="translated">Nome '{0}' não associado no contexto de padrão</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNonPrimitiveLiteralInPatternMatch">
        <source>Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when &lt;variable&gt; = &lt;constant&gt;' at the end of the match clause.</source>
        <target state="translated">Constantes literais numéricas não-primitivas não podem ser usadas em correspondências de padrões porque elas podem ser mapeadas para vários tipos diferentes através do uso de um módulo NumericLiteral. Substitua por uma variável e use 'when &lt;variable&gt; = &lt;constant&gt;' no fim da cláusula de correspondência.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentUsage">
        <source>Type arguments cannot be specified here</source>
        <target state="translated">Argumentos de tipos não podem ser especificados aqui</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireActivePatternWithOneResult">
        <source>Only active patterns returning exactly one result may accept arguments</source>
        <target state="translated">Somente padrões ativos que retornam exatamente um resultado podem aceitar argumentos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidArgForParameterizedPattern">
        <source>Invalid argument to parameterized pattern label</source>
        <target state="translated">Argumento inválido para rótulo padrão parametrizado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexIntoActivePatternArray">
        <source>Internal error. Invalid index into active pattern array</source>
        <target state="translated">Erro interno. Indexação inválida em matriz de padrão ativa</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseDoesNotTakeArguments">
        <source>This union case does not take arguments</source>
        <target state="translated">Este caso união não obtém argumentos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseRequiresOneArgument">
        <source>This union case takes one argument</source>
        <target state="translated">Este caso união obtém um argumento</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseExpectsTupledArguments">
        <source>This union case expects {0} arguments in tupled form</source>
        <target state="translated">Este caso união espera argumentos {0} na forma de tupla</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotStatic">
        <source>Field '{0}' is not static</source>
        <target state="translated">O campo '{0}' não é estático</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNotLiteralCannotBeUsedInPattern">
        <source>This field is not a literal and cannot be used in a pattern</source>
        <target state="translated">Este campo não é um literal e não pode ser usado como um padrão</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireVarConstRecogOrLiteral">
        <source>This is not a variable, constant, active recognizer or literal</source>
        <target state="translated">Isto não é uma variável, constante, reorganizador ativo ou literal</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPattern">
        <source>This is not a valid pattern</source>
        <target state="translated">Este não é um padrão válido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseWhenPatternGuard">
        <source>Character range matches have been removed in F#. Consider using a 'when' pattern guard instead.</source>
        <target state="translated">Correspondências de intervalo de caractere foram removidas em F#. Considere usar um 'when' na proteção padrão.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalPattern">
        <source>Illegal pattern</source>
        <target state="translated">Padrão inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxErrorUnexpectedQMark">
        <source>Syntax error - unexpected '?' symbol</source>
        <target state="translated">Erro de sintaxe - símbolo '?' inesperado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionCountMisMatch">
        <source>Expected {0} expressions, got {1}</source>
        <target state="translated">Expressões {0} esperadas, {1} obtidas</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExprUndelayed">
        <source>TcExprUndelayed: delayed</source>
        <target state="translated">TcExprUndelayed: atrasado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionRequiresSequence">
        <source>This expression form may only be used in sequence and computation expressions</source>
        <target state="translated">Este forma de expressão só pode ser utilizada em expressões de computação e sequência</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectExpressionSyntaxForm">
        <source>Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.</source>
        <target state="translated">Expressão de objeto inválida. Objetos sem substituições ou interfaces devem usar o formato de expressão 'new Type(args)' sem as chaves.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectSequenceOrRecordExpression">
        <source>Invalid object, sequence or record expression</source>
        <target state="translated">Expressão de objeto, sequência ou registro inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSequenceExpressionSyntaxForm">
        <source>Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq {{ ... }}'</source>
        <target state="translated">Expressão de registro, sequência ou computação inválida. Expressões de sequência devem estar na forma 'seq {{ ... }}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionWithIfRequiresParenthesis">
        <source>This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression</source>
        <target state="translated">Esta expressão de lista ou matriz inclui um elemento da forma 'if ... then ... else'. Use parênteses nesta expressão para indicar os elementos individuais da lista ou matriz. Use uma expressão de sequência para tirar esta ambiguidade desta lista gerada</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseFormatString">
        <source>Unable to parse format string '{0}'</source>
        <target state="translated">Não é possível analisar a cadeia de caracteres de formato '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcListLiteralMaxSize">
        <source>This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.</source>
        <target state="translated">Esta expressão de lista excede o tamanho máximo para literais de lista. Use uma matriz para literais maiores e chame Array.ToList.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresObjectConstructor">
        <source>The expression form 'expr then expr' may only be used as part of an explicit object constructor</source>
        <target state="translated">A forma de expressão 'expr then expr' só pode ser usada como parte de um construtor de objeto explícito</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentsCannotBeUsedInMemberTraits">
        <source>Named arguments cannot be given to member trait calls</source>
        <target state="translated">Argumentos nomeados não podem ser dados às chamadas características de membros</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotValidEnumCaseName">
        <source>This is not a valid name for an enumeration case</source>
        <target state="translated">Este não é um nome válido para um caso de enumeração</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotMutable">
        <source>This field is not mutable</source>
        <target state="translated">Este campo não é mutável</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresListArrayOrSequence">
        <source>This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq {{ ... }}', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements</source>
        <target state="translated">Esse constructo só pode ser utilizado em expressões de lista, de matriz e de sequência, como expressões da forma 'seq {{ ... }}', '[ ... ]' ou '[| ... |]', por exemplo. Elas usam a sintaxe 'for ... in ... do ... yield...' para gerar elementos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpressions">
        <source>This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'.</source>
        <target state="translated">Esse constructo só pode ser utilizado em expressões de computação. Para retornar um valor de uma função comum apenas escreva a expressão sem o 'return'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresSequenceOrComputations">
        <source>This construct may only be used within sequence or computation expressions</source>
        <target state="translated">Esse constructo só pode ser utilizado em expressões de sequência ou computação</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpression">
        <source>This construct may only be used within computation expressions</source>
        <target state="translated">Esse constructo só pode ser utilizado em expressões de computação</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexerExpression">
        <source>Invalid indexer expression</source>
        <target state="translated">Expressão de indexador inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
        <source>The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints</source>
        <target state="translated">O operador 'expr.[idx]' foi usado em um objeto de tipo indeterminado baseado em informações anteriores a este ponto do programa. Considere adicionar novas restrições de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromVariableType">
        <source>Cannot inherit from a variable type</source>
        <target state="translated">Não é possível herdar de um tipo de variável</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsOnTypeParametersCannotTakeArguments">
        <source>Calls to object constructors on type parameters cannot be given arguments</source>
        <target state="translated">Chamadas para construtores de objeto sobre parâmetros de tipo não podem receber argumentos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCompiledNameAttributeMisused">
        <source>The 'CompiledName' attribute cannot be used with this language element</source>
        <target state="translated">O atributo 'CompiledName' não pode ser usado com este elemento de linguagem</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedTypeRequired">
        <source>'{0}' may only be used with named types</source>
        <target state="translated">'{0}' só podem ser usados com tipos nomeados</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritCannotBeUsedOnInterfaceType">
        <source>'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead.</source>
        <target state="translated">'inherit' não pode ser usado em tipos de interface. Considere implementar a interface usando 'interface ... with ... end'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewCannotBeUsedOnInterfaceType">
        <source>'new' cannot be used on interface types. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">new' não pode ser usado em tipos de interface. Considere usar uma expressão de objeto '{{ new ... with ... }}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractTypeCannotBeInstantiated">
        <source>Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">Instâncias desse tipo não podem ser criadas uma vez que elas foram marcadas como abstratas ou nem todos os métodos receberam implementações. Considere usar uma expressão de objeto '{{ new ... with ... }}' em vez disso.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIDisposableTypeShouldUseNew">
        <source>It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value</source>
        <target state="translated">Recomenda-se que objetos que deem suporte à interface IDisposable sejam criados usando a sintaxe 'new Type(args)', em vez de 'Type(args)' ou 'Type' como um valor de função representando o construtor, para indicar que os recursos podem ser de propriedade do valor gerado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxCanOnlyBeUsedToCreateObjectTypes">
        <source>'{0}' may only be used to construct object types</source>
        <target state="translated">'{0}' só podem ser usados para tipos de objetos de constructo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresCall">
        <source>Constructors for the type '{0}' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.</source>
        <target state="translated">Construtores para o tipo '{0}' devem chamar seu construtor de objeto implícito direta ou indiretamente. Use uma chamada para o construtor de objeto implícito em vez de uma expressão de registro.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUndefinedField">
        <source>The field '{0}' has been given a value, but is not present in the type '{1}'</source>
        <target state="translated">O campo '{0}' recebeu um valor, mas ele não está presente no tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresAssignment">
        <source>No assignment given for field '{0}' of type '{1}'</source>
        <target state="translated">Nenhuma atribuição foi dada ao campo '{0}' do tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExtraneousFieldsGivenValues">
        <source>Extraneous fields have been given values</source>
        <target state="translated">Campos incorretos receberam valores</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
        <source>Only overrides of abstract and virtual members may be specified in object expressions</source>
        <target state="translated">Apenas substituições de membros abstratos e virtuais podem ser especificadas nas expressões de objeto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoAbstractOrVirtualMemberFound">
        <source>The member '{0}' does not correspond to any abstract or virtual method available to override or implement.</source>
        <target state="translated">O membro '{0}' não corresponde a nenhum método virtual ou abstrato disponível para substituição ou implementação.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberFoundIsNotAbstractOrVirtual">
        <source>The type {0} contains the member '{1}' but it is not a virtual or abstract method that is available to override or implement.</source>
        <target state="translated">O tipo {0} contém o membro '{1}', mas ele não é um método virtual ou abstrato disponível para substituição ou implementação.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatch">
        <source>The member '{0}' does not accept the correct number of arguments. {1} argument(s) are expected, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">O membro '{0}' não aceita o número correto de argumentos. São esperados {1} argumentos, mas foram fornecidos {2}. A assinatura exigida é '{3}'.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatchOneOverload">
        <source>The member '{0}' does not accept the correct number of arguments. One overload accepts {1} arguments, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">O membro '{0}' não aceita o número correto de argumentos. Uma sobrecarga aceita {1} argumentos, mas {2} foram fornecidos. A assinatura exigida é '{3}'.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSimpleMethodNameRequired">
        <source>A simple method name is required here</source>
        <target state="translated">Um nome de método simples é requerido aqui</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPredefinedTypeCannotBeUsedAsSuperType">
        <source>The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class</source>
        <target state="translated">Os tipos System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate e System.Array não podem ser usados como supertipos em uma expressão ou classe de objeto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMustBeUsedWithNamedType">
        <source>'new' must be used with a named type</source>
        <target state="translated">'new' deve ser usado com um tipo nomeado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCreateExtensionOfSealedType">
        <source>Cannot create an extension of a sealed type</source>
        <target state="translated">Não é possível criar uma extensão de um tipo selado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoArgumentsForRecordValue">
        <source>No arguments may be given when constructing a record value</source>
        <target state="translated">Nenhum argumento pode ser dado na construção de um valor de registro</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoInterfaceImplementationForConstructionExpression">
        <source>Interface implementations cannot be given on construction expressions</source>
        <target state="translated">Implementações de interface não podem ser fornecidas em expressões de construção</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionCanOnlyBeUsedInClassTypes">
        <source>Object construction expressions may only be used to implement constructors in class types</source>
        <target state="translated">Expressões de construção de objeto só podem ser usadas para implementar construtores nos tipos de classe</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
        <source>Only simple bindings of the form 'id = expr' can be used in construction expressions</source>
        <target state="translated">Apenas associações simples da forma 'id = expr' podem ser usadas em expressões de construções</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectsMustBeInitializedWithObjectExpression">
        <source>Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field</source>
        <target state="translated">Objetos devem ser inicializados por uma expressão de construção de objeto que chame um construtor de objeto herdado e atribua um valor para cada campo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedInterfaceType">
        <source>Expected an interface type</source>
        <target state="translated">Um tipo de interface é esperado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorForInterfacesDoNotTakeArguments">
        <source>Constructor expressions for interfaces do not take arguments</source>
        <target state="translated">Expressões de construtor para interfaces não possuem argumentos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresArguments">
        <source>This object constructor requires arguments</source>
        <target state="translated">Este construtor do objeto requer argumentos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewRequiresObjectConstructor">
        <source>'new' may only be used with object constructors</source>
        <target state="translated">'new' deve ser usado com construtores de objeto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAtLeastOneOverrideIsInvalid">
        <source>At least one override did not correctly implement its corresponding abstract member</source>
        <target state="translated">Pelo menos uma substituição não foi implementada corretamente no membro abstrato correspondente</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNumericLiteralRequiresModule">
        <source>This numeric literal requires that a module '{0}' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope</source>
        <target state="translated">Este literal numérico requer que um módulo '{0}' que define funções FromZero, FromOne, FromInt32, FromInt64 e FromString esteja no escopo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRecordConstruction">
        <source>Invalid record construction</source>
        <target state="translated">Construção de registros inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresRecordTypes">
        <source>The expression form {{ expr with ... }} may only be used with record types. To build object types use {{ new Type(...) with ... }}</source>
        <target state="translated">A forma de expressão {{ expr with ... }} só pode ser usada com tipos de registro. Para compilar tipos de objeto, use {{ new Type(...) with ... }}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritedTypeIsNotObjectModelType">
        <source>The inherited type is not an object model type</source>
        <target state="translated">O tipo herdado não é um tipo de objeto modelo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
        <source>Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors</source>
        <target state="translated">Expressões de construção de objeto (isto é, expressões de registros com especificações de herança) só podem ser usadas para implementar construtores em tipos de modelo de objeto. Use 'new ObjectType(args)' para instâncias de tipos de modelo de objeto fora dos construtores</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyRecordInvalid">
        <source>'{{ }}' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.</source>
        <target state="translated">'{{ }}' não é uma expressão válida. Registros devem incluir pelo menos um campo. Sequências vazias são especificadas pelo uso de Seq.empty ou uma lista vazia '[]'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordTypeNeedConstructor">
        <source>This type is not a record type. Values of class and struct types must be created using calls to object constructors.</source>
        <target state="translated">Este tipo não é um tipo de registro. Valores de tipos de classe e struct devem ser criados com o uso de construtores de objeto.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordType">
        <source>This type is not a record type</source>
        <target state="translated">Este não é um tipo de registro</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInComputationExpression">
        <source>This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder {{ ... }}'.</source>
        <target state="translated">Esse constructo é ambíguo como parte de uma expressão de computação. Expressões aninhadas podem ser gravadas com o uso de 'let _ = (...)' e computações aninhadas através de 'let! res = builder {{ ... }}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInSequenceExpression">
        <source>This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {{... }}'.</source>
        <target state="translated">Esse constructo é ambíguo como parte de uma expressão de sequência. Expressões aninhadas podem ser gravadas usando 'let _ = (...)' e sequências aninhadas através de 'yield! seq {{... }}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoBangIllegalInSequenceExpression">
        <source>'do!' cannot be used within sequence expressions</source>
        <target state="translated">'do!' não pode ser resolvido em expressões de sequência</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseForInSequenceExpression">
        <source>The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead.</source>
        <target state="translated">O uso de 'let! x = coll' em expressões de sequência não é permitido. Em vez disso, use 'for x in coll'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryIllegalInSequenceExpression">
        <source>'try'/'with' cannot be used within sequence expressions</source>
        <target state="translated">'try'/'with' não podem ser usados em expressões de sequência</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseYieldBangForMultipleResults">
        <source>In sequence expressions, multiple results are generated using 'yield!'</source>
        <target state="translated">Em expressões de sequência, os resultados múltiplos são gerados com o uso de 'yield!'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAssignment">
        <source>Invalid assignment</source>
        <target state="translated">Atribuição inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfTypeName">
        <source>Invalid use of a type name</source>
        <target state="translated">Uso inválido de um nome de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoAccessibleConstructor">
        <source>This type has no accessible object constructors</source>
        <target state="translated">Este tipo não possui construtores de objeto acessíveis</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfInterfaceType">
        <source>Invalid use of an interface type</source>
        <target state="translated">Uso inválido de um tipo de interface</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfDelegate">
        <source>Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'.</source>
        <target state="translated">Uso inválido de um construtor delegado. Use a sintaxe 'new Type(args)' ou somente 'Type(args)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotStatic">
        <source>Property '{0}' is not static</source>
        <target state="translated">A propriedade '{0}' não é estática</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotReadable">
        <source>Property '{0}' is not readable</source>
        <target state="translated">A propriedade '{0}' não é legível</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLookupMayNotBeUsedHere">
        <source>This lookup cannot be used here</source>
        <target state="translated">Esta pesquisa não pode ser usada aqui</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsStatic">
        <source>Property '{0}' is static</source>
        <target state="translated">A propriedade '{0}' é estática</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet1">
        <source>Property '{0}' cannot be set</source>
        <target state="translated">A propriedade '{0}' não pode ser definida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsCannotBeFirstClassValues">
        <source>Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</source>
        <target state="translated">Construtores devem ser aplicados a argumentos e não podem ser usados como valores de primeira classe. Se necessário, use uma função anônima '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
        <source>The syntax 'expr.id' may only be used with record labels, properties and fields</source>
        <target state="translated">A sintaxe 'expr.id' só pode ser usada em rótulos de registros, propriedades e campos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsStatic">
        <source>Event '{0}' is static</source>
        <target state="translated">O evento '{0}' é estático</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsNotStatic">
        <source>Event '{0}' is not static</source>
        <target state="translated">O evento '{0}' não é estático</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentDidNotMatch">
        <source>The named argument '{0}' did not match any argument or mutable property</source>
        <target state="translated">O argumento nomeado '{0}' não correspondeu ao argumento ou propriedade mutável</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverloadsCannotHaveCurriedArguments">
        <source>One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.</source>
        <target state="translated">Uma ou mais das sobrecargas deste método possui argumentos na forma curried. Considere reformular esses membros para terem argumentos na forma de tupla.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnnamedArgumentsDoNotFormPrefix">
        <source>The unnamed arguments do not form a prefix of the arguments of the method called</source>
        <target state="translated">Os argumentos sem nome não formam um prefixo dos argumentos de métodos chamados</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
        <source>Static optimization conditionals are only for use within the F# library</source>
        <target state="translated">Condicionais de otimização estáticas destinam-se apenas ao uso na biblioteca F#</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFormalArgumentIsNotOptional">
        <source>The corresponding formal argument is not optional</source>
        <target state="translated">O argumento formal correspondente não é opcional</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOptionalAssignmentToPropertyOrField">
        <source>Invalid optional assignment to a property or field</source>
        <target state="translated">Atribuição opcional inválida para uma propriedade ou um campo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegateConstructorMustBePassed">
        <source>A delegate constructor must be passed a single function value</source>
        <target state="translated">Um construtor delegado deve ser transmitido como um valor de função único</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindingCannotBeUseAndRec">
        <source>A binding cannot be marked both 'use' and 'rec'</source>
        <target state="translated">Uma associação não pode ser marcada com 'use' e 'rec' ao mesmo tempo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileOnlyOnClassLetBindings">
        <source>The 'VolatileField' attribute may only be used on 'let' bindings in classes</source>
        <target state="translated">O atributo 'VolatileField' só pode ser usado em associações 'let' nas classes</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesAreNotPermittedOnLetBindings">
        <source>Attributes are not permitted on 'let' bindings in expressions</source>
        <target state="translated">Atributos não são permitidos em associações 'let' das expressões</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultValueAttributeRequiresVal">
        <source>The 'DefaultValue' attribute may only be used on 'val' declarations</source>
        <target state="translated">O atributo 'DefaultValue' só pode ser utilizado em declarações 'val'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeRequiresMembers">
        <source>The 'ConditionalAttribute' attribute may only be used on members</source>
        <target state="translated">O atributo 'ConditionalAttribute' só pode ser usado em membros</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidActivePatternName">
        <source>This is not a valid name for an active pattern</source>
        <target state="translated">Este não é um nome válido para um padrão ativo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEntryPointAttributeRequiresFunctionInModule">
        <source>The 'EntryPointAttribute' attribute may only be used on function definitions in modules</source>
        <target state="translated">O atributo 'EntryPointAttribute' só pode ser usado em definições de função em módulos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesCannotBeInline">
        <source>Mutable values cannot be marked 'inline'</source>
        <target state="translated">Valores mutáveis não podem ser marcados como 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesMayNotHaveGenericParameters">
        <source>Mutable values cannot have generic parameters</source>
        <target state="translated">Valores mutáveis não podem ter parâmetros genéricos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesSyntax">
        <source>Mutable function values should be written 'let mutable f = (fun args -&gt; ...)'</source>
        <target state="translated">Valores de função mutáveis devem ser escritos como 'let mutable f = (fun args -&gt; ...)'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyFunctionsCanBeInline">
        <source>Only functions may be marked 'inline'</source>
        <target state="translated">Apenas funções podem ser marcadas como 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalAttributesForLiteral">
        <source>A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes</source>
        <target state="translated">Não é possível atribuir um valor literal aos atributos [&lt;ThreadStatic&gt;] ou [&lt;ContextStatic&gt;]</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeMutable">
        <source>A literal value cannot be marked 'mutable'</source>
        <target state="translated">Um valor literal não pode ser marcado como 'mutável'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeInline">
        <source>A literal value cannot be marked 'inline'</source>
        <target state="translated">Um valor literal não pode ser marcado como 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotHaveGenericParameters">
        <source>Literal values cannot have generic parameters</source>
        <target state="translated">Valores literais não têm parâmetros genéricos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstantExpression">
        <source>This is not a valid constant expression</source>
        <target state="translated">Esta não é uma expressão constante válida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsInaccessible">
        <source>This type is not accessible from this code location</source>
        <target state="translated">Este tipo não é acessível deste local de código</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConditionInImportedAssembly">
        <source>Unexpected condition in imported assembly: failed to decode AttributeUsage attribute</source>
        <target state="translated">Condição inesperada no assembly importado: falha ao decodificar o atributo AttributeUsage</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedAttributeTarget">
        <source>Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</source>
        <target state="translated">Destino de atributo não reconhecido. Os destinos de atributos válidos são 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event' e 'constructor'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElementUseDo">
        <source>This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module.</source>
        <target state="translated">Este atributo não é válido para ser usado neste elemento de linguagem. Os atributos de assembly devem ser anexados a uma declaração 'do ()' e, se necessário, em um módulo F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElement">
        <source>This attribute is not valid for use on this language element</source>
        <target state="translated">Este atributo não é válido para ser usado neste elemento de linguagem</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgumentsCannotBeUsedInCustomAttribute">
        <source>Optional arguments cannot be used in custom attributes</source>
        <target state="translated">Argumentos opcionais não podem ser usados em atributos personalizados</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet0">
        <source>This property cannot be set</source>
        <target state="translated">Esta propriedade não pode ser definida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyOrFieldNotFoundInAttribute">
        <source>This property or field was not found on this custom attribute type</source>
        <target state="translated">Esta propriedade ou campo não foram encontrados neste tipo de atributo personalizado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustBeReferenceType">
        <source>A custom attribute must be a reference type</source>
        <target state="translated">Um atributo personalizado deve ser um tipo de referência</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeArgumentMismatch">
        <source>The number of args for a custom attribute does not match the expected number of args for the attribute constructor</source>
        <target state="translated">O número de argumentos de um atributo personalizado não corresponde ao número de argumentos esperado para o construtor de atributos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustInvokeConstructor">
        <source>A custom attribute must invoke an object constructor</source>
        <target state="translated">Um atributo personalizado deve chamar um construtor de objeto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeExpressionsMustBeConstructorCalls">
        <source>Attribute expressions must be calls to object constructors</source>
        <target state="translated">Expressões de atributo devem ser chamadas para construtores de objeto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedAttribute">
        <source>This attribute cannot be used in this version of F#</source>
        <target state="translated">Este atributo não pode ser usado nesta versão de F#</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidInlineSpecification">
        <source>Invalid inline specification</source>
        <target state="translated">Especificação embutida inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBinding">
        <source>'use' bindings must be of the form 'use &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">as associações 'use' devem ser da forma 'use &lt;var&gt; = &lt;expr&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractMembersIllegalInAugmentation">
        <source>Abstract members are not permitted in an augmentation - they must be defined as part of the type itself</source>
        <target state="translated">Membros abstratos não são permitidos em um aumento, eles devem ser definidos como parte do tipo por eles mesmos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodOverridesIllegalHere">
        <source>Method overrides and interface implementations are not permitted here</source>
        <target state="translated">Substituições de método e implementações de interface não são permitidas aqui</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoMemberFoundForOverride">
        <source>No abstract or interface member was found that corresponds to this override</source>
        <target state="translated">Nenhum membro abstrato ou de interface que corresponde a esta substituição foi localizado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverrideArityMismatch">
        <source>This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:{0}</source>
        <target state="translated">Esta substituição obteve um número de argumentos diferente do membro abstrato correspondente. Os seguintes membros abstratos foram encontrados:{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationAlreadyExists">
        <source>This method already has a default implementation</source>
        <target state="translated">Este método já tem uma implementação padrão</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultAmbiguous">
        <source>The method implemented by this default is ambiguous</source>
        <target state="translated">O método implementado por este padrão é ambíguo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoPropertyFoundForOverride">
        <source>No abstract property was found that corresponds to this override</source>
        <target state="translated">Nenhuma propriedade abstrata que corresponde a esta substituição foi encontrada</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractPropertyMissingGetOrSet">
        <source>This property overrides or implements an abstract property but the abstract property doesn't have a corresponding {0}</source>
        <target state="translated">Esta propriedade substitui ou implementa uma propriedade abstrata, mas esta não possui uma correspondência {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSignatureForSet">
        <source>Invalid signature for set member</source>
        <target state="translated">Assinatura para configuração de membro inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMember">
        <source>This new member hides the abstract member '{0}'. Rename the member or use 'override' instead.</source>
        <target state="translated">Este novo membro oculta o membro abstrato '{0}'. Renomeie o membro ou use 'override'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMemberWithSuffix">
        <source>This new member hides the abstract member '{0}' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead.</source>
        <target state="translated">Este novo membro oculta o membro abstrato '{0}' assim que tuplas, funções, unidades de medida e/ou tipos fornecidos são apagados. Renomeie o membro ou use 'override'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializersIllegalInInterface">
        <source>Interfaces cannot contain definitions of static initializers</source>
        <target state="translated">Interfaces não podem conter definições de inicializadores estáticos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsIllegalInInterface">
        <source>Interfaces cannot contain definitions of object constructors</source>
        <target state="translated">Interfaces não podem conter definições de construtores de objeto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOverridesIllegalInInterface">
        <source>Interfaces cannot contain definitions of member overrides</source>
        <target state="translated">Interfaces não podem conter definições de substituições de membros</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConcreteMembersIllegalInInterface">
        <source>Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.</source>
        <target state="translated">Interfaces não podem conter definições de membros concretos. Talvez seja necessário definir um construtor no seu tipo para indicar que o tipo é uma classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsDisallowedInExceptionAugmentation">
        <source>Constructors cannot be specified in exception augmentations</source>
        <target state="translated">Não é possível especificar construtores em aumentos de exceções</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCannotHaveConstructorWithNoArguments">
        <source>Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.</source>
        <target state="translated">Os structs não podem ter um construtor de objetos sem argumentos. Esta é uma restrição imposta a todas as linguagens CLI, porque os structs suportam automaticamente um construtor padrão.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalForThisType">
        <source>Constructors cannot be defined for this type</source>
        <target state="translated">Não é possível definir construtores para este tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
        <source>Recursive bindings that include member specifications can only occur as a direct augmentation of a type</source>
        <target state="translated">Associações recursivas que incluem especificações de membros só podem ocorrer como um aumento direto de um tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimplePatternsInLetRec">
        <source>Only simple variable patterns can be bound in 'let rec' constructs</source>
        <target state="translated">Apenas padrões de variáveis simples podem ser associados em construtores 'let rec'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
        <source>Only record fields and simple, non-recursive 'let' bindings may be marked mutable</source>
        <target state="translated">Apenas campos de registro e associações 'let' simples e não recursivas podem ser marcados como mutáveis</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberIsNotSufficientlyGeneric">
        <source>This member is not sufficiently generic</source>
        <target state="translated">Este membro não é suficientemente genérico</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralAttributeRequiresConstantValue">
        <source>A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. 'val x : int = 1'</source>
        <target state="translated">Uma declaração só pode ser o atributo [&lt;Literal&gt;] se um valor constante também é dado, ex.:' val x: int = 1'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcValueInSignatureRequiresLiteralAttribute">
        <source>A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute</source>
        <target state="translated">Uma declaração só pode receber um valor em uma assinatura se a declaração tiver o atributo [&lt;Literal&gt;]</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThreadStaticAndContextStaticMustBeStatic">
        <source>Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread</source>
        <target state="translated">As variáveis de contexto estático e de thread estático devem ser estáticas e dado o atributo [&lt;DefaultValue&gt;] para indicar que o valor é inicializado para o valor padrão em cada novo thread</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileFieldsMustBeMutable">
        <source>Volatile fields must be marked 'mutable' and cannot be thread-static</source>
        <target state="translated">Campos voláteis devem ser marcados como 'mutable' e não podem ser thread estático</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUninitializedValFieldsMustBeMutable">
        <source>Uninitialized 'val' fields must be mutable and marked with the '[&lt;DefaultValue&gt;]' attribute. Consider using a 'let' binding instead of a 'val' field.</source>
        <target state="translated">Campos 'val' não inicializados devem ser mutáveis e marcados com o atributo '[&lt;DefaultValue&gt;]'.Use uma associação 'let' em vez de um campo 'val'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticValFieldsMustBeMutableAndPrivate">
        <source>Static 'val' fields in types must be mutable, private and marked with the '[&lt;DefaultValue&gt;]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type.</source>
        <target state="translated">Os campos estáticos 'val' nos tipos devem ser mutáveis, particulares e marcados com o atributo '[&lt;DefaultValue&gt;]'. Eles são inicializados com o valor 'null' ou 'zero' para seu tipo. Use também uma associação 'static let mutable' em um tipo de classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresName">
        <source>This field requires a name</source>
        <target state="translated">Este campo requer um nome</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNamespaceModuleTypeUnionName">
        <source>Invalid namespace, module, type or union case name</source>
        <target state="translated">Nome de namespace, módulo, tipo ou caso união inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalFormForExplicitTypeDeclaration">
        <source>Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -&gt; resTy'. Parentheses may be required around 'resTy'</source>
        <target state="translated">Declarações de tipo explícito para construtores devem estar na forma 'ty1 * ... * tyN -&gt; resTy'. Pode ser necessário usar parênteses em torno de 'resTy'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnTypesForUnionMustBeSameAsType">
        <source>Return types of union cases must be identical to the type being defined, up to abbreviations</source>
        <target state="translated">Tipos de retorno de casos união devem ser idênticos aos tipos que estão sendo definidos, até as abreviações</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumerationLiteral">
        <source>This is not a valid value for an enumeration literal</source>
        <target state="translated">Este não é um valor válido para um literal de enumeração</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType1">
        <source>The type '{0}' is not an interface type</source>
        <target state="translated">O tipo '{0}' não é um tipo de interface</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDuplicateSpecOfInterface">
        <source>Duplicate specification of an interface</source>
        <target state="translated">Especificação duplicada de uma interface</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldValIllegalHere">
        <source>A field/val declaration is not permitted here</source>
        <target state="translated">Uma declaração de campo/val não é permitida aqui</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritIllegalHere">
        <source>A inheritance declaration is not permitted here</source>
        <target state="translated">Não é permitido usar uma declaração herdada aqui</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleRequiresQualifiedAccess">
        <source>This declaration opens the module '{0}', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.</source>
        <target state="translated">Esta declaração abre o módulo '{0}', que é marcado como 'RequireQualifiedAccess'. Ajuste seus códigos para usar referências qualificadas aos elementos do módulo, por exemplo 'List.map' ao invés de 'map'. Esta mudança garantirá que seu código seja robusto porque novos construtores são adicionados às bibliotecas.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenUsedWithPartiallyQualifiedPath">
        <source>This declaration opens the namespace or module '{0}' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.</source>
        <target state="translated">Esta declaração abre o namespace ou módulo '{0}' através de um caminho parcialmente qualificado. Ajuste este código par usar o caminho completo do namespace. Esta mudança deixará seu código mais robusto uma vez que novos construtores são adicionados a F# e bibliotecas CLI.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLocalClassBindingsCannotBeInline">
        <source>Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.</source>
        <target state="translated">Associações de classes locais não podem ser marcadas como embutidas. Considere elevar a definição de classe ou não marcá-la como embutida.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsMayNotHaveMembers">
        <source>Type abbreviations cannot have members</source>
        <target state="translated">Abreviações de tipo não podem ter membros</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCheckedAtCompileTime">
        <source>As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.</source>
        <target state="translated">Começando no F# 4.1, a acessibilidade das abreviações de tipo é verificada no momento da compilação. Considere alterar a acessibilidade do tipo de abreviação. Ignorar este aviso pode levar a erros de tempo de execução.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsMayNotHaveMembers">
        <source>Enumerations cannot have members</source>
        <target state="translated">Enumerações não podem ter membros</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembers">
        <source>Measure declarations may have only static members</source>
        <target state="translated">Declarações de medida só podem ter membros estáticos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainDoBindings">
        <source>Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings</source>
        <target state="translated">Structs não podem conter associações 'do' porque o construtor padrão para structs não as executaria</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainLetBindings">
        <source>Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.</source>
        <target state="translated">Structs não podem conter definições de valores porque o construtor padrão para structs não executará essas vinculações. Considere adicionar argumentos complementares ao construtor primário para o tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticLetBindingsRequireClassesWithImplicitConstructors">
        <source>Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Definições de valores estáticos só podem ser usadas em tipos com um construtor primário. Considere adicionar argumentos à definição de tipo, por exemplo, 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembersNotConstructors">
        <source>Measure declarations may have only static members: constructors are not available</source>
        <target state="translated">Declarações de medida só podem ter membros estáticos: construtores não estão disponíveis</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberAndLocalClassBindingHaveSameName">
        <source>A member and a local class binding both have the name '{0}'</source>
        <target state="translated">Um membro e uma associação de classe local têm o mesmo nome '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
        <source>Type abbreviations cannot have interface declarations</source>
        <target state="translated">Abreviações de tipo não podem ter declarações de interface</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsCannotHaveInterfaceDeclaration">
        <source>Enumerations cannot have interface declarations</source>
        <target state="translated">Enumeradores não podem ter declarações de interface</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType0">
        <source>This type is not an interface type</source>
        <target state="translated">Este não é um tipo de interface</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllImplementedInterfacesShouldBeDeclared">
        <source>All implemented interfaces should be declared on the initial declaration of the type</source>
        <target state="translated">Todas as interfaces implementadas devem ser declaradas na declaração inicial do tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
        <source>A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type</source>
        <target state="translated">Uma implementação padrão desta interface já foi adicionada porque a implementação explícita da interface não foi especificada na definição do tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberNotPermittedInInterfaceImplementation">
        <source>This member is not permitted in an interface implementation</source>
        <target state="translated">Este membro não é permitido em implementação de interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclarationElementNotPermittedInAugmentation">
        <source>This declaration element is not permitted in an augmentation</source>
        <target state="translated">Este elemento de declaração não é permitido em um aumento</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotContainNestedTypes">
        <source>Types cannot contain nested type definitions</source>
        <target state="translated">Tipos não podem conter definições de tipo aninhadas</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeExceptionOrModule">
        <source>type, exception or module</source>
        <target state="translated">tipo, exceção ou módulo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeOrModule">
        <source>type or module</source>
        <target state="translated">tipo ou módulo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type.</source>
        <target state="translated">O tipo de struct, registro ou união '{0}' implementa explicitamente a interface 'System.IStructuralEquatable'. Aplique o atributo 'CustomEquality' ao tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IEquatable&lt;_&gt;' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'.</source>
        <target state="translated">O tipo de struct, registro ou união '{0}' implementa a interface 'System.IEquatable&lt;_&gt;' explicitamente. Aplique o atributo 'CustomEquality' ao tipo e forneça uma implementação consistente da substituição não genérica 'System.Object.Equals(obj)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
        <source>Explicit type specifications cannot be used for exception constructors</source>
        <target state="translated">Especificações de tipo explícitas não podem ser usadas para construtores de exceção</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsShouldNotHaveArgumentList">
        <source>Exception abbreviations should not have argument lists</source>
        <target state="translated">Abreviações de exceção não devem ter listas de argumentos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
        <source>Abbreviations for Common IL exceptions cannot take arguments</source>
        <target state="translated">Abreviações para exceções do IL Comum não podem pegar argumentos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsMustReferToValidExceptions">
        <source>Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception</source>
        <target state="translated">Abreviações de exceção devem referir-se às exceções existentes ou tipos F# derivados de System.Exception</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
        <source>Abbreviations for Common IL exception types must have a matching object constructor</source>
        <target state="translated">Abreviações para tipos de exceção do IL Comum devem ter um construtor de objeto correspondente</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotAnException">
        <source>Not an exception</source>
        <target state="translated">Não é uma exceção</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidModuleName">
        <source>Invalid module name</source>
        <target state="translated">Nome de módulo inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeExtension">
        <source>Invalid type extension</source>
        <target state="translated">Extensão de tipo inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesOfTypeSpecifyMultipleKindsForType">
        <source>The attributes of this type specify multiple kinds for the type</source>
        <target state="translated">Os atributos deste tipo especificam múltiplas variedades para este tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcKindOfTypeSpecifiedDoesNotMatchDefinition">
        <source>The kind of the type specified by its attributes does not match the kind implied by its definition</source>
        <target state="translated">A espécie do tipo especificado por seus atributos não corresponde à espécie sugerida por sua definição</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDefinitionsCannotHaveTypeParameters">
        <source>Measure definitions cannot have type parameters</source>
        <target state="translated">Definições de medida não podem ter parâmetros de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeRequiresDefinition">
        <source>This type requires a definition</source>
        <target state="translated">Este tipo requer uma definição</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationHasTypeParametersMissingOnType">
        <source>This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C&lt;'a&gt; = C of ...'.</source>
        <target state="translated">Essa abreviação de tipo tem um ou mais parâmetros de tipo declarados que não aparecem no tipo que está sendo abreviado. Abreviações de tipo devem usar todos os parâmetros de tipo declarados no tipo que está sendo abreviado. Remova um ou mais parâmetros de tipo ou use uma definição de tipo concreta que envolva um tipo subjacente, como 'type C&lt;'a&gt; = C of ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
        <source>Structs, interfaces, enums and delegates cannot inherit from other types</source>
        <target state="translated">Structs, interfaces, enums e delegados não podem ser herdados de outros tipos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotInheritFromMultipleConcreteTypes">
        <source>Types cannot inherit from multiple concrete types</source>
        <target state="translated">Tipos não podem ser herdados de tipos concretos múltiplos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
        <source>Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute</source>
        <target state="translated">Tipos de registros, união, abreviações e struct não podem ter o atributo 'AllowNullLiteral'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
        <source>Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal</source>
        <target state="translated">Tipos com o atributo 'AllowNullLiteral' só podem implementar ou herdar tipos que também permitem o uso do literal nulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericTypesCannotHaveStructLayout">
        <source>Generic types cannot be given the 'StructLayout' attribute</source>
        <target state="translated">O atributo 'StructLayout' não pode ser dado a tipos genéricos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyStructsCanHaveStructLayout">
        <source>Only structs and classes without primary constructors may be given the 'StructLayout' attribute</source>
        <target state="translated">Somente structs e classes sem construtores primários podem receber o atributo 'StructLayout'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRepresentationOfTypeHiddenBySignature">
        <source>The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.</source>
        <target state="translated">A representação deste tipo está oculta pela assinatura. Deve ser dado um atributo como [&lt;Sealed&gt;], [&lt;Class&gt;] ou [&lt;Interface&gt;] para indicar as características do tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyClassesCanHaveAbstract">
        <source>Only classes may be given the 'AbstractClass' attribute</source>
        <target state="translated">O atributo 'AbstractClass' só pode ser dado a classes</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
        <source>Only types representing units-of-measure may be given the 'Measure' attribute</source>
        <target state="translated">Apenas unidades de medida de representações de tipos podem receber o atributo 'Measure'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on overrides or interface implementations</source>
        <target state="translated">Modificadores de acessibilidade não são permitidos em implementações de substituições ou de interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDU">
        <source>Discriminated union types are always sealed</source>
        <target state="translated">Tipos de união discriminados são sempre selados</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedRecord">
        <source>Record types are always sealed</source>
        <target state="translated">Tipos de registros são sempre selados</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedAssemblyCode">
        <source>Assembly code types are always sealed</source>
        <target state="translated">Tipos de código de assembly são sempre selados</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedStruct">
        <source>Struct types are always sealed</source>
        <target state="translated">Tipos struct são sempre selados</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDelegate">
        <source>Delegate types are always sealed</source>
        <target state="translated">Tipos delegados são sempre selados</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedEnum">
        <source>Enum types are always sealed</source>
        <target state="translated">Tipos enum são sempre selados</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesAndDelegatesCannotContainFields">
        <source>Interface types and delegate types cannot contain fields</source>
        <target state="translated">Tipos de interface e tipos delegado não podem conter campos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviatedTypesCannotBeSealed">
        <source>Abbreviated types cannot be given the 'Sealed' attribute</source>
        <target state="translated">O atributo 'Sealed' não pode ser dado aos tipos abreviados.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromSealedType">
        <source>Cannot inherit a sealed type</source>
        <target state="translated">Não é possível herdar um tipo selado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromInterfaceType">
        <source>Cannot inherit from interface type. Use interface ... with instead.</source>
        <target state="translated">Não é possível herdar de um tipo de interface. Use interface ... with em seu lugar.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructTypesCannotContainAbstractMembers">
        <source>Struct types cannot contain abstract members</source>
        <target state="translated">Tipos de struct não podem conter membros abstratos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesCannotBeSealed">
        <source>Interface types cannot be sealed</source>
        <target state="translated">Tipos de interface não podem ser selados</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDelegateSpecification">
        <source>Delegate specifications must be of the form 'typ -&gt; typ'</source>
        <target state="translated">As especificações de delegado devem ser da forma 'typ -&gt; typ'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegatesCannotBeCurried">
        <source>Delegate specifications must not be curried types. Use 'typ * ... * typ -&gt; typ' for multi-argument delegates, and 'typ -&gt; (typ -&gt; typ)' for delegates returning function values.</source>
        <target state="translated">Especificações de delegado não devem ser tipos de representante via currying. Use 'typ * ... * typ -&gt; typ' para delegados multi-argumento e 'typ -&gt; (typ -&gt; typ)' para delegados que retornam valores de função.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForLiteralEnumeration">
        <source>Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char</source>
        <target state="translated">Enumerações literais devem ter tipo int, uint, int16, uint16, int64, uint64, byte, sbyte ou char</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclic">
        <source>This type definition involves an immediate cyclic reference through an abbreviation</source>
        <target state="translated">Esta definição de tipo envolve uma referência cíclica imediata através de uma abreviação</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclicThroughInheritance">
        <source>This type definition involves an immediate cyclic reference through a struct field or inheritance relation</source>
        <target state="translated">Esta definição de tipo envolve uma referência cíclica imediata através de um campo struct ou relação de herança</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReservedSyntaxForAugmentation">
        <source>The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[&lt;Sealed&gt;] attribute to the type definition in the signature</source>
        <target state="translated">A sintaxe 'type X with ...' é reservada para aumentos. Os tipos cujas representações estão ocultas, mas que possuem membros, são agora declarados em assinaturas usando 'type X = ...'. Você também pode precisar adicionar o atributo '[&lt;Sealed&gt;] à definição de tipo na assinatura</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
        <source>Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.</source>
        <target state="translated">Membros que estendem tipos de interface, delegado ou enum devem ser colocados em um módulo separado da definição do tipo. Este módulo deve ter o atributo AutoOpen ou ser aberto explicitamente por um código de cliente para trazer os membros de extensão para o escopo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal">
        <source>One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '{0}'</source>
        <target state="translated">Um ou mais dos parâmetros de tipo declarados para esta extensão de tipo têm uma restrição ausente ou incorreta que não corresponde às restrições de tipo originais em '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
        <source>Type definitions may only have one 'inherit' specification and it must be the first declaration</source>
        <target state="translated">As definições de tipo só podem ter uma especificação 'inherit' e devem ser a primeira declaração</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
        <source>'let' and 'do' bindings must come before member and interface definitions in type definitions</source>
        <target state="translated">As associações 'let' e 'do' devem vir antes das definições de membro e interface nas definições de tipos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritDeclarationMissingArguments">
        <source>This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'.</source>
        <target state="translated">Esta declaração 'inherit' especifica o tipo herdado, mas não especifica nenhum argumento. Considere fornecer argumentos, por exemplo 'inherit BaseType(args)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritConstructionCallNotPartOfImplicitSequence">
        <source>This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Esta declaração 'inherit' possui argumentos, mas não está em um tipo com um construtor primário. Considere adicionar argumentos à sua definição de tipo, por exemplo, 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLetAndDoRequiresImplicitConstructionSequence">
        <source>This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Esta definição só pode ser usada em um tipo com um construtor primário. Considere adicionar argumentos à sua definição de tipo, por exemplo, 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveAugmentations">
        <source>Type abbreviations cannot have augmentations</source>
        <target state="translated">Abreviações de tipo não podem ter aumentos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbreviationForNamespace">
        <source>The path '{0}' is a namespace. A module abbreviation may not abbreviate a namespace.</source>
        <target state="translated">O caminho '{0}' é um namespace. Uma abreviação de módulo não pode abreviar um namespace.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeUsedInInvalidWay">
        <source>The type '{0}' is used in an invalid way. A value prior to '{1}' has an inferred type involving '{2}', which is an invalid forward reference.</source>
        <target state="translated">O tipo '{0}' é usado de forma inválida. Um valor anterior a '{1}' possui um tipo inferido envolvendo '{2}', que é uma referencia de encaminhamento inválida.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to the definition of '{2}', which is an invalid forward reference.</source>
        <target state="translated">O membro '{0}' é usado de forma inválida. Um uso de '{1}' possui inferência anterior à definição de '{2}', que é uma referência de encaminhamento inválida.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeAutoOpenWasIgnored">
        <source>The attribute 'AutoOpen(\"{0}\")' in the assembly '{1}' did not refer to a valid module or namespace in that assembly and has been ignored</source>
        <target state="translated">O atributo 'AutoOpen(\"{0}\")' no assembly '{1}' não referenciou um módulo ou namespace válido neste assembly e foi ignorado</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUndefinedValue">
        <source>Undefined value '{0}'</source>
        <target state="translated">Valor indefinido '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLabelNotFound">
        <source>Label {0} not found</source>
        <target state="translated">Rótulo {0} não encontrado</target>
        <note />
      </trans-unit>
      <trans-unit id="ilIncorrectNumberOfTypeArguments">
        <source>Incorrect number of type arguments to local call</source>
        <target state="translated">Número incorreto de argumentos de tipo para chamadas locais</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDynamicInvocationNotSupported">
        <source>Dynamic invocation of {0} is not supported</source>
        <target state="translated">A chamada dinâmica de {0} não é suportada</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfLiteralFieldIsInvalid">
        <source>Taking the address of a literal field is invalid</source>
        <target state="translated">Não é válido pegar o endereço de um campo literal</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfValueHereIsInvalid">
        <source>This operation involves taking the address of a value '{0}' represented using a local variable or other special representation. This is invalid.</source>
        <target state="translated">Esta operação envolve pegar o endereço de um valor representado '{0}' através do uso de variável local ou outra representação especial, o que é inválido.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilCustomMarshallersCannotBeUsedInFSharp">
        <source>Custom marshallers cannot be specified in F# code. Consider using a C# helper function.</source>
        <target state="translated">Marshallers personalizados não podem ser especificados em código F#. Considere usar uma função de ajuda de C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMarshalAsAttributeCannotBeDecoded">
        <source>The MarshalAs attribute could not be decoded</source>
        <target state="translated">Não foi possível decodificar o atributo MarshalAs</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignatureForExternalFunctionContainsTypeParameters">
        <source>The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.</source>
        <target state="translated">A assinatura para esta função externa contém parâmetros de tipo. Restrinja o argumento e tipos de retorno para indicar os tipos de função C correspondente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDllImportAttributeCouldNotBeDecoded">
        <source>The DllImport attribute could not be decoded</source>
        <target state="translated">Não foi possível decodificar o atributo DllImport</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLiteralFieldsCannotBeSet">
        <source>Literal fields cannot be set</source>
        <target state="translated">Não foi possível definir os campos literais</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStaticMethodIsNotLambda">
        <source>GenSetStorage: {0} was represented as a static method but was not an appropriate lambda expression</source>
        <target state="translated">GenSetStorage: {0} foi representado como método estático mas não foi uma expressão lambda apropriada</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMutableVariablesCannotEscapeMethod">
        <source>Mutable variables cannot escape their method</source>
        <target state="translated">Variáveis mutáveis não podem escapar de seus métodos</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedUnrealizedValue">
        <source>Compiler error: unexpected unrealized value</source>
        <target state="translated">Erro de compilador: valor não realizado inesperado</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMainModuleEmpty">
        <source>Main module of program is empty: nothing will happen when it is run</source>
        <target state="translated">O módulo principal do programa está vazio: nada ocorrerá enquanto ele estiver em execução</target>
        <note />
      </trans-unit>
      <trans-unit id="ilTypeCannotBeUsedForLiteralField">
        <source>This type cannot be used for a literal field</source>
        <target state="translated">Este tipo não pode ser usado para um campo literal</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedGetSetAnnotation">
        <source>Unexpected GetSet annotation on a property</source>
        <target state="translated">Anotação GetSet inesperada em um propriedade</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldOffsetAttributeCouldNotBeDecoded">
        <source>The FieldOffset attribute could not be decoded</source>
        <target state="translated">Não foi possível decodificar o atributo FieldOffset</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStructLayoutAttributeCouldNotBeDecoded">
        <source>The StructLayout attribute could not be decoded</source>
        <target state="translated">Não foi possível decodificar o atributo StructLayout</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDefaultAugmentationAttributeCouldNotBeDecoded">
        <source>The DefaultAugmentation attribute could not be decoded</source>
        <target state="translated">Não foi possível decodificar o atributo DefaultAugmentation</target>
        <note />
      </trans-unit>
      <trans-unit id="ilReflectedDefinitionsCannotUseSliceOperator">
        <source>Reflected definitions cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">Definições refletidas não podem conter usos do operador união pré-fixo '%'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsProblemWithCodepage">
        <source>Problem with codepage '{0}': {1}</source>
        <target state="translated">Problema com o código de página '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyright">
        <source>Copyright (c) Microsoft Corporation. All Rights Reserved.</source>
        <target state="translated">Copyright (C) Microsoft Corporation. Todos os direitos reservados.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyrightCommunity">
        <source>Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</source>
        <target state="translated">Distribuído gratuitamente sob a Licença de Software Livre do MIT.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNameOfOutputFile">
        <source>Name of the output file (Short form: -o)</source>
        <target state="translated">Nome do arquivo de saída (Forma abreviada: -o)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildConsole">
        <source>Build a console executable</source>
        <target state="translated">Criar um executável de console</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildWindows">
        <source>Build a Windows executable</source>
        <target state="translated">Criar um executável do Windows</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildLibrary">
        <source>Build a library (Short form: -a)</source>
        <target state="translated">Criar uma biblioteca (Forma abreviada: -a)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildModule">
        <source>Build a module that can be added to another assembly</source>
        <target state="translated">Criar um módulo que possa ser adicionado a outro assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDelaySign">
        <source>Delay-sign the assembly using only the public portion of the strong name key</source>
        <target state="translated">Assinatura atrasada do assembly usando somente a parte pública da chave de nome forte</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPublicSign">
        <source>Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed</source>
        <target state="translated">Assine de forma pública o assembly usando a única parte pública da chave de nome forte e marque o assembly como assinado</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWriteXml">
        <source>Write the xmldoc of the assembly to the given file</source>
        <target state="translated">Gravar o xmldoc do assembly para o arquivo especificado</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyFile">
        <source>Specify a strong name key file</source>
        <target state="translated">Especificar um arquivo de chave de nome forte</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyContainer">
        <source>Specify a strong name key container</source>
        <target state="translated">Especificar um contêiner de chave de nome forte</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPlatform">
        <source>Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.</source>
        <target state="translated">Limite em quais plataformas este código pode ser executado: x86, Itanium, x64, anycpu32bitpreferred ou anycpu. O padrão é anycpu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoOpt">
        <source>Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.</source>
        <target state="translated">Inclua somente informações de otimização essenciais para a implementação de constructos embutidos. Isso inibe a integração dos módulos cruzados, mas aumenta a compatibilidade binária.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoInterface">
        <source>Don't add a resource to the generated assembly containing F#-specific metadata</source>
        <target state="translated">Não adicione um recurso ao assembly gerado que contenha metadados específicos a F#</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSig">
        <source>Print the inferred interface of the assembly to a file</source>
        <target state="translated">Imprimir interface deduzida do assembly para um arquivo</target>
        <note />
      </trans-unit>
      <trans-unit id="optsReference">
        <source>Reference an assembly (Short form: -r)</source>
        <target state="translated">Referenciar um assembly (Forma abreviada: -r)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32res">
        <source>Specify a Win32 resource file (.res)</source>
        <target state="translated">Especificar um arquivo de recursos do Win32 (.res)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32manifest">
        <source>Specify a Win32 manifest file</source>
        <target state="translated">Especificar um arquivo de manifesto Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowin32manifest">
        <source>Do not include the default Win32 manifest</source>
        <target state="translated">Não inclua o manifesto Win32 padrão</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedAllSource">
        <source>Embed all source files in the portable PDB file</source>
        <target state="translated">Inserir todos os arquivos de origem no arquivo PDB portátil</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedSource">
        <source>Embed specific source files in the portable PDB file</source>
        <target state="translated">Inserir os arquivos de origem específicos no arquivo PDB portátil</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLink">
        <source>Source link information file to embed in the portable PDB file</source>
        <target state="translated">O arquivo de informações do link de origem para inserir em um arquivo PDB portátil</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbeddedSourceRequirePortablePDBs">
        <source>--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">o comutador --embed tem suporte somente ao emitir um PDB Portátil (--debug:portable ou --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLinkRequirePortablePDBs">
        <source>--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">o comutador --sourcelink tem suporte somente ao emitir um PDB Portátil (--debug:portable ou --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="srcFileTooLarge">
        <source>Source file is too large to embed in a portable PDB</source>
        <target state="translated">O arquivo de origem é muito grande para ser inserido em um PDB portátil</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResource">
        <source>Embed the specified managed resource</source>
        <target state="translated">Inserir o recurso gerenciado especificado</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLinkresource">
        <source>Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]</source>
        <target state="translated">Vincule o recurso especificado a esse assembly em que o formato resinfo é &lt;file&gt;[,&lt;string name&gt;[,public|private]]</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebugPM">
        <source>Emit debug information (Short form: -g)</source>
        <target state="translated">Emita as informação de depuração (Forma abreviada: -g)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebug">
        <source>Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file).</source>
        <target state="translated">Especificar tipo de depuração: completo, portátil, incorporado, somente PDB. ('{0}' será o padrão se nenhum tipo de depuração for especificado e permite anexar um depurador a um programa em execução; 'portátil' é um formato multiplataforma; 'incorporado' é um formato multiplataforma incorporado no arquivo de saída).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsOptimize">
        <source>Enable optimizations (Short form: -O)</source>
        <target state="translated">Habilite otimizações (Forma abreviada: -O)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTailcalls">
        <source>Enable or disable tailcalls</source>
        <target state="translated">Habilitar ou desabilitar tailcalls</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDeterministic">
        <source>Produce a deterministic assembly (including module version GUID and timestamp)</source>
        <target state="translated">Produzir um assembly determinístico (incluindo GUID de versão de módulo e carimbo de data/hora)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCrossoptimize">
        <source>Enable or disable cross-module optimizations</source>
        <target state="translated">Habilite ou desabilite otimizações de módulo cruzado</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserrorPM">
        <source>Report all warnings as errors</source>
        <target state="translated">Relatar todos os avisos como erros</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserror">
        <source>Report specific warnings as errors</source>
        <target state="translated">Relatar avisos específicos como erros</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarn">
        <source>Set a warning level (0-5)</source>
        <target state="translated">Definir um nível de aviso (0-5)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowarn">
        <source>Disable specific warning messages</source>
        <target state="translated">Desabilitar mensagens de aviso específicas</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnOn">
        <source>Enable specific warnings that may be off by default</source>
        <target state="translated">Habilitar avisos específicos que podem estar desativados por padrão</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecked">
        <source>Generate overflow checks</source>
        <target state="translated">Gerar verificações de estouro</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDefine">
        <source>Define conditional compilation symbols (Short form: -d)</source>
        <target state="translated">Defina símbolos de compilação condicional (Forma abreviada: -d)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsMlcompatibility">
        <source>Ignore ML compatibility warnings</source>
        <target state="translated">Ignore avisos de compatibilidade ML</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNologo">
        <source>Suppress compiler copyright message</source>
        <target state="translated">Suprimir a mensagem de direitos autorais do compilador</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelp">
        <source>Display this usage message (Short form: -?)</source>
        <target state="translated">Exibir esta mensagem de uso (Forma abreviada: -?)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFile">
        <source>Read response file for more options</source>
        <target state="translated">Leia o arquivo de resposta para obter mais opções</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCodepage">
        <source>Specify the codepage used to read source files</source>
        <target state="translated">Especifique a página de código usada para ler arquivos de origem</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUtf8output">
        <source>Output messages in UTF-8 encoding</source>
        <target state="translated">Mensagens de saída em codificação UTF-8</target>
        <note />
      </trans-unit>
      <trans-unit id="optsFullpaths">
        <source>Output messages with fully qualified paths</source>
        <target state="translated">Mensagens de saída com caminhos totalmente qualificados</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLib">
        <source>Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)</source>
        <target state="translated">Especifique um diretório para incluir o caminho que é usado para resolver arquivos de origem e assemblies (Forma abreviada: -I)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBaseaddress">
        <source>Base address for the library to be built</source>
        <target state="translated">Endereço base para a biblioteca a ser criada</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoframework">
        <source>Do not reference the default CLI assemblies by default</source>
        <target state="translated">Não referencie os assemblies CLI padrões por padrão</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStandalone">
        <source>Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated</source>
        <target state="translated">Vincular estaticamente a biblioteca F# e todos os DLLs referenciados que dependem do assembly que está sendo gerado</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStaticlink">
        <source>Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.</source>
        <target state="translated">Vincule estaticamente o assembly fornecido e todas as DLLs referenciadas que dependem deste assembly. Use um nome de assembly como mylib, por exemplo, não um nome de DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResident">
        <source>Use a resident background compilation service to improve compiler startup times.</source>
        <target state="translated">Use um serviço de compilação em segundo plano residente para aprimorar os tempos de inicialização do compilador.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPdb">
        <source>Name the output debug file</source>
        <target state="translated">Nomear o arquivo de depuração de saída</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSimpleresolution">
        <source>Resolve assembly references using directory-based rules rather than MSBuild resolution</source>
        <target state="translated">Resolver referências de assembly usando regras baseadas em diretório em vez da resolução do MSBuild</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedTarget">
        <source>Unrecognized target '{0}', expected 'exe', 'winexe', 'library' or 'module'</source>
        <target state="translated">Destino desconhecido '{0}', 'exe', 'winexe', 'library' ou 'module' era esperado</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedDebugType">
        <source>Unrecognized debug type '{0}', expected 'pdbonly' or 'full'</source>
        <target state="translated">Tipo de depuração desconhecida '{0}', 'pdbonly' ou 'full' era esperado</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidWarningLevel">
        <source>Invalid warning level '{0}'</source>
        <target state="translated">Nível de aviso '{0}' inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="optsShortFormOf">
        <source>Short form of '{0}'</source>
        <target state="translated">Forma abreviada de '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDeprecatedMsg">
        <source>The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.</source>
        <target state="translated">A opção de linha de comando '--cliroot' foi preterida. Use uma referência explicita para uma cópia específica de mscorlib.dll em seu lugar.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDescription">
        <source>Use to override where the compiler looks for mscorlib.dll and framework components</source>
        <target state="translated">Use para substituir onde o compilador deve procurar por mscorlib.dll e componentes de framework</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerOutputFiles">
        <source>- OUTPUT FILES -</source>
        <target state="translated">- ARQUIVOS DE SAÍDA -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerInputFiles">
        <source>- INPUT FILES -</source>
        <target state="translated">- ARQUIVOS DE ENTRADA -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerResources">
        <source>- RESOURCES -</source>
        <target state="translated">- RECURSOS -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerCodeGen">
        <source>- CODE GENERATION -</source>
        <target state="translated">- GERAÇÃO DE CÓDIGO -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerAdvanced">
        <source>- ADVANCED -</source>
        <target state="translated">- AVANÇADO -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerMisc">
        <source>- MISCELLANEOUS -</source>
        <target state="translated">- DIVERSOS -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerLanguage">
        <source>- LANGUAGE -</source>
        <target state="translated">- LINGUAGEM -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerErrsAndWarns">
        <source>- ERRORS AND WARNINGS -</source>
        <target state="translated">- ERROS E AVISOS -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownArgumentToTheTestSwitch">
        <source>Unknown --test argument: '{0}'</source>
        <target state="translated">Argumento --test desconhecido: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownPlatform">
        <source>Unrecognized platform '{0}', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'</source>
        <target state="translated">Plataforma não reconhecida '{0}', os valores válidos são 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred' e 'anycpu'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInternalNoDescription">
        <source>The command-line option '{0}' is for test purposes only</source>
        <target state="translated">A opção de linha de comando '{0}' é somente para propósitos de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLONoDescription">
        <source>The command-line option '{0}' has been deprecated</source>
        <target state="translated">A opção de linha de comando '{0}' foi preterida</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLODeprecatedSuggestAlternative">
        <source>The command-line option '{0}' has been deprecated. Use '{1}' instead.</source>
        <target state="translated">A opção de linha de comando '{0}' foi preterida. Use '{1}' em seu lugar.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLOHtmlDoc">
        <source>The command-line option '{0}' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.</source>
        <target state="translated">A opção de linha de comando '{0}' foi preterida. A geração de documento HTML é agora parte do pacote de energia F#, através da ferramenta FsHtmlDoc.exe.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsConsoleColors">
        <source>Output warning and error messages in color</source>
        <target state="translated">Mensagens de aviso e erro de saída em cores</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUseHighEntropyVA">
        <source>Enable high-entropy ASLR</source>
        <target state="translated">Habilitar ASLR de alta entropia</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSubSystemVersion">
        <source>Specify subsystem version of this assembly</source>
        <target state="translated">Especificar a versão do subsistema deste assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTargetProfile">
        <source>Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib</source>
        <target state="translated">Especifique o perfil da estrutura de destino deste assembly. Os valores válidos são mscorlib, netcore ou netstandard. O padrão é mscorlib</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmitDebugInfoInQuotations">
        <source>Emit debug information in quotations</source>
        <target state="translated">Emitir informações de depuração entre aspas</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPreferredUiLang">
        <source>Specify the preferred output language culture name (e.g. es-ES, ja-JP)</source>
        <target state="translated">Especifique o nome de cultura de idioma de saída preferencial (por exemplo, es-ES, ja-JP)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoCopyFsharpCore">
        <source>Don't copy FSharp.Core.dll along the produced binaries</source>
        <target state="translated">Não copiar FSharp.Core.dll nos binários produzidos</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidSubSystemVersion">
        <source>Invalid version '{0}' for '--subsystemversion'. The version must be 4.00 or greater.</source>
        <target state="translated">Versão inválida '{0}' para '--subsystemversion'. A versão deve ser 4.00 ou posterior.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidTargetProfile">
        <source>Invalid value '{0}' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.</source>
        <target state="translated">Valor inválido '{0}' para '--targetprofile', os valores válidos são 'mscorlib', 'netcore' ou 'netstandard'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFullName">
        <source>Full name</source>
        <target state="translated">Nome completo</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoOtherOverloads">
        <source>and {0} other overloads</source>
        <target state="translated">e {0} outras sobrecargas</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoUnionCase">
        <source>union case</source>
        <target state="translated">caso união</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActivePatternResult">
        <source>active pattern result</source>
        <target state="translated">resultado padrão ativo</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActiveRecognizer">
        <source>active recognizer</source>
        <target state="translated">reorganizador ativo</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoField">
        <source>field</source>
        <target state="translated">Campo</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoEvent">
        <source>event</source>
        <target state="translated">evento</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoProperty">
        <source>property</source>
        <target state="translated">Propriedade.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoExtension">
        <source>extension</source>
        <target state="translated">Extensão</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCustomOperation">
        <source>custom operation</source>
        <target state="translated">operação personalizada</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoArgument">
        <source>argument</source>
        <target state="translated">Argumento</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoPatternVariable">
        <source>patvar</source>
        <target state="translated">patvar</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespace">
        <source>namespace</source>
        <target state="translated">namespace</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoModule">
        <source>module</source>
        <target state="translated">módulo</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespaceOrModule">
        <source>namespace/module</source>
        <target state="translated">namespace/módulo</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromFirst">
        <source>from {0}</source>
        <target state="translated">de {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromNext">
        <source>also from {0}</source>
        <target state="translated">também de {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedProperty">
        <source>generated property</source>
        <target state="translated">propriedade gerada</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedType">
        <source>generated type</source>
        <target state="translated">tipo gerado</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersKey">
        <source>Found by AssemblyFolders registry key</source>
        <target state="translated">Localizada pela chave de registro AssemblyFolders</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersExKey">
        <source>Found by AssemblyFoldersEx registry key</source>
        <target state="translated">Localizada pela chave de registro AssemblyFoldersEx</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionNetFramework">
        <source>.NET Framework</source>
        <target state="translated">.NET Framework</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionGAC">
        <source>Global Assembly Cache</source>
        <target state="translated">Cache de Assembly Global</target>
        <note />
      </trans-unit>
      <trans-unit id="recursiveClassHierarchy">
        <source>Recursive class hierarchy in type '{0}'</source>
        <target state="translated">Hierarquia de classe recursiva no tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRecursiveReferenceToAbstractSlot">
        <source>Invalid recursive reference to an abstract slot</source>
        <target state="translated">Referência recursiva inválida para um slot abstrato</target>
        <note />
      </trans-unit>
      <trans-unit id="eventHasNonStandardType">
        <source>The event '{0}' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit {1} and {2} methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent&lt;_&gt;' or 'IEvent&lt;_,_&gt;'.</source>
        <target state="translated">O evento '{0}' tem um tipo não padrão. Se este evento for declarado em outra linguagem CLI, você poderá precisar acessar este evento com o uso de {1} explícito e métodos {2} para ele. Se este evento estiver declarado em F#, faça o tipo de evento também ser uma instanciação de 'IDelegateEvent&lt;_&gt;' ou 'IEvent&lt;_,_&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeIsNotAccessible">
        <source>The type '{0}' is not accessible from this code location</source>
        <target state="translated">O tipo '{0}' não é acessível deste local do código</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCasesAreNotAccessible">
        <source>The union cases or fields of the type '{0}' are not accessible from this code location</source>
        <target state="translated">Os casos união ou campos do tipo '{0}' não são acessíveis deste local de código</target>
        <note />
      </trans-unit>
      <trans-unit id="valueIsNotAccessible">
        <source>The value '{0}' is not accessible from this code location</source>
        <target state="translated">O valor '{0}' não é acessível deste local de código</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCaseIsNotAccessible">
        <source>The union case '{0}' is not accessible from this code location</source>
        <target state="translated">O caso união '{0}' não está acessível deste local de código</target>
        <note />
      </trans-unit>
      <trans-unit id="fieldIsNotAccessible">
        <source>The record, struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">O campo de registro, struct ou classe '{0}' não está acessível neste local de código</target>
        <note />
      </trans-unit>
      <trans-unit id="structOrClassFieldIsNotAccessible">
        <source>The struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">O campo da struct ou classe '{0}' não é acessível neste local do código</target>
        <note />
      </trans-unit>
      <trans-unit id="experimentalConstruct">
        <source>This construct is experimental</source>
        <target state="translated">Este constructo é experimental</target>
        <note />
      </trans-unit>
      <trans-unit id="noInvokeMethodsFound">
        <source>No Invoke methods found for delegate type</source>
        <target state="translated">Nenhum método de invocação encontrado para o tipo delegate</target>
        <note />
      </trans-unit>
      <trans-unit id="moreThanOneInvokeMethodFound">
        <source>More than one Invoke method found for delegate type</source>
        <target state="translated">Mais de um método de chamada encontrado para o tipo delegado</target>
        <note />
      </trans-unit>
      <trans-unit id="delegatesNotAllowedToHaveCurriedSignatures">
        <source>Delegates are not allowed to have curried signatures</source>
        <target state="translated">Delegados não estão autorizados a ter assinaturas na forma curried</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrUnexpectedTExpr">
        <source>Unexpected Expr.TyChoose</source>
        <target state="translated">Expr.TyChoose inesperado</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrLambdaLiftingOptimizationsNotApplied">
        <source>Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.</source>
        <target state="translated">Observação: as otimizações de levantamento de lambda não foram aplicadas devido ao uso desta função genérica restrita local como um valor de primeira classe. Adicionar restrições pode resolver esta condição.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifiersContainingAtSymbolReserved">
        <source>Identifiers containing '@' are reserved for use in F# code generation</source>
        <target state="translated">Identificadores que contém '@' são reservados para uso em geração de código F#</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifierReserved">
        <source>The identifier '{0}' is reserved for future use by F#</source>
        <target state="translated">O identificador '{0}' é reservado para uso futuro por F#</target>
        <note />
      </trans-unit>
      <trans-unit id="patcMissingVariable">
        <source>Missing variable '{0}'</source>
        <target state="translated">Variável '{0}' ausente</target>
        <note />
      </trans-unit>
      <trans-unit id="patcPartialActivePatternsGenerateOneResult">
        <source>Partial active patterns may only generate one result</source>
        <target state="translated">Padrões ativos parciais só podem gerar um resultado</target>
        <note />
      </trans-unit>
      <trans-unit id="impTypeRequiredUnavailable">
        <source>The type '{0}' is required here and is unavailable. You must add a reference to assembly '{1}'.</source>
        <target state="translated">O tipo '{0}' é requerido aqui e não está disponível. Você deve adicionar uma referência ao assembly '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferencedTypeCouldNotBeFoundInAssembly">
        <source>A reference to the type '{0}' in assembly '{1}' was found, but the type could not be found in that assembly</source>
        <target state="translated">A referência para o tipo '{0}' no assembly '{1}' foi encontrada, mas o tipo não pôde ser encontrado neste assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="impNotEnoughTypeParamsInScopeWhileImporting">
        <source>Internal error or badly formed metadata: not enough type parameters were in scope while importing</source>
        <target state="translated">Erro interno ou metadado malformado: os parâmetros de tipo que estavam no escopo durante a importação não são suficientes</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferenceToDllRequiredByAssembly">
        <source>A reference to the DLL {0} is required by assembly {1}. The imported type {2} is located in the first assembly and could not be resolved.</source>
        <target state="translated">Uma referência ao DLL {0} é requerida pelo assembly {1}. O tipo importado {2} está localizado no primeiro assembly e não pôde ser resolvido.</target>
        <note />
      </trans-unit>
      <trans-unit id="impImportedAssemblyUsesNotPublicType">
        <source>An imported assembly uses the type '{0}' but that type is not public</source>
        <target state="translated">Um assembly importado usa o tipo '{0}', mas este tipo não é público</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButIncomplete">
        <source>The value '{0}' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible</source>
        <target state="translated">O valor '{0}' foi marcado como embutido, mas sua implementação faz uso de uma função interna ou privada que não é suficientemente acessível</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButWasNotBoundInTheOptEnv">
        <source>The value '{0}' was marked inline but was not bound in the optimization environment</source>
        <target state="translated">O valor '{0}' foi marcado como embutido, mas não está associado no ambiente de otimização</target>
        <note />
      </trans-unit>
      <trans-unit id="optLocalValueNotFoundDuringOptimization">
        <source>Local value {0} not found during optimization</source>
        <target state="translated">O valor local {0} não foi encontrado durante a otimização</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineHasUnexpectedValue">
        <source>A value marked as 'inline' has an unexpected value</source>
        <target state="translated">Um valor marcado como 'embutido' possui um valor inesperado</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineCouldNotBeInlined">
        <source>A value marked as 'inline' could not be inlined</source>
        <target state="translated">Um valor marcado como 'embutido' não pôde ser embutido</target>
        <note />
      </trans-unit>
      <trans-unit id="optFailedToInlineValue">
        <source>Failed to inline the value '{0}' marked 'inline', perhaps because a recursive value was marked 'inline'</source>
        <target state="translated">Falha ao embutir o valor '{0}' marcado como 'inline', talvez porque um valor recursivo tenha sido marcado como 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="optRecursiveValValue">
        <source>Recursive ValValue {0}</source>
        <target state="translated">ValValue {0} recursivo </target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltIncorrentIndentationOfIn">
        <source>The indentation of this 'in' token is incorrect with respect to the corresponding 'let'</source>
        <target state="translated">O recuo deste token 'in' é incorreto em relação ao 'let' correspondente</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltTokenIsOffsideOfContextStartedEarlier">
        <source>Possible incorrect indentation: this token is offside of context started at position {0}. Try indenting this token further or using standard formatting conventions.</source>
        <target state="translated">Recuo possivelmente incorreto: este token está fora do contexto iniciado na posição {0}. Tente recuar mais este token ou use conversões de formatação padrão.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltSeparatorTokensOfPatternMatchMisaligned">
        <source>The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.</source>
        <target state="translated">Os tokens '|' que separam regras desta correspondência de padrão estão desalinhados em uma coluna. Considere realinhar seu código ou usar mais recuo.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidModuleExprType">
        <source>Invalid module/expression/type</source>
        <target state="translated">Módulo/expressão/tipo inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationNeededToDisambiguateTypesWithSameName">
        <source>Multiple types exist called '{0}', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '{1}'.</source>
        <target state="translated">Existem tipos múltiplos chamados '{0}', que pegam diferentes números de parâmetros genéricos. Forneça uma instanciação de tipo para desfazer a ambiguidade da resolução de tipo, por exemplo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationIsMissingAndCouldNotBeInferred">
        <source>The instantiation of the generic type '{0}' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '{1}'.</source>
        <target state="translated">Está faltando a instanciação do tipo genérico '{0}', a qual não pode ser inferida a partir de argumentos ou tipo de retorno deste membro. Considere providenciar uma instanciação de tipo quando acessar este tipo, por exemplo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrGlobalUsedOnlyAsFirstName">
        <source>'global' may only be used as the first name in a qualified path</source>
        <target state="translated">'global' só pode ser usado com primeiro nome em um caminho qualificado</target>
        <note />
      </trans-unit>
      <trans-unit id="nrIsNotConstructorOrLiteral">
        <source>This is not a constructor or literal, or a constructor is being used incorrectly</source>
        <target state="translated">Este não é um construtor ou literal, ou então um construtor está sendo usado de forma incorreta</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnexpectedEmptyLongId">
        <source>Unexpected empty long identifier</source>
        <target state="translated">Identificador de long vazio inesperado</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordDoesNotContainSuchLabel">
        <source>The record type '{0}' does not contain a label '{1}'.</source>
        <target state="translated">O tipo de registro '{0}' não contém um rótulo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidFieldLabel">
        <source>Invalid field label</source>
        <target state="translated">Rótulo de campo inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidExpression">
        <source>Invalid expression '{0}'</source>
        <target state="translated">Expressão '{0}' inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="nrNoConstructorsAvailableForType">
        <source>No constructors are available for the type '{0}'</source>
        <target state="translated">Nenhum construtor está disponível para o tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnionTypeNeedsQualifiedAccess">
        <source>The union type for union case '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('{1}') in the name you are using.</source>
        <target state="translated">O tipo de união para o caso de união '{0}' foi definido com o RequireQualifiedAccessAttribute. Inclua o nome do tipo de união ('{1}') no nome que você está usando.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordTypeNeedsQualifiedAccess">
        <source>The record type for the record field '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('{1}') in the name you are using.</source>
        <target state="translated">O tipo de registro para o campo de registro '{0}' foi definido com o RequireQualifiedAccessAttribute. Inclua o nome do tipo de registro ('{1}') no nome que você está usando.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingPdb">
        <source>Unexpected error creating debug information file '{0}'</source>
        <target state="translated">Erro inesperado ao criar o arquivo de informação de depuração '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideIntegerRange">
        <source>This number is outside the allowable range for this integer type</source>
        <target state="translated">Este número está fora do intervalo permitido para este tipo de inteiro</target>
        <note />
      </trans-unit>
      <trans-unit id="lexCharNotAllowedInOperatorNames">
        <source>'{0}' is not permitted as a character in operator names and is reserved for future use</source>
        <target state="translated">'{0}' não é permitido como um caractere em nomes de operadores e está reservado para uso futuro</target>
        <note />
      </trans-unit>
      <trans-unit id="lexUnexpectedChar">
        <source>Unexpected character '{0}'</source>
        <target state="translated">Caractere inesperado '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteArrayCannotEncode">
        <source>This byte array literal contains characters that do not encode as a single byte</source>
        <target state="translated">Este literal matriz de byte contém caracteres não codificados como um byte simples</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIdentEndInMarkReserved">
        <source>Identifiers followed by '{0}' are reserved for future use</source>
        <target state="translated">Os identificadores seguidos por '{0}' são reservados para uso futuro</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSigned">
        <source>This number is outside the allowable range for 8-bit signed integers</source>
        <target state="translated">Este número está fora do intervalo permitido para inteiros de 8-bit com sinal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSignedHex">
        <source>This number is outside the allowable range for hexadecimal 8-bit signed integers</source>
        <target state="translated">Este número está fora do intervalo permitido para inteiros hexadecimais de 8-bit com sinal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitUnsigned">
        <source>This number is outside the allowable range for 8-bit unsigned integers</source>
        <target state="translated">Este número está fora do intervalo permitido para inteiros de 8-bit sem sinal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitSigned">
        <source>This number is outside the allowable range for 16-bit signed integers</source>
        <target state="translated">Este número está fora do intervalo permitido para inteiros de 16-bit com sinal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitUnsigned">
        <source>This number is outside the allowable range for 16-bit unsigned integers</source>
        <target state="translated">Este número está fora do intervalo permitido para inteiros de 16-bit sem sinal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitSigned">
        <source>This number is outside the allowable range for 32-bit signed integers</source>
        <target state="translated">Este número está fora do intervalo permitido para inteiros de 32-bit com sinal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitUnsigned">
        <source>This number is outside the allowable range for 32-bit unsigned integers</source>
        <target state="translated">Este número está fora do intervalo permitido para inteiros de 32-bit sem sinal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitSigned">
        <source>This number is outside the allowable range for 64-bit signed integers</source>
        <target state="translated">Este número está fora do intervalo permitido para inteiros de 64-bit com sinal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitUnsigned">
        <source>This number is outside the allowable range for 64-bit unsigned integers</source>
        <target state="translated">Este número está fora do intervalo permitido para inteiros de 64-bit sem sinal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeSigned">
        <source>This number is outside the allowable range for signed native integers</source>
        <target state="translated">Este número está fora do intervalo permitido para inteiros nativos com sinal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeUnsigned">
        <source>This number is outside the allowable range for unsigned native integers</source>
        <target state="translated">Este número está fora do intervalo permitido para inteiros nativos sem sinal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidFloat">
        <source>Invalid floating point number</source>
        <target state="translated">Número do ponto flutuante inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideDecimal">
        <source>This number is outside the allowable range for decimal literals</source>
        <target state="translated">Este número está fora do intervalo permitido para literais decimais</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideThirtyTwoBitFloat">
        <source>This number is outside the allowable range for 32-bit floats</source>
        <target state="translated">Este número está fora do intervalo permitido para floats de 32-bit</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidNumericLiteral">
        <source>This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</source>
        <target state="translated">Este não é um literal numérico válido. Literais numéricos válidos incluem 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidByteLiteral">
        <source>This is not a valid byte literal</source>
        <target state="translated">Este não é um literal de byte válido</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidCharLiteral">
        <source>This is not a valid character literal</source>
        <target state="translated">Este não é um literal de caractere válido</target>
        <note />
      </trans-unit>
      <trans-unit id="lexThisUnicodeOnlyInStringLiterals">
        <source>This Unicode encoding is only valid in string literals</source>
        <target state="translated">Esta codificação Unicode só é válida em literais de cadeia de caracteres</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTokenReserved">
        <source>This token is reserved for future use</source>
        <target state="translated">Este token está reservado para uso futuro</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTabsNotAllowed">
        <source>TABs are not allowed in F# code unless the #indent \"off\" option is used</source>
        <target state="translated">TABs não são permitidos em código F#, a menos que a opção #indent \"off\" seja usada</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidLineNumber">
        <source>Invalid line number: '{0}'</source>
        <target state="translated">Número de linha inválido: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustBeFirst">
        <source>#if directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">A diretiva #if deve aparecer como o primeiro caractere diferente de um espaço em branco em uma linha</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseNoMatchingIf">
        <source>#else has no matching #if</source>
        <target state="translated">#else não tem nenhuma correspondência #if</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifRequiredForElse">
        <source>#endif required for #else</source>
        <target state="translated">#endif requerido por #else</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseMustBeFirst">
        <source>#else directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">A diretiva #else deve aparecer como o primeiro caractere diferente de um espaço em branco em uma linha</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndingNoMatchingIf">
        <source>#endif has no matching #if</source>
        <target state="translated">#endif não tem nenhuma correspondência #if</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifMustBeFirst">
        <source>#endif directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">A diretiva #endif deve aparecer como o primeiro caractere diferente de um espaço em branco em uma linha</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustHaveIdent">
        <source>#if directive should be immediately followed by an identifier</source>
        <target state="translated">A diretiva #if deve ser seguida imediatamente por um identificador</target>
        <note />
      </trans-unit>
      <trans-unit id="lexWrongNestedHashEndif">
        <source>Syntax error. Wrong nested #endif, unexpected tokens before it.</source>
        <target state="translated">Erro de sintaxe. #endif aninhado de forma errada, tokens não são esperados antes dele.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashBangMustBeFirstInFile">
        <source>#! may only appear as the first line at the start of a file.</source>
        <target state="translated">#! somente pode aparecer na primeira linha do início de um arquivo.</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexExpectedSingleLineComment">
        <source>Expected single line comment or end of line</source>
        <target state="translated">Linha de comando simples ou fim de linha esperado</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNoArguments">
        <source>Infix operator member '{0}' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">O membro do operador infixo '{0}' não possui argumentos. Uma tupla de 2 argumentos é esperada, como por exemplo o membro estático (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonPairArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">O membro do operador infixo '{0}' possui {1} argumentos iniciais. Uma tupla de 2 argumentos é esperada, como por exemplo o membro estático (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithCurriedArguments">
        <source>Infix operator member '{0}' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">O membro do operador infixo '{0}' possui argumentos na forma curried adicionais. Uma tupla de 2 argumentos é esperada, como por exemplo o membro estático (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFSharpCoreRequiresExplicit">
        <source>All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'</source>
        <target state="translated">Todos tipos de registro, união e struct em FSharp.Core.dll devem ser rotulados explicitamente com 'StructuralComparison' ou 'NoComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the type parameter '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter</source>
        <target state="translated">O tipo struct, registro ou união '{0}' tem o atributo 'StructuralComparison', mas o parâmetro de tipo '{1}' não satisfaz a restrição 'comparison'. Considere incluir a restrição 'comparison' ao parâmetro de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the component type '{1}' does not satisfy the 'comparison' constraint</source>
        <target state="translated">O tipo struct, registro ou união '{0}' tem o atributo 'StructuralComparison', mas o tipo de componente '{1}' não satisfaz a restrição 'comparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded1">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type parameter {1} does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">O tipo de struct, registro ou união '{0}' não é estruturalmente comparável porque o parâmetro de tipo {1} não satisfaz a restrição 'comparison'. Considere adicionar o atributo 'NoComparison' ao tipo '{2}' para esclarecer que o tipo não é comparável</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded2">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">O tipo de struct, registro ou união '{0}' não é estruturalmente comparável porque o tipo {1} não satisfaz a restrição 'comparison'. Considere adicionar o atributo 'NoComparison' ao tipo '{2}' para esclarecer que o tipo não é comparável</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded1">
        <source>The struct, record or union type '{0}' does not support structural equality because the type parameter {1} does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">O tipo de struct, registro ou união '{0}' não suporta igualdade estrutural porque o parâmetro de tipo {1} não satisfaz a restrição 'equality'. Considere adicionar o atributo 'NoEquality' ao tipo '{2}' para esclarecer que o tipo não suporta igualdade estrutural</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded2">
        <source>The struct, record or union type '{0}' does not support structural equality because the type '{1}' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">O tipo de struct, registro ou união '{0}' não suporta igualdade estrutural porque o tipo {1} não satisfaz a restrição 'equality'. Considere adicionar o atributo 'NoEquality' ao tipo '{2}' para esclarecer que o tipo não suporta igualdade estrutural</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the type parameter '{1}' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter</source>
        <target state="translated">O tipo struct, registro ou união '{0}' tem o atributo 'StructuralEquality', mas o parâmetro de tipo '{1}' não satisfaz a restrição 'equality'. Considere adicionar a restrição 'equality' ao parâmetro de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the component type '{1}' does not satisfy the 'equality' constraint</source>
        <target state="translated">O tipo struct, registro ou união '{0}' tem o atributo 'StructuralEquality', mas o tipo de componente '{1}' não satisfaz a restrição 'equality'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
        <source>Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct.</source>
        <target state="translated">Cada argumento do construtor primário para um struct deve receber um tipo, por exemplo 'type S(x1:int, x2: int) = ...'. Esses argumentos determinam o campo do struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedValue">
        <source>The value '{0}' is unused</source>
        <target state="translated">O valor '{0}' é não usado.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedThisVariable">
        <source>The recursive object reference '{0}' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.</source>
        <target state="translated">A referência de objeto recursiva '{0}' não é usada. A presença de uma referência de objeto recursiva adiciona verificações de inicialização em tempo de execução aos membros destes tipos e seus derivados. Considere remover essa referência de objeto recursiva.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterAtMostOneArgument">
        <source>A getter property may have at most one argument group</source>
        <target state="translated">Uma propriedade getter pode ter no máximo um grupo de argumento</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetterAtMostTwoArguments">
        <source>A setter property may have at most two argument groups</source>
        <target state="translated">Uma propriedade setter pode ter no máximo dois grupos de argumento</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidProperty">
        <source>Invalid property getter or setter</source>
        <target state="translated">Propriedade getter ou setter inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIndexerPropertyRequiresAtLeastOneArgument">
        <source>An indexer property must be given at least one argument</source>
        <target state="translated">Uma propriedade do indexador deve receber pelo menos um argumento</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidAddressOfMutableAcrossAssemblyBoundary">
        <source>This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation</source>
        <target state="translated">Esta operação acessa um valor de alto nível mutável definido em outro assembly de uma forma não suportada. O valor não pode ser acessado através de seu endereço. Considere copiar a expressão ao local mutável, por exemplo: 'let mutable x = ...', e se for necessário atribuir o valor de volta após a conclusão da operação</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTypars">
        <source>Remove spaces between the type name and type parameter, e.g. \"type C&lt;'T&gt;\", not type \"C   &lt;'T&gt;\". Type parameters must be placed directly adjacent to the type name.</source>
        <target state="translated">Remova os espaços entre o nome de tipo e o parâmetro de tipo, ex.: \"digite C&lt;'T&gt;\", não digite \"C &lt;'T&gt;\". Parâmetros de tipo devem ser colocados diretamente adjacentes ao nome de tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTyargs">
        <source>Remove spaces between the type name and type parameter, e.g. \"C&lt;'T&gt;\", not \"C &lt;'T&gt;\". Type parameters must be placed directly adjacent to the type name.</source>
        <target state="translated">Remova os espaços entre o nome de tipo e o parâmetro de tipo, ex.: \"C&lt;'T&gt;\", not \"C &lt;'T&gt;\". Os parâmetros de tipo devem ser colocados diretamente adjacentes ao nome do tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAtomicType">
        <source>The use of the type syntax 'int C' and 'C  &lt;int&gt;' is not permitted here. Consider adjusting this type to be written in the form 'C&lt;int&gt;'</source>
        <target state="translated">O uso da sintaxe dos tipos 'int C' e 'C &lt;int&gt;' não é permitido aqui. Ajuste este tipo para ser escrito na forma 'C&lt;int&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespace">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the module/namespace '{2}'</source>
        <target state="translated">O módulo/namespace '{0}' da unidade de compilação '{1}' não contém o módulo/namespace '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefVal">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the val '{2}'</source>
        <target state="translated">O módulo/namespace '{0}' da unidade de compilação '{1}' não contém o val '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespaceType">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the namespace, module or type '{2}'</source>
        <target state="translated">O módulo/namespace '{0}' da unidade de compilação '{1}' não contém o namespace, módulo ou tipo '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseNullAsTrueValue">
        <source>The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case</source>
        <target state="translated">O sinalizador de atributo 'UseNullAsTrueValue' só podem ser usados com tipos de união que possuem um caso nulário e pelo menos um caso não nulário</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterInferredByref">
        <source>The parameter '{0}' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref&lt;int&gt;'. When used, a byref parameter is implicitly dereferenced.</source>
        <target state="translated">O parâmetro '{0}' foi inferido para ter o tipo byref. Os parâmetros do tipo byref devem receber uma anotação de tipo explícito, ex.: 'x1: byref&lt;int&gt;'. Quando usado, um parâmetro byref é implicitamente desreferenciado.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonUniformMemberUse">
        <source>The generic member '{0}' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.</source>
        <target state="translated">O membro genérico '{0}' foi usado em uma instanciação não uniforme anterior a este ponto de programa. Considere reordenar os membros para que ele venha antes. Como alternativa, especifique o tipo completo do membro explicitamente, incluindo tipos de argumentos, tipo de retorno e todos parâmetros e restrições genéricas adicionais.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttribArgsDiffer">
        <source>The attribute '{0}' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.</source>
        <target state="translated">O atributo '{0}' parece tanto na implementação quanto na assinatura, mas os argumentos de atributos são diferentes. Apenas o atributo da assinatura será incluído no código compilado.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallAbstractBaseMember">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">Não é possível chamar o membro de base abstrata: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInUnmanaged">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position</source>
        <target state="translated">Não foi possível resolver a ambiguidade no uso do constructo genérico com uma restrição 'unmanaged' nesta posição ou próxima a ela</target>
        <note />
      </trans-unit>
      <trans-unit id="mlCompatMessage">
        <source>This construct is for ML compatibility. {0}. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'.</source>
        <target state="translated">Este constructo serve para a compatibilidade ML. {0}. Você pode desabilitar esse aviso usando '--mlcompatibility' ou '--nowarn:62'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldDoesNotHaveValidOffsetForStructureLayout">
        <source>The type '{0}' has been marked as having an Explicit layout, but the field '{1}' has not been marked with the 'FieldOffset' attribute</source>
        <target state="translated">O tipo '{0}' foi marcado como tendo um layout explícito, mas o campo '{1}' não tinha sido marcado com o atributo 'FieldOffset'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfacesShouldUseInheritNotInterface">
        <source>Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'</source>
        <target state="translated">Interfaces herdadas de outras interfaces devem ser declaradas com o uso de 'inherit ...' ao invés de 'interface ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperator">
        <source>Invalid prefix operator</source>
        <target state="translated">Operador pré-fixo inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperatorDefinition">
        <source>Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.</source>
        <target state="translated">Definição de operador inválida. Definições de operadores pré-fixos precisam usar um nome de operador válido.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCompilingExtensionIsForML">
        <source>The file extensions '.ml' and '.mli' are for ML compatibility</source>
        <target state="translated">As extensões de arquivo '.ml' e '.mli' são para compatibilidade com ML</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIndentOffForML">
        <source>Consider using a file with extension '.ml' or '.mli' instead</source>
        <target state="translated">Considere usar um arquivo com extensão '.ml' ou '.mli' em vez disso</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternIdentIsNotFunctionTyped">
        <source>Active pattern '{0}' is not a function</source>
        <target state="translated">O padrão ativo '{0}' não é uma função</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternChoiceHasFreeTypars">
        <source>Active pattern '{0}' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</source>
        <target state="translated">O padrão ativo '{0}' tem um tipo de resultado que contém variáveis de tipo que não são determinadas pela entrada. A causa mais comum é quando um caso de resultado não é mencionado, ex.: 'let (|A|B|) (x:int) = A x'. Isso pode ser corrigido com uma restrição de tipo, ex.: 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldHasOffsetForSequentialLayout">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">O atributo FieldOffset só pode ser colocado em membros de tipos marcados com StructLayout(LayoutKind.Explicit)</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsMustComeAfterNonOptionalArgs">
        <source>Optional arguments must come at the end of the argument list, after any non-optional arguments</source>
        <target state="translated">Argumentos opcionais devem vir no final da lista de argumentos, depois dos argumentos não opcionais</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeUsage">
        <source>Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes</source>
        <target state="translated">O atributo 'System.Diagnostics.ConditionalAttribute' somente é válido em classes de métodos ou atributos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOperatorDefinitionInExtrinsic">
        <source>Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.</source>
        <target state="translated">Membros de extensão não podem fornecer sobrecargas de operadores. Considere definir o operador como parte da definição de tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBFileNameCannotBeChangedWarning">
        <source>The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.</source>
        <target state="translated">O nome do arquivo MDB deve ser &lt;assembly-file-name&gt;.mdb. A opção --pdb será ignorada.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBMemberMissing">
        <source>MDB generation failed. Could not find compatible member {0}</source>
        <target state="translated">Falha ao gerar MDB. Não foi possível encontrar o membro compatível {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingMdb">
        <source>Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly.</source>
        <target state="translated">Não é possível gerar informações de depuração de MDB. Falha ao carregar o tipo 'MonoSymbolWriter' do assembly 'Mono.CompilerServices.SymbolWriter.dll'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseNameConflictsWithGeneratedType">
        <source>The union case named '{0}' conflicts with the generated type '{1}'</source>
        <target state="translated">O caso união chamado '{0}' conflita com o tipo gerado '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoReflectedDefinitionOnStructMember">
        <source>ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter</source>
        <target state="translated">O ReflectedDefinitionAttribute não pode ser aplicado a um membro de instância em um tipo struct porque o membro da instância assume um parâmetro byref 'this' implícito</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportNotAllowed">
        <source>DLLImport bindings must be static members in a class or function definitions in a module</source>
        <target state="translated">As associações DLLImport devem ser membros estáticos em uma classe ou definições de função em um módulo</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExplicitCoreLibRequiresNoFramework">
        <source>When mscorlib.dll or FSharp.Core.dll is explicitly referenced the {0} option must also be passed</source>
        <target state="translated">Enquanto mscorlib.dll ou FSharp.Core.dll é explicitamente referenciado, a opção {0} também deve ser passada</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedSigdataFile">
        <source>FSharp.Core.sigdata not found alongside FSharp.Core. File expected in {0}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">FSharp.Core.sigdata não encontrado junto com FSharp.Core. Arquivo esperado em {0}. Considere atualizar para uma versão mais recente do FSharp.Corem, na qual esse arquivo não é mais necessário.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedFileAlongSideFSharpCore">
        <source>File '{0}' not found alongside FSharp.Core. File expected in {1}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">O arquivo '{0}' não foi encontrado junto com FSharp.Core. Arquivo esperado em {1}. Considere atualizar para uma versão mais recente do FSharp.Corem, na qual esse arquivo não é mais necessário.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedFileNameCharacter">
        <source>Filename '{0}' contains invalid character '{1}'</source>
        <target state="translated">O nome de arquivo '{0}' contém o caractere inválido '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBinding">
        <source>'use!' bindings must be of the form 'use! &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">associações 'use!' devem ser da forma 'use! &lt;var&gt; = &lt;expr&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoInnerGenericsInQuotations">
        <source>Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.</source>
        <target state="translated">Funções genéricas interiores não são permitidas em expressões entre aspas. Considere adicionar algumas restrições de tipo até que esta função não seja mais genérica.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumTypeCannotBeEnumerated">
        <source>The type '{0}' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property</source>
        <target state="translated">O tipo '{0}' não é um tipo de enumerador válido, ou seja, não possui um método MoveNext()' retornando um bool e uma propriedade 'Current'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteString">
        <source>End of file in triple-quote string begun at or before here</source>
        <target state="translated">Fim de arquivo na cadeia de caracteres com aspas triplas iniciada aqui ou antes</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteStringInComment">
        <source>End of file in triple-quote string embedded in comment begun at or before here</source>
        <target state="translated">Fim de arquivo na cadeia de caracteres com aspas triplas inserida no comentário iniciado aqui ou antes</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLosesMeasures">
        <source>This type test or downcast will ignore the unit-of-measure '{0}'</source>
        <target state="translated">Esse teste de tipo ou downcast ignorará a unidade de medida '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingTypeArgs">
        <source>Expected type argument or static argument</source>
        <target state="translated">Argumento de tipo ou argumento estático esperado</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingGreaterThan">
        <source>Unmatched '&lt;'. Expected closing '&gt;'</source>
        <target state="translated">'&lt;'. Fechamento esperado '&gt;' incompatível</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
        <source>Unexpected quotation operator '&lt;@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '&lt;' and '@' characters.</source>
        <target state="translated">Operador de cotação inesperado '&lt;@' na definição de tipo. Se deseja passar uma cadeia de caracteres textual como um argumento estático para um provedor de tipos, coloque um espaço entre os caracteres '&lt;' e '@'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorParsingAsOperatorName">
        <source>Attempted to parse this as an operator name, but failed</source>
        <target state="translated">A tentativa de analisar isto como um nome de operador falhou</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidUnicodeLiteral">
        <source>\U{0} is not a valid Unicode character escape sequence</source>
        <target state="translated">\U{0} não é uma sequência de escape de caracteres Unicode válida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoWrongType">
        <source>'{0}' must be applied to an argument of type '{1}', but has been applied to an argument of type '{2}'</source>
        <target state="translated">'{0}' deve ser aplicado a um argumento do tipo '{1}', mas foi aplicado a um argumento do tipo '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoNotOptional">
        <source>'{0}' can only be applied to optional arguments</source>
        <target state="translated">'{0}' só pode ser aplicado a argumentos opcionais</target>
        <note />
      </trans-unit>
      <trans-unit id="toolLocationHelperUnsupportedFrameworkVersion">
        <source>The specified .NET Framework version '{0}' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
        <target state="translated">Não há suporte para a versão especificada do .NET Framework '{0}'. Especifique um valor da enumeração Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidMagicValue">
        <source>Invalid Magic value in CLR Header</source>
        <target state="translated">Valor Mágico Inválido no Cabeçalho CLR</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignBadImageFormat">
        <source>Bad image format</source>
        <target state="translated">Formato de imagem inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignPrivateKeyExpected">
        <source>Private key expected</source>
        <target state="translated">Chave privada esperada</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignRsaKeyExpected">
        <source>RSA key expected</source>
        <target state="translated">Chave RSA esperada</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidBitLen">
        <source>Invalid bit Length</source>
        <target state="translated">Tamanho de bit inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidRSAParams">
        <source>Invalid RSAParameters structure - '{{0}}' expected</source>
        <target state="translated">Estrutura RSAParameters inválida - '{{0}}' esperado</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidAlgId">
        <source>Invalid algId - 'Exponent' expected</source>
        <target state="translated">algId inválido - 'Exponente' esperado</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidSignatureSize">
        <source>Invalid signature size</source>
        <target state="translated">Tamanho de assinatura inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignNoSignatureDirectory">
        <source>No signature directory</source>
        <target state="translated">Nenhum diretório de assinatura</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidPKBlob">
        <source>Invalid Public Key blob</source>
        <target state="translated">Blob de Chave Pública Inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTooManyErrors">
        <source>Exiting - too many errors</source>
        <target state="translated">Saindo: excesso de erros</target>
        <note />
      </trans-unit>
      <trans-unit id="docfileNoXmlSuffix">
        <source>The documentation file has no .xml suffix</source>
        <target state="translated">O arquivo de documentação não possui sufixo .xml</target>
        <note />
      </trans-unit>
      <trans-unit id="fscNoImplementationFiles">
        <source>No implementation files specified</source>
        <target state="translated">Nenhum arquivo de implementação especificado</target>
        <note />
      </trans-unit>
      <trans-unit id="fscBadAssemblyVersion">
        <source>The attribute {0} specified version '{1}', but this value is invalid and has been ignored</source>
        <target state="translated">O atributo {0} especificou a versão '{1}', mas esse valor é inválido e foi ignorado</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTwoResourceManifests">
        <source>Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used.</source>
        <target state="translated">Opções de conflito especificadas: 'win32manifest' e 'win32res'. Somente uma delas pode ser usada.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking">
        <source>The code in assembly '{0}' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">O código no assembly '{0}' usa literais de cotação. A vinculação estática pode não incluir componentes que usam literais de cotação, a menos que todos os assemblies estejam compilados com, pelo menos, F# 4.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking0">
        <source>Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">O código neste assembly usa literais de cotação. A vinculação estática pode não incluir componentes que usam literais de cotação, a menos que todos os assemblies estejam compilados com, pelo menos, F# 4.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoEXE">
        <source>Static linking may not include a .EXE</source>
        <target state="translated">A vinculação estática pode não incluir um .EXE</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoMixedDLL">
        <source>Static linking may not include a mixed managed/unmanaged DLL</source>
        <target state="translated">A vinculação estática pode não incluir uma DLL gerenciada/não gerenciada mista</target>
        <note />
      </trans-unit>
      <trans-unit id="fscIgnoringMixedWhenLinking">
        <source>Ignoring mixed managed/unmanaged assembly '{0}' during static linking</source>
        <target state="translated">Ignorando assembly gerenciado/não gerenciado misto '{0}' durante vinculação estática</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssumeStaticLinkContainsNoDependencies">
        <source>Assembly '{0}' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.</source>
        <target state="translated">O assembly '{0}' foi referenciado transitivamente e o assembly não pôde ser resolvido automaticamente. A vinculação estática assumirá que esta DLL não possui dependências na biblioteca F# ou outras DLLs vinculadas estaticamente. Considere adicionar uma referência explícita a esta DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyNotFoundInDependencySet">
        <source>Assembly '{0}' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.</source>
        <target state="translated">O assembly '{0}' não foi encontrado no conjunto de dependências do binário de destino. Raízes vinculadas estaticamente devem ser especificadas por um nome de assembly, sem extensão DLL ou EXE. Se esse assembly foi referenciado explicitamente, é possível que ele não tenha sido exigido de fato pelo binário gerado e, nesse caso, ele não deve ser vinculado estaticamente.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileCouldNotBeOpened">
        <source>The key file '{0}' could not be opened</source>
        <target state="translated">Não foi possível abrir o arquivo de chave '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="fscProblemWritingBinary">
        <source>A problem occurred writing the binary '{0}': {1}</source>
        <target state="translated">Ocorreu um problema ao gravar o binário '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyVersionAttributeIgnored">
        <source>The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option</source>
        <target state="translated">O 'AssemblyVersionAttribute' foi ignorado porque uma versão foi atribuída usando uma opção de linha de comando</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyCultureAttributeError">
        <source>Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'</source>
        <target state="translated">Erro ao emitir o atributo 'System.Reflection.AssemblyCultureAttribute' -- 'Executáveis não podem ser assemblies satélites, a Cultura deve estar sempre vazia'</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDelaySignWarning">
        <source>Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module</source>
        <target state="translated">A opção '--delaysign' substitui o atributo 'System.Reflection.AssemblyDelaySignAttribute' fornecido em um arquivo de origem ou módulo adicionado</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileWarning">
        <source>Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module</source>
        <target state="translated">A opção '--keyfile' substitui o atributo 'System.Reflection.AssemblyKeyFileAttribute' fornecido em um módulo adicionado ou arquivo de origem</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyNameWarning">
        <source>Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module</source>
        <target state="translated">A opção '--keycontainer' substitui o atributo 'System.Reflection.AssemblyNameAttribute' fornecido em um módulo adicionado ou arquivo de origem</target>
        <note />
      </trans-unit>
      <trans-unit id="fscReferenceOnCommandLine">
        <source>The assembly '{0}' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'.</source>
        <target state="translated">O assembly '{0}' está listado na linha de comando. Assemblies devem ser referenciados usando um sinalizador de linha de comando como '-r'.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscRemotingError">
        <source>The resident compilation service was not used because a problem occured in communicating with the server.</source>
        <target state="translated">O serviço de compilação residente não foi usado porque houve um problema de comunicação com o servidor.</target>
        <note />
      </trans-unit>
      <trans-unit id="pathIsInvalid">
        <source>Problem with filename '{0}': Illegal characters in path.</source>
        <target state="translated">Problema com nome de arquivo '{0}': caracteres inválidos no caminho.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscResxSourceFileDeprecated">
        <source>Passing a .resx file ({0}) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.</source>
        <target state="translated">Passar um arquivo. resx ({0}) como um arquivo de origem para o compilador é preterido. Use resgen.exe para transformar o arquivo .resx em um arquivo .resources para passar como uma opção --resource.Se você estiver usando MSBuild, isso poderá ser feito por meio de um item &lt;EmbeddedResource&gt; no arquivo de projeto. fsproj.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoProfileMismatches">
        <source>Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).</source>
        <target state="translated">A vinculação estática não pode ser usada em um assembly com referência a mscorlib (por exemplo, um assembly do .NET Framework) ao gerar um assembly com referência a System.Runtime (por exemplo, um assembly .NET Core ou Portátil).</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyWildcardAndDeterminism">
        <source>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</source>
        <target state="translated">Uma versão especificada {0} '{1}', mas esse valor é um curinga, e você solicitou uma compilação determinística. Eles estão em conflito.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDeterministicDebugRequiresPortablePdb">
        <source>Deterministic builds only support portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="needs-review-translation">Compilações determinísticas dão suporte somente a PDBs portáteis (--debug:portable ou --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInNamespaceName">
        <source>Character '{0}' is not allowed in provided namespace name '{1}'</source>
        <target state="translated">O caractere '{0}' não é permitido no nome de namespace fornecido '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullOrEmptyMemberName">
        <source>The provided type '{0}' returned a member with a null or empty member name</source>
        <target state="translated">O tipo fornecido '{0}' retornou um membro com nome de membro nulo ou vazio</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMember">
        <source>The provided type '{0}' returned a null member</source>
        <target state="translated">O tipo fornecido '{0}' retornou um membro nulo</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringType">
        <source>The provided type '{0}' member info '{1}' has null declaring type</source>
        <target state="translated">As informações do membro {1} do tipo fornecido '{0}' possui um tipo de declaração nulo</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringTypeDifferentFromProvidedType">
        <source>The provided type '{0}' has member '{1}' which has declaring type '{2}'. Expected declaring type to be the same as provided type.</source>
        <target state="translated">O tipo fornecido '{0}' possui um membro '{1}' com tipo declarativo '{2}'. O tipo declarativo esperado deve ser o mesmo que o tipo fornecido.</target>
        <note />
      </trans-unit>
      <trans-unit id="etHostingAssemblyFoundWithoutHosts">
        <source>Referenced assembly '{0}' has assembly level attribute '{1}' but no public type provider classes were found</source>
        <target state="translated">O assembly referenciado '{0}' possui atributo de nível de assembly '{1}', mas nenhuma classe de provedor de tipos público foi encontrada</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceOfTypeNotAllowed">
        <source>Type '{0}' from type provider '{1}' has an empty namespace. Use 'null' for the global namespace.</source>
        <target state="translated">O tipo '{0}' do provedor de tipos '{1}' possui um namespace vazio. Use 'null' para o namespace global.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceNotAllowed">
        <source>Empty namespace found from the type provider '{0}'. Use 'null' for the global namespace.</source>
        <target state="translated">Namespace vazio encontrado do provedor de tipos '{0}'. Use 'null' para o namespace global.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeGeneric">
        <source>Provided type '{0}' has 'IsGenericType' as true, but generic types are not supported.</source>
        <target state="translated">O tipo fornecido '{0}' possui 'IsGenericType' como verdadeiro, mas não há suporte a tipos genéricos.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeAnArray">
        <source>Provided type '{0}' has 'IsArray' as true, but array types are not supported.</source>
        <target state="translated">O tipo fornecido '{0}' possui 'IsArray' como verdadeiro, mas não há suporte a tipos matriz.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMethodHasRequirements">
        <source>Invalid member '{0}' on provided type '{1}'. Provided type members must be public, and not be generic, virtual, or abstract.</source>
        <target state="translated">Membro inválido '{0}' no tipo fornecido '{1}'. Os membros do tipo fornecido devem ser públicos, e não genéricos, virtuais ou abstratos.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedMemberKind">
        <source>Invalid member '{0}' on provided type '{1}'. Only properties, methods and constructors are allowed</source>
        <target state="translated">Membro inválido '{0}' no tipo fornecido '{1}'. Somente propriedades, métodos e construtores são permitidos</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanReadButHasNoGetter">
        <source>Property '{0}' on provided type '{1}' has CanRead=true but there was no value from GetGetMethod()</source>
        <target state="translated">A propriedade '{0}' no tipo fornecido '{1}' possui CanRead=true, mas não houve valor de GetGetMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasGetterButNoCanRead">
        <source>Property '{0}' on provided type '{1}' has CanRead=false but GetGetMethod() returned a method</source>
        <target state="translated">A propriedade '{0}' no tipo fornecido '{1}' possui CanRead=false, mas GetGetMethod() retornou um método</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanWriteButHasNoSetter">
        <source>Property '{0}' on provided type '{1}' has CanWrite=true but there was no value from GetSetMethod()</source>
        <target state="translated">A propriedade '{0}' no tipo fornecido '{1}' possui CanWrite=true, mas não houve valor de GetSetMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasSetterButNoCanWrite">
        <source>Property '{0}' on provided type '{1}' has CanWrite=false but GetSetMethod() returned a method</source>
        <target state="translated">A propriedade '{0}' no tipo fornecido '{1}' possui CanWrite=false, mas GetSetMethod() retornou um método</target>
        <note />
      </trans-unit>
      <trans-unit id="etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
        <source>One or more errors seen during provided type setup</source>
        <target state="translated">Um ou mais erros observados durante a configuração de tipo fornecida</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedTypeMember">
        <source>Unexpected exception from provided type '{0}' member '{1}': {2}</source>
        <target state="translated">Exceção inesperada do membro '{1}' do tipo fornecido '{0}': {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedConstantType">
        <source>Unsupported constant type '{0}'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal.</source>
        <target state="translated">Tipo da constante sem suporte '{0}'. Citações fornecidas pelos provedores de tipo só podem conter constantes simples. A implementação do provedor do tipo talvez precise ser ajustada movendo um valor declarado para fora de um literal de citação fornecido para que seja uma associação 'let' dentro do literal de citação.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedProvidedExpression">
        <source>Unsupported expression '{0}' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.</source>
        <target state="translated">Expressão '{0}' sem suporte do provedor de tipos. Se você é o autor desse provedor de tipo, considere ajustá-lo para oferecer uma expressão diferente.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedName">
        <source>Expected provided type named '{0}' but provided type has 'Name' with value '{1}'</source>
        <target state="translated">Um tipo fornecido com nome '{0}' era esperado, mas o tipo fornecido possui 'Name' com o valor '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoAdd">
        <source>Event '{0}' on provided type '{1}' has no value from GetAddMethod()</source>
        <target state="translated">O evento '{0}' no tipo fornecido '{1}' não tem valores de GetAddMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoRemove">
        <source>Event '{0}' on provided type '{1}' has no value from GetRemoveMethod()</source>
        <target state="translated">O evento '{0}' no tipo fornecido '{1}' não tem valores de GetRemoveMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssembly">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded or doesn't exist. {2}</source>
        <target state="translated">O atributo '{0}' do assembly refere-se a um assembly de designer '{1}' que não pode ser carregado ou não existe. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderDoesNotHaveValidConstructor">
        <source>The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected.</source>
        <target state="translated">O provedor de tipos não tem um construtor válido. Um construtor que não recebe argumentos ou recebe um argumento do tipo 'TypeProviderConfig' era esperado.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderError">
        <source>The type provider '{0}' reported an error: {1}</source>
        <target state="translated">O provedor de tipos '{0}' relatou um erro: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectParameterExpression">
        <source>The type provider '{0}' used an invalid parameter in the ParameterExpression: {1}</source>
        <target state="translated">O provedor de tipos '{0}' usou um parâmetro inválido na ParameterExpression: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedMethod">
        <source>The type provider '{0}' provided a method with a name '{1}' and metadata token '{2}', which is not reported among its methods of its declaring type '{3}'</source>
        <target state="translated">O provedor de tipos '{0}' forneceu um método com um nome '{1}' e um token de metadados '{2}' que não é relatado entre seus métodos de seu tipo declarante '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedConstructor">
        <source>The type provider '{0}' provided a constructor which is not reported among the constructors of its declaring type '{1}'</source>
        <target state="translated">O provedor de tipos '{0}' forneceu um construtor que não é relatado entre os construtores de seu tipo declarante '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etDirectReferenceToGeneratedTypeNotAllowed">
        <source>A direct reference to the generated type '{0}' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = &lt;path&gt;'. This indicates that a type provider adds generated types to your assembly.</source>
        <target state="translated">Uma referência direta para o tipo gerado '{0}' não é permitida. Use uma definição de tipo, por exemplo, 'type TypeAlias = &lt;path&gt;'. Isso indica que um provedor de tipos adiciona tipos gerados para seu assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedPath">
        <source>Expected provided type with path '{0}' but provided type has path '{1}'</source>
        <target state="translated">Um tipo fornecido com caminho '{0}' era esperado, mas o tipo fornecido possui o caminho '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedNullFromProvidedTypeMember">
        <source>Unexpected 'null' return value from provided type '{0}' member '{1}'</source>
        <target state="translated">Valor 'null' inesperado retornado do membro '{1}' do tipo fornecido '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedMemberMember">
        <source>Unexpected exception from member '{0}' of provided type '{1}' member '{2}': {3}</source>
        <target state="translated">Exceção inesperada do membro '{0}' do membro '{2}' do tipo fornecido '{1}': {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
        <source>Nested provided types do not take static arguments or generic parameters</source>
        <target state="translated">Os tipos fornecidos aninhados não recebem argumentos estáticos ou parâmetros genéricos</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidStaticArgument">
        <source>Invalid static argument to provided type. Expected an argument of kind '{0}'.</source>
        <target state="translated">Argumento estático inválido para tipo fornecido. Argumento do tipo '{0}' esperado.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToType">
        <source>An error occured applying the static arguments to a provided type</source>
        <target state="translated">Erro ao aplicar os argumentos estáticos a um tipo fornecido</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnknownStaticArgumentKind">
        <source>Unknown static argument kind '{0}' when resolving a reference to a provided type or method '{1}'</source>
        <target state="translated">Tipo de argumento estático desconhecido '{0}' ao resolver uma referência a um método ou tipo fornecido '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidNamespaceForProvidedType">
        <source>invalid namespace for provided type</source>
        <target state="translated">namespace inválido para tipo fornecido</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidFullNameForProvidedType">
        <source>invalid full name for provided type</source>
        <target state="translated">nome completo inválido para tipo fornecido</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderReturnedNull">
        <source>The type provider returned 'null', which is not a valid return value from '{0}'</source>
        <target state="translated">O provedor de tipos retornou 'null', o que não é um valor retornado válido de '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTypeProviderConstructorException">
        <source>The type provider constructor has thrown an exception: {0}</source>
        <target state="translated">O construtor do provedor de tipos gerou uma exceção: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullProvidedExpression">
        <source>Type provider '{0}' returned null from GetInvokerExpression.</source>
        <target state="translated">O provedor de tipos '{0}' retornou nulo de GetInvokerExpression.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedTypeHadWrongName">
        <source>The type provider '{0}' returned an invalid type from 'ApplyStaticArguments'. A type with name '{1}' was expected, but a type with name '{2}' was returned.</source>
        <target state="translated">O provedor de tipos '{0}' retornou um tipo inválido de 'ApplyStaticArguments'. Um tipo com nome '{1}' era esperado, mas um tipo com nome '{2}' foi retornado.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedMethodHadWrongName">
        <source>The type provider '{0}' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '{1}' was expected, but a method with name '{2}' was returned.</source>
        <target state="translated">O provedor de tipos '{0}' retornou um método inválido de 'AplicarArgumentosEstáticosParaMétodo'. Um método com o nome '{1}' era esperado, mas um método com o nome '{2}' foi retornado.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLossy">
        <source>This type test or downcast will erase the provided type '{0}' to the type '{1}'</source>
        <target state="translated">Esse teste de tipo ou downcast irá apagar o tipo fornecido '{0}' para o tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCastErased">
        <source>This downcast will erase the provided type '{0}' to the type '{1}'.</source>
        <target state="translated">Este downcast apagará o tipo fornecido '{0}' para o tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestErased">
        <source>This type test with a provided type '{0}' is not allowed because this provided type will be erased to '{1}' at runtime.</source>
        <target state="translated">Este teste de tipo com um tipo fornecido '{0}' não é permitido porque este tipo fornecido será apagado para '{1}' no tempo de execução.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromErasedType">
        <source>Cannot inherit from erased provided type</source>
        <target state="translated">Não é possível herdar de um tipo fornecido apagado</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidTypeProviderAssemblyName">
        <source>Assembly '{0}' hase TypeProviderAssembly attribute with invalid value '{1}'. The value should be a valid assembly name</source>
        <target state="translated">O assembly '{0}' possui um atributo TypeProviderAssembly com valor inválido '{1}'. O valor deve ser um nome de assembly válido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameCtor">
        <source>Invalid member name. Members may not have name '.ctor' or '.cctor'</source>
        <target state="translated">Nome de membro inválido. Os membros não podem ter os nomes '.ctor' ou '.cctor'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInferredGenericTypeGivesRiseToInconsistency">
        <source>The function or member '{0}' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '{1}'.</source>
        <target state="translated">A função ou o membro '{0}' é usado de uma forma que requer anotações de tipo adicionais em sua definição para garantir a consistência de tipos deduzidos. A assinatura deduzida é '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentCount">
        <source>The number of type arguments did not match: '{0}' given, '{1}' expected. This may be related to a previously reported error.</source>
        <target state="translated">O número de argumentos de tipo não corresponde: '{0}' fornecido, '{1}' esperado. Isso pode estar relacionado a um erro relatado anteriormente.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotOverrideSealedMethod">
        <source>Cannot override inherited member '{0}' because it is sealed</source>
        <target state="translated">Não é possível substituir o membro herdado '{0}' porque ele é sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderErrorWithContext">
        <source>The type provider '{0}' reported an error in the context of provided type '{1}', member '{2}'. The error: {3}</source>
        <target state="translated">O provedor de tipos '{0}' relatou um erro no contexto do tipo fornecido '{1}', membro '{2}'. Erro: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNameException">
        <source>An exception occurred when accessing the '{0}' of a provided type: {1}</source>
        <target state="translated">Exceção ao acessar o '{0}' de um tipo fornecido: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNullOrEmptyName">
        <source>The '{0}' of a provided type was null or empty.</source>
        <target state="translated">O '{0}' de um tipo fornecido era nulo ou vazio.</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInTypeName">
        <source>Character '{0}' is not allowed in provided type name '{1}'</source>
        <target state="translated">O caractere '{0}' não é permitido no nome de tipo fornecido '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcJoinMustUseSimplePattern">
        <source>In queries, '{0}' must use a simple pattern</source>
        <target state="translated">Em consultas, '{0}' deve usar um padrão simples</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMissingCustomOperation">
        <source>A custom query operation for '{0}' is required but not specified</source>
        <target state="translated">Uma consulta de operação personalizada para '{0}' é necessária, mas não foi especificada</target>
        <note />
      </trans-unit>
      <trans-unit id="etBadUnnamedStaticArgs">
        <source>Named static arguments must come after all unnamed static arguments</source>
        <target state="translated">Argumentos estáticos nomeados devem ser colocados após todos os argumentos estáticos não nomeados</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterRequiresAValue">
        <source>The static parameter '{0}' of the provided type or method '{1}' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '{2}&lt;{3}=...&gt;'.</source>
        <target state="translated">O parâmetro estático '{0}' do tipo ou método fornecido '{1}' exige um valor. Parâmetros estáticos para provedores de tipos podem ser especificados opcionalmente usando argumentos nomeados, ex.: '{2}&lt;{3}=...&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNoStaticParameterWithName">
        <source>No static parameter exists with name '{0}'</source>
        <target state="translated">Não existe um parâmetro estático com o nome '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterAlreadyHasValue">
        <source>The static parameter '{0}' has already been given a value</source>
        <target state="translated">O parâmetro estático '{0}' já recebeu um valor</target>
        <note />
      </trans-unit>
      <trans-unit id="etMultipleStaticParameterWithName">
        <source>Multiple static parameters exist with name '{0}'</source>
        <target state="translated">Há vários parâmetros estáticos com o nome '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
        <source>A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression</source>
        <target state="translated">Uma operação personalizada não pode ser usada em conjunto com uma vinculação 'let' recursiva ou sem valor em outra parte desta expressão computacional</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedHere">
        <source>A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression</source>
        <target state="translated">Uma operação personalizada não pode ser usada em conjunto com os operadores 'use', 'try/with', 'try/finally', 'if/then/else' ou 'match' nesta expressão computacional</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeOverloaded">
        <source>The custom operation '{0}' refers to a method which is overloaded. The implementations of custom operations may not be overloaded.</source>
        <target state="translated">A operação personalizada '{0}' refere-se a um método que está sobrecarregado. As implementações das operações personalizadas não podem ser sobrecarregadas.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIfThenElseMayNotBeUsedWithinQueries">
        <source>An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.</source>
        <target state="translated">Uma expressão if/then/else não pode ser usada em consultas. Considere usar uma expressão if/then ou uma expressão de sequência.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
        <source>Invalid argument to 'methodhandleof' during codegen</source>
        <target state="translated">Argumento inválido para 'methodhandleof' durante geração de código</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceMissingArgument">
        <source>A reference to a provided type was missing a value for the static parameter '{0}'. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">Uma referência para um tipo fornecido não continha um valor para o parâmetro estático '{0}'. Talvez seja necessário recompilar um ou mais assemblies referenciados.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceInvalidText">
        <source>A reference to a provided type had an invalid value '{0}' for a static parameter. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">Uma referência a um tipo fornecido possuía um valor inválido '{0}' para um parâmetro estático. Talvez seja necessário recompilar um ou mais assemblies referenciados.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly">
        <source>'{0}' is not used correctly. This is a custom operation in this query or computation expression.</source>
        <target state="translated">'{0}' não está sendo usado corretamente. Esta é uma operação personalizada nesta consulta ou expressão de computação.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly2">
        <source>'{0}' is not used correctly. Usage: {1}. This is a custom operation in this query or computation expression.</source>
        <target state="translated">'{0}' não está sendo usado corretamente. Uso: {1}. Esta é uma operação personalizada nesta consulta ou expressão de computação.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeJoin">
        <source>{0} var in collection {1} (outerKey = innerKey). Note that parentheses are required after '{2}'</source>
        <target state="translated">{0} var na coleção {1} (outerKey = innerKey). Observe que os parênteses são necessários após '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeGroupJoin">
        <source>{0} var in collection {1} (outerKey = innerKey) into group. Note that parentheses are required after '{2}'</source>
        <target state="translated">{0} var na coleção {1} (outerKey = innerKey) para o grupo. Observe que os parênteses são necessários após '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeZip">
        <source>{0} var in collection</source>
        <target state="translated">{0} var na coleção</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresVariable">
        <source>'{0}' must be followed by a variable name. Usage: {1}.</source>
        <target state="translated">'{0}' deve ser seguido por um nome de variável. Uso: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorIncorrectSyntax">
        <source>Incorrect syntax for '{0}'. Usage: {1}.</source>
        <target state="translated">Sintaxe incorreta para '{0}'. Uso: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresBody">
        <source>'{0}' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... {1} ...</source>
        <target state="translated">'{0}' deve vir após uma cláusula de seleção 'for' e ser seguido pelo restante da consulta. Sintaxe: ... {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationHasIncorrectArgCount">
        <source>'{0}' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected {1} argument(s), but given {2}.</source>
        <target state="translated">'{0}' é usado com um número incorreto de argumentos. Esta é uma operação personalizada nesta consulta ou expressão de computação. {1} argumentos são esperados, mas {2} foram fornecidos.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterToken">
        <source>Expected an expression after this point</source>
        <target state="translated">Expressão esperada após este ponto</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedTypeAfterToken">
        <source>Expected a type after this point</source>
        <target state="translated">Um tipo é esperado após este ponto</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLBrackLess">
        <source>Unmatched '[&lt;'. Expected closing '&gt;]'</source>
        <target state="translated">[&lt;'. Fechamento esperado '&gt;]' incompatível</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileMatch">
        <source>Unexpected end of input in 'match' expression. Expected 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</source>
        <target state="translated">Fim inesperado da entrada na expressão 'match'. Esperado 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTry">
        <source>Unexpected end of input in 'try' expression. Expected 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;'.</source>
        <target state="translated">Fim inesperado da entrada na expressão 'try'. Esperado 'try &lt;expr&gt; with &lt;rules&gt;' ou 'try &lt;expr&gt; finally &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWhile">
        <source>Unexpected end of input in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Fim inesperado da entrada na expressão 'while'. Esperado 'while &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFor">
        <source>Unexpected end of input in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Fim inesperado de entrada na expressão 'for'. Esperado 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWith">
        <source>Unexpected end of input in 'match' or 'try' expression</source>
        <target state="translated">Fim inesperado de entrada na expressão 'match' ou 'try'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileThen">
        <source>Unexpected end of input in 'then' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Fim inesperado da entrada no branch 'then' da expressão condicional. Esperado 'if &lt;expr&gt; then &lt;expr&gt;' ou 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileElse">
        <source>Unexpected end of input in 'else' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Fim inesperado de entrada no branch 'else' da expressão condicional. Esperado 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFunBody">
        <source>Unexpected end of input in body of lambda expression. Expected 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</source>
        <target state="translated">Fim inesperado de entrada no corpo da expressão lambda. Esperado 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeArgs">
        <source>Unexpected end of input in type arguments</source>
        <target state="translated">Fim inesperado de entrada em argumentos de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeSignature">
        <source>Unexpected end of input in type signature</source>
        <target state="translated">Fim inesperado de entrada em assinatura de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeDefinition">
        <source>Unexpected end of input in type definition</source>
        <target state="translated">Fim inesperado de entrada em definição de tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileObjectMembers">
        <source>Unexpected end of input in object members</source>
        <target state="translated">Fim inesperado de entrada em membros de objeto.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileDefinition">
        <source>Unexpected end of input in value, function or member definition</source>
        <target state="translated">Fim inesperado de entrada em definição de valor, função ou membro</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileExpression">
        <source>Unexpected end of input in expression</source>
        <target state="translated">Fim inesperado de entrada na expressão</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedNameAfterToken">
        <source>Unexpected end of type. Expected a name after this point.</source>
        <target state="translated">Fim de tipo inesperado. Esperado um nome após este ponto.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLet">
        <source>Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.</source>
        <target state="translated">Definição incompleta de valor ou função. Se isso for uma expressão, o corpo da expressão deverá ser recuado para a mesma coluna que a palavra-chave 'let'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLetBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword.</source>
        <target state="translated">Definição incompleta de valor. Se isso for uma expressão, o corpo da expressão deverá ser recuado para a mesma coluna que a palavra-chave 'let'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUseBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword.</source>
        <target state="translated">Definição incompleta de valor. Se isso for uma expressão, o corpo da expressão deverá ser recuado para a mesma coluna que a palavra-chave 'use!'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUse">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword.</source>
        <target state="translated">Definição incompleta de valor. Se isso for uma expressão, o corpo da expressão deverá ser recuado para a mesma coluna que a palavra-chave 'use'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsWhileDoExpected">
        <source>Missing 'do' in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'do' ausente na expressão 'while'. Esperado 'while &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsForDoExpected">
        <source>Missing 'do' in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'do' ausente na expressão 'for'. Esperado 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRelationInJoin">
        <source>Invalid join relation in '{0}'. Expected 'expr &lt;op&gt; expr', where &lt;op&gt; is =, =?, ?= or ?=?.</source>
        <target state="translated">Relação de associação inválida em '{0}'. Esperado 'expr &lt;op&gt; expr', onde &lt;op&gt; for =, =?, ?= ou ?=?.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCallsWord">
        <source>Calls</source>
        <target state="translated">Chamadas</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidNumberOfGenericArguments">
        <source>Invalid number of generic arguments to type '{0}' in provided type. Expected '{1}' arguments, given '{2}'.</source>
        <target state="translated">Número inválido de argumentos genéricos para o tipo '{0}' no tipo fornecido. '{1}' argumentos esperados, '{2}' recebidos.</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument1">
        <source>Invalid value '{0}' for unit-of-measure parameter '{1}'</source>
        <target state="translated">Valor inválido '{0}' para parâmetro de unidade de medida '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument2">
        <source>Invalid value unit-of-measure parameter '{0}'</source>
        <target state="translated">Valor inválido do parâmetro de unidade de medida '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyNeedsCanWriteOrCanRead">
        <source>Property '{0}' on provided type '{1}' is neither readable nor writable as it has CanRead=false and CanWrite=false</source>
        <target state="translated">A propriedade '{0}' no tipo fornecido '{1}' não é legível nem gravável, pois possui CanRead=false e CanWrite=false</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIntoNeedsRestOfQuery">
        <source>A use of 'into' must be followed by the remainder of the computation</source>
        <target state="translated">O uso de 'into' deve ser seguido pelo restante da computação</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorDoesntAcceptInto">
        <source>The operator '{0}' does not accept the use of 'into'</source>
        <target state="translated">O operador '{0}' não aceita o uso de 'into'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationInvalid">
        <source>The definition of the custom operator '{0}' does not use a valid combination of attribute flags</source>
        <target state="translated">A definição do operador personalizado '{0}' não usa uma combinação válida de sinalizadores de atributos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisTypeMayNotHaveACLIMutableAttribute">
        <source>This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute.</source>
        <target state="translated">Esta definição de tipo pode não ter o atributo CLIMutable'. Somente tipos de registro podem ter este atributo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAutoPropertyRequiresImplicitConstructionSequence">
        <source>'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">As definições de 'member val' são permitidas apenas em tipos com um construtor primário. Considere adicionar argumentos à sua definição de tipo, por exemplo, 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSet">
        <source>Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">As definições de propriedades podem não ser declaradas mutáveis. Para indicar que esta propriedade pode ser definida, use 'member val PropertyName = expr com get,set'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
        <source>To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Para indicar que esta propriedade pode ser definida, use 'member val PropertyName = expr com get,set'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefsOfByrefs">
        <source>Type '{0}' is illegal because in byref&lt;T&gt;, T cannot contain byref types.</source>
        <target state="translated">O tipo '{0}' é ilegal porque o byref&lt;T&gt;, não pode conter tipos byref.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastopsMaxArrayThirtyTwo">
        <source>F# supports array ranks between 1 and 32. The value {0} is not allowed.</source>
        <target state="translated">F# dá suporte a classificações de matriz entre 1 e 32. O valor {0} não é permitido.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoIntegerForLoopInQuery">
        <source>In queries, use the form 'for x in n .. m do ...' for ranging over integers</source>
        <target state="translated">Em consultas, use o formato 'for x in n .. m do ...' para inteiros abrangentes</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoWhileInQuery">
        <source>'while' expressions may not be used in queries</source>
        <target state="translated">As expressões 'while' não podem ser usadas em consultas</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoTryFinallyInQuery">
        <source>'try/finally' expressions may not be used in queries</source>
        <target state="translated">As expressões 'try/finally' não podem ser usadas em consultas</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseMayNotBeUsedInQueries">
        <source>'use' expressions may not be used in queries</source>
        <target state="translated">As expressões 'use' não podem ser usadas em consultas</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindMayNotBeUsedInQueries">
        <source>'let!', 'use!' and 'do!' expressions may not be used in queries</source>
        <target state="translated">As expressões 'let!', 'use!' e 'do!' não podem ser usadas em consultas</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnMayNotBeUsedInQueries">
        <source>'return' and 'return!' may not be used in queries</source>
        <target state="translated">'return' e 'return!' não podem ser usados em consultas</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryOperator">
        <source>This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type.</source>
        <target state="translated">Este não é um operador de consulta válido. Operadores de consulta são identificadores como 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' e 'averageBy' definidos usando métodos correspondentes no tipo 'QueryBuilder'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryWithMayNotBeUsedInQueries">
        <source>'try/with' expressions may not be used in queries</source>
        <target state="translated">As expressões 'try/with' não podem ser usadas em consultas</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonSimpleLetBindingInQuery">
        <source>This 'let' definition may not be used in a query. Only simple value definitions may be used in queries.</source>
        <target state="translated">Esta definição 'let' não pode ser usada em uma consulta. Somente definições de valores simples podem ser usadas em consultas.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTooManyStaticParameters">
        <source>Too many static parameters. Expected at most {0} parameters, but got {1} unnamed and {2} named parameters.</source>
        <target state="translated">Excesso de parâmetros estáticos. Eram esperados no máximo {0} parâmetros, mas {1} parâmetros não nomeados e {2} parâmetros nomeados foram recebidos.</target>
        <note />
      </trans-unit>
      <trans-unit id="infosInvalidProvidedLiteralValue">
        <source>Invalid provided literal value '{0}'</source>
        <target state="translated">Valor literal fornecido '{0}' inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidPlatformTarget">
        <source>The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead.</source>
        <target state="translated">A plataforma 'anycpu32bitpreferred' só pode ser usada com destinos EXE. Em vez disso, use 'anycpu'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisValueMayNotBeInlined">
        <source>This member, function or value declaration may not be declared 'inline'</source>
        <target state="translated">Esta declaração de membro, função ou valor não pode ser declarada 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="etErasedTypeUsedInGeneration">
        <source>The provider '{0}' returned a non-generated type '{1}' in the context of a set of generated types. Consider adjusting the type provider to only return generated types.</source>
        <target state="translated">O provedor '{0}' retornou um tipo não gerado '{1}' no contexto de um conjunto de tipos gerados. Considere ajustar o provedor de tipos para retornar somente tipos gerados.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryBinaryOperator">
        <source>Arguments to query operators may require parentheses, e.g. 'where (x &gt; y)' or 'groupBy (x.Length / 10)'</source>
        <target state="translated">Argumentos para operadores de consulta podem exigir parênteses, ex.: 'where (x &gt; y)' ou 'groupBy (x.Length / 10)'</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoSetOfHole">
        <source>A quotation may not involve an assignment to or taking the address of a captured local variable</source>
        <target state="translated">Uma cotação não pode incluir uma atribuição para ou assumir o endereço de uma variável local capturada</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloads1">
        <source>+ 1 overload</source>
        <target state="translated">+ 1 sobrecarga</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloadsN">
        <source>+ {0} overloads</source>
        <target state="translated">+ {0} sobrecargas</target>
        <note />
      </trans-unit>
      <trans-unit id="erasedTo">
        <source>Erased to</source>
        <target state="translated">Apagado para</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnfinishedExpression">
        <source>Unexpected token '{0}' or incomplete expression</source>
        <target state="translated">Token '{0}' inesperado ou expressão incompleta</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributeOnIncompleteCode">
        <source>Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.</source>
        <target state="translated">Não é possível encontrar o destino de código para este atributo, possivelmente porque o código após o atributo está incompleto.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeNameCannotBeEmpty">
        <source>Type name cannot be empty.</source>
        <target state="translated">O nome do tipo não pode ficar vazio.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemReadingAssembly">
        <source>Problem reading assembly '{0}': {1}</source>
        <target state="translated">Problema ao ler assembly '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTPFieldMustBeLiteral">
        <source>Invalid provided field. Provided fields of erased provided types must be literals.</source>
        <target state="translated">Campo fornecido inválido. Os campos fornecidos de tipos fornecidos apagados devem ser literais.</target>
        <note />
      </trans-unit>
      <trans-unit id="loadingDescription">
        <source>(loading description...)</source>
        <target state="translated">(carregando descrição...)</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionUnavailable">
        <source>(description unavailable...)</source>
        <target state="translated">(descrição não disponível...)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTyparMultipleClassConstraints">
        <source>A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.</source>
        <target state="translated">Uma variável de tipo foi restringida por vários tipos de classes diferentes. Uma variável de tipo só pode conter uma restrição de classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMatchMayNotBeUsedWithQuery">
        <source>'match' expressions may not be used in queries</source>
        <target state="translated">As expressões 'match' não podem ser usadas em consultas</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonTripleArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 3 arguments</source>
        <target state="translated">O membro do operador infixo '{0}' possui {1} argumentos iniciais. Uma tupla de 3 argumentos é esperada</target>
        <note />
      </trans-unit>
      <trans-unit id="cannotResolveNullableOperators">
        <source>The operator '{0}' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">O operador '{0}' não pode ser resolvido. Considere abrir o módulo 'Microsoft.FSharp.Linq.NullableOperators'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorRequiresIn">
        <source>'{0}' must be followed by 'in'. Usage: {1}.</source>
        <target state="translated">'{0}' deve ser seguido por 'in'. Uso: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalMemberVarInObjectImplementation">
        <source>Neither 'member val' nor 'override val' definitions are permitted in object expressions.</source>
        <target state="translated">As definições de 'member val' e 'override val' não são permitidas em expressões de objetos.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyCopyAndUpdateRecordInvalid">
        <source>Copy-and-update record expressions must include at least one field.</source>
        <target state="translated">As expressões de registros copiar e atualizar devem incluir pelo menos um campo.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnderscoreInvalidFieldName">
        <source>'_' cannot be used as field name</source>
        <target state="translated">'_' não pode ser usado como nome de campo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGeneratedTypesShouldBeInternalOrPrivate">
        <source>The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'.</source>
        <target state="translated">Os tipos fornecidos gerados por este uso de um provedor de tipos não podem ser usados de outros assemblies F# e devem ser marcados como internos ou privados. Considere usar 'type internal TypeName = ...' ou 'type private TypeName = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterAndSetterHaveSamePropertyType">
        <source>A property's getter and setter must have the same type. Property '{0}' has getter of type '{1}' but setter of type '{2}'.</source>
        <target state="translated">O getter e o setter de uma propriedade devem ter o mesmo tipo. A propriedade '{0}' possui getter do tipo '{1}', mas setter do tipo '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRuntimeSuppliedMethodCannotBeUsedInUserCode">
        <source>Array method '{0}' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.</source>
        <target state="translated">O método de matriz '{0}' é fornecido pelo tempo de execução e não pode ser usado diretamente no código. Para operações com elementos de matriz, considere usar a família de funções GetArray/SetArray do módulo LanguagePrimitives.IntrinsicFunctions.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName">
        <source>The union case '{0}' does not have a field named '{1}'.</source>
        <target state="translated">O caso união '{0}' não tem um campo nomeado '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseFieldCannotBeUsedMoreThanOnce">
        <source>Union case/exception field '{0}' cannot be used more than once.</source>
        <target state="translated">O campo '{0}' do caso união/exceção não pode ser usado mais de uma vez.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameIsUsedModeThanOnce">
        <source>Named field '{0}' is used more than once.</source>
        <target state="translated">O campo nomeado '{0}' é usado mais de uma vez.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameConflictsWithGeneratedNameForAnonymousField">
        <source>Named field '{0}' conflicts with autogenerated name for anonymous field.</source>
        <target state="translated">O campo nomeado '{0}' está em conflito com o nome gerado automaticamente para o campo anônimo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConstantExpressionOverflow">
        <source>This literal expression or attribute argument results in an arithmetic overflow.</source>
        <target state="translated">Esta expressão literal ou este argumento de atributo resulta em um estouro aritmético.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalStructTypeForConstantExpression">
        <source>This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.</source>
        <target state="translated">Esta não é uma expressão literal válida. O atributo [&lt;Literal&gt;] será ignorado.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscSystemRuntimeInteropServicesIsRequired">
        <source>System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.</source>
        <target state="translated">O assembly System.Runtime.InteropServices é necessário para usar classes as UnknownWrapper\DispatchWrapper.</target>
        <note />
      </trans-unit>
      <trans-unit id="abImplicitHeapAllocation">
        <source>The mutable local '{0}' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.</source>
        <target state="translated">O local mutável '{0}' está alocado implicitamente como uma célula de referência porque foi capturado por um fechamento. Este aviso é somente para fins informativos para indicar onde alocações implícitas são executadas.</target>
        <note />
      </trans-unit>
      <trans-unit id="estApplyStaticArgumentsForMethodNotImplemented">
        <source>A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid</source>
        <target state="translated">Um provedor de tipos implementado ObterParâmetrosEstáticosParaMétodo, mas AplicarArgumentosEstatísticasParaMétodo não foi implementado ou inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToMethod">
        <source>An error occured applying the static arguments to a provided method</source>
        <target state="translated">Ocorreu um erro ao aplicar os argumentos estáticos para um método fornecido</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexUnexpectedChar">
        <source>Unexpected character '{0}' in preprocessor expression</source>
        <target state="translated">Caractere inesperado '{0}' na expressão do pré-processador</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsUnexpectedToken">
        <source>Unexpected token '{0}' in preprocessor expression</source>
        <target state="translated">Token inesperado '{0}' na expressão do pré-processador</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsIncompleteExpression">
        <source>Incomplete preprocessor expression</source>
        <target state="translated">Expressão incompleta do pré-processador</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsMissingToken">
        <source>Missing token '{0}' in preprocessor expression</source>
        <target state="translated">Token ausente '{0}' na expressão do pré-processador</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleMissingDefinition">
        <source>An error occurred while reading the F# metadata node at position {0} in table '{1}' of assembly '{2}'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.</source>
        <target state="translated">Ocorreu um erro ao ler o nó de metadados F# na posição {0} na tabela '{1}' do assembly '{2}'. O nó não tinha declaração correspondente. Reporte este aviso. Pode ser necessário recompilar o assembly F# que você está usando.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScope">
        <source>Type inference caused the type variable {0} to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.</source>
        <target state="translated">A inferência de tipos causou um escape no escopo da variável de tipo {0}. Considere adicionar uma declaração de parâmetro de tipo explícito ou ajustar seu código para ser menos genérico.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScopeAnon">
        <source>Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.</source>
        <target state="translated">A inferência de tipos causou um escape no escopo de uma variável de tipo de inferência. Considere adicionar anotações de tipo para tornar seu código menos genérico.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkRaiseFamilyFunctionArgumentCount">
        <source>Redundant arguments are being ignored in function '{0}'. Expected {1} but got {2} arguments.</source>
        <target state="translated">Argumentos redundantes estão sendo ignorados na função '{0}'. Era esperado {1} mas foi obtido {2} argumentos.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkLowercaseLiteralBindingInPattern">
        <source>Lowercase literal '{0}' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.</source>
        <target state="translated">O literal em minúsculas '{0}' está sendo ocultado por um novo padrão com o mesmo nome. Somente literais com prefixo de módulo e em maiúsculas podem ser usados como padrões de nomes.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralDoesNotTakeArguments">
        <source>This literal pattern does not take arguments</source>
        <target state="translated">Esse padrão literal não tem argumentos</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalInAugmentation">
        <source>Constructors are not permitted as extension members - they must be defined as part of the original definition of the type</source>
        <target state="translated">Os construtores não são permitidos como membros de extensão - eles devem ser definidos como parte da definição original do tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidResponseFile">
        <source>Invalid response file '{0}' ( '{1}' )</source>
        <target state="translated">Arquivo de resposta '{0}' inválido ( '{1}' )</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNotFound">
        <source>Response file '{0}' not found in '{1}'</source>
        <target state="translated">Arquivo de resposta '{0}' não encontrado em '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNameInvalid">
        <source>Response file name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">O nome do arquivo de resposta '{0}' está vazio, contém caracteres inválidos, tem uma especificação de unidade sem um caminho absoluto ou é muito longo</target>
        <note />
      </trans-unit>
      <trans-unit id="fsharpCoreNotFoundToBeCopied">
        <source>Cannot find FSharp.Core.dll in compiler's directory</source>
        <target state="translated">Não é possível localizar FSharp.Core.dll no diretório do compilador</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleStructMismatch">
        <source>One tuple type is a struct tuple, the other is a reference tuple</source>
        <target state="translated">Um tipo de tupla é uma tupla de struct, o outro é uma tupla de referência</target>
        <note />
      </trans-unit>
      <trans-unit id="etMissingStaticArgumentsToMethod">
        <source>This provided method requires static parameters</source>
        <target state="translated">Esse método fornecido requer parâmetros estáticos</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcast">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'.</source>
        <target state="translated">A conversão de {0} para {1} é um upcast de segurança de tempo de compilação, não um downcast. Considere usar 'upcast' em vez de 'downcast'.</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcastOperator">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.</source>
        <target state="translated">A conversão de {0} para {1} é um upcast seguro em tempo de compilação, não um downcast. Use o operador:&gt; (upcast) em vez do operador :?&gt; (downcast).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecImplied">
        <source>The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored</source>
        <target state="translated">O 'rec' neste módulo é implícito por uma declaração 'rec' externa e está sendo ignorado</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenFirstInMutRec">
        <source>In a recursive declaration group, 'open' declarations must come first in each module</source>
        <target state="translated">Em um grupo de declaração recursivo, as declarações 'open' devem vir antes em cada módulo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbrevFirstInMutRec">
        <source>In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations</source>
        <target state="translated">Em um grupo de declaração recursivo, as abreviações de módulo devem vir após todas as declarações 'open' e antes de outras declarações</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedMutRecDecl">
        <source>This declaration is not supported in recursive declaration groups</source>
        <target state="translated">Não há suporte para esta declaração em grupos de declaração recursivos</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidUseOfRec">
        <source>Invalid use of 'rec' keyword</source>
        <target state="translated">Uso inválido da palavra-chave 'rec'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructUnionMultiCaseDistinctFields">
        <source>If a union type has more than one case and is a struct, then all fields within the union type must be given unique names.</source>
        <target state="translated">Se um tipo de união tiver mais de um caso e for struct, então todos os campos dentro do tipo de união deverão ter nomes exclusivos.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerMemberNameIsOverriden">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">O CallerMemberNameAttribute aplicado ao parâmetro "{0}" não terá efeito. Ele é substituído pelo CallerFilePathAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFixedNotAllowed">
        <source>Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'</source>
        <target state="translated">Uso inválido da 'fixed'. 'fixed' somente pode ser usada em uma declaração no formato 'use x = fixed expr', em que a expressão é uma matriz, o endereço de um campo, o endereço de um elemento de matriz ou uma cadeia de caracteres</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindOffsetToStringData">
        <source>Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression.</source>
        <target state="translated">Não foi possível encontrar o método System.Runtime.CompilerServices.OffsetToStringData nas referências ao compilar a expressão 'fixed'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedActivePattern">
        <source>{0} is an active pattern and cannot be treated as a discriminated union case with named fields.</source>
        <target state="translated">{0} é um padrão ativo e não pode ser tratado como um caso de união discriminada com campos nomeados.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultParameterValueNotAppropriateForArgument">
        <source>The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'.</source>
        <target state="translated">O valor padrão não tem o mesmo tipo que o argumento. O atributo DefaultParameterValue e qualquer atributo Optional serão ignorados. Observação: 'null' precisa ser anotado com o tipo correto, por exemplo, 'DefaultParameterValue(null:obj)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGlobalsSystemTypeNotFound">
        <source>The system type '{0}' was required but no referenced system DLL contained this type</source>
        <target state="translated">O tipo de sistema '{0}' era necessário, mas nenhum DLL de sistema referenciado o continha</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberHasMultiplePossibleDispatchSlots">
        <source>The member '{0}' matches multiple overloads of the same method.\nPlease restrict it to one of the following:{1}.</source>
        <target state="translated">O membro '{0}' corresponde a várias sobrecargas do mesmo método.\nLimite-o a uma das seguintes:{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="methodIsNotStatic">
        <source>Method or object constructor '{0}' is not static</source>
        <target state="translated">O método ou o construtor de objeto '{0}' não é estático</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolEqualsInsteadOfIn">
        <source>Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?</source>
        <target state="translated">Símbolo inesperado '=' na expressão. Você pretendia usar 'for x in y .. z do' em vez disso?</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAbstract">
        <source>Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</source>
        <target state="translated">Indica um método que não tem implementação no tipo no qual ele é declarado ou que é virtual e tem uma implementação padrão.</target>
        <note />
      </trans-unit>
      <trans-unit id="keyworkDescriptionAnd">
        <source>Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</source>
        <target state="translated">Usado em associações mutualmente recursivas, em declarações de propriedade e em múltiplas restrições em parâmetros genéricos.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAs">
        <source>Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</source>
        <target state="translated">Usado para dar ao objeto de classe atual um nome de objeto. Também usado para dar um nome para um padrão completo em uma correspondência de padrão.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAssert">
        <source>Used to verify code during debugging.</source>
        <target state="translated">Usado para verificar o código durante a depuração.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBase">
        <source>Used as the name of the base class object.</source>
        <target state="translated">Usado como o nome do objeto de classe base.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBegin">
        <source>In verbose syntax, indicates the start of a code block.</source>
        <target state="translated">Na sintaxe detalhada, indica o começo de um bloco de código.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionClass">
        <source>In verbose syntax, indicates the start of a class definition.</source>
        <target state="translated">Na sintaxe detalhada, indica o começo de uma definição de classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDefault">
        <source>Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</source>
        <target state="translated">Indica uma implementação de um método abstrato; usado em conjunto com uma declaração de método abstrato para criar um método virtual.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDelegate">
        <source>Used to declare a delegate.</source>
        <target state="translated">Usada para declarar um delegado.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDo">
        <source>Used in looping constructs or to execute imperative code.</source>
        <target state="translated">Usado em construções de looping ou para executar código imperativo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDone">
        <source>In verbose syntax, indicates the end of a block of code in a looping expression.</source>
        <target state="translated">Na sintaxe detalhada, indica o fim de um bloco de código em uma expressão de looping.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDowncast">
        <source>Used to convert to a type that is lower in the inheritance chain.</source>
        <target state="translated">Usada para converter para um tipo que é inferior na cadeia de herança.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDownto">
        <source>In a for expression, used when counting in reverse.</source>
        <target state="translated">Em uma expressão, usado ao contar regressivamente.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElif">
        <source>Used in conditional branching. A short form of else if.</source>
        <target state="translated">Usado em ramificação condicional. Uma forma abreviada de else if.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElse">
        <source>Used in conditional branching.</source>
        <target state="translated">Usado em ramificação condicional.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionEnd">
        <source>In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</source>
        <target state="translated">Em definições e extensões de tipo, indica o final de uma seção de definições de membro. Na sintaxe detalhada, é usado para especificar o final de um bloco de código que começa com a palavra-chave "begin".</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionException">
        <source>Used to declare an exception type.</source>
        <target state="translated">Usado para declarar um tipo de exceção.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionExtern">
        <source>Indicates that a declared program element is defined in another binary or assembly.</source>
        <target state="translated">Indica que um elemento de programa declarado é definido em outro binário ou assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTrueFalse">
        <source>Used as a Boolean literal.</source>
        <target state="translated">Usado como um literal Booliano.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFinally">
        <source>Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</source>
        <target state="translated">Usado junto com try para introduzir um bloco de código que é executado independentemente da ocorrência de uma exceção.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFor">
        <source>Used in looping constructs.</source>
        <target state="translated">Usado em constructos de looping.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFun">
        <source>Used in lambda expressions, also known as anonymous functions.</source>
        <target state="translated">Usado em expressões lambda, também conhecidas como funções anônimas.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFunction">
        <source>Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</source>
        <target state="translated">Usado como uma alternativa menor para a palavra-chave "fun" e uma expressão de correspondência em uma expressão lambda que tem correspondência de padrão em um único argumento.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionGlobal">
        <source>Used to reference the top-level .NET namespace.</source>
        <target state="translated">Usado para referenciar o namespace .NET de nível superior.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIf">
        <source>Used in conditional branching constructs.</source>
        <target state="translated">Usado em constructos de ramificação condicional.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIn">
        <source>Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</source>
        <target state="translated">Usada para expressões de sequência e, na sintaxe detalhada, para separar expressões de ligações.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInherit">
        <source>Used to specify a base class or base interface.</source>
        <target state="translated">Usado para especificar uma classe base ou interface base.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInline">
        <source>Used to indicate a function that should be integrated directly into the caller's code.</source>
        <target state="translated">Usado para indicar a função que deve ser integrada diretamente no código do chamador.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInterface">
        <source>Used to declare and implement interfaces.</source>
        <target state="translated">Usado para declarar e implementar interfaces.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInternal">
        <source>Used to specify that a member is visible inside an assembly but not outside it.</source>
        <target state="translated">Usado para especificar que membro está visível dentro de um assembly, mas não fora dele.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLazy">
        <source>Used to specify a computation that is to be performed only when a result is needed.</source>
        <target state="translated">Usado para especificar uma computação que deve ser executada somente quando um resultado é necessário.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLet">
        <source>Used to associate, or bind, a name to a value or function.</source>
        <target state="translated">Usado para associar um nome para uma função ou valor.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLetBang">
        <source>Used in computation expressions to bind a name to the result of another computation expression.</source>
        <target state="translated">Usado em expressões de computação para associar um nome ao resultado de outra expressão de computação.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatch">
        <source>Used to branch by comparing a value to a pattern.</source>
        <target state="translated">Usado para ramificar ao comparar um valor a um padrão.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMember">
        <source>Used to declare a property or method in an object type.</source>
        <target state="translated">Usado para declarar uma propriedade ou método em um tipo de objeto.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionModule">
        <source>Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</source>
        <target state="translated">Usado para associar um nome com um grupo de tipos, valores e funções relacionados para separá-lo de outro código.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMutable">
        <source>Used to declare a variable, that is, a value that can be changed.</source>
        <target state="translated">Usado para declarar uma variável, ou seja, um valor que pode ser alterado.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNamespace">
        <source>Used to associate a name with a group of related types and modules, to logically separate it from other code.</source>
        <target state="translated">Usado para associar um nome com um grupo de tipos e módulos relacionados, para separá-lo logicamente de outro código.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNew">
        <source>Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.</source>
        <target state="translated">Usado para declarar, definir ou invocar um construtor que cria ou que pode criar um objeto. Também usado em restrições de parâmetro genérico para indicar que um tipo deve ter um certo construtor.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNot">
        <source>Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</source>
        <target state="translated">Não é uma palavra-chave real. No entanto, o "not struct" em combinação é usado como uma restrição de parâmetro genérico.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNull">
        <source>Indicates the absence of an object. Also used in generic parameter constraints.</source>
        <target state="translated">Indica a ausência de um objeto. Também usado em restrições de parâmetros genéricos.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOf">
        <source>Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</source>
        <target state="translated">Usado em uniões discriminadas para indicar o tipo de categorias de valores e nas declarações de delegado e exceção.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOpen">
        <source>Used to make the contents of a namespace or module available without qualification.</source>
        <target state="translated">Usado para disponibilizar o conteúdo de um namespace ou módulo sem qualificação.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOr">
        <source>Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.</source>
        <target state="translated">Usado com condições Boolianas como um Booliano ou operador. Equivalente a ||. Também usado em restrições de membro.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOverride">
        <source>Used to implement a version of an abstract or virtual method that differs from the base version.</source>
        <target state="translated">Usado para implantar uma versão de um resumo ou método virtual que difere da versão de base.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPrivate">
        <source>Restricts access to a member to code in the same type or module.</source>
        <target state="translated">Restringe o acesso a um membro para codificar no mesmo tipo ou módulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPublic">
        <source>Allows access to a member from outside the type.</source>
        <target state="translated">Permite acesso a um membro de fora do tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRec">
        <source>Used to indicate that a function is recursive.</source>
        <target state="translated">Usado para indicar que uma função é recursiva.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturn">
        <source>Used to provide a value for the result of the containing computation expression.</source>
        <target state="translated">Usado para fornecer um valor para o resultado da expressão de computação que a contém.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturnBang">
        <source>Used to provide a value for the result of the containing computation expression, where that value itself comes from the result another computation expression.</source>
        <target state="translated">Usado para fornecer um valor para o resultado da expressão de computação contida, em que esse próprio valor vem do resultado da expressão de computação que a contém.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionSelect">
        <source>Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</source>
        <target state="translated">Usado em expressões de consulta para especificar quais campos ou colunas extrair. Observe que isso é uma palavra-chave contextual, o que significa que não é realmente uma palavra reservada e age apenas como uma palavra-chave no contexto apropriado.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStatic">
        <source>Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</source>
        <target state="translated">Usado para indicar um método ou propriedade que podem ser chamados sem uma instância de um tipo ou um membro de valor que é compartilhado entre todas as instâncias de um tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStruct">
        <source>Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions.</source>
        <target state="translated">Usado para declarar um tipo de estrutura. Também usado nas restrições de parâmetro genérico. Usado para compatibilidade OCaml nas definições do módulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionThen">
        <source>Used in conditional expressions. Also used to perform side effects after object construction.</source>
        <target state="translated">Usado em expressões condicionais. Também usado para desempenhar efeitos colaterais depois de construção de objeto.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTo">
        <source>Used in for loops to indicate a range.</source>
        <target state="translated">Usado em loops para indicar um intervalo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTry">
        <source>Used to introduce a block of code that might generate an exception. Used together with with or finally.</source>
        <target state="translated">Usado para introduzir um bloco de código que pode gerar uma exceção. Usado junto com with ou finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionType">
        <source>Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</source>
        <target state="translated">Usado para declarar uma classe, registro, estrutura, união discriminada, tipo de enumeração, unidade de medida ou abreviação de tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUpcast">
        <source>Used to convert to a type that is higher in the inheritance chain.</source>
        <target state="translated">Usada para converter para um tipo que é superior na cadeia de herança.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUse">
        <source>Used instead of let for values that implement IDisposable</source>
        <target state="needs-review-translation">Usado ao invés de let para valores que necessitam que Dispose seja chamado para liberar recursos.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUseBang">
        <source>Used instead of let! in computation expressions for computation expression results that implement IDisposable.</source>
        <target state="translated">Usado em vez de let! em expressões de computação para resultados de expressão de computação que implementam IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVal">
        <source>Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</source>
        <target state="translated">Usado em uma assinatura para indicar um valor ou em um tipo para declarar um membro em situações limitadas.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVoid">
        <source>Indicates the .NET void type. Used when interoperating with other .NET languages.</source>
        <target state="translated">Indica o tipo void .NET. Usado ao interoperar com outras linguagens .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhen">
        <source>Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.</source>
        <target state="translated">Usado para condições boolianas (when guards) em correspondências de padrão e para introduzir uma cláusula de restrição para um parâmetro de tipo genérico.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhile">
        <source>Introduces a looping construct.</source>
        <target state="translated">Apresenta um constructo de looping.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWith">
        <source>Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</source>
        <target state="translated">Usado em conjunto com a palavra-chave correspondente em expressões de correspondência de padrão. Também usado em expressões de objeto, expressões de cópia de registros e extensões de tipo para apresentar as definições de membro e introduzir os manipuladores de exceção.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYield">
        <source>Used in a sequence expression to produce a value for a sequence.</source>
        <target state="translated">Usado em uma expressão de sequência para produzir um valor de uma sequência.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYieldBang">
        <source>Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</source>
        <target state="translated">Usado em uma expressão de computação para acrescentar ao resultado de uma expressão de computação fornecida a uma coleção de resultados para a expressão de computação que a contém.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRightArrow">
        <source>In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions</source>
        <target state="translated">Em tipos de função, delimita argumentos e valores retornados. Produz uma expressão (em expressões de sequência); equivalente à palavra-chave de rendimento. Usado em expressões de correspondência</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLeftArrow">
        <source>Assigns a value to a variable.</source>
        <target state="translated">Atribui um valor a uma variável.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionCast">
        <source>Converts a type to type that is higher in the hierarchy.</source>
        <target state="translated">Converte um tipo em um tipo em posição superior na hierarquia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDynamicCast">
        <source>Converts a type to a type that is lower in the hierarchy.</source>
        <target state="translated">Converte um tipo em um tipo em posição inferior na hierarquia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTypedQuotation">
        <source>Delimits a typed code quotation.</source>
        <target state="translated">Delimita uma citação tipada do código.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUntypedQuotation">
        <source>Delimits a untyped code quotation.</source>
        <target state="translated">Delimita uma citação não tipada do código.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundDuringDynamicCodeGen">
        <source>{0} '{1}' not found in assembly '{2}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{0} '{1}' não encontrado no assembly '{2}'. Uma possível causa seria uma incompatibilidade de versão. Talvez seja necessário fazer uma referência explicitamente à versão correta deste assembly para permitir que todos os componentes referenciados possam utilizar a versão correta.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundInTypeDuringDynamicCodeGen">
        <source>{0} '{1}' not found in type '{2}' from assembly '{3}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{0} '{1}' não encontrado no tipo '{2}' do assembly '{3}'. Uma possível causa seria uma incompatibilidade de versão. Talvez seja necessário fazer uma referência explicitamente à versão correta deste assembly para permitir que todos os componentes referenciados utilizem a versão correta.</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionWordIs">
        <source>is</source>
        <target state="translated">is</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunction">
        <source>This value is not a function and cannot be applied.</source>
        <target state="translated">Este valor não é uma função e não pode ser aplicado.</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexerWithName">
        <source>This value is not a function and cannot be applied. Did you intend to access the indexer via {0}.[index] instead?</source>
        <target state="translated">Este valor não é uma função e não pode ser aplicado. Você pretendia acessar o indexador por meio do {0}.[index] como alternativa?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexer">
        <source>This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?</source>
        <target state="translated">Esta expressão não é uma função e não pode ser aplicada. Você pretendia acessar o indexador por meio do expr.[index] como alternativa?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeDeclaration">
        <source>This value is not a function and cannot be applied. Did you forget to terminate a declaration?</source>
        <target state="translated">Este valor não é uma função e não pode ser aplicado. Você esqueceu de finalizar a declaração?</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentsInSigAndImplMismatch">
        <source>The argument names in the signature '{0}' and implementation '{1}' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling.</source>
        <target state="translated">Os nomes de argumento na assinatura '{0}' e na implementação '{1}' não coincidem. O nome do argumento do arquivo da assinatura será usado. Isso pode causar problemas durante a depuração ou a criação de perfil.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleUnexpectedNonZero">
        <source>An error occurred while reading the F# metadata of assembly '{0}'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct.</source>
        <target state="translated">Ocorreu um erro ao ler os metadados F# do assembly '{0}'. Foi utilizada um constructo reservado. Talvez seja necessário atualizar seu compilador F# ou usar uma versão anterior do assembly que não faça uso de um constructo específico.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleMemberNotNormallyUsed">
        <source>This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.</source>
        <target state="translated">Essa propriedade ou esse método normalmente não é usado no código F#. Use um padrão de tupla explícito para a desconstrução.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'.</source>
        <target state="translated">Essa expressão retorna um valor de tipo '{0}', mas é descartada de forma implícita. Considere o uso de 'let' para associar o resultado a um nome, por exemplo, 'let result = expression'. Se você pretende usar a expressão como um valor na sequência, use um “yield” explícito.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedSequenceInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'.</source>
        <target state="translated">Essa expressão retorna um valor de tipo '{0}', mas é descartada de forma implícita. Considere o uso de 'let' para associar o resultado a um nome, por exemplo, 'let result = expression'. Se você pretende usar a expressão como um valor na sequência, use um “yield!” explícito.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatchBang">
        <source>Used in computation expressions to pattern match directly over the result of another computation expression.</source>
        <target state="translated">Usado em expressões de computação para corresponder ao padrão diretamente sobre o resultado de outra expressão de computação.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilreadFileChanged">
        <source>The file '{0}' changed on disk unexpectedly, please reload.</source>
        <target state="translated">O arquivo '{0}' foi alterado no disco inesperadamente. Recarregue-o.</target>
        <note />
      </trans-unit>
      <trans-unit id="writeToReadOnlyByref">
        <source>The byref pointer is readonly, so this write is not permitted.</source>
        <target state="translated">O ponteiro byref é somente leitura. Portanto, esta gravação não é permitida.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeMutable">
        <source>A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'</source>
        <target state="translated">Um valor deve ser mutável para que seja possível mudar o conteúdo ou pegar o endereço de um tipo de valor, por exemplo: 'let mutable x = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="readOnlyAttributeOnStructWithMutableField">
        <source>A ReadOnly attribute has been applied to a struct type with a mutable field.</source>
        <target state="translated">O atributo ReadOnly foi aplicado a um tipo de struct com um campo mutável.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByrefReturnImplicitlyDereferenced">
        <source>A byref pointer returned by a function or method is implicitly dereferenced as of F# 4.5. To acquire the return value as a pointer, use the address-of operator, e.g. '&amp;f(x)' or '&amp;obj.Method(arg1, arg2)'.</source>
        <target state="translated">Um ponteiro byref retornado por uma função ou um método é implicitamente desreferenciado a partir de F# 4.5. Para adquirir o valor de retorno como um ponteiro, use o operador de endereço, por exemplo, '&amp;f(x)' ou '&amp;obj.Method(arg1, arg2)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByRefLikeNotStruct">
        <source>A type annotated with IsByRefLike must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.</source>
        <target state="translated">Um tipo anotado com IsByRefLike também deve ser um struct. Adicione o atributo [&lt;Struct&gt;] ao tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAddressOfLocal">
        <source>The address of the variable '{0}' or a related expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">O endereço da variável '{0}' ou de uma expressão relacionada não pode ser utilizado neste ponto. Isso tem como objetivo garantir que o endereço do valor local não escape de seu escopo.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoWriteToLimitedSpan">
        <source>This value can't be assigned because the target '{0}' may refer to non-stack-local memory, while the expression being assigned is assessed to potentially refer to stack-local memory. This is to help prevent pointers to stack-bound memory escaping their scope.</source>
        <target state="translated">Este valor não pode ser atribuído porque o destino '{0}' pode se referir a uma memória local não empilhada, enquanto a expressão que está sendo atribuída é avaliada para possivelmente se referir à memória local empilhada. Isso tem como objetivo ajudar a evitar que os ponteiros da memória vinculada à pilha escapem de seu escopo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeLocal">
        <source>A value defined in a module must be mutable in order to take its address, e.g. 'let mutable x = ...'</source>
        <target state="translated">O valor definido em um módulo deve ser mutável para obter seu endereço, por exemplo, 'let mutable x = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIsReadOnlyNotStruct">
        <source>A type annotated with IsReadOnly must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.</source>
        <target state="translated">Um tipo anotado com IsReadOnly também deve ser um struct. Adicione o atributo [&lt;Struct&gt;] ao tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkStructsMayNotReturnAddressesOfContents">
        <source>Struct members cannot return the address of fields of the struct by reference</source>
        <target state="translated">Os membros do struct não podem retornar o endereço dos campos do struct por referência</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefLikeFunctionCall">
        <source>The function or method call cannot be used at this point, because one argument that is a byref of a non-stack-local Span or IsByRefLike type is used with another argument that is a stack-local Span or IsByRefLike type. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">A função ou a chamada do método não pode ser utilizada neste ponto porque um argumento, que é um byref de um tipo Span ou IsByRefLike local não empilhado, é utilizado com outro argumento, que é um tipo Span ou IsByRefLike local empilhado. Isso tem como objetivo garantir que o endereço do valor local não escape de seu escopo.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAddressOfValueFromExpression">
        <source>The address of a value returned from the expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">O endereço de um valor retornado da expressão não pode ser utilizado neste ponto. Isso tem como objetivo garantir que o endereço do valor local não escape de seu escopo.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoSpanLikeVariable">
        <source>The Span or IsByRefLike variable '{0}' cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">A variável '{0}' de Span ou IsByRefLike não pode ser utilizada neste ponto. Isso tem como objetivo garantir que o endereço do valor local não escape de seu escopo.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoSpanLikeValueFromExpression">
        <source>A Span or IsByRefLike value returned from the expression cannot be used at ths point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">O valor Span ou IsByRefLike retornado da expressão não pode ser utilizado neste ponto. Isso tem como objetivo garantir que o endereço do valor local não escape de seu escopo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastCantTakeAddressOfExpression">
        <source>Cannot take the address of the value returned from the expression. Assign the returned value to a let-bound value before taking the address.</source>
        <target state="translated">Não é possível obter o endereço do valor retornado da expressão. Atribua o valor retornado a um valor associado a let antes de obter o endereço.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBraceBar">
        <source>Unmatched '{{|'</source>
        <target state="translated">'{{|' incompatível</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoAnonRecdField">
        <source>anonymous record field</source>
        <target state="translated">campo de registro anônimo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionConstructorDoesNotHaveFieldWithGivenName">
        <source>The exception '{0}' does not have a field named '{1}'.</source>
        <target state="translated">A exceção '{0}' não tem um campo nomeado '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcActivePatternsDoNotHaveFields">
        <source>Active patterns do not have fields. This syntax is invalid.</source>
        <target state="translated">Padrões ativos não têm campos. Essa sintaxe é inválida.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorDoesNotHaveFieldWithGivenName">
        <source>The constructor does not have a field named '{0}'.</source>
        <target state="translated">O construtor não tem um campo nomeado '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdCcuMismatch">
        <source>Two anonymous record types are from different assemblies '{0}' and '{1}'</source>
        <target state="translated">Dois tipos de registro anônimos são de diferentes assemblies '{0}' e '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameMismatch">
        <source>Two anonymous record types have mismatched sets of field names '{0}' and '{1}'</source>
        <target state="translated">Dois tipos de registro anônimos têm conjuntos incompatíveis de nomes de campos '{0}' e '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallExtensionMethodInrefToByref">
        <source>Cannot call the byref extension method '{0}. The first parameter requires the value to be mutable or a non-readonly byref type.</source>
        <target state="translated">Não é possível chamar o método de extensão de byref '{0}. O primeiro parâmetro requer que o valor seja mutável ou não seja byref somente leitura.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByrefsMayNotHaveTypeExtensions">
        <source>Byref types are not allowed to have optional type extensions.</source>
        <target state="translated">Tipos de ByRef não podem ter extensões de tipo opcionais.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotPartiallyApplyExtensionMethodForByref">
        <source>Cannot partially apply the extension method '{0}' because the first parameter is a byref type.</source>
        <target state="translated">Não é possível aplicar parcialmente o método de extensão '{0}' porque o primeiro parâmetro é um tipo de byref.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDoesNotInheritAttribute">
        <source>This type does not inherit Attribute, it will not work correctly with other .NET languages.</source>
        <target state="translated">Este tipo não herda atributo, ele não funcionará corretamente com outras linguagens .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidAnonRecdExpr">
        <source>Invalid anonymous record expression</source>
        <target state="translated">Expressão de registro anônimo inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidAnonRecdType">
        <source>Invalid anonymous record type</source>
        <target state="translated">Tipo de registro anônimo inválido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCopyAndUpdateNeedsRecordType">
        <source>The input to a copy-and-update expression that creates an anonymous record must be either an anonymous record or a record</source>
        <target state="translated">A entrada para uma expressão de copiar-e-atualizar que cria um registro anônimo deve ser um registro ou um registro anônimo</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidFunctionParameterType">
        <source>The parameter '{0}' has an invalid type '{1}'. This is not permitted by the rules of Common IL.</source>
        <target state="translated">O parâmetro '{0}' tem um tipo inválido '{1}'. Isso não é permitido pelas regras do IL comum.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidFunctionReturnType">
        <source>The function or method has an invalid return type '{0}'. This is not permitted by the rules of Common IL.</source>
        <target state="translated">A função ou método tem um tipo de retorno inválido '{0}'. Isso não é permitido pelas regras do IL Comum.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveral">
        <source>No implementation was given for those members: {0}</source>
        <target state="new">No implementation was given for those members: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralWithSuggestion">
        <source>No implementation was given for those members: {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="new">No implementation was given for those members: {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralTruncated">
        <source>No implementation was given for those members (some results omitted): {0}</source>
        <target state="new">No implementation was given for those members (some results omitted): {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralTruncatedWithSuggestion">
        <source>No implementation was given for those members (some results omitted): {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="new">No implementation was given for those members (some results omitted): {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPathMap">
        <source>Maps physical paths to source path names output by the compiler</source>
        <target state="new">Maps physical paths to source path names output by the compiler</target>
        <note />
      </trans-unit>
      <trans-unit id="fscPathMapDebugRequiresPortablePdb">
        <source>--pathmap can only be used with portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="new">--pathmap can only be used with portable PDBs (--debug:portable or --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidPathMapFormat">
        <source>Invalid path map. Mappings must be comma separated and of the format 'path=sourcePath'</source>
        <target state="new">Invalid path map. Mappings must be comma separated and of the format 'path=sourcePath'</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>