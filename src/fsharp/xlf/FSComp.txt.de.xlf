<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="de" original="../FSComp.resx">
    <body>
      <trans-unit id="undefinedNameNamespace">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">Der Namespace "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespaceOrModule">
        <source>The namespace or module '{0}' is not defined.</source>
        <target state="translated">Der Namespace oder das Modul "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMember">
        <source>The field, constructor or member '{0}' is not defined.</source>
        <target state="translated">Das Feld, der Konstruktor oder der Member "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueConstructorNamespaceOrType">
        <source>The value, constructor, namespace or type '{0}' is not defined.</source>
        <target state="translated">Der Wert, Konstruktor, Namespace oder Typ "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueOfConstructor">
        <source>The value or constructor '{0}' is not defined.</source>
        <target state="translated">Der Wert oder Konstruktor "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueNamespaceTypeOrModule">
        <source>The value, namespace, type or module '{0}' is not defined.</source>
        <target state="translated">Der Wert, Namespace, Typ oder das Modul "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameConstructorModuleOrNamespace">
        <source>The constructor, module or namespace '{0}' is not defined.</source>
        <target state="translated">Der Konstruktor, das Modul oder der Namespace "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameType">
        <source>The type '{0}' is not defined.</source>
        <target state="translated">Der Typ "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeIn">
        <source>The type '{0}' is not defined in '{1}'.</source>
        <target state="translated">Der Typ "{0}" ist nicht in "{1}" definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabelOrNamespace">
        <source>The record label or namespace '{0}' is not defined.</source>
        <target state="translated">Die Datensatzbezeichnung oder der Namespace "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabel">
        <source>The record label '{0}' is not defined.</source>
        <target state="translated">Die Datensatzbezeichnung "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameSuggestionsIntro">
        <source>Maybe you want one of the following:</source>
        <target state="translated">Vielleicht möchten Sie eine der folgenden Bezeichnungen verwenden:</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeParameter">
        <source>The type parameter {0} is not defined.</source>
        <target state="translated">Der Typparameter "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNamePatternDiscriminator">
        <source>The pattern discriminator '{0}' is not defined.</source>
        <target state="translated">Der Musterdiskriminator "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="replaceWithSuggestion">
        <source>Replace with '{0}'</source>
        <target state="translated">Durch "{0}" ersetzen</target>
        <note />
      </trans-unit>
      <trans-unit id="addIndexerDot">
        <source>Add . for indexer access.</source>
        <target state="translated">Fügen Sie . für Indexerzugriff hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="listElementHasWrongType">
        <source>All elements of a list constructor expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</source>
        <target state="translated">Alle Elemente eines Listenkonstruktorausdrucks müssen den gleichen Typ aufweisen. Es wurde erwartet, dass dieser Ausdruck den Typ "{0}" aufweist, hier liegt aber der Typ "{1}" vor.</target>
        <note />
      </trans-unit>
      <trans-unit id="arrayElementHasWrongType">
        <source>All elements of an array constructor expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</source>
        <target state="translated">Alle Elemente eines Arraykonstruktorausdrucks müssen den gleichen Typ aufweisen. Es wurde erwartet, dass dieser Ausdruck den Typ "{0}" aufweist, hier liegt aber der Typ "{1}" vor.</target>
        <note />
      </trans-unit>
      <trans-unit id="missingElseBranch">
        <source>The 'if' expression is missing an 'else' branch. The 'then' branch has type '{0}'. Because 'if' is an expression, and not a statement, add an 'else' branch which returns a value of the same type.</source>
        <target state="translated">Dem if-Ausdruck fehlt ein else-Branch. Der then-Branch weist den Typ "{0}" auf. Da "if" ein Ausdruck und keine Anweisung ist, fügen Sie einen else-Branch hinzu, der einen Wert des gleichen Typs zurückgibt.</target>
        <note />
      </trans-unit>
      <trans-unit id="ifExpression">
        <source>The 'if' expression needs to have type '{0}' to satisfy context type requirements. It currently has type '{1}'.</source>
        <target state="translated">Der if-Ausdruck muss Typ "{0}" aufweisen, damit die Kontexttypanforderungen erfüllt sind. Derzeit weist er Typ "{1}" auf.</target>
        <note />
      </trans-unit>
      <trans-unit id="elseBranchHasWrongType">
        <source>All branches of an 'if' expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</source>
        <target state="translated">Alle Branches eines if-Ausdrucks müssen den gleichen Typ aufweisen. Es wurde erwartet, dass dieser Ausdruck den Typ "{0}" aufweist, hier liegt aber der Typ "{1}" vor.</target>
        <note />
      </trans-unit>
      <trans-unit id="followingPatternMatchClauseHasWrongType">
        <source>All branches of a pattern match expression must return values of the same type. The first branch returned a value of type '{0}', but this branch returned a value of type '{1}'.</source>
        <target state="needs-review-translation">Alle Branches eines Musterabgleichsausdrucks müssen den gleichen Typ aufweisen. Es wurde erwartet, dass dieser Ausdruck den Typ "{0}" aufweist, hier liegt aber der Typ "{1}" vor.</target>
        <note />
      </trans-unit>
      <trans-unit id="patternMatchGuardIsNotBool">
        <source>A pattern match guard must be of type 'bool', but this 'when' expression is of type '{0}'.</source>
        <target state="translated">Ein Musterübereinstimmungswächter muss den Typ "bool" aufweisen, dieser when-Ausdruck hat hingegen den Typ "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="commaInsteadOfSemicolonInRecord">
        <source>A ';' is used to separate field values in records. Consider replacing ',' with ';'.</source>
        <target state="translated">Das Zeichen ";" wird verwendet, um Feldwerte in Datensätzen zu trennen. Ersetzen Sie "," ggf. durch ";".</target>
        <note />
      </trans-unit>
      <trans-unit id="derefInsteadOfNot">
        <source>The '!' operator is used to dereference a ref cell. Consider using 'not expr' here.</source>
        <target state="translated">Der Operator "!" wird zum Dereferenzieren einer Verweiszelle verwendet. Verwenden Sie hier ggf. "not expr".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedTypeArgs">
        <source>The non-generic type '{0}' does not expect any type arguments, but here is given {1} type argument(s)</source>
        <target state="translated">Der nicht generische Typ "{0}" erwartet keine Typargumente; hier wird/werden jedoch {1} Typargument(e) übergeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="returnUsedInsteadOfReturnBang">
        <source>Consider using 'return!' instead of 'return'.</source>
        <target state="translated">Verwenden Sie ggf. "return!" anstelle von "return".</target>
        <note />
      </trans-unit>
      <trans-unit id="yieldUsedInsteadOfYieldBang">
        <source>Consider using 'yield!' instead of 'yield'.</source>
        <target state="translated">Verwenden Sie ggf. "yield!" anstelle von "yield".</target>
        <note />
      </trans-unit>
      <trans-unit id="tupleRequiredInAbstractMethod">
        <source>\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.</source>
        <target state="translated">\nEin Tupeltyp ist für mindestens ein Argument erforderlich. Schließen Sie die angegebenen Argumente ggf. in zusätzliche Klammern ein, oder überprüfen Sie die Definition der Schnittstelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidWarningNumber">
        <source>Invalid warning number '{0}'</source>
        <target state="translated">Ungültige Warnungsnummer "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionString">
        <source>Invalid version string '{0}'</source>
        <target state="translated">Ungültige Versionszeichenfolge "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionFile">
        <source>Invalid version file '{0}'</source>
        <target state="translated">Ungültige Versionsdatei "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProductName">
        <source>Microsoft (R) F# Compiler version {0}</source>
        <target state="translated">Microsoft (R) F# Compiler, Version {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProductNameCommunity">
        <source>F# Compiler for F# {0}</source>
        <target state="translated">F# Compiler für F# {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemWithFilename">
        <source>Problem with filename '{0}': {1}</source>
        <target state="translated">Problem mit Dateinamen "{0}": {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildNoInputsSpecified">
        <source>No inputs specified</source>
        <target state="translated">Keine Eingaben angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildPdbRequiresDebug">
        <source>The '--pdb' option requires the '--debug' option to be used</source>
        <target state="translated">Die Option "--pdb" macht die Verwendung der Option "--debug" erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSearchDirectory">
        <source>The search directory '{0}' is invalid</source>
        <target state="translated">Das Suchverzeichnis "{0}" ist ungültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSearchDirectoryNotFound">
        <source>The search directory '{0}' could not be found</source>
        <target state="translated">Das Suchverzeichnis "{0}" wurde nicht gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidFilename">
        <source>'{0}' is not a valid filename</source>
        <target state="translated">{0} ist kein gültiger Dateiname.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidAssemblyName">
        <source>'{0}' is not a valid assembly name</source>
        <target state="translated">{0} ist kein gültiger Assemblyname.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidPrivacy">
        <source>Unrecognized privacy setting '{0}' for managed resource, valid options are 'public' and 'private'</source>
        <target state="translated">Unbekannte Datenschutzeinstellung "{0}" für verwaltete Ressource; gültige Optionen sind "public" und "private".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleReferencesNotAllowed">
        <source>Multiple references to '{0}.dll' are not permitted</source>
        <target state="translated">Mehrere Verweise auf "{0}.dll" sind nicht zulässig</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotReadVersionInfoFromMscorlib">
        <source>Could not read version from mscorlib.dll</source>
        <target state="translated">Version konnte nicht aus "mscorlib.dll" gelesen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCannotReadAssembly">
        <source>Unable to read assembly '{0}'</source>
        <target state="translated">Assembly "{0}" kann nicht gelesen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildAssemblyResolutionFailed">
        <source>Assembly resolution failure at or near this location</source>
        <target state="translated">Fehler bei Assemblyauflösung an dieser Position oder in ihrer Nähe.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplicitModuleIsNotLegalIdentifier">
        <source>The declarations in this file will be placed in an implicit module '{0}' based on the file name '{1}'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file.</source>
        <target state="translated">Die Deklarationen in dieser Datei werden anhand des Dateinamens "{1}" im impliziten Modul "{0}" platziert. Dies ist jedoch kein gültiger F#-Bezeichner, sodass von anderen Dateien aus kein Zugriff auf die Inhalte möglich ist. Benennen Sie die Datei um, oder fügen Sie oben in der Datei eine module- oder namespace-Deklaration hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultiFileRequiresNamespaceOrModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration.</source>
        <target state="translated">Dateien in Bibliotheken oder Anwendungen mit mehreren Dateien müssen mit einer Namespace- oder Moduldeklaration beginnen. Beispiel: "namespace SomeNamespace.SubNamespace" oder "module SomeNamespace.SomeModule". Nur in der letzten Quelldatei einer Anwendung darf eine solche Deklaration ausgelassen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="noEqualSignAfterModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.</source>
        <target state="translated">Dateien in Bibliotheken oder Anwendungen mit mehreren Dateien müssen mit einem Namespace oder einer Moduldeklaration beginnen. Wenn eine Moduldeklaration am Anfang einer Datei verwendet wird, ist das Zeichen "=" unzulässig. Wenn es sich um ein Modul der obersten Ebene handelt, sollten Sie ggf. das Zeichen "=" entfernen, um diesen Fehler zu beheben.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleToplevelModules">
        <source>This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules.</source>
        <target state="translated">Diese Datei enthält mehrere Deklarationen im Format "module SomeNamespace.SomeModule". Pro Datei ist nur eine Deklaration in diesem Format zulässig. Verwenden Sie eine Namespacedeklaration am Dateianfang und/oder "module ModuleName = ..." zur Definition der Module.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildOptionRequiresParameter">
        <source>Option requires parameter: {0}</source>
        <target state="translated">Option erfordert einen Parameter: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotFindSourceFile">
        <source>Source file '{0}' could not be found</source>
        <target state="translated">Quelldatei "{0}" wurde nicht gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSourceFileExtension">
        <source>The file extension of '{0}' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.</source>
        <target state="translated">Die Dateierweiterung "{0}" wurde nicht erkannt. Quelldateien müssen die Erweiterung .fs, .fsi, .fsx, .fsscript, .ml oder .mli haben.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssembly">
        <source>Could not resolve assembly '{0}'</source>
        <target state="translated">Assembly "{0}" konnte nicht aufgelöst werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssemblyRequiredByFile">
        <source>Could not resolve assembly '{0}' required by '{1}'</source>
        <target state="translated">Die für "{1}" erforderliche Assembly "{0}" konnte nicht aufgelöst werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildErrorOpeningBinaryFile">
        <source>Error opening binary file '{0}': {1}</source>
        <target state="translated">Fehler beim Öffnen der Binärdatei "{0}": {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDifferentVersionMustRecompile">
        <source>The F#-compiled DLL '{0}' needs to be recompiled to be used with this version of F#</source>
        <target state="translated">Die kompilierte F#-DLL "{0}" muss erneut kompiliert werden, damit sie mit dieser Version von F# verwendet werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashIDirective">
        <source>Invalid directive. Expected '#I \"&lt;path&gt;\"'.</source>
        <target state="translated">Ungültige Direktive. Erwartet wurde "#I \"&lt;Pfad&gt;\"".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashrDirective">
        <source>Invalid directive. Expected '#r \"&lt;file-or-assembly&gt;\"'.</source>
        <target state="translated">Ungültige Direktive. Erwartet wurde "#r \"&lt;Datei-oder-Assembly&gt;\"".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashloadDirective">
        <source>Invalid directive. Expected '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</source>
        <target state="translated">Ungültige Direktive. Erwartet wurde "#load \"&lt;Datei&gt;\" ... \"&lt;Datei&gt;\"".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashtimeDirective">
        <source>Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'.</source>
        <target state="translated">Ungültige Direktive. Erwartet wurde "#time", "#time \"on\"" oder '#time \"off\"".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDirectivesInModulesAreIgnored">
        <source>Directives inside modules are ignored</source>
        <target state="translated">Direktiven innerhalb von Modulen werden ignoriert.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureAlreadySpecified">
        <source>A signature for the file or module '{0}' has already been specified</source>
        <target state="translated">Für Datei oder Modul "{0}" wurde bereits eine Signatur angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGivenDetail">
        <source>An implementation of file or module '{0}' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.</source>
        <target state="translated">Eine Implementierung der Datei oder des Moduls "{0}" wurde bereits angegeben. Die Kompilierungsreihenfolge ist in F# aufgrund des Typrückschlusses von Bedeutung. Möglicherweise müssen Sie die Reihenfolge der Dateien anpassen, um die Signaturdatei vor der Implementierung zu platzieren. In Visual Studio erfolgt die Typprüfung der Dateien in der Reihenfolge, in der sie in der Projektdatei aufgeführt sind; diese kann manuell bearbeitet oder im Projektmappen-Explorer angepasst werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGiven">
        <source>An implementation of the file or module '{0}' has already been given</source>
        <target state="translated">Eine Implementierung der Datei oder des Moduls "{0}" wurde bereits angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureWithoutImplementation">
        <source>The signature file '{0}' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match.</source>
        <target state="translated">Für die Signaturdatei "{0}" ist keine entsprechende Implementierungsdatei vorhanden. Falls eine Implementierungsdatei existiert, stellen Sie sicher, dass die module- und namespace-Deklarationen in der Signatur- und der Implementierungsdatei übereinstimmen.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidInt">
        <source>'{0}' is not a valid integer argument</source>
        <target state="translated">{0} ist kein gültiges Integer-Argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidFloat">
        <source>'{0}' is not a valid floating point argument</source>
        <target state="translated">{0} ist kein gültiges Gleitkommaargument.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnrecognizedOption">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">Unbekannte Option: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidModuleOrNamespaceName">
        <source>Invalid module or namespace name</source>
        <target state="translated">Ungültiger Modul- oder Namespacename.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleErrorReadingWritingMetadata">
        <source>Error reading/writing metadata for the F# compiled DLL '{0}'. Was the DLL compiled with an earlier version of the F# compiler? (error: '{1}').</source>
        <target state="translated">Fehler beim Lesen/Schreiben von Metadaten für die kompilierte F#-DLL "{0}". Wurde die DLL mit einer früheren Version des F#-Compilers kompiliert? (Fehler: "{1}").</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeOrModuleNotConcrete">
        <source>The type/module '{0}' is not a concrete module or type</source>
        <target state="translated">Der Typ bzw. das Modul "{0}" ist kein konkretes Modul bzw. kein konkreter Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeHasAssemblyCodeRepresentation">
        <source>The type '{0}' has an inline assembly code representation</source>
        <target state="translated">Der Typ "{0}" besitzt eine Inlineassembly-Codedarstellung.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNamespaceAndModuleWithSameNameInAssembly">
        <source>A namespace and a module named '{0}' both occur in two parts of this assembly</source>
        <target state="translated">Ein Namespace und ein Modul namens "{0}" sind beide in zwei Teilen dieser Assembly vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTwoModulesWithSameNameInAssembly">
        <source>Two modules named '{0}' occur in two parts of this assembly</source>
        <target state="translated">Zwei Module namens "{0}" treten in zwei Teilen dieser Assembly auf.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastDuplicateTypeDefinitionInAssembly">
        <source>Two type definitions named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">Zwei Typdefinitionen namens "{0}" erscheinen im Namespace "{1}" in zwei Teilen dieser Assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConflictingModuleAndTypeDefinitionInAssembly">
        <source>A module and a type definition named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">Ein Modul und eine Typdefinition namens "{0}" erscheinen im Namespace "{1}" in zwei Teilen dieser Assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMemberSignature">
        <source>Invalid member signature encountered because of an earlier error</source>
        <target state="translated">Ungültige Membersignatur aufgrund eines früheren Fehlers.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueDoesNotHaveSetterType">
        <source>This value does not have a valid property setter type</source>
        <target state="translated">Für diesen Wert ist kein gültiger Eigenschaftensettertyp vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertyGetter">
        <source>Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax.</source>
        <target state="translated">Ungültiges Format für einen Eigenschaftengetter. Mindestens ein ()-Argument ist bei Verwendung der expliziten Syntax erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertySetter">
        <source>Invalid form for a property setter. At least one argument is required.</source>
        <target state="translated">Ungültiges Format für einen Eigenschaftensetter. Mindestens ein Argument ist erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedByRef">
        <source>Unexpected use of a byref-typed variable</source>
        <target state="translated">Unerwartete Verwendung einer Variablen vom Typ "byref".</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeMutable">
        <source>A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'</source>
        <target state="translated">Ein Wert muss änderbar sein, um die Inhalte eines Werttyps zu mutieren oder seine Adresse zu übernehmen, z.B. "let mutable x = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMutationOfConstant">
        <source>Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'.</source>
        <target state="translated">Ungültige Mutation eines konstanten Ausdrucks. Kopieren Sie den Ausdruck in eine änderbare lokale Variable, z.B. "let mutable x = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueHasBeenCopied">
        <source>The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed</source>
        <target state="translated">Dieser Wert wurde kopiert, damit das Original von diesem Vorgang nicht verändert wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeInConstructionOfTuple">
        <source>Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding</source>
        <target state="translated">Rekursiv definierte Werte können nicht direkt als Teil der Konstruktion eines Tupelwerts innerhalb einer rekursiven Bindung auftreten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotAppearInConstructionOfType">
        <source>Recursive values cannot appear directly as a construction of the type '{0}' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.</source>
        <target state="translated">Rekursive Werte können nicht direkt als Konstruktion vom Typ "{0}" innerhalb einer rekursiven Bindung auftreten. Diese Funktion wurde aus der Programmiersprache F# entfernt. Verwenden Sie stattdessen einen Datensatz.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeAssignedToNonMutableField">
        <source>Recursive values cannot be directly assigned to the non-mutable field '{0}' of the type '{1}' within a recursive binding. Consider using a mutable field instead.</source>
        <target state="translated">Rekursive Werte können dem nicht änderbaren Feld "{0}" vom Typ "{1}" innerhalb einer rekursiven Bindung nicht direkt zugewiesen werden. Verwenden Sie stattdessen ein änderbares Feld.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfAutoOpenAttribute">
        <source>Unexpected decode of AutoOpenAttribute</source>
        <target state="translated">Unerwartete Decodierung von AutoOpenAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInternalsVisibleToAttribute">
        <source>Unexpected decode of InternalsVisibleToAttribute</source>
        <target state="translated">Unerwartete Decodierung von InternalsVisibleToAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
        <source>Unexpected decode of InterfaceDataVersionAttribute</source>
        <target state="translated">Unerwartete Decodierung von InterfaceDataVersionAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastActivePatternsLimitedToSeven">
        <source>Active patterns cannot return more than 7 possibilities</source>
        <target state="translated">Aktive Muster können maximal 7 Möglichkeiten zurückgeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNotAConstantExpression">
        <source>This is not a valid constant expression or custom attribute value</source>
        <target state="translated">Dies ist kein gültiger konstanter Ausdruck oder benutzerdefinierter Attributwert.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAttributesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe mutability attributes differ</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Änderbarkeitsattribute sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe names differ</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Namen sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityCompiledNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled names differ</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1},    \n doch die Signatur gibt\n    {2}    an.\nDie kompilierten Namen unterscheiden sich</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDisplayNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe display names differ</source>
        <target state="translated">Modul "{0}" enthält\n    {1},    \ndoch die Signatur gibt\n    {2}    an.\nDie Anzeigenamen unterscheiden sich</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAccessibilityMore">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nIn der Signatur ist eine höhere Zugreifbarkeit angegeben als in der Implementierung.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInlineFlagsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe inline flags differ</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie inline-Flags sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityLiteralConstantValuesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe literal constant values and/or attributes differ</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Werte und/oder Attribute der literalen Konstanten sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsTypeFunction">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine Angabe ist eine Typfunktion, die andere nicht. Die Signatur erfordert explizite Typparameter, falls diese in der Implementierung vorhanden sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityParameterCountsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe respective type parameter counts differ</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Anzahl der entsprechenden Typparameter ist unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityTypesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe types differ</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Typen sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityExtensionsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is an extension member and the other is not</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine Angabe ist ein Erweiterungsmember, die andere nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityArityNotInferred">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nAn arity was not inferred for this value</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nFür diesen Wert wurde keine Stelligkeit per Rückschluss abgeleitet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe number of generic parameters in the signature and implementation differ (the signature declares {3} but the implementation declares {4}</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Anzahl der generischen Parameter in der Signatur und in der Implementierung ist unterschiedlich (in der Signatur werden {3} deklariert, in der Implementierung {4}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersAreDifferentKinds">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie generischen Parameter in der Signatur und in der Implementierung haben einen unterschiedlichen Typ. Möglicherweise fehlt ein [&lt;Measure&gt;]-Attribut.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAritiesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe arities in the signature and implementation differ. The signature specifies that '{3}' is function definition or lambda expression accepting at least {4} argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int.</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Stelligkeit in der Signatur und in der Implementierung ist unterschiedlich. Laut Signatur ist "{3}" eine Funktionsdefinition oder ein lambda-Ausdruck, die bzw. der mindestens {4} Argument(e) akzeptiert, bei der Implementierung handelt es sich allerdings um einen berechneten Funktionswert. Um einen berechneten Funktionswert als zulässige Implementierung zu deklarieren, setzen Sie den Typ in der Signatur einfach in Klammern, z.B.\n\tval {5}: int -&gt; (int -&gt; int)\nanstatt\n\tval {6}: int -&gt; int -&gt; int.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDotNetNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe CLI member names differ</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie CLI-Membernamen sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is static and the other isn't</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine statische Angabe steht einer nicht statischen gegenüber.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityVirtualsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is virtual and the other isn't</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine virtuelle Angabe steht einer nicht virtuellen gegenüber.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAbstractsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is abstract and the other isn't</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine abstrakte Angabe steht einer nicht abstrakten gegenüber.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityFinalsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is final and the other isn't</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine finale Angabe steht einer nicht finalen gegenüber.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOverridesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is marked as an override and the other isn't</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine Angabe ist als Überschreibung markiert, die andere nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsConstructor">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a constructor/property and the other is not</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine Angabe ist ein Konstruktor bzw. eine Eigenschaft, die andere nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticButInstance">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie kompilierte Darstellung dieser Methode ist ein statischer Member, laut Signatur ist sie aber eine kompilierte Darstellung als Instanzmember.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInstanceButStatic">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member</source>
        <target state="translated">Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie kompilierte Darstellung dieser Methode ist ein Instanzmember, laut Signatur ist sie aber eine kompilierte Darstellung als statischer Member.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNamesDiffer">
        <source>The {0} definitions in the signature and implementation are not compatible because the names differ. The type is called '{1}' in the signature file but '{2}' in implementation.</source>
        <target state="translated">Die {0} Definitionen in der Signatur und in der Implementierung sind nicht kompatibel, weil die Namen unterschiedlich sind. Der Typ heißt "{1}" in der Signaturdatei, aber "{2}" in der Implementierung.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Anzahl der entsprechenden Typparameter unterschiedlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil in der Signatur eine höhere Zugreifbarkeit angegeben ist als in der Implementierung.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleMissingInterface">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature requires that the type supports the interface {2} but the interface has not been implemented</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Signatur erfordert, dass der Typ die {2}-Schnittstelle unterstützt; diese Schnittstelle ist aber nicht implementiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil dieser Typ laut Implementierung NULL als Darstellung verwenden darf, laut Signatur aber nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil dieser Typ laut Implementierung NULL als zusätzlichen Wert verwenden darf, laut Signatur aber nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil dieser Typ laut Signatur NULL als Darstellung verwenden darf, laut Implementierung aber nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil dieser Typ laut Signatur NULL als zusätzlichen Wert verwenden darf, laut Implementierung aber nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil der Implementierungstyp versiegelt ist, laut Signatur aber nicht versiegelt sein sollte. Fügen Sie der Signatur ggf. das [&lt;Sealed&gt;]-Attribut hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil der Implementierungstyp nicht versiegelt ist, laut Signatur aber versiegelt sein sollte. Fügen Sie der Implementierung ggf. das [&lt;Sealed&gt;]-Attribut hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil es sich bei der Implementierung um eine abstrakte Klasse handelt, bei der Signatur hingegen nicht. Fügen Sie der Signatur ggf. das [&lt;AbstractClass&gt;]-Attribut hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil es sich bei der Signatur um eine abstrakte Klasse handelt, bei der Implementierung hingegen nicht. Fügen Sie der Implementierung ggf. das [&lt;AbstractClass&gt;]-Attribut hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types have different base types</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Typen unterschiedliche Basistypen aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNumbersDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the number of {2}s differ</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die {2}-Anzahl unterschiedlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature defines the {2} '{3}' but the implementation does not (or does, but not in the same order)</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil in der Signatur {2} "{3}" definiert ist, in der Implementierung aber nicht (oder nicht in der gleichen Reihenfolge).</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines the {2} '{3}' but the signature does not (or does, but not in the same order)</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil in der Implementierung {2} "{3}" definiert ist, in der Signatur aber nicht (oder nicht in der gleichen Reihenfolge).</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil in der Implementierung eine Struktur definiert ist, in der Signatur hingegen ein Typ mit einer verborgenen Darstellung.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil eine CLI-Typdarstellung von einer Signatur verdeckt wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a type representation is being hidden by a signature</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil eine Typdarstellung von einer Signatur verdeckt wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types are of different kinds</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Typen unterschiedlich sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleILDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the IL representations differ</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die IL-Darstellungen unterschiedlich sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the representations differ</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Darstellungen unterschiedlich sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldWasPresent">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was present in the implementation but not in the signature</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil das Feld "{2}" in der Implementierung vorhanden war, nicht aber in der Signatur.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Reihenfolge der Felder in der Signatur und in der Implementierung unterschiedlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was required by the signature but was not specified by the implementation</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil das Feld "{2}" für die Signatur erforderlich war, in der Implementierung aber nicht angegeben wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field '{2}' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'.</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil das Feld "{2}" in der Implementierung vorhanden war, nicht aber in der Signatur. Strukturtypen müssen jetzt ihre Felder in der Signatur für den Typ offen legen, auch wenn die Felder möglicherweise noch als "private" oder "internal" bezeichnet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was required by the signature but was not specified by the implementation</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil der abstrakte Member "{2}" für die Signatur erforderlich war, in der Implementierung aber nicht angegeben wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was present in the implementation but not in the signature</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil der abstrakte Member "{2}" in der Implementierung vorhanden war, nicht aber in der Signatur.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature declares a {2} while the implementation declares a {3}</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und Implementierung sind nicht kompatibel, weil in der Signatur "{2}", in der Implementierung hingegen "{3}" deklariert wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abbreviations differ: {2} versus {3}</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind aufgrund unterschiedlicher Abkürzungen nicht kompatibel: {2} und {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil eine Abkürzung von einer Signatur verdeckt wird. Die Abkürzung muss für andere CLI-Sprachen sichtbar sein. Sorgen Sie dafür, dass die Abkürzung in der Signatur sichtbar ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not</source>
        <target state="translated">Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Signatur eine Abkürzung enthält, die Implementierung hingegen nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButNamesDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">Das Modul enthält den Konstruktor\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie Namen sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButDataFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe respective number of data fields differ</source>
        <target state="translated">Das Modul enthält den Konstruktor\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie entsprechende Anzahl von Datenfeldern ist unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButTypesOfFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe types of the fields differ</source>
        <target state="translated">Das Modul enthält den Konstruktor\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie Typen der Felder sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButAccessibilityDiffers">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Das Modul enthält den Konstruktor\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nIn der Signatur ist eine höhere Zugreifbarkeit angegeben als in der Implementierung.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedNamesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">Das Modul enthält das Feld\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie Namen sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedAccessibilitiesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Das Modul enthält das Feld\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nIn der Signatur ist eine höhere Zugreifbarkeit angegeben als in der Implementierung.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedStaticsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'static' modifiers differ</source>
        <target state="translated">Das Modul enthält das Feld\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie static-Modifizierer sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedMutablesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'mutable' modifiers differ</source>
        <target state="translated">Das Modul enthält das Feld\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie mutable-Modifizierer sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedLiteralsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'literal' modifiers differ</source>
        <target state="translated">Das Modul enthält das Feld\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie literal-Modifizierer sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedTypesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe types differ</source>
        <target state="translated">Das Modul enthält das Feld\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie Typen sind unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveImplicitGenericInstantiation">
        <source>The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '{0}' and '{1}'. Consider using type annotations to resolve the ambiguity</source>
        <target state="translated">Die implizite Instanziierung eines generischen Konstrukts an diesem Punkt oder in dessen Umgebung konnte nicht aufgelöst werden, weil sie zu mehreren unzusammenhängenden Typen aufgelöst werden könnte, z.B. "{0}" und "{1}". Verwenden Sie Typanmerkungen, um die Mehrdeutigkeit aufzulösen.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInPrintf">
        <source>Could not resolve the ambiguity inherent in the use of a 'printf'-style format string</source>
        <target state="translated">Die inhärente Mehrdeutigkeit bei der Verwendung einer printf-Formatzeichenfolge konnte nicht aufgelöst werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInEnum">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position</source>
        <target state="translated">Die Mehrdeutigkeit bei der Verwendung eines generischen Konstrukts mit einer enum-Einschränkung an dieser Position oder in ihrer Umgebung konnte nicht aufgelöst werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInDelegate">
        <source>Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position</source>
        <target state="translated">Die Mehrdeutigkeit bei der Verwendung eines generischen Konstrukts mit einer delegate-Einschränkung an dieser Position oder in ihrer Umgebung konnte nicht aufgelöst werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInvalidValue">
        <source>Invalid value</source>
        <target state="translated">Ungültiger Wert.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleParamCountsDiffer">
        <source>The signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">Die Signatur und die Implementierung sind nicht kompatibel, da die Anzahl der entsprechenden Typparameter unterschiedlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
        <source>The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation</source>
        <target state="translated">Die Signatur und die Implementierung sind nicht kompatibel, da der Typparameter in der Klasse/Signatur eine andere Kompilierzeitanforderung stellt als der Member bzw. die Implementierung.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDiffer">
        <source>The signature and implementation are not compatible because the declaration of the type parameter '{0}' requires a constraint of the form {1}</source>
        <target state="translated">Die Signatur und die Implementierung sind nicht kompatibel, da die Deklaration des Typparameters "{0}" eine Einschränkung im Format "{1}" erfordert.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDifferRemove">
        <source>The signature and implementation are not compatible because the type parameter '{0}' has a constraint of the form {1} but the implementation does not. Either remove this constraint from the signature or add it to the implementation.</source>
        <target state="translated">Die Signatur und die Implementierung sind nicht kompatibel, da der Typparameter "{0}" eine Einschränkung im Format "{1}" aufweist, die Implementierung aber nicht. Entfernen Sie diese Einschränkung entweder aus der Signatur, oder fügen Sie sie der Implementierung hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableShouldOverrideObjectEquals">
        <source>The type '{0}' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'</source>
        <target state="translated">Der Typ "{0}" implementiert "System.IComparable". Sie sollten ebenfalls eine explizite Überschreibung für "Object.Equals" hinzufügen.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableDefaultObjectEqualsProvided">
        <source>The type '{0}' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly</source>
        <target state="translated">Der Typ "{0}" implementiert "System.IComparable" explizit, stellt aber keine entsprechende Überschreibung für "Object.Equals" bereit. Eine Implementierung von "Object.Equals" wurde automatisch über "System.IComparable" bereitgestellt. Implementieren Sie die Überschreibung "Object.Equals" explizit.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCodeOrEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" umfasst eine explizite Implementierung von "Object.GetHashCode" oder "Object.Equals". Sie müssen das CustomEquality-Attribut auf den Typ anwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCode">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" umfasst eine explizite Implementierung von "Object.GetHashCode". Implementieren Sie eine entsprechende Überschreibung für "Object.Equals(obj)".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" umfasst eine explizite Implementierung von "Object.Equals". Implementieren Sie eine entsprechende Überschreibung für "Object.GetHashCode()".</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleHiddenBySignature">
        <source>The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">Die Ausnahmedefinitionen sind nicht kompatibel, weil eine CLI-Ausnahmezuordnung von einer Signatur verdeckt wird. Die Ausnahmezuordnung muss für andere Module sichtbar sein. Das Modul enthält die Ausnahmedefinition\n    {0}    \nDie Signatur gibt aber Folgendes an:\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer">
        <source>The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">Die Ausnahmedefinitionen sind nicht kompatibel, weil die CLI-Darstellungen unterschiedlich sind. Das Modul enthält die Ausnahmedefinition\n    {0}    \nDie Signatur gibt aber Folgendes an:\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature">
        <source>The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Die Ausnahmedefinitionen sind nicht kompatibel, weil die Ausnahmeabkürzung von der Signatur verdeckt wird. Die Abkürzung muss für andere CLI-Sprachen sichtbar sein. Sorgen Sie dafür, dass die Abkürzung in der Signatur sichtbar ist. Das Modul enthält die Ausnahmedefinition\n    {0}    \nDie Signatur gibt aber Folgendes an:\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleSignaturesDiffer">
        <source>The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Die Ausnahmedefinitionen sind nicht kompatibel, weil die Ausnahmeabkürzungen in der Signatur und in der Implementierung unterschiedlich sind. Das Modul enthält die Ausnahmedefinition\n    {0}    \nDie Signatur gibt aber Folgendes an:\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer">
        <source>The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Die Ausnahmedefinitionen sind nicht kompatibel, weil die Ausnahmedeklarationen unterschiedlich sind. Das Modul enthält die Ausnahmedefinition\n    {0}    \nDie Signatur gibt aber Folgendes an:\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInSigButNotImpl">
        <source>The exception definitions are not compatible because the field '{0}' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">Die Ausnahmedefinitionen sind nicht kompatibel, weil das Feld "{0}" für die Signatur erforderlich war, in der Implementierung aber nicht angegeben wurde. Das Modul enthält die Ausnahmedefinition\n    {1}    \nDie Signatur gibt aber Folgendes an:\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInImplButNotSig">
        <source>The exception definitions are not compatible because the field '{0}' was present in the implementation but not in the signature. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">Die Ausnahmedefinitionen sind nicht kompatibel, weil das Feld "{0}" in der Implementierung vorhanden war, aber nicht in der Signatur. Das Modul enthält die Ausnahmedefinition\n    {1}    \nDie Signatur gibt aber Folgendes an:\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldOrderDiffers">
        <source>The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Die Ausnahmedefinitionen sind nicht kompatibel, weil die Reihenfolge der Felder in der Signatur und in der Implementierung unterschiedlich ist. Das Modul enthält die Ausnahmedefinition\n    {0}    \nDie Signatur gibt aber Folgendes an:\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelModuleNamespaceAttributesDifferInSigAndImpl">
        <source>The namespace or module attributes differ between signature and implementation</source>
        <target state="translated">Die Namespace- oder Modulattribute sind in Signatur und Implementierung unterschiedlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsOverconstrained">
        <source>This method is over-constrained in its type parameters</source>
        <target state="translated">Diese Methode ist durch ihre Typparameter übermäßig eingeschränkt.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverloadNotFound">
        <source>No implementations of '{0}' had the correct number of arguments and type parameters. The required signature is '{1}'.</source>
        <target state="translated">Keine Implementierung von "{0}" wies die richtige Anzahl von Argumenten und Typparametern auf. Die erforderliche Signatur lautet "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideWasAmbiguous">
        <source>The override for '{0}' was ambiguous</source>
        <target state="translated">Die Überschreibung für "{0}" war mehrdeutig.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMoreThenOneOverride">
        <source>More than one override implements '{0}'</source>
        <target state="translated">{0} wird von mehr als einer Überschreibung implementiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsSealed">
        <source>The method '{0}' is sealed and cannot be overridden</source>
        <target state="translated">Die {0}-Methode ist versiegelt und kann nicht überschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideImplementsMoreThenOneSlot">
        <source>The override '{0}' implements more than one abstract slot, e.g. '{1}' and '{2}'</source>
        <target state="translated">Die Überschreibung "{0}" implementiert mehr als einen abstrakten Umsetzungsplatz, z.B. "{1}" und "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelDuplicateInterface">
        <source>Duplicate or redundant interface</source>
        <target state="translated">Doppelte oder redundante Schnittstelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNeedExplicitImplementation">
        <source>The interface '{0}' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.</source>
        <target state="translated">Die {0}-Schnittstelle ist in mehreren explizit implementierten Schnittstellentypen enthalten. Fügen Sie eine explizite Implementierung dieser Schnittstelle hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNamedArgumentHasBeenAssignedMoreThenOnce">
        <source>A named argument has been assigned more than one value</source>
        <target state="translated">Einem benannten Argument wurde mehr als ein Wert zugewiesen.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGiven">
        <source>No implementation was given for '{0}'</source>
        <target state="translated">Für "{0}" wurde keine Implementierung angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenWithSuggestion">
        <source>No implementation was given for '{0}'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Für "{0}" wurde keine Implementierung angegeben. Alle Schnittstellenmember müssen implementiert und unter einer entsprechenden interface-Deklaration aufgeführt werden, z.B. "interface ... with member ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfArguments">
        <source>The member '{0}' does not have the correct number of arguments. The required signature is '{1}'.</source>
        <target state="translated">Der Member "{0}" weist nicht die richtige Anzahl von Argumenten auf. Die erforderliche Signatur lautet "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters">
        <source>The member '{0}' does not have the correct number of method type parameters. The required signature is '{1}'.</source>
        <target state="translated">Der Member "{0}" weist nicht die richtige Anzahl von Methodentypparametern auf. Die erforderliche Signatur lautet "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters">
        <source>The member '{0}' does not have the correct kinds of generic parameters. The required signature is '{1}'.</source>
        <target state="translated">Der Member "{0}" weist nicht die richtigen Arten von generischen Parametern auf. Die erforderliche Signatur lautet "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberCannotImplement">
        <source>The member '{0}' cannot be used to implement '{1}'. The required signature is '{2}'.</source>
        <target state="translated">Der Member "{0}" kann nicht zur Implementierung von "{1}" verwendet werden. Die erforderliche Signatur lautet "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILError">
        <source>Error while parsing embedded IL</source>
        <target state="translated">Fehler beim Analysieren der eingebetteten IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILTypeError">
        <source>Error while parsing embedded IL type</source>
        <target state="translated">Fehler beim Analysieren des eingebetteten IL-Typs.</target>
        <note />
      </trans-unit>
      <trans-unit id="astDeprecatedIndexerNotation">
        <source>This indexer notation has been removed from the F# language</source>
        <target state="translated">Diese Indexernotation wurde aus der Programmiersprache F# entfernt.</target>
        <note />
      </trans-unit>
      <trans-unit id="astInvalidExprLeftHandOfAssignment">
        <source>Invalid expression on left of assignment</source>
        <target state="translated">Ungültiger Ausdruck auf der linken Seite der Zuweisung.</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoRefEqualsOnStruct">
        <source>The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'.</source>
        <target state="translated">Das ReferenceEquality-Attribut darf nicht für Strukturen verwendet werden. Verwenden Sie stattdessen das StructuralEquality-Attribut, oder implementieren Sie eine Überschreibung für "System.Object.Equals(obj)".</target>
        <note />
      </trans-unit>
      <trans-unit id="augInvalidAttrs">
        <source>This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'</source>
        <target state="translated">Dieser Typ verwendet eine unzulässige Kombination der Attribute "NoEquality", "ReferenceEquality", "StructuralEquality", "NoComparison" und "StructuralComparison".</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqualityNeedsNoComparison">
        <source>The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute</source>
        <target state="translated">Das NoEquality-Attribut muss in Verbindung mit dem NoComparison-Attribut verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructCompNeedsStructEquality">
        <source>The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute</source>
        <target state="translated">Das StructuralComparison-Attribut muss in Verbindung mit dem StructuralEquality-Attribut verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructEqNeedsNoCompOrStructComp">
        <source>The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes</source>
        <target state="translated">Das StructuralEquality-Attribut muss in Verbindung mit den Attributen "NoComparison" oder "StructuralComparison" verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="augTypeCantHaveRefEqAndStructAttrs">
        <source>A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes</source>
        <target state="translated">Ein Typ darf nicht gleichzeitig das ReferenceEquality-Attribut und die Attribute "StructuralEquality" oder "StructuralComparison" aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="augOnlyCertainTypesCanHaveAttrs">
        <source>Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes</source>
        <target state="translated">Nur Datensatz-, Union-, Ausnahme- und Strukturtypen können mit den Attributen "ReferenceEquality", "StructuralEquality" und "StructuralComparison" augmentiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="augRefEqCantHaveObjEquals">
        <source>A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">Ein Typ mit dem ReferenceEquality-Attribut darf keine explizite Implementierung von "Object.Equals(obj)", "System.IEquatable&lt;_&gt;" und/oder "System.Collections.IStructuralEquatable" aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsObjEquals">
        <source>A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">Ein Typ mit dem CustomEquality-Attribut erfordert die explizite Implementierung von "Object.Equals(obj)", "System.IEquatable&lt;_&gt;" und/oder "System.Collections.IStructuralEquatable".</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomCompareNeedsIComp">
        <source>A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'</source>
        <target state="translated">Ein Typ mit dem CustomComparison-Attribut erfordert die explizite Implementierung von "System.IComparable" und/oder "System.Collections.IStructuralComparable".</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqNeedsNoObjEquals">
        <source>A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">Ein Typ mit dem NoEquality-Attribut sollte in der Regel keine explizite Implementierung von "Object.Equals(obj)" aufweisen. Deaktivieren Sie diese Warnung, wenn diese Implementierung aus Interoperabilitätsgründen beabsichtigt ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoCompCantImpIComp">
        <source>A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable&lt;_&gt;' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">Ein Typ mit dem NoComparison-Attribut sollte in der Regel keine explizite Implementierung von "System.IComparable", "System.IComparable&lt;_&gt;" oder "System.Collections.IStructuralComparable" aufweisen. Deaktivieren Sie diese Warnung, wenn diese Implementierung aus Interoperabilitätsgründen beabsichtigt ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsNoCompOrCustomComp">
        <source>The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes</source>
        <target state="translated">Das CustomEquality-Attribut muss in Verbindung mit den Attributen "NoComparison" oder "CustomComparison" verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="forPositionalSpecifiersNotPermitted">
        <source>Positional specifiers are not permitted in format strings</source>
        <target state="translated">Positionsspezifizierer sind in Formatzeichenfolgen nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="forMissingFormatSpecifier">
        <source>Missing format specifier</source>
        <target state="translated">Der Formatbezeichner fehlt.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFlagSetTwice">
        <source>'{0}' flag set twice</source>
        <target state="translated">{0}-Flag doppelt festgelegt.</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrefixFlagSpacePlusSetTwice">
        <source>Prefix flag (' ' or '+') set twice</source>
        <target state="translated">Präfixflag (" " oder "+") doppelt festgelegt.</target>
        <note />
      </trans-unit>
      <trans-unit id="forHashSpecifierIsInvalid">
        <source>The # formatting modifier is invalid in F#</source>
        <target state="translated">Der #-Formatierungsmodifizierer ist in F# ungültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadPrecision">
        <source>Bad precision in format specifier</source>
        <target state="translated">Unzulässige Genauigkeitsangaben in Formatbezeichner.</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadWidth">
        <source>Bad width in format specifier</source>
        <target state="translated">Unzulässige Breite in Formatbezeichner.</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportZeroFlag">
        <source>'{0}' format does not support '0' flag</source>
        <target state="translated">Das Format "{0}" unterstützt kein 0-Flag.</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrecisionMissingAfterDot">
        <source>Precision missing after the '.'</source>
        <target state="translated">Genauigkeitsangaben nach dem "." fehlen.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatDoesntSupportPrecision">
        <source>'{0}' format does not support precision</source>
        <target state="translated">Das Format "{0}" unterstützt keine Genauigkeitsangaben.</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifier">
        <source>Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Ungültiger Formatbezeichner (nach l oder L): Erwartet wurde ld, li, lo, lu, lx oder lX. In F#-Code können Sie stattdessen %d, %x, %o oder %u verwenden; diese Bezeichner sind überladen und funktionieren mit allen grundlegenden Integer-Typen.</target>
        <note />
      </trans-unit>
      <trans-unit id="forLIsUnnecessary">
        <source>The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Die Angabe von "l" oder "L" ist in diesem Formatbezeichner nicht erforderlich. In F#-Code können Sie stattdessen %d, %x, %o oder %u verwenden; diese Bezeichner sind überladen und funktionieren mit allen grundlegenden Integer-Typen.</target>
        <note />
      </trans-unit>
      <trans-unit id="forHIsUnnecessary">
        <source>The 'h' or 'H' in this format specifier is unnecessary. You can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Die Angabe von "h" oder "H" ist in diesem Formatbezeichner nicht erforderlich. Sie können stattdessen %d, %x, %o oder %u verwenden. Diese Bezeichner sind überladen und funktionieren mit allen grundlegenden Integertypen.</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportPrefixFlag">
        <source>'{0}' does not support prefix '{1}' flag</source>
        <target state="translated">"{0}" unterstützt kein {1}-Präfixflag.</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifierGeneral">
        <source>Bad format specifier: '{0}'</source>
        <target state="translated">Ungültiger Formatbezeichner: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="elSysEnvExitDidntExit">
        <source>System.Environment.Exit did not exit</source>
        <target state="translated">System.Environment.Exit war nicht vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="elDeprecatedOperator">
        <source>The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined</source>
        <target state="translated">Die Behandlung dieses Operators erfolgt jetzt direkt durch den F#-Compiler; die Bedeutung kann nicht mehr geändert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkProtectedOrBaseCalled">
        <source>A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope.</source>
        <target state="translated">Entweder wird ein geschützter Member aufgerufen oder "base" verwendet. Dies ist nur bei der direkten Implementierung von Membern zulässig, da diese ihren Objektbereich mit Escapevorgängen außer Kraft setzen könnten.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkByrefUsedInInvalidWay">
        <source>The byref-typed variable '{0}' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.</source>
        <target state="translated">Die Verwendung der Variablen "{0}" vom Typ "byref" ist ungültig. Byrefs können nicht von Abschlüssen erfasst oder an innere Funktionen übergeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkBaseUsedInInvalidWay">
        <source>The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.</source>
        <target state="translated">Die Verwendung des Schlüsselworts "base" ist ungültig. Base-Aufrufe können nicht in Abschlüssen verwendet werden. Verwenden Sie einen privaten Member für base-Aufrufe.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkVariableUsedInInvalidWay">
        <source>The variable '{0}' is used in an invalid way</source>
        <target state="translated">Die Verwendung der Variablen "{0}" ist ungültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTypeLessAccessibleThanType">
        <source>The type '{0}' is less accessible than the value, member or type '{1}' it is used in.</source>
        <target state="translated">Der Typ "{0}" ist weniger zugreifbar als der Wert, Member oder Typ "{1}", in dem er verwendet wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSystemVoidOnlyInTypeof">
        <source>'System.Void' can only be used as 'typeof&lt;System.Void&gt;' in F#</source>
        <target state="translated">System.Void kann in F# nur als "typeof&lt;System.Void&gt;" verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorUseOfByref">
        <source>A type instantiation involves a byref type. This is not permitted by the rules of Common IL.</source>
        <target state="translated">Eine Typinstanziierung enthält einen byref-Typ. Dies ist nach den Regeln der Common IL nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorContainsCallToRethrow">
        <source>Calls to 'reraise' may only occur directly in a handler of a try-with</source>
        <target state="translated">Aufrufe von "reraise" dürfen nicht direkt in einem Handler für "try-with" auftreten.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSplicingOnlyInQuotations">
        <source>Expression-splicing operators may only be used within quotations</source>
        <target state="translated">Splice-Operatoren für Ausdrücke dürfen nur in Anführungszeichen verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassSplicing">
        <source>First-class uses of the expression-splicing operator are not permitted</source>
        <target state="translated">Die Verwendung des expression-splicing-Operators in der ersten Klasse ist nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassAddressOf">
        <source>First-class uses of the address-of operators are not permitted</source>
        <target state="translated">Die Verwendung der address-of-Operatoren in der ersten Klasse ist nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassRethrow">
        <source>First-class uses of the 'reraise' function is not permitted</source>
        <target state="translated">Die Verwendung der reraise-Funktion in der ersten Klasse ist nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAtThisPoint">
        <source>The byref typed value '{0}' cannot be used at this point</source>
        <target state="translated">Der Wert "{0}" vom Typ "byref" kann an diesem Punkt nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkLimitationsOfBaseKeyword">
        <source>'base' values may only be used to make direct calls to the base implementations of overridden members</source>
        <target state="translated">base-Werte dürfen nur für direkte Aufrufe der Basisimplementierungen von überschriebenen Membern verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkObjCtorsCantUseExceptionHandling">
        <source>Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.</source>
        <target state="translated">Objektkonstruktoren dürfen "try/with" und "try/finally" vor der Initialisierung des Objekts nicht direkt verwenden. Dies umfasst Konstrukte wie "for x in ...", bei denen diese Konstrukte u.U. verwendet werden. Dies ist eine Einschränkung der Common IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfAtThisPoint">
        <source>The address of the variable '{0}' cannot be used at this point</source>
        <target state="translated">Die Adresse der Variablen "{0}" kann an diesem Punkt nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressStaticFieldAtThisPoint">
        <source>The address of the static field '{0}' cannot be used at this point</source>
        <target state="translated">Die Adresse des statischen Felds "{0}" kann an diesem Punkt nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressFieldAtThisPoint">
        <source>The address of the field '{0}' cannot be used at this point</source>
        <target state="translated">Die Adresse des Felds "{0}" kann an diesem Punkt nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfArrayElementAtThisPoint">
        <source>The address of an array element cannot be used at this point</source>
        <target state="translated">Die Adresse eines Arrayelements kann an diesem Punkt nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFirstClassFuncNoByref">
        <source>The type of a first-class function cannot contain byrefs</source>
        <target state="translated">Der Typ einer Funktion erster Klasse darf keine Byrefs enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReturnTypeNoByref">
        <source>A method return type would contain byrefs which is not permitted</source>
        <target state="translated">Ein Methodenrückgabetyp würde Byrefs enthalten; das ist nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidCustAttrVal">
        <source>Invalid custom attribute value (not a constant or literal)</source>
        <target state="translated">Ungültiger benutzerdefinierter Attributwert (keine Konstante und kein Literal).</target>
        <note />
      </trans-unit>
      <trans-unit id="chkAttrHasAllowMultiFalse">
        <source>The attribute type '{0}' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element.</source>
        <target state="translated">Für den Attributtyp "{0}" ist "AllowMultiple=false" festgelegt. Mehrere Instanzen dieses Attributs können nicht einem einzigen Sprachelement angefügt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to its definition at or near '{2}'. This is an invalid forward reference.</source>
        <target state="translated">Die Verwendung des Members "{0}" ist ungültig. Die Verwendung von "{1}" wurde vor der Definition bei oder in der Nähe von "{2}" per Rückschluss abgeleitet. Dies ist ein ungültiger Vorwärtsverweis.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAsTopValue">
        <source>A byref typed value would be stored here. Top-level let-bound byref values are not permitted.</source>
        <target state="translated">Ein Wert vom Typ "byref" würde hier gespeichert werden. byref-Werte der obersten Ebene vom Typ "let-bound" sind nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReflectedDefCantSplice">
        <source>[&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">[&lt;ReflectedDefinition&gt;]-Begriffe dürfen keinen Präfix-Splice-Operator "%" enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkEntryPointUsage">
        <source>A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence.</source>
        <target state="translated">Eine Funktion mit dem EntryPointAttribute-Attribut muss die letzte Deklaration in der letzten Datei der Kompilierungssequenz sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseCompiledForm">
        <source>compiled form of the union case</source>
        <target state="translated">kompilierte Form des Union-Falls</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseDefaultAugmentation">
        <source>default augmentation of the union case</source>
        <target state="translated">Standardaugmentation des Union-Falls</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameMethod">
        <source>The property '{0}' has the same name as a method in type '{1}'.</source>
        <target state="translated">Die Eigenschaft "{0}" hat denselben Namen wie eine Methode im Typ "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterSetterDoNotMatchAbstract">
        <source>The property '{0}' of type '{1}' has a getter and a setter that do not match. If one is abstract then the other must be as well.</source>
        <target state="translated">Der Getter und der Setter der Eigenschaft "{0}" vom Typ "{1}" stimmen nicht überein. Wenn einer abstrakt ist, muss es der andere ebenfalls sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameIndexer">
        <source>The property '{0}' has the same name as another property in type '{1}', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.</source>
        <target state="translated">Die Eigenschaft "{0}" hat denselben Namen wie eine andere Eigenschaft im Typ "{1}", allerdings akzeptiert eine Eigenschaft Indexerargumente und die andere nicht. Möglicherweise fehlt ein Indexerargument für eine der Eigenschaften.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCantStoreByrefValue">
        <source>A type would store a byref typed value. This is not permitted by Common IL.</source>
        <target state="translated">In einem Typ würde ein Wert vom Typ "byref" gespeichert werden. Dies ist mit der Common IL nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethod">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}'.</source>
        <target state="translated">Doppelte Methode. Die Methode "{0}" hat denselben Namen und dieselbe Signatur wie eine andere Methode im Typ "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodWithSuffix">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Doppelte Methode. Die Methode "{0}" hat denselben Namen und dieselbe Signatur wie eine andere Methode im Typ "{1}", nachdem Tupel, Funktionen, Maßeinheiten und/oder angegebene Typen gelöscht wurden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodCurried">
        <source>The method '{0}' has curried arguments but has the same name as another method in type '{1}'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.</source>
        <target state="translated">Die Methode "{0}" enthält Curryargumente, hat aber denselben Namen wie eine andere Methode im Typ "{1}". Methoden mit Curryargumenten dürfen nicht überladen werden. Verwenden Sie ggf. eine Methode, die Tupelargumente akzeptiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCurriedMethodsCantHaveOutParams">
        <source>Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments</source>
        <target state="translated">Methoden mit Curry-Argumenten dürfen keine out-, ParamArray-, optional-, ReflectedDefinition-, byref-, CallerLineNumber-, CallerMemberName- oder CallerFilePath-Argumente deklarieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateProperty">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}'.</source>
        <target state="translated">Doppelte Eigenschaft. Die Eigenschaft "{0}" hat denselben Namen und dieselbe Signatur wie eine andere Eigenschaft im Typ "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicatePropertyWithSuffix">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Doppelte Eigenschaft. Die Eigenschaft "{0}" hat denselben Namen und dieselbe Signatur wie in eine andere Eigenschaft im Typ "{1}", nachdem Tupel, Funktionen, Maßeinheiten und/oder angegebene Typen gelöscht wurden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedType">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type.</source>
        <target state="translated">Doppelte Methode. Die abstrakte {0}-Methode hat denselben Namen und dieselbe Signatur wie eine abstrakte Methode in einem geerbten Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedTypeWithSuffix">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Doppelte Methode. Die abstrakte {0}-Methode hat denselben Namen und dieselbe Signatur wie in eine abstrakte Methode in einem geerbten Typ, nachdem Tupel, Funktionen, Maßeinheiten und/oder angegebene Typen gelöscht wurden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMultipleGenericInterfaceInstantiations">
        <source>This type implements the same interface at different generic instantiations '{0}' and '{1}'. This is not permitted in this version of F#.</source>
        <target state="translated">Dieser Typ implementiert dieselbe Schnittstelle mit den unterschiedlichen generischen Instanziierungen "{0}" und "{1}". Dies ist in dieser Version von F# nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkValueWithDefaultValueMustHaveDefaultValue">
        <source>The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check</source>
        <target state="translated">Der Typ eines Felds mit dem DefaultValue-Attribut muss die Standardinitialisierung zulassen, also NULL als eigenen Wert aufweisen oder ein Strukturtyp sein, dessen Felder alle die Standardinitialisierung zulassen. Mit "DefaultValue(false)" können Sie diese Prüfung deaktivieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefInTypeAbbrev">
        <source>The type abbreviation contains byrefs. This is not permitted by F#.</source>
        <target state="translated">Die Typabkürzung enthält Byrefs. Dies ist in F# nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefBoundVarUsedInSplice">
        <source>The variable '{0}' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.</source>
        <target state="translated">Die Variable "{0}" ist in Anführungszeichen gebunden, wird aber in einem Splice-Ausdruck verwendet. Dies ist nicht zulässig, da dadurch der Bereich mittels Escapevorgängen außer Kraft gesetzt werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericExprs">
        <source>Quotations cannot contain uses of generic expressions</source>
        <target state="translated">Anführungszeichen dürfen keine generischen Ausdrücke enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericFunctions">
        <source>Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.</source>
        <target state="translated">Anführungszeichen dürfen keine Funktionsdefinitionen enthalten, die per Rückschluss abgeleitet sind oder als generisch deklariert werden. Fügen Sie Typeinschränkungen hinzu, damit dieser Ausdruck in Anführungszeichen gültig wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainObjExprs">
        <source>Quotations cannot contain object expressions</source>
        <target state="translated">Anführungszeichen dürfen keine Objektausdrücke enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainAddressOf">
        <source>Quotations cannot contain expressions that take the address of a field</source>
        <target state="translated">Anführungszeichen dürfen keine Ausdrücke enthalten, die die Adresse eines Felds aufnehmen.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainStaticFieldRef">
        <source>Quotations cannot contain expressions that fetch static fields</source>
        <target state="translated">Anführungszeichen dürfen keine Ausdrücke enthalten, die statische Felder abrufen.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainInlineIL">
        <source>Quotations cannot contain inline assembly code or pattern matching on arrays</source>
        <target state="translated">Anführungszeichen dürfen keinen Inlineassemblycode oder Mustervergleich für Arrays enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainDescendingForLoops">
        <source>Quotations cannot contain descending for loops</source>
        <target state="translated">Anführungszeichen dürfen keine absteigenden For-Schleifen enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantFetchUnionIndexes">
        <source>Quotations cannot contain expressions that fetch union case indexes</source>
        <target state="translated">Anführungszeichen dürfen keine Ausdrücke enthalten, die Union-Fallindizes abrufen.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetUnionFields">
        <source>Quotations cannot contain expressions that set union case fields</source>
        <target state="translated">Anführungszeichen dürfen keine Ausdrücke enthalten, die Union-Fallfelder festlegen.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetExceptionFields">
        <source>Quotations cannot contain expressions that set fields in exception values</source>
        <target state="translated">Anführungszeichen dürfen keine Ausdrücke enthalten, die Felder in Ausnahmewerten festlegen.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantRequireByref">
        <source>Quotations cannot contain expressions that require byref pointers</source>
        <target state="translated">Anführungszeichen dürfen keine Ausdrücke enthalten, die byref-Zeiger erfordern.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantCallTraitMembers">
        <source>Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call</source>
        <target state="translated">Anführungszeichen dürfen keine Ausdrücke, die Membereinschränkungsaufrufe durchführen, oder Operatorverwendungen enthalten, die implizit in einen Membereinschränkungsaufruf aufgelöst werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisConstant">
        <source>Quotations cannot contain this kind of constant</source>
        <target state="translated">Anführungszeichen dürfen diese Art von Konstante nicht enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisPatternMatch">
        <source>Quotations cannot contain this kind of pattern match</source>
        <target state="translated">Anführungszeichen dürfen diese Art von Mustervergleich nicht enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainArrayPatternMatching">
        <source>Quotations cannot contain array pattern matching</source>
        <target state="translated">Anführungszeichen dürfen keinen Arraymustervergleich enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisType">
        <source>Quotations cannot contain this kind of type</source>
        <target state="translated">Anführungszeichen dürfen diese Art von Typ nicht enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeCannotBeResolvedAtCompileTime">
        <source>The declared type parameter '{0}' cannot be used here since the type parameter cannot be resolved at compile time</source>
        <target state="translated">Der deklarierte Typparameter "{0}" kann an dieser Stelle nicht verwendet werden, weil der Typparameter zur Kompilierzeit nicht aufgelöst werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCodeLessGeneric">
        <source>This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'.</source>
        <target state="translated">Dieser Code ist weniger generisch, als aus seinen Anmerkungen hervorgeht. Eine mit "_" angegebene Maßeinheit ist "1", also ohne Dimension. Machen Sie den Code generisch, oder entfernen Sie "_".</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInferenceMaxDepth">
        <source>Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.</source>
        <target state="translated">Problem beim Rückschluss von Typen ist zu komplex (maximale Iterationstiefe erreicht). Fügen Sie ggf. weitere Typanmerkungen hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectedArguments">
        <source>Expected arguments to an instance member</source>
        <target state="translated">Argumente für einen Instanzmember wurden erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="csIndexArgumentMismatch">
        <source>This indexer expects {0} arguments but is here given {1}</source>
        <target state="translated">Dieser Indexer erwartet {0} Argumente, erhält hier aber {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenFunction">
        <source>Expecting a type supporting the operator '{0}' but given a function type. You may be missing an argument to a function.</source>
        <target state="translated">Ein unterstützender Typ für den Operator "{0}" wurde erwartet, aber ein Funktionstyp wurde empfangen. Möglicherweise fehlt ein Argument für eine Funktion.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenTuple">
        <source>Expecting a type supporting the operator '{0}' but given a tuple type</source>
        <target state="translated">Ein unterstützender Typ für den Operator '{0}' wurde erwartet, aber ein Tupeltyp wurde empfangen</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperator">
        <source>None of the types '{0}' support the operator '{1}'</source>
        <target state="translated">Der Operator '{1}' wird von keinem der Typen '{0}' unterstützt</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperator">
        <source>The type '{0}' does not support the operator '{1}'</source>
        <target state="translated">Der Operator '{1}' wird vom Typ '{0}' nicht unterstützt</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperatorNullable">
        <source>None of the types '{0}' support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Der Operator '{1}' wird von keinem der Typen '{0}' unterstützt. Möglicherweise sollte das Modul 'Microsoft.FSharp.Linq.NullableOperators' geöffnet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperatorNullable">
        <source>The type '{0}' does not support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Der Operator '{1}' wird vom Typ '{0}' nicht unterstützt. Möglicherweise sollte das Modul 'Microsoft.FSharp.Linq.NullableOperators' geöffnet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportConversion">
        <source>The type '{0}' does not support a conversion to the type '{1}'</source>
        <target state="translated">Der Typ "{0}" unterstützt die Konvertierung in den Typ "{1}" nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is static</source>
        <target state="translated">Der Typ "{0}" enthält die {1}-Methode (vollständiger Name "{2}"), die Methode ist aber statisch.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsNotStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is not static</source>
        <target state="translated">Der Typ "{0}" enthält die {1}-Methode (vollständiger Name "{2}"), die Methode ist aber nicht statisch.</target>
        <note />
      </trans-unit>
      <trans-unit id="csStructConstraintInconsistent">
        <source>The constraints 'struct' and 'not struct' are inconsistent</source>
        <target state="translated">Die Einschränkungen "struct" und "not struct" sind nicht konsistent.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value</source>
        <target state="translated">Der Typ "{0}" weist nicht NULL als eigenen Wert auf.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNullableTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'.</source>
        <target state="translated">Der Typ '{0}' weist nicht NULL als eigenen Wert auf. Zum Erstellen eines NULL-Werts für einen Typ, der NULL-Werte zulässt, 'System.Nullable()' verwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison1">
        <source>The type '{0}' does not support the 'comparison' constraint because it has the 'NoComparison' attribute</source>
        <target state="translated">Der Typ "{0}" unterstützt die comparison-Einschränkung nicht, weil er das NoComparison-Attribut aufweist.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison2">
        <source>The type '{0}' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface</source>
        <target state="translated">Der Typ "{0}" unterstützt die comparison-Einschränkung nicht. Beispielsweise unterstützt er die System.IComparable-Schnittstelle nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison3">
        <source>The type '{0}' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison</source>
        <target state="translated">Der Typ "{0}" unterstützt die comparison-Einschränkung nicht, weil es sich um einen Datensatz, eine Union oder Struktur mit mindestens einem Strukturelementtyp handelt, der die comparison-Einschränkung nicht unterstützt. Verwenden Sie entweder keinen Vergleich in Verbindung mit diesem Typ, oder fügen Sie dem Typ das StructuralComparison-Attribut hinzu, um festzustellen, von welchem Feldtyp der Vergleich nicht unterstützt wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality1">
        <source>The type '{0}' does not support the 'equality' constraint because it has the 'NoEquality' attribute</source>
        <target state="translated">Der Typ "{0}" unterstützt die equality-Einschränkung nicht, weil er das NoEquality-Attribut aufweist.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality2">
        <source>The type '{0}' does not support the 'equality' constraint because it is a function type</source>
        <target state="translated">Der Typ "{0}" unterstützt die equality-Einschränkung nicht, weil es sich um einen Funktionstyp handelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality3">
        <source>The type '{0}' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality</source>
        <target state="translated">Der Typ "{0}" unterstützt die equality-Einschränkung nicht, weil es sich um einen Datensatz, eine Union oder Struktur mit mindestens einem Strukturelementtyp handelt, der die equality-Einschränkung nicht unterstützt. Verwenden Sie entweder keine Gleichheit in Verbindung mit diesem Typ, oder fügen Sie dem Typ das StructuralEquality-Attribut hinzu, um festzustellen, von welchem Feldtyp die Gleichheit nicht unterstützt wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotEnumType">
        <source>The type '{0}' is not a CLI enum type</source>
        <target state="translated">Der Typ "{0}" ist kein CLI-Enumerationstyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeHasNonStandardDelegateType">
        <source>The type '{0}' has a non-standard delegate type</source>
        <target state="translated">Der Typ "{0}" hat einen nicht standardmäßigen Delegattyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotDelegateType">
        <source>The type '{0}' is not a CLI delegate type</source>
        <target state="translated">Der Typ "{0}" ist kein CLI-Delegattyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeParameterCannotBeNullable">
        <source>This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values.</source>
        <target state="translated">Dieser Typparameter kann nicht auf "Nullable" instanziiert werden. Diese Einschränkung soll sicherstellen, dass die Bedeutung von NULL in manchen CLI-Sprachen in Verbindung mit Nullable-Werten nicht verwirrend ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructType">
        <source>A generic construct requires that the type '{0}' is a CLI or F# struct type</source>
        <target state="translated">Für ein generisches Konstrukt muss der Typ "{0}" ein CLI- oder F#-Strukturtyp sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresUnmanagedType">
        <source>A generic construct requires that the type '{0}' is an unmanaged type</source>
        <target state="translated">Für ein generisches Konstrukt muss es sich beim Typ "{0}" um einen nicht verwalteten Typ handeln.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeNotCompatibleBecauseOfPrintf">
        <source>The type '{0}' is not compatible with any of the types {1}, arising from the use of a printf-style format string</source>
        <target state="translated">Der Typ "{0}" ist mit keinem der Typen "{1}" kompatibel; dies ist die Folge der Verwendung einer printf-Formatzeichenfolge.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresReferenceSemantics">
        <source>A generic construct requires that the type '{0}' have reference semantics, but it does not, i.e. it is a struct</source>
        <target state="translated">Für ein generisches Konstrukt muss der Typ "{0}" Verweissemantik aufweisen; dies ist aber nicht der Fall, es handelt sich also um eine Struktur.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresNonAbstract">
        <source>A generic construct requires that the type '{0}' be non-abstract</source>
        <target state="translated">Für ein generisches Konstrukt muss der Typ "{0}" nicht abstrakt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresPublicDefaultConstructor">
        <source>A generic construct requires that the type '{0}' have a public default constructor</source>
        <target state="translated">Für ein generisches Konstrukt muss der Typ "{0}" einen öffentlichen Standardkonstruktor aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInstantiationLengthMismatch">
        <source>Type instantiation length mismatch</source>
        <target state="translated">Typinstanziierungslänge stimmt nicht überein.</target>
        <note />
      </trans-unit>
      <trans-unit id="csOptionalArgumentNotPermittedHere">
        <source>Optional arguments not permitted here</source>
        <target state="translated">Optionale Argumente sind hier nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotStatic">
        <source>{0} is not a static member</source>
        <target state="translated">{0} ist kein statischer Member.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotInstance">
        <source>{0} is not an instance member</source>
        <target state="translated">{0} ist kein Instanzmember.</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentLengthMismatch">
        <source>Argument length mismatch</source>
        <target state="translated">Argumentlänge stimmt nicht überein.</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentTypesDoNotMatch">
        <source>The argument types don't match</source>
        <target state="translated">Argumenttypen stimmen nicht überein.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodExpectsParams">
        <source>This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument</source>
        <target state="translated">Diese Methode erwartet an dieser Position den CLI-Parameter "params". Mit "params" kann in Programmiersprachen wie C# eine variable Zahl von Argumenten an eine Methode übergeben werden. Übergeben Sie ein Array für dieses Argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible">
        <source>The member or object constructor '{0}' is not {1}</source>
        <target state="translated">Der Member oder Objektkonstruktor "{0}" ist nicht {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible2">
        <source>The member or object constructor '{0}' is not {1}. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.</source>
        <target state="translated">Der Member oder Objektkonstruktor "{0}" ist nicht {1}. Auf private Member darf nur innerhalb des deklarierenden Typs zugegriffen werden. Auf geschützte Member darf nur von einem erweiternden Typ zugegriffen werden; der Zugriff von inneren lambda-Ausdrücken ist nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAStaticMethod">
        <source>{0} is not a static method</source>
        <target state="translated">{0} ist keine statische Methode.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAnInstanceMethod">
        <source>{0} is not an instance method</source>
        <target state="translated">{0} ist keine Instanzmethode.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberHasNoArgumentOrReturnProperty">
        <source>The member or object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">Der Member oder Objektkonstruktor "{0}" enthält kein Argument und keine festlegbare Rückgabeeigenschaft "{1}". {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorHasNoArgumentOrReturnProperty">
        <source>The object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">Der Objektkonstruktor "{0}" besitzt kein Argument oder keine festlegbare Rückgabeeigenschaft "{1}". {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csRequiredSignatureIs">
        <source>The required signature is {0}</source>
        <target state="translated">Die erforderliche Signatur ist {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'.</source>
        <target state="translated">Der Member oder Objektkonstruktor "{0}" erfordert {1} Argument(e). Die erforderliche Signatur lautet "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch2">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'.</source>
        <target state="translated">Der Member oder Objektkonstruktor "{0}" erfordert {1} zusätzliche(s) Argument(e). Die erforderliche Signatur lautet "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch3">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">Der Member oder Objektkonstruktor "{0}" erfordert {1} Argument(e). Die erforderliche Signatur lautet "{2}". Einige fehlende Argumente sind {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch4">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">Der Member oder Objektkonstruktor "{0}" erfordert {1} zusätzliche(s) Argument(e). Die erforderliche Signatur lautet "{2}". Einige fehlende Argumente sind {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityNamed">
        <source>The member or object constructor '{0}' requires {1} argument(s) but is here given {2} unnamed and {3} named argument(s). The required signature is '{4}'.</source>
        <target state="translated">Der Member oder Objektkonstruktor "{0}" erfordert {1} Argument(e), erhält hier aber {2} unbenannte(s) und {3} benannte(s) Argument(e). Die erforderliche Signatur lautet "{4}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArity">
        <source>The member or object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Der Member oder Objektkonstruktor "{0}" akzeptiert {1} Argument(e), erhält hier aber {2}. Die erforderliche Signatur lautet "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArity">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Der Objektkonstruktor "{0}" akzeptiert {1} Argument(e), erhält hier aber {2}. Die erforderliche Signatur ist "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArityProp">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',').</source>
        <target state="translated">Der Objektkonstruktor "{0}" akzeptiert {1} Argument(e), erhält hier aber {2}. Die erforderliche Signatur ist "{3}". Wenn bestimmte Argumente Eigenschaften Werte zuordnen sollen, trennen Sie diese Argumente mit einem Komma (",").</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityType">
        <source>The member or object constructor '{0}' takes {1} type argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Der Member oder Objektkonstruktor "{0}" akzeptiert {1} Typargument(e), erhält hier aber {2}. Die erforderliche Signatur lautet "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberNotAccessible">
        <source>A member or object constructor '{0}' taking {1} arguments is not accessible from this code location. All accessible versions of method '{2}' take {3} arguments.</source>
        <target state="translated">Auf einen Member oder Objektkonstruktor "{0}", der {1} Argumente akzeptiert, kann von dieser Position im Code nicht zugegriffen werden. Alle zugreifbaren Versionen der {2}-Methode nehmen {3} Argumente an.</target>
        <note />
      </trans-unit>
      <trans-unit id="csIncorrectGenericInstantiation">
        <source>Incorrect generic instantiation. No {0} member named '{1}' takes {2} generic arguments.</source>
        <target state="translated">Fehlerhafte generische Instanziierung. Kein {0}-Member namens "{1}" akzeptiert {2} generische Argumente.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberOverloadArityMismatch">
        <source>The member or object constructor '{0}' does not take {1} argument(s). An overload was found taking {2} arguments.</source>
        <target state="translated">Der Member oder Objektkonstruktor "{0}" akzeptiert {1} Argument(e) nicht. Eine Überladung wurde gefunden, die {2} Argumente akzeptiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments</source>
        <target state="translated">Kein {0}-Member oder -Objektkonstruktor namens "{1}" akzeptiert {2} Argumente.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments2">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. Note the call to this member also provides {3} named arguments.</source>
        <target state="translated">Kein {0}-Member oder -Objektkonstruktor namens "{1}" akzeptiert {2} Argumente. Beachten Sie, dass ein Aufruf dieses Members ebenfalls {3} benannte Argumente bereitstellt.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments3">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. The named argument '{3}' doesn't correspond to any argument or settable return property for any overload.</source>
        <target state="translated">Kein {0}-Member oder -Objektkonstruktor namens "{1}" akzeptiert {2} Argumente. Das benannte Argument "{3}" entspricht keinem Argument und keiner festlegbaren Rückgabeeigenschaft für eine Überladung.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodNotFound">
        <source>Method or object constructor '{0}' not found</source>
        <target state="translated">Methode oder Objektkonstruktor "{0}" wurde nicht gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFound">
        <source>No overloads match for method '{0}'.</source>
        <target state="translated">Keine passenden Überladungen für die Methode '{0}' vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsOverloaded">
        <source>A unique overload for method '{0}' could not be determined based on type information prior to this program point. A type annotation may be needed.</source>
        <target state="translated">Eine eindeutige Überladung für Methode '{0}' konnte nicht auf Basis von Typinformationen vor diesem Programmpunkt bestimmt werden. Unter Umständen ist eine Typanmerkung erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCandidates">
        <source>Candidates: {0}</source>
        <target state="translated">Kandidaten: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csSeeAvailableOverloads">
        <source>The available overloads are shown below.</source>
        <target state="translated">Die verfügbaren Überladungen werden unten angezeigt.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsDoCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on 'do' bindings, but '{0}' was given.</source>
        <target state="translated">Zugriffsmodifizierer sind für "do"-Bindungen nicht zulässig, "{0}" wurde jedoch angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInHashIf">
        <source>End of file in #if section begun at or after here</source>
        <target state="translated">Dateiende in einem #if-Abschnitt, der an oder vor dieser Stelle begonnen wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInString">
        <source>End of file in string begun at or before here</source>
        <target state="translated">Dateiende in einer Zeichenfolge, die an oder vor dieser Stelle begonnen wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimString">
        <source>End of file in verbatim string begun at or before here</source>
        <target state="translated">Dateiende in einer ausführlichen Zeichenfolge, die an oder vor dieser Stelle begonnen wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInComment">
        <source>End of file in comment begun at or before here</source>
        <target state="translated">Dateiende in einem Kommentar, der an oder vor dieser Stelle begonnen wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInStringInComment">
        <source>End of file in string embedded in comment begun at or before here</source>
        <target state="translated">Dateiende in einer in den Kommentar eingebetteten Zeichenfolge, die an oder vor dieser Stelle begonnen wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimStringInComment">
        <source>End of file in verbatim string embedded in comment begun at or before here</source>
        <target state="translated">Dateiende in einer in den Kommentar eingebetteten ausführlichen Zeichenfolge, die an oder vor dieser Stelle begonnen wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInIfOcaml">
        <source>End of file in IF-OCAML section begun at or before here</source>
        <target state="translated">Dateiende in einem IF-OCAML-Abschnitt, der an oder vor dieser Stelle begonnen wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInDirective">
        <source>End of file in directive begun at or before here</source>
        <target state="translated">Dateiende in einer Direktive, die an oder vor dieser Stelle begonnen wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoHashEndIfFound">
        <source>No #endif found for #if or #else</source>
        <target state="translated">Kein #endif für #if oder #else gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIgnored">
        <source>Attributes have been ignored in this construct</source>
        <target state="translated">Attribute wurden in diesem Konstrukt ignoriert.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInImplicitClassConstructors">
        <source>'use' bindings are not permitted in primary constructors</source>
        <target state="translated">use-Bindungen sind in primären Konstruktoren unzulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInModules">
        <source>'use' bindings are not permitted in modules and are treated as 'let' bindings</source>
        <target state="translated">use-Bindungen sind in Modulen nicht zulässig und werden als let-Bindungen behandelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIntegerForLoopRequiresSimpleIdentifier">
        <source>An integer for loop must use a simple identifier</source>
        <target state="translated">Eine Integer-for-Schleife muss einen einfachen Bezeichner verwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyOneWithAugmentationAllowed">
        <source>At most one 'with' augmentation is permitted</source>
        <target state="translated">Es ist maximal eine with-Augmentation zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSemicolon">
        <source>A semicolon is not expected at this point</source>
        <target state="translated">An dieser Stelle wird kein Semikolon erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFile">
        <source>Unexpected end of input</source>
        <target state="translated">Unerwartetes Ende der Eingabe</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedVisibilityDeclaration">
        <source>Accessibility modifiers are not permitted here, but '{0}' was given.</source>
        <target state="translated">Zugriffsmodifizierer sind an dieser Stelle nicht zulässig, "{0}" wurde jedoch angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyHashDirectivesAllowed">
        <source>Only '#' compiler directives may occur prior to the first 'namespace' declaration</source>
        <target state="translated">Nur #-Compilerdirektiven dürfen vor der ersten namespace-Deklaration auftreten.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityDeclarationsShouldComePriorToIdentifier">
        <source>Accessibility modifiers should come immediately prior to the identifier naming a construct</source>
        <target state="translated">Zugriffsmodifizierer sollten unmittelbar vor dem Bezeichner eines Konstrukts aufgeführt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNamespaceOrModuleNotBoth">
        <source>Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'</source>
        <target state="translated">Dateien sollten mit einer Namespace- oder einer Moduldeklaration beginnen, z.B. "namespace SomeNamespace.SubNamespace" oder "module SomeNamespace.SomeModule", aber nicht mit beidem. Verwenden Sie "module SomeModule = ...", um ein Modul in einem Namespace zu definieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleAbbreviationMustBeSimpleName">
        <source>A module abbreviation must be a simple name, not a path</source>
        <target state="translated">Eine Modulabkürzung muss ein einfacher Name sein, kein Pfad.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviation">
        <source>Ignoring attributes on module abbreviation</source>
        <target state="translated">Attribute für Modulabkürzung werden ignoriert.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">Das Zugriffsattribut "{0}" ist für die Modulabkürzung nicht zulässig. Modulabkürzungen sind immer privat.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">Das Sichtbarkeitsattribut "{0}" ist für die Modulabkürzung nicht zulässig. Modulabkürzungen sind immer privat.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnClosedBlockInHashLight">
        <source>Unclosed block</source>
        <target state="translated">Nicht geschlossener Block.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBeginOrStruct">
        <source>Unmatched 'begin' or 'struct'</source>
        <target state="translated">Keine Entsprechung für "begin" oder "struct".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleDefnMustBeSimpleName">
        <source>A module name must be a simple name, not a path</source>
        <target state="translated">Ein Modulname muss ein einfacher Name sein, kein Pfad.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEmptyModuleDefn">
        <source>Unexpected empty type moduleDefn list</source>
        <target state="translated">Unerwartete moduleDefn-Liste mit leerem Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesMustComeBeforeVal">
        <source>Attributes should be placed before 'val'</source>
        <target state="translated">Attribute sollten vor "val" platziert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesAreNotPermittedOnInterfaceImplementations">
        <source>Attributes are not permitted on interface implementations</source>
        <target state="translated">Attribute sind für Schnittstellenimplementierungen nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxError">
        <source>Syntax error</source>
        <target state="translated">Syntaxfehler</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAugmentationsIllegalOnDelegateType">
        <source>Augmentations are not permitted on delegate type moduleDefns</source>
        <target state="translated">Augmentationen sind für den Delegattyp "moduleDefns" nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedClassInterfaceOrStruct">
        <source>Unmatched 'class', 'interface' or 'struct'</source>
        <target state="translated">Keine Entsprechung für "class", "interface" oder "struct".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyTypeDefinition">
        <source>A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'.</source>
        <target state="translated">Eine Typdefinition erfordert mindestens eine Member- oder andere Deklaration. Wenn Sie eine leere Klasse, Struktur oder Schnittstelle definieren möchten, sollten Sie stattdessen "type ... = class end", "interface end" oder "struct end" verwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedWith">
        <source>Unmatched 'with' or badly formatted 'with' block</source>
        <target state="translated">Keine Entsprechung für "with" oder fehlerhaft formatierter with-Block.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetOrSetRequired">
        <source>'get', 'set' or 'get,set' required</source>
        <target state="translated">get, "set" oder "get,set" erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyClassCanTakeValueArguments">
        <source>Only class types may take value arguments</source>
        <target state="translated">Nur Klassentypen können Wertargumente akzeptieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBegin">
        <source>Unmatched 'begin'</source>
        <target state="translated">Keine Entsprechung für "begin".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidDeclarationSyntax">
        <source>Invalid declaration syntax</source>
        <target state="translated">Ungültige Deklarationssyntax.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetAndOrSetRequired">
        <source>'get' and/or 'set' required</source>
        <target state="translated">get und/oder "set" erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAnnotationsOnGetSet">
        <source>Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'</source>
        <target state="translated">Typanmerkungen für Eigenschaftengetter und -setter müssen nach "get()" oder "set(v)" angegeben werden, z.B. "with get() : string = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterMustHaveAtLeastOneArgument">
        <source>A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'</source>
        <target state="translated">Eine Getter-Eigenschaft muss eine Funktion sein, z.B. "get() = ..." oder "get(index) = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultipleAccessibilitiesForGetSet">
        <source>Multiple accessibilities given for property getter or setter</source>
        <target state="translated">Für den Getter oder Setter der Eigenschaft wurden mehrere Zugriffsebenen angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetSyntax">
        <source>Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '</source>
        <target state="translated">Eigenschaftensetter müssen mit "set value = ", "set idx value = " oder "set (idx1,...,idxN) value = ... " definiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInterfacesHaveSameVisibilityAsEnclosingType">
        <source>Interfaces always have the same visibility as the enclosing type</source>
        <target state="translated">Schnittstellen weisen immer die gleiche Sichtbarkeit auf wie der einschließende Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAccessibilityModsIllegalForAbstract">
        <source>Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.</source>
        <target state="translated">Zugriffsmodifizierer sind für diesen Member nicht zulässig. Abstrakte Umsetzungsplätze weisen immer die gleiche Sichtbarkeit auf wie der einschließende Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalOnInherit">
        <source>Attributes are not permitted on 'inherit' declarations</source>
        <target state="translated">Attribute sind für inherit-Deklarationen nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityIllegalOnInherit">
        <source>Accessibility modifiers are not permitted on an 'inherits' declaration</source>
        <target state="translated">Zugriffsmodifizierer sind für eine inherits-Deklaration nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInheritDeclarationsCannotHaveAsBindings">
        <source>'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding.</source>
        <target state="translated">Deklarationen vom Typ 'inherit' dürfen keine as-Bindungen aufweisen. Für den Zugriff auf Member der Basisklasse beim Überschreiben einer Methode kann die Syntax 'base.SomeMember' verwendet werden; 'base' ist ein Schlüsselwort. Entfernen Sie diese as-Bindung.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalHere">
        <source>Attributes are not allowed here</source>
        <target state="translated">Attribute sind an dieser Stelle nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for type abbreviations</source>
        <target state="translated">Zugriffsmodifizierer sind an dieser Stelle für Typabkürzungen nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumTypesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for enum types</source>
        <target state="translated">Zugriffsmodifizierer sind an dieser Stelle für Enumerationstypen nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAllEnumFieldsRequireValues">
        <source>All enum fields must be given values</source>
        <target state="translated">Alle Enumerationsfelder müssen Werte erhalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInlineAssemblyCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on inline assembly code types</source>
        <target state="translated">Zugriffsmodifizierer sind für Inlineassembly-Codetypen nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIdentifier">
        <source>Unexpected identifier: '{0}'</source>
        <target state="translated">Unerwarteter Bezeichner: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnionCasesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Zugriffsmodifizierer sind für Union-Fälle nicht zulässig. Verwenden Sie "type U = internal ..." oder "type U = private ...", um die Zugreifbarkeit für die vollständige Darstellung anzugeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on enumeration fields</source>
        <target state="translated">Zugriffsmodifizierer sind für Enumerationsfelder nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsConsiderUsingSeparateRecordType">
        <source>Consider using a separate record type instead</source>
        <target state="translated">Verwenden Sie stattdessen einen separaten Datensatztyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsRecordFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Zugriffsmodifizierer sind für Datensatzfelder nicht zulässig. Verwenden Sie "type R = internal ..." oder "type R = private ...", um die Zugreifbarkeit für die vollständige Darstellung anzugeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsLetAndForNonRecBindings">
        <source>The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings</source>
        <target state="translated">Im F#-Code wird das Deklarationsformat "let ... and ..." für nicht rekursive Bindungen nicht verwendet. Verwenden Sie eine Reihe aus let-Bindungen.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedParen">
        <source>Unmatched '('</source>
        <target state="translated">Keine Entsprechung für "(".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessivePatternsShouldBeSpacedOrTupled">
        <source>Successive patterns should be separated by spaces or tupled</source>
        <target state="translated">Aufeinanderfolgende Muster sollten durch Leerzeichen getrennt oder als Tupel angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoMatchingInForLet">
        <source>No matching 'in' found for this 'let'</source>
        <target state="translated">Kein übereinstimmendes "in" für dieses "let" gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorInReturnForLetIncorrectIndentation">
        <source>Error in the return expression for this 'let'. Possible incorrect indentation.</source>
        <target state="translated">Fehler im Rückgabeausdruck für dieses "let". Möglicherweise falscher Einzug.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterLet">
        <source>The block following this '{0}' is unfinished. Every code block is an expression and must have a result. '{1}' cannot be the final code element in a block. Consider giving this block an explicit result.</source>
        <target state="translated">Der Block, der auf dieses {0}-Element folgt, ist unvollständig. Jeder Codeblock ist ein Ausdruck und muss ein Ergebnis besitzen. "{1}" kann nicht das letzte Codeelement in einem Block sein. Weisen Sie diesem Block ggf. ein explizites Ergebnis zu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIncompleteIf">
        <source>Incomplete conditional. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Unvollständiger bedingter Ausdruck. Es wurde 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAssertIsNotFirstClassValue">
        <source>'assert' may not be used as a first class value. Use 'assert &lt;expr&gt;' instead.</source>
        <target state="translated">assert darf nicht als Wert der ersten Klasse verwendet werden. Verwenden Sie stattdessen "assert &lt;Ausdruck&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">Bezeichner erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInOrEqualExpected">
        <source>'in' or '=' expected</source>
        <target state="translated">'in' oder '=' erwartet</target>
        <note />
      </trans-unit>
      <trans-unit id="parsArrowUseIsLimited">
        <source>The use of '-&gt;' in sequence and computation expressions is limited to the form 'for pat in expr -&gt; expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions.</source>
        <target state="translated">Die Verwendung von "-&gt;" in Sequenz- und Berechnungsausdrücken ist auf das Format "for pat in expr -&gt; expr" beschränkt. Verwenden Sie die Syntax "for ... in ... do ... yield...", um Elemente in komplexeren Sequenzausdrücken zu generieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessiveArgsShouldBeSpacedOrTupled">
        <source>Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized</source>
        <target state="translated">Aufeinanderfolgende Argumente sollten durch Leerzeichen getrennt oder als Tupel angegeben werden, und Argumente mit Funktions- oder Methodenanwendungen sollten in Klammern gesetzt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracket">
        <source>Unmatched '['</source>
        <target state="translated">Keine Entsprechung für "[".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingQualificationAfterDot">
        <source>Missing qualification after '.'</source>
        <target state="translated">Fehlende Qualifikation nach ".".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsParenFormIsForML">
        <source>In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array</source>
        <target state="translated">Im F#-Code kann "expr.[expr]" verwendet werden. Möglicherweise ist eine Typanmerkung erforderlich, um den ersten Ausdruck in einem Array anzugeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuote">
        <source>Mismatched quotation, beginning with '{0}'</source>
        <target state="translated">Anführungszeichen stimmen nicht überein, beginnt mit "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatched">
        <source>Unmatched '{0}'</source>
        <target state="translated">Keine Entsprechung für "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracketBar">
        <source>Unmatched '[|'</source>
        <target state="translated">Keine Entsprechung für "[|".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBrace">
        <source>Unmatched '{{'</source>
        <target state="translated">Keine Entsprechung für "{{".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsFieldBinding">
        <source>Field bindings must have the form 'id = expr;'</source>
        <target state="translated">Feldbindungen müssen das Format "id = expr;" aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMemberIllegalInObjectImplementation">
        <source>This member is not permitted in an object implementation</source>
        <target state="translated">Dieser Member ist in einer Objektimplementierung unzulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingFunctionBody">
        <source>Missing function body</source>
        <target state="translated">Fehlender Funktionsrumpf.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxErrorInLabeledType">
        <source>Syntax error in labelled type argument</source>
        <target state="translated">Syntaxfehler in Typargument mit Bezeichnung.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedInfixOperator">
        <source>Unexpected infix operator in type expression</source>
        <target state="translated">Unerwarteter infix-Operator in Typenausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultiArgumentGenericTypeFormDeprecated">
        <source>The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident&lt;typ,...,typ&gt;' instead</source>
        <target state="translated">Die Syntax "(typ,...,typ) ident" wird im F#-Code nicht verwendet. Verwenden Sie stattdessen "ident&lt;typ,...,typ&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidLiteralInType">
        <source>Invalid literal in type</source>
        <target state="translated">Ungültiges Literal im Typ</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedOperatorForUnitOfMeasure">
        <source>Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'.</source>
        <target state="translated">Unerwarteter infix-Operator in Maßeinheitenausdruck. Zulässige Operatoren sind "*", "/" und "^".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIntegerLiteralForUnitOfMeasure">
        <source>Unexpected integer literal in unit-of-measure expression</source>
        <target state="translated">Unerwartetes Integer-Literal in Maßeinheitenausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedTypeParameter">
        <source>Syntax error: unexpected type parameter specification</source>
        <target state="translated">Syntaxfehler: Unerwartete Typparameterangabe.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuotationName">
        <source>Mismatched quotation operator name, beginning with '{0}'</source>
        <target state="translated">Anführungszeichen-Operatorname stimmt nicht überein, beginnt mit "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseMustBeginWithUpperCase">
        <source>Active pattern case identifiers must begin with an uppercase letter</source>
        <target state="translated">Schreibweisenbezeichner für das aktive Muster müssen mit einem Großbuchstaben beginnen.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseContainsPipe">
        <source>The '|' character is not permitted in active pattern case identifiers</source>
        <target state="translated">Das Zeichen '|' ist nicht in Schreibweisenbezeichnern für das aktive Muster zulässig</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalDenominatorForMeasureExponent">
        <source>Denominator must not be 0 in unit-of-measure exponent</source>
        <target state="translated">Nenner darf in der Maßeinheit des Exponenten nicht 0 sein</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoEqualShouldFollowNamespace">
        <source>No '=' symbol should follow a 'namespace' declaration</source>
        <target state="translated">Auf eine namespace-Deklaration darf kein "="-Zeichen folgen.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleStructEndDeprecated">
        <source>The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">Die Syntax "module ... = struct .. end" wird im F#-Code nicht verwendet. Verwenden Sie stattdessen "module ... = begin .. end".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleSigEndDeprecated">
        <source>The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">Die Syntax "module ... : sig .. end" wird im F#-Code nicht verwendet. Verwenden Sie stattdessen "module ... = begin .. end".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticFieldUsedWhenInstanceFieldExpected">
        <source>A static field was used where an instance field is expected</source>
        <target state="translated">Ein statisches Feld wurde an einer Stelle verwendet, an der ein Instanzfeld erwartet wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodNotAccessible">
        <source>Method '{0}' is not accessible from this code location</source>
        <target state="translated">Auf die {0}-Methode kann von dieser Position im Code nicht zugegriffen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplicitMeasureFollowingSlash">
        <source>Implicit product of measures following /</source>
        <target state="translated">Implizites Produktmaß nach "/".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedMeasureAnon">
        <source>Unexpected SynMeasure.Anon</source>
        <target state="translated">Unerwartetes SynMeasure.Anon</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonZeroConstantCannotHaveGenericUnit">
        <source>Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.</source>
        <target state="translated">Konstanten ungleich null dürfen keine generischen Einheiten aufweisen. Für eine generische Null schreiben Sie "0.0&lt;_&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSeqResultsUseYield">
        <source>In sequence expressions, results are generated using 'yield'</source>
        <target state="translated">In Sequenzausdrücken werden Ergebnisse mithilfe von "yield" erzeugt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedBigRationalConstant">
        <source>Unexpected big rational constant</source>
        <target state="translated">Unerwartete große rationale Konstante.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForUnitsOfMeasure">
        <source>Units-of-measure supported only on float, float32, decimal and signed integer types</source>
        <target state="translated">Maßeinheiten werden nur für die Typen "float", "float32", "decimal" und "signed integer" unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstUint16Array">
        <source>Unexpected Const_uint16array</source>
        <target state="translated">Unerwartetes "Const_uint16array".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstByteArray">
        <source>Unexpected Const_bytearray</source>
        <target state="translated">Unerwartetes "Const_bytearray".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterRequiresName">
        <source>A parameter with attributes must also be given a name, e.g. '[&lt;Attribute&gt;] Name : Type'</source>
        <target state="translated">Ein Parameter mit Attributen muss auch einen Namen erhalten, z.B. "[&lt;Attribut&gt;] Name : Type".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnValuesCannotHaveNames">
        <source>Return values cannot have names</source>
        <target state="translated">Rückgabetypen dürfen keinen Namen aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberKindPropertyGetSetNotExpected">
        <source>MemberKind.PropertyGetSet only expected in parse trees</source>
        <target state="translated">MemberKind.PropertyGetSet wird nur in Analysestrukturen erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainValues">
        <source>Namespaces cannot contain values. Consider using a module to hold your value declarations.</source>
        <target state="translated">Namespaces dürfen keine Werte enthalten. Verwenden Sie ein eigenes Modul für Ihre Wertdeklarationen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainExtensionMembers">
        <source>Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.</source>
        <target state="translated">Namespaces dürfen Erweiterungsmember nur in der gleichen Datei und Namespace-Deklarationsgruppe enthalten, in denen der Typ definiert ist. Verwenden Sie ggf. ein eigenes Modul für Deklarationen von Erweiterungsmembern.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributes">
        <source>Multiple visibility attributes have been specified for this identifier</source>
        <target state="translated">Für diesen Bezeichner wurden mehrere Sichtbarkeitsattribute angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributesWithLet">
        <source>Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions.</source>
        <target state="translated">Für diesen Bezeichner wurden mehrere Sichtbarkeitsattribute angegeben. Bindungen vom Typ 'let' in Klassen sind immer privat, wie alle Bindungen vom Typ 'let' innerhalb von Ausdrücken.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForRelationalOperator">
        <source>The name '({0})' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">Der Name "({0})" sollte nicht als Membername verwendet werden. Implementieren Sie zum Definieren der Vergleichssemantik für einen Typ die System.IComparable-Schnittstelle. Verwenden Sie zum Definieren eines statischen Members für die Verwendung durch andere CLI-Sprachen stattdessen den Namen "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForEquality">
        <source>The name '({0})' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">Der Name "({0})" sollte nicht als Membername verwendet werden. Überschreiben Sie zum Definieren der Gleichheitssemantik für einen Typ den Object.Equals-Member. Verwenden Sie zum Definieren eines statischen Members für die Verwendung durch andere CLI-Sprachen stattdessen den Namen "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberName">
        <source>The name '({0})' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">Der Name "({0})" sollte nicht als Membername verwendet werden. Verwenden Sie zum Definieren eines statischen Members für die Verwendung durch andere CLI-Sprachen stattdessen den Namen "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameFixedTypes">
        <source>The name '({0})' should not be used as a member name because it is given a standard definition in the F# library over fixed types</source>
        <target state="translated">Der Name "({0})" sollte nicht als Membername verwendet werden, weil in der F#-Bibliothek eine Standarddefinition für feste Typen dafür vergeben wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionRelational">
        <source>The '{0}' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type.</source>
        <target state="translated">Der {0}-Operator sollte normalerweise nicht umdefiniert werden. Implementieren Sie zum Definieren der überladenen Vergleichssemantik für einen bestimmten Typ die System.IComparable-Schnittstelle in der Definition dieses Typs.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionEquality">
        <source>The '{0}' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type.</source>
        <target state="translated">Der {0}-Operator sollte normalerweise nicht umdefiniert werden. Überschreiben Sie zum Definieren der Gleichheitssemantik für einen Typ den Object.Equals-Member in der Definition dieses Typs.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinition">
        <source>The '{0}' operator should not normally be redefined. Consider using a different operator name</source>
        <target state="translated">Der {0}-Operator sollte normalerweise nicht umdefiniert werden. Verwenden Sie einen anderen Operatornamen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexOperatorDefinition">
        <source>The '{0}' operator cannot be redefined. Consider using a different operator name</source>
        <target state="translated">Der {0}-Operator kann nicht umdefiniert werden. Verwenden Sie einen anderen Operatornamen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectModuleOrNamespaceParent">
        <source>Expected module or namespace parent {0}</source>
        <target state="translated">Ein übergeordnetes Modul oder ein übergeordneter Namespace "{0}" wurde erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" implementiert die System.IComparable-Schnittstelle explizit. Sie müssen das CustomComparison-Attribut auf den Typ anwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsGenericIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable&lt;_&gt;' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" implementiert die System.IComparable&lt;_&gt;-Schnittstelle explizit. Sie müssen das CustomComparison-Attribut auf den Typ anwenden und sollten außerdem eine einheitliche Implementierung der nicht generischen System.IComparable-Schnittstelle bereitstellen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" implementiert die System.IStructuralComparable-Schnittstelle explizit. Wenden Sie das CustomComparison-Attribut auf den Typ an.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordFieldInconsistentTypes">
        <source>This record contains fields from inconsistent types</source>
        <target state="translated">Dieser Datensatz enthält Felder aus inkonsistenten Typen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportStubsCannotBeInlined">
        <source>DLLImport stubs cannot be inlined</source>
        <target state="translated">DLLImport-Stubs können nicht inline gesetzt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCanOnlyBindThisAtMemberDeclaration">
        <source>Structs may only bind a 'this' parameter at member declarations</source>
        <target state="translated">Strukturen dürfen einen this-Parameter nur in Memberdeklarationen binden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedExprAtRecInfPoint">
        <source>Unexpected expression at recursive inference point</source>
        <target state="translated">Unerwarteter Ausdruck bei rekursivem Rückschlusspunkt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLessGenericBecauseOfAnnotation">
        <source>This code is less generic than required by its annotations because the explicit type variable '{0}' could not be generalized. It was constrained to be '{1}'.</source>
        <target state="translated">Dieser Code ist weniger generisch, als dies laut Anmerkungen erforderlich ist, weil die explizite Typvariable "{0}" nicht generalisiert werden konnte. Einschränkung auf "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstrainedTypeVariableCannotBeGeneralized">
        <source>One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types</source>
        <target state="translated">Mindestens eine der expliziten Klassen- oder Funktionstypvariablen für diese Bindung konnte nicht generalisiert werden, weil eine Einschränkung für andere Typen vorlag.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericParameterHasBeenConstrained">
        <source>A generic type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Ein generischer Typparameter wurde auf eine Weise verwendet, durch die er immer "{0}" sein muss.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterHasBeenConstrained">
        <source>This type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Dieser Typparameter wurde auf eine Weise verwendet, durch die er immer "{0}" sein muss.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParametersInferredAreNotStable">
        <source>The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</source>
        <target state="translated">Die für diesen Wert per Rückschluss abgeleiteten Typparameter sind beim Löschen von Typabkürzungen nicht stabil. Dies ist auf die Verwendung von Typabkürzungen zurückzuführen, die Typparameter löschen oder neu anordnen, z.B. \n\ttype taggedInt&lt;'a&gt; = int oder\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nDeklarieren Sie die Typparameter für diesen Wert explizit, z.B.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeParameterInvalid">
        <source>Explicit type parameters may only be used on module or member bindings</source>
        <target state="translated">Explizite Typparameter dürfen nur für Modul- oder Memberbindungen verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridingMethodRequiresAllOrNoTypeParameters">
        <source>You must explicitly declare either all or no type parameters when overriding a generic abstract method</source>
        <target state="translated">Sie müssen entweder alle Typparameter oder keinen Typparameter explizit deklarieren, wenn Sie eine generische abstrakte Methode überschreiben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldsDoNotDetermineUniqueRecordType">
        <source>The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type</source>
        <target state="translated">Anhand der Feldbezeichnungen und des erwarteten Typs dieses Datensatzausdrucks oder Musters lässt sich kein eindeutiger Datensatztyp bestimmen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldAppearsTwiceInRecord">
        <source>The field '{0}' appears twice in this record expression or pattern</source>
        <target state="translated">Das Feld "{0}" ist in diesem Datensatzausdruck oder Muster zweimal vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnknownUnion">
        <source>Unknown union case</source>
        <target state="translated">Unbekannter Union-Fall.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotSufficientlyGenericBecauseOfScope">
        <source>This code is not sufficiently generic. The type variable {0} could not be generalized because it would escape its scope.</source>
        <target state="translated">Dieser Code ist nicht generisch genug. Die Typvariable "{0}" konnte nicht generalisiert werden, weil sie sonst aus dem Bereich fallen würde.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyRequiresExplicitTypeParameters">
        <source>A property cannot have explicit type parameters. Consider using a method instead.</source>
        <target state="translated">Eine Eigenschaft darf keine expliziten Typparameter aufweisen. Verwenden Sie stattdessen eine Methode.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorCannotHaveTypeParameters">
        <source>A constructor cannot have explicit type parameters. Consider using a static construction method instead.</source>
        <target state="translated">Ein Konstruktor darf keine expliziten Typparameter aufweisen. Verwenden Sie stattdessen eine statische Konstruktionsmethode.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInstanceMemberRequiresTarget">
        <source>This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'.</source>
        <target state="translated">Dieser Instanzmember erfordert einen Parameter, der das aufgerufene Objekt darstellt. Definieren Sie den Member als statisch, oder verwenden Sie die Notation "member x.Member(args) = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertyInSyntaxTree">
        <source>Unexpected source-level property specification in syntax tree</source>
        <target state="translated">Unerwartete Eigenschaftenspezifikation auf Quellcodeebene in der Syntaxstruktur.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializerRequiresArgument">
        <source>A static initializer requires an argument</source>
        <target state="translated">Ein statischer Initialisierer erfordert ein Argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorRequiresArgument">
        <source>An object constructor requires an argument</source>
        <target state="translated">Ein Objektkonstruktor erfordert ein Argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticMemberShouldNotHaveThis">
        <source>This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'.</source>
        <target state="translated">Dieser statische Member sollte keinen this-Parameter aufweisen. Verwenden Sie die Notation "member Member(args) = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitStaticInitializerSyntax">
        <source>An explicit static initializer should use the syntax 'static new(args) = expr'</source>
        <target state="translated">Ein expliziter statischer Initialisierer sollte die Syntax "static new(args) = expr" verwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitObjectConstructorSyntax">
        <source>An explicit object constructor should use the syntax 'new(args) = expr'</source>
        <target state="translated">Ein expliziter Objektkonstruktor sollte die Syntax "new(args) = expr" verwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertySpec">
        <source>Unexpected source-level property specification</source>
        <target state="translated">Unerwartete Eigenschaftenspezifikation auf Quellcodeebene.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionFormDeprecated">
        <source>This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions.</source>
        <target state="translated">Dieses Format eines Objektausdrucks wird in F# nicht verwendet. Verwenden Sie "member this.MemberName ... = ...", um Memberimplementierungen in Objektausdrücken zu definieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDeclaration">
        <source>Invalid declaration</source>
        <target state="translated">Ungültige Deklaration.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesInvalidInPatterns">
        <source>Attributes are not allowed within patterns</source>
        <target state="translated">Attribute sind innerhalb von Mustern nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitTypeArguments">
        <source>The generic function '{0}' must be given explicit type argument(s)</source>
        <target state="translated">Die generische Funktion "{0}" muss explizite Typargumente erhalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoesNotAllowExplicitTypeArguments">
        <source>The method or function '{0}' should not be given explicit type argument(s) because it does not declare its type parameters explicitly</source>
        <target state="translated">Der Methode oder Funktion "{0}" sollten keine expliziten Typargumente zugewiesen werden, weil sie ihre Typparameter nicht explizit deklariert.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterArityMismatch">
        <source>This value, type or method expects {0} type parameter(s) but was given {1}</source>
        <target state="translated">Dieser Wert, dieser Typ oder diese Methode erwartet {0} Typparameter, es wurde(n) aber {1} übergeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultStructConstructorCall">
        <source>The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization</source>
        <target state="translated">Der mit null initialisierte Standardkonstruktor eines Strukturtyps darf nur verwendet werden, wenn alle Felder des Strukturtyps die Standardinitialisierung zulassen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindIDisposable">
        <source>Couldn't find Dispose on IDisposable, or it was overloaded</source>
        <target state="translated">Dispose für "IDisposable" wurde nicht gefunden oder war überladen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonLiteralCannotBeUsedInPattern">
        <source>This value is not a literal and cannot be used in a pattern</source>
        <target state="translated">Dieser Wert ist kein Literal und kann nicht als Muster verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsReadonly">
        <source>This field is readonly</source>
        <target state="translated">Dieses Feld ist schreibgeschützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameArgumentsMustAppearLast">
        <source>Named arguments must appear after all other arguments</source>
        <target state="translated">Benannte Argumente müssen nach allen anderen Argumenten aufgeführt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitLambda">
        <source>This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking {0} arguments.</source>
        <target state="translated">Dieser Funktionswert dient zum Erstellen eines Delegattyps, dessen Signatur ein Byref-Argument umfasst. Sie müssen einen expliziten lambda-Ausdruck mit {0} Argumenten verwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCannotBeEnumerated">
        <source>The type '{0}' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method</source>
        <target state="translated">Der Typ "{0}" ist kein Typ, dessen Werte mit dieser Syntax aufgelistet werden können, er ist daher weder mit "seq&lt;_&gt;" noch mit "IEnumerable&lt;_&gt;" oder "IEnumerable" kompatibel und verfügt über keine GetEnumerator-Methode.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMixtureOfRecursiveForms">
        <source>This recursive binding uses an invalid mixture of recursive forms</source>
        <target state="translated">Diese rekursive Bindung verwendet eine unzulässige Mischung von rekursiven Formaten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectConstructionExpression">
        <source>This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.</source>
        <target state="translated">Dies ist kein gültiger Objektkonstruktionsausdruck. Explizite Objektkonstruktoren müssen entweder einen alternativen Konstruktor aufrufen oder alle Felder des Objekts initialisieren und einen Aufruf an einen übergeordneten Klassenkonstruktor angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraint">
        <source>Invalid constraint</source>
        <target state="translated">Ungültige Einschränkung.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraintTypeSealed">
        <source>Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution</source>
        <target state="translated">Ungültige Einschränkung: Der für diese Einschränkung verwendete Typ ist versiegelt; das bedeutet, die Einschränkung wurde von höchstens einer Projektmappe erfüllt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumConstraint">
        <source>An 'enum' constraint must be of the form 'enum&lt;type&gt;'</source>
        <target state="translated">Eine enum-Einschränkung muss das Format "enum&lt;Typ&gt;" aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNewConstraint">
        <source>'new' constraints must take one argument of type 'unit' and return the constructed type</source>
        <target state="translated">New-Einschränkungen müssen ein Argument vom Typ "unit" annehmen und den konstruierten Typ zurückgeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPropertyType">
        <source>This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -&gt; ty3'. Properties returning functions should have types of the form '(ty1 -&gt; ty2)'.</source>
        <target state="translated">Diese Eigenschaft hat einen ungültigen Typ. Eigenschaften, die mehrere Indexerargumente akzeptieren, sollten Typen im Format "ty1 * ty2 -&gt; ty3" aufweisen. Eigenschaften, die Funktionen zurückgeben, sollten Typen im Format "(ty1 -&gt; ty2)" aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureMarkWithAttribute">
        <source>Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.</source>
        <target state="translated">Ein Maßeinheitenparameter wurde erwartet, kein Typparameter. Explizite Maßeinheitenparameter müssen mit dem [&lt;Measure&gt;]-Attribut markiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeParameter">
        <source>Expected type parameter, not unit-of-measure parameter</source>
        <target state="translated">Ein Typparameter wurde erwartet, kein Maßeinheitenparameter.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeNotUnitOfMeasure">
        <source>Expected type, not unit-of-measure</source>
        <target state="translated">Ein Typ wurde erwartet, keine Maßeinheit.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureNotType">
        <source>Expected unit-of-measure, not type</source>
        <target state="translated">Eine Maßeinheit wurde erwartet, kein Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUnitsOfMeasurePrefix">
        <source>Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.</source>
        <target state="translated">Maßeinheiten dürfen nicht als Präfixargumente für einen Typ verwendet werden. Ändern Sie sie in Postfixargumente in spitzen Klammern.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnitsOfMeasureInvalidInTypeConstructor">
        <source>Unit-of-measure cannot be used in type constructor application</source>
        <target state="translated">Eine Maßeinheit kann nicht in einer Typkonstruktoranwendung verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireBuilderMethod">
        <source>This control construct may only be used if the computation expression builder defines a '{0}' method</source>
        <target state="translated">Dieses Steuerkonstrukt darf nur verwendet werden, wenn vom Berechnungsausdrucks-Generator eine {0}-Methode definiert wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoNestedTypes">
        <source>This type has no nested types</source>
        <target state="translated">Dieser Typ enthält keine geschachtelten Typen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSymbolInTypeExpression">
        <source>Unexpected {0} in type expression</source>
        <target state="translated">Unerwartetes {0} in Typenausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterInvalidAsTypeConstructor">
        <source>Type parameter cannot be used as type constructor</source>
        <target state="translated">Der Typparameter kann nicht als Typkonstruktor verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalSyntaxInTypeExpression">
        <source>Illegal syntax in type expression</source>
        <target state="translated">Unzulässige Syntax in Typenausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousUnitsOfMeasureCannotBeNested">
        <source>Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression</source>
        <target state="translated">Anonyme Maßeinheiten können nicht innerhalb eines anderen Maßeinheitenausdrucks geschachtelt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousTypeInvalidInDeclaration">
        <source>Anonymous type variables are not permitted in this declaration</source>
        <target state="translated">Anonyme Typvariablen sind in dieser Deklaration nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSlashInType">
        <source>Unexpected / in type</source>
        <target state="translated">Unerwarteter Schrägstrich ("/") im Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedTypeArguments">
        <source>Unexpected type arguments</source>
        <target state="translated">Unerwartete Typargumente.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsOnlyOnMembers">
        <source>Optional arguments are only permitted on type members</source>
        <target state="translated">Optionale Argumente sind nur für Typmember zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameNotBoundInPattern">
        <source>Name '{0}' not bound in pattern context</source>
        <target state="translated">Der Name "{0}" ist im Musterkontext nicht gebunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNonPrimitiveLiteralInPatternMatch">
        <source>Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when &lt;variable&gt; = &lt;constant&gt;' at the end of the match clause.</source>
        <target state="translated">Nicht primitive numerische Literalkonstanten können nicht für Mustervergleiche verwendet werden, weil sie mithilfe eines NumericLiteral-Moduls mehreren verschiedenen Typen zugeordnet werden können. Ersetzen Sie sie durch eine Variable, und verwenden Sie am Ende der Vergleichsklausel "&lt;Variable&gt; = &lt;Konstante&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentUsage">
        <source>Type arguments cannot be specified here</source>
        <target state="translated">Typargumente können an dieser Stelle nicht angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireActivePatternWithOneResult">
        <source>Only active patterns returning exactly one result may accept arguments</source>
        <target state="translated">Nur aktive Muster, die genau ein Ergebnis zurückgeben, dürfen Argumente akzeptieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidArgForParameterizedPattern">
        <source>Invalid argument to parameterized pattern label</source>
        <target state="translated">Ungültiges Argument für parametrisierte Musterbezeichnung.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexIntoActivePatternArray">
        <source>Internal error. Invalid index into active pattern array</source>
        <target state="translated">Interner Fehler. Ungültiger Index für aktives Musterarray.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseDoesNotTakeArguments">
        <source>This union case does not take arguments</source>
        <target state="translated">Dieser Union-Fall akzeptiert keine Argumente.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseRequiresOneArgument">
        <source>This union case takes one argument</source>
        <target state="translated">Dieser Union-Fall akzeptiert ein Argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseExpectsTupledArguments">
        <source>This union case expects {0} arguments in tupled form</source>
        <target state="translated">Dieser Union-Fall erwartet {0} Argumente als Tupel.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotStatic">
        <source>Field '{0}' is not static</source>
        <target state="translated">Das Feld "{0}" ist nicht statisch.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNotLiteralCannotBeUsedInPattern">
        <source>This field is not a literal and cannot be used in a pattern</source>
        <target state="translated">Dieses Feld ist kein Literal und kann nicht als Muster verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireVarConstRecogOrLiteral">
        <source>This is not a variable, constant, active recognizer or literal</source>
        <target state="translated">Hierbei handelt es sich nicht um eine Variable, Konstante, eine aktive Erkennung oder ein Literal.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPattern">
        <source>This is not a valid pattern</source>
        <target state="translated">Dies ist kein gültiges Muster.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseWhenPatternGuard">
        <source>Character range matches have been removed in F#. Consider using a 'when' pattern guard instead.</source>
        <target state="translated">Der Abgleich von Zeichenbereichen wurde in F# entfernt. Verwenden Sie stattdessen einen when-Musterwächter.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalPattern">
        <source>Illegal pattern</source>
        <target state="translated">Unzulässiges Muster.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxErrorUnexpectedQMark">
        <source>Syntax error - unexpected '?' symbol</source>
        <target state="translated">Syntaxfehler - unerwartetes Symbol "?".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionCountMisMatch">
        <source>Expected {0} expressions, got {1}</source>
        <target state="translated">Es wurden {0} Ausdrücke erwartet, aber {1} empfangen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExprUndelayed">
        <source>TcExprUndelayed: delayed</source>
        <target state="translated">TcExprUndelayed: verzögert</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionRequiresSequence">
        <source>This expression form may only be used in sequence and computation expressions</source>
        <target state="translated">Dieses Ausdrucksformat darf nur in Sequenz- und Berechnungsausdrücken verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectExpressionSyntaxForm">
        <source>Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.</source>
        <target state="translated">Ungültiger Objektausdruck. Objekte ohne Überschreibungen oder Schnittstellen sollten das Ausdrucksformat "new Type(args)" ohne geschweifte Klammern verwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectSequenceOrRecordExpression">
        <source>Invalid object, sequence or record expression</source>
        <target state="translated">Ungültiger Objekt-, Sequenz- oder Datensatzausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSequenceExpressionSyntaxForm">
        <source>Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq {{ ... }}'</source>
        <target state="translated">Ungültiger Datensatz-, Sequenz- oder Berechnungsausdruck. Sequenzausdrücke müssen das Format "seq {{ ... }}" besitzen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionWithIfRequiresParenthesis">
        <source>This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression</source>
        <target state="translated">Dieser Listen- oder Arrayausdruck enthält ein Element im Format "if ... then ... else". Setzen Sie diesen Ausdruck in Klammern, um ihn als einzelnes Element der Liste oder des Arrays zu kenntlich zu machen und den Ausdruck von einer Liste zu unterscheiden, die mithilfe eines Sequenzausdrucks erzeugt wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseFormatString">
        <source>Unable to parse format string '{0}'</source>
        <target state="translated">Formatzeichenfolge "{0}" kann nicht analysiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcListLiteralMaxSize">
        <source>This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.</source>
        <target state="translated">Dieser Listenausdruck übersteigt die maximale Größe für Listenliterale. Verwenden Sie für umfangreichere Literale ein Array, und rufen Sie "Array.ToList" auf.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresObjectConstructor">
        <source>The expression form 'expr then expr' may only be used as part of an explicit object constructor</source>
        <target state="translated">Das Ausdrucksformat 'expr then expr' darf nur als Teil eines expliziten Objektkonstruktors verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentsCannotBeUsedInMemberTraits">
        <source>Named arguments cannot be given to member trait calls</source>
        <target state="translated">Benannte Argumente dürfen nicht an Aufrufe für Membermerkmale übergeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotValidEnumCaseName">
        <source>This is not a valid name for an enumeration case</source>
        <target state="translated">Dies ist kein gültiger Name für einen Enumerationsfall.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotMutable">
        <source>This field is not mutable</source>
        <target state="translated">Dieses Feld ist nicht änderbar.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresListArrayOrSequence">
        <source>This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq {{ ... }}', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements</source>
        <target state="translated">Dieses Konstrukt darf nur innerhalb von Listen-, Array- und Sequenzausdrücken verwendet werden, also Ausdrücken im Format "seq {{ ... }}", "[ ... ]" oder "[| ... |]". Bei diesen wird zum Generieren von Elementen die Syntax "for ... in ... do ... yield..." verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpressions">
        <source>This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'.</source>
        <target state="translated">Dieses Konstrukt darf nur innerhalb von Berechnungsausdrücken verwendet werden. Wenn ein Wert von einer normalen Funktion zurückgegeben werden soll, lassen Sie einfach "return" im Ausdruck weg.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresSequenceOrComputations">
        <source>This construct may only be used within sequence or computation expressions</source>
        <target state="translated">Dieses Konstrukt darf nur innerhalb von Sequenz- oder Berechnungsausdrücken verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpression">
        <source>This construct may only be used within computation expressions</source>
        <target state="translated">Dieses Konstrukt darf nur innerhalb von Berechnungsausdrücken verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexerExpression">
        <source>Invalid indexer expression</source>
        <target state="translated">Ungültiger Indexerausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
        <source>The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints</source>
        <target state="translated">Der expr.[idx]-Operator hat auf Grundlage von Informationen vor diesem Programmpunkt ein Objekt unbestimmten Typs verwendet. Fügen Sie ggf. weitere Typeinschränkungen hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromVariableType">
        <source>Cannot inherit from a variable type</source>
        <target state="translated">Von einem Variablentyp kann nicht geerbt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsOnTypeParametersCannotTakeArguments">
        <source>Calls to object constructors on type parameters cannot be given arguments</source>
        <target state="translated">Aufrufe von Objektkonstruktoren auf Typparametern dürfen keine Argumente erhalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCompiledNameAttributeMisused">
        <source>The 'CompiledName' attribute cannot be used with this language element</source>
        <target state="translated">Das CompiledName-Attribut kann nicht mit diesem Sprachelement verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedTypeRequired">
        <source>'{0}' may only be used with named types</source>
        <target state="translated">{0} darf nur für benannte Typen verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritCannotBeUsedOnInterfaceType">
        <source>'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead.</source>
        <target state="translated">inherit kann nicht für Schnittstellentypen verwendet werden. Implementieren Sie die Schnittstelle stattdessen mit "interface ... with ... end".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewCannotBeUsedOnInterfaceType">
        <source>'new' cannot be used on interface types. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">new kann nicht für Schnittstellentypen verwendet werden. Verwenden Sie stattdessen einen Objektausdruck "{{ new ... with ... }}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractTypeCannotBeInstantiated">
        <source>Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">Instanzen dieses Typs können nicht erstellt werden, da er als "abstract" markiert wurde oder nicht für alle Methoden Implementierungen vorhanden sind. Verwenden Sie stattdessen einen Objektausdruck "{{ new ... with ... }}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIDisposableTypeShouldUseNew">
        <source>It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value</source>
        <target state="translated">Objekte, die die IDisposable-Schnittstelle unterstützen, sollten mit der Syntax "new Type(args)" statt mit "Type(args)" oder "Type" als Funktionswert für den Konstruktor erstellt werden, um anzugeben, dass die Ressourcen sich möglicherweise im Besitz des generierten Werts befinden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxCanOnlyBeUsedToCreateObjectTypes">
        <source>'{0}' may only be used to construct object types</source>
        <target state="translated">{0} darf nur für Konstruktobjekttypen verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresCall">
        <source>Constructors for the type '{0}' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.</source>
        <target state="translated">Konstruktoren für den Typ "{0}" müssen den impliziten Objektkonstruktor direkt oder indirekt aufrufen. Verwenden Sie den Aufruf des impliziten Objektkonstruktors anstelle eines Datensatzausdrucks.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUndefinedField">
        <source>The field '{0}' has been given a value, but is not present in the type '{1}'</source>
        <target state="translated">Das Feld "{0}" hat einen Wert erhalten, ist aber im Typ "{1}" nicht vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresAssignment">
        <source>No assignment given for field '{0}' of type '{1}'</source>
        <target state="translated">Keine Zuweisung für Feld "{0}" vom Typ "{1}" angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExtraneousFieldsGivenValues">
        <source>Extraneous fields have been given values</source>
        <target state="translated">Zusätzliche Felder haben Werte erhalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
        <source>Only overrides of abstract and virtual members may be specified in object expressions</source>
        <target state="translated">Nur Überschreibungen von abstrakten und virtuellen Membern dürfen in Objektausdrücken angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoAbstractOrVirtualMemberFound">
        <source>The member '{0}' does not correspond to any abstract or virtual method available to override or implement.</source>
        <target state="translated">Der Member "{0}" entspricht keiner abstrakten oder virtuellen Methode, die zum Überschreiben oder Implementieren zur Verfügung steht.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberFoundIsNotAbstractOrVirtual">
        <source>The type {0} contains the member '{1}' but it is not a virtual or abstract method that is available to override or implement.</source>
        <target state="translated">Der Typ {0} enthält den Member "{1}", entspricht aber keiner virtuellen oder abstrakten Methode, die zum Überschreiben oder Implementieren verfügbar ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatch">
        <source>The member '{0}' does not accept the correct number of arguments. {1} argument(s) are expected, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">Der Member "{0}" akzeptiert nicht die richtige Anzahl von Argumenten. {1} Argumente werden erwartet, es wurden aber {2} Argumente angegeben. Die erforderliche Signatur ist "{3}".{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatchOneOverload">
        <source>The member '{0}' does not accept the correct number of arguments. One overload accepts {1} arguments, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">Der Member "{0}" akzeptiert nicht die richtige Anzahl von Argumenten. Eine Überladung akzeptiert {1} Argumente, es wurden aber {2} Argumente angegeben. Die erforderliche Signatur ist "{3}".{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSimpleMethodNameRequired">
        <source>A simple method name is required here</source>
        <target state="translated">An dieser Stelle ist ein einfacher Methodenname erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPredefinedTypeCannotBeUsedAsSuperType">
        <source>The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class</source>
        <target state="translated">Die Typen "System.ValueType", "System.Enum", "System.Delegate", "System.MulticastDelegate" und "System.Array" dürfen nicht als übergeordnete Typen in einem Objektausdruck oder einer Klasse verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMustBeUsedWithNamedType">
        <source>'new' must be used with a named type</source>
        <target state="translated">new muss für einen benannten Typ verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCreateExtensionOfSealedType">
        <source>Cannot create an extension of a sealed type</source>
        <target state="translated">Erweiterung eines versiegelten Typs kann nicht erstellt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoArgumentsForRecordValue">
        <source>No arguments may be given when constructing a record value</source>
        <target state="translated">Beim Erstellen eines Datensatzwerts dürfen keine Argumente angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoInterfaceImplementationForConstructionExpression">
        <source>Interface implementations cannot be given on construction expressions</source>
        <target state="translated">Schnittstellenimplementierungen dürfen nicht für Konstruktionsausdrücke verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionCanOnlyBeUsedInClassTypes">
        <source>Object construction expressions may only be used to implement constructors in class types</source>
        <target state="translated">Objektkonstruktionsausdrücke dürfen nur zur Implementierung von Konstruktoren in Klassentypen verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
        <source>Only simple bindings of the form 'id = expr' can be used in construction expressions</source>
        <target state="translated">In Konstruktionsausdrücken dürfen nur einfache Bindungen im Format "id = expr" verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectsMustBeInitializedWithObjectExpression">
        <source>Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field</source>
        <target state="translated">Objekte müssen von einem Objektkonstruktionsausdruck initialisiert werden, der einen geerbten Objektkonstruktor aufruft und jedem Feld einen Wert zuweist.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedInterfaceType">
        <source>Expected an interface type</source>
        <target state="translated">Ein Schnittstellentyp wurde erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorForInterfacesDoNotTakeArguments">
        <source>Constructor expressions for interfaces do not take arguments</source>
        <target state="translated">Konstruktorausdrücke für Schnittstellen akzeptieren keine Argumente.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresArguments">
        <source>This object constructor requires arguments</source>
        <target state="translated">Dieser Objektkonstruktor erfordert Argumente.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewRequiresObjectConstructor">
        <source>'new' may only be used with object constructors</source>
        <target state="translated">new darf nur für Objektkonstruktoren verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAtLeastOneOverrideIsInvalid">
        <source>At least one override did not correctly implement its corresponding abstract member</source>
        <target state="translated">In mindestens einer Überschreibung ist der entsprechende abstrakte Member nicht korrekt implementiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNumericLiteralRequiresModule">
        <source>This numeric literal requires that a module '{0}' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope</source>
        <target state="translated">Für dieses numerische Literal muss sich das Modul "{0}" im Bereich befinden, das die Funktionen "FromZero", "FromOne", "FromInt32", "FromInt64" und "FromString" definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRecordConstruction">
        <source>Invalid record construction</source>
        <target state="translated">Ungültige Datensatzkonstruktion.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresRecordTypes">
        <source>The expression form {{ expr with ... }} may only be used with record types. To build object types use {{ new Type(...) with ... }}</source>
        <target state="translated">Das Ausdrucksformat {{ expr with ... }} darf nur für Datensatztypen verwendet werden. Verwenden Sie zum Erstellen von Objekttypen {{ new Type(...) with ... }}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritedTypeIsNotObjectModelType">
        <source>The inherited type is not an object model type</source>
        <target state="translated">Der geerbte Typ ist kein Objektmodelltyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
        <source>Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors</source>
        <target state="translated">Objektkonstruktionsausdrücke (also Datensatzausdrücke mit Vererbungsspezifikationen) dürfen nur zur Implementierung von Konstruktoren in Objektmodelltypen verwendet werden. Verwenden Sie "new ObjectType(args)", um Instanzen von Objektmodelltypen außerhalb von Konstruktoren zu erstellen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyRecordInvalid">
        <source>'{{ }}' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.</source>
        <target state="translated">{{ }} ist kein gültiger Ausdruck. Datensätze müssen mindestens ein Feld umfassen. Leere Sequenzen werden mit "Seq.empty" oder einer leeren Liste "[]" angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordTypeNeedConstructor">
        <source>This type is not a record type. Values of class and struct types must be created using calls to object constructors.</source>
        <target state="translated">Dieser Typ ist kein Datensatztyp. Werte von Klassen- und Strukturtypen müssen mithilfe von Aufrufen an Objektkonstruktoren erstellt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordType">
        <source>This type is not a record type</source>
        <target state="translated">Dieser Typ ist kein Datensatztyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInComputationExpression">
        <source>This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder {{ ... }}'.</source>
        <target state="translated">Dieses Konstrukt ist als Teil eines Berechnungsausdrucks nicht eindeutig. Geschachtelte Ausdrücke können mit "let _ = (...)", geschachtelte Berechnungen mit "let! res = builder {{ ... }}" ausgedrückt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInSequenceExpression">
        <source>This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {{... }}'.</source>
        <target state="translated">Dieses Konstrukt ist als Teil eines Sequenzausdrucks nicht eindeutig. Geschachtelte Ausdrücke können mit "let _ = (...)", geschachtelte Sequenzen mit "yield! seq {{... }}" ausgedrückt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoBangIllegalInSequenceExpression">
        <source>'do!' cannot be used within sequence expressions</source>
        <target state="translated">do! kann nicht in Sequenzausdrücken verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseForInSequenceExpression">
        <source>The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead.</source>
        <target state="translated">Die Verwendung von "let! x = coll" in Sequenzausdrücken ist nicht zulässig. Verwenden Sie stattdessen "for x in coll".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryIllegalInSequenceExpression">
        <source>'try'/'with' cannot be used within sequence expressions</source>
        <target state="translated">'try'/'with' kann nicht in Sequenzausdrücken verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseYieldBangForMultipleResults">
        <source>In sequence expressions, multiple results are generated using 'yield!'</source>
        <target state="translated">In Sequenzausdrücken werden mehrere Ergebnisse mithilfe von "yield!" erzeugt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAssignment">
        <source>Invalid assignment</source>
        <target state="translated">Ungültige Zuweisung.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfTypeName">
        <source>Invalid use of a type name</source>
        <target state="translated">Unzulässige Verwendung eines Typnamens.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoAccessibleConstructor">
        <source>This type has no accessible object constructors</source>
        <target state="translated">Dieser Typ verfügt über keine zugreifbaren Objektkonstruktoren.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfInterfaceType">
        <source>Invalid use of an interface type</source>
        <target state="translated">Unzulässige Verwendung eines Schnittstellentyps.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfDelegate">
        <source>Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'.</source>
        <target state="translated">Unzulässige Verwendung eines Delegatkonstruktors. Verwenden Sie die Syntax "new Type(args)" oder einfach nur "Type(args)".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotStatic">
        <source>Property '{0}' is not static</source>
        <target state="translated">Die {0}-Eigenschaft ist nicht statisch.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotReadable">
        <source>Property '{0}' is not readable</source>
        <target state="translated">Die {0}-Eigenschaft ist nicht lesbar.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLookupMayNotBeUsedHere">
        <source>This lookup cannot be used here</source>
        <target state="translated">Dieses Lookup kann an dieser Stelle nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsStatic">
        <source>Property '{0}' is static</source>
        <target state="translated">Die {0}-Eigenschaft ist statisch.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet1">
        <source>Property '{0}' cannot be set</source>
        <target state="translated">Die {0}-Eigenschaft kann nicht festgelegt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsCannotBeFirstClassValues">
        <source>Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</source>
        <target state="translated">Konstruktoren müssen auf Argumente angewendet werden und dürfen nicht als Werte der ersten Klasse verwendet werden. Verwenden Sie bei Bedarf eine anonyme Funktion "(fun arg1 ... argN -&gt; new Type(arg1,...,argN))".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
        <source>The syntax 'expr.id' may only be used with record labels, properties and fields</source>
        <target state="translated">Die Syntax "expr.id" darf nur für Datensatzbezeichnungen, Eigenschaften und Felder verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsStatic">
        <source>Event '{0}' is static</source>
        <target state="translated">Das {0}-Ereignis ist statisch.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsNotStatic">
        <source>Event '{0}' is not static</source>
        <target state="translated">Das {0}-Ereignis ist nicht statisch.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentDidNotMatch">
        <source>The named argument '{0}' did not match any argument or mutable property</source>
        <target state="translated">Das benannte Argument "{0}" stimmt mit keinem Argument und keiner änderbaren Eigenschaft überein.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverloadsCannotHaveCurriedArguments">
        <source>One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.</source>
        <target state="translated">Mindestens eine der Überladungen dieser Methode besitzt Curryargumente. Definieren Sie diese Member so um, dass sie Argumente als Tupel akzeptieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnnamedArgumentsDoNotFormPrefix">
        <source>The unnamed arguments do not form a prefix of the arguments of the method called</source>
        <target state="translated">Die unbenannten Argumente bilden kein Präfix der Argumente der aufgerufenen Methode.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
        <source>Static optimization conditionals are only for use within the F# library</source>
        <target state="translated">Statische bedingte Optimierungsausdrücke sind nur für die Verwendung innerhalb der F#-Bibliothek vorgesehen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFormalArgumentIsNotOptional">
        <source>The corresponding formal argument is not optional</source>
        <target state="translated">Das entsprechende Formalargument ist nicht optional.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOptionalAssignmentToPropertyOrField">
        <source>Invalid optional assignment to a property or field</source>
        <target state="translated">Ungültige optionale Zuweisung zu einer Eigenschaft oder einem Feld.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegateConstructorMustBePassed">
        <source>A delegate constructor must be passed a single function value</source>
        <target state="translated">Einem Delegatkonstruktor muss ein einzelner Funktionswert übergeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindingCannotBeUseAndRec">
        <source>A binding cannot be marked both 'use' and 'rec'</source>
        <target state="translated">Eine Bindung kann nicht gleichzeitig als "use" und "rec" markiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileOnlyOnClassLetBindings">
        <source>The 'VolatileField' attribute may only be used on 'let' bindings in classes</source>
        <target state="translated">Das VolatileField-Attribut kann nur für let-Bindungen in Klassen verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesAreNotPermittedOnLetBindings">
        <source>Attributes are not permitted on 'let' bindings in expressions</source>
        <target state="translated">Attribute sind für let-Bindungen in Ausdrücken nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultValueAttributeRequiresVal">
        <source>The 'DefaultValue' attribute may only be used on 'val' declarations</source>
        <target state="translated">Das DefaultValue-Attribut darf nur für val-Deklarationen verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeRequiresMembers">
        <source>The 'ConditionalAttribute' attribute may only be used on members</source>
        <target state="translated">Das ConditionalAttribute-Attribut darf nur für Member verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidActivePatternName">
        <source>This is not a valid name for an active pattern</source>
        <target state="translated">Dies ist kein gültiger Name für ein aktives Muster.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEntryPointAttributeRequiresFunctionInModule">
        <source>The 'EntryPointAttribute' attribute may only be used on function definitions in modules</source>
        <target state="translated">Das EntryPointAttribute-Attribut darf nur für Funktionsdefinitionen in Modulen verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesCannotBeInline">
        <source>Mutable values cannot be marked 'inline'</source>
        <target state="translated">Änderbare Werte können nicht als "inline" markiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesMayNotHaveGenericParameters">
        <source>Mutable values cannot have generic parameters</source>
        <target state="translated">Änderbare Werte dürfen keine generischen Parameter aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesSyntax">
        <source>Mutable function values should be written 'let mutable f = (fun args -&gt; ...)'</source>
        <target state="translated">Änderbare Funktionswerte sollten im Format "let mutable f = (fun args -&gt; ...)" angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyFunctionsCanBeInline">
        <source>Only functions may be marked 'inline'</source>
        <target state="translated">Nur Funktionen dürfen als "inline" markiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalAttributesForLiteral">
        <source>A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes</source>
        <target state="translated">Ein Literalwert kann nicht mit den Attributen "[&lt;ThreadStatic&gt;]" oder "[&lt;ContextStatic&gt;]" versehen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeMutable">
        <source>A literal value cannot be marked 'mutable'</source>
        <target state="translated">Ein Literalwert kann nicht als "mutable" markiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeInline">
        <source>A literal value cannot be marked 'inline'</source>
        <target state="translated">Ein Literalwert kann nicht als "inline" markiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotHaveGenericParameters">
        <source>Literal values cannot have generic parameters</source>
        <target state="translated">Literalwerte dürfen keine generischen Parameter aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstantExpression">
        <source>This is not a valid constant expression</source>
        <target state="translated">Dies ist kein gültiger konstanter Ausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsInaccessible">
        <source>This type is not accessible from this code location</source>
        <target state="translated">Auf diesen Typ kann von dieser Position im Code nicht zugegriffen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConditionInImportedAssembly">
        <source>Unexpected condition in imported assembly: failed to decode AttributeUsage attribute</source>
        <target state="translated">Unerwartete Bedingung in importierter Assembly: Fehler beim Decodieren des AttributeUsage-Attributs.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedAttributeTarget">
        <source>Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</source>
        <target state="translated">Unbekanntes Attributziel. Gültige Attributziele sind "assembly", "module", "type", "method", "property", "return", "param", "field", "event", "constructor".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElementUseDo">
        <source>This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module.</source>
        <target state="translated">Dieses Attribut ist für dieses Sprachelement nicht gültig. Assemblyattribute sollten an eine "do ()"-Deklaration angefügt werden, falls notwendig innerhalb eines F#-Moduls.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElement">
        <source>This attribute is not valid for use on this language element</source>
        <target state="translated">Dieses Attribut ist für dieses Sprachelement nicht gültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgumentsCannotBeUsedInCustomAttribute">
        <source>Optional arguments cannot be used in custom attributes</source>
        <target state="translated">Optionale Argumente dürfen nicht für benutzerdefinierte Attribute verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet0">
        <source>This property cannot be set</source>
        <target state="translated">Diese Eigenschaft kann nicht festgelegt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyOrFieldNotFoundInAttribute">
        <source>This property or field was not found on this custom attribute type</source>
        <target state="translated">Diese Eigenschaft bzw. dieses Feld wurde in diesem benutzerdefinierten Attributtyp nicht gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustBeReferenceType">
        <source>A custom attribute must be a reference type</source>
        <target state="translated">Ein benutzerdefiniertes Attribut muss ein Verweistyp sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeArgumentMismatch">
        <source>The number of args for a custom attribute does not match the expected number of args for the attribute constructor</source>
        <target state="translated">Die Anzahl der Argumente für ein benutzerdefiniertes Attribut stimmt nicht mit der erwarteten Argumentzahl für den Attributkonstruktor überein.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustInvokeConstructor">
        <source>A custom attribute must invoke an object constructor</source>
        <target state="translated">Ein benutzerdefiniertes Attribut muss einen Objektkonstruktor aufrufen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeExpressionsMustBeConstructorCalls">
        <source>Attribute expressions must be calls to object constructors</source>
        <target state="translated">Attributausdrücke müssen Aufrufe von Objektkonstruktoren sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedAttribute">
        <source>This attribute cannot be used in this version of F#</source>
        <target state="translated">Dieses Attribut kann in dieser Version von F# nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidInlineSpecification">
        <source>Invalid inline specification</source>
        <target state="translated">Ungültige Inlinespezifikation</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBinding">
        <source>'use' bindings must be of the form 'use &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">Use-Bindungen müssen das Format "use &lt;var&gt; = &lt;Ausdruck&gt;" aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractMembersIllegalInAugmentation">
        <source>Abstract members are not permitted in an augmentation - they must be defined as part of the type itself</source>
        <target state="translated">Abstrakte Member sind in einer Augmentation nicht zulässig, sondern müssen als Teil des Typs selbst definiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodOverridesIllegalHere">
        <source>Method overrides and interface implementations are not permitted here</source>
        <target state="translated">Methodenüberschreibungen und Schnittstellenimplementierungen sind an dieser Stelle nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoMemberFoundForOverride">
        <source>No abstract or interface member was found that corresponds to this override</source>
        <target state="translated">Es wurde keine abstrakter Member und kein Schnittstellenmember gefunden, der dieser Überschreibung entspricht.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverrideArityMismatch">
        <source>This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:{0}</source>
        <target state="translated">Diese Überschreibung akzeptiert eine andere Anzahl von Argumenten als der entsprechende abstrakte Member. Die folgenden abstrakten Members wurden gefunden: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationAlreadyExists">
        <source>This method already has a default implementation</source>
        <target state="translated">Für diese Methode ist bereits eine Standardimplementierung vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultAmbiguous">
        <source>The method implemented by this default is ambiguous</source>
        <target state="translated">Die von dieser Standardimplementierung implementierte Methode ist nicht eindeutig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoPropertyFoundForOverride">
        <source>No abstract property was found that corresponds to this override</source>
        <target state="translated">Es wurde kein abstrakte Eigenschaft gefunden, die dieser Überschreibung entspricht.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractPropertyMissingGetOrSet">
        <source>This property overrides or implements an abstract property but the abstract property doesn't have a corresponding {0}</source>
        <target state="translated">Diese Eigenschaft überschreibt oder implementiert eine abstrakte Eigenschaft, aber für die abstrakte Eigenschaft ist kein(e) entsprechende(r/s) {0} vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSignatureForSet">
        <source>Invalid signature for set member</source>
        <target state="translated">Ungültige Signatur für festgelegten Member.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMember">
        <source>This new member hides the abstract member '{0}'. Rename the member or use 'override' instead.</source>
        <target state="translated">Dieser neue Member verbirgt den abstrakten Member "{0}". Benennen Sie den Member um, oder verwenden Sie stattdessen "override".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMemberWithSuffix">
        <source>This new member hides the abstract member '{0}' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead.</source>
        <target state="translated">Dieser neue Member verbirgt den abstrakten Member "{0}", nachdem alle Tupel, Funktionen, Maßeinheiten und/oder angegebene Typen gelöscht wurden. Benennen Sie den Member um, oder verwenden Sie stattdessen "override".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializersIllegalInInterface">
        <source>Interfaces cannot contain definitions of static initializers</source>
        <target state="translated">Schnittstellen dürfen keine Definitionen von statischen Initialisierern enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsIllegalInInterface">
        <source>Interfaces cannot contain definitions of object constructors</source>
        <target state="translated">Schnittstellen dürfen keine Definitionen von Objektkonstruktoren enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOverridesIllegalInInterface">
        <source>Interfaces cannot contain definitions of member overrides</source>
        <target state="translated">Schnittstellen dürfen keine Definitionen von Memberüberschreibungen enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConcreteMembersIllegalInInterface">
        <source>Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.</source>
        <target state="translated">Schnittstellen dürfen keine Definitionen konkreter Member enthalten. Sie müssen ggf. einen Konstruktor für den Typ definieren, um anzugeben, dass es sich bei dem Typ um eine Klasse handelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsDisallowedInExceptionAugmentation">
        <source>Constructors cannot be specified in exception augmentations</source>
        <target state="translated">Konstruktoren können nicht in Ausnahmeaugmentationen angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCannotHaveConstructorWithNoArguments">
        <source>Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.</source>
        <target state="translated">Strukturen dürfen keinen Objektkonstruktor ohne Argumente aufweisen. Diese Einschränkung gilt für alle CLI-Sprachen, da Strukturen automatisch einen Standardkonstruktor unterstützen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalForThisType">
        <source>Constructors cannot be defined for this type</source>
        <target state="translated">Für diesen Typ können keine Konstruktoren definiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
        <source>Recursive bindings that include member specifications can only occur as a direct augmentation of a type</source>
        <target state="translated">Rekursive Bindungen mit Memberspezifikationen dürfen nur als direkte Augmentation eines Typs auftreten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimplePatternsInLetRec">
        <source>Only simple variable patterns can be bound in 'let rec' constructs</source>
        <target state="translated">In "let rec"-Konstrukten können nur einfache Variablenmuster gebunden werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
        <source>Only record fields and simple, non-recursive 'let' bindings may be marked mutable</source>
        <target state="translated">Nur Datensatzfelder und einfache, nicht rekursive let-Bindungen dürfen als "mutable" markiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberIsNotSufficientlyGeneric">
        <source>This member is not sufficiently generic</source>
        <target state="translated">Dieser Member ist nicht generisch genug.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralAttributeRequiresConstantValue">
        <source>A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. 'val x : int = 1'</source>
        <target state="translated">Eine Deklaration darf nur dann als [&lt;Literal&gt;]-Attribut verwendet werden, wenn auch ein Konstantenwert angegeben wird, z.B. "val x : int = 1".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcValueInSignatureRequiresLiteralAttribute">
        <source>A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute</source>
        <target state="translated">Einer Deklaration kann nur dann ein Wert in einer Signatur zugewiesen werden, wenn die Deklaration mit dem [&lt;Literal&gt;]-Attribut versehen ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThreadStaticAndContextStaticMustBeStatic">
        <source>Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread</source>
        <target state="translated">Threadstatische und kontextstatische Variablen müssen statisch sein und mit dem [&lt;DefaultValue&gt;]-Attribut versehen werden, um anzugeben, dass der Wert bei jedem neuen Thread mit dem Standardwert initialisiert wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileFieldsMustBeMutable">
        <source>Volatile fields must be marked 'mutable' and cannot be thread-static</source>
        <target state="translated">Flüchtige Felder müssen als "mutable" markiert werden und können nicht threadstatisch sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUninitializedValFieldsMustBeMutable">
        <source>Uninitialized 'val' fields must be mutable and marked with the '[&lt;DefaultValue&gt;]' attribute. Consider using a 'let' binding instead of a 'val' field.</source>
        <target state="translated">Nicht initialisierte val-Felder müssen änderbar sein und mit dem [&lt;DefaultValue&gt;]-Attribut versehen werden. Verwenden Sie eine let-Bindung anstelle eines val-Felds.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticValFieldsMustBeMutableAndPrivate">
        <source>Static 'val' fields in types must be mutable, private and marked with the '[&lt;DefaultValue&gt;]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type.</source>
        <target state="translated">Statische val-Felder in Typen müssen änderbar und privat sein und mit dem [&lt;DefaultValue&gt;]-Attribut versehen werden. Sie werden mit dem NULL- oder 0-Wert für ihren Typ initialisiert. Verwenden Sie ggf. zusätzlich eine "static let mutable"-Bindung in einem Klassentyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresName">
        <source>This field requires a name</source>
        <target state="translated">Für dieses Feld ist ein Name erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNamespaceModuleTypeUnionName">
        <source>Invalid namespace, module, type or union case name</source>
        <target state="translated">Ungültiger Namespace-, Modul-, Typ- oder Union-Fallname.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalFormForExplicitTypeDeclaration">
        <source>Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -&gt; resTy'. Parentheses may be required around 'resTy'</source>
        <target state="translated">Explizite Typdeklarationen für Konstruktoren müssen im Format "ty1 * ... * tyN -&gt; resTy" angegeben werden. Möglicherweise muss "resTy" in Klammern gesetzt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnTypesForUnionMustBeSameAsType">
        <source>Return types of union cases must be identical to the type being defined, up to abbreviations</source>
        <target state="translated">Rückgabetypen von Union-Fällen müssen genau mit dem definierten Typ übereinstimmen, bis hin zu den Abkürzungen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumerationLiteral">
        <source>This is not a valid value for an enumeration literal</source>
        <target state="translated">Dies ist kein gültiger Wert für ein Enumerationsliteral.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType1">
        <source>The type '{0}' is not an interface type</source>
        <target state="translated">Der Typ "{0}" ist kein Schnittstellentyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDuplicateSpecOfInterface">
        <source>Duplicate specification of an interface</source>
        <target state="translated">Doppelte Schnittstellenspezifikation.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldValIllegalHere">
        <source>A field/val declaration is not permitted here</source>
        <target state="translated">Eine Feld/Wert-Deklaration ist an dieser Stelle nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritIllegalHere">
        <source>A inheritance declaration is not permitted here</source>
        <target state="translated">Eine Vererbungsdeklaration ist an dieser Stelle nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleRequiresQualifiedAccess">
        <source>This declaration opens the module '{0}', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.</source>
        <target state="translated">Diese Deklaration öffnet das Modul "{0}", das als "RequireQualifiedAccess" markiert ist. Passen Sie den Code an, indem Sie stattdessen qualifizierte Verweise auf die Modulelemente verwenden. Beispiel: "List.map" anstelle von "map". Durch diese Änderung stellen Sie sicher, dass der Code auch dann stabil bleibt, wenn die Bibliotheken um neue Konstrukte ergänzt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenUsedWithPartiallyQualifiedPath">
        <source>This declaration opens the namespace or module '{0}' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.</source>
        <target state="translated">Mit dieser Deklaration wird der Namespace oder das Modul "{0}" über einen teilweise qualifizierten Pfad geöffnet. Passen Sie den Code an, und fügen Sie den vollständigen Pfad des Namespace hinzu. Durch diese Änderung bleibt der Code auch dann stabil, wenn die F#- und CLI-Bibliotheken um neue Konstrukte ergänzt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLocalClassBindingsCannotBeInline">
        <source>Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.</source>
        <target state="translated">Lokale Klassenbindungen können nicht als "inline" markiert werden. Entfernen Sie die Definition aus der Klasse, oder markieren Sie sie nicht als "inline".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsMayNotHaveMembers">
        <source>Type abbreviations cannot have members</source>
        <target state="translated">Typabkürzungen dürfen keine Member aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCheckedAtCompileTime">
        <source>As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.</source>
        <target state="translated">Ab F# 4.1 wird die Zugreifbarkeit von Typabkürzungen zur Kompilierzeit überprüft. Sie sollten die Zugreifbarkeit der Typabkürzung ggf. ändern. Das Ignorieren dieser Warnung führt möglicherweise zu Laufzeitfehlern.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsMayNotHaveMembers">
        <source>Enumerations cannot have members</source>
        <target state="translated">Enumerationen dürfen keine Member aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembers">
        <source>Measure declarations may have only static members</source>
        <target state="translated">Maßeinheitendeklarationen dürfen nur statische Member enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainDoBindings">
        <source>Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings</source>
        <target state="translated">Strukturen dürfen keine do-Bindungen enthalten, da der Standardkonstruktor für Strukturen diese Bindungen nicht ausführen würde.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainLetBindings">
        <source>Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.</source>
        <target state="translated">Strukturen dürfen keine Wertdefinitionen enthalten, da der Standardkonstruktor für Strukturen diese Bindungen nicht ausführt. Fügen Sie dem primären Konstruktor für diesen Typ ggf. zusätzliche Argumente hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticLetBindingsRequireClassesWithImplicitConstructors">
        <source>Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Statische Wertdefinitionen dürfen nur in Typen mit einem primären Konstruktor verwendet werden. Ziehen Sie in Betracht, Argumente zur Typdefinition hinzuzufügen, z. B. "type X(args) = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembersNotConstructors">
        <source>Measure declarations may have only static members: constructors are not available</source>
        <target state="translated">Maßeinheitendeklarationen dürfen nur statische Member enthalten: Konstruktoren sind nicht verfügbar.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberAndLocalClassBindingHaveSameName">
        <source>A member and a local class binding both have the name '{0}'</source>
        <target state="translated">Ein Member und eine lokale Klassenbindung haben beide den Namen "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
        <source>Type abbreviations cannot have interface declarations</source>
        <target state="translated">Typabkürzungen dürfen keine Schnittstellendeklarationen aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsCannotHaveInterfaceDeclaration">
        <source>Enumerations cannot have interface declarations</source>
        <target state="translated">Enumerationen dürfen keine Schnittstellendeklarationen aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType0">
        <source>This type is not an interface type</source>
        <target state="translated">Dieser Typ ist kein Schnittstellentyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllImplementedInterfacesShouldBeDeclared">
        <source>All implemented interfaces should be declared on the initial declaration of the type</source>
        <target state="translated">Alle implementierten Schnittstellen sollten in der anfänglichen Deklaration des Typs deklariert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
        <source>A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type</source>
        <target state="translated">Es wurde bereits eine Standardimplementierung dieser Schnittstelle hinzugefügt, weil die explizite Implementierung der Schnittstelle nicht in der Typdefinition angegeben war.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberNotPermittedInInterfaceImplementation">
        <source>This member is not permitted in an interface implementation</source>
        <target state="translated">Dieser Member ist in einer Schnittstellenimplementierung unzulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclarationElementNotPermittedInAugmentation">
        <source>This declaration element is not permitted in an augmentation</source>
        <target state="translated">Dieses Deklarationselement ist in einer Augmentation nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotContainNestedTypes">
        <source>Types cannot contain nested type definitions</source>
        <target state="translated">Typen dürfen keine geschachtelten Typdefinitionen enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeExceptionOrModule">
        <source>type, exception or module</source>
        <target state="translated">Typ, Ausnahme oder Modul</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeOrModule">
        <source>type or module</source>
        <target state="translated">Typ oder Modul</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type.</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" implementiert die System.IStructuralEquatable-Schnittstelle explizit. Wenden Sie das CustomEquality-Attribut auf den Typ an.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IEquatable&lt;_&gt;' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'.</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" implementiert die System.IEquatable&lt;_&gt;-Schnittstelle explizit. Wenden Sie das CustomEquality-Attribut auf den Typ an, und stellen Sie eine einheitliche Implementierung der nicht generischen System.Object.Equals(obj)-Überschreibung bereit.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
        <source>Explicit type specifications cannot be used for exception constructors</source>
        <target state="translated">Explizite Typspezifikationen dürfen nicht für Ausnahmekonstruktoren verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsShouldNotHaveArgumentList">
        <source>Exception abbreviations should not have argument lists</source>
        <target state="translated">Ausnahmeabkürzungen sollten keine Argumentlisten aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
        <source>Abbreviations for Common IL exceptions cannot take arguments</source>
        <target state="translated">Abkürzungen für Common IL-Ausnahmen können keine Argumente akzeptieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsMustReferToValidExceptions">
        <source>Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception</source>
        <target state="translated">Ausnahmeabkürzungen müssen auf vorhandene Ausnahmen oder F#-Typen verweisen, die von "System.Exception" abgeleitet sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
        <source>Abbreviations for Common IL exception types must have a matching object constructor</source>
        <target state="translated">Abkürzungen für Common IL-Ausnahmetypen müssen einen entsprechenden Objektkonstruktor aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotAnException">
        <source>Not an exception</source>
        <target state="translated">Keine Ausnahme.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidModuleName">
        <source>Invalid module name</source>
        <target state="translated">Ungültiger Modulname.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeExtension">
        <source>Invalid type extension</source>
        <target state="translated">Ungültige Typerweiterung.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesOfTypeSpecifyMultipleKindsForType">
        <source>The attributes of this type specify multiple kinds for the type</source>
        <target state="translated">Die Attribute dieses Typs geben mehrere Arten für den Typ an.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcKindOfTypeSpecifiedDoesNotMatchDefinition">
        <source>The kind of the type specified by its attributes does not match the kind implied by its definition</source>
        <target state="translated">Der von den Attributen angegebene Typ stimmt nicht mit der von der Definition implizierten Art überein.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDefinitionsCannotHaveTypeParameters">
        <source>Measure definitions cannot have type parameters</source>
        <target state="translated">Maßeinheitendefinitionen dürfen keine Typparameter aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeRequiresDefinition">
        <source>This type requires a definition</source>
        <target state="translated">Dieser Typ erfordert eine Definition.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationHasTypeParametersMissingOnType">
        <source>This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C&lt;'a&gt; = C of ...'.</source>
        <target state="translated">Für diese Typabkürzung ist mindestens ein Typparameter deklariert, der in dem abgekürzten Typ nicht erscheint. Typabkürzungen müssen alle deklarierten Typparameter im abgekürzten Typ verwenden. Entfernen Sie mindestens einen Typparameter, oder verwenden Sie eine konkrete Typdefinition, die einen zugrundeliegenden Typ umschließt, z.B. "type C&lt;'a&gt; = C of ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
        <source>Structs, interfaces, enums and delegates cannot inherit from other types</source>
        <target state="translated">Strukturen, Schnittstellen, Enumerationen und Delegaten können nicht von anderen Typen erben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotInheritFromMultipleConcreteTypes">
        <source>Types cannot inherit from multiple concrete types</source>
        <target state="translated">Typen können nicht von mehreren konkreten Typen erben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
        <source>Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute</source>
        <target state="translated">Datensatz, Union-, Abkürzungs- und Strukturtypen dürfen nicht das AllowNullLiteral-Attribut aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
        <source>Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal</source>
        <target state="translated">Typen mit dem AllowNullLiteral-Attribut können nur von Typen erben bzw. diese implementieren, die die Verwendung des NULL-Literals ebenfalls zulassen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericTypesCannotHaveStructLayout">
        <source>Generic types cannot be given the 'StructLayout' attribute</source>
        <target state="translated">Generische Typen können nicht mit dem StructLayout-Attribut versehen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyStructsCanHaveStructLayout">
        <source>Only structs and classes without primary constructors may be given the 'StructLayout' attribute</source>
        <target state="translated">Nur Strukturen und Klassen ohne primäre Konstruktoren dürfen das StructLayout-Attribut erhalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRepresentationOfTypeHiddenBySignature">
        <source>The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.</source>
        <target state="translated">Die Darstellung dieses Typs ist hinter der Signatur verborgen. Sie muss mit einem Attribut wie "[&lt;Sealed&gt;]", "[&lt;Class&gt;]" oder "[&lt;Interface&gt;]" versehen werden, um die Merkmale des Typs anzugeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyClassesCanHaveAbstract">
        <source>Only classes may be given the 'AbstractClass' attribute</source>
        <target state="translated">Nur Klassen dürfen das AbstractClass-Attribut erhalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
        <source>Only types representing units-of-measure may be given the 'Measure' attribute</source>
        <target state="translated">Nur Typen, die Maßeinheiten darstellen, dürfen das Measure-Attribut erhalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on overrides or interface implementations</source>
        <target state="translated">Zugriffsmodifizierer sind für Überschreibungen oder Schnittstellenimplementierungen nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDU">
        <source>Discriminated union types are always sealed</source>
        <target state="translated">Diskriminierte Union-Typen sind immer versiegelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedRecord">
        <source>Record types are always sealed</source>
        <target state="translated">Datensatztypen sind immer versiegelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedAssemblyCode">
        <source>Assembly code types are always sealed</source>
        <target state="translated">Assemblycodetypen sind immer versiegelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedStruct">
        <source>Struct types are always sealed</source>
        <target state="translated">Strukturtypen sind immer versiegelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDelegate">
        <source>Delegate types are always sealed</source>
        <target state="translated">Delegattypen sind immer versiegelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedEnum">
        <source>Enum types are always sealed</source>
        <target state="translated">Enumerationstypen sind immer versiegelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesAndDelegatesCannotContainFields">
        <source>Interface types and delegate types cannot contain fields</source>
        <target state="translated">Schnittstellentypen und Delegattypen dürfen keine Felder enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviatedTypesCannotBeSealed">
        <source>Abbreviated types cannot be given the 'Sealed' attribute</source>
        <target state="translated">Abgekürzte Typen können nicht mit dem Sealed-Attribut versehen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromSealedType">
        <source>Cannot inherit a sealed type</source>
        <target state="translated">Von einem versiegelten Typ kann nicht geerbt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromInterfaceType">
        <source>Cannot inherit from interface type. Use interface ... with instead.</source>
        <target state="translated">Vom Schnittstellentyp kann nicht geerbt werden. Verwenden Sie stattdessen "interface ... with".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructTypesCannotContainAbstractMembers">
        <source>Struct types cannot contain abstract members</source>
        <target state="translated">Strukturtypen dürfen keine abstrakten Member enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesCannotBeSealed">
        <source>Interface types cannot be sealed</source>
        <target state="translated">Schnittstellentypen dürfen nicht versiegelt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDelegateSpecification">
        <source>Delegate specifications must be of the form 'typ -&gt; typ'</source>
        <target state="translated">Delegatspezifikationen müssen das Format "typ -&gt; typ" aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegatesCannotBeCurried">
        <source>Delegate specifications must not be curried types. Use 'typ * ... * typ -&gt; typ' for multi-argument delegates, and 'typ -&gt; (typ -&gt; typ)' for delegates returning function values.</source>
        <target state="translated">Delegatspezifikationen dürfen keine Currytypen sein. Verwenden Sie "typ * ... * typ -&gt; typ" für Delegaten mit mehreren Argumenten und "typ -&gt; (typ -&gt; typ)" für Delegaten, die Funktionswerte zurückgeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForLiteralEnumeration">
        <source>Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char</source>
        <target state="translated">Literalenumerationen müssen den Typ "int", "uint", "int16", "uint16", "int64", "uint64", "byte", "sbyte" oder "char" aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclic">
        <source>This type definition involves an immediate cyclic reference through an abbreviation</source>
        <target state="translated">Diese Typdefinition umfasst einen sofortigen zyklischen Verweis über eine Abkürzung.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclicThroughInheritance">
        <source>This type definition involves an immediate cyclic reference through a struct field or inheritance relation</source>
        <target state="translated">Diese Typdefinition umfasst einen sofortigen zyklischen Verweis über ein Strukturfeld oder eine Vererbungsbeziehung.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReservedSyntaxForAugmentation">
        <source>The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[&lt;Sealed&gt;] attribute to the type definition in the signature</source>
        <target state="translated">Die Syntax "type X with ..." ist für Augmentationen reserviert. Typen, deren Darstellung verborgen ist, die aber Member aufweisen, werden jetzt mithilfe von "type X = ..." in Signaturen deklariert. Möglicherweise müssen Sie der Typdefinition in der Signatur auch das [&lt;Sealed&gt;]-Attribut hinzufügen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
        <source>Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.</source>
        <target state="translated">Member, die Schnittstellen-, Delegat- oder Enumerationstypen erweitern, müssen in einem von der Typdefinition getrennten eigenen Modul platziert werden. Dieses Modul muss entweder mit dem AutoOpen-Attribut versehen oder vom Clientcode explizit geöffnet werden, um die Erweiterungsmember in den Bereich einzubinden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal">
        <source>One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '{0}'</source>
        <target state="translated">Mindestens ein deklarierter Typparameter für diese Typerweiterung verfügt über keine oder eine falsche Typeinschränkung, die nicht mit der ursprünglichen Typeinschränkung "{0}" übereinstimmt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
        <source>Type definitions may only have one 'inherit' specification and it must be the first declaration</source>
        <target state="translated">Typdefinitionen dürfen nur eine inherit-Angabe aufweisen, und diese muss die erste Deklaration sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
        <source>'let' and 'do' bindings must come before member and interface definitions in type definitions</source>
        <target state="translated">let- und "do"-Bindungen müssen in Typdefinitionen vor Member- und Schnittstellendefinitionen kommen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritDeclarationMissingArguments">
        <source>This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'.</source>
        <target state="translated">Diese inherit-Deklaration gibt zwar den geerbten Typ an, aber keine Argumente. Stellen Sie ggf. Argumente bereit, z.B. "inherit BaseType(args)".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritConstructionCallNotPartOfImplicitSequence">
        <source>This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Diese "inherit"-Daklaration hat Argumente, ist jedoch nicht in einem Typ mit einem primären Konstruktor. Ziehen Sie in Betracht, Argumente zur Typdefinition hinzuzufügen, z. B. "type X(args) = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLetAndDoRequiresImplicitConstructionSequence">
        <source>This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Diese Definition kann nur in einem Typ mit einem primären Konstruktor verwendet werden. Ziehen Sie in Betracht, Argumente zur Typdefinition hinzuzufügen, z. B. "type X(args) = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveAugmentations">
        <source>Type abbreviations cannot have augmentations</source>
        <target state="translated">Typabkürzungen dürfen keine Augmentationen aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbreviationForNamespace">
        <source>The path '{0}' is a namespace. A module abbreviation may not abbreviate a namespace.</source>
        <target state="translated">Der Pfad "{0}" ist ein Namespace. Eine Modulabkürzung darf nicht zum Abkürzen von Namespaces verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeUsedInInvalidWay">
        <source>The type '{0}' is used in an invalid way. A value prior to '{1}' has an inferred type involving '{2}', which is an invalid forward reference.</source>
        <target state="translated">Die Verwendung des Typs "{0}" ist ungültig. Ein Wert vor "{1}" hat einen per Rückschluss abgeleiteten Typ mit "{2}"; dies ist ein ungültiger Vorwärtsverweis.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to the definition of '{2}', which is an invalid forward reference.</source>
        <target state="translated">Die Verwendung des Members "{0}" ist ungültig. Die Verwendung von "{1}" wurde vor der Definition von "{2}" per Rückschluss abgeleitet; dies ist ein ungültiger Vorwärtsverweis.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeAutoOpenWasIgnored">
        <source>The attribute 'AutoOpen(\"{0}\")' in the assembly '{1}' did not refer to a valid module or namespace in that assembly and has been ignored</source>
        <target state="translated">Das AutoOpen(\"{0}\")-Attribut in der Assembly "{1}" verweist nicht auf ein gültiges Modul oder einen gültigen Namespace in der Assembly; es wird deshalb ignoriert.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUndefinedValue">
        <source>Undefined value '{0}'</source>
        <target state="translated">Nicht definierter Wert "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLabelNotFound">
        <source>Label {0} not found</source>
        <target state="translated">Bezeichnung "{0}" nicht gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilIncorrectNumberOfTypeArguments">
        <source>Incorrect number of type arguments to local call</source>
        <target state="translated">Fehlerhafte Anzahl von Typargumenten für lokalen Aufruf.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDynamicInvocationNotSupported">
        <source>Dynamic invocation of {0} is not supported</source>
        <target state="translated">Der dynamische Aufruf von {0} wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfLiteralFieldIsInvalid">
        <source>Taking the address of a literal field is invalid</source>
        <target state="translated">Das Übernehmen der Adresse eines Literalfelds ist unzulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfValueHereIsInvalid">
        <source>This operation involves taking the address of a value '{0}' represented using a local variable or other special representation. This is invalid.</source>
        <target state="translated">Bei diesem Vorgang wird die Adresse eines Werts "{0}" übernommen, der durch eine lokale Variable oder eine andere Spezialdarstellung dargestellt wird. Dies ist unzulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilCustomMarshallersCannotBeUsedInFSharp">
        <source>Custom marshallers cannot be specified in F# code. Consider using a C# helper function.</source>
        <target state="translated">Benutzerdefinierte Marshaller dürfen im F#-Code nicht angegeben werden. Verwenden Sie eine C#-Hilfsfunktion.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMarshalAsAttributeCannotBeDecoded">
        <source>The MarshalAs attribute could not be decoded</source>
        <target state="translated">Das MarshalAs-Attribut konnte nicht decodiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignatureForExternalFunctionContainsTypeParameters">
        <source>The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.</source>
        <target state="translated">Die Signatur für diese externe Funktion enthält Typparameter. Schränken Sie das Argument und die Rückgabetypen ein, und geben Sie die Typen der entsprechenden C-Funktion an.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDllImportAttributeCouldNotBeDecoded">
        <source>The DllImport attribute could not be decoded</source>
        <target state="translated">Das DllImport-Attribut konnte nicht decodiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLiteralFieldsCannotBeSet">
        <source>Literal fields cannot be set</source>
        <target state="translated">Literalfelder können nicht festgelegt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStaticMethodIsNotLambda">
        <source>GenSetStorage: {0} was represented as a static method but was not an appropriate lambda expression</source>
        <target state="translated">GenSetStorage: {0} wurde als statische Methode dargestellt, war aber kein geeigneter lambda-Ausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMutableVariablesCannotEscapeMethod">
        <source>Mutable variables cannot escape their method</source>
        <target state="translated">Änderbare Variablen können ihre Methode nicht mit Escapevorgängen außer Kraft setzen.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedUnrealizedValue">
        <source>Compiler error: unexpected unrealized value</source>
        <target state="translated">Compilerfehler: unerwarteter nicht realisierter Wert.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMainModuleEmpty">
        <source>Main module of program is empty: nothing will happen when it is run</source>
        <target state="translated">Das Hauptmodul des Programms ist leer: Beim Ausführen erfolgt keinerlei Aktion.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilTypeCannotBeUsedForLiteralField">
        <source>This type cannot be used for a literal field</source>
        <target state="translated">Dieser Typ kann nicht für ein Literalfeld verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedGetSetAnnotation">
        <source>Unexpected GetSet annotation on a property</source>
        <target state="translated">Unerwartete GetSet-Anmerkung für eine Eigenschaft.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldOffsetAttributeCouldNotBeDecoded">
        <source>The FieldOffset attribute could not be decoded</source>
        <target state="translated">Das FieldOffset-Attribut konnte nicht decodiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStructLayoutAttributeCouldNotBeDecoded">
        <source>The StructLayout attribute could not be decoded</source>
        <target state="translated">Das StructLayout-Attribut konnte nicht decodiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDefaultAugmentationAttributeCouldNotBeDecoded">
        <source>The DefaultAugmentation attribute could not be decoded</source>
        <target state="translated">Das DefaultAugmentation-Attribut konnte nicht decodiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilReflectedDefinitionsCannotUseSliceOperator">
        <source>Reflected definitions cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">Reflektierte Definitionen dürfen keinen Präfix-Splice-Operator "%" enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsProblemWithCodepage">
        <source>Problem with codepage '{0}': {1}</source>
        <target state="translated">Problem mit Codepage "{0}": {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyright">
        <source>Copyright (c) Microsoft Corporation. All Rights Reserved.</source>
        <target state="translated">Copyright (c) Microsoft Corporation. Alle Rechte vorbehalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyrightCommunity">
        <source>Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</source>
        <target state="translated">Freie Verteilung unter der MIT-Open Source-Lizenz.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNameOfOutputFile">
        <source>Name of the output file (Short form: -o)</source>
        <target state="translated">Name der Ausgabedatei (Kurzform: -o)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildConsole">
        <source>Build a console executable</source>
        <target state="translated">Ausführbare Konsolendatei erstellen</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildWindows">
        <source>Build a Windows executable</source>
        <target state="translated">Ausführbare Windows-Datei erstellen</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildLibrary">
        <source>Build a library (Short form: -a)</source>
        <target state="translated">Bibliothek erstellen (Kurzform: -a)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildModule">
        <source>Build a module that can be added to another assembly</source>
        <target state="translated">Modul erstellen, das einer anderen Assembly hinzugefügt werden kann</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDelaySign">
        <source>Delay-sign the assembly using only the public portion of the strong name key</source>
        <target state="translated">Assembly nur mit dem öffentlichen Teil des Schlüssels für einen starken Namen verzögert signieren</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPublicSign">
        <source>Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed</source>
        <target state="translated">Assembly mithilfe nur des öffentlichen Teils des Schlüssels für einen starken Namen öffentlich signieren und als signiert markieren</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWriteXml">
        <source>Write the xmldoc of the assembly to the given file</source>
        <target state="translated">XmlDoc der Assembly in angegebene Datei schreiben</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyFile">
        <source>Specify a strong name key file</source>
        <target state="translated">Datei mit einem Schlüssel für einen starken Namen angeben</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyContainer">
        <source>Specify a strong name key container</source>
        <target state="translated">Container mit einem Schlüssel für einen starken Namen angeben</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPlatform">
        <source>Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.</source>
        <target state="translated">Schränken Sie ein, auf welchen Plattformen dieser Code ausgeführt werden kann: "x86", "Itanium", "x64", "anycpu32bitpreferred" oder "anycpu". Der Standard ist "anycpu".</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoOpt">
        <source>Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.</source>
        <target state="translated">Binden Sie nur Optimierungsinformationen ein, die für die Implementierung von Inlinekonstrukten unbedingt erforderlich sind. Dies verhindert zwar modulübergreifende Inlinekonstrukte, verbessert aber die Binärkompatibilität.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoInterface">
        <source>Don't add a resource to the generated assembly containing F#-specific metadata</source>
        <target state="translated">Der generierten Assembly mit F#-spezifischen Metadaten keine Ressource hinzufügen</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSig">
        <source>Print the inferred interface of the assembly to a file</source>
        <target state="translated">Per Rückschluss abgeleitete Schnittstelle der Assembly in Datei ausgeben</target>
        <note />
      </trans-unit>
      <trans-unit id="optsReference">
        <source>Reference an assembly (Short form: -r)</source>
        <target state="translated">Auf eine Assembly verweisen (Kurzform: -r)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32res">
        <source>Specify a Win32 resource file (.res)</source>
        <target state="translated">Win32-Ressourcendatei (.res) angeben</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32manifest">
        <source>Specify a Win32 manifest file</source>
        <target state="translated">Win32-Manifestdatei angeben</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowin32manifest">
        <source>Do not include the default Win32 manifest</source>
        <target state="translated">Win32-Standardmanifest nicht einschließen</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedAllSource">
        <source>Embed all source files in the portable PDB file</source>
        <target state="translated">Alle Quelldateien in der portablen PDB-Datei einbetten</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedSource">
        <source>Embed specific source files in the portable PDB file</source>
        <target state="translated">Bestimmte Quelldateien in der portablen PDB-Datei einbetten</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLink">
        <source>Source link information file to embed in the portable PDB file</source>
        <target state="translated">Die Datei mit Quelllinkinformationen, die in die portable PDB-Datei eingebettet werden soll</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbeddedSourceRequirePortablePDBs">
        <source>--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">Die Option "--embed" wird nur bei der Ausgabe einer portablen PDB unterstützt (--debug:portable oder --debug:embedded).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLinkRequirePortablePDBs">
        <source>--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">Die Option "--sourcelink" wird nur bei der Ausgabe einer portablen PDB unterstützt (--debug:portable oder --debug:embedded).</target>
        <note />
      </trans-unit>
      <trans-unit id="srcFileTooLarge">
        <source>Source file is too large to embed in a portable PDB</source>
        <target state="translated">Die Quelldatei ist zu groß, um in eine portable PDB eingebettet zu werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResource">
        <source>Embed the specified managed resource</source>
        <target state="translated">Angegebene verwaltete Ressource einbetten</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLinkresource">
        <source>Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]</source>
        <target state="translated">Angegebene Ressource mit dieser Assembly verknüpfen; Resinfo-Format: &lt;Datei&gt;[,&lt;Zeichenfolgenname&gt;[,public|private]]</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebugPM">
        <source>Emit debug information (Short form: -g)</source>
        <target state="translated">Debuginformationen ausgeben (Kurzform: -g)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebug">
        <source>Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file).</source>
        <target state="translated">Geben Sie den Debugtyp an: vollständig, portabel, eingebettet, pdbonly. ("{0}" ist der Standardwert, wenn kein Debugtyp angegeben wird, und ermöglicht das Anfügen eines Debuggers an ein aktuell ausgeführtes Programm. "Portabel" ist ein plattformübergreifendes Format, "eingebettet" ein plattformübergreifendes, in die Ausgabedatei eingebettetes Format).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsOptimize">
        <source>Enable optimizations (Short form: -O)</source>
        <target state="translated">Optimierungen aktivieren (Kurzform: -O)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTailcalls">
        <source>Enable or disable tailcalls</source>
        <target state="translated">Endeaufrufe aktivieren oder deaktivieren</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDeterministic">
        <source>Produce a deterministic assembly (including module version GUID and timestamp)</source>
        <target state="translated">Deterministische Assembly erstellen (einschließlich Modulversions-GUID und Zeitstempel)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCrossoptimize">
        <source>Enable or disable cross-module optimizations</source>
        <target state="translated">Modulübergreifende Optimierungen aktivieren oder deaktivieren</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserrorPM">
        <source>Report all warnings as errors</source>
        <target state="translated">Alle Warnungen als Fehler melden</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserror">
        <source>Report specific warnings as errors</source>
        <target state="translated">Bestimmte Warnungen als Fehler melden</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarn">
        <source>Set a warning level (0-5)</source>
        <target state="translated">Warnstufe (0-5) bestimmen</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowarn">
        <source>Disable specific warning messages</source>
        <target state="translated">Bestimmte Warnmeldungen deaktivieren</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnOn">
        <source>Enable specific warnings that may be off by default</source>
        <target state="translated">Spezifische Warnungen aktivieren, die möglicherweise standardmäßig deaktiviert sind</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecked">
        <source>Generate overflow checks</source>
        <target state="translated">Überlaufprüfungen generieren</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDefine">
        <source>Define conditional compilation symbols (Short form: -d)</source>
        <target state="translated">Bedingte Kompilierungssymbole definieren (Kurzform: -d)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsMlcompatibility">
        <source>Ignore ML compatibility warnings</source>
        <target state="translated">ML-Kompatibilitätswarnungen ignorieren</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNologo">
        <source>Suppress compiler copyright message</source>
        <target state="translated">Compiler-Copyrightmeldung unterdrücken</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelp">
        <source>Display this usage message (Short form: -?)</source>
        <target state="translated">Diesen Hilfetext anzeigen (Kurzform: -?)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFile">
        <source>Read response file for more options</source>
        <target state="translated">Antwortdatei lesen, um weitere Optionen zu ermitteln</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCodepage">
        <source>Specify the codepage used to read source files</source>
        <target state="translated">Codepage zum Lesen von Quelldateien angeben</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUtf8output">
        <source>Output messages in UTF-8 encoding</source>
        <target state="translated">Ausgabemeldungen in UTF-8-Codierung</target>
        <note />
      </trans-unit>
      <trans-unit id="optsFullpaths">
        <source>Output messages with fully qualified paths</source>
        <target state="translated">Ausgabemeldungen mit vollqualifiziertem Pfad</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLib">
        <source>Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)</source>
        <target state="translated">Verzeichnis für den Includepfad angeben, der zum Auflösen von Quelldateien und -assemblys verwendet wird (Kurzform: -I)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBaseaddress">
        <source>Base address for the library to be built</source>
        <target state="translated">Basisadresse für die zu erstellende Bibliothek</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoframework">
        <source>Do not reference the default CLI assemblies by default</source>
        <target state="translated">Standardmäßig nicht auf die CLI-Standardassemblys verweisen</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStandalone">
        <source>Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated</source>
        <target state="translated">F#-Bibliothek und alle davon abhängigen DLLs, auf die verwiesen wird, statisch mit der generierten Assembly verknüpfen</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStaticlink">
        <source>Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.</source>
        <target state="translated">Die angegebene Assembly und alle davon abhängigen DLLs, auf die verwiesen wird, statisch verknüpfen. Hierfür ist ein Assemblyname wie "mylib" zu verwenden, kein DLL-Name.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResident">
        <source>Use a resident background compilation service to improve compiler startup times.</source>
        <target state="translated">Verwenden Sie einen residenten Hintergrundkompilierungsdienst, um die Startzeiten des Compilers zu verbessern.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPdb">
        <source>Name the output debug file</source>
        <target state="translated">Ausgabedebugdatei benennen</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSimpleresolution">
        <source>Resolve assembly references using directory-based rules rather than MSBuild resolution</source>
        <target state="translated">Assemblyverweise mithilfe von verzeichnisbasierten Regeln anstelle von MSBuild-Auflösung auflösen</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedTarget">
        <source>Unrecognized target '{0}', expected 'exe', 'winexe', 'library' or 'module'</source>
        <target state="translated">Unbekanntes Ziel "{0}", "exe", "winexe", "library" oder "module" wurde erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedDebugType">
        <source>Unrecognized debug type '{0}', expected 'pdbonly' or 'full'</source>
        <target state="translated">Unbekannter Debugtyp "{0}", "pdbonly" oder "full" wurde erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidWarningLevel">
        <source>Invalid warning level '{0}'</source>
        <target state="translated">Ungültige Warnstufe "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="optsShortFormOf">
        <source>Short form of '{0}'</source>
        <target state="translated">Kurzform von "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDeprecatedMsg">
        <source>The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.</source>
        <target state="translated">Die Befehlszeilenoption "--cliroot" ist veraltet. Verwenden Sie stattdessen einen expliziten Verweis auf eine bestimmte Kopie von "mscorlib.dll".</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDescription">
        <source>Use to override where the compiler looks for mscorlib.dll and framework components</source>
        <target state="translated">Dient zum Überschreiben des Speicherorts, an dem der Compiler nach "mscorlib.dll" und den Frameworkkomponenten sucht.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerOutputFiles">
        <source>- OUTPUT FILES -</source>
        <target state="translated">- AUSGABEDATEIEN -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerInputFiles">
        <source>- INPUT FILES -</source>
        <target state="translated">- EINGABEDATEIEN -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerResources">
        <source>- RESOURCES -</source>
        <target state="translated">- RESSOURCEN -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerCodeGen">
        <source>- CODE GENERATION -</source>
        <target state="translated">- CODEGENERIERUNG -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerAdvanced">
        <source>- ADVANCED -</source>
        <target state="translated">- ERWEITERT -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerMisc">
        <source>- MISCELLANEOUS -</source>
        <target state="translated">- VERSCHIEDENES -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerLanguage">
        <source>- LANGUAGE -</source>
        <target state="translated">- SPRACHE -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerErrsAndWarns">
        <source>- ERRORS AND WARNINGS -</source>
        <target state="translated">- FEHLER UND WARNUNGEN -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownArgumentToTheTestSwitch">
        <source>Unknown --test argument: '{0}'</source>
        <target state="translated">Unbekannt - Testargument: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownPlatform">
        <source>Unrecognized platform '{0}', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'</source>
        <target state="translated">Unbekannte Plattform "{0}", gültige Werte sind "x86", "x64", "Itanium", "anycpu32bitpreferred" und "anycpu".</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInternalNoDescription">
        <source>The command-line option '{0}' is for test purposes only</source>
        <target state="translated">Die Befehlszeilenoption "{0}" ist ausschließlich für Testzwecke bestimmt.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLONoDescription">
        <source>The command-line option '{0}' has been deprecated</source>
        <target state="translated">Die Befehlszeilenoption "{0}" ist veraltet.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLODeprecatedSuggestAlternative">
        <source>The command-line option '{0}' has been deprecated. Use '{1}' instead.</source>
        <target state="translated">Die Befehlszeilenoption "{0}" ist veraltet. Verwenden Sie stattdessen "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLOHtmlDoc">
        <source>The command-line option '{0}' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.</source>
        <target state="translated">Die Befehlszeilenoption "{0}" ist veraltet. Das Generieren von HTML-Dokumenten ist jetzt über das Tool "FsHtmlDoc.exe" Bestandteil des F# Power Packs.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsConsoleColors">
        <source>Output warning and error messages in color</source>
        <target state="translated">Warnungen und Fehlermeldungen farbig ausgeben</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUseHighEntropyVA">
        <source>Enable high-entropy ASLR</source>
        <target state="translated">ASLR mit hoher Entropie aktivieren</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSubSystemVersion">
        <source>Specify subsystem version of this assembly</source>
        <target state="translated">Subsystemversion für diese Assembly festlegen</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTargetProfile">
        <source>Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib</source>
        <target state="translated">Geben Sie das Profil des Zielframeworks dieser Assembly an. Gültige Werte sind "mscorlib", "netcore" oder "netstandard". Standard – "mscorlib".</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmitDebugInfoInQuotations">
        <source>Emit debug information in quotations</source>
        <target state="translated">Debugginginformationen in Anführungszeichen ausgeben</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPreferredUiLang">
        <source>Specify the preferred output language culture name (e.g. es-ES, ja-JP)</source>
        <target state="translated">Namen der bevorzugten Ausgabesprachenkultur angeben (z. B. "es-ES", "ja-JP")</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoCopyFsharpCore">
        <source>Don't copy FSharp.Core.dll along the produced binaries</source>
        <target state="translated">FSharp.Core.dll nicht zusammen mit den generierten Binärdateien kopieren</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidSubSystemVersion">
        <source>Invalid version '{0}' for '--subsystemversion'. The version must be 4.00 or greater.</source>
        <target state="translated">Ungültige Version '{0}' für '--subsystemversion'. Die Version muss 4.00 oder höher sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidTargetProfile">
        <source>Invalid value '{0}' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.</source>
        <target state="translated">Ungültiger Wert "{0}" für "--targetprofile", gültige Werte sind "mscorlib", "netcore" oder "netstandard".</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFullName">
        <source>Full name</source>
        <target state="translated">Vollständiger Name</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoOtherOverloads">
        <source>and {0} other overloads</source>
        <target state="translated">und {0} weitere Überladungen</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoUnionCase">
        <source>union case</source>
        <target state="translated">Union-Fall</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActivePatternResult">
        <source>active pattern result</source>
        <target state="translated">aktives Musterergebnis</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActiveRecognizer">
        <source>active recognizer</source>
        <target state="translated">aktive Erkennung</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoField">
        <source>field</source>
        <target state="translated">Feld</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoEvent">
        <source>event</source>
        <target state="translated">Ereignis</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoProperty">
        <source>property</source>
        <target state="translated">Eigenschaft</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoExtension">
        <source>extension</source>
        <target state="translated">Erweiterung</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCustomOperation">
        <source>custom operation</source>
        <target state="translated">Benutzerdefinierter Vorgang</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoArgument">
        <source>argument</source>
        <target state="translated">Argument</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoPatternVariable">
        <source>patvar</source>
        <target state="translated">patvar</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespace">
        <source>namespace</source>
        <target state="translated">Namespace</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoModule">
        <source>module</source>
        <target state="translated">Modul</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespaceOrModule">
        <source>namespace/module</source>
        <target state="translated">Namespace/Modul</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromFirst">
        <source>from {0}</source>
        <target state="translated">aus {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromNext">
        <source>also from {0}</source>
        <target state="translated">ebenfalls von {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedProperty">
        <source>generated property</source>
        <target state="translated">Generierte Eigenschaft</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedType">
        <source>generated type</source>
        <target state="translated">Generierter Typ</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersKey">
        <source>Found by AssemblyFolders registry key</source>
        <target state="translated">Von AssemblyFolders-Registrierungsschlüssel gefunden</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersExKey">
        <source>Found by AssemblyFoldersEx registry key</source>
        <target state="translated">Von AssemblyFoldersEx-Registrierungsschlüssel gefunden</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionNetFramework">
        <source>.NET Framework</source>
        <target state="translated">.NET Framework</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionGAC">
        <source>Global Assembly Cache</source>
        <target state="translated">Globaler Assemblycache</target>
        <note />
      </trans-unit>
      <trans-unit id="recursiveClassHierarchy">
        <source>Recursive class hierarchy in type '{0}'</source>
        <target state="translated">Rekursive Klassenhierarchie in Typ "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRecursiveReferenceToAbstractSlot">
        <source>Invalid recursive reference to an abstract slot</source>
        <target state="translated">Ungültiger rekursiver Verweis auf einen abstrakten Umsetzungsplatz.</target>
        <note />
      </trans-unit>
      <trans-unit id="eventHasNonStandardType">
        <source>The event '{0}' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit {1} and {2} methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent&lt;_&gt;' or 'IEvent&lt;_,_&gt;'.</source>
        <target state="translated">Das {0}-Ereignis hat einen nicht standardmäßigen Typ. Falls dieses Ereignis in einer anderen CLI-Sprache deklariert wurde, müssen Sie ggf. mithilfe der expliziten {1}- und {2}-Methoden für das Ereignis darauf zugreifen. Falls das Ereignis in F# deklariert wurde, definieren Sie den Ereignistyp als Instanziierung von "IDelegateEvent&lt;_&gt;" oder "IEvent&lt;_,_&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="typeIsNotAccessible">
        <source>The type '{0}' is not accessible from this code location</source>
        <target state="translated">Auf den Typ "{0}" kann von dieser Position im Code nicht zugegriffen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCasesAreNotAccessible">
        <source>The union cases or fields of the type '{0}' are not accessible from this code location</source>
        <target state="translated">Auf die Union-Fälle oder Felder des Typs "{0}" kann von dieser Position im Code nicht zugegriffen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="valueIsNotAccessible">
        <source>The value '{0}' is not accessible from this code location</source>
        <target state="translated">Auf den Wert "{0}" kann von dieser Position im Code nicht zugegriffen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCaseIsNotAccessible">
        <source>The union case '{0}' is not accessible from this code location</source>
        <target state="translated">Auf den Union-Fall "{0}" kann von dieser Position im Code nicht zugegriffen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="fieldIsNotAccessible">
        <source>The record, struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">Auf das Datensatz-, Struktur- oder Klassenfeld "{0}" kann von dieser Position im Code nicht zugegriffen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="structOrClassFieldIsNotAccessible">
        <source>The struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">Auf das Struktur- oder Klassenfeld "{0}" kann von dieser Position im Code nicht zugegriffen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="experimentalConstruct">
        <source>This construct is experimental</source>
        <target state="translated">Dieses Konstrukt ist experimentell.</target>
        <note />
      </trans-unit>
      <trans-unit id="noInvokeMethodsFound">
        <source>No Invoke methods found for delegate type</source>
        <target state="translated">Es wurden keine Invoke-Methoden für den Delegattyp gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="moreThanOneInvokeMethodFound">
        <source>More than one Invoke method found for delegate type</source>
        <target state="translated">Es wurde mehr als eine Invoke-Methode für den Delegattyp gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="delegatesNotAllowedToHaveCurriedSignatures">
        <source>Delegates are not allowed to have curried signatures</source>
        <target state="translated">Delegaten dürfen keine Currysignaturen aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrUnexpectedTExpr">
        <source>Unexpected Expr.TyChoose</source>
        <target state="translated">Unerwartetes Expr.TyChoose</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrLambdaLiftingOptimizationsNotApplied">
        <source>Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.</source>
        <target state="translated">Hinweis: Auf Lambda-Lifting-Optimierungen wurde verzichtet, weil diese lokal eingeschränkte generische Funktion als Wert der ersten Klasse verwendet wird. Durch Hinzufügen von Typeinschränkungen lässt sich diese Bedingung möglicherweise auflösen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifiersContainingAtSymbolReserved">
        <source>Identifiers containing '@' are reserved for use in F# code generation</source>
        <target state="translated">Bezeichner mit "@" sind für die F#-Codegenerierung reserviert.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifierReserved">
        <source>The identifier '{0}' is reserved for future use by F#</source>
        <target state="translated">Der Bezeichner "{0}" ist für die zukünftige Verwendung durch F# reserviert.</target>
        <note />
      </trans-unit>
      <trans-unit id="patcMissingVariable">
        <source>Missing variable '{0}'</source>
        <target state="translated">Fehlende Variable "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="patcPartialActivePatternsGenerateOneResult">
        <source>Partial active patterns may only generate one result</source>
        <target state="translated">Teilweise aktive Muster können nur ein Ergebnis erzeugen.</target>
        <note />
      </trans-unit>
      <trans-unit id="impTypeRequiredUnavailable">
        <source>The type '{0}' is required here and is unavailable. You must add a reference to assembly '{1}'.</source>
        <target state="translated">Der Typ "{0}" ist hier erforderlich, aber nicht verfügbar. Sie müssen einen Verweis auf Assembly "{1}" hinzufügen.</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferencedTypeCouldNotBeFoundInAssembly">
        <source>A reference to the type '{0}' in assembly '{1}' was found, but the type could not be found in that assembly</source>
        <target state="translated">Ein Verweis auf den Typ "{0}" in Assembly "{1}" wurde gefunden, der Typ ist aber nicht in der Assembly vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="impNotEnoughTypeParamsInScopeWhileImporting">
        <source>Internal error or badly formed metadata: not enough type parameters were in scope while importing</source>
        <target state="translated">Interner Fehler oder falsch formatierte Metadaten: Während des Imports befanden sich nicht genügend Typparameter im Bereich.</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferenceToDllRequiredByAssembly">
        <source>A reference to the DLL {0} is required by assembly {1}. The imported type {2} is located in the first assembly and could not be resolved.</source>
        <target state="translated">Ein Verweis auf die DLL "{0}" ist für die Assembly "{1}" erforderlich. Der importierte Typ "{2}" befindet sich in der ersten Assembly und konnte nicht aufgelöst werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="impImportedAssemblyUsesNotPublicType">
        <source>An imported assembly uses the type '{0}' but that type is not public</source>
        <target state="translated">Eine importierte Assembly verwendet den Typ "{0}"; dieser Typ ist aber nicht öffentlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButIncomplete">
        <source>The value '{0}' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible</source>
        <target state="translated">Der Wert "{0}" war als inline markiert, die Implementierung verwendet aber eine interne oder private Funktion, die keine ausreichende Zugreifbarkeit bietet.</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButWasNotBoundInTheOptEnv">
        <source>The value '{0}' was marked inline but was not bound in the optimization environment</source>
        <target state="translated">Der Wert "{0}" war als inline markiert, aber nicht in der Optimierungsumgebung gebunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="optLocalValueNotFoundDuringOptimization">
        <source>Local value {0} not found during optimization</source>
        <target state="translated">Der lokale Wert "{0}" wurde während der Optimierung nicht gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineHasUnexpectedValue">
        <source>A value marked as 'inline' has an unexpected value</source>
        <target state="translated">Ein als "inline" markierter Wert hat einen unerwarteten Wert.</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineCouldNotBeInlined">
        <source>A value marked as 'inline' could not be inlined</source>
        <target state="translated">Ein als "inline" markierter Wert konnte nicht inline gestellt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="optFailedToInlineValue">
        <source>Failed to inline the value '{0}' marked 'inline', perhaps because a recursive value was marked 'inline'</source>
        <target state="translated">Der als "inline" markierte Wert "{0}" konnte nicht inline gestellt werden, möglicherweise, weil ein rekursiver Wert als "inline" markiert war.</target>
        <note />
      </trans-unit>
      <trans-unit id="optRecursiveValValue">
        <source>Recursive ValValue {0}</source>
        <target state="translated">Rekursiver ValValue "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltIncorrentIndentationOfIn">
        <source>The indentation of this 'in' token is incorrect with respect to the corresponding 'let'</source>
        <target state="translated">Der Einzug dieses in-Tokens ist im Hinblick auf das entsprechende "let" fehlerhaft.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltTokenIsOffsideOfContextStartedEarlier">
        <source>Possible incorrect indentation: this token is offside of context started at position {0}. Try indenting this token further or using standard formatting conventions.</source>
        <target state="translated">Möglicherweise falscher Einzug: Dieses Token ist gegenüber dem bei Position {0} beginnenden Kontext verschoben. Erhöhen Sie den Einzug für dieses Token, oder verwenden Sie die standardmäßigen Formatierungskonventionen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltSeparatorTokensOfPatternMatchMisaligned">
        <source>The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.</source>
        <target state="translated">Die Trennregeln des |-Tokens für diesen Mustervergleich sind um eine Spalte verschoben. Richten Sie den Code neu aus, oder verwenden Sie weitere Einzüge.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidModuleExprType">
        <source>Invalid module/expression/type</source>
        <target state="translated">Ungültiges Modul bzw. ungültiger Ausdruck/Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationNeededToDisambiguateTypesWithSameName">
        <source>Multiple types exist called '{0}', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '{1}'.</source>
        <target state="translated">Es sind mehrere Typen mit dem Namen "{0}" vorhanden, die eine unterschiedliche Anzahl von generischen Parametern akzeptieren. Stellen Sie eine Typinstanziierung bereit, um eine eindeutige Typauflösung zu ermöglichen, z.B. "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationIsMissingAndCouldNotBeInferred">
        <source>The instantiation of the generic type '{0}' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '{1}'.</source>
        <target state="translated">Die Instanziierung des generischen Typs "{0}" fehlt und kann nicht per Rückschluss von den Argumenten oder dem Rückgabetyp dieses Members abgeleitet werden. Stellen Sie beim Zugriff auf diesen Typ eine Typinstanziierung bereit, z.B. "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="nrGlobalUsedOnlyAsFirstName">
        <source>'global' may only be used as the first name in a qualified path</source>
        <target state="translated">global darf nur als erster Name in einem qualifizierten Pfad verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrIsNotConstructorOrLiteral">
        <source>This is not a constructor or literal, or a constructor is being used incorrectly</source>
        <target state="translated">Dies ist kein Konstruktor oder Literal, oder ein Konstruktor wird nicht ordnungsgemäß verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnexpectedEmptyLongId">
        <source>Unexpected empty long identifier</source>
        <target state="translated">Unerwarteter leerer langer Bezeichner.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordDoesNotContainSuchLabel">
        <source>The record type '{0}' does not contain a label '{1}'.</source>
        <target state="translated">Der Datensatztyp "{0}" enthält keine Bezeichnung "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidFieldLabel">
        <source>Invalid field label</source>
        <target state="translated">Ungültige Feldbezeichnung.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidExpression">
        <source>Invalid expression '{0}'</source>
        <target state="translated">Ungültiger Ausdruck "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="nrNoConstructorsAvailableForType">
        <source>No constructors are available for the type '{0}'</source>
        <target state="translated">Für den Typ "{0}" sind keine Konstruktoren verfügbar.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnionTypeNeedsQualifiedAccess">
        <source>The union type for union case '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('{1}') in the name you are using.</source>
        <target state="translated">Der Union-Typ für Union-Fall "{0}" wurde mit RequireQualifiedAccessAttribute definiert. Fügen Sie den Union-Typnamen ("{1}") in den verwendeten Namen ein.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordTypeNeedsQualifiedAccess">
        <source>The record type for the record field '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('{1}') in the name you are using.</source>
        <target state="translated">Der Datensatztyp für das Feld "{0}" wurde mit RequireQualifiedAccessAttribute definiert. Fügen Sie den Namen des Datensatztyps ("{1}") in den verwendeten Namen ein.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingPdb">
        <source>Unexpected error creating debug information file '{0}'</source>
        <target state="translated">Unerwarteter Fehler beim Erstellen der Debuginformationsdatei "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideIntegerRange">
        <source>This number is outside the allowable range for this integer type</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für diesen Integer-Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexCharNotAllowedInOperatorNames">
        <source>'{0}' is not permitted as a character in operator names and is reserved for future use</source>
        <target state="translated">{0} darf nicht in Operatornamen verwendet werden und ist für eine zukünftige Verwendung reserviert.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexUnexpectedChar">
        <source>Unexpected character '{0}'</source>
        <target state="translated">Unerwartetes Zeichen "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteArrayCannotEncode">
        <source>This byte array literal contains characters that do not encode as a single byte</source>
        <target state="translated">Dieses Bytearrayliteral enthält Zeichen, die sich nicht als einzelnes Byte codieren lassen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIdentEndInMarkReserved">
        <source>Identifiers followed by '{0}' are reserved for future use</source>
        <target state="translated">Bezeichner, auf die "{0}" folgt, sind für die zukünftige Verwendung reserviert.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSigned">
        <source>This number is outside the allowable range for 8-bit signed integers</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für 8-Bit-Integer mit Vorzeichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSignedHex">
        <source>This number is outside the allowable range for hexadecimal 8-bit signed integers</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für hexadezimale 8-Bit-Integer mit Vorzeichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitUnsigned">
        <source>This number is outside the allowable range for 8-bit unsigned integers</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für 8-Bit-Integer ohne Vorzeichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitSigned">
        <source>This number is outside the allowable range for 16-bit signed integers</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für 16-Bit-Integer mit Vorzeichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitUnsigned">
        <source>This number is outside the allowable range for 16-bit unsigned integers</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für 16-Bit-Integer ohne Vorzeichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitSigned">
        <source>This number is outside the allowable range for 32-bit signed integers</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für 32-Bit-Integer mit Vorzeichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitUnsigned">
        <source>This number is outside the allowable range for 32-bit unsigned integers</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für 32-Bit-Integer ohne Vorzeichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitSigned">
        <source>This number is outside the allowable range for 64-bit signed integers</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für 64-Bit-Integer mit Vorzeichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitUnsigned">
        <source>This number is outside the allowable range for 64-bit unsigned integers</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für 64-Bit-Integer ohne Vorzeichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeSigned">
        <source>This number is outside the allowable range for signed native integers</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für native Integer mit Vorzeichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeUnsigned">
        <source>This number is outside the allowable range for unsigned native integers</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für native Integer ohne Vorzeichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidFloat">
        <source>Invalid floating point number</source>
        <target state="translated">Ungültige Gleitkommazahl.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideDecimal">
        <source>This number is outside the allowable range for decimal literals</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für Dezimalliterale.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideThirtyTwoBitFloat">
        <source>This number is outside the allowable range for 32-bit floats</source>
        <target state="translated">Diese Zahl liegt außerhalb des zulässigen Bereichs für 32-Bit-Gleitkommastellen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidNumericLiteral">
        <source>This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</source>
        <target state="translated">Dies ist kein gültiges numerisches Literal. Die folgenden numerischen Literale sind z. B. gültig: 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidByteLiteral">
        <source>This is not a valid byte literal</source>
        <target state="translated">Dies ist kein gültiges Byteliteral.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidCharLiteral">
        <source>This is not a valid character literal</source>
        <target state="translated">Dies ist kein gültiges Zeichenliteral.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexThisUnicodeOnlyInStringLiterals">
        <source>This Unicode encoding is only valid in string literals</source>
        <target state="translated">Diese Unicode-Codierung ist nur für Zeichenfolgenliterale zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTokenReserved">
        <source>This token is reserved for future use</source>
        <target state="translated">Dieses Token ist für die zukünftige Verwendung reserviert.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTabsNotAllowed">
        <source>TABs are not allowed in F# code unless the #indent \"off\" option is used</source>
        <target state="translated">Tabulatorzeichen sind in F#-Code nur zulässig, wenn die Option "#indent \"off\"" verwendet wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidLineNumber">
        <source>Invalid line number: '{0}'</source>
        <target state="translated">Ungültige Zeilennummer: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustBeFirst">
        <source>#if directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">Die #if-Direktive muss das erste Zeichen in einer Zeile sein, das keine Leerstelle ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseNoMatchingIf">
        <source>#else has no matching #if</source>
        <target state="translated">Kein passendes #if für #else vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifRequiredForElse">
        <source>#endif required for #else</source>
        <target state="translated">#endif für #else erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseMustBeFirst">
        <source>#else directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">Die #else-Direktive muss das erste Zeichen in einer Zeile sein, das keine Leerstelle ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndingNoMatchingIf">
        <source>#endif has no matching #if</source>
        <target state="translated">Kein passendes #if für #endif vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifMustBeFirst">
        <source>#endif directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">Die #endif-Direktive muss das erste Zeichen in einer Zeile sein, das keine Leerstelle ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustHaveIdent">
        <source>#if directive should be immediately followed by an identifier</source>
        <target state="translated">Auf die #if-Direktive sollte sofort ein Bezeichner folgen.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexWrongNestedHashEndif">
        <source>Syntax error. Wrong nested #endif, unexpected tokens before it.</source>
        <target state="translated">Syntaxfehler. Falsches geschachteltes #endif, unerwartete Token davor.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashBangMustBeFirstInFile">
        <source>#! may only appear as the first line at the start of a file.</source>
        <target state="translated">#! kann nur als erste Zeile zu Beginn einer Datei angezeigt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexExpectedSingleLineComment">
        <source>Expected single line comment or end of line</source>
        <target state="translated">Einzeiliger Kommentar oder Zeilenende erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNoArguments">
        <source>Infix operator member '{0}' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Infix-Operatormember "{0}" weist keine Argumente auf. Erwartet wurde ein Tupel mit 2 Argumenten, z.B. statischer Member (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonPairArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Infix-Operatormember "{0}" weist {1} anfängliche(s) Argument(e) auf. Erwartet wurde ein Tupel mit 2 Argumenten, z.B. statischer Member (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithCurriedArguments">
        <source>Infix operator member '{0}' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Infix-Operatormember "{0}" weist zusätzliche Curryargumente auf. Erwartet wurde ein Tupel mit 2 Argumenten, z.B. statischer Member (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFSharpCoreRequiresExplicit">
        <source>All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'</source>
        <target state="translated">Alle Datensatz-, Union- und Strukturtypen in "FSharp.Core.dll" müssen explizit mit "StructuralComparison" oder "NoComparison" bezeichnet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the type parameter '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" ist mit dem StructuralComparison-Attribut versehen, aber der Typparameter "{1}" erfüllt die comparison-Einschränkung nicht. Fügen Sie dem Typparameter die comparison-Einschränkung hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the component type '{1}' does not satisfy the 'comparison' constraint</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" ist mit dem StructuralComparison-Attribut versehen, aber der Komponententyp "{1}" erfüllt die comparison-Einschränkung nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded1">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type parameter {1} does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" ist strukturell nicht vergleichbar, weil der Typparameter "{1}" die comparison-Einschränkung nicht erfüllt. Fügen Sie dem Typ "{2}" das NoComparison-Attribut hinzu, um eindeutig anzugeben, dass der Typ nicht verglichen werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded2">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" ist strukturell nicht vergleichbar, weil der Typ "{1}" die comparison-Einschränkung nicht erfüllt. Fügen Sie dem Typ "{2}" das NoComparison-Attribut hinzu, um eindeutig anzugeben, dass der Typ nicht verglichen werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded1">
        <source>The struct, record or union type '{0}' does not support structural equality because the type parameter {1} does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" unterstützt keine strukturelle Gleichheit, weil der Typparameter "{1}" die equality-Einschränkung nicht erfüllt. Fügen Sie dem Typ "{2}" das NoEquality-Attribut hinzu, um eindeutig anzugeben, dass der Typ keine strukturelle Gleichheit unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded2">
        <source>The struct, record or union type '{0}' does not support structural equality because the type '{1}' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" unterstützt keine strukturelle Gleichheit, weil der Typ "{1}" die equality-Einschränkung nicht erfüllt. Fügen Sie dem Typ "{2}" das NoEquality-Attribut hinzu, um eindeutig anzugeben, dass der Typ keine strukturelle Gleichheit unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the type parameter '{1}' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" ist mit dem StructuralEquality-Attribut versehen, aber der Typparameter "{1}" erfüllt die equality-Einschränkung nicht. Fügen Sie dem Typparameter die equality-Einschränkung hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the component type '{1}' does not satisfy the 'equality' constraint</source>
        <target state="translated">Der Struktur-, Datensatz- oder Union-Typ "{0}" ist mit dem StructuralEquality-Attribut versehen, aber der Komponententyp "{1}" erfüllt die equality-Einschränkung nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
        <source>Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct.</source>
        <target state="translated">Jedes Argument des primären Konstruktors für eine Struktur muss einen Typ erhalten, z.B. "type S(x1:int, x2: int) = ...". Diese Argumente bestimmen die Felder der Struktur.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedValue">
        <source>The value '{0}' is unused</source>
        <target state="translated">Der Wert "{0}" wird nicht verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedThisVariable">
        <source>The recursive object reference '{0}' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.</source>
        <target state="translated">Der rekursive Objektverweis "{0}" wird nicht verwendet. Ist ein rekursiver Objektverweis vorhanden, werden Membern in diesem Typ und in abgeleiteten Typen Laufzeitinitialisierungsprüfungen hinzugefügt. Entfernen Sie diesen rekursiven Objektverweis.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterAtMostOneArgument">
        <source>A getter property may have at most one argument group</source>
        <target state="translated">Eine Getter-Eigenschaft darf maximal eine Argumentgruppe aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetterAtMostTwoArguments">
        <source>A setter property may have at most two argument groups</source>
        <target state="translated">Eine Setter-Eigenschaft darf maximal zwei Argumentgruppen aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidProperty">
        <source>Invalid property getter or setter</source>
        <target state="translated">Ungültiger Getter oder Setter für Eigenschaft.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIndexerPropertyRequiresAtLeastOneArgument">
        <source>An indexer property must be given at least one argument</source>
        <target state="translated">Eine Indexereigenschaft muss mindestens ein Argument erhalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidAddressOfMutableAcrossAssemblyBoundary">
        <source>This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation</source>
        <target state="translated">Bei diesem Vorgang wird auf eine nicht unterstützte Weise auf einen nicht änderbaren Wert der obersten Ebene zugegriffen, der in einer anderen Assembly definiert ist. Der Zugriff auf den Wert über seine Adresse ist nicht möglich. Kopieren Sie den Ausdruck in eine änderbare lokale Variable, z.B. "let mutable x = ...", und weisen Sie den Wert ggf. im Anschluss an diesen Vorgang erneut zu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTypars">
        <source>Type parameters must be placed directly adjacent to the type name, e.g. \"type C&lt;'T&gt;\", not     type \"C   &lt;'T&gt;\"</source>
        <target state="translated">Typparameter müssen direkt neben dem Typnamen platziert werden, z.B. \"type C&lt;'T&gt;\", nicht     type \"C   &lt;'T&gt;\".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTyargs">
        <source>Type arguments must be placed directly adjacent to the type name, e.g. \"C&lt;'T&gt;\", not \"C  &lt;'T&gt;\"</source>
        <target state="translated">Typargumente müssen direkt neben dem Typnamen platziert werden. Beispiel: \"C&lt;'T&gt;\", nicht \"C  &lt;'T&gt;\".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAtomicType">
        <source>The use of the type syntax 'int C' and 'C  &lt;int&gt;' is not permitted here. Consider adjusting this type to be written in the form 'C&lt;int&gt;'</source>
        <target state="translated">Die Verwendung der Typsyntax "int C" und "C  &lt;int&gt;" ist an dieser Stelle nicht zulässig. Passen Sie die Typangabe im Format "C&lt;int&gt;" an.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespace">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the module/namespace '{2}'</source>
        <target state="translated">Das Modul bzw. der Namespace "{0}" aus der Kompilierungseinheit "{1}" enthielt nicht das Modul bzw. den Namespace "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefVal">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the val '{2}'</source>
        <target state="translated">Das Modul bzw. der Namespace "{0}" aus der Kompilierungseinheit "{1}" enthielt nicht den Wert "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespaceType">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the namespace, module or type '{2}'</source>
        <target state="translated">Das Modul bzw. der Namespace "{0}" aus der Kompilierungseinheit "{1}" enthielt nicht den Namespace, das Modul oder den Typ "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseNullAsTrueValue">
        <source>The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case</source>
        <target state="translated">Das UseNullAsTrueValue-Attributflag darf nur für Union-Typen verwendet werden, die einen nullären Fall und mindestens einen nicht nullären Fall aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterInferredByref">
        <source>The parameter '{0}' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref&lt;int&gt;'. When used, a byref parameter is implicitly dereferenced.</source>
        <target state="translated">Beim Parameter "{0}" wird angenommen, dass er über den byref-Typ verfügt. Für Parameter mit dem byref-Typ muss eine explizite Typanmerkung angegeben werden. Beispiel: "x1: byref&lt;int&gt;". Wenn er verwendet wird, wird ein byref-Parameter implizit dereferenziert.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonUniformMemberUse">
        <source>The generic member '{0}' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.</source>
        <target state="translated">Der generische Member "{0}" wurde bei einer nicht einheitlichen Instanziierung vor diesem Programmpunkt verwendet. Ordnen Sie die Member ggf. neu an, damit dieser Member zuerst angezeigt wird. Sie können auch explizit den vollständigen Typ des Members angeben, einschließlich Argumenttypen, des Rückgabetyps und aller zusätzlichen generischen Parametern und Einschränkungen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttribArgsDiffer">
        <source>The attribute '{0}' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.</source>
        <target state="translated">Das Attribut "{0}" ist sowohl in der Implementierung als auch in der Signatur enthalten, die Attributargumente unterscheiden sich jedoch. In den kompilierten Code wird nur das Attribut aus der Signatur eingefügt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallAbstractBaseMember">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">Ein abstrakter Basismember kann nicht aufgerufen werden: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInUnmanaged">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position</source>
        <target state="translated">Die Mehrdeutigkeit bei der Verwendung eines generischen Konstrukts mit einer unmanaged-Einschränkung an dieser Position oder in ihrer Umgebung konnte nicht aufgelöst werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="mlCompatMessage">
        <source>This construct is for ML compatibility. {0}. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'.</source>
        <target state="translated">Dieses Konstrukt dient der ML-Kompatibilität. {0}. Die Warnung lässt sich mit "--mlcompatibility" oder "--nowarn:62" deaktivieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldDoesNotHaveValidOffsetForStructureLayout">
        <source>The type '{0}' has been marked as having an Explicit layout, but the field '{1}' has not been marked with the 'FieldOffset' attribute</source>
        <target state="translated">Der Typ "{0}" wurde als Typ mit explizitem Layout markiert, das Feld "{1}" wurde jedoch nicht mit dem FieldOffset-Attribut versehen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfacesShouldUseInheritNotInterface">
        <source>Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'</source>
        <target state="translated">Von anderen Schnittstellen geerbte Schnittstellen müssen mit "inherit ..." (und nicht mit "interface ...") deklariert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperator">
        <source>Invalid prefix operator</source>
        <target state="translated">Ungültiger Präfixoperator</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperatorDefinition">
        <source>Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.</source>
        <target state="translated">Ungültige Operatordefinition. Für Präfixoperatordefinitionen muss ein gültiger Präfixoperatorname verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCompilingExtensionIsForML">
        <source>The file extensions '.ml' and '.mli' are for ML compatibility</source>
        <target state="translated">Die Dateierweiterungen ".ml" und ".mli" dienen der ML-Kompatibilität.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIndentOffForML">
        <source>Consider using a file with extension '.ml' or '.mli' instead</source>
        <target state="translated">Verwenden Sie stattdessen eine Datei mit der Erweiterung ".ml" oder ".mli".</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternIdentIsNotFunctionTyped">
        <source>Active pattern '{0}' is not a function</source>
        <target state="translated">Das aktive Muster "{0}" ist keine Funktion.</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternChoiceHasFreeTypars">
        <source>Active pattern '{0}' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</source>
        <target state="translated">Das aktive Muster "{0}" besitzt einen Ergebnistyp mit Typvariablen, die nicht von der Eingabe bestimmt werden. Häufige Ursache: Es ist kein Ergebnisfall angegeben. Beispiel: "let (|A|B|) (x:int) = A x". Dieses Problem kann mithilfe einer Typeinschränkung behoben werden. Beispiel: "let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x"</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldHasOffsetForSequentialLayout">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">Das FieldOffset-Attribut kann nur für Member des mit "StructLayout(LayoutKind.Explicit)" markierten Typs festgelegt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsMustComeAfterNonOptionalArgs">
        <source>Optional arguments must come at the end of the argument list, after any non-optional arguments</source>
        <target state="translated">Optionale Argumente müssen am Ende der Argumentliste stehen, ggf. nach den nicht optionalen Argumenten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeUsage">
        <source>Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes</source>
        <target state="translated">Das Attribut "System.Diagnostics.ConditionalAttribute" ist nur bei Methoden oder Attributklassen gültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOperatorDefinitionInExtrinsic">
        <source>Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.</source>
        <target state="translated">Erweiterungsmember können keine Operatorüberladungen bereitstellen. Definieren Sie den Operator stattdessen als Teil der Typdefinition.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBFileNameCannotBeChangedWarning">
        <source>The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.</source>
        <target state="translated">Der Name der MDB-Datei muss &lt;assembly-datei-name&gt;.mdb lauten. Die --pdb-Option wird ignoriert.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBMemberMissing">
        <source>MDB generation failed. Could not find compatible member {0}</source>
        <target state="translated">Fehler bei der MDB-Generierung. Kompatibler Member {0} wurde nicht gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingMdb">
        <source>Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly.</source>
        <target state="translated">Es können keine MDB-Debuginformationen generiert werden. Fehler beim Laden des Typs 'MonoSymbolWriter' aus der 'Mono.CompilerServices.SymbolWriter.dll'-Assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseNameConflictsWithGeneratedType">
        <source>The union case named '{0}' conflicts with the generated type '{1}'</source>
        <target state="translated">Der Union-Fall mit dem Namen '{0}' befindet sich in einem Konflikt mit dem generierten Typ '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoReflectedDefinitionOnStructMember">
        <source>ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter</source>
        <target state="translated">ReflectedDefinitionAttribute kann nicht auf einen Instanzmember eines struct-Typs angewendet werden, da der Instanzmember einen impliziten 'this'-byref-Parameter akzeptiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportNotAllowed">
        <source>DLLImport bindings must be static members in a class or function definitions in a module</source>
        <target state="translated">Bei DLLImport-Bindungen muss es sich um statische Member von Klassen- oder Funktionsdefinitionen eines Moduls handeln.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExplicitCoreLibRequiresNoFramework">
        <source>When mscorlib.dll or FSharp.Core.dll is explicitly referenced the {0} option must also be passed</source>
        <target state="translated">Wenn explizit auf "mscorlib.dll" oder "FSharp.Core.dll" verwiesen wird, muss auch die Option "{0}" übergeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedSigdataFile">
        <source>FSharp.Core.sigdata not found alongside FSharp.Core. File expected in {0}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">FSharp.Core.sigdata wurde nicht neben "FSharp.Core" gefunden. Die Datei wurde in {0} erwartet. Erwägen Sie ein Upgrade auf eine aktuellere Version von "FSharp.Core", in der die Datei nicht mehr erforderlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedFileAlongSideFSharpCore">
        <source>File '{0}' not found alongside FSharp.Core. File expected in {1}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">Die Datei "{0}" wurde nicht neben "FSharp.Core" gefunden. Die Datei wurde in {1} erwartet. Erwägen Sie ein Upgrade auf eine aktuellere Version von "FSharp.Core", in der die Datei nicht mehr erforderlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedFileNameCharacter">
        <source>Filename '{0}' contains invalid character '{1}'</source>
        <target state="translated">Der Dateiname '{0}' enthält das ungültige Zeichen '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBinding">
        <source>'use!' bindings must be of the form 'use! &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">'Use!'-Bindungen müssen das Format 'use! &lt;pat&gt; -&gt; &lt;expr&gt;' aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoInnerGenericsInQuotations">
        <source>Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.</source>
        <target state="translated">In Ausdrücken in Anführungszeichen sind innere generische Funktionen nicht zulässig. Fügen Sie Typeinschränkungen hinzu, bis diese Funktion nicht mehr generisch ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumTypeCannotBeEnumerated">
        <source>The type '{0}' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property</source>
        <target state="translated">Beim Typ '{0}' handelt es sich nicht um einen gültigen Enumeratortyp, d. h. er verfügt über keine 'MoveNext()'-Methode, die einen booleschen Wert zurückgibt, und keine 'Current'-Eigenschaft.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteString">
        <source>End of file in triple-quote string begun at or before here</source>
        <target state="translated">Dateiende in einer Zeichenfolge mit dreifachen Anführungszeichen, die an oder vor dieser Stelle begonnen wurde</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteStringInComment">
        <source>End of file in triple-quote string embedded in comment begun at or before here</source>
        <target state="translated">Dateiende in einer in den Kommentar eingebetteten Zeichenfolge mit dreifachen Anführungszeichen, die an oder vor dieser Stelle begonnen wurde</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLosesMeasures">
        <source>This type test or downcast will ignore the unit-of-measure '{0}'</source>
        <target state="translated">Bei diesem Typtest oder der Typumwandlung wird die Maßeinheit '{0}' ignoriert.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingTypeArgs">
        <source>Expected type argument or static argument</source>
        <target state="translated">Es wurde ein Typ- oder statisches Argument erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingGreaterThan">
        <source>Unmatched '&lt;'. Expected closing '&gt;'</source>
        <target state="translated">Keine Entsprechung für '&lt;'. Schließendes '&gt;' erwartet</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
        <source>Unexpected quotation operator '&lt;@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '&lt;' and '@' characters.</source>
        <target state="translated">Unerwarteter Anführungszeichen-Operator '&lt;@' in der Typdefinition. Wenn eine ausführliche Zeichenfolge als statisches Argument an einen Typanbieter übergeben werden soll, fügen Sie zwischen den Zeichen '&lt;' und '@' eine Leerstelle ein.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorParsingAsOperatorName">
        <source>Attempted to parse this as an operator name, but failed</source>
        <target state="translated">Versuchte Analyse als Operatornamen, jedoch Analysefehler</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidUnicodeLiteral">
        <source>\U{0} is not a valid Unicode character escape sequence</source>
        <target state="translated">\U{0} ist keine gültige Unicode-Zeichen-Escapesequenz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoWrongType">
        <source>'{0}' must be applied to an argument of type '{1}', but has been applied to an argument of type '{2}'</source>
        <target state="translated">"{0}" muss auf ein Argument vom Typ "{1}" angewendet werden, wurde aber auf ein Argument vom Typ "{2}" angewendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoNotOptional">
        <source>'{0}' can only be applied to optional arguments</source>
        <target state="translated">{0} kann nur auf optionale Argumente angewendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="toolLocationHelperUnsupportedFrameworkVersion">
        <source>The specified .NET Framework version '{0}' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
        <target state="translated">Die angegebene .NET Framework-Version "{0}" wird nicht unterstützt. Geben Sie einen Wert aus der Enumeration "Microsoft.Build.Utilities.TargetDotNetFrameworkVersion" an.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidMagicValue">
        <source>Invalid Magic value in CLR Header</source>
        <target state="translated">Ungültiger Magic-Wert im CLR-Header.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignBadImageFormat">
        <source>Bad image format</source>
        <target state="translated">Ungültiges Bildformat.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignPrivateKeyExpected">
        <source>Private key expected</source>
        <target state="translated">Ein privater Schlüssel wurde erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignRsaKeyExpected">
        <source>RSA key expected</source>
        <target state="translated">Ein RSA-Schlüssel wurde erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidBitLen">
        <source>Invalid bit Length</source>
        <target state="translated">Ungültige Bitlänge.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidRSAParams">
        <source>Invalid RSAParameters structure - '{{0}}' expected</source>
        <target state="translated">Ungültige RSAParameters-Struktur – "{{0}}" wurde erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidAlgId">
        <source>Invalid algId - 'Exponent' expected</source>
        <target state="translated">Ungültige "algId" – "Exponent" wurde erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidSignatureSize">
        <source>Invalid signature size</source>
        <target state="translated">Ungültige Signaturgröße.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignNoSignatureDirectory">
        <source>No signature directory</source>
        <target state="translated">Kein Signaturverzeichnis</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidPKBlob">
        <source>Invalid Public Key blob</source>
        <target state="translated">Ungültiger öffentlicher Schlüssel-BLOB.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTooManyErrors">
        <source>Exiting - too many errors</source>
        <target state="translated">Der Vorgang wird aufgrund zu vieler Fehler beendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="docfileNoXmlSuffix">
        <source>The documentation file has no .xml suffix</source>
        <target state="translated">Die Dokumentationsdatei weist kein XML-Suffix auf.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscNoImplementationFiles">
        <source>No implementation files specified</source>
        <target state="translated">Es wurden keine Implementierungsdateien angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscBadAssemblyVersion">
        <source>The attribute {0} specified version '{1}', but this value is invalid and has been ignored</source>
        <target state="translated">Ein {0} gab Version '{1}' an, dieser Wert ist jedoch ungültig und wurde ignoriert.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTwoResourceManifests">
        <source>Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used.</source>
        <target state="translated">Es wurden widersprüchliche Optionen angegeben: 'win32manifest' und 'win32res'. Nur eine dieser Optionen kann verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking">
        <source>The code in assembly '{0}' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">Der Code in der Assembly "{0}" verwendet Quotation-Literale. Statische Verknüpfungen schließen unter Umständen Komponenten nicht ein, die Quotation-Literale verwenden, sofern nicht alle Assemblys mindestens mit F# 4.0 kompiliert sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking0">
        <source>Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">Der Code in dieser Assembly verwendet Quotation-Literale. Statische Verknüpfungen schließen unter Umständen Komponenten nicht ein, die Quotation-Literale verwenden, sofern nicht alle Assemblys mindestens mit F# kompiliert sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoEXE">
        <source>Static linking may not include a .EXE</source>
        <target state="translated">Die statische Verknüpfung darf keine EXE-Datei einschließen.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoMixedDLL">
        <source>Static linking may not include a mixed managed/unmanaged DLL</source>
        <target state="translated">Eine statische Verknüpfung darf eine gemischte verwaltete/nicht verwaltete DLL nicht einschließen.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscIgnoringMixedWhenLinking">
        <source>Ignoring mixed managed/unmanaged assembly '{0}' during static linking</source>
        <target state="translated">Die gemischte verwaltete/nicht verwaltete Assembly '{0}' wird während der statischen Verknüpfung ignoriert.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssumeStaticLinkContainsNoDependencies">
        <source>Assembly '{0}' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.</source>
        <target state="translated">Auf die Assembly '{0}' wurde transitiv verwiesen, und sie konnte nicht automatisch aufgelöst werden. Bei einer statischen Verknüpfung wird davon ausgegangen, dass diese DLL keine Abhängigkeiten in der F#-Bibliothek oder anderen statisch verknüpften DLLs aufweist. Fügen Sie dieser DLL einen expliziten Verweis hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyNotFoundInDependencySet">
        <source>Assembly '{0}' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.</source>
        <target state="translated">Assembly '{0}' wurde im Abhängigkeitssatz der Zielbinärdatei nicht gefunden. Statistisch verknüpfte Stämme müssen mithilfe eines Assemblynamen angegeben werden, ohne DLL- oder EXE-Erweiterung. Wenn explizit auf diese Assembly verwiesen wurde, ist es möglich, dass die Assembly nicht wirklich für die erzeugte Binärdatei erforderlich war. In diesem Fall sollte sie nicht statisch verknüpft sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileCouldNotBeOpened">
        <source>The key file '{0}' could not be opened</source>
        <target state="translated">Die Schlüsseldatei '{0}' konnte nicht geöffnet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscProblemWritingBinary">
        <source>A problem occurred writing the binary '{0}': {1}</source>
        <target state="translated">Fehler beim Schreiben der Binärdatei '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyVersionAttributeIgnored">
        <source>The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option</source>
        <target state="translated">Das 'AssemblyVersionAttribute' wurde ignoriert, da eine Version mithilfe einer Befehlszeilenoption angegeben wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyCultureAttributeError">
        <source>Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'</source>
        <target state="translated">Fehler beim Ausgeben des 'System.Reflection.AssemblyCultureAttribute'-Attributs -- "Ausführbare Dateien können keine Satellitenassemblys sein, Kulturen sollten immer leer sein".</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDelaySignWarning">
        <source>Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module</source>
        <target state="translated">Die Option '--delaysign' überschreibt das Attribut 'System.Reflection.AssemblyDelaySignAttribute', das in einer Quelldatei oder einem hinzugefügten Modul angegeben wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileWarning">
        <source>Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module</source>
        <target state="translated">Die Option '--keyfile' überschreibt das Attribut 'System.Reflection.AssemblyKeyFileAttribute', das in einer Quelldatei oder einem hinzugefügten Modul angegeben wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyNameWarning">
        <source>Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module</source>
        <target state="translated">Die Option '--keycontainer' überschreibt das Attribut 'System.Reflection.AssemblyNameAttribute', das in einer Quelldatei oder einem hinzugefügten Modul angegeben wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscReferenceOnCommandLine">
        <source>The assembly '{0}' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'.</source>
        <target state="translated">Die Assembly '{0}' ist an der Befehlszeile aufgeführt. Auf Assemblys muss mithilfe eines Befehlszeilenflags wie '-r' verwiesen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscRemotingError">
        <source>The resident compilation service was not used because a problem occured in communicating with the server.</source>
        <target state="translated">Der residente Kompilierungsdienst wurde nicht verwendet, da bei der Kommunikation mit dem Server ein Problem aufgetreten ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="pathIsInvalid">
        <source>Problem with filename '{0}': Illegal characters in path.</source>
        <target state="translated">Problem mit Dateinamen '{0}': Ungültige Zeichen im Pfad.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscResxSourceFileDeprecated">
        <source>Passing a .resx file ({0}) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.</source>
        <target state="translated">Das Übergeben einer RESX-Datei ({0}) als Quelldatei an den Compiler ist veraltet. Verwenden Sie "resgen.exe", um die RESX-Datei in eine RESOURCES-Datei zu transformieren, um eine --resource-Option zu übergeben. Bei der Verwendung von MSBuild kann dies über ein &lt;EmbeddedResource&gt;-Element in der .fsproj-Projektdatei erfolgen.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoProfileMismatches">
        <source>Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).</source>
        <target state="translated">Statische Verknüpfungen dürfen beim Generieren einer Assembly mit Verweis auf System.Runtime (z. B. eine .NET Core- oder eine portierbare Assembly) nicht für eine Assembly verwendet werden, die auf mscorlib verweist (z. B. eine .NET Framework-Assembly).</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyWildcardAndDeterminism">
        <source>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</source>
        <target state="translated">{0} hat Version "{1}" angegeben, dieser Wert ist jedoch ein Platzhalter, und Sie haben einen deterministischen Build angefordert. Zwischen diesen besteht ein Konflikt.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDeterministicDebugRequiresPortablePdb">
        <source>Determinstic builds only support portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">Deterministische Builds unterstützen nur portierbare PDbs ("--debug:portable" oder "--debug:embedded").</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInNamespaceName">
        <source>Character '{0}' is not allowed in provided namespace name '{1}'</source>
        <target state="translated">Das Zeichen '{0}' ist im angegebenen Namespacenamen '{1}' nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullOrEmptyMemberName">
        <source>The provided type '{0}' returned a member with a null or empty member name</source>
        <target state="translated">Der angegebene Typ '{0}' hat einen Member mit einem NULL- oder leeren Membernamen zurückgegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMember">
        <source>The provided type '{0}' returned a null member</source>
        <target state="translated">Der Typanbieter '{0}' hat einen NULL-Member zurückgegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringType">
        <source>The provided type '{0}' member info '{1}' has null declaring type</source>
        <target state="translated">Die Memberinformationen '{1}' des angegebenen Typs '{0}' verfügen über einen NULL-Deklarierungstyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringTypeDifferentFromProvidedType">
        <source>The provided type '{0}' has member '{1}' which has declaring type '{2}'. Expected declaring type to be the same as provided type.</source>
        <target state="translated">Der angegebene Typ '{0}' verfügt über einen Member '{1}' mit dem deklarierenden Typ '{2}'. Es wurde als deklarierender Typ derselbe wie der angegebene Typ erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="etHostingAssemblyFoundWithoutHosts">
        <source>Referenced assembly '{0}' has assembly level attribute '{1}' but no public type provider classes were found</source>
        <target state="translated">Die referenzierte Assembly '{0}' verfügt über das Attribut '{1}' auf Assemblyebene, es wurden jedoch keine öffentlichen Typanbieterklassen gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceOfTypeNotAllowed">
        <source>Type '{0}' from type provider '{1}' has an empty namespace. Use 'null' for the global namespace.</source>
        <target state="translated">Typ '{0}' von Typanbieter '{1}' verfügt über einen leeren Namespace. Verwenden Sie für den globalen Namespace 'null'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceNotAllowed">
        <source>Empty namespace found from the type provider '{0}'. Use 'null' for the global namespace.</source>
        <target state="translated">Leerer Namespace gefunden von Typanbieter '{0}'. Verwenden Sie für den globalen Namespace 'null'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeGeneric">
        <source>Provided type '{0}' has 'IsGenericType' as true, but generic types are not supported.</source>
        <target state="translated">Für den angegebenen Typ '{0}' ist 'IsGenericType' auf true festgelegt, es werden jedoch keine generischen Typen unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeAnArray">
        <source>Provided type '{0}' has 'IsArray' as true, but array types are not supported.</source>
        <target state="translated">Für den angegebenen Typ '{0}' ist 'IsArray' auf true festgelegt, es werden jedoch keine Arraytypen unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMethodHasRequirements">
        <source>Invalid member '{0}' on provided type '{1}'. Provided type members must be public, and not be generic, virtual, or abstract.</source>
        <target state="translated">Ungültiger Member '{0}' für Anbietertyp '{1}'. Die angegebenen Typmember müssen öffentlich, nicht jedoch generisch, virtuell oder abstrakt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedMemberKind">
        <source>Invalid member '{0}' on provided type '{1}'. Only properties, methods and constructors are allowed</source>
        <target state="translated">Ungültiger Member '{0}' für Anbietertyp '{1}'. Es sind nur Eigenschaften, Methoden und Konstruktoren zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanReadButHasNoGetter">
        <source>Property '{0}' on provided type '{1}' has CanRead=true but there was no value from GetGetMethod()</source>
        <target state="translated">Die '{0}'-Eigenschaft des angegebenen Typs '{1}' ist auf CanRead=true festgelegt, es gab jedoch keinen Wert von GetGetMethod().</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasGetterButNoCanRead">
        <source>Property '{0}' on provided type '{1}' has CanRead=false but GetGetMethod() returned a method</source>
        <target state="translated">Die '{0}'-Eigenschaft des angegebenen Typs '{1}' ist auf CanRead=false festgelegt, GetGetMethod() hat jedoch eine Methode zurückgegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanWriteButHasNoSetter">
        <source>Property '{0}' on provided type '{1}' has CanWrite=true but there was no value from GetSetMethod()</source>
        <target state="translated">Die '{0}'-Eigenschaft des angegebenen Typs '{1}' ist auf CanWrite=true festgelegt, es gab jedoch keinen Wert von GetSetMethod().</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasSetterButNoCanWrite">
        <source>Property '{0}' on provided type '{1}' has CanWrite=false but GetSetMethod() returned a method</source>
        <target state="translated">Die '{0}'-Eigenschaft des angegebenen Typs '{1}' ist auf CanWrite=false festgelegt, GetSetMethod() hat jedoch eine Methode zurückgegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
        <source>One or more errors seen during provided type setup</source>
        <target state="translated">Beim Setup des angegebenen Typs ist mindestens ein Fehler aufgetreten.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedTypeMember">
        <source>Unexpected exception from provided type '{0}' member '{1}': {2}</source>
        <target state="translated">Unerwartete Ausnahme vom angegebenen Typ '{0}' Member '{1}': {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedConstantType">
        <source>Unsupported constant type '{0}'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal.</source>
        <target state="translated">Nicht unterstützter Konstantentyp "{0}". Vom Typanbieter bereitgestellte Quotations dürfen nur einfache Konstanten enthalten. Die Implementierung des Typanbieters muss unter Umständen angepasst werden, indem ein Wert, der außerhalb eines bereitgestellten Quotation-Literals daklariert wird, mittels Verschieben in eine let-Bindung innerhalb eines Quotation-Literals umgewandelt wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedProvidedExpression">
        <source>Unsupported expression '{0}' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.</source>
        <target state="translated">Nicht unterstützter Ausdruck '{0}' des Typanbieters. Wenn Sie der Autor dieses Typanbieters sind, sollten Sie ihn möglicherweise so anpassen, dass ein anderer unterstützter Ausdruck bereitgestellt wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedName">
        <source>Expected provided type named '{0}' but provided type has 'Name' with value '{1}'</source>
        <target state="translated">Es wurde ein angegebener Type mit dem Namen '{0}' erwartet, der angegebene Typ verfügt jedoch über 'Name' mit dem Wert '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoAdd">
        <source>Event '{0}' on provided type '{1}' has no value from GetAddMethod()</source>
        <target state="translated">Ereignis '{0}' des angegebenen Typs '{1}' verfügt nicht über einen Wert von GetAddMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoRemove">
        <source>Event '{0}' on provided type '{1}' has no value from GetRemoveMethod()</source>
        <target state="translated">Ereignis '{0}' des angegebenen Typs '{1}' verfügt nicht über einen Wert von GetRemoveMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssembly">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded or doesn't exist. {2}</source>
        <target state="translated">Das Assemblyattribut '{0}' bezieht sich auf eine Designerassembly '{1}', die entweder nicht geladen werden kann oder nicht vorhanden ist. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderDoesNotHaveValidConstructor">
        <source>The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected.</source>
        <target state="translated">Der Typanbieter verfügt über keinen gültigen Konstruktor. Es wurde ein Konstruktor erwartet, der entweder keine Argumente oder ein Argument des Typs 'TypeProviderConfig' akzeptiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderError">
        <source>The type provider '{0}' reported an error: {1}</source>
        <target state="translated">Der Typanbieter '{0}' hat einen Fehler gemeldet: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectParameterExpression">
        <source>The type provider '{0}' used an invalid parameter in the ParameterExpression: {1}</source>
        <target state="translated">Der Typanbieter '{0}' hat in ParameterExpression einen ungültigen Parameter verwendet: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedMethod">
        <source>The type provider '{0}' provided a method with a name '{1}' and metadata token '{2}', which is not reported among its methods of its declaring type '{3}'</source>
        <target state="translated">Der Typanbieter '{0}' hat eine Methode mit dem Namen '{1}' und dem Metadatentoken '{2}' angegeben, die nicht zu den Methoden des deklarierenden Typs '{3}' gehört</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedConstructor">
        <source>The type provider '{0}' provided a constructor which is not reported among the constructors of its declaring type '{1}'</source>
        <target state="translated">Der Typanbieter '{0}' hat einen Konstruktor bereitgestellt, der nicht zu den Konstruktoren des deklarierten Typs '{1}' gehört</target>
        <note />
      </trans-unit>
      <trans-unit id="etDirectReferenceToGeneratedTypeNotAllowed">
        <source>A direct reference to the generated type '{0}' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = &lt;path&gt;'. This indicates that a type provider adds generated types to your assembly.</source>
        <target state="translated">Es ist kein direkter Verweis zum generierten Typ '{0}' zulässig. Verwenden Sie stattdessen eine Typdefinition, z. B. TypeAlias = &lt;path&gt;. Dies weist darauf hin, dass ein Typanbieter Ihrer Assembly generierte Typen hinzufügt.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedPath">
        <source>Expected provided type with path '{0}' but provided type has path '{1}'</source>
        <target state="translated">Es wurde ein angegebener Type mit dem Pfad '{0}' erwartet, der angegebene Typ verfügt jedoch über den Pfad '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedNullFromProvidedTypeMember">
        <source>Unexpected 'null' return value from provided type '{0}' member '{1}'</source>
        <target state="translated">Unerwarteter NULL-Rückgabewert vom angegebenen Typ '{0}' Member '{1}':</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedMemberMember">
        <source>Unexpected exception from member '{0}' of provided type '{1}' member '{2}': {3}</source>
        <target state="translated">Unerwartete Ausnahme von Member '{0}' des angegebenen Typs '{1}' von Member '{2}': {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
        <source>Nested provided types do not take static arguments or generic parameters</source>
        <target state="translated">Die geschachtelten angegebenen Typen akzeptieren keine statischen Argumente oder generische Parameter.</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidStaticArgument">
        <source>Invalid static argument to provided type. Expected an argument of kind '{0}'.</source>
        <target state="translated">Ungültiges statisches Argument für angegebenen Typ. Es wurde ein Argument der Art '{0}' erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToType">
        <source>An error occured applying the static arguments to a provided type</source>
        <target state="translated">Fehler beim Anwenden des statischen Arguments auf einen angegebenen Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnknownStaticArgumentKind">
        <source>Unknown static argument kind '{0}' when resolving a reference to a provided type or method '{1}'</source>
        <target state="translated">Unbekannte Art des statischen Arguments "{0}" beim Auflösen eines Verweises zum angegebenen Typ oder zur angegebenen Methode "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidNamespaceForProvidedType">
        <source>invalid namespace for provided type</source>
        <target state="translated">Ungültiger Namespace für den angegebenen Typ</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidFullNameForProvidedType">
        <source>invalid full name for provided type</source>
        <target state="translated">Ungültiger vollständiger Name für den angegebenen Typ</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderReturnedNull">
        <source>The type provider returned 'null', which is not a valid return value from '{0}'</source>
        <target state="translated">Der Typanbieter hat NULL zurückgegeben, wobei es sich nicht um einen gültigen Rückgabewert von '{0}' handelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTypeProviderConstructorException">
        <source>The type provider constructor has thrown an exception: {0}</source>
        <target state="translated">Der Typanbieterkonstruktor hat eine Ausnahme ausgelöst: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullProvidedExpression">
        <source>Type provider '{0}' returned null from GetInvokerExpression.</source>
        <target state="translated">Typanbieter '{0}' hat von GetInvokerExpression NULL zurückgegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedTypeHadWrongName">
        <source>The type provider '{0}' returned an invalid type from 'ApplyStaticArguments'. A type with name '{1}' was expected, but a type with name '{2}' was returned.</source>
        <target state="translated">Der Typanbieter '{0}' hat von 'ApplyStaticArguments' einen ungültigen Typ zurückgegeben. Es wurde ein Typ mit dem Namen '{1}' erwartet, es wurde jedoch ein Typ mit dem Namen '{2}' zurückgegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedMethodHadWrongName">
        <source>The type provider '{0}' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '{1}' was expected, but a method with name '{2}' was returned.</source>
        <target state="translated">Der Typanbieter "{0}" hat von "ApplyStaticArgumentsForMethod" eine ungültige Methode zurückgegeben. Es wurde eine Methode mit dem Namen "{1}" erwartet, es wurde jedoch eine Methode mit dem Namen "{2}" zurückgegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLossy">
        <source>This type test or downcast will erase the provided type '{0}' to the type '{1}'</source>
        <target state="translated">Mit diesem Typtest oder der Typumwandlung wird der angegebene Typ '{0}' in den Typ '{1}' geändert.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCastErased">
        <source>This downcast will erase the provided type '{0}' to the type '{1}'.</source>
        <target state="translated">Mit dieser Typumwandlung wird der angegebene Typ '{0}' in den Typ '{1}' geändert.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestErased">
        <source>This type test with a provided type '{0}' is not allowed because this provided type will be erased to '{1}' at runtime.</source>
        <target state="translated">Dieser Typetest mit dem angegeben Typ '{0}' ist nicht zulässig, da dieser angegebene Typ zur Laufzeit in '{1}' gelöscht wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromErasedType">
        <source>Cannot inherit from erased provided type</source>
        <target state="translated">Von einem gelöschten angegebenen Typ kann nicht geerbt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidTypeProviderAssemblyName">
        <source>Assembly '{0}' hase TypeProviderAssembly attribute with invalid value '{1}'. The value should be a valid assembly name</source>
        <target state="translated">Assembly '{0}' verfügt über ein TypeProviderAssembly-Attribut mit dem ungültigen Wert '{1}'. Beim Wert sollte es sich um einen gültigen Assemblynamen handeln.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameCtor">
        <source>Invalid member name. Members may not have name '.ctor' or '.cctor'</source>
        <target state="translated">Ungültiger Membername. Member dürfen nicht die Namen '.ctor' oder '.cctor' haben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInferredGenericTypeGivesRiseToInconsistency">
        <source>The function or member '{0}' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '{1}'.</source>
        <target state="translated">Die Funktion oder der Member '{0}' wird auf eine Weise verwendet, die in den Definitionen zusätzliche Typanmerkungen erfordert, um die Konsistenz der abgeleiteten Typen sicherzustellen. Die abgeleitete Signatur lautet '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentCount">
        <source>The number of type arguments did not match: '{0}' given, '{1}' expected. This may be related to a previously reported error.</source>
        <target state="translated">Die Anzahl der Typargumente stimmte nicht überein: Es wurde {1} erwartet, jedoch {0} ausgegeben. Dies kann mit einem zuvor gemeldeten Fehler zusammenhängen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotOverrideSealedMethod">
        <source>Cannot override inherited member '{0}' because it is sealed</source>
        <target state="translated">Der geerbte Member '{0}' kann nicht überschrieben werden, da er versiegelt ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderErrorWithContext">
        <source>The type provider '{0}' reported an error in the context of provided type '{1}', member '{2}'. The error: {3}</source>
        <target state="translated">Der Typanbieter '{0}' hat einen Fehler im Kontext des angegebenen Typs '{1}', Member '{2}' gemeldet. Fehler: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNameException">
        <source>An exception occurred when accessing the '{0}' of a provided type: {1}</source>
        <target state="translated">Beim Zugreifen auf '{0}' eines angegebenen Typs ist eine Ausnahme aufgetreten: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNullOrEmptyName">
        <source>The '{0}' of a provided type was null or empty.</source>
        <target state="translated">'{0}' eines angegebenen Typs war NULL oder leer.</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInTypeName">
        <source>Character '{0}' is not allowed in provided type name '{1}'</source>
        <target state="translated">Das Zeichen '{0}' ist im angegebenen Typnamen '{1}' nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcJoinMustUseSimplePattern">
        <source>In queries, '{0}' must use a simple pattern</source>
        <target state="translated">In Abfragen muss '{0}' ein einfaches Muster verwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMissingCustomOperation">
        <source>A custom query operation for '{0}' is required but not specified</source>
        <target state="translated">Für '{0}' ist ein benutzerdefinierter Abfragevorgang erforderlich, der jedoch nicht angegeben wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="etBadUnnamedStaticArgs">
        <source>Named static arguments must come after all unnamed static arguments</source>
        <target state="translated">Die benannten statischen Argumente müssen auf alle unbenannten statischen Argumente folgen.</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterRequiresAValue">
        <source>The static parameter '{0}' of the provided type or method '{1}' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '{2}&lt;{3}=...&gt;'.</source>
        <target state="translated">Der statische Parameter "{0}" vom angegebenen Typ oder der angegebenen Methode "{1}" benötigt einen Wert. Statische Parameter zu Typanbietern können optional mithilfe von benannten Argumenten angegeben werden, z. B. "{2}&lt;{3}=...&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="etNoStaticParameterWithName">
        <source>No static parameter exists with name '{0}'</source>
        <target state="translated">Es sind keine statische Parameter mit dem Namen '{0}' vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterAlreadyHasValue">
        <source>The static parameter '{0}' has already been given a value</source>
        <target state="translated">Der statische Parameter '{0}' verfügt bereits über einen Wert.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMultipleStaticParameterWithName">
        <source>Multiple static parameters exist with name '{0}'</source>
        <target state="translated">Es sind mehrere statische Parameter mit dem Namen '{0}' vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
        <source>A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression</source>
        <target state="translated">Ein benutzerdefinierter Vorgang darf in einem anderen Teil dieses Berechnungsausdrucks nicht in Verbindung mit einem Nicht-Wert oder einer rekursiven 'let'-Bindung verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedHere">
        <source>A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression</source>
        <target state="translated">Ein benutzerdefinierter Vorgang darf in diesem Berechnungsausdruck nicht in Verbindung mit den Operatoren 'use', 'try/with', 'try/finally', 'if/then/else' oder 'match' verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeOverloaded">
        <source>The custom operation '{0}' refers to a method which is overloaded. The implementations of custom operations may not be overloaded.</source>
        <target state="translated">Der benutzerdefinierte Vorgang '{0}' bezieht sich auf eine überladene Methode. Die Implementierungen der benutzerdefinierten Vorgänge sind möglicherweise nicht überladen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIfThenElseMayNotBeUsedWithinQueries">
        <source>An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.</source>
        <target state="translated">In Abfragen dürfen if/then/else-Ausdrücke nicht verwendet werden. Verwenden Sie stattdessen entweder einen if/then-Ausdruck oder einen Sequenzausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
        <source>Invalid argument to 'methodhandleof' during codegen</source>
        <target state="translated">Ungültiges Argument für 'methodhandleof' bei der Codegenerierung</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceMissingArgument">
        <source>A reference to a provided type was missing a value for the static parameter '{0}'. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">Einem Verweis auf einen angegebenen Typ fehlte ein Wert für den statischen Parameter '{0}'. Es müssen möglicherweise eine oder mehrere referenzierte Assemblys erneut kompiliert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceInvalidText">
        <source>A reference to a provided type had an invalid value '{0}' for a static parameter. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">Ein Verweis auf einen angegebenen Typ hatte für einen statischen Parameter den ungültigen Wert '{0}'. Es müssen möglicherweise eine oder mehrere referenzierte Assemblys erneut kompiliert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly">
        <source>'{0}' is not used correctly. This is a custom operation in this query or computation expression.</source>
        <target state="translated">'{0}' wird nicht ordnungsgemäß verwendet. Hierbei handelt es sich um einen benutzerdefinierten Vorgang in dieser Abfrage oder im Berechnungsausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly2">
        <source>'{0}' is not used correctly. Usage: {1}. This is a custom operation in this query or computation expression.</source>
        <target state="translated">"{0}" wird nicht ordnungsgemäß verwendet. Verwendung: {1}. Hierbei handelt es sich um einen benutzerdefinierten Vorgang in dieser Abfrage oder im Berechnungsausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeJoin">
        <source>{0} var in collection {1} (outerKey = innerKey). Note that parentheses are required after '{2}'</source>
        <target state="translated">{0}-Variable in der Sammlung {1} (outerKey = innerKey). Nach "{2}" sind Klammern erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeGroupJoin">
        <source>{0} var in collection {1} (outerKey = innerKey) into group. Note that parentheses are required after '{2}'</source>
        <target state="translated">{0}-Variable in der Sammlung {1} (outerKey = innerKey) in der Gruppe. Nach "{2}" sind Klammern erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeZip">
        <source>{0} var in collection</source>
        <target state="translated">{0}-Variable in der Sammlung</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresVariable">
        <source>'{0}' must be followed by a variable name. Usage: {1}.</source>
        <target state="translated">"{0}" muss von einem Variablennamen gefolgt werden. Verwendung: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorIncorrectSyntax">
        <source>Incorrect syntax for '{0}'. Usage: {1}.</source>
        <target state="translated">Fehlerhafte Syntax für '{0}'. Verwendung: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresBody">
        <source>'{0}' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... {1} ...</source>
        <target state="translated">"{0}" muss auf eine for-Auswahlklausel folgen und vom Rest der Abfrage gefolgt werden. Syntax: ... {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationHasIncorrectArgCount">
        <source>'{0}' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected {1} argument(s), but given {2}.</source>
        <target state="translated">"{0}" wird mit einer unzulässigen Anzahl von Argumenten verwendet. Hierbei handelt es sich um einen benutzerdefinierten Vorgang in dieser Abfrage oder im Berechnungsausdruck. {1} Argument(e) erwartet, jedoch {2} erhalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterToken">
        <source>Expected an expression after this point</source>
        <target state="translated">Nach diesem Punkt wurde ein Ausdruck erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedTypeAfterToken">
        <source>Expected a type after this point</source>
        <target state="translated">Nach diesem Punkt wurde ein Typ erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLBrackLess">
        <source>Unmatched '[&lt;'. Expected closing '&gt;]'</source>
        <target state="translated">Keine Entsprechung für "[&lt;". Schließendes "&gt;]" erwartet</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileMatch">
        <source>Unexpected end of input in 'match' expression. Expected 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</source>
        <target state="translated">Unerwartetes Eingabeende im 'match'-Ausdruck. Es wurde 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...' erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTry">
        <source>Unexpected end of input in 'try' expression. Expected 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;'.</source>
        <target state="translated">Unerwartetes Eingabeende im 'try'-Ausdruck. Es wurde 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;' erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWhile">
        <source>Unexpected end of input in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Unerwartetes Eingabeende im 'while'-Ausdruck. Es wurde 'while &lt;expr&gt; do &lt;expr&gt;' erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFor">
        <source>Unexpected end of input in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Unerwartetes Eingabeende im 'for'-Ausdruck. Es wurde 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;' erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWith">
        <source>Unexpected end of input in 'match' or 'try' expression</source>
        <target state="translated">Unerwartetes Eingabeende im 'match'- oder 'try'-Ausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileThen">
        <source>Unexpected end of input in 'then' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Unerwartetes Eingabeende in der 'then'-Verzweigung des bedingten Ausdrucks. Es wurde 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileElse">
        <source>Unexpected end of input in 'else' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Unerwartetes Eingabeende in der 'else'-Verzweigung des bedingten Ausdrucks. Es wurde 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFunBody">
        <source>Unexpected end of input in body of lambda expression. Expected 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</source>
        <target state="translated">Unerwartetes Eingabeende im Text des lambda-Ausdrucks. Es wurde 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;' erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeArgs">
        <source>Unexpected end of input in type arguments</source>
        <target state="translated">Unerwartetes Eingabeende in den Typargumenten</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeSignature">
        <source>Unexpected end of input in type signature</source>
        <target state="translated">Unerwartetes Eingabeende in der Typsignatur</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeDefinition">
        <source>Unexpected end of input in type definition</source>
        <target state="translated">Unerwartetes Eingabeende in der Typdefinition</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileObjectMembers">
        <source>Unexpected end of input in object members</source>
        <target state="translated">Unerwartetes Eingabeende in Objektmembern</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileDefinition">
        <source>Unexpected end of input in value, function or member definition</source>
        <target state="translated">Unerwartetes Eingabeende im Wert, der Funktion oder der Memberdefinition</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileExpression">
        <source>Unexpected end of input in expression</source>
        <target state="translated">Unerwartetes Eingabeende im Ausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedNameAfterToken">
        <source>Unexpected end of type. Expected a name after this point.</source>
        <target state="translated">Unerwartetes Typende. Nach diesem Punkt wurde ein Name erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLet">
        <source>Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.</source>
        <target state="translated">Unvollständiger Wert oder unvollständige Funktionsdefinition. Wenn es sich hierbei um einen Ausdruck handelt, muss der Text des Ausdrucks in dieselbe Spalte wie das Schlüsselwort 'let' eingezogen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLetBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword.</source>
        <target state="translated">Unvollständige Wertdefinition. Wenn es sich hierbei um einen Ausdruck handelt, muss der Text des Ausdrucks in dieselbe Spalte wie das Schlüsselwort 'let!' eingezogen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUseBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword.</source>
        <target state="translated">Unvollständige Wertdefinition. Wenn es sich hierbei um einen Ausdruck handelt, muss der Text des Ausdrucks in dieselbe Spalte wie das Schlüsselwort 'use!' eingezogen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUse">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword.</source>
        <target state="translated">Unvollständige Wertdefinition. Wenn es sich hierbei um einen Ausdruck handelt, muss der Text des Ausdrucks in dieselbe Spalte wie das Schlüsselwort 'use' eingezogen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsWhileDoExpected">
        <source>Missing 'do' in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Fehlendes 'do' in 'while'-Ausdruck. Es wurde 'while &lt;expr&gt; do &lt;expr&gt;' erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsForDoExpected">
        <source>Missing 'do' in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Fehlendes 'do' in 'for'-Ausdruck. Es wurde 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;' erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRelationInJoin">
        <source>Invalid join relation in '{0}'. Expected 'expr &lt;op&gt; expr', where &lt;op&gt; is =, =?, ?= or ?=?.</source>
        <target state="translated">Ungültige Joinbeziehung in '{0}'. Es wurde 'expr &lt;op&gt; expr' erwartet, wobei &lt;op&gt; =, =?, ?= oder ?=? ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCallsWord">
        <source>Calls</source>
        <target state="translated">Aufrufe</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidNumberOfGenericArguments">
        <source>Invalid number of generic arguments to type '{0}' in provided type. Expected '{1}' arguments, given '{2}'.</source>
        <target state="translated">Ungültige Anzahl generischer Argumente für Typ '{0}' im angegebenen Typ. Es wurden '{1}' Argumente erwartet, jedoch '{2}' ausgegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument1">
        <source>Invalid value '{0}' for unit-of-measure parameter '{1}'</source>
        <target state="translated">Ungültiger Wert '{0}' für Maßeinheitenparameter '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument2">
        <source>Invalid value unit-of-measure parameter '{0}'</source>
        <target state="translated">Ungültiger Wert für Maßeinheitenparameter '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyNeedsCanWriteOrCanRead">
        <source>Property '{0}' on provided type '{1}' is neither readable nor writable as it has CanRead=false and CanWrite=false</source>
        <target state="translated">Die '{0}'-Eigenschaft des angegebenen Typs '{1}' kann weder gelesen noch geschrieben werden, da sie auf CanRead=false und CanWrite=false festgelegt ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIntoNeedsRestOfQuery">
        <source>A use of 'into' must be followed by the remainder of the computation</source>
        <target state="translated">Bei der Verwendung von 'into' muss der Rest der Berechnung folgen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorDoesntAcceptInto">
        <source>The operator '{0}' does not accept the use of 'into'</source>
        <target state="translated">Der Operator '{0}' lässt die Verwendung von 'into' nicht zu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationInvalid">
        <source>The definition of the custom operator '{0}' does not use a valid combination of attribute flags</source>
        <target state="translated">Für die Definition des benutzerdefinierten Operatoren '{0}' wird keine gültige Kombination von Attributflags verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisTypeMayNotHaveACLIMutableAttribute">
        <source>This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute.</source>
        <target state="translated">Diese Typdefinition darf nicht über das 'CLIMutable'-Attribut verfügen. Nur Datensatztypen dürfen über dieses Attribut verfügen.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAutoPropertyRequiresImplicitConstructionSequence">
        <source>'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">'member val'-Definitionen sind nur in Typen mit einem primären Konstruktor zulässig. Möglicherweise sollten Sie Ihrer Typdefinition Argumente hinzufügen, z. B. 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSet">
        <source>Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Eigenschaftsdefinitionen können nicht änderbar deklariert werden. Um anzugeben, dass diese Eigenschaft festgelegt werden kann, verwenden Sie 'member val PropertyName = expr with get,set'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
        <source>To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Um anzugeben, dass diese Eigenschaft festgelegt werden kann, verwenden Sie "'member val PropertyName = expr with get,set".</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefsOfByrefs">
        <source>Type '{0}' is illegal because in byref&lt;T&gt;, T cannot contain byref types.</source>
        <target state="translated">Typ '{0}' ist unzulässig, da T in byref&lt;T&gt; keine byref-Typen enthalten darf.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastopsMaxArrayThirtyTwo">
        <source>F# supports array ranks between 1 and 32. The value {0} is not allowed.</source>
        <target state="translated">F# unterstützt einen Arrayrang zwischen 1 und 32. Der Wert {0} ist nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoIntegerForLoopInQuery">
        <source>In queries, use the form 'for x in n .. m do ...' for ranging over integers</source>
        <target state="translated">Verwenden Sie in Abfragen die Form 'for x in n .. m do ...' für bereichsübergreifende Integer.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoWhileInQuery">
        <source>'while' expressions may not be used in queries</source>
        <target state="translated">'while'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoTryFinallyInQuery">
        <source>'try/finally' expressions may not be used in queries</source>
        <target state="translated">'try/finally'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseMayNotBeUsedInQueries">
        <source>'use' expressions may not be used in queries</source>
        <target state="translated">'use'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindMayNotBeUsedInQueries">
        <source>'let!', 'use!' and 'do!' expressions may not be used in queries</source>
        <target state="translated">Die 'let!'-, 'use!'- und 'do!'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnMayNotBeUsedInQueries">
        <source>'return' and 'return!' may not be used in queries</source>
        <target state="translated">'return'- und 'return!'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryOperator">
        <source>This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type.</source>
        <target state="translated">Dies ist kein bekannter Abfrageoperator. Abfrageoperatoren sind Bezeichner wie z. B. 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' und 'averageBy', die mithilfe der entsprechenden Methoden für den Typ 'QueryBuilder' definiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryWithMayNotBeUsedInQueries">
        <source>'try/with' expressions may not be used in queries</source>
        <target state="translated">'try/with'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonSimpleLetBindingInQuery">
        <source>This 'let' definition may not be used in a query. Only simple value definitions may be used in queries.</source>
        <target state="translated">Diese 'let'-Definition darf in einer Abfrage nicht verwendet werden. In Abfragen dürfen nur einfache Wertdefinitionen verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTooManyStaticParameters">
        <source>Too many static parameters. Expected at most {0} parameters, but got {1} unnamed and {2} named parameters.</source>
        <target state="translated">Zu viele statische Parameter. Es wurden höchstens {0} Parameter erwartet, zurückgegeben wurden jedoch {1} unbenannte und {2} benannte Parameter.</target>
        <note />
      </trans-unit>
      <trans-unit id="infosInvalidProvidedLiteralValue">
        <source>Invalid provided literal value '{0}'</source>
        <target state="translated">Ungültiger angegebener Literalwert '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidPlatformTarget">
        <source>The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead.</source>
        <target state="translated">Die Plattform 'anycpu32bitpreferred' kann nur mit EXE-Zielen verwendet werden. Stattdessen muss 'anycpu' verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisValueMayNotBeInlined">
        <source>This member, function or value declaration may not be declared 'inline'</source>
        <target state="translated">Diese Member-, Funktions- oder der Wertdeklaration darf nicht mit 'inline' deklariert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErasedTypeUsedInGeneration">
        <source>The provider '{0}' returned a non-generated type '{1}' in the context of a set of generated types. Consider adjusting the type provider to only return generated types.</source>
        <target state="translated">Der Anbieter "{0}" hat einen nicht generierten Typ "{1}" im Kontext einer Reihe von generierten Typen zurückgegeben. Ziehen Sie eine Anpassung des Typanbieters in Betracht, damit dieser nur generierte Typen zurückgibt.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryBinaryOperator">
        <source>Arguments to query operators may require parentheses, e.g. 'where (x &gt; y)' or 'groupBy (x.Length / 10)'</source>
        <target state="translated">Argumente für Abfrageoperatoren erfordern möglicherweise Klammern, z. B. 'where (x &gt; y)' oder 'groupBy (x.Length / 10)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoSetOfHole">
        <source>A quotation may not involve an assignment to or taking the address of a captured local variable</source>
        <target state="translated">Eine Quotation darf keine Zuweisung zu einer erfassten lokalen Variable enthalten oder deren Adresse übernehmen</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloads1">
        <source>+ 1 overload</source>
        <target state="translated">+ 1 Überladung</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloadsN">
        <source>+ {0} overloads</source>
        <target state="translated">+ {0} Überladungen</target>
        <note />
      </trans-unit>
      <trans-unit id="erasedTo">
        <source>Erased to</source>
        <target state="translated">Gelöscht zu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnfinishedExpression">
        <source>Unexpected token '{0}' or incomplete expression</source>
        <target state="translated">Unerwartetes Token "{0}" oder unvollständiger Ausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributeOnIncompleteCode">
        <source>Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.</source>
        <target state="translated">Codeziel für dieses Attribut kann nicht gefunden werden. Möglicherweise ist der Code nach dem Attribut unvollständig.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeNameCannotBeEmpty">
        <source>Type name cannot be empty.</source>
        <target state="translated">Der Typname darf nicht leer sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemReadingAssembly">
        <source>Problem reading assembly '{0}': {1}</source>
        <target state="translated">Problem beim Lesen von Assembly "{0}": {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTPFieldMustBeLiteral">
        <source>Invalid provided field. Provided fields of erased provided types must be literals.</source>
        <target state="translated">Ungültiges angegebenes Feld. Die angegebenen Felder von gelöschten angegebenen Typen müssen Literale sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="loadingDescription">
        <source>(loading description...)</source>
        <target state="translated">(Die Beschreibung wird geladen…)</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionUnavailable">
        <source>(description unavailable...)</source>
        <target state="translated">(Die Beschreibung ist nicht verfügbar...)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTyparMultipleClassConstraints">
        <source>A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.</source>
        <target state="translated">Eine Typvariable wurde durch mehrere unterschiedliche Klassentypen eingeschränkt. Eine Typvariable weist möglicherweise nur eine Klasseneinschränkung auf.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMatchMayNotBeUsedWithQuery">
        <source>'match' expressions may not be used in queries</source>
        <target state="translated">'match'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonTripleArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 3 arguments</source>
        <target state="translated">Infix-Operatormember '{0}' weist {1} anfängliche(s) Argument(e) auf. Erwartet wurde ein Tupel mit 3 Argumenten</target>
        <note />
      </trans-unit>
      <trans-unit id="cannotResolveNullableOperators">
        <source>The operator '{0}' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Der Operator '{0}' konnte nicht aufgelöst werden. Möglicherweise sollte das Modul 'Microsoft.FSharp.Linq.NullableOperators' geöffnet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorRequiresIn">
        <source>'{0}' must be followed by 'in'. Usage: {1}.</source>
        <target state="translated">"{0}" muss von "in" gefolgt werden. Verwendung: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalMemberVarInObjectImplementation">
        <source>Neither 'member val' nor 'override val' definitions are permitted in object expressions.</source>
        <target state="translated">Weder die Definition 'member val' noch die Definition 'override val' ist in Objektausdrücken zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyCopyAndUpdateRecordInvalid">
        <source>Copy-and-update record expressions must include at least one field.</source>
        <target state="translated">Copy-and-Update-Datensatzausdrücke müssen mindestens ein Feld enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnderscoreInvalidFieldName">
        <source>'_' cannot be used as field name</source>
        <target state="translated">'_' kann nicht als Feldname verwendet werden</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGeneratedTypesShouldBeInternalOrPrivate">
        <source>The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'.</source>
        <target state="translated">Die angegebenen Typen, die durch diese Verwendung eines Typanbieters generiert wurden, können von anderen F#-Assemblys nicht verwendet werden und sollten als intern oder privat markiert werden. Verwenden Sie stattdessen 'type internal TypeName = ...' oder 'type private TypeName = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterAndSetterHaveSamePropertyType">
        <source>A property's getter and setter must have the same type. Property '{0}' has getter of type '{1}' but setter of type '{2}'.</source>
        <target state="translated">Getter und Setter einer Eigenschaft müssen denselben Typ aufweisen. Eigenschaft '{0}' hat einen Getter vom Typ '{1}', jedoch einen Setter vom Typ '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRuntimeSuppliedMethodCannotBeUsedInUserCode">
        <source>Array method '{0}' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.</source>
        <target state="translated">Die Arraymethode '{0}' wird von der Laufzeit bereitgestellt und kann nicht direkt in Code verwendet werden. Ziehen Sie bei Vorgängen mit Arrayelementen die Familie der GetArray/SetArray-Funktionen aus dem LanguagePrimitives.IntrinsicFunctions-Modul in Erwägung.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName">
        <source>Union case/exception '{0}' does not have field named '{1}'.</source>
        <target state="translated">Union-Fall/Ausnahme '{0}' verfügt nicht über ein Feld mit dem Namen '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseFieldCannotBeUsedMoreThanOnce">
        <source>Union case/exception field '{0}' cannot be used more than once.</source>
        <target state="translated">Feld für Union-Fall/Ausnahme '{0}' kann nicht mehrmals verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameIsUsedModeThanOnce">
        <source>Named field '{0}' is used more than once.</source>
        <target state="translated">Das Feld mit dem Namen '{0}' wird mehrmals verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameConflictsWithGeneratedNameForAnonymousField">
        <source>Named field '{0}' conflicts with autogenerated name for anonymous field.</source>
        <target state="translated">Das Feld mit dem Namen '{0}' steht in Konflikt mit dem automatisch generierten Namen für ein anonymes Feld.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConstantExpressionOverflow">
        <source>This literal expression or attribute argument results in an arithmetic overflow.</source>
        <target state="translated">Dieser literale Ausdruck oder dieses Attributargument führt zu einem arithmetischen Überlauf.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalStructTypeForConstantExpression">
        <source>This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.</source>
        <target state="translated">Dies ist kein gültiger literaler Ausdruck. Das [&lt;Literal&gt;]-Attribut wird ignoriert.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscSystemRuntimeInteropServicesIsRequired">
        <source>System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.</source>
        <target state="translated">System.Runtime.InteropServices-Assembly erfordert Verwendung von UnknownWrapper\DispatchWrapper-Klassen.</target>
        <note />
      </trans-unit>
      <trans-unit id="abImplicitHeapAllocation">
        <source>The mutable local '{0}' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.</source>
        <target state="translated">Die änderbare lokale Variable "{0}" ist implizit als Verweiszelle zugewiesen, da sie von einem Abschluss erfasst wurde. Diese Warnung dient nur zur Information und soll auf die Ausführungsorte impliziter Zuweisungen hinweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="estApplyStaticArgumentsForMethodNotImplemented">
        <source>A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid</source>
        <target state="translated">Von einem Typanbieter wurde "GetStaticParametersForMethod" implementiert, aber "ApplyStaticArgumentsForMethod" wurde nicht implementiert oder war ungültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToMethod">
        <source>An error occured applying the static arguments to a provided method</source>
        <target state="translated">Fehler beim Anwenden der statischen Argumente auf eine angegebene Methode.</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexUnexpectedChar">
        <source>Unexpected character '{0}' in preprocessor expression</source>
        <target state="translated">Unerwartetes Zeichen "{0}" im Präprozessorausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsUnexpectedToken">
        <source>Unexpected token '{0}' in preprocessor expression</source>
        <target state="translated">Unerwartetes Token "{0}" im Präprozessorausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsIncompleteExpression">
        <source>Incomplete preprocessor expression</source>
        <target state="translated">Unvollständiger Präprozessorausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsMissingToken">
        <source>Missing token '{0}' in preprocessor expression</source>
        <target state="translated">Fehlendes Token "{0}" im Präprozessorausdruck.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleMissingDefinition">
        <source>An error occurred while reading the F# metadata node at position {0} in table '{1}' of assembly '{2}'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.</source>
        <target state="translated">Beim Lesen des F#-Metadatenknotens an Position {0} in Tabelle "{1}" von Assembly "{2}" ist ein Fehler aufgetreten. Der Knoten besaß keine übereinstimmende Deklarierung. Melden Sie diese Warnung. Sie müssen die von Ihnen verwendete F#-Assembly möglicherweise neu kompilieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScope">
        <source>Type inference caused the type variable {0} to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.</source>
        <target state="translated">Ein Typrückschluss hat bewirkt, dass die Typvariable '{0}' ihren Bereich verlassen hat. Fügen Sie ggf. eine explizite Typparameterdeklaration hinzu, oder passen Sie Ihren Code so an, dass er weniger generisch ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScopeAnon">
        <source>Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.</source>
        <target state="translated">Ein Typrückschluss hat bewirkt, dass eine Variable vom Rückschlusstyp ihren Bereich verlassen hat. Fügen Sie ggf. Typanmerkungen hinzu, damit Ihr Code weniger generisch ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkRaiseFamilyFunctionArgumentCount">
        <source>Redundant arguments are being ignored in function '{0}'. Expected {1} but got {2} arguments.</source>
        <target state="translated">Redundante Argumente werden in der Funktion '{0}' ignoriert. Erwartet wurden {1} Argumente, abgerufen jedoch {2} Argumente.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkLowercaseLiteralBindingInPattern">
        <source>Lowercase literal '{0}' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.</source>
        <target state="translated">Das Literal in Kleinbuchstaben '{0}' verursacht einen Konflikt mit einem neuen Muster mit dem gleichen Namen. Nur Literale in Großbuchstaben und Literale mit Modulpräfix können als benannte Muster verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralDoesNotTakeArguments">
        <source>This literal pattern does not take arguments</source>
        <target state="translated">Dieses Literalmuster nimmt keine Argumente an.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalInAugmentation">
        <source>Constructors are not permitted as extension members - they must be defined as part of the original definition of the type</source>
        <target state="translated">Konstruktoren sind als Erweiterungsmember unzulässig. Sie müssen als Teil der ursprünglichen Definition des Typs definiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidResponseFile">
        <source>Invalid response file '{0}' ( '{1}' )</source>
        <target state="translated">Ungültige Antwortdatei "{0}" ("{1}").</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNotFound">
        <source>Response file '{0}' not found in '{1}'</source>
        <target state="translated">Die Antwortdatei "{0}" wurde in "{1}" nicht gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNameInvalid">
        <source>Response file name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">Der Antwortdateiname "{0}" ist leer, enthält ungültige Zeichen, weist eine Laufwerkspezifikation ohne einen absoluten Pfad auf oder ist zu lang.</target>
        <note />
      </trans-unit>
      <trans-unit id="fsharpCoreNotFoundToBeCopied">
        <source>Cannot find FSharp.Core.dll in compiler's directory</source>
        <target state="translated">FSharp.Core.dll wurde im Verzeichnis des Compilers nicht gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleStructMismatch">
        <source>One tuple type is a struct tuple, the other is a reference tuple</source>
        <target state="translated">Ein Tupeltyp ist ein Strukturtupel, der andere Typ ein Verweistupel.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMissingStaticArgumentsToMethod">
        <source>This provided method requires static parameters</source>
        <target state="translated">Diese angegebene Methode erfordert statische Parameter.</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcast">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'.</source>
        <target state="translated">Die Konvertierung aus {0} in {1} ist ein sicherer Ausdruck zur Umwandlung in eine Basisklasse zur Kompilierungszeit und kein Ausdruck zur Umwandlung in eine abgeleitet Klasse. Verwenden Sie ggf. "upcast" anstelle von "downcast".</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcastOperator">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.</source>
        <target state="translated">Die Konvertierung aus {0} in {1} ist ein sicherer Ausdruck zur Umwandlung in eine Basisklasse zur Kompilierungszeit und kein Ausdruck zur Umwandlung in eine abgeleitet Klasse. Verwenden Sie ggf. den Operator :&gt; (Ausdruck zur Umwandlung in eine Basisklasse) anstelle des Operators :?&gt; (Ausdruck zur Umwandlung in eine abgeleitet Klasse).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecImplied">
        <source>The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored</source>
        <target state="translated">rec für dieses Modul wird implizit durch eine äußere rec-Deklaration angegeben und daher ignoriert.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenFirstInMutRec">
        <source>In a recursive declaration group, 'open' declarations must come first in each module</source>
        <target state="translated">In einer rekursiven Deklarationsgruppe müssen open-Deklarationen in jedem Modul an erster Stelle auftreten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbrevFirstInMutRec">
        <source>In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations</source>
        <target state="translated">In einer rekursiven Deklarationsgruppe müssen Modulabkürzungen nach allen open-Deklarationen und vor anderen Deklarationen auftreten.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedMutRecDecl">
        <source>This declaration is not supported in recursive declaration groups</source>
        <target state="translated">Diese Deklaration wird in rekursiven Deklarationsgruppen nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidUseOfRec">
        <source>Invalid use of 'rec' keyword</source>
        <target state="translated">Ungültige Verwendung des Schlüsselworts "rec".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructUnionMultiCaseDistinctFields">
        <source>If a union type has more than one case and is a struct, then all fields within the union type must be given unique names.</source>
        <target state="translated">Wenn ein Union-Typ mehrere case-Anweisungen aufweist und eine Struktur ist, müssen für alle Felder im Union-Typ eindeutige Namen angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerMemberNameIsOverriden">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">Das auf Parameter "{0}" angewendete CallerMemberNameAttribute hat keine Auswirkung. Es wird vom CallerFilePathAttribute überschrieben.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFixedNotAllowed">
        <source>Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'</source>
        <target state="translated">Ungültige Verwendung von "fixed". "fixed" darf ausschließlich in einer Deklaration der Form "use x = fixed expr" verwendet werden. Dabei ist der Ausdruck ein Array, die Adresse eines Felds, die Adresse eines Arrayelements oder eine Zeichenfolge.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindOffsetToStringData">
        <source>Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression.</source>
        <target state="translated">Die Methode "System.Runtime.CompilerServices.OffsetToStringData" wurde beim Erstellen des fixed-Ausdrucks in den Verweisen nicht gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefReturnOfLocal">
        <source>The address of the variable '{0}' cannot be used at this point. A method or function may not return the address of this local value.</source>
        <target state="translated">Die Adresse der Variablen "{0}" kann an dieser Stelle nicht verwendet werden. Eine Methode oder Funktion gibt ggf. nicht die Adresse dieses lokalen Werts zurück.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedActivePattern">
        <source>{0} is an active pattern and cannot be treated as a discriminated union case with named fields.</source>
        <target state="translated">{0} ist ein aktives Muster und kann nicht als ein diskriminierter Union-Fall mit benannten Feldern behandelt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultParameterValueNotAppropriateForArgument">
        <source>The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'.</source>
        <target state="translated">Der Standardwert hat nicht den gleichen Typ wie das Argument. Das DefaultParameterValue-Attribut sowie ggf. vorhandene optionale Attribute werden ignoriert. Hinweis: "null" muss mit dem richtigen Typ gekennzeichnet sein. Beispiel: DefaultParameterValue(null:obj).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGlobalsSystemTypeNotFound">
        <source>The system type '{0}' was required but no referenced system DLL contained this type</source>
        <target state="translated">Der Systemtyp "{0}" war erforderlich, aber in keiner referenzierten System-DLL vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberHasMultiplePossibleDispatchSlots">
        <source>The member '{0}' matches multiple overloads of the same method.\nPlease restrict it to one of the following:{1}.</source>
        <target state="translated">Der Member "{0}" entspricht mehreren Überladungen der gleichen Methode.\nBeschränken Sie ihn auf eine der folgenden Optionen: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="methodIsNotStatic">
        <source>Method or object constructor '{0}' is not static</source>
        <target state="translated">Methode oder Objektkonstruktor "{0}" ist nicht statisch.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolEqualsInsteadOfIn">
        <source>Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?</source>
        <target state="translated">Unerwartetes Symbol "=" im Ausdruck. Wollten Sie stattdessen "for x in y .. z do" verwenden?</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAbstract">
        <source>Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</source>
        <target state="translated">Gibt eine Methode an, die entweder im Typ, in dem sie deklariert wird, über keine Implementierung verfügt oder die virtuell ist und über eine Standardimplementierung verfügt.</target>
        <note />
      </trans-unit>
      <trans-unit id="keyworkDescriptionAnd">
        <source>Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</source>
        <target state="translated">Wird in gegenseitig rekursiven Bindungen, in Eigenschaftendeklarationen und bei mehreren Beschränkungen in Bezug auf generische Parameter verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAs">
        <source>Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</source>
        <target state="translated">Wird verwendet, um für das aktuelle Klassenobjekt einen Objektnamen zu vergeben. Wird auch verwendet, um für ein gesamtes Muster innerhalb eines Musterabgleichs einen Namen zu vergeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAssert">
        <source>Used to verify code during debugging.</source>
        <target state="translated">Wird verwendet, um den Code während des Debuggens zu überprüfen.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBase">
        <source>Used as the name of the base class object.</source>
        <target state="translated">Wird als Name des Basisklassenobjekts verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBegin">
        <source>In verbose syntax, indicates the start of a code block.</source>
        <target state="translated">Gibt in ausführlicher Syntax den Start eines Codeblocks an.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionClass">
        <source>In verbose syntax, indicates the start of a class definition.</source>
        <target state="translated">Gibt in ausführlicher Syntax den Beginn einer Klassendefinition an.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDefault">
        <source>Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</source>
        <target state="translated">Gibt eine Implementierung einer abstrakten Methode an; wird gemeinsam mit einer abstrakten Methodendeklaration zum Erstellen einer virtuellen Methode verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDelegate">
        <source>Used to declare a delegate.</source>
        <target state="translated">Wird verwendet, um einen Delegaten zu deklarieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDo">
        <source>Used in looping constructs or to execute imperative code.</source>
        <target state="translated">Wird in Schleifenkonstrukten oder zum Ausführen von imperativem Code verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDone">
        <source>In verbose syntax, indicates the end of a block of code in a looping expression.</source>
        <target state="translated">Gibt in ausführlicher Syntax das Ende eines Codeblocks in einem Schleifenausdruck an.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDowncast">
        <source>Used to convert to a type that is lower in the inheritance chain.</source>
        <target state="translated">Wird zum Konvertieren in einen Typ verwendet, der in Vererbungskette niedriger ist. </target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDownto">
        <source>In a for expression, used when counting in reverse.</source>
        <target state="translated">Wird in einem for-Ausdruck beim Rückwährtszählen verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElif">
        <source>Used in conditional branching. A short form of else if.</source>
        <target state="translated">Wird in Verzweigungskonstrukten verwendet. Eine Kurzform von "else if".</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElse">
        <source>Used in conditional branching.</source>
        <target state="translated">Wird in Verzweigungskonstrukten verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionEnd">
        <source>In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</source>
        <target state="translated">Gibt in Typendefinitionen und Typerweiterungen das Ende eines Abschnitts von Memberdefinitionen an. Wird in ausführlicher Syntax verwendet, um das Ende eines Codeblocks festzulegen, der mit dem Anfangsschlüsselwort beginnt.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionException">
        <source>Used to declare an exception type.</source>
        <target state="translated">Wird verwendet, um einen Ausnahmetyp zu deklarieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionExtern">
        <source>Indicates that a declared program element is defined in another binary or assembly.</source>
        <target state="translated">Gibt an, dass ein deklariertes Programmelement in einem anderen Binär oder einer anderen Assembly definiert ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTrueFalse">
        <source>Used as a Boolean literal.</source>
        <target state="translated">Wird als boolesches Literal verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFinally">
        <source>Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</source>
        <target state="translated">Wird zusammen mit "try" verwendet, um einen Codeblock bereitzustellen, der unabhängig davon ausgeführt wird, ob eine Ausnahme auftritt.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFor">
        <source>Used in looping constructs.</source>
        <target state="translated">Wird in Schleifenkonstrukten verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFun">
        <source>Used in lambda expressions, also known as anonymous functions.</source>
        <target state="translated">Wird in Lambdaausdrücken verwendet, auch als anonyme Funktionen bekannt.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFunction">
        <source>Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</source>
        <target state="translated">Wird als kürzere Alternative zum fun-Schlüsselwort und einen Vergleichsausdruck in einem Lambdaausdruck verwendet, der über Musterabgleich für ein einzelnes Argument verfügt.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionGlobal">
        <source>Used to reference the top-level .NET namespace.</source>
        <target state="translated">Wird verwendet, um auf den .NET-Namespace der obersten Ebene zu verweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIf">
        <source>Used in conditional branching constructs.</source>
        <target state="translated">Wird in bedingten Verzweigungskonstrukten verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIn">
        <source>Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</source>
        <target state="translated">Wird für Sequenzausdrücke und in ausführlicher Syntax zum Trennen von Ausdrücken aus Bindungen verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInherit">
        <source>Used to specify a base class or base interface.</source>
        <target state="translated">Wird verwendet, um eine Basisklasse oder Basisschnittstelle festzulegen.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInline">
        <source>Used to indicate a function that should be integrated directly into the caller's code.</source>
        <target state="translated">Wird verwendet, um eine Funktion anzugeben, die direkt in den Code der aufrufenden Funktion integriert werden soll.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInterface">
        <source>Used to declare and implement interfaces.</source>
        <target state="translated">Wird verwendet, um Schnittstellen zu deklarieren und implementieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInternal">
        <source>Used to specify that a member is visible inside an assembly but not outside it.</source>
        <target state="translated">Wird verwendet, um festzulegen, dass ein Member innerhalb einer Assembly sichtbar ist, außerhalb jedoch nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLazy">
        <source>Used to specify a computation that is to be performed only when a result is needed.</source>
        <target state="translated">Wird verwendet, um eine Berechnung festzulegen, die nur ausgeführt wird, wenn ein Ergebnis erforderlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLet">
        <source>Used to associate, or bind, a name to a value or function.</source>
        <target state="translated">Wird verwendet, um einen Namen einem Wert oder einer Funktion zuzuordnen oder daran zu binden.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLetBang">
        <source>Used in asynchronous workflows to bind a name to the result of an asynchronous computation, or, in other computation expressions, used to bind a name to a result, which is of the computation type.</source>
        <target state="translated">Wird in asynchronen Workflows verwendet, um einen Namen an das Ergebnis einer asynchronen Berechnung zu binden, oder in anderen Berechnungsausdrücken, um einen Namen an ein Ergebnis vom Berechnungstyp zu binden.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatch">
        <source>Used to branch by comparing a value to a pattern.</source>
        <target state="translated">Wird zum Verzweigen verwendet, indem ein Wert mit einem Muster verglichen wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMember">
        <source>Used to declare a property or method in an object type.</source>
        <target state="translated">Wird verwendet, um eine Eigenschaft oder Methode in einem Objekttypen zu deklarieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionModule">
        <source>Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</source>
        <target state="translated">Wird verwendet, um einen Namen einer Gruppe zugehöriger Typen, Werte und Funktionen zuzuordnen, um ihn logisch von anderem Code zu trennen.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMutable">
        <source>Used to declare a variable, that is, a value that can be changed.</source>
        <target state="translated">Wird verwendet, um eine Variable zu deklarieren, d. h. einen veränderlichen Wert.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNamespace">
        <source>Used to associate a name with a group of related types and modules, to logically separate it from other code.</source>
        <target state="translated">Wird verwendet, um einen Namen einer Gruppe zugehöriger Typen und Module zuzuordnen, um ihn logisch von anderem Code zu trennen.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNew">
        <source>Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.</source>
        <target state="translated">Wird verwendet, um einen Konstruktor zu deklarieren, definieren oder aufzurufen, der ein Objekt erstellt oder erstellen kann. Wird auch in generischen Parameterbeschränkungen verwendet, um anzugeben, dass ein Typ über einen bestimmten Konstruktor verfügen muss.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNot">
        <source>Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</source>
        <target state="translated">Kein tatsächliches Schlüsselwort. "not struct" wird in Kombination als generische Parametereinschränkung verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNull">
        <source>Indicates the absence of an object. Also used in generic parameter constraints.</source>
        <target state="translated">Gibt die Abwesenheit eines Objekts an. Wird auch in generischen Parameterbeschränkungen verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOf">
        <source>Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</source>
        <target state="translated">Wird in Unterscheidungs-Unions verwenden, um den Typ der Wertekategorien anzugeben, sowie in Delegaten und Ausnahmedeklarationen.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOpen">
        <source>Used to make the contents of a namespace or module available without qualification.</source>
        <target state="translated">Wird verwendet, um den Inhalt eines Namespace oder Moduls ohne Qualifizierung verfügbar zu machen.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOr">
        <source>Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.</source>
        <target state="translated">Wird mit booleschen Bedingungen als boolescher Wert oder Operator verwendet. Entspricht ||. Wird auch in Memberbeschränkungen verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOverride">
        <source>Used to implement a version of an abstract or virtual method that differs from the base version.</source>
        <target state="translated">Wird verwendet, um eine Version einer abstrakten oder virtuellen Methode zu implementieren, die sich von der Basisversion unterscheidet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPrivate">
        <source>Restricts access to a member to code in the same type or module.</source>
        <target state="translated">Beschränkt den Zugriff eines Element auf Code im gleichen Typ oder Modul.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPublic">
        <source>Allows access to a member from outside the type.</source>
        <target state="translated">Lässt von einer Position außerhalb des Typs den Zugriff auf ein Member zu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRec">
        <source>Used to indicate that a function is recursive.</source>
        <target state="translated">Wird verwendet, um anzugeben, dass eine Funktion rekursiv ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturn">
        <source>Used to indicate a value to provide as the result of a computation expression.</source>
        <target state="translated">Wird verwendet, um einen Wert anzugeben, der als Ergebnis eines Berechnungsausdrucks auszugeben ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturnBang">
        <source>Used to indicate a computation expression that, when evaluated, provides the result of the containing computation expression.</source>
        <target state="translated">Wird verwendet, um einen Berechnungsausdruck anzugeben, der bei der Auswertung das Ergebnis ausgibt, welches den Berechnungsausdruck enthält.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionSelect">
        <source>Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</source>
        <target state="translated">Wird in Abfrageausdrücken verwendet, um festzulegen, welche Felder oder Spalten extrahiert werden. Dies ist kontextabhängiges Schlüsselwort, d. h. es ist kein reserviertes Wort und funktioniert nur im entsprechenden Kontext als Schlüsselwort. </target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStatic">
        <source>Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</source>
        <target state="translated">Wird verwendet, um eine Methode oder Eigenschaft anzugeben, die ohne eine Instanz eines Typs aufgerufen werden kann, oder einen Wertemember, der für alle Instanzen eines Typs freigegeben wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStruct">
        <source>Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions.</source>
        <target state="translated">Wird verwendet, um einen Strukturtyp zu deklarieren. Wird auch in generischen Parameterbeschränkungen verwendet. Wird für die OCaml-Kompatibilität in Moduldefinitionen verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionThen">
        <source>Used in conditional expressions. Also used to perform side effects after object construction.</source>
        <target state="translated">Wird in Bedingungsausdrücken verwendet. Wird auch verwendet, um nach der Objektkonstruktion Nebeneffekte auszuführen.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTo">
        <source>Used in for loops to indicate a range.</source>
        <target state="translated">Wird in for-Schleifen zum Angeben eines Bereichs verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTry">
        <source>Used to introduce a block of code that might generate an exception. Used together with with or finally.</source>
        <target state="translated">Wird verwendet, um einen Codeblock einzuführen, der unter Umständen eine Ausnahme generiert. Wird zusammen mit "with" oder "finally" verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionType">
        <source>Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</source>
        <target state="translated">Wird verwendet, um Klassen, Datensätze, Strukturen, Unterscheidungs-Unions, Enumerationstypen, Maßeinheiten oder Typenabkürzungen zu deklarieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUpcast">
        <source>Used to convert to a type that is higher in the inheritance chain.</source>
        <target state="translated">Wird zum Konvertieren in einen Typ verwendet, der in Vererbungskette höher ist. </target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUse">
        <source>Used instead of let for values that require Dispose to be called to free resources.</source>
        <target state="translated">Wird anstelle von "let" für Werte verwendet, bei denen die "Dispose" zum Freigeben von Ressourcen erforderlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUseBang">
        <source>Used instead of let! in asynchronous workflows and other computation expressions for values that require Dispose to be called to free resources.</source>
        <target state="translated">Wird anstelle von "let!" in asynchronen Workflows und anderen Berechnungsausdrücken für Werte verwendet, bei denen die "Dispose" zum Freigeben von Ressourcen erforderlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVal">
        <source>Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</source>
        <target state="translated">Wird in einer Signatur verwendet, um einen Wert anzugeben, oder in wenigen Situationen in einem Typ, um einen Member zu deklarieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVoid">
        <source>Indicates the .NET void type. Used when interoperating with other .NET languages.</source>
        <target state="translated">Gibt den .NET-void-Typ an. Wird bei der Interaktion mit anderen .NET-Sprachen verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhen">
        <source>Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.</source>
        <target state="translated">Wird für boolesche Bedingungen (when-Klausel) bei Musterabgleichen sowie zum Einführen einer Einschränkungsklausel für einen generischen Typparameterparameter verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhile">
        <source>Introduces a looping construct.</source>
        <target state="translated">Führt ein Schleifenkonstrukt ein.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWith">
        <source>Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</source>
        <target state="translated">Wird zusammen mit dem Vergleichsschlüsselwort in Musterabgleichsausdrücken verwendet. Wird auch in Objektausdrücken, Datensatzkopierausdrücken und Typerweiterungen verwendet, um Memberdefinitionen und Ausnahmehandler bereitzustellen.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYield">
        <source>Used in a sequence expression to produce a value for a sequence.</source>
        <target state="translated">Wird in einem Sequenzausdruck zum Generieren eines Werts für eine Sequenz verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYieldBang">
        <source>Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</source>
        <target state="translated">Wird in einem Berechnungsausdruck zum Anhängen des Ergebnisses eines bestimmten Berechnungsausdrucks für eine Ergebnissammlung für den enthaltenden Berechnungsausdruck verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRightArrow">
        <source>In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions</source>
        <target state="translated">Begrenzt Argumente und Rückgabewerte in Funktionstypen. Ergibt einen Ausdruck (in Sequenzausdrücken); entspricht dem Yield-Schlüsselwort. Wird in Vergleichsausdrücken verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLeftArrow">
        <source>Assigns a value to a variable.</source>
        <target state="translated">Weist einen Wert einer Variablen zu.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionCast">
        <source>Converts a type to type that is higher in the hierarchy.</source>
        <target state="translated">Konvertiert einen Typ in einen Typen, der in der Hierarchie höher ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDynamicCast">
        <source>Converts a type to a type that is lower in the hierarchy.</source>
        <target state="translated">Konvertiert einen Typ in einen Typen, der in der Hierarchie niedriger ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTypedQuotation">
        <source>Delimits a typed code quotation.</source>
        <target state="translated">Begrenzt ein typisiertes Codezitat.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUntypedQuotation">
        <source>Delimits a untyped code quotation.</source>
        <target state="translated">Begrenzt ein nicht typisiertes Codezitat.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundDuringDynamicCodeGen">
        <source>{0} '{1}' not found in assembly '{2}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{0} "{1}" wurde in Assembly "{2}" nicht gefunden. Mögliche Ursache ist eine Versionsinkompatibilität. Möglicherweise müssen Sie die richtige Version dieser Assembly explizit referenzieren, damit alle referenzierten Komponenten die richtige Version benutzen können.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundInTypeDuringDynamicCodeGen">
        <source>{0} '{1}' not found in type '{2}' from assembly '{3}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{0} "{1}" wurde in Typ "{2} von Assembly "{3}" nicht gefunden. Mögliche Ursache ist eine Versionsinkompatibilität. Möglicherweise müssen Sie die richtige Version dieser Assembly explizit referenzieren, damit alle referenzierten Komponenten die richtige Version benutzen können.</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionWordIs">
        <source>is</source>
        <target state="translated">ist</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunction">
        <source>This value is not a function and cannot be applied.</source>
        <target state="translated">Dieser Wert ist keine Funktion und kann nicht angewendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexerWithName">
        <source>This value is not a function and cannot be applied. Did you intend to access the indexer via {0}.[index] instead?</source>
        <target state="translated">Dieser Wert ist keine Funktion und kann nicht angewendet werden. Wollten Sie auf den Indexer stattdessen über "{0}.[index]" zugreifen?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexer">
        <source>This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?</source>
        <target state="translated">Dieser Ausdruck ist keine Funktion und kann nicht angewendet werden. Wollten Sie auf den Indexer stattdessen über "expr.[index]" zugreifen?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeDeclaration">
        <source>This value is not a function and cannot be applied. Did you forget to terminate a declaration?</source>
        <target state="translated">Dieser Wert ist keine Funktion und kann nicht angewendet werden. Wurde möglicherweise eine Deklaration nicht abgeschlossen?</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentsInSigAndImplMismatch">
        <source>The argument names in the signature '{0}' and implementation '{1}' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling.</source>
        <target state="translated">Die Argumentnamen in Signatur "{0}" und Implementierung "{1}" stimmen nicht überein. Der Argumentname aus der Signaturdatei wird verwendet. Dadurch können Probleme beim Debuggen oder bei der Profilerstellung auftreten.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleUnexpectedNonZero">
        <source>An error occurred while reading the F# metadata of assembly '{0}'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct.</source>
        <target state="translated">Fehler beim Lesen der F#-Metadaten der Assembly "{0}". Es wurde ein reserviertes Konstrukt verwendet. Möglicherweise müssen Sie Ihren F#-Compiler aktualisieren oder eine frühere Version der Assembly verwenden, die dieses spezielle Konstrukt nicht verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleMemberNotNormallyUsed">
        <source>This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.</source>
        <target state="translated">Diese Methode oder Eigenschaft wird normalerweise nicht im F#-Code verwendet. Nutzen Sie stattdessen zur Dekonstruktion ein explizites Tupelmuster.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'.</source>
        <target state="translated">Dieser Ausdruck gibt einen Wert des Typs "{0}" zurück, wird aber implizit verworfen. Verwenden Sie ggf. "let", um das Ergebnis an einen Namen zu binden. Beispiel: "let Ergebnis = Ausdruck". Falls Sie den Ausdruck als Wert in der Sequenz einsetzen möchten, verwenden Sie explizit "yield".</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedSequenceInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'.</source>
        <target state="translated">Dieser Ausdruck gibt einen Wert des Typs "{0}" zurück, wird aber implizit verworfen. Verwenden Sie ggf. "let", um das Ergebnis an einen Namen zu binden. Beispiel: "let Ergebnis = Ausdruck". Falls Sie den Ausdruck als Wert in der Sequenz einsetzen möchten, verwenden Sie explizit "yield!".</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatchBang">
        <source>Used in computation expressions to pattern match directly over the result of another computation expression.</source>
        <target state="new">Used in computation expressions to pattern match directly over the result of another computation expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilreadFileChanged">
        <source>The file '{0}' changed on disk unexpectedly, please reload.</source>
        <target state="translated">Die Datei "{0}" wurde auf dem Datenträger unerwartet geändert. Laden Sie sie erneut.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>