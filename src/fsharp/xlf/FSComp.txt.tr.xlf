<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="tr" original="../FSComp.resx">
    <body>
      <trans-unit id="chkFeatureNotLanguageSupported">
        <source>Feature '{0}' is not available in F# {1}. Please use language version {2} or greater.</source>
        <target state="translated">'{0}' özelliği F# {1} sürümünde kullanılamıyor. Lütfen {2} veya daha yüksek bir dil sürümünü kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFeatureNotRuntimeSupported">
        <source>Feature '{0}' is not supported by target runtime.</source>
        <target state="translated">'{0}' özelliği hedef çalışma zamanı tarafından desteklenmiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFeatureNotSupportedInLibrary">
        <source>Feature '{0}' requires the F# library for language version {1} or greater.</source>
        <target state="translated">'{0}' özelliği için F# kitaplığının {1} veya üstü dil sürümü gerekir.</target>
        <note />
      </trans-unit>
      <trans-unit id="csAvailableOverloads">
        <source>Available overloads:\n{0}</source>
        <target state="translated">Kullanılabilir aşırı yüklemeler:\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructOrReferenceConstraint">
        <source>A generic construct requires that a generic type parameter be known as a struct or reference type. Consider adding a type annotation.</source>
        <target state="translated">Genel yapı, genel bir tür parametresinin yapı veya başvuru türü olarak bilinmesini gerektirir. Tür ek açıklaması eklemeyi düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundArgumentsPrefixPlural">
        <source>Known types of arguments: {0}</source>
        <target state="translated">Bilinen bağımsız değişken türleri: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundArgumentsPrefixSingular">
        <source>Known type of argument: {0}</source>
        <target state="translated">Bilinen bağımsız değişken türü: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundReturnType">
        <source>Known return type: {0}</source>
        <target state="translated">Bilinen dönüş türü: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundTypeParametersPrefixPlural">
        <source>Known type parameters: {0}</source>
        <target state="translated">Bilinen tür parametreleri: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundTypeParametersPrefixSingular">
        <source>Known type parameter: {0}</source>
        <target state="translated">Bilinen tür parametresi: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csOverloadCandidateIndexedArgumentTypeMismatch">
        <source>Argument at index {0} doesn't match</source>
        <target state="translated">{0} dizinindeki bağımsız değişken eşleşmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="csOverloadCandidateNamedArgumentTypeMismatch">
        <source>Argument '{0}' doesn't match</source>
        <target state="translated">'{0}' bağımsız değişkeni eşleşmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasDesignerAssemblyDependency">
        <source>The type provider designer assembly '{0}' could not be loaded from folder '{1}' because a dependency was missing or could not loaded. All dependencies of the type provider designer assembly must be located in the same folder as that assembly. The exception reported was: {2} - {3}</source>
        <target state="translated">'{0}' tür sağlayıcısı tasarımcı bütünleştirilmiş kodu, bir bağımlılık eksik olduğundan veya yüklenemediğinden '{1}' klasöründen yüklenemedi. Tür sağlayıcısı tasarımcısı bütünleştirilmiş kodunun tüm bağımlılıkları, ilgili bütünleştirilmiş kodun bulunduğu klasörde bulunmalıdır. Bildirilen özel durum: {2} - {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasDesignerAssemblyException">
        <source>The type provider designer assembly '{0}' could not be loaded from folder '{1}'. The exception reported was: {2} - {3}</source>
        <target state="translated">'{0}' tür sağlayıcısı tasarımcı bütünleştirilmiş kodu '{1}' klasöründen yüklenemedi. Bildirilen özel durum: {2} - {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssemblyNoPath">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded or doesn't exist. The exception reported was: {2} - {3}</source>
        <target state="translated">'{0}' bütünleştirilmiş kod özniteliği, yüklenemeyen veya mevcut olmayan '{1}' tasarımcı bütünleştirilmiş koduna başvuruyor. Bildirilen özel durum: {2} - {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="featureAndBang">
        <source>applicative computation expressions</source>
        <target state="translated">uygulama hesaplama ifadeleri</target>
        <note />
      </trans-unit>
      <trans-unit id="featureDefaultInterfaceMemberConsumption">
        <source>default interface member consumption</source>
        <target state="translated">varsayılan arabirim üyesi tüketimi</target>
        <note />
      </trans-unit>
      <trans-unit id="featureDotlessFloat32Literal">
        <source>dotless float32 literal</source>
        <target state="translated">noktasız float32 sabit değeri</target>
        <note />
      </trans-unit>
      <trans-unit id="featureExpandedMeasurables">
        <source>more types support units of measure</source>
        <target state="new">more types support units of measure</target>
        <note />
      </trans-unit>
      <trans-unit id="featureFixedIndexSlice3d4d">
        <source>fixed-index slice 3d/4d</source>
        <target state="translated">sabit dizinli dilim 3d/4d</target>
        <note />
      </trans-unit>
      <trans-unit id="featureFromEndSlicing">
        <source>from-end slicing</source>
        <target state="translated">uçtan dilimleme</target>
        <note />
      </trans-unit>
      <trans-unit id="featureImplicitYield">
        <source>implicit yield</source>
        <target state="translated">örtük yield</target>
        <note />
      </trans-unit>
      <trans-unit id="featureInterfacesWithMultipleGenericInstantiation">
        <source>interfaces with multiple generic instantiation</source>
        <target state="translated">birden çok genel örnek oluşturma içeren arabirimler</target>
        <note />
      </trans-unit>
      <trans-unit id="featureNameOf">
        <source>nameof</source>
        <target state="translated">nameof</target>
        <note />
      </trans-unit>
      <trans-unit id="featureNullableOptionalInterop">
        <source>nullable optional interop</source>
        <target state="translated">null atanabilir isteğe bağlı birlikte çalışma</target>
        <note />
      </trans-unit>
      <trans-unit id="featureOpenTypeDeclaration">
        <source>open type declaration</source>
        <target state="translated">açık tür bildirimi</target>
        <note />
      </trans-unit>
      <trans-unit id="featureOverloadsForCustomOperations">
        <source>overloads for custom operations</source>
        <target state="translated">özel işlemler için aşırı yüklemeler</target>
        <note />
      </trans-unit>
      <trans-unit id="featurePackageManagement">
        <source>package management</source>
        <target state="translated">paket yönetimi</target>
        <note />
      </trans-unit>
      <trans-unit id="featureRelaxWhitespace">
        <source>whitespace relexation</source>
        <target state="translated">boşluk genişlemesi</target>
        <note />
      </trans-unit>
      <trans-unit id="featureSingleUnderscorePattern">
        <source>single underscore pattern</source>
        <target state="translated">tek alt çizgi deseni</target>
        <note />
      </trans-unit>
      <trans-unit id="featureStringInterpolation">
        <source>string interpolation</source>
        <target state="translated">dizede düz metin arasına kod ekleme</target>
        <note />
      </trans-unit>
      <trans-unit id="featureWildCardInForLoop">
        <source>wild card in for loop</source>
        <target state="translated">for döngüsünde joker karakter</target>
        <note />
      </trans-unit>
      <trans-unit id="featureWitnessPassing">
        <source>witness passing for trait constraints in F# quotations</source>
        <target state="translated">F# alıntılarındaki nitelik kısıtlamaları için tanık geçirme</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated">
        <source>Interpolated strings may not use '%' format specifiers unless each is given an expression, e.g. '%d{{1+1}}'.</source>
        <target state="translated">Düz metin arasına kod eklenmiş dizeler, her birine '%d{{1+1}}' gibi bir ifade verilmedikçe '%' biçim belirticilerini kullanamaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated2">
        <source>.NET-style format specifiers such as '{{x,3}}' or '{{x:N5}}' may not be mixed with '%' format specifiers.</source>
        <target state="translated">'{{X,3}}' ya da '{{x:N5}}' gibi .NET stili biçim belirticileri '%' biçim belirticileriyle karışık kullanılamaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated3">
        <source>The '%P' specifier may not be used explicitly.</source>
        <target state="translated">'%P' belirticisi açık olarak kullanılamaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated4">
        <source>Interpolated strings used as type IFormattable or type FormattableString may not use '%' specifiers, only .NET-style interpolands such as '{{expr}}', '{{expr,3}}' or '{{expr:N5}}' may be used.</source>
        <target state="translated">IFormattable veya FormattableString türü olarak kullanılan düz metin arasına kod eklenmiş dizeler '%' belirticilerini kullanamaz. Yalnızca '{{ifade}}', '{{ifade,3}}' veya '{{ifade:N5}}' gibi .NET stili düz metin arasına kod ekleme işlemleri kullanılabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="formatDashItem">
        <source> - {0}</source>
        <target state="translated"> - {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="fromEndSlicingRequiresVFive">
        <source>From the end slicing with requires language version 5.0, use /langversion:preview.</source>
        <target state="translated">Sondan dilimleme, 5.0 dil sürümünü gerektirir, /langversion:preview kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="fsiInvalidDirective">
        <source>Invalid directive '#{0} {1}'</source>
        <target state="translated">Geçersiz yönerge '#{0} {1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionConst">
        <source>Keyword to specify a constant literal as a type parameter argument in Type Providers.</source>
        <target state="translated">Tür Sağlayıcılarında tür parametresi bağımsız değişkeni olarak sabit değişmez değeri belirtmek için anahtar sözcük.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteStringMayNotBeInterpolated">
        <source>a byte string may not be interpolated</source>
        <target state="translated">bir bayt dizesi, düz metin arasına kod eklenerek kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="lexRBraceInInterpolatedString">
        <source>A '}}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">Bir '}}' karakteri, düz metin arasına kod eklenmiş bir dizede kaçış dizisi ile (yineleme yapılarak) belirtilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexSingleQuoteInSingleQuote">
        <source>Invalid interpolated string. Single quote or verbatim string literals may not be used in interpolated expressions in single quote or verbatim strings. Consider using an explicit 'let' binding for the interpolation expression or use a triple quote string as the outer string literal.</source>
        <target state="translated">Geçersiz düz metin arasına kod eklenmiş dize. Tek tırnaklı veya düz metin dizesi sabitleri, tek tırnaklı veya düz metin dizelerinde düz metin arasına kod eklenmiş ifadelerde kullanılamaz. Düz metin arasına kod ekleme ifadesi için açık bir 'let' bağlaması kullanmayı düşünün veya dış dize sabiti olarak üç tırnaklı bir dize kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTripleQuoteInTripleQuote">
        <source>Invalid interpolated string. Triple quote string literals may not be used in interpolated expressions. Consider using an explicit 'let' binding for the interpolation expression.</source>
        <target state="translated">Geçersiz düz metin arasına kod eklenmiş dize. Üç tırnaklı dize sabitleri, düz metin arasına kod eklenmiş ifadelerde kullanılamaz. Düz metin arasına kod ekleme ifadesi için açık bir 'let' bağlaması kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="nativeResourceFormatError">
        <source>Stream does not begin with a null resource and is not in '.RES' format.</source>
        <target state="translated">Akış null kaynakla başlamıyor ve '.RES' biçiminde değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="nativeResourceHeaderMalformed">
        <source>Resource header beginning at offset {0} is malformed.</source>
        <target state="translated">{0} uzaklığında başlayan kaynak üst bilgisi hatalı biçimlendirilmiş.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLangVersion">
        <source>Display the allowed values for language version, specify language version such as 'latest' or 'preview'</source>
        <target state="translated">Dil sürümü için izin verilen değerleri görüntüleyin, dil sürümünü 'en son' veya 'önizleme' örneklerindeki gibi belirtin</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSupportedLangVersions">
        <source>Supported language versions:</source>
        <target state="translated">Desteklenen dil sürümleri:</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedLanguageVersion">
        <source>Unrecognized value '{0}' for --langversion use --langversion:? for complete list</source>
        <target state="translated">--langversion için '{0}' değeri tanınmıyor. Tam liste için --langversion:? kullanın</target>
        <note />
      </trans-unit>
      <trans-unit id="optsVersion">
        <source>Display compiler version banner and exit</source>
        <target state="new">Display compiler version banner and exit</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagementRequiresVFive">
        <source>The package management feature requires language version 5.0 use /langversion:preview</source>
        <target state="translated">Paket yönetimi özelliği dil sürümü 5.0 gerektiriyor, /langversion:preview kullanın</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyFillInInterpolatedString">
        <source>Invalid interpolated string. This interpolated string expression fill is empty, an expression was expected.</source>
        <target state="translated">Düz metin arasına kod eklenmiş dize geçersiz. Bu düz metin arasına kod eklenmiş dize ifade dolgusu boş. İfade bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedString">
        <source>Incomplete interpolated string begun at or before here</source>
        <target state="translated">Tamamlanmamış düz metin arasına kod eklenmiş dize, burada veya daha önce başlıyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedStringFill">
        <source>Incomplete interpolated string expression fill begun at or before here</source>
        <target state="translated">Tamamlanmamış düz metin arasına kod eklenmiş dize ifadesi dolgusu, burada veya daha önce başlıyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedTripleQuoteString">
        <source>Incomplete interpolated triple-quote string begun at or before here</source>
        <target state="translated">Tamamlanmamış düz metin arasına kod eklenmiş üç tırnaklı dize, burada veya daha önce başlıyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedVerbatimString">
        <source>Incomplete interpolated verbatim string begun at or before here</source>
        <target state="translated">Tamamlanmamış düz metin arasına kod eklenmiş düz metin dizesi, burada veya daha önce başlıyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEqualsMissingInTypeDefinition">
        <source>Unexpected token in type definition. Expected '=' after the type '{0}'.</source>
        <target state="new">Unexpected token in type definition. Expected '=' after the type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolDot">
        <source>Unexpected symbol '.' in member definition. Expected 'with', '=' or other token.</source>
        <target state="translated">Üye tanımında '.' sembolü beklenmiyordu. 'with', '=' veya başka bir belirteç bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecksumAlgorithm">
        <source>Specify algorithm for calculating source file checksum stored in PDB. Supported values are: SHA1 or SHA256 (default)</source>
        <target state="translated">PDB içinde depolanan kaynak dosyası sağlama toplamını hesaplama algoritmasını belirtin. Desteklenen değerler: SHA1 veya SHA256 (varsayılan)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">{0}' algoritması desteklenmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="poundiNotSupportedByRegisteredDependencyManagers">
        <source>#i is not supported by the registered PackageManagers</source>
        <target state="translated">#i, kayıtlı PackageManagers tarafından desteklenmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAndBangNotSupported">
        <source>This feature is not supported in this version of F#. You may need to add /langversion:preview to use this feature.</source>
        <target state="translated">Bu özellik, bu F# sürümünde desteklenmiyor. Bu özelliği kullanabilmeniz için /langversion:preview eklemeniz gerekebilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameDifferent">
        <source>This is the wrong anonymous record. It should have the fields {0}.</source>
        <target state="translated">Bu anonim kayıt yanlış. Kayıt, {0} alanlarını içermelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameSubset">
        <source>This anonymous record does not have enough fields. Add the missing fields {0}.</source>
        <target state="translated">Bu anonim kayıtta yeterli sayıda alan yok. Eksik {0} alanlarını ekleyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameSuperset">
        <source>This anonymous record has too many fields. Remove the extra fields {0}.</source>
        <target state="translated">Bu anonim kayıtta çok fazla alan var. Ek {0} alanlarını kaldırın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdInvalid">
        <source>Invalid Anonymous Record type declaration.</source>
        <target state="translated">Anonim Kayıt türü bildirimi geçersiz.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAugmentationsCannotHaveAttributes">
        <source>Attributes cannot be applied to type extensions.</source>
        <target state="translated">Öznitelikler tür uzantılarına uygulanamaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalByrefsInOpenTypeDeclaration">
        <source>Byref types are not allowed in an open type declaration.</source>
        <target state="translated">Açık tür bildiriminde Byref türlerine izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterpolationMixedWithPercent">
        <source>Mismatch in interpolated string. Interpolated strings may not use '%' format specifiers unless each is given an expression, e.g. '%d{{1+1}}'</source>
        <target state="translated">Düz metin arasına kod eklenmiş dizede uyuşmazlık. Düz metin arasına kod eklenmiş dizeler, her birine '%d{{1+1}}' gibi bir ifade verilmedikçe '%' biçim belirticilerini kullanamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAlignmentInInterpolatedString">
        <source>Invalid alignment in interpolated string</source>
        <target state="translated">Düz metin arasına kod eklenmiş dizede geçersiz hizalama</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBindingNoAndBangs">
        <source>use! may not be combined with and!</source>
        <target state="translated">use!, and! ile birleştirilemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralFieldAssignmentNoArg">
        <source>Cannot assign a value to another value marked literal</source>
        <target state="translated">Sabit değer olarak işaretlenen bir değere başka bir değer atanamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralFieldAssignmentWithArg">
        <source>Cannot assign '{0}' to a value marked literal</source>
        <target state="translated">Sabit değer olarak işaretlenen bir değere '{0}' atanamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireMergeSourcesOrBindN">
        <source>The 'let! ... and! ...' construct may only be used if the computation expression builder defines either a '{0}' method or appropriate 'MergeSource' and 'Bind' methods</source>
        <target state="translated">'let! ... and! ...' yapısı, yalnızca hesaplama ifadesi oluşturucu bir '{0}' metodunu ya da uygun 'MergeSource' ve 'Bind' metotlarını tanımlarsa kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseInterpolatedString">
        <source>Invalid interpolated string. {0}</source>
        <target state="translated">Geçersiz düz metin arasına kod eklenmiş dize. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceMemberNoMostSpecificImplementation">
        <source>Interface member '{0}' does not have a most specific implementation.</source>
        <target state="translated">'{0}' arabirim üyesinin en belirgin uygulaması yok.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceWithConcreteAndVariable">
        <source>'{0}' cannot implement the interface '{1}' with the two instantiations '{2}' and '{3}' because they may unify.</source>
        <target state="translated">'{0}', '{2}' ve '{3}' örnek oluşturmaları birleşebileceğinden '{1}' arabirimini bunlarla birlikte uygulayamaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceWithConcreteAndVariableObjectExpression">
        <source>You cannot implement the interface '{0}' with the two instantiations '{1}' and '{2}' because they may unify.</source>
        <target state="translated">'{1}' ve '{2}' örnek oluşturmaları birleşebileceğinden '{0}' arabirimini bunlarla birlikte uygulayamazsınız.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMemberWhenTypeIsKnown">
        <source>The type '{0}' does not define the field, constructor or member '{1}'.</source>
        <target state="translated">'{0}' türü; alanı, oluşturucuyu veya '{1}' üyesini tanımlamıyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespace">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">'{0}' ad alanı tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespaceOrModule">
        <source>The namespace or module '{0}' is not defined.</source>
        <target state="translated">'{0}' ad alanı veya modülü tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMember">
        <source>The field, constructor or member '{0}' is not defined.</source>
        <target state="translated">'{0}' alanı, oluşturucusu veya üyesi tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueConstructorNamespaceOrType">
        <source>The value, constructor, namespace or type '{0}' is not defined.</source>
        <target state="translated">'{0}' değeri, oluşturucusu, ad alanı veya türü tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueOfConstructor">
        <source>The value or constructor '{0}' is not defined.</source>
        <target state="translated">'{0}' değer veya oluşturucusu tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueNamespaceTypeOrModule">
        <source>The value, namespace, type or module '{0}' is not defined.</source>
        <target state="translated">'{0}' değeri, ad alanı, türü veya modülü tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameConstructorModuleOrNamespace">
        <source>The constructor, module or namespace '{0}' is not defined.</source>
        <target state="translated">'{0}' oluşturucusu, modülü veya ad alanı tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameType">
        <source>The type '{0}' is not defined.</source>
        <target state="translated">'{0}' türü tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeIn">
        <source>The type '{0}' is not defined in '{1}'.</source>
        <target state="translated">{0}' türü '{1}' içinde tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabelOrNamespace">
        <source>The record label or namespace '{0}' is not defined.</source>
        <target state="translated">'{0}' kayıt etiketi veya ad alanı tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabel">
        <source>The record label '{0}' is not defined.</source>
        <target state="translated">'{0}' kayıt etiketi tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameSuggestionsIntro">
        <source>Maybe you want one of the following:</source>
        <target state="translated">Aşağıdakilerden birini arıyor olabilirsiniz:</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeParameter">
        <source>The type parameter {0} is not defined.</source>
        <target state="translated">'{0}' tür parametresi tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNamePatternDiscriminator">
        <source>The pattern discriminator '{0}' is not defined.</source>
        <target state="translated">'{0}' desen ayrıştırıcısı tanımlı değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="replaceWithSuggestion">
        <source>Replace with '{0}'</source>
        <target state="translated">'{0}' ile değiştir</target>
        <note />
      </trans-unit>
      <trans-unit id="addIndexerDot">
        <source>Add . for indexer access.</source>
        <target state="translated">Dizin oluşturucu erişimi için . ekleyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="listElementHasWrongType">
        <source>All elements of a list must be of the same type as the first element, which here is '{0}'. This element has type '{1}'.</source>
        <target state="translated">Bir list constructor ifadesinin tüm öğeleri aynı türe sahip olmalıdır. Bu ifadenin '{0}' türünde olması bekleniyordu ancak burada '{1}' türünde.</target>
        <note />
      </trans-unit>
      <trans-unit id="arrayElementHasWrongType">
        <source>All elements of an array must be of the same type as the first element, which here is '{0}'. This element has type '{1}'.</source>
        <target state="translated">Bir array constructor ifadesinin tüm öğeleri aynı türe sahip olmalıdır. Bu ifadenin '{0}' türünde olması bekleniyordu ancak burada '{1}' türünde.</target>
        <note />
      </trans-unit>
      <trans-unit id="missingElseBranch">
        <source>This 'if' expression is missing an 'else' branch. Because 'if' is an expression, and not a statement, add an 'else' branch which also returns a value of type '{0}'.</source>
        <target state="translated">'if' ifadesinde bir 'else' dalı eksik. 'then' dalı '{0}' türünde. 'if' bir ifade değil deyim olduğundan, aynı türde değer döndüren bir 'else' dalı eklemeniz gerekir.</target>
        <note />
      </trans-unit>
      <trans-unit id="ifExpression">
        <source>The 'if' expression needs to have type '{0}' to satisfy context type requirements. It currently has type '{1}'.</source>
        <target state="translated">if' ifadesinin bağlam türü gereksinimlerini karşılayabilmesi için '{0}' türüne sahip olması gerekir. Şu anda '{1}' türüne sahip.</target>
        <note />
      </trans-unit>
      <trans-unit id="elseBranchHasWrongType">
        <source>All branches of an 'if' expression must return values of the same type as the first branch, which here is '{0}'. This branch returns a value of type '{1}'.</source>
        <target state="translated">Bir 'if' ifadesinin tüm dalları aynı türe sahip olmalıdır. Bu ifadenin '{0}' türünde olması bekleniyordu ancak burada '{1}' türünde.</target>
        <note />
      </trans-unit>
      <trans-unit id="followingPatternMatchClauseHasWrongType">
        <source>All branches of a pattern match expression must return values of the same type as the first branch, which here is '{0}'. This branch returns a value of type '{1}'.</source>
        <target state="translated">Bir desen eşleştirme ifadesinin tüm dalları aynı türdeki değerleri döndürmelidir. Birinci dal '{0}' türünde bir değer döndürdü ancak bu dal '{1}' türünde bir değer döndürdü.</target>
        <note />
      </trans-unit>
      <trans-unit id="patternMatchGuardIsNotBool">
        <source>A pattern match guard must be of type 'bool', but this 'when' expression is of type '{0}'.</source>
        <target state="translated">Bir desen eşleşmesi koruyucusunun 'bool' türünde olması gerekir, ancak bu 'when' ifadesi '{0}' türünde.</target>
        <note />
      </trans-unit>
      <trans-unit id="commaInsteadOfSemicolonInRecord">
        <source>A ';' is used to separate field values in records. Consider replacing ',' with ';'.</source>
        <target state="translated">Kayıtlarda alan değerlerini ayırmak için ';' kullanılır. ',' karakterini ';' ile değiştirmeyi düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="derefInsteadOfNot">
        <source>The '!' operator is used to dereference a ref cell. Consider using 'not expr' here.</source>
        <target state="translated">'!' operatörü bir ref hücresine başvurmak için kullanılır. Burada 'not expr' kullanmayı deneyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedTypeArgs">
        <source>The non-generic type '{0}' does not expect any type arguments, but here is given {1} type argument(s)</source>
        <target state="translated">Genel olmayan '{0}' türü herhangi bir tür bağımsız değişkeni beklemez, ancak burada {1} tür bağımsız değişkenleri verilmiş</target>
        <note />
      </trans-unit>
      <trans-unit id="returnUsedInsteadOfReturnBang">
        <source>Consider using 'return!' instead of 'return'.</source>
        <target state="translated">'return' yerine 'return!' kullanmayı deneyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="useSdkRefs">
        <source>Use reference assemblies for .NET framework references when available (Enabled by default).</source>
        <target state="translated">Kullanılabilir olduğunda, .NET Framework başvuruları için başvuru bütünleştirilmiş kodlarını kullanın (Varsayılan olarak etkindir).</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocBadlyFormed">
        <source>This XML comment is invalid: '{0}'</source>
        <target state="translated">Bu XML açıklaması geçersiz: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocDuplicateParameter">
        <source>This XML comment is invalid: multiple documentation entries for parameter '{0}'</source>
        <target state="translated">Bu XML açıklaması geçersiz: '{0}' parametresi için birden çok belge girişi var</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocInvalidParameterName">
        <source>This XML comment is invalid: unknown parameter '{0}'</source>
        <target state="translated">Bu XML açıklaması geçersiz: '{0}' parametresi bilinmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingCrossReference">
        <source>This XML comment is invalid: missing 'cref' attribute for cross-reference</source>
        <target state="translated">Bu XML açıklaması geçersiz. Çapraz başvuru için 'cref' özniteliği eksik</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingParameter">
        <source>This XML comment is incomplete: no documentation for parameter '{0}'</source>
        <target state="translated">Bu XML açıklaması eksik: '{0}' parametresi için belge yok</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingParameterName">
        <source>This XML comment is invalid: missing 'name' attribute for parameter or parameter reference</source>
        <target state="translated">Bu XML açıklaması geçersiz: Parametre veya parametre başvurusu için 'name' özniteliği eksik</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocUnresolvedCrossReference">
        <source>This XML comment is invalid: unresolved cross-reference '{0}'</source>
        <target state="translated">Bu XML açıklaması geçersiz: '{0}' çapraz başvurusu çözümlenmemiş</target>
        <note />
      </trans-unit>
      <trans-unit id="yieldUsedInsteadOfYieldBang">
        <source>Consider using 'yield!' instead of 'yield'.</source>
        <target state="translated">'yield' yerine 'yield!' kullanmayı deneyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="tupleRequiredInAbstractMethod">
        <source>\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.</source>
        <target state="translated">\nBir veya daha çok bağımsız değişken için demet türü gerekli. Verilen bağımsız değişkenleri ek parantezlerle sarmalamanız veya arabirimin tanımını gözden geçirmeniz önerilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidWarningNumber">
        <source>Invalid warning number '{0}'</source>
        <target state="translated">Geçersiz uyarı numarası '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionString">
        <source>Invalid version string '{0}'</source>
        <target state="translated">Geçersiz sürüm dizesi '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionFile">
        <source>Invalid version file '{0}'</source>
        <target state="translated">Geçersiz dosya sürümü '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemWithFilename">
        <source>Problem with filename '{0}': {1}</source>
        <target state="translated">Dosya adında hata: '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildNoInputsSpecified">
        <source>No inputs specified</source>
        <target state="translated">Bir giriş belirtilmedi</target>
        <note />
      </trans-unit>
      <trans-unit id="buildPdbRequiresDebug">
        <source>The '--pdb' option requires the '--debug' option to be used</source>
        <target state="translated">'--pdb' seçeneği '--debug' seçeneğinin kullanılmasını gerektirir</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSearchDirectory">
        <source>The search directory '{0}' is invalid</source>
        <target state="translated">Arama dizini '{0}' geçersiz</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSearchDirectoryNotFound">
        <source>The search directory '{0}' could not be found</source>
        <target state="translated">Arama dizini '{0}' bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidFilename">
        <source>'{0}' is not a valid filename</source>
        <target state="translated">'{0}' geçerli bir dosya adı değil</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidAssemblyName">
        <source>'{0}' is not a valid assembly name</source>
        <target state="translated">'{0}' geçerli bir bütünleştirilmiş kod adı değil</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidPrivacy">
        <source>Unrecognized privacy setting '{0}' for managed resource, valid options are 'public' and 'private'</source>
        <target state="translated">Yönetilen kaynak için tanınmayan gizlilik ayarı '{0}'; geçerli seçenekler: 'public' ve 'private'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCannotReadAssembly">
        <source>Unable to read assembly '{0}'</source>
        <target state="translated">'{0}' bütünleştirilmiş kodu okunamıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="buildAssemblyResolutionFailed">
        <source>Assembly resolution failure at or near this location</source>
        <target state="translated">Bu konumda veya yakınında bütünleştirilmiş kod çözme hatası</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplicitModuleIsNotLegalIdentifier">
        <source>The declarations in this file will be placed in an implicit module '{0}' based on the file name '{1}'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file.</source>
        <target state="translated">Bu dosyadaki bildirimler, '{1}' dosya adı temelinde örtük '{0}' modülüne yerleştirilecek. Ancak bu geçerli bir F# tanımlayıcısı olmadığından, içeriğine diğer dosyalardan erişilemeyecek. Dosyayı yeniden adlandırmayı veya dosyanın başına 'modül' ya da 'ad alanı' bildirimi eklemeyi düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultiFileRequiresNamespaceOrModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration.</source>
        <target state="translated">Kitaplıklardaki veya çok dosyalı uygulamalardaki dosyalar ad alanı veya modül bildirimiyle başlamalıdır, örn. 'namespace SomeNamespace.SubNamespace' veya 'module SomeNamespace.SomeModule'. Bir uygulamanın yalnızca son kaynak dosyasında böyle bir bildirim atlanabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="noEqualSignAfterModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.</source>
        <target state="translated">Kitaplıklar veya çok dosyalı uygulamalardaki dosyalar bir ad alanı veya modül bildirimiyle başlamalıdır. Bir dosyanın başında modül bildirimi kullanılırken '=' işaretine izin verilmez. Bu bir üst düzey modülse, bu hatayı çözmek için = işaretini kaldırmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleToplevelModules">
        <source>This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules.</source>
        <target state="translated">Bu dosya, 'module SomeNamespace.SomeModule' formunun birden çok bildirimini içeriyor. Bir dosyada, bu formun yalnızca bir bildirimine izin verilir. Dosyanızı başlangıç ad alanı bildirimi kullanacak şekilde değiştirin ve/veya modüllerinizi tanımlamak için 'module ModuleName = ...' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildOptionRequiresParameter">
        <source>Option requires parameter: {0}</source>
        <target state="translated">Seçenek şu parametreyi gerektiriyor: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotFindSourceFile">
        <source>Source file '{0}' could not be found</source>
        <target state="translated">Kaynak dosya '{0}' bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSourceFileExtension">
        <source>The file extension of '{0}' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.</source>
        <target state="translated">Dosya uzantısı '{0}' tanınmadı. Kaynak dosyaların uzantısı .fs, .fsi, .fsx, .fsscript, .ml veya .mli olmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssembly">
        <source>Could not resolve assembly '{0}'</source>
        <target state="translated">'{0}' bütünleştirilmiş kodu çözümlenemedi</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssemblyRequiredByFile">
        <source>Could not resolve assembly '{0}' required by '{1}'</source>
        <target state="translated">{1}' tarafından istenen '{0}' bütünleştirilmiş kodu çözümlenemedi</target>
        <note />
      </trans-unit>
      <trans-unit id="buildErrorOpeningBinaryFile">
        <source>Error opening binary file '{0}': {1}</source>
        <target state="translated">{0}': {1} ikili dosyasını açma işleminde hata</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDifferentVersionMustRecompile">
        <source>The F#-compiled DLL '{0}' needs to be recompiled to be used with this version of F#</source>
        <target state="translated">F# ile derlenen '{0}' DLL dosyasının, F# dilinin bu sürümünde kullanılabilmesi için yeniden derlenmesi gerekiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashIDirective">
        <source>Invalid directive. Expected '#I \"&lt;path&gt;\"'.</source>
        <target state="translated">Geçersiz yönerge. '#I \"&lt;path&gt;\"' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashrDirective">
        <source>Invalid directive. Expected '#r \"&lt;file-or-assembly&gt;\"'.</source>
        <target state="translated">Geçersiz yönerge. '#r \"&lt;file-or-assembly&gt;\"' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashloadDirective">
        <source>Invalid directive. Expected '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</source>
        <target state="translated">Geçersiz yönerge. '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashtimeDirective">
        <source>Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'.</source>
        <target state="translated">Geçersiz yönerge. Beklenen: '#time', '#time \"on\"' veya '#time \"off\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDirectivesInModulesAreIgnored">
        <source>Directives inside modules are ignored</source>
        <target state="translated">Modül içi yönergeler yoksayılır</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureAlreadySpecified">
        <source>A signature for the file or module '{0}' has already been specified</source>
        <target state="translated">'{0}' dosyasının veya modülünün imzası zaten belirtilmiş</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGivenDetail">
        <source>An implementation of file or module '{0}' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.</source>
        <target state="translated">'{0}' dosyasını veya modülünü uygulama örneği zaten verildi. Tür çıkarımı nedeniyle F# dilinde derleme sırası önemlidir. Uygulamadan önce imza dosyasını yerleştirmek için dosyalarınızın sırasını ayarlamanız gerekebilir. Visual Studio'da dosyalar, el ile düzenlenebilen veya çözüm gezgini kullanılarak ayarlanabilen proje dosyasında göründükleri sırada türlerine göre denetlenir.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGiven">
        <source>An implementation of the file or module '{0}' has already been given</source>
        <target state="translated">'{0}' dosyasını veya modülünü uygulama örneği zaten verildi</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureWithoutImplementation">
        <source>The signature file '{0}' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match.</source>
        <target state="translated">'{0}' imza dosyasında eşleşen bir uygulama dosyası yok. Bir uygulama dosyası varsa imza ve uygulama dosyalarındaki 'module' ve 'namespace' bildirimlerinin eşleştiğini kontrol edin.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidInt">
        <source>'{0}' is not a valid integer argument</source>
        <target state="translated">'{0}' geçerli bir tamsayı bağımsız değişkeni değil</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidFloat">
        <source>'{0}' is not a valid floating point argument</source>
        <target state="translated">'{0}' geçerli bir kayan nokta bağımsız değişkeni değil</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnrecognizedOption">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">Tanınmayan seçenek: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidModuleOrNamespaceName">
        <source>Invalid module or namespace name</source>
        <target state="translated">Geçersiz modül veya ad alanı adı</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleErrorReadingWritingMetadata">
        <source>Error reading/writing metadata for the F# compiled DLL '{0}'. Was the DLL compiled with an earlier version of the F# compiler? (error: '{1}').</source>
        <target state="translated">F# ile derlenmiş DLL '{0}' meta verilerini hatalı okuma/yazma. DLL, F# derleyicisinin önceki bir sürümüyle mi derlenmişti? (hata: '{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeOrModuleNotConcrete">
        <source>The type/module '{0}' is not a concrete module or type</source>
        <target state="translated">'{0}' türü/modülü somut bir modül veya tür değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeHasAssemblyCodeRepresentation">
        <source>The type '{0}' has an inline assembly code representation</source>
        <target state="translated">'{0}' türünün satır içi bir bütünleştirilmiş kod kodu temsili var</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNamespaceAndModuleWithSameNameInAssembly">
        <source>A namespace and a module named '{0}' both occur in two parts of this assembly</source>
        <target state="translated">Bir ad alanı ve '{0}' adlı modülün ikisi birden bu bütünleştirilmiş kodun iki yerinde geçiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTwoModulesWithSameNameInAssembly">
        <source>Two modules named '{0}' occur in two parts of this assembly</source>
        <target state="translated">'{0}' adlı iki modül bu bütünleştirilmiş kodun iki yerinde geçiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tastDuplicateTypeDefinitionInAssembly">
        <source>Two type definitions named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">{0}' adlı iki tür tanımı bu bütünleştirilmiş kodun iki yerinde '{1}' ad alanında geçiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConflictingModuleAndTypeDefinitionInAssembly">
        <source>A module and a type definition named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">{0}' adlı bir modül ve tür tanımı bu bütünleştirilmiş kodun iki yerinde '{1}' ad alanında geçiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMemberSignature">
        <source>Invalid member signature encountered because of an earlier error</source>
        <target state="translated">Önceki bir hata nedeniyle geçersiz üye imzasıyla karşılaşıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueDoesNotHaveSetterType">
        <source>This value does not have a valid property setter type</source>
        <target state="translated">Bu değerin geçerli bir özellik ayarlayıcı türü yok</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertyGetter">
        <source>Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax.</source>
        <target state="translated">Özellik alıcı için geçersiz biçim. Açık sözdizimini kullanırken en az bir '()' bağımsız değişkeni gereklidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertySetter">
        <source>Invalid form for a property setter. At least one argument is required.</source>
        <target state="translated">Özellik ayarlayıcı için geçersiz biçim. En az bir bağımsız değişken gereklidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedByRef">
        <source>Unexpected use of a byref-typed variable</source>
        <target state="translated">Beklenmeyen byref olarak belirtilmiş değişken kullanımı</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMutationOfConstant">
        <source>Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'.</source>
        <target state="translated">Sabit ifadesinin geçersiz olarak değiştirilmesi. İfadeyi değiştirilebilir bir yerel değere kopyalamayı düşünün, örn. 'let mutable x = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueHasBeenCopied">
        <source>The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed</source>
        <target state="translated">Bu işlemin özgün değeri değiştirmemesi veya bir üyeden yapı döndürülürken başka bir üyeye erişildiğinde kopyalanmış değer örtük olduğu için, değer kopyalandı</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeInConstructionOfTuple">
        <source>Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding</source>
        <target state="translated">Özyinelemeli tanımlanmış değerler özyinelemeli bir bağlama içinde demet değer oluşumunun parçası olarak doğrudan görünemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotAppearInConstructionOfType">
        <source>Recursive values cannot appear directly as a construction of the type '{0}' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.</source>
        <target state="translated">Özyinelemeli değerler, özyinelemeli bir bağlama içinde '{0}' türünün doğrudan oluşturulması olarak görünemez. Bu özellik F# dilinden kaldırılmıştır. Onun yerine bir kayıt kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeAssignedToNonMutableField">
        <source>Recursive values cannot be directly assigned to the non-mutable field '{0}' of the type '{1}' within a recursive binding. Consider using a mutable field instead.</source>
        <target state="translated">Özyinelemeli değerler, özyinelemeli bir bağlama içinde '{1}' türünün değiştirilemeyen '{0}' alanına dorudan atanamaz. Onun yerine değiştirilebilir alan kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfAutoOpenAttribute">
        <source>Unexpected decode of AutoOpenAttribute</source>
        <target state="translated">Beklenmeyen AutoOpenAttribute kod çözümü</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInternalsVisibleToAttribute">
        <source>Unexpected decode of InternalsVisibleToAttribute</source>
        <target state="translated">Beklenmeyen InternalsVisibleToAttribute kod çözümü</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
        <source>Unexpected decode of InterfaceDataVersionAttribute</source>
        <target state="translated">Beklenmeyen InterfaceDataVersionAttribute kod çözümü</target>
        <note />
      </trans-unit>
      <trans-unit id="tastActivePatternsLimitedToSeven">
        <source>Active patterns cannot return more than 7 possibilities</source>
        <target state="translated">Etkin desenler 7 olasılıktan fazlasını döndüremez</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNotAConstantExpression">
        <source>This is not a valid constant expression or custom attribute value</source>
        <target state="translated">Bu geçerli bir sabit ifade veya özel öznitelik değeri değil</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAttributesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe mutability attributes differ</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Değişebilirlik öznitelikleri farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe names differ</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Adlar farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityCompiledNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled names differ</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Derlenen adlar farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDisplayNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe display names differ</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Görünen adlar farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAccessibilityMore">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. İmzada belirtilen erişilebilirlik uygulamada belirtilenden daha fazla</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInlineFlagsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe inline flags differ</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Satır içi bayraklar farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityLiteralConstantValuesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe literal constant values and/or attributes differ</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Sabit değerler ve/veya öznitelikler farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsTypeFunction">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri tür işlevi, diğeri değil. Açık tür parametreleri uygulamada varsa imza için bunlar gerekiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityParameterCountsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe respective type parameter counts differ</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. İlgili tür parametresi sayıları farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityTypesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe types differ</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Türler farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityExtensionsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is an extension member and the other is not</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri uzantı üyesi, diğeri değil</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityArityNotInferred">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nAn arity was not inferred for this value</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Bu değer için parametre sayısı çıkarılmadı</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe number of generic parameters in the signature and implementation differ (the signature declares {3} but the implementation declares {4}</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. İmzadaki ve uygulamadaki genel parametrelerin sayısı farklı (imzada {3}, ancak uygulamada {4} tanımlanıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersAreDifferentKinds">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.</source>
        <target state="translated">'{0}' modülü\n    {1}    \niçeriyor, ancak modülün imzası tarafından\n    {2} belirtiliyor    \nİmzadaki ve uygulamadaki genel parametrelerin türleri farklı. Bir [&lt;Measure&gt;] özniteliği eksik olabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAritiesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe arities in the signature and implementation differ. The signature specifies that '{3}' is function definition or lambda expression accepting at least {4} argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int.</source>
        <target state="translated">'{0}' modülü\n    {1}    \niçeriyor, ancak imzasında şu belirtiliyor:\n    {2}    \nİmzadaki parametre sayısı ile uygulamadaki farklı. İmzada '{3}' öğesinin en az {4} bağımsız değişken kabul eden bir işlem tanımı veya lambda ifadesi olduğu belirtiliyor, ancak uygulama hesaplanan bir işlev değeri. Hesaplanan işlev değerinin izin verilen bir uygulama olduğunu bildirmek için imzada türünü ayraç içine almak yeterlidir, ör. \n\tval {6}: int -&gt; int -&gt; int yerine \n\tval {5}: int -&gt; (int -&gt; int)\n.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDotNetNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe CLI member names differ</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. CLI üye adları farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is static and the other isn't</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri statik, diğeri değil</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityVirtualsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is virtual and the other isn't</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri sanal, diğeri değil</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAbstractsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is abstract and the other isn't</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri soyut, diğeri değil</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityFinalsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is final and the other isn't</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri nihai, diğeri değil</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOverridesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is marked as an override and the other isn't</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri geçersiz kılma olarak işaretlenmiş, diğeri işaretlenmemiş</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsConstructor">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a constructor/property and the other is not</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri oluşturucu/özellik, diğeri değil</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticButInstance">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Bu metodun derlenen temsili statik üye olarak gösteriliyor ancak imzada derlenmiş gösterim örnek üye olarak belirtiliyor</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInstanceButStatic">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member</source>
        <target state="translated">{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Bu metodun derlenen gösterimi örnek üye olarak verilmiş, ancak imzada derlenen gösterim statik üye olarak belirtiliyor</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNamesDiffer">
        <source>The {0} definitions in the signature and implementation are not compatible because the names differ. The type is called '{1}' in the signature file but '{2}' in implementation.</source>
        <target state="translated">Adları farklı olduğundan, imza ve uygulamadaki {0} tanımları uyumlu değil. Türün adı, imzada '{1}' olmasına rağmen uygulamada '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">İlgili tür parametresi sayıları farklı olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">İmzada belirtilen erişilebilirlik uygulamada belirtilenden daha fazla olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleMissingInterface">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature requires that the type supports the interface {2} but the interface has not been implemented</source>
        <target state="translated">İmzanın, türün {2} arabirimini desteklemesini gerektirmesine rağmen arabirim uygulanmadığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not</source>
        <target state="translated">Uygulamada bu türün temsil olarak null değerleri kullanabileceği belirtilmesine rağmen imzada bu belirtmediğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not</source>
        <target state="translated">Uygulamada bu türün ek değer olarak null değerleri kullanabileceği belirtilmesine rağmen imzada bu belirtmediğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not</source>
        <target state="translated">İmzada bu türün temsil olarak null değerleri kullanabileceği belirtilmesine rağmen uygulamada bu belirtilmediğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not</source>
        <target state="translated">İmzada bu türün ek değer olarak null değerleri kullanabileceği belirtilmesine rağmen uygulamada bu belirtilmediğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.</source>
        <target state="translated">Uygulama türü mühürlü olduğu halde imza mühürlü olmadığını işaret ettiğinden, '{1}' türü için imzadaki ve uygulamadaki {0} tanımları uyumsuz. İmzaya [&lt;Sealed&gt;] özniteliğini eklemeyi göz önünde bulundurun.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.</source>
        <target state="translated">Uygulama türü mühürlü olmadığı halde imza mühürlü olduğunu işaret ettiğinden, '{1}' türü için imzadaki ve uygulamadaki {0} tanımları uyumsuz. İmzaya [&lt;Sealed&gt;] özniteliğini eklemeyi göz önünde bulundurun.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.</source>
        <target state="translated">Uygulama soyut bir sınıf olduğu halde imza soyut sınıf olmadığından '{1}' türü için imzadaki ve uygulamadaki {0} tanımları uyumlu değil. İmzaya [&lt;AbstractClass&gt;] özniteliğini eklemeyi göz önünde bulundurun.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.</source>
        <target state="translated">İmza soyut bir sınıf olduğu halde uygulama soyut sınıf olmadığından '{1}' türü için imzadaki ve uygulamadaki {0} tanımları uyumlu değil. Uygulamaya [&lt;AbstractClass&gt;] özniteliğini eklemeyi göz önünde bulundurun.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types have different base types</source>
        <target state="translated">Türler farklı temel türlere sahip olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNumbersDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the number of {2}s differ</source>
        <target state="translated">{2} sayıları farklı olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature defines the {2} '{3}' but the implementation does not (or does, but not in the same order)</source>
        <target state="translated">İmzada '{3}' adlı {2} tanımlanmasına rağmen uygulamada tanımlanmadığından (veya farklı sırayla tanımlandığından), imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines the {2} '{3}' but the signature does not (or does, but not in the same order)</source>
        <target state="translated">Uygulamada '{3}' adlı {2} tanımlanmasına rağmen imzada tanımlanmadığından (veya farklı sırada tanımlandığından), imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation</source>
        <target state="translated">Uygulamada bir struct tanımlanmasına rağmen imzada gizli temsili olan bir tür tanımlandığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature</source>
        <target state="translated">Bir CLI tür temsili imza ile gizlendiğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a type representation is being hidden by a signature</source>
        <target state="translated">Bir tür temsili imza ile gizlendiğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types are of different kinds</source>
        <target state="translated">Türler farklı çeşitlerde olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleILDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the IL representations differ</source>
        <target state="translated">IL temsilleri farklı olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the representations differ</source>
        <target state="translated">Temsiller farklı olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldWasPresent">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was present in the implementation but not in the signature</source>
        <target state="translated">{2} alanı uygulamada mevcut olmasına rağmen imzada mevcut olmadığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation</source>
        <target state="translated">Alanların sırası imzada ve uygulamada farklı olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was required by the signature but was not specified by the implementation</source>
        <target state="translated">{2} alanı imza için gerekmesine rağmen uygulama tarafından belirtilmediğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field '{2}' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'.</source>
        <target state="translated">{2}' alanı uygulamada mevcut olmasına rağmen imzada mevcut olmadığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil. Struct türleri artık tür imzasında alanlarını göstermelidir, ancak bu alanlar yine de 'private' veya 'internal' olarak etiketlenebilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was required by the signature but was not specified by the implementation</source>
        <target state="translated">{2}' soyut üyesi imza için gerekmesine rağmen uygulama tarafından belirtilmediğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was present in the implementation but not in the signature</source>
        <target state="translated">{2}' soyut üyesi uygulamada mevcut olmasına rağmen imzada mevcut olmadığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature declares a {2} while the implementation declares a {3}</source>
        <target state="translated">İmzada {2} bildirilirken uygulamada {3} bildirildiğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abbreviations differ: {2} versus {3}</source>
        <target state="translated">Kısaltmalar farklı olduğundan ({2} ve {3}), imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.</source>
        <target state="translated">Bir kısaltma imza ile gizlendiğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil. Kısaltmanın diğer CLI dilleri tarafından görünebilir olması gerekir. Kısaltmayı imzada görünür yapmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not</source>
        <target state="translated">İmzanın kısaltması olmasına rağmen uygulamanın olmadığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButNamesDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">Modül\n    {0}    \noluşturucusunu içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. Adlar farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButDataFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe respective number of data fields differ</source>
        <target state="translated">Modül\n    {0}    \noluşturucusunu içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. İlgili veri alanı sayısı farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButTypesOfFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe types of the fields differ</source>
        <target state="translated">Modül\n    {0}    \noluşturucusunu içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. Alanların türleri farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButAccessibilityDiffers">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Modül\n    {0}    \noluşturucusunu içeriyor ancak imzasında\n    {1}    \nbelirtiliyor; imzada belirtilen erişilebilirlik uygulamada belirtilenden daha fazla</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedNamesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">Modül\n    {0}    \nalanını içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. Adlar farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedAccessibilitiesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Modül\n    {0}    \nalanını içeriyor ancak imzasında\n    {1}    \nbelirtiliyor; imzada belirtilen erişilebilirlik uygulamada belirtilenden daha fazla</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedStaticsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'static' modifiers differ</source>
        <target state="translated">Modül\n    {0}    \nalanını içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. 'static' değiştiricileri farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedMutablesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'mutable' modifiers differ</source>
        <target state="translated">Modül\n    {0}    \nalanını içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. 'mutable' değiştiricileri farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedLiteralsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'literal' modifiers differ</source>
        <target state="translated">Modül\n    {0}    \nalanını içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. 'literal' değiştiricileri farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedTypesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe types differ</source>
        <target state="translated">Modül\n    {0}    \nalanını içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. Türler farklı</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveImplicitGenericInstantiation">
        <source>The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '{0}' and '{1}'. Consider using type annotations to resolve the ambiguity</source>
        <target state="translated">Genel yapının bu konumda veya yakınında örtük olarak örneklenmesi çözümlenemedi, çünkü ilişkisiz birden çok türe çözümlenebiliyordu, örn. '{0}' ve '{1}'. Belirsizliği çözümlemek için tür ek açıklamaları kullanmayı düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInPrintf">
        <source>Could not resolve the ambiguity inherent in the use of a 'printf'-style format string</source>
        <target state="translated">'printf' stilindeki biçim dizesinin kullanılmasına bulunan belirsizlik çözümlenemedi.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInEnum">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position</source>
        <target state="translated">Bu konumda veya yakınında 'enum' kısıtlaması olan bir genel yapının kullanımındaki belirsizlik çözümlenemedi</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInDelegate">
        <source>Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position</source>
        <target state="translated">Bu konumda veya yakınında 'delegate' kısıtlaması olan bir genel yapının kullanımındaki belirsizlik çözümlenemedi</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInvalidValue">
        <source>Invalid value</source>
        <target state="translated">Geçersiz değer</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleParamCountsDiffer">
        <source>The signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">İlgili tür parametresi sayıları farklı olduğu için imza ve uygulama uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
        <source>The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation</source>
        <target state="translated">Sınıf/imzadaki tür parametresinin üye/uygulama içindekinden farklı bir derleme zamanı gereksinimi olduğu için imza ve uygulama uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDiffer">
        <source>The signature and implementation are not compatible because the declaration of the type parameter '{0}' requires a constraint of the form {1}</source>
        <target state="translated">{0}' tür parametresinin bildirimi {1} biçiminin kısıtlamasını gerektirdiği için imza ve uygulama uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDifferRemove">
        <source>The signature and implementation are not compatible because the type parameter '{0}' has a constraint of the form {1} but the implementation does not. Either remove this constraint from the signature or add it to the implementation.</source>
        <target state="translated">{0}' tür parametresinde {1} biçiminde bir kısıtlama olmasına karşın uygulamada olmadığı için imza ve uygulama uyumlu değil. Bu kısıtlamayı ya imzadan kaldırın ya da uygulamaya ekleyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableShouldOverrideObjectEquals">
        <source>The type '{0}' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'</source>
        <target state="translated">'{0}' türü 'System.IComparable' metodunu uyguluyor. Ayrıca 'Object.Equals' için açık bir geçersiz kılma eklemeyi düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableDefaultObjectEqualsProvided">
        <source>The type '{0}' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly</source>
        <target state="translated">'{0}' türü 'System.IComparable' metodunu açık olarak uyguluyor ancak 'Object.Equals' için buna karşılık gelen bir geçersiz kılma sağlamıyor. 'System.IComparable' aracılığıyla uygulanan 'Object.Equals' metodunun uygulaması otomatik olarak sağlandı. 'Object.Equals' geçersiz kılma işlemini açık olarak uygulamayı düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCodeOrEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type</source>
        <target state="translated">'{0}' yapı, kayıt veya birleşim türünde açık 'Object.GetHashCode' veya 'Object.Equals' uygulaması var. Türe 'CustomEquality' özniteliğini uygulamanız gerekiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCode">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'</source>
        <target state="translated">'{0}' yapı, kayıt veya birleşim türünde açık 'Object.GetHashCode' uygulaması var. 'Object.Equals(obj)' için bununla eşleşen bir geçersiz kılma uygulamayı düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'</source>
        <target state="translated">'{0}' yapı, kayıt veya birleşim türünde açık 'Object.Equals' uygulaması var. 'Object.GetHashCode()' için bununla eşleşen bir geçersiz kılma uygulamayı düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleHiddenBySignature">
        <source>The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">CLI özel durum eşlemesi imza aracılığıyla gizlendiği için özel durum tanımları uyumlu değil. Özel durum eşlemesi diğer modüllere görünmelidir. Modül,\n    {0}    \nözel durum tanımını içeriyor ancak imzasında\n\t{1} belirtiliyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer">
        <source>The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">CLI temsilleri farklı olduğu için özel durum tanımları uyumlu değil. Modül,\n    {0}    \nözel durum tanımını içeriyor ancak imzasında\n\t{1} belirtiliyor</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature">
        <source>The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Özel durum kısaltması imza tarafından gizlendiği için özel durum tanımları uyumlu değil. Kısaltmanın diğer CLI dillerine görünmesi gerekir. Bu kısaltmayı imzada görünür yapmayı düşünün. Modül,\n    {0}    \nözel durum tanımını içeriyor ancak imzasında\n\t{1} belirtiliyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleSignaturesDiffer">
        <source>The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Özel durum kısaltmaları imza ve uygulamada farklı olduğu için özel durum tanımları uyumlu değil. Modül,\n    {0}    \nözel durum tanımını içeriyor ancak imzasında\n\t{1} belirtiliyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer">
        <source>The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Özel durum bildirimleri farklı olduğu için özel durum tanımları uyumlu değil. Modül,\n    {0}    \nözel durum tanımını içeriyor ancak imzasında\n\t{1} belirtiliyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInSigButNotImpl">
        <source>The exception definitions are not compatible because the field '{0}' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">{0}' alanı imza için gerekmesine karşın uygulama tarafından belirtilmediği için özel durum tanımları uyumlu değil. Modül,\n    {1}    \nözel durum tanımını içeriyor ancak imzasında\n\t{2} belirtiliyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInImplButNotSig">
        <source>The exception definitions are not compatible because the field '{0}' was present in the implementation but not in the signature. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">{0}' alanı uygulamada olup imzada olmadığı için özel durum tanımları uyumlu değil. Modül,\n    {1}    \nözel durum tanımını içeriyor ancak imzasında\n\t{2} belirtiliyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldOrderDiffers">
        <source>The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Alanların sırası imza ve uygulamada farklı olduğu için özel durum tanımları uyumlu değil. Modül,\n    {0}    \nözel durum tanımını içeriyor ancak imzasında\n\t{1} belirtiliyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelModuleNamespaceAttributesDifferInSigAndImpl">
        <source>The namespace or module attributes differ between signature and implementation</source>
        <target state="translated">Ad alanı veya modül öznitelikleri imza ile uygulama arasında farklılık gösteriyor</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsOverconstrained">
        <source>This method is over-constrained in its type parameters</source>
        <target state="translated">Bu metot tür parametrelerinde aşırı kısıtlanmış</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverloadNotFound">
        <source>No implementations of '{0}' had the correct number of arguments and type parameters. The required signature is '{1}'.</source>
        <target state="translated">Hiçbir '{0}' uygulamasında doğru sayıda bağımsız değişken ve tür parametresi yoktu. Gereken imza: '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideWasAmbiguous">
        <source>The override for '{0}' was ambiguous</source>
        <target state="translated">'{0}' geçersiz kılma işlemi belirsizdi</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMoreThenOneOverride">
        <source>More than one override implements '{0}'</source>
        <target state="translated">Birden fazla geçersiz kılma '{0}' uyguluyor</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsSealed">
        <source>The method '{0}' is sealed and cannot be overridden</source>
        <target state="translated">'{0}' metodu mühürlü olduğundan geçersiz kılınamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideImplementsMoreThenOneSlot">
        <source>The override '{0}' implements more than one abstract slot, e.g. '{1}' and '{2}'</source>
        <target state="translated">{0}' geçersiz kılma işlemi birden fazla soyut yuva uyguluyor, örn. '{1}' ve '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelDuplicateInterface">
        <source>Duplicate or redundant interface</source>
        <target state="translated">Yinelenen veya gereksiz arabirim</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNeedExplicitImplementation">
        <source>The interface '{0}' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.</source>
        <target state="translated">'{0}' arabirimi, birden fazla açık olarak uygulanan arabirim türüne eklenmiş. Bu arabirimin açık uygulamasını ekleyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNamedArgumentHasBeenAssignedMoreThenOnce">
        <source>The named argument '{0}' has been assigned more than one value</source>
        <target state="translated">'{0}' adlandırılmış bağımsız değişkeni birden fazla değere atanmış</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGiven">
        <source>No implementation was given for '{0}'</source>
        <target state="translated">'{0}' için bir uygulama verilmedi</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenWithSuggestion">
        <source>No implementation was given for '{0}'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">'{0}' için bir uygulama verilmedi. Tüm arabirim üyelerinin uygulanması ve uygun bir 'interface' bildirimi, örn. 'interface ... with member ...' altında listelenmesi gerektiğine dikkat edin.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfArguments">
        <source>The member '{0}' does not have the correct number of arguments. The required signature is '{1}'.</source>
        <target state="translated">Üye '{0}', doğru sayıda bağımsız değişkene sahip değil. Gereken imza: '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters">
        <source>The member '{0}' does not have the correct number of method type parameters. The required signature is '{1}'.</source>
        <target state="translated">Üye '{0}', doğru sayıda metot türü parametresine sahip değil. Gereken imza: '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters">
        <source>The member '{0}' does not have the correct kinds of generic parameters. The required signature is '{1}'.</source>
        <target state="translated">Üye '{0}', doğru tür genel parametrelere sahip değil. Gereken imza: '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberCannotImplement">
        <source>The member '{0}' cannot be used to implement '{1}'. The required signature is '{2}'.</source>
        <target state="translated">Üye '{0}', '{1}' uygulamak için kullanılamaz. Gerekli imza: '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILError">
        <source>Error while parsing embedded IL</source>
        <target state="translated">Gömülü IL ayrıştırılırken hata oluştu</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILTypeError">
        <source>Error while parsing embedded IL type</source>
        <target state="translated">Gömülü IL türü ayrıştırılırken hata oluştu</target>
        <note />
      </trans-unit>
      <trans-unit id="astDeprecatedIndexerNotation">
        <source>This indexer notation has been removed from the F# language</source>
        <target state="translated">Bu dizin erişimcisi gösterimi F# dilinden kaldırıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="astInvalidExprLeftHandOfAssignment">
        <source>Invalid expression on left of assignment</source>
        <target state="translated">Atamanın solunda geçersiz ifade</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoRefEqualsOnStruct">
        <source>The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'.</source>
        <target state="translated">'ReferenceEquality' özniteliği struct öğelerinde kullanılamaz. Onun yerine 'StructuralEquality' özniteliğini kullanın veya 'System.Object.Equals(obj)' için geçersiz kılma uygulayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="augInvalidAttrs">
        <source>This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'</source>
        <target state="translated">Bu tür, 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' ve 'StructuralComparison' özniteliklerini geçersiz bir karışımda kullanıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqualityNeedsNoComparison">
        <source>The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute</source>
        <target state="translated">'NoEquality' özniteliği, 'NoComparison' özniteliği ile bağlantılı kullanılmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructCompNeedsStructEquality">
        <source>The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute</source>
        <target state="translated">'StructuralComparison' özniteliği, 'StructuralEquality' özniteliği ile bağlantılı kullanılmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructEqNeedsNoCompOrStructComp">
        <source>The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes</source>
        <target state="translated">'StructuralEquality' özniteliği, 'NoComparison' veya 'StructuralComparison' öznitelikleriyle bağlantılı kullanılmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="augTypeCantHaveRefEqAndStructAttrs">
        <source>A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes</source>
        <target state="translated">Bir türde 'ReferenceEquality' ile 'StructuralEquality' veya 'StructuralComparison' öznitelikleri aynı anda olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="augOnlyCertainTypesCanHaveAttrs">
        <source>Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes</source>
        <target state="translated">Yalnızca kayıt, birleşim, özel durum ve yapı türleri 'ReferenceEquality', 'StructuralEquality' ve 'StructuralComparison' öznitelikleriyle büyütülebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="augRefEqCantHaveObjEquals">
        <source>A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">'ReferenceEquality' özniteliğine sahip bir tür, açık bir 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' veya 'System.Collections.IStructuralEquatable' uygulamasına sahip olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsObjEquals">
        <source>A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">'CustomEquality' özniteliğine sahip bir aracın en az bir 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' veya 'System.Collections.IStructuralEquatable' için açık bir uygulaması olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomCompareNeedsIComp">
        <source>A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'</source>
        <target state="translated">'CustomComparison' özniteliği olan bir türde, 'System.IComparable' veya 'System.Collections.IStructuralComparable' yöntemlerinden en az biri açık olarak uygulanmış olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqNeedsNoObjEquals">
        <source>A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">'NoEquality' özniteliği olan bir türde, genellikle açık olarak uygulanmış 'Object.Equals(obj)' metodu olmamalıdır. Bu birlikte çalışabilme amacıyla bilerek yapılmışsa bu uyarıyı devre dışı bırakın</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoCompCantImpIComp">
        <source>A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable&lt;_&gt;' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">'NoComparison' özniteliğine sahip bir tür genellikle açık bir 'System.IComparable', 'System.IComparable&lt;_&gt;' veya 'System.Collections.IStructuralComparable' uygulamasına sahip olmamalıdır. Bunu birlikte çalışabilirlik amacıyla bilerek yaptıysanız bu uyarıyı devre dışı bırakın</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsNoCompOrCustomComp">
        <source>The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes</source>
        <target state="translated">'CustomEquality' özniteliği, 'NoComparison' veya 'CustomComparison' öznitelikleri ile bağlantılı kullanılmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="forPositionalSpecifiersNotPermitted">
        <source>Positional specifiers are not permitted in format strings</source>
        <target state="translated">Biçim dizelerinde konum tanımlayıcılara izin verilmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="forMissingFormatSpecifier">
        <source>Missing format specifier</source>
        <target state="translated">Biçim belirticisi eksik</target>
        <note />
      </trans-unit>
      <trans-unit id="forFlagSetTwice">
        <source>'{0}' flag set twice</source>
        <target state="translated">'{0}' bayrağı iki kez ayarlandı</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrefixFlagSpacePlusSetTwice">
        <source>Prefix flag (' ' or '+') set twice</source>
        <target state="translated">Ön ek bayrağı (' ' veya '+') iki kez ayarlandı</target>
        <note />
      </trans-unit>
      <trans-unit id="forHashSpecifierIsInvalid">
        <source>The # formatting modifier is invalid in F#</source>
        <target state="translated"># biçimlendirme değiştiricisi F# içinde geçersizdir</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadPrecision">
        <source>Bad precision in format specifier</source>
        <target state="translated">Biçim tanımlayıcıda hatalı duyarlık</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadWidth">
        <source>Bad width in format specifier</source>
        <target state="translated">Biçim tanımlayıcıda hatalı genişlik</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportZeroFlag">
        <source>'{0}' format does not support '0' flag</source>
        <target state="translated">'{0}' biçimi '0' bayrağını desteklemiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrecisionMissingAfterDot">
        <source>Precision missing after the '.'</source>
        <target state="translated">'.' karakterinden sonra duyarlık eksik</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatDoesntSupportPrecision">
        <source>'{0}' format does not support precision</source>
        <target state="translated">'{0}' biçimi duyarlığı desteklemiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifier">
        <source>Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Hatalı biçim tanımlayıcı (l veya L'den sonra): ld,li,lo,lu,lx veya lX bekleniyordu. Bunun yerine F# kodunda, tüm temel tamsayı türleriyle çalışmak üzere aşırı yüklenmiş olan %d, %x, %o veya %u kullanabilirsiniz.</target>
        <note />
      </trans-unit>
      <trans-unit id="forLIsUnnecessary">
        <source>The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Bu biçim tanımlayıcıdaki 'l' veya 'L' gereksiz. Bunun yerine F# kodunda, tüm temel tamsayı türleriyle çalışmak üzere aşırı yüklenmiş olan %d, %x, %o veya %u kullanabilirsiniz.</target>
        <note />
      </trans-unit>
      <trans-unit id="forHIsUnnecessary">
        <source>The 'h' or 'H' in this format specifier is unnecessary. You can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Bu biçim tanımlayıcıdaki 'h' veya 'H' gereksiz. Bunun yerine, tüm temel tamsayı türleriyle çalışmak üzere aşırı yüklenmiş olan %d, %x, %o veya %u kullanabilirsiniz.</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportPrefixFlag">
        <source>'{0}' does not support prefix '{1}' flag</source>
        <target state="translated">'{0}', ön ek '{1}' bayrağını desteklemiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifierGeneral">
        <source>Bad format specifier: '{0}'</source>
        <target state="translated">Hatalı biçim tanımlayıcı: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="elSysEnvExitDidntExit">
        <source>System.Environment.Exit did not exit</source>
        <target state="translated">System.Environment.Exit yoktu</target>
        <note />
      </trans-unit>
      <trans-unit id="elDeprecatedOperator">
        <source>The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined</source>
        <target state="translated">Bu işlecin işlemleri artık doğrudan F# derleyicisi tarafından işlendiğinden anlamı yeniden tanımlanamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="chkProtectedOrBaseCalled">
        <source>A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope.</source>
        <target state="translated">Korunan bir üye çağrıldı veya 'base' kullanılıyor. Üyeler nesne kapsamlarını kaçırabildikleri için buna yalnızca üyeler doğrudan uygulandığında izin verilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkByrefUsedInInvalidWay">
        <source>The byref-typed variable '{0}' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.</source>
        <target state="translated">Byref olarak belirtilmiş '{0}' değişkeni geçersiz bir biçimde kullanılmış. Byref değerleri, kapanışlar ile yakalanamaz veya iç işlevlere geçirilemez.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkBaseUsedInInvalidWay">
        <source>The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.</source>
        <target state="translated">'Base' anahtar sözcüğü geçersiz bir biçimde kullanılmış. Base çağrıları kapanışlarda kullanılamaz. Base çağrıları yapmak için özel üye kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkVariableUsedInInvalidWay">
        <source>The variable '{0}' is used in an invalid way</source>
        <target state="translated">'{0}' değişkeni geçersiz bir biçimde kullanılmış</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTypeLessAccessibleThanType">
        <source>The type '{0}' is less accessible than the value, member or type '{1}' it is used in.</source>
        <target state="translated">{0}' türünün erişilebilirliği, içinde kullanıldığı değer, üye veya '{1}' türünden daha düşük düzeyde.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSystemVoidOnlyInTypeof">
        <source>'System.Void' can only be used as 'typeof&lt;System.Void&gt;' in F#</source>
        <target state="translated">F# dilinde 'System.Void' yalnızca 'typeof&lt;System.Void&gt;' olarak kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorUseOfByref">
        <source>A type instantiation involves a byref type. This is not permitted by the rules of Common IL.</source>
        <target state="translated">Tür örnek oluşturma işlemi byref türünü içerir. Ortak Ara Dil (CIL) kurallarında buna izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorContainsCallToRethrow">
        <source>Calls to 'reraise' may only occur directly in a handler of a try-with</source>
        <target state="translated">'Reraise' çağrıları yalnızca doğrudan try-with ifadesinin işleyicisinde oluşabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSplicingOnlyInQuotations">
        <source>Expression-splicing operators may only be used within quotations</source>
        <target state="translated">İfade ekleme işleçleri yalnızca tırnak içinde kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassSplicing">
        <source>First-class uses of the expression-splicing operator are not permitted</source>
        <target state="translated">İfade ekleme işlecinin birinci sınıf kullanımlarına izin verilmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassAddressOf">
        <source>First-class uses of the address-of operators are not permitted</source>
        <target state="translated">Address-of işleçlerinin birinci sınıf kullanımlarına izin verilmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassRethrow">
        <source>First-class uses of the 'reraise' function is not permitted</source>
        <target state="translated">'reraise' işlevinin birinci sınıf kullanımlarına izin verilmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAtThisPoint">
        <source>The byref typed value '{0}' cannot be used at this point</source>
        <target state="translated">Türü byref olarak belirtilmiş '{0}' değeri bu noktada kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="chkLimitationsOfBaseKeyword">
        <source>'base' values may only be used to make direct calls to the base implementations of overridden members</source>
        <target state="translated">'base' değerleri yalnızca geçersiz kılınmış üyelerin taban uygulamalarına doğrudan çağrı yapmak için kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="chkObjCtorsCantUseExceptionHandling">
        <source>Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.</source>
        <target state="translated">Nesne oluşturucular, nesnenin başlatılmasından önce try/with ve try/finally ifadelerini doğrudan kullanamazlar. Buna bu yapıların kullanımını çeşitlendirebilen 'for x in ...' gibi yapılar da dahildir. Bu, Ortak Ara Dilin getirdiği bir kısıtlamadır.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfAtThisPoint">
        <source>The address of the variable '{0}' cannot be used at this point</source>
        <target state="translated">'{0}' değişkeninin adresi bu noktada kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressStaticFieldAtThisPoint">
        <source>The address of the static field '{0}' cannot be used at this point</source>
        <target state="translated">'{0}' statik alanının adresi bu noktada kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressFieldAtThisPoint">
        <source>The address of the field '{0}' cannot be used at this point</source>
        <target state="translated">'{0}' alanının adresi bu noktada kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfArrayElementAtThisPoint">
        <source>The address of an array element cannot be used at this point</source>
        <target state="translated">Dizi öğesinin adresi bu noktada kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFirstClassFuncNoByref">
        <source>The type of a first-class function cannot contain byrefs</source>
        <target state="translated">Birinci sınıf bir işlevin türü byref'ler içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReturnTypeNoByref">
        <source>A method return type would contain byrefs which is not permitted</source>
        <target state="translated">Bir metot dönüş türü byref'ler içeriyordu, buna izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidCustAttrVal">
        <source>Invalid custom attribute value (not a constant or literal)</source>
        <target state="translated">Geçersiz özel öznitelik değeri (sabit veya değişmez değerli değil)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkAttrHasAllowMultiFalse">
        <source>The attribute type '{0}' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element.</source>
        <target state="translated">'{0}' öznitelik türünde 'AllowMultiple=false' değeri var. Bu özniteliğin birden çok örneği tek bir dil öğesine iliştirilemez.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to its definition at or near '{2}'. This is an invalid forward reference.</source>
        <target state="translated">{0}' üyesi geçersiz bir biçimde kullanılmış. '{1}' kullanımı, '{2}' konumunda veya yakınındaki tanımından önce çıkarılmış. Bu geçersiz bir ileriye doğru başvurudur.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAsTopValue">
        <source>A byref typed value would be stored here. Top-level let-bound byref values are not permitted.</source>
        <target state="translated">Türü byref olarak belirtilmiş bir değer buraya depolanacaktı. Üst düzeyde let ile bağlanmış byref değerlerine izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReflectedDefCantSplice">
        <source>[&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">[&lt;ReflectedDefinition&gt;] terimleri, '%' ön ek birleştirme işlecinin kullanımını içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="chkEntryPointUsage">
        <source>A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence.</source>
        <target state="translated">'EntryPointAttribute' özniteliği ile etiketlenmiş bir işlev, derleme dizisinin sonuncu dosyasındaki sonuncu bildirim olmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseCompiledForm">
        <source>compiled form of the union case</source>
        <target state="translated">birleşim durumunun derlenmiş biçimi</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseDefaultAugmentation">
        <source>default augmentation of the union case</source>
        <target state="translated">birleşim durumunun varsayılan genişletmesi</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameMethod">
        <source>The property '{0}' has the same name as a method in type '{1}'.</source>
        <target state="translated">{0}' özelliği, '{1}' türündeki bir metotla aynı ada sahip.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterSetterDoNotMatchAbstract">
        <source>The property '{0}' of type '{1}' has a getter and a setter that do not match. If one is abstract then the other must be as well.</source>
        <target state="translated">{1}' türündeki '{0}' özelliğinin alıcısı ve ayarlayıcısı eşleşmiyor. Biri soyut ise diğeri de soyut olmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameIndexer">
        <source>The property '{0}' has the same name as another property in type '{1}', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.</source>
        <target state="translated">{0}' özelliği, '{1}' türündeki başka bir özellikle aynı ada sahip ancak bunlardan biri dizin oluşturucu bağımsız değişkenleri alırken diğeri almıyor. Özelliklerinizden birinde dizin oluşturucu bağımsız değişkeni eksik olabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCantStoreByrefValue">
        <source>A type would store a byref typed value. This is not permitted by Common IL.</source>
        <target state="translated">Bir türde byref olarak belirtilmiş değer depolanmak istendi. Ortak Ara Dilde (CIL) buna izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethod">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}'.</source>
        <target state="translated">Yinelenen metot. '{0}' metodu, '{1}' türündeki başka bir metotla aynı ada ve imzaya sahip.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodWithSuffix">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Yinelenen metot. Demetler, işlevler, ölçü birimleri ve/veya sağlanan türler silindikten sonra '{0}' metodu, '{1}' türündeki başka bir metotla aynı ada ve imzaya sahip oluyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodCurried">
        <source>The method '{0}' has curried arguments but has the same name as another method in type '{1}'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.</source>
        <target state="translated">{0}' metodunda Curry biçimli bağımsız değişkenler var ancak metodun adı, '{1}' türündeki başka bir metodun adıyla aynı. Curry biçimli bağımsız değişkenleri olan metotlar aşırı yüklenemez. Demet olarak tanımlanmış bağımsız değişkenler alan bir metot kullanmanız önerilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCurriedMethodsCantHaveOutParams">
        <source>Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments</source>
        <target state="translated">Curry bağımsız değişkenlerine sahip metotlar 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName' veya 'CallerFilePath' bağımsız değişkenlerini bildiremez</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateProperty">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}'.</source>
        <target state="translated">Yinelenen özellik. '{0}' özelliği, '{1}' türündeki başka bir özellikle aynı ada ve imzaya sahip.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicatePropertyWithSuffix">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Yinelenen özellik. Demetler, işlevler, ölçü birimleri ve/veya sağlanan türler silindikten sonra '{0}' özelliği, '{1}' türündeki başka bir özellikle aynı ada ve imzaya sahip oluyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedType">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type.</source>
        <target state="translated">Yinelenen metot. Soyut '{0}' metodu, devralınan türdeki soyut metotla aynı ada ve imzaya sahip.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedTypeWithSuffix">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Yinelenen metot. Demetler, işlevler, ölçü birimleri ve/veya sağlanan türler silindikten sonra, soyut '{0}' metodu, devralınan türdeki soyut metotla aynı ada ve imzaya sahip.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMultipleGenericInterfaceInstantiations">
        <source>This type implements the same interface at different generic instantiations '{0}' and '{1}'. This is not permitted in this version of F#.</source>
        <target state="translated">Bu tür, farklı '{0}' ve '{1}' genel örneklemelerinde aynı arabirimi uyguluyor. F# dilinin bu sürümünde buna izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkValueWithDefaultValueMustHaveDefaultValue">
        <source>The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check</source>
        <target state="translated">'DefaultValue' özniteliğini kullanan alanın türü varsayılan başlatmayı kabul etmelidir, yani uygun değer olarak 'null' değerli olmalı veya alanlarının tümü varsayılan başlatmayı kabul eden yapı türünde olmalıdır. Bu denetimi devre dışı bırakmak için 'DefaultValue(false)' kullanabilirsiniz</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefInTypeAbbrev">
        <source>The type abbreviation contains byrefs. This is not permitted by F#.</source>
        <target state="translated">Tür kısaltması byref değerleri içeriyor. F# dilinde buna izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefBoundVarUsedInSplice">
        <source>The variable '{0}' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.</source>
        <target state="translated">'{0}' değişkeni bir alıntı içine bağlanmış ancak eklenmiş ifadenin parçası olarak kullanılmış. Kapsamından kaçabileceği için buna izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericExprs">
        <source>Quotations cannot contain uses of generic expressions</source>
        <target state="translated">Alıntılar, genel ifade kullanımları içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericFunctions">
        <source>Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.</source>
        <target state="translated">Alıntılar, genel olduğu çıkarılmış veya tanımlanmış işlev tanımları içeremez. Bunu geçerli bir alıntı ifadesi yapmak için bazı tür kısıtlamaları eklemeyi düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainObjExprs">
        <source>Quotations cannot contain object expressions</source>
        <target state="translated">Alıntılar, nesne ifadeleri içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainAddressOf">
        <source>Quotations cannot contain expressions that take the address of a field</source>
        <target state="translated">Alıntılar, bir alanın adresini alan ifadeler içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainStaticFieldRef">
        <source>Quotations cannot contain expressions that fetch static fields</source>
        <target state="translated">Alıntılar, statik alanlar getiren ifadeler içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainInlineIL">
        <source>Quotations cannot contain inline assembly code or pattern matching on arrays</source>
        <target state="translated">Alıntılar, satır içi bütünleştirilmiş kod kodu veya dizilerde desen eşleştirme içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainDescendingForLoops">
        <source>Quotations cannot contain descending for loops</source>
        <target state="translated">Alıntılar, döngülere yönelik azalan sıra içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantFetchUnionIndexes">
        <source>Quotations cannot contain expressions that fetch union case indexes</source>
        <target state="translated">Alıntılar, birleşim durumu dizinleri getiren ifadeler içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetUnionFields">
        <source>Quotations cannot contain expressions that set union case fields</source>
        <target state="translated">Alıntılar, birleşim durumu alanları ayarlayan ifadeler içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetExceptionFields">
        <source>Quotations cannot contain expressions that set fields in exception values</source>
        <target state="translated">Alıntılar, özel durum değerleri içinde alanlar ayarlayan ifadeler içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantRequireByref">
        <source>Quotations cannot contain expressions that require byref pointers</source>
        <target state="translated">Alıntılar, byref işaretçileri gerektiren ifadeler içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantCallTraitMembers">
        <source>Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call</source>
        <target state="translated">Alıntılar, üye kısıtlama çağrıları yapan veya örtük olarak üye kısıtlama çağrısına çözümlenen işleçler kullanan ifadeler içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisConstant">
        <source>Quotations cannot contain this kind of constant</source>
        <target state="translated">Alıntılar, bu tür bir sabit içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisPatternMatch">
        <source>Quotations cannot contain this kind of pattern match</source>
        <target state="translated">Alıntılar, bu tür bir desen eşleştirme içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainArrayPatternMatching">
        <source>Quotations cannot contain array pattern matching</source>
        <target state="translated">Alıntılar, dizi deseni eşleştirmesi içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisType">
        <source>Quotations cannot contain this kind of type</source>
        <target state="translated">Alıntılar, böyle bir tür içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeCannotBeResolvedAtCompileTime">
        <source>The declared type parameter '{0}' cannot be used here since the type parameter cannot be resolved at compile time</source>
        <target state="translated">Tanımlanan tür parametresi '{0}' derleme zamanında çözümlenemediği için burada kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="csCodeLessGeneric">
        <source>This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'.</source>
        <target state="translated">Bu kod, ek açıklamalarında belirtilenden daha az genel. '_' kullanılarak belirtilen bir ölçü biriminin '1', yani boyutsuz olduğu belirlendi. Kodu genel yapmayı veya '_' kullanımını kaldırmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInferenceMaxDepth">
        <source>Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.</source>
        <target state="translated">Tür çıkarma sorunu çok karmaşık (en fazla yinelenme derinliğine ulaşıldı). İlave tür ek açıklamaları eklemeyi düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectedArguments">
        <source>Expected arguments to an instance member</source>
        <target state="translated">Örnek üye için bağımsız değişkenler bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="csIndexArgumentMismatch">
        <source>This indexer expects {0} arguments but is here given {1}</source>
        <target state="translated">Bu dizin erişimcisi {0} bağımsız değişkenlerini bekliyor ancak burada {1} verilmiş</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenFunction">
        <source>Expecting a type supporting the operator '{0}' but given a function type. You may be missing an argument to a function.</source>
        <target state="translated">'{0}' işlecini destekleyen bir tür bekleniyor ancak bir işlev türü verildi. Bir işlevde bağımsız değişkeniniz eksik olabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenTuple">
        <source>Expecting a type supporting the operator '{0}' but given a tuple type</source>
        <target state="translated">'{0}' işlecini destekleyen bir tür bekleniyor ancak bir demet türü verildi.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperator">
        <source>None of the types '{0}' support the operator '{1}'</source>
        <target state="translated">{0}' türlerinin hiçbiri '{1}' işlecini desteklemez</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperator">
        <source>The type '{0}' does not support the operator '{1}'</source>
        <target state="translated">{0}' türü '{1}' işlecini desteklemez</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperatorNullable">
        <source>None of the types '{0}' support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">{0}' türlerinin hiçbiri '{1}' işlecini desteklemez. 'Microsoft.FSharp.Linq.NullableOperators' modülünü açmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperatorNullable">
        <source>The type '{0}' does not support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">{0}' türü '{1}' işlecini desteklemez. 'Microsoft.FSharp.Linq.NullableOperators' modülünü açmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportConversion">
        <source>The type '{0}' does not support a conversion to the type '{1}'</source>
        <target state="translated">{0}' türü '{1}' türüne dönüşümü desteklemez</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is static</source>
        <target state="translated">{0}' türünün '{1}' metodu var (tam adı '{2}'), ancak bu metot statik</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsNotStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is not static</source>
        <target state="translated">{0}' türünün '{1}' metodu var (tam adı '{2}'), ancak bu metot statik değil</target>
        <note />
      </trans-unit>
      <trans-unit id="csStructConstraintInconsistent">
        <source>The constraints 'struct' and 'not struct' are inconsistent</source>
        <target state="translated">'struct' ve 'not struct' kısıtlamaları tutarsız</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value</source>
        <target state="translated">'{0}' türünde uygun değer olarak 'null' yoktur</target>
        <note />
      </trans-unit>
      <trans-unit id="csNullableTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'.</source>
        <target state="translated">'{0}' türünün uygun değer olarak bir 'null' değeri yok. Boş değer atanabilir türe bir boş değer atamak için 'System.Nullable()' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison1">
        <source>The type '{0}' does not support the 'comparison' constraint because it has the 'NoComparison' attribute</source>
        <target state="translated">'{0}' türünün 'NoComparison' özniteliği olduğu için 'comparison' kısıtlamasını desteklemez</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison2">
        <source>The type '{0}' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface</source>
        <target state="translated">'{0}' türü 'comparison' kısıtlamasını desteklemez. Örneğin, 'System.IComparable' arabirimini desteklemez</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison3">
        <source>The type '{0}' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison</source>
        <target state="translated">'{0}' türü, 'comparison' kısıtlamasını desteklemeyen bir veya daha fazla yapısal öğe türünün olduğu bir record, union veya struct olduğu için 'comparison' kısıtlamasını desteklemez. Bu türde karşılaştırma kullanmayın veya hangi alan türünün karşılaştırmayı desteklemediğini belirlemek için 'StructuralComparison' özniteliğini türe ekleyin</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality1">
        <source>The type '{0}' does not support the 'equality' constraint because it has the 'NoEquality' attribute</source>
        <target state="translated">'{0}' türünün 'NoEquality' özniteliği olduğu için 'equality' kısıtlamasını desteklemez</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality2">
        <source>The type '{0}' does not support the 'equality' constraint because it is a function type</source>
        <target state="translated">'{0}' türünün bir işlev türü olduğu için 'equality' kısıtlamasını desteklemez</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality3">
        <source>The type '{0}' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality</source>
        <target state="translated">'{0}' türü, 'equality' kısıtlamasını desteklemeyen bir veya daha fazla yapısal öğe türünün olduğu bir record, union veya struct olduğu için 'equality' kısıtlamasını desteklemez. Bu türde eşitlik kullanmayın veya hangi alan türünün eşitliği desteklemediğini belirlemek için 'StructuralEquality' özniteliğini türe ekleyin</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotEnumType">
        <source>The type '{0}' is not a CLI enum type</source>
        <target state="translated">'{0}' türü bir CLI enum türü değil</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeHasNonStandardDelegateType">
        <source>The type '{0}' has a non-standard delegate type</source>
        <target state="translated">'{0}' türünün standart olmayan temsilci türü var</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotDelegateType">
        <source>The type '{0}' is not a CLI delegate type</source>
        <target state="translated">'{0}' türü bir CLI temsilci türü değil</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeParameterCannotBeNullable">
        <source>This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values.</source>
        <target state="translated">Bu tür parametresi 'Nullable' olarak örneklenemez. Bu, bazı CLI dillerinde 'null' ifadesinin anlamının 'Nullable' değerlerle birlikte kullanıldığında karışıklık yaratmamasını sağlamak amacıyla getirilmiş bir kısıtlamadır.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructType">
        <source>A generic construct requires that the type '{0}' is a CLI or F# struct type</source>
        <target state="translated">Genel bir yapı, '{0}' türünün bir CLI veya F# struct türü olmasını gerektirir</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresUnmanagedType">
        <source>A generic construct requires that the type '{0}' is an unmanaged type</source>
        <target state="translated">Genel bir yapı, '{0}' türünün yönetilmeyen bir tür olmasını gerektirir</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeNotCompatibleBecauseOfPrintf">
        <source>The type '{0}' is not compatible with any of the types {1}, arising from the use of a printf-style format string</source>
        <target state="translated">{0}' türü, printf tarzı biçim dizesinin kullanımından kaynaklanan {1} türlerinden herhangi biriyle uyumlu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresReferenceSemantics">
        <source>A generic construct requires that the type '{0}' have reference semantics, but it does not, i.e. it is a struct</source>
        <target state="translated">Genel bir yapı, '{0}' türünde başvuru semantiği olmasını gerektirir ancak bu söz konusu değil, yani bu bir struct</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresNonAbstract">
        <source>A generic construct requires that the type '{0}' be non-abstract</source>
        <target state="translated">Genel bir yapı, '{0}' türünün soyut olmamasını gerektirir</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresPublicDefaultConstructor">
        <source>A generic construct requires that the type '{0}' have a public default constructor</source>
        <target state="translated">Genel bir yapı, '{0}' türünde ortak varsayılan oluşturucu olmasını gerektirir</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInstantiationLengthMismatch">
        <source>Type instantiation length mismatch</source>
        <target state="translated">Tür örnekleme uzunluğu uyuşmazlığı</target>
        <note />
      </trans-unit>
      <trans-unit id="csOptionalArgumentNotPermittedHere">
        <source>Optional arguments not permitted here</source>
        <target state="translated">İsteğe bağlı bağımsız değişkenler burada kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotStatic">
        <source>{0} is not a static member</source>
        <target state="translated">{0} bir statik üye değil</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotInstance">
        <source>{0} is not an instance member</source>
        <target state="translated">{0} bir örnek üyesi değil</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentLengthMismatch">
        <source>Argument length mismatch</source>
        <target state="translated">Bağımsız değişken uzunluğu mismatch uyuşmazlığı</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentTypesDoNotMatch">
        <source>The argument types don't match</source>
        <target state="translated">Bağımsız değişken türleri eşleşmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodExpectsParams">
        <source>This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument</source>
        <target state="translated">Bu metot bu konumda CLI 'params' parametresini bekler. 'params', C# gibi dillerde değişken sayıda bağımsız değişkeni bir metoda geçirme yoludur. Bu bağımsız değişken için bir dizi geçirmeyi düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible">
        <source>The member or object constructor '{0}' is not {1}</source>
        <target state="translated">Üye veya nesne oluşturucu '{0}', {1} değil</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible2">
        <source>The member or object constructor '{0}' is not {1}. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.</source>
        <target state="translated">Üye veya nesne oluşturucu '{0}', {1} değil. Özel üyelere yalnızca tanımlayan türün içinden erişilebilir. Korunan üyelere yalnızca genişletilen bir türden erişilebilir, iç lambda ifadelerinden erişilemez.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAStaticMethod">
        <source>{0} is not a static method</source>
        <target state="translated">{0} bir statik metot değil</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAnInstanceMethod">
        <source>{0} is not an instance method</source>
        <target state="translated">{0} bir örnek metodu değil</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberHasNoArgumentOrReturnProperty">
        <source>The member or object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">Üye veya nesne oluşturucu '{0}' bağımsız değişkene veya ayarlanabilen '{1}' dönüş özelliğine sahip değil. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorHasNoArgumentOrReturnProperty">
        <source>The object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">{0}' nesne oluşturucusu, bağımsız değişkene veya ayarlanabilen '{1}' dönüş özelliğine sahip değil. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csRequiredSignatureIs">
        <source>The required signature is {0}</source>
        <target state="translated">Gereken imza: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'.</source>
        <target state="translated">Üye veya nesne oluşturucu '{0}' {1} bağımsız değişken gerektirir. Gereken imza: '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch2">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'.</source>
        <target state="translated">Üye veya nesne oluşturucu '{0}' {1} bağımsız değişken daha gerektiriyor. Gereken imza: '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch3">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">Üye veya nesne oluşturucu '{0}' {1} bağımsız değişken gerektirir. Gereken imza: '{2}'. Eksik bağımsız değişkenlerden bazılarının adları: {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch4">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">Üye veya nesne oluşturucu '{0}' {1} bağımsız değişken daha gerektirir. Gereken imza: '{2}'. Eksik bağımsız değişkenlerden bazılarının adları: {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityNamed">
        <source>The member or object constructor '{0}' requires {1} argument(s) but is here given {2} unnamed and {3} named argument(s). The required signature is '{4}'.</source>
        <target state="translated">Üye veya nesne oluşturucu '{0}' {1} bağımsız değişken alır ancak burada adlandırılmamış {2} ve adlandırılmış {3} bağımsız değişken verilmiş. Gereken imza: '{4}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArity">
        <source>The member or object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Üye veya nesne oluşturucu '{0}' {1} bağımsız değişken alır ancak burada {2} bağımsız değişken verilmiş. Gereken imza: '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArity">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">{0}' nesne oluşturucusunun {1} bağımsız değişken alması gerekiyor, ancak burada {2} bağımsız değişken almış. Gerekli imza: '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArityProp">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',').</source>
        <target state="translated">{0}' nesne oluşturucusunun {1} bağımsız değişken alması gerekiyor, ancak burada {2} bağımsız değişken almış. Gerekli imza: '{3}'. Bazı bağımsız değişkenler özelliklere değer atamak için kullanıldıysa, bu bağımsız değişkenleri virgül (',') ile ayırmanız önerilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityType">
        <source>The member or object constructor '{0}' takes {1} type argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Üye veya nesne oluşturucu '{0}' {1} tür bağımsız değişkeni alır ancak burada {2} bağımsız değişken verilmiş. Gereken imza: '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberNotAccessible">
        <source>A member or object constructor '{0}' taking {1} arguments is not accessible from this code location. All accessible versions of method '{2}' take {3} arguments.</source>
        <target state="translated">{1} bağımsız değişken alan '{0}' adlı üyeye veya nesne oluşturucusuna bu kod konumundan erişilemiyor. '{2}' metodunun erişilebilen tüm sürümleri {3} bağımsız değişken alır.</target>
        <note />
      </trans-unit>
      <trans-unit id="csIncorrectGenericInstantiation">
        <source>Incorrect generic instantiation. No {0} member named '{1}' takes {2} generic arguments.</source>
        <target state="translated">Yanlış genel örnekleme. '{1}' adlı hiçbir {0} üyesi {2} genel bağımsız değişkenlerini almıyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberOverloadArityMismatch">
        <source>The member or object constructor '{0}' does not take {1} argument(s). An overload was found taking {2} arguments.</source>
        <target state="translated">Üye veya nesne oluşturucu '{0}', {1} bağımsız değişkenlerini almaz. {2} bağımsız değişkenler alınırken aşırı yükleme bulundu.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments</source>
        <target state="translated">Hiçbir {0} üyesi veya '{1}' adlı nesne oluşturucusu {2} bağımsız değişken almaz</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments2">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. Note the call to this member also provides {3} named arguments.</source>
        <target state="translated">Hiçbir {0} üyesi veya '{1}' adlı nesne oluşturucusu {2} bağımsız değişken almaz. Bu üyeye çağrı yapılmasının {3} adlandırılmış bağımsız değişken sağladığına ayrıca dikkat edin.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments3">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. The named argument '{3}' doesn't correspond to any argument or settable return property for any overload.</source>
        <target state="translated">Hiçbir {0} üyesi veya '{1}' adlı nesne oluşturucusu {2} bağımsız değişken almaz. '{3}' adlandırılmış bağımsız değişkeni, herhangi bir aşırı yüklemeye yönelik hiçbir bağımsız değişkene veya ayarlanabilen dönüş özelliğine karşılık gelmiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodNotFound">
        <source>Method or object constructor '{0}' not found</source>
        <target state="translated">Metot veya nesne oluşturucusu '{0}' bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFound">
        <source>No overloads match for method '{0}'.</source>
        <target state="translated">Hiçbir aşırı yükleme '{0}' metodu ile eşleşmiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsOverloaded">
        <source>A unique overload for method '{0}' could not be determined based on type information prior to this program point. A type annotation may be needed.</source>
        <target state="translated">Bu program noktasından önce, tür bilgilerine dayalı olarak '{0}' metodu için benzersiz bir aşırı yükleme belirlenemedi. Tür ek açıklaması gerekebilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCandidates">
        <source>Candidates:\n{0}</source>
        <target state="translated">Adaylar:\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="parsDoCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on 'do' bindings, but '{0}' was given.</source>
        <target state="translated">Erişilebilirlik değiştiricilerine 'do' bağlamalarında izin verilmez, ancak '{0}' belirtildi.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInHashIf">
        <source>End of file in #if section begun at or after here</source>
        <target state="translated">#if bölümünde dosya sonu burada veya daha önce başlatıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInString">
        <source>End of file in string begun at or before here</source>
        <target state="translated">Dizede dosya sonu burada veya daha önce başlatıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimString">
        <source>End of file in verbatim string begun at or before here</source>
        <target state="translated">Tam dizede dosya sonu burada veya daha önce başlatıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInComment">
        <source>End of file in comment begun at or before here</source>
        <target state="translated">Açıklamada dosya sonu burada veya daha önce başlatıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInStringInComment">
        <source>End of file in string embedded in comment begun at or before here</source>
        <target state="translated">Açıklamaya gömülü dizede dosya sonu burada veya daha önce başlatıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimStringInComment">
        <source>End of file in verbatim string embedded in comment begun at or before here</source>
        <target state="translated">Açıklamaya gömülü tam dizede dosya sonu burada veya daha önce başlatıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInIfOcaml">
        <source>End of file in IF-OCAML section begun at or before here</source>
        <target state="translated">IF-OCAML bölümünde dosya sonu burada veya daha önce başlatıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInDirective">
        <source>End of file in directive begun at or before here</source>
        <target state="translated">Yönergede dosya sonu burada veya daha önce başlatıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoHashEndIfFound">
        <source>No #endif found for #if or #else</source>
        <target state="translated">#if veya #else için bir #endif bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIgnored">
        <source>Attributes have been ignored in this construct</source>
        <target state="translated">Bu yapıda öznitelikler yok sayıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInImplicitClassConstructors">
        <source>'use' bindings are not permitted in primary constructors</source>
        <target state="translated">birincil oluşturucularda 'use' bağlamalarına izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInModules">
        <source>'use' bindings are not permitted in modules and are treated as 'let' bindings</source>
        <target state="translated">modüllerde 'use' bağlamalarına izin verilmez ve 'let' bağlamaları gibi işlem yapılır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIntegerForLoopRequiresSimpleIdentifier">
        <source>An integer for loop must use a simple identifier</source>
        <target state="translated">Döngü tamsayısı basit tanımlayıcı kullanmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyOneWithAugmentationAllowed">
        <source>At most one 'with' augmentation is permitted</source>
        <target state="translated">En çok bir 'with' genişletmesine izin verilir</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSemicolon">
        <source>A semicolon is not expected at this point</source>
        <target state="translated">Bu aşamada noktalı virgül beklenmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFile">
        <source>Unexpected end of input</source>
        <target state="translated">Beklenmeyen giriş sonu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedVisibilityDeclaration">
        <source>Accessibility modifiers are not permitted here, but '{0}' was given.</source>
        <target state="translated">Erişilebilirlik değiştiricilerine burada izin verilmez, ancak '{0}' belirtildi.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyHashDirectivesAllowed">
        <source>Only '#' compiler directives may occur prior to the first 'namespace' declaration</source>
        <target state="translated">İlk 'namespace' bildiriminden önce yalnızca '#' derleyici yönergeleri gerçekleşebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityDeclarationsShouldComePriorToIdentifier">
        <source>Accessibility modifiers should come immediately prior to the identifier naming a construct</source>
        <target state="translated">Erişilebilirlik değiştiricileri bir yapıyı adlandıran tanımlayıcıdan hemen önce gelmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNamespaceOrModuleNotBoth">
        <source>Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'</source>
        <target state="translated">Dosyalar ad alanıyla veya modül bildirimiyle başlamalıdır, örn. 'namespace SomeNamespace.SubNamespace' veya 'module SomeNamespace.SomeModule', ikisiyle birden değil. Ad alanı içinde bir modül tanımlamak için 'module SomeModule = ...' kullanın</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleAbbreviationMustBeSimpleName">
        <source>A module abbreviation must be a simple name, not a path</source>
        <target state="translated">Modül kısaltması yol değil, basit ad olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviation">
        <source>Ignoring attributes on module abbreviation</source>
        <target state="translated">Modül kısaltmasındaki öznitelikler yoksayılıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">Modül kısaltmasında '{0}' erişilebilirlik özniteliğine izin verilmez. Modül kısaltmaları her zaman özeldir.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">Modül kısaltmasında '{0}' görünürlük özniteliğine izin verilmez. Modül kısaltmaları her zaman özeldir.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnClosedBlockInHashLight">
        <source>Unclosed block</source>
        <target state="translated">Kapatılmamış blok</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBeginOrStruct">
        <source>Unmatched 'begin' or 'struct'</source>
        <target state="translated">Eşleşmeyen 'begin' veya 'struct'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleDefnMustBeSimpleName">
        <source>A module name must be a simple name, not a path</source>
        <target state="translated">Modül adı yol değil, basit ad olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEmptyModuleDefn">
        <source>Unexpected empty type moduleDefn list</source>
        <target state="translated">Beklenmeyen boş tür moduleDefn listesi</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesMustComeBeforeVal">
        <source>Attributes should be placed before 'val'</source>
        <target state="translated">Öznitelikler 'val' öğesinin önüne konulmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesAreNotPermittedOnInterfaceImplementations">
        <source>Attributes are not permitted on interface implementations</source>
        <target state="translated">Arabirim uygulamalarında özniteliklere izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxError">
        <source>Syntax error</source>
        <target state="translated">Söz dizimi hatası</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAugmentationsIllegalOnDelegateType">
        <source>Augmentations are not permitted on delegate type moduleDefns</source>
        <target state="translated">moduleDefns temsilci türünde genişletmelere izin verilmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedClassInterfaceOrStruct">
        <source>Unmatched 'class', 'interface' or 'struct'</source>
        <target state="translated">Eşleşmeyen 'class', 'interface' veya 'struct'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyTypeDefinition">
        <source>A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'.</source>
        <target state="translated">Tür tanımı, bir veya daha fazla üyeyi ya da diğer tanımlamaları gerektirir. Boş bir class, struct veya interface tanımlamayı planlıyorsanız 'type ... = class end', 'interface end' veya 'struct end' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedWith">
        <source>Unmatched 'with' or badly formatted 'with' block</source>
        <target state="translated">Eşleşmeyen 'with' veya hatalı biçimlendirilmiş 'with' bloğu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetOrSetRequired">
        <source>'get', 'set' or 'get,set' required</source>
        <target state="translated">'get', 'set' veya 'get,set' gerekiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyClassCanTakeValueArguments">
        <source>Only class types may take value arguments</source>
        <target state="translated">Yalnızca sınıf türleri değer bağımsız değişkenleri alabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBegin">
        <source>Unmatched 'begin'</source>
        <target state="translated">Eşleşmeyen 'begin'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidDeclarationSyntax">
        <source>Invalid declaration syntax</source>
        <target state="translated">Geçersiz bildirim sözdizimi</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetAndOrSetRequired">
        <source>'get' and/or 'set' required</source>
        <target state="translated">'get' ve/veya 'set' gerekiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAnnotationsOnGetSet">
        <source>Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'</source>
        <target state="translated">Özellik alıcılar ve ayarlayıcılardaki tür ek açıklamaları 'get()' veya 'set(v)' ifadesinden sonra verilmelidir, örn. 'with get() : string = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterMustHaveAtLeastOneArgument">
        <source>A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'</source>
        <target state="translated">Alıcı özelliğinin işlev olması bekleniyor, örn. 'get() = ...' veya 'get(index) = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultipleAccessibilitiesForGetSet">
        <source>Multiple accessibilities given for property getter or setter</source>
        <target state="translated">Özellik alıcı veya ayarlayıcı için birden çok erişilebilirlik verildi</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetSyntax">
        <source>Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '</source>
        <target state="translated">Özellik ayarlayıcıları 'set value = ', 'set idx value = ' veya 'set (idx1,...,idxN) value = ... ' kullanılarak tanımlanmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInterfacesHaveSameVisibilityAsEnclosingType">
        <source>Interfaces always have the same visibility as the enclosing type</source>
        <target state="translated">Arabirimler her zaman kapsayan tür ile aynı görünürlüğe sahiptir</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAccessibilityModsIllegalForAbstract">
        <source>Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.</source>
        <target state="translated">Erişilebilirlik değiştiricilerine bu üyede izin verilmiyor. Soyut yuvalar, kapsayan tür ile her zaman aynı görünürlüğe sahiptir.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalOnInherit">
        <source>Attributes are not permitted on 'inherit' declarations</source>
        <target state="translated">'inherit' tanımlamalarında özniteliklere izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityIllegalOnInherit">
        <source>Accessibility modifiers are not permitted on an 'inherits' declaration</source>
        <target state="translated">'inherits' bildiriminde erişilebilirlik değiştiricilerine izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInheritDeclarationsCannotHaveAsBindings">
        <source>'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding.</source>
        <target state="translated">'inherit' tanımlamalarının 'as' bağlamaları olamaz. Bir metodu geçersiz kılarken temel sınıfın üyelerine erişmek için 'base.SomeMember' sözdizimi kullanılabilir; 'base' bir anahtar sözcüktür. Bu 'as' bağlamasını kaldırın.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalHere">
        <source>Attributes are not allowed here</source>
        <target state="translated">Özniteliklere burada izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for type abbreviations</source>
        <target state="translated">Erişilebilirlik değiştiricilerine tür kısaltmalarının bu konumunda izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumTypesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for enum types</source>
        <target state="translated">Erişilebilirlik değiştiricilerine enum türlerinin bu konumunda izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAllEnumFieldsRequireValues">
        <source>All enum fields must be given values</source>
        <target state="translated">Tüm enum alanları verilen değerler olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInlineAssemblyCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on inline assembly code types</source>
        <target state="translated">Erişilebilirlik değiştiricilerine satır içi bütünleştirilmiş kod kodu türlerinde izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIdentifier">
        <source>Unexpected identifier: '{0}'</source>
        <target state="translated">Beklenmeyen tanımlayıcı: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnionCasesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Birleşim durumlarında erişilebilirlik değiştiricilerine izin verilmez. Temsilin tamamına erişilebilirlik kazandırmak için 'type U = internal ...' veya 'type U = private ...' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on enumeration fields</source>
        <target state="translated">Erişilebilirlik değiştiricilerine sabit listesi alanlarında izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsConsiderUsingSeparateRecordType">
        <source>Consider using a separate record type instead</source>
        <target state="translated">Onun yerine ayrı bir kayıt türü kullanmayı deneyin</target>
        <note />
      </trans-unit>
      <trans-unit id="parsRecordFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Kayıt alanlarında erişilebilirlik değiştiricilerine izin verilmez. Temsilin tamamına erişilebilirlik kazandırmak için 'type R = internal ...' veya 'type R = private ...' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsLetAndForNonRecBindings">
        <source>The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings</source>
        <target state="translated">Özyinelemeli olmayan bağlamalar için 'let ... and ...' bildirim biçimi F# kodunda kullanılmaz. 'let' bağlama sırası kullanmayı düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedParen">
        <source>Unmatched '('</source>
        <target state="translated">Eşleşmeyen '('</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessivePatternsShouldBeSpacedOrTupled">
        <source>Successive patterns should be separated by spaces or tupled</source>
        <target state="translated">Ardışık desenler boşluklarla veya grup olarak tanımlayarak ayrılmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoMatchingInForLet">
        <source>No matching 'in' found for this 'let'</source>
        <target state="translated">Bu 'let' için eşleşen bir 'in' bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorInReturnForLetIncorrectIndentation">
        <source>Error in the return expression for this 'let'. Possible incorrect indentation.</source>
        <target state="translated">Bu 'let' için dönüş ifadesinde hata. Muhtemelen hatalı girinti.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterLet">
        <source>The block following this '{0}' is unfinished. Every code block is an expression and must have a result. '{1}' cannot be the final code element in a block. Consider giving this block an explicit result.</source>
        <target state="translated">Bu '{0}' öğesini izleyen blok tamamlanmadı. Her kod bloğu bir ifadedir ve bir sonucu olmalıdır. '{1}' bir bloktaki son kod öğesi olamaz. Bu bloğa açık bir sonuç vermeyi düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIncompleteIf">
        <source>Incomplete conditional. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Eksik koşullu. 'if &lt;expr&gt; then &lt;expr&gt;' veya 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAssertIsNotFirstClassValue">
        <source>'assert' may not be used as a first class value. Use 'assert &lt;expr&gt;' instead.</source>
        <target state="translated">'assert' birinci sınıf değer olarak kullanılamaz. Bunun yerine 'assert &lt;expr&gt;' değerini kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">Tanımlayıcı bekleniyor</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInOrEqualExpected">
        <source>'in' or '=' expected</source>
        <target state="translated">'in' veya '=' bekleniyor</target>
        <note />
      </trans-unit>
      <trans-unit id="parsArrowUseIsLimited">
        <source>The use of '-&gt;' in sequence and computation expressions is limited to the form 'for pat in expr -&gt; expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions.</source>
        <target state="translated">Dizi ve hesaplama ifadelerinde '-&gt;' kullanımı, 'for pat in expr -&gt; expr' biçimiyle sınırlıdır. Daha karmaşık dizi ifadelerinde öğe oluşturmak için 'for ... in ... do ... yield...' söz dizimini kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessiveArgsShouldBeSpacedOrTupled">
        <source>Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized</source>
        <target state="translated">Ardışık bağımsız değişkenler boşluklarla veya grup olarak tanımlayarak ayrılmalı ve işlev veya metot uygulamaları içeren bağımsız değişkenler ayraç içine alınmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracket">
        <source>Unmatched '['</source>
        <target state="translated">Eşleşmeyen '['</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingQualificationAfterDot">
        <source>Missing qualification after '.'</source>
        <target state="translated">'.' sonrasında eksik nitelik</target>
        <note />
      </trans-unit>
      <trans-unit id="parsParenFormIsForML">
        <source>In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array</source>
        <target state="translated">F# kodunda 'expr.[expr]' kullanabilirsiniz. İlk ifadenin dizi olduğunu belirtmek için tür ek açıklaması gerekebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuote">
        <source>Mismatched quotation, beginning with '{0}'</source>
        <target state="translated">'{0}' ile başlayan, eşleşmeyen alıntı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatched">
        <source>Unmatched '{0}'</source>
        <target state="translated">Eşleşmeyen '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracketBar">
        <source>Unmatched '[|'</source>
        <target state="translated">Eşleşmeyen '[|'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBrace">
        <source>Unmatched '{{'</source>
        <target state="translated">Eşleşmeyen '{{'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsFieldBinding">
        <source>Field bindings must have the form 'id = expr;'</source>
        <target state="translated">Alan bağlamaları 'id = expr;' biçiminde olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMemberIllegalInObjectImplementation">
        <source>This member is not permitted in an object implementation</source>
        <target state="translated">Nesne uygulamasında bu üyeye izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingFunctionBody">
        <source>Missing function body</source>
        <target state="translated">Eksik işlev gövdesi</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxErrorInLabeledType">
        <source>Syntax error in labelled type argument</source>
        <target state="translated">Etiketli tür bağımsız değişkeninde sözdizimi hatası</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedInfixOperator">
        <source>Unexpected infix operator in type expression</source>
        <target state="translated">Tür ifadesinde beklenmeyen içtakı işleci</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultiArgumentGenericTypeFormDeprecated">
        <source>The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident&lt;typ,...,typ&gt;' instead</source>
        <target state="translated">F# kodunda '(typ,...,typ) ident' söz dizimi kullanılmaz . Bunun yerine 'ident&lt;typ,...,typ&gt;' söz dizimini kullanmayı göz önünde bulundurun</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidLiteralInType">
        <source>Invalid literal in type</source>
        <target state="translated">Türde geçersiz sabit değer</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedOperatorForUnitOfMeasure">
        <source>Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'.</source>
        <target state="translated">Ölçü birimi ifadesinde beklenmeyen içtakı işleci. Geçerli işleçler: '*', '/' ve '^'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIntegerLiteralForUnitOfMeasure">
        <source>Unexpected integer literal in unit-of-measure expression</source>
        <target state="translated">Ölçü birimi ifadesinde beklenmeyen tamsayı sabit değeri</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedTypeParameter">
        <source>Syntax error: unexpected type parameter specification</source>
        <target state="translated">Sözdizimi hatası: beklenmeyen tür parametresi belirtimi</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuotationName">
        <source>Mismatched quotation operator name, beginning with '{0}'</source>
        <target state="translated">'{0}' ile başlayan, eşleşmeyen alıntı işleci adı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseMustBeginWithUpperCase">
        <source>Active pattern case identifiers must begin with an uppercase letter</source>
        <target state="translated">Etkin desen örneği tanımlayıcıları büyük harfle başlamalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseContainsPipe">
        <source>The '|' character is not permitted in active pattern case identifiers</source>
        <target state="translated">'|' karakterine ektin desen örneği tanımlayıcılarında izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalDenominatorForMeasureExponent">
        <source>Denominator must not be 0 in unit-of-measure exponent</source>
        <target state="translated">Ölçü birimi üssünde payda 0 olmamalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoEqualShouldFollowNamespace">
        <source>No '=' symbol should follow a 'namespace' declaration</source>
        <target state="translated">'namespace' bildirimini bir '=' simgesi izleyemez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleStructEndDeprecated">
        <source>The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">'module ... = struct .. end' sözdizimi F# kodunda kullanılmaz. 'module ... = begin .. end' kullanmayı düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleSigEndDeprecated">
        <source>The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">'module ... : sig .. end' sözdizimi F# kodunda kullanılmaz. 'module ... = begin .. end' kullanmayı düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticFieldUsedWhenInstanceFieldExpected">
        <source>A static field was used where an instance field is expected</source>
        <target state="translated">Örnek alanı beklenen yerde statik alan kullanılmış</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodNotAccessible">
        <source>Method '{0}' is not accessible from this code location</source>
        <target state="translated">'{0}' metoduna bu kod konumundan erişilemiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplicitMeasureFollowingSlash">
        <source>Implicit product of measures following /</source>
        <target state="translated">/ sonrasındaki ölçülerin örtük çarpımı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedMeasureAnon">
        <source>Unexpected SynMeasure.Anon</source>
        <target state="translated">Beklenmeyen SynMeasure.Anon</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonZeroConstantCannotHaveGenericUnit">
        <source>Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.</source>
        <target state="translated">Sıfır olmayan sabit değerlerin genel birimleri olamaz. Genel sıfır için 0.0&lt;_&gt; yazın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSeqResultsUseYield">
        <source>In sequence expressions, results are generated using 'yield'</source>
        <target state="translated">Dizi ifadelerinde, sonuçlar 'yield' kullanılarak oluşturulur</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedBigRationalConstant">
        <source>Unexpected big rational constant</source>
        <target state="translated">Beklenmeyen büyüklükte oran sabiti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForUnitsOfMeasure">
        <source>Units-of-measure are only supported on float, float32, decimal, and integer types.</source>
        <target state="needs-review-translation">Ölçü birimleri yalnızca kayan, float32, ondalık ve işaretli tamsayı türlerinde desteklenir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstUint16Array">
        <source>Unexpected Const_uint16array</source>
        <target state="translated">Beklenmeyen Const_uint16array</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstByteArray">
        <source>Unexpected Const_bytearray</source>
        <target state="translated">Beklenmeyen Const_bytearray</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterRequiresName">
        <source>A parameter with attributes must also be given a name, e.g. '[&lt;Attribute&gt;] Name : Type'</source>
        <target state="translated">Öznitelikleri olan bir parametreye ad da verilmelidir, ör. '[&lt;Attribute&gt;] Name : Type'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnValuesCannotHaveNames">
        <source>Return values cannot have names</source>
        <target state="translated">Dönüş değerlerinin adları olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberKindPropertyGetSetNotExpected">
        <source>MemberKind.PropertyGetSet only expected in parse trees</source>
        <target state="translated">MemberKind.PropertyGetSet yalnızca ayrıştırma ağaçlarında beklenir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainValues">
        <source>Namespaces cannot contain values. Consider using a module to hold your value declarations.</source>
        <target state="translated">Ad alanları değer içeremez. Değer bildirimlerinizi tutmak için modül kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainExtensionMembers">
        <source>Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.</source>
        <target state="translated">Ad alanları, türün tanımlandığı dosya ve ad alanı bildirim grubundakiler dışında uzantı üyeleri içeremez. Uzantı üyesi bildirimlerini tutmak için bir modül kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributes">
        <source>Multiple visibility attributes have been specified for this identifier</source>
        <target state="translated">Bu tanımlayıcı için birden çok görünürlük özniteliği belirtilmiş</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributesWithLet">
        <source>Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions.</source>
        <target state="translated">Bu tanımlayıcı için birden çok görünürlük özniteliği belirtilmiş. İfade içlerindeki tüm 'let' bağlamaları her zaman özel olduğu gibi sınıflardaki 'let' bağlamaları da her zaman özeldir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForRelationalOperator">
        <source>The name '({0})' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">({0})' adı üye adı olarak kullanılmamalıdır. Türe yönelik karşılaştırma semantiğini tanımlamak için 'System.IComparable' arabirimini uygulayın. Diğer CLI dillerinden kullanılacak statik bir üye tanımlıyorsanız onun yerine '{1}' adını kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForEquality">
        <source>The name '({0})' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">({0})' adı üye adı olarak kullanılmamalıdır. Türe yönelik eşitlik semantiğini tanımlamak için 'Object.Equals' üyesini geçersiz kılın. Diğer CLI dillerinden kullanılacak statik bir üye tanımlıyorsanız onun yerine '{1}' adını kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberName">
        <source>The name '({0})' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">({0})' adı üye adı olarak kullanılmamalıdır. Diğer CLI dillerinden kullanılacak statik bir üye tanımlıyorsanız onun yerine '{1}' adını kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameFixedTypes">
        <source>The name '({0})' should not be used as a member name because it is given a standard definition in the F# library over fixed types</source>
        <target state="translated">'({0})' adına F# kitaplığında sabit türler üzerinden standart bir tanım verildiği için üye adı olarak kullanılmamalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionRelational">
        <source>The '{0}' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type.</source>
        <target state="translated">'{0}' işleci normalde yeniden tanımlanmamalıdır. Belirli bir türün aşırı yüklenmiş karşılaştırma semantiğini tanımlamak için o türün tanımında 'System.IComparable' arabirimini uygulayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionEquality">
        <source>The '{0}' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type.</source>
        <target state="translated">'{0}' işleci normalde yeniden tanımlanmamalıdır. Bir türün eşitlik semantiğini tanımlamak için o türün tanımında 'Object.Equals' üyesini geçersiz kılın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinition">
        <source>The '{0}' operator should not normally be redefined. Consider using a different operator name</source>
        <target state="translated">'{0}' işleci normalde yeniden tanımlanmamalıdır. Farklı bir işleç adı kullanmayı düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexOperatorDefinition">
        <source>The '{0}' operator cannot be redefined. Consider using a different operator name</source>
        <target state="translated">'{0}' işleci yeniden tanımlanamaz. Farklı bir işleç adı kullanmayı düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectModuleOrNamespaceParent">
        <source>Expected module or namespace parent {0}</source>
        <target state="translated">Modül veya ad alanı üst öğesi {0} bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">Yapı, kayıt veya birleşim türü '{0}', 'System.IComparable' arabirimini açık olarak uyguluyor. Türe 'CustomComparison' özniteliğini uygulamanız gerekir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsGenericIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable&lt;_&gt;' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.</source>
        <target state="translated">Yapı, kayıt veya birleşim türü '{0}', 'System.IComparable&lt;_&gt;' arabirimini açıkça uyguluyor. Türe 'CustomComparison' özniteliğini uygulamalı ve aynı zamanda genel olmayan System.IComparable arabiriminin tutarlı bir uygulamasını sağlamalısınız.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">Yapı, kayıt veya birleşim türü '{0}', 'System.IStructuralComparable' arabirimini açık olarak uyguluyor. Türe 'CustomComparison' özniteliğini uygulayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordFieldInconsistentTypes">
        <source>This record contains fields from inconsistent types</source>
        <target state="translated">Bu kayıt tutarsız türlere ait alanlar içeriyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportStubsCannotBeInlined">
        <source>DLLImport stubs cannot be inlined</source>
        <target state="translated">DLLImport saplamaları satır içine alınamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCanOnlyBindThisAtMemberDeclaration">
        <source>Structs may only bind a 'this' parameter at member declarations</source>
        <target state="translated">Yapılar üye bildirimlerinde yalnızca 'this' parametresini bağlayabilirler</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedExprAtRecInfPoint">
        <source>Unexpected expression at recursive inference point</source>
        <target state="translated">Özyinelemeli çıkarım noktasında beklenmeyen ifade</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLessGenericBecauseOfAnnotation">
        <source>This code is less generic than required by its annotations because the explicit type variable '{0}' could not be generalized. It was constrained to be '{1}'.</source>
        <target state="translated">Açık tür değişkeni '{0}' oluşturulamadığı için bu kod ek açıklamalarının gerektirdiğinden daha az genel. '{1}' olacak şekilde kısıtlanmıştı.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstrainedTypeVariableCannotBeGeneralized">
        <source>One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types</source>
        <target state="translated">Bu bağlamanın bir veya daha fazla açık sınıf veya işlev türü değişkeni diğer türlerle kısıtlandığı için oluşturulamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericParameterHasBeenConstrained">
        <source>A generic type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Genel bir tür parametresi, her zaman '{0}' olarak kısıtlanacak şekilde kullanılmış</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterHasBeenConstrained">
        <source>This type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Bu tür parametresi, her zaman '{0}' olarak kısıtlanacak şekilde kullanılmış</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParametersInferredAreNotStable">
        <source>The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</source>
        <target state="translated">Bu değer için çıkarsanan tür parametreleri, tür kısaltmalarının silinmesi halinde kararlı değildir. Bunun nedeni, tür parametrelerini bırakan veya yeniden sıralayan tür kısaltmalarının kullanımıdır, ör. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nBu değer için tür parametrelerini açıkça bildirmeyi deneyin, ör.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeParameterInvalid">
        <source>Explicit type parameters may only be used on module or member bindings</source>
        <target state="translated">Açık tür parametreleri yalnızca modülde veya üye bağlamalarında kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridingMethodRequiresAllOrNoTypeParameters">
        <source>You must explicitly declare either all or no type parameters when overriding a generic abstract method</source>
        <target state="translated">Genel soyut metodu geçersiz kılarken tür parametrelerinin ya tümünü açık olarak tanımlamanız ya da hiçbirini açık olarak tanımlamamanız gerekir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldsDoNotDetermineUniqueRecordType">
        <source>The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type</source>
        <target state="translated">Bu kayıt ifadesinin veya deseninin alan etiketleri ve beklenen türü, karşılık gelen bir kayıt türünü benzersiz olarak belirlemiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldAppearsTwiceInRecord">
        <source>The field '{0}' appears twice in this record expression or pattern</source>
        <target state="translated">'{0}' alanı bu kayıt ifadesinde veya deseninde iki kez görünüyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnknownUnion">
        <source>Unknown union case</source>
        <target state="translated">Bilinmeyen birleşim durumu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotSufficientlyGenericBecauseOfScope">
        <source>This code is not sufficiently generic. The type variable {0} could not be generalized because it would escape its scope.</source>
        <target state="translated">Bu kod yeterince genel değil. Tür değişkeni {0}, kapsamını kaçıracağı için genelleştirilemedi.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyRequiresExplicitTypeParameters">
        <source>A property cannot have explicit type parameters. Consider using a method instead.</source>
        <target state="translated">Bir özelliğin açık tür parametreleri olamaz. Onun yerine metot kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorCannotHaveTypeParameters">
        <source>A constructor cannot have explicit type parameters. Consider using a static construction method instead.</source>
        <target state="translated">Bir oluşturucunun açık tür parametreleri olamaz. Onun yerine statik oluşturma metodu kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInstanceMemberRequiresTarget">
        <source>This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'.</source>
        <target state="translated">Bu örnek üyesinin çağrılan nesneyi temsil etmek için parametreye ihtiyacı var. Üyeyi statik yapın veya 'member x.Member(args) = ...' gösterimini kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertyInSyntaxTree">
        <source>Unexpected source-level property specification in syntax tree</source>
        <target state="translated">Sözdizimi ağacında beklenmeyen kaynak düzeyli özellik belirtimi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializerRequiresArgument">
        <source>A static initializer requires an argument</source>
        <target state="translated">Statik başlatıcı için bağımsız değişken gerekiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorRequiresArgument">
        <source>An object constructor requires an argument</source>
        <target state="translated">Nesne oluşturucusu bağımsız değişken gerektiriyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticMemberShouldNotHaveThis">
        <source>This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'.</source>
        <target state="translated">Bu statik üyenin 'this' parametresi olmamalıdır. 'member Member(args) = ...' gösterimini kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitStaticInitializerSyntax">
        <source>An explicit static initializer should use the syntax 'static new(args) = expr'</source>
        <target state="translated">Açık statik başlatıcı 'static new(args) = expr' sözdizimini kullanmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitObjectConstructorSyntax">
        <source>An explicit object constructor should use the syntax 'new(args) = expr'</source>
        <target state="translated">Açık nesne oluşturucusu 'new(args) = expr' sözdizimini kullanmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertySpec">
        <source>Unexpected source-level property specification</source>
        <target state="translated">Beklenmeyen kaynak düzeyli özellik belirtimi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionFormDeprecated">
        <source>This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions.</source>
        <target state="translated">Nesne ifadesinin bu biçimi F# dilinde kullanılmaz. Nesne ifadelerinde üye uygulamalarını tanımlamak için 'member this.MemberName ... = ...' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDeclaration">
        <source>Invalid declaration</source>
        <target state="translated">Geçersiz bildirim</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesInvalidInPatterns">
        <source>Attributes are not allowed within patterns</source>
        <target state="translated">Desen içinde özniteliğe izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitTypeArguments">
        <source>The generic function '{0}' must be given explicit type argument(s)</source>
        <target state="translated">'{0}' genel işlevine açık tür bağımsız değişkenleri verilmesi gerekiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoesNotAllowExplicitTypeArguments">
        <source>The method or function '{0}' should not be given explicit type argument(s) because it does not declare its type parameters explicitly</source>
        <target state="translated">'{0}' metodu veya işlevi kendi tür parametrelerini açık olarak tanımlamadığı için açık tür bağımsız değişkenleri verilmemelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterArityMismatch">
        <source>This value, type or method expects {0} type parameter(s) but was given {1}</source>
        <target state="translated">Bu değer, tür veya metot {0} tür parametrelerini bekliyor ancak {1} verilmiş</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultStructConstructorCall">
        <source>The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization</source>
        <target state="translated">Varsayılan seçenek olan yapı türünün sıfır ile başlayan oluşturucusu yalnızca yapı türünün tüm alanları varsayılan başlatmayı kabul ediyorsa kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindIDisposable">
        <source>Couldn't find Dispose on IDisposable, or it was overloaded</source>
        <target state="translated">IDisposable üzerinde Dispose bulunamadı veya aşırı yüklenmişti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonLiteralCannotBeUsedInPattern">
        <source>This value is not a literal and cannot be used in a pattern</source>
        <target state="translated">Bu değer bir sabit değer olmadığından desende kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsReadonly">
        <source>This field is readonly</source>
        <target state="translated">Bu alan salt okunur</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameArgumentsMustAppearLast">
        <source>Named arguments must appear after all other arguments</source>
        <target state="translated">Adlandırılmış bağımsız değişkenler diğer tüm bağımsız değişkenlerden sonra görünmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitLambda">
        <source>This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking {0} arguments.</source>
        <target state="translated">Bu işlev değeri, imzası byref bağımsız değişkeni içeren bir temsilci türü oluşturmak için kullanılıyor. {0} bağımsız değişken alan açık lambda ifadesi kullanmanız gerekir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCannotBeEnumerated">
        <source>The type '{0}' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method</source>
        <target state="translated">'{0}' türü, değerleri bu söz dizimiyle numaralandırılabilecek bir tür değil, yani seq&lt;_&gt;, IEnumerable&lt;_&gt; veya IEnumerable ile uyumlu değil ve bir GetEnumerator metodu yok</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMixtureOfRecursiveForms">
        <source>This recursive binding uses an invalid mixture of recursive forms</source>
        <target state="translated">Bu özyinelemeli bağlama özyinelemeli biçimlerin geçersiz bir karışımını kullanıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectConstructionExpression">
        <source>This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.</source>
        <target state="translated">Bu geçerli bir nesne oluşturma ifadesi değil. Açık nesne oluşturucular ya alternatif bir oluşturucu çağırmalı ya da nesnenin tüm alanlarını başlatmalı ve üst sınıf oluşturucuya çağrı belirtmelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraint">
        <source>Invalid constraint</source>
        <target state="translated">Geçersiz kısıtlama</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraintTypeSealed">
        <source>Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution</source>
        <target state="translated">Geçersiz kısıtlama: kısıtlama için kullanılan tür mühürlü, yani bu kısıtlama yalnızca en çok tek çözümde karşılanabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumConstraint">
        <source>An 'enum' constraint must be of the form 'enum&lt;type&gt;'</source>
        <target state="translated">Bir 'enum' kısıtlaması, 'enum&lt;type&gt;' biçiminde olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNewConstraint">
        <source>'new' constraints must take one argument of type 'unit' and return the constructed type</source>
        <target state="translated">'new' kısıtlamaları 'unit' türünde bir bağımsız değişken almalı ve oluşturulan türü döndürmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPropertyType">
        <source>This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -&gt; ty3'. Properties returning functions should have types of the form '(ty1 -&gt; ty2)'.</source>
        <target state="translated">Bu özelliğin türü geçersiz. Birden çok dizin oluşturucu bağımsız değişkeni alan özellikler 'ty1 * ty2 -&gt; ty3' biçiminde olmalıdır. İşlev döndüren özellikler, '(ty1 -&gt; ty2)' biçiminde türlere sahip olmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureMarkWithAttribute">
        <source>Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.</source>
        <target state="translated">Tür parametresi değil unit-of-measure parametresi bekleniyordu. Açık unit-of-measure parametreleri [&lt;Measure&gt;] özniteliğiyle işaretlenmelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeParameter">
        <source>Expected type parameter, not unit-of-measure parameter</source>
        <target state="translated">Ölçü birimi parametresi değil tür parametresi bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeNotUnitOfMeasure">
        <source>Expected type, not unit-of-measure</source>
        <target state="translated">Ölçü birimi değil tür bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureNotType">
        <source>Expected unit-of-measure, not type</source>
        <target state="translated">Tür değil ölçü birimi bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUnitsOfMeasurePrefix">
        <source>Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.</source>
        <target state="translated">Ölçü birimleri bir türün ön ek bağımsız değişkenleri olarak kullanılamaz. Açılı ayraç içinde son ek bağımsız değişkeni olarak yeniden yazın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnitsOfMeasureInvalidInTypeConstructor">
        <source>Unit-of-measure cannot be used in type constructor application</source>
        <target state="translated">Tür oluşturucu uygulamasında ölçü birimi kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireBuilderMethod">
        <source>This control construct may only be used if the computation expression builder defines a '{0}' method</source>
        <target state="translated">Bu denetim yapısı, yalnızca hesaplama ifadesi oluşturucu '{0}' metodunu tanımlıyorsa kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoNestedTypes">
        <source>This type has no nested types</source>
        <target state="translated">Bu türde hiç iç içe tür yok</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSymbolInTypeExpression">
        <source>Unexpected {0} in type expression</source>
        <target state="translated">Tür ifadesinde beklenmeyen {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterInvalidAsTypeConstructor">
        <source>Type parameter cannot be used as type constructor</source>
        <target state="translated">Tür parametresi tür oluşturucusu olarak kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalSyntaxInTypeExpression">
        <source>Illegal syntax in type expression</source>
        <target state="translated">Tür ifadesinde geçersiz sözdizimi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousUnitsOfMeasureCannotBeNested">
        <source>Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression</source>
        <target state="translated">Anonim ölçü birimi başka bir ölçü birimi ifadesinin içine konamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousTypeInvalidInDeclaration">
        <source>Anonymous type variables are not permitted in this declaration</source>
        <target state="translated">Bu bildirimde anonim tür değişkenlerine izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSlashInType">
        <source>Unexpected / in type</source>
        <target state="translated">Türde beklenmeyen /</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedTypeArguments">
        <source>Unexpected type arguments</source>
        <target state="translated">Beklenmeyen tür bağımsız değişkenleri</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsOnlyOnMembers">
        <source>Optional arguments are only permitted on type members</source>
        <target state="translated">İsteğe bağlı bağımsız değişkenlere yalnızca tür üyelerinde izin verilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameNotBoundInPattern">
        <source>Name '{0}' not bound in pattern context</source>
        <target state="translated">'{0}' adı desen bağlamında bağlanmamış</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNonPrimitiveLiteralInPatternMatch">
        <source>Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when &lt;variable&gt; = &lt;constant&gt;' at the end of the match clause.</source>
        <target state="translated">Temel olmayan sayısal sabit değerler bir NumericLiteral kullanılarak birden çok farklı türle eşleştirilemediğinden desen eşleştirmelerinde kullanılamaz. Bunu bir değişkenle değiştirmeyi ve eşleşme yan tümcesinin sonunda 'when &lt;variable&gt; = &lt;constant&gt;' kullanmayı göz önünde bulundurun.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentUsage">
        <source>Type arguments cannot be specified here</source>
        <target state="translated">Tür bağımsız değişkenleri burada belirtilemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireActivePatternWithOneResult">
        <source>Only active patterns returning exactly one result may accept arguments</source>
        <target state="translated">Yalnızca tam olarak bir sonuç döndüren etkin desenler bağımsız değişken kabul edilebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidArgForParameterizedPattern">
        <source>Invalid argument to parameterized pattern label</source>
        <target state="translated">Parametreli desen etiketine geçersiz bağımsız değişken</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexIntoActivePatternArray">
        <source>Internal error. Invalid index into active pattern array</source>
        <target state="translated">İç hata. Etkin desen dizisi için geçersiz dizin</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseDoesNotTakeArguments">
        <source>This union case does not take arguments</source>
        <target state="translated">Bu birleşim durumu bağımsız değişken almaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseRequiresOneArgument">
        <source>This union case takes one argument</source>
        <target state="translated">Bu birleşim durumu bir bağımsız değişken alır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseExpectsTupledArguments">
        <source>This union case expects {0} arguments in tupled form</source>
        <target state="translated">Bu birleşim durumu grup olarak tanımlanmış biçimde {0} bağımsız değişken bekliyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotStatic">
        <source>Field '{0}' is not static</source>
        <target state="translated">'{0}' alanı statik değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNotLiteralCannotBeUsedInPattern">
        <source>This field is not a literal and cannot be used in a pattern</source>
        <target state="translated">Bu alan sabit değer olmadığından desende kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireVarConstRecogOrLiteral">
        <source>This is not a variable, constant, active recognizer or literal</source>
        <target state="translated">Bu bir değişkeni sabit, etkin tanıyıcı veya sabit değer değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPattern">
        <source>This is not a valid pattern</source>
        <target state="translated">Bu geçerli bir desen değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseWhenPatternGuard">
        <source>Character range matches have been removed in F#. Consider using a 'when' pattern guard instead.</source>
        <target state="translated">Karakter aralığı eşleştirmeler F# dilinde kaldırılmıştır. Onun yerine 'when' desen koruma kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalPattern">
        <source>Illegal pattern</source>
        <target state="translated">Geçersiz desen</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxErrorUnexpectedQMark">
        <source>Syntax error - unexpected '?' symbol</source>
        <target state="translated">Sözdizimi hatası - beklenmeyen '?' simgesi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionCountMisMatch">
        <source>Expected {0} expressions, got {1}</source>
        <target state="translated">{0} ifadeleri bekleniyordu, {1} alındı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExprUndelayed">
        <source>TcExprUndelayed: delayed</source>
        <target state="translated">TcExprUndelayed: gecikti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionRequiresSequence">
        <source>This expression form may only be used in sequence and computation expressions</source>
        <target state="translated">Bu ifade biçimi yalnızca dizi ve hesaplama ifadelerinde kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectExpressionSyntaxForm">
        <source>Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.</source>
        <target state="translated">Geçersiz nesne ifadesi. Geçersiz kılmaların ve arabirimlerin olmadığı nesneler küme ayraçsız 'new Type(args)' ifade biçimini kullanmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectSequenceOrRecordExpression">
        <source>Invalid object, sequence or record expression</source>
        <target state="translated">Geçersiz nesne, dizi veya kayıt ifadesi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSequenceExpressionSyntaxForm">
        <source>Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq {{ ... }}'</source>
        <target state="translated">Geçersiz kayıt, dizi veya hesaplama ifadesi. Dizi ifadeleri 'seq {{ ... }}' biçiminde olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionWithIfRequiresParenthesis">
        <source>This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression</source>
        <target state="translated">Liste veya dizi ifadesi 'if ... then ... else' biçiminde bir öğe içeriyor. Listenin veya dizinin bağımsız bir öğesi olduğunu belirtmek, dizi ifadesi kullanılarak oluşturulmuş listeden ayırt etmek için bu ifadeyi ayraç içine alın</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseFormatString">
        <source>Unable to parse format string '{0}'</source>
        <target state="translated">'{0}' biçim dizesi ayrıştırılamıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcListLiteralMaxSize">
        <source>This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.</source>
        <target state="translated">Bu liste ifadesi liste sabit değerlerinin en büyük boyutunu aşıyor. Daha büyük sabit değerler için dizi kullanın ve Array.ToList işlevini çağırın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresObjectConstructor">
        <source>The expression form 'expr then expr' may only be used as part of an explicit object constructor</source>
        <target state="translated">'expr then expr' ifade biçimi yalnızca açık nesne oluşturucunun parçası olarak kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentsCannotBeUsedInMemberTraits">
        <source>Named arguments cannot be given to member trait calls</source>
        <target state="translated">Adlandırılmış bağımsız değişkenler üye nitelik çağrılarına verilemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotValidEnumCaseName">
        <source>This is not a valid name for an enumeration case</source>
        <target state="translated">Bu, sabit listesi durumu olarak geçerli bir ad değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotMutable">
        <source>This field is not mutable</source>
        <target state="translated">Bu alan değiştirilebilir değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresListArrayOrSequence">
        <source>This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq {{ ... }}', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements</source>
        <target state="translated">Bu yapı, yalnızca liste, dizi ve sıra ifadeleri içinde (örn. 'seq {{ ... }}', '[ ... ]' veya '[| ... |]' biçimindeki ifadelerde) kullanılabilir. Bunlarda öğe oluşturmak için 'for ... in ... do ... yield...' söz dizimi kullanılır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpressions">
        <source>This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'.</source>
        <target state="translated">Bu yapı yalnızca hesaplama ifadeleri içinde kullanılabilir. Normal bir işlevden değer döndürmek için sadece ifadeyi 'return' olmadan yazın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresSequenceOrComputations">
        <source>This construct may only be used within sequence or computation expressions</source>
        <target state="translated">Bu yapı yalnızca dizi ve hesaplama ifadeleri içinde kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpression">
        <source>This construct may only be used within computation expressions</source>
        <target state="translated">Bu yapı yalnızca hesaplama ifadeleri içinde kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexerExpression">
        <source>Invalid indexer expression</source>
        <target state="translated">Geçersiz dizin erişimcisi ifadesi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
        <source>The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints</source>
        <target state="translated">Bu program noktasından önceki bilgiler temelinde 'expr.[idx]' işleci belirsiz türdeki bir nesnede kullanılmış. Başka tür kısıtlamaları eklemeyi düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromVariableType">
        <source>Cannot inherit from a variable type</source>
        <target state="translated">Değişken türünden devralınamıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsOnTypeParametersCannotTakeArguments">
        <source>Calls to object constructors on type parameters cannot be given arguments</source>
        <target state="translated">Tür parametrelerindeki nesne oluşturucu çağrılarına bağımsız değişken verilemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCompiledNameAttributeMisused">
        <source>The 'CompiledName' attribute cannot be used with this language element</source>
        <target state="translated">'CompiledName' özniteliği bu dil öğesiyle kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedTypeRequired">
        <source>'{0}' may only be used with named types</source>
        <target state="translated">'{0}' yalnızca adlandırılmış türlerle kullanılır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritCannotBeUsedOnInterfaceType">
        <source>'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead.</source>
        <target state="translated">Arabirim türlerinde 'inherit' kullanılamaz. Onun yerine arabirimi 'interface ... with ... end' kullanarak uygulamayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewCannotBeUsedOnInterfaceType">
        <source>'new' cannot be used on interface types. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">'new' arabirim türlerinde kullanılamaz. Bunun yerine bir nesne ifadesi '{{ new ... with ... }}' kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractTypeCannotBeInstantiated">
        <source>Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">Bu tür soyut olarak işaretlendiği veya metotlarının tümüne uygulama verilmediği için örnekleri oluşturulamaz. Onun yerine bir nesne ifadesi '{{ new ... with ... }}' kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIDisposableTypeShouldUseNew">
        <source>It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value</source>
        <target state="translated">Kaynakların oluşturulan değer tarafından sahiplenilebileceğini belirtmek için, IDisposable arabirimini destekleyen nesnelerin, oluşturucuyu temsil eden bir işlev değeri olarak 'Type(args)' veya 'Type' yerine 'new Type(args)' söz dizimi kullanılarak oluşturulması önerilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxCanOnlyBeUsedToCreateObjectTypes">
        <source>'{0}' may only be used to construct object types</source>
        <target state="translated">'{0}' yalnızca nesne türlerini oluşturmak için kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresCall">
        <source>Constructors for the type '{0}' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.</source>
        <target state="translated">'{0}' türünün oluşturucuları doğrudan veya dolaylı olarak kendi örtük nesne oluşturucusunu çağırmalıdır. Kayıt ifadesi yerine örtük nesne oluşturucusu çağrısını kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUndefinedField">
        <source>The field '{0}' has been given a value, but is not present in the type '{1}'</source>
        <target state="translated">{0}' alanına bir değer verilmiş ancak '{1}' türünde bu yok</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresAssignment">
        <source>No assignment given for field '{0}' of type '{1}'</source>
        <target state="translated">{1}' türündeki '{0}' alanı için bir atama verilmedi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExtraneousFieldsGivenValues">
        <source>Extraneous fields have been given values</source>
        <target state="translated">Dış alanlara değerler verilmiş</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
        <source>Only overrides of abstract and virtual members may be specified in object expressions</source>
        <target state="translated">Nesne ifadelerinde yalnızca soyut ve sanal üyelerin geçersiz kılmaları belirtilebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoAbstractOrVirtualMemberFound">
        <source>The member '{0}' does not correspond to any abstract or virtual method available to override or implement.</source>
        <target state="translated">'{0}' adlı üye, geçersiz kılma veya uygulama için kullanılabilen herhangi bir soyut veya sanal metoda karşılık gelmiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberFoundIsNotAbstractOrVirtual">
        <source>The type {0} contains the member '{1}' but it is not a virtual or abstract method that is available to override or implement.</source>
        <target state="translated">{0} türü, '{1}' üyesini içeriyor ancak bu, geçersiz kılma veya uygulama için kullanılabilen bir sanal veya soyut metot değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatch">
        <source>The member '{0}' does not accept the correct number of arguments. {1} argument(s) are expected, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">{0}' üyesine doğru sayıda bağımsız değişken geçirilmedi. {1} bağımsız değişken bekleniyor ancak geçerli sayı, {2}. Gerekli imza: '{3}'.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatchOneOverload">
        <source>The member '{0}' does not accept the correct number of arguments. One overload accepts {1} arguments, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">{0}' üyesine doğru sayıda bağımsız değişken geçirilmedi. Bir aşırı yükleme {1} bağımsız değişken kabul ediyor ancak geçerli sayı {2}. Gerekli imza: '{3}'.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSimpleMethodNameRequired">
        <source>A simple method name is required here</source>
        <target state="translated">Burada basit metot adı gereklidir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPredefinedTypeCannotBeUsedAsSuperType">
        <source>The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class</source>
        <target state="translated">System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate ve System.Array türleri bir nesne ifadesinde veya sınıfta üst tür olarak kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMustBeUsedWithNamedType">
        <source>'new' must be used with a named type</source>
        <target state="translated">'new' adlandırılmış türle kullanılmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCreateExtensionOfSealedType">
        <source>Cannot create an extension of a sealed type</source>
        <target state="translated">Mühürlü türün uzantısı oluşturulamıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoArgumentsForRecordValue">
        <source>No arguments may be given when constructing a record value</source>
        <target state="translated">Kayıt değeri oluşturulurken bir bağımsız değişken verilemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoInterfaceImplementationForConstructionExpression">
        <source>Interface implementations cannot be given on construction expressions</source>
        <target state="translated">Arabirim uygulamaları oluşturma ifadelerinde verilemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionCanOnlyBeUsedInClassTypes">
        <source>Object construction expressions may only be used to implement constructors in class types</source>
        <target state="translated">Nesne oluşturma ifadeleri yalnızca sınıf türlerinde oluşturucuları uygulamak için kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
        <source>Only simple bindings of the form 'id = expr' can be used in construction expressions</source>
        <target state="translated">Yalnızca 'id = expr' biçimindeki basit bağlamalar oluşturma ifadelerinde kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectsMustBeInitializedWithObjectExpression">
        <source>Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field</source>
        <target state="translated">Nesneler devralınan nesne oluşturucusunu çağıran ve her alana bir değer atayan bir nesne oluşturma ifadesi ile başlatılmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedInterfaceType">
        <source>Expected an interface type</source>
        <target state="translated">Arabirim türü bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorForInterfacesDoNotTakeArguments">
        <source>Constructor expressions for interfaces do not take arguments</source>
        <target state="translated">Arabirimlerin oluşturucu ifadeleri bağımsız değişken almaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresArguments">
        <source>This object constructor requires arguments</source>
        <target state="translated">Bu nesne oluşturucusu bağımsız değişken gerektirir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewRequiresObjectConstructor">
        <source>'new' may only be used with object constructors</source>
        <target state="translated">'new' yalnızca nesne oluşturucularla kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAtLeastOneOverrideIsInvalid">
        <source>At least one override did not correctly implement its corresponding abstract member</source>
        <target state="translated">En az bir geçersiz kılma işlemi kendisine karşılık gelen soyut üyeyi doğru uygulamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNumericLiteralRequiresModule">
        <source>This numeric literal requires that a module '{0}' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope</source>
        <target state="translated">Bu sayısal sabit değer FromZero, FromOne, FromInt32, FromInt64 ve FromString işlevlerini tanımlayan '{0}' modülünün kapsamda olmasını gerektirir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRecordConstruction">
        <source>Invalid record construction</source>
        <target state="translated">Geçersiz kayıt oluşturma</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresRecordTypes">
        <source>The expression form {{ expr with ... }} may only be used with record types. To build object types use {{ new Type(...) with ... }}</source>
        <target state="translated">{{ expr with ... }} ifade biçimi yalnızca kayıt türleriyle kullanılabilir. Nesne türleri oluşturmak için {{ new Type(...) with ... }} kullanın</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritedTypeIsNotObjectModelType">
        <source>The inherited type is not an object model type</source>
        <target state="translated">Devralınan tür bir nesne modeli türü değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
        <source>Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors</source>
        <target state="translated">Nesne oluşturma ifadeleri (yani devralma belirtimleri olan kayıt ifadeleri) yalnızca nesne modeli türlerinde oluşturucuları uygulamak için kullanılabilir. Nesne modeli türlerinin örneklerini oluşturucuların dışında oluşturmak için 'new ObjectType(args)' kullanın</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyRecordInvalid">
        <source>'{{ }}' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.</source>
        <target state="translated">'{{ }}' geçerli bir ifade değil. Kayıtlar en az bir alan içermelidir. Boş diziler Seq.empty veya boş liste '[]' kullanılarak belirtilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordTypeNeedConstructor">
        <source>This type is not a record type. Values of class and struct types must be created using calls to object constructors.</source>
        <target state="translated">Bu tür bir kayıt türü değil. Nesne oluşturucularına yapılan çağrılar kullanılarak sınıf ve yapı türlerinin değerlerinin oluşturulması gerekiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordType">
        <source>This type is not a record type</source>
        <target state="translated">Bu tür bir kayıt türü değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInComputationExpression">
        <source>This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder {{ ... }}'.</source>
        <target state="translated">Bu yapı, bir hesaplama ifadesinin parçası olarak belirsiz. İç içe ifadeler 'let _ = (...)' kullanılarak ve iç içe hesaplamalar 'let! res = builder {{ ... }}' kullanılarak yazılabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInSequenceExpression">
        <source>This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {{... }}'.</source>
        <target state="translated">Bu yapı, bir dizi ifadesinin parçası olarak belirsiz. İç içe ifadeler 'let _ = (...)' kullanılarak ve iç içe diziler 'yield! seq {{... }}' kullanılarak yazılabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoBangIllegalInSequenceExpression">
        <source>'do!' cannot be used within sequence expressions</source>
        <target state="translated">'do!' dizi ifadeleri içinde kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseForInSequenceExpression">
        <source>The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead.</source>
        <target state="translated">Dizi ifadelerinde 'let! x = coll' kullanımına izin verilmez. Onun yerine 'for x in coll' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryIllegalInSequenceExpression">
        <source>'try'/'with' cannot be used within sequence expressions</source>
        <target state="translated">Dizi ifadeleri içinde 'try'/'with' kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseYieldBangForMultipleResults">
        <source>In sequence expressions, multiple results are generated using 'yield!'</source>
        <target state="translated">Dizi ifadelerinde, 'yield!' kullanılarak birden çok sonuç oluşturulur</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAssignment">
        <source>Invalid assignment</source>
        <target state="translated">Geçersiz atama</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfTypeName">
        <source>Invalid use of a type name</source>
        <target state="translated">Geçersiz tür adı kullanımı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoAccessibleConstructor">
        <source>This type has no accessible object constructors</source>
        <target state="translated">Bu türün erişilebilir bir nesne oluşturucusu yok</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfInterfaceType">
        <source>Invalid use of an interface type</source>
        <target state="translated">Geçersiz arabirim türü kullanımı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfDelegate">
        <source>Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'.</source>
        <target state="translated">Geçersiz temsilci oluşturucu kullanımı. 'new Type(args)' sözdizimini kullanın veya yalnızca 'Type(args)' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotStatic">
        <source>Property '{0}' is not static</source>
        <target state="translated">'{0}' özelliği statik değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotReadable">
        <source>Property '{0}' is not readable</source>
        <target state="translated">'{0}' özelliği okunamıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLookupMayNotBeUsedHere">
        <source>This lookup cannot be used here</source>
        <target state="translated">Bu arama burada kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsStatic">
        <source>Property '{0}' is static</source>
        <target state="translated">'{0}' özelliği statik</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet1">
        <source>Property '{0}' cannot be set</source>
        <target state="translated">'{0}' özelliği ayarlanamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsCannotBeFirstClassValues">
        <source>Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</source>
        <target state="translated">Oluşturucular bağımsız değişkenlere uygulanmalıdır ve birinci sınıf değerler olarak kullanılamaz. Gerekirse anonim bir işlev '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
        <source>The syntax 'expr.id' may only be used with record labels, properties and fields</source>
        <target state="translated">'expr.id' sözdizimi yalnızca kayıt etiketleri, özellikler ve alanlarla kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsStatic">
        <source>Event '{0}' is static</source>
        <target state="translated">'{0}' olayı statik</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsNotStatic">
        <source>Event '{0}' is not static</source>
        <target state="translated">'{0}' olayı statik değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentDidNotMatch">
        <source>The named argument '{0}' did not match any argument or mutable property</source>
        <target state="translated">'{0}' adlandırılmış bağımsız değişkeni herhangi bir bağımsız değişkenle veya değişebilir özelliğiyle eşleşmedi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverloadsCannotHaveCurriedArguments">
        <source>One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.</source>
        <target state="translated">Bu metodun bir veya daha fazla aşırı yüklemesinde eksiltimli bağımsız değişkenler var. Bu üyeleri grup olarak tanımlanmış biçimde bağımsız değişkenler alacak şekilde yeniden tasarlamayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnnamedArgumentsDoNotFormPrefix">
        <source>The unnamed arguments do not form a prefix of the arguments of the method called</source>
        <target state="translated">Adlandırılmamış bağımsız değişkenler çağrılan metodun bağımsız değişkenlerinin ön ekini oluşturmaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
        <source>Static optimization conditionals are only for use within the F# library</source>
        <target state="translated">Statik iyileştirme koşulları yalnızca F# kitaplığı içinde kullanım içindir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFormalArgumentIsNotOptional">
        <source>The corresponding formal argument is not optional</source>
        <target state="translated">Karşılık gelen biçimsel bağımsız değişken isteğe bağlı değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOptionalAssignmentToPropertyOrField">
        <source>Invalid optional assignment to a property or field</source>
        <target state="translated">Özelliğe veya alana geçersiz isteğe bağlı atama</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegateConstructorMustBePassed">
        <source>A delegate constructor must be passed a single function value</source>
        <target state="translated">Temsilci oluşturucuya tek bir işlev değeri geçirilmesi gerekiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindingCannotBeUseAndRec">
        <source>A binding cannot be marked both 'use' and 'rec'</source>
        <target state="translated">Bir bağlama hem 'use' hem de 'rec' olarak işaretlenemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileOnlyOnClassLetBindings">
        <source>The 'VolatileField' attribute may only be used on 'let' bindings in classes</source>
        <target state="translated">'VolatileField' özniteliği yalnızca sınıflardaki 'let' bağlamalarında kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesAreNotPermittedOnLetBindings">
        <source>Attributes are not permitted on 'let' bindings in expressions</source>
        <target state="translated">İfadelerdeki 'let' bağlamalarında özniteliğe izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultValueAttributeRequiresVal">
        <source>The 'DefaultValue' attribute may only be used on 'val' declarations</source>
        <target state="translated">'DefaultValue' özniteliği yalnızca 'val' bildirimlerinde kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeRequiresMembers">
        <source>The 'ConditionalAttribute' attribute may only be used on members</source>
        <target state="translated">'ConditionalAttribute' özniteliği yalnızca üyelerde kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidActivePatternName">
        <source>This is not a valid name for an active pattern</source>
        <target state="translated">Etkin desen için bu geçerli bir ad değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEntryPointAttributeRequiresFunctionInModule">
        <source>The 'EntryPointAttribute' attribute may only be used on function definitions in modules</source>
        <target state="translated">'EntryPointAttribute' özniteliği yalnızca modüllerdeki işlev tanımlarında kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesCannotBeInline">
        <source>Mutable values cannot be marked 'inline'</source>
        <target state="translated">Değişebilir değerler 'inline' olarak işaretlenemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesMayNotHaveGenericParameters">
        <source>Mutable values cannot have generic parameters</source>
        <target state="translated">Değişebilir değerlerin genel parametreleri olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesSyntax">
        <source>Mutable function values should be written 'let mutable f = (fun args -&gt; ...)'</source>
        <target state="translated">Değiştirilebilir işlev değerleri şu şekilde yazılmalıdır: 'let mutable f = (fun args -&gt; ...)'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyFunctionsCanBeInline">
        <source>Only functions may be marked 'inline'</source>
        <target state="translated">Yalnızca işlevler 'inline' olarak işaretlenebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalAttributesForLiteral">
        <source>A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes</source>
        <target state="translated">Sabit bir değere [&lt;ThreadStatic&gt;] veya [&lt;ContextStatic&gt;] öznitelikleri verilemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeMutable">
        <source>A literal value cannot be marked 'mutable'</source>
        <target state="translated">Sabit değer 'mutable' olarak işaretlenemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeInline">
        <source>A literal value cannot be marked 'inline'</source>
        <target state="translated">Sabit değer 'inline' olarak işaretlenemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotHaveGenericParameters">
        <source>Literal values cannot have generic parameters</source>
        <target state="translated">Sabit değerlerin genel parametreleri olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstantExpression">
        <source>This is not a valid constant expression</source>
        <target state="translated">Bu geçerli bir sabit ifade değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsInaccessible">
        <source>This type is not accessible from this code location</source>
        <target state="translated">Bu türe bu kod konumundan erişilemiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConditionInImportedAssembly">
        <source>Unexpected condition in imported assembly: failed to decode AttributeUsage attribute</source>
        <target state="translated">İçeri aktarılan bütünleştirilmiş kodda beklenmeyen koşul: AttributeUsage özniteliğinin kodu çözülemedi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedAttributeTarget">
        <source>Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</source>
        <target state="translated">Tanınmayan öznitelik hedefi. Geçerli öznitelik hedefleri şunlardır: 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElementUseDo">
        <source>This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module.</source>
        <target state="translated">Bu öznitelik, bu dil öğesinde kullanılmak için geçerli değil. Bütünleştirilmiş kod öznitelikleri, bir 'do ()' bildirimine, gerekirse F# modülü içine iliştirilmelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElement">
        <source>This attribute is not valid for use on this language element</source>
        <target state="translated">Bu öznitelik, bu dil öğesinde kullanılmak için geçerli değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgumentsCannotBeUsedInCustomAttribute">
        <source>Optional arguments cannot be used in custom attributes</source>
        <target state="translated">İsteğe bağlı bağımsız değişkenler özel özniteliklerde kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet0">
        <source>This property cannot be set</source>
        <target state="translated">Bu özellik ayarlanamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyOrFieldNotFoundInAttribute">
        <source>This property or field was not found on this custom attribute type</source>
        <target state="translated">Bu özellik veya alan bu özel öznitelik türünde bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustBeReferenceType">
        <source>A custom attribute must be a reference type</source>
        <target state="translated">Özel öznitelik başvuru türünde olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeArgumentMismatch">
        <source>The number of args for a custom attribute does not match the expected number of args for the attribute constructor</source>
        <target state="translated">Özel bir özniteliğin bağımsız değişken sayısı öznitelik oluşturucusunun beklenen bağımsız değişken sayısı ile eşleşmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustInvokeConstructor">
        <source>A custom attribute must invoke an object constructor</source>
        <target state="translated">Özel öznitelik nesne oluşturucusunu çağırmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeExpressionsMustBeConstructorCalls">
        <source>Attribute expressions must be calls to object constructors</source>
        <target state="translated">Öznitelik ifadeleri nesne oluşturucu çağrısı olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedAttribute">
        <source>This attribute cannot be used in this version of F#</source>
        <target state="translated">Bu öznitelik F# dilinin bu sürümünde kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidInlineSpecification">
        <source>Invalid inline specification</source>
        <target state="translated">Geçersiz satır içi belirtim</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBinding">
        <source>'use' bindings must be of the form 'use &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">'use' bağlamaları 'use &lt;var&gt; = &lt;expr&gt;' biçiminde olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractMembersIllegalInAugmentation">
        <source>Abstract members are not permitted in an augmentation - they must be defined as part of the type itself</source>
        <target state="translated">Genişletmede soyut üyelere izin verilmez; bunlar türün kendi parçası olarak tanımlanmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodOverridesIllegalHere">
        <source>Method overrides and interface implementations are not permitted here</source>
        <target state="translated">Burada metot geçersiz kılmalara ve arabirim uygulamalarına izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoMemberFoundForOverride">
        <source>No abstract or interface member was found that corresponds to this override</source>
        <target state="translated">Bu geçersiz kılmaya karşılık gelen bir soyut üye veya arabirim üyesi bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverrideArityMismatch">
        <source>This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:{0}</source>
        <target state="translated">Bu geçersiz kılma, karşılık gelen soyut üyeden farklı sayıda bağımsız değişken alıyor. Şu soyut üyeler bulundu: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationAlreadyExists">
        <source>This method already has a default implementation</source>
        <target state="translated">Bu metodun zaten varsayılan uygulaması var</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultAmbiguous">
        <source>The method implemented by this default is ambiguous</source>
        <target state="translated">Bu varsayılan tarafından uygulanan metot belirsiz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoPropertyFoundForOverride">
        <source>No abstract property was found that corresponds to this override</source>
        <target state="translated">Bu geçersiz kılmaya karşılık gelen bir soyut özellik bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractPropertyMissingGetOrSet">
        <source>This property overrides or implements an abstract property but the abstract property doesn't have a corresponding {0}</source>
        <target state="translated">Bu özellik, soyut bir özelliği geçersiz kılıyor veya uyguluyor ancak bu soyut özelliğe karşılık gelen bir {0} yok</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSignatureForSet">
        <source>Invalid signature for set member</source>
        <target state="translated">Küme üyesi için geçersiz imza</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMember">
        <source>This new member hides the abstract member '{0}'. Rename the member or use 'override' instead.</source>
        <target state="translated">Bu yeni üye, '{0}' soyut üyesini gizliyor. Üyeyi yeniden adlandırın veya bunun yerine 'override' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMemberWithSuffix">
        <source>This new member hides the abstract member '{0}' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead.</source>
        <target state="translated">Demetler, işlevler, ölçü birimleri ve/veya sağlanan türler silindikten sonra bu yeni üye, '{0}' soyut üyesini gizliyor. Üyeyi yeniden adlandırın veya bunun yerine 'override' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializersIllegalInInterface">
        <source>Interfaces cannot contain definitions of static initializers</source>
        <target state="translated">Arabirimler statik başlatıcı tanımları içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsIllegalInInterface">
        <source>Interfaces cannot contain definitions of object constructors</source>
        <target state="translated">Arabirimler nesne oluşturucularının tanımlarını içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOverridesIllegalInInterface">
        <source>Interfaces cannot contain definitions of member overrides</source>
        <target state="translated">Arabirimler üye geçersiz kılma tanımları içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConcreteMembersIllegalInInterface">
        <source>Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.</source>
        <target state="translated">Arabirimler somut üyelerin tanımlarını içeremez. Türün sınıf olduğunu belirtmek için türünüzde bir oluşturucu tanımlamanız gerekebilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsDisallowedInExceptionAugmentation">
        <source>Constructors cannot be specified in exception augmentations</source>
        <target state="translated">Oluşturucular özel durum genişletmelerinde belirtilemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCannotHaveConstructorWithNoArguments">
        <source>Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.</source>
        <target state="translated">Yapıların bağımsız değişkensiz nesne oluşturucusu olamaz. Yapılar varsayılan oluşturucuyu otomatik olarak desteklediği için bu, tüm CLI dillerine getirilen bir kısıtlamadır.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalForThisType">
        <source>Constructors cannot be defined for this type</source>
        <target state="translated">Oluşturucular bu tür için tanımlanamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
        <source>Recursive bindings that include member specifications can only occur as a direct augmentation of a type</source>
        <target state="translated">Üye belirtimleri içeren özyinelemeli bağlamalar yalnızca türün doğrudan genişletmesi olarak oluşabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimplePatternsInLetRec">
        <source>Only simple variable patterns can be bound in 'let rec' constructs</source>
        <target state="translated">'let rec' yapılarında yalnızca basit değişken desenleri bağlanabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
        <source>Mutable 'let' bindings can't be recursive or defined in recursive modules or namespaces</source>
        <target state="translated">Değişebilir 'let' bağlamaları özyinelemeli olamaz veya özyinelemeli modüllerde ya da ad alanlarında tanımlanamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberIsNotSufficientlyGeneric">
        <source>This member is not sufficiently generic</source>
        <target state="translated">Bu üye yeterince genel değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralAttributeRequiresConstantValue">
        <source>A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. 'val x : int = 1'</source>
        <target state="translated">Bir sabit değer de sağlanmışsa bildirim yalnızca [&lt;Literal&gt;] özniteliği olabilir, ör. 'val x : int = 1'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcValueInSignatureRequiresLiteralAttribute">
        <source>A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute</source>
        <target state="translated">Bir bildirime yalnızca bildirim [&lt;Literal&gt;] özniteliğine sahipse bir imzada değer verilebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThreadStaticAndContextStaticMustBeStatic">
        <source>Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread</source>
        <target state="translated">Thread-static ve context-static değişkenleri statik olmalı ve değerin her yeni iş parçacığında varsayılan değer olarak başlatıldığının gösterilmesi için bunlara [&lt;DefaultValue&gt;] özniteliği verilmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileFieldsMustBeMutable">
        <source>Volatile fields must be marked 'mutable' and cannot be thread-static</source>
        <target state="translated">Geçici alanlar 'mutable' olarak işaretlenmelidir ve bunlar statik iş parçacıklı olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUninitializedValFieldsMustBeMutable">
        <source>Uninitialized 'val' fields must be mutable and marked with the '[&lt;DefaultValue&gt;]' attribute. Consider using a 'let' binding instead of a 'val' field.</source>
        <target state="translated">Başlatılmamış 'val' alanları değiştirilebilir olmalı ve '[&lt;DefaultValue&gt;]' özniteliğiyle işaretlenmelidir. Bir 'val' alanı yerine 'let' kullanmayı göz önünde bulundurun.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticValFieldsMustBeMutableAndPrivate">
        <source>Static 'val' fields in types must be mutable, private and marked with the '[&lt;DefaultValue&gt;]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type.</source>
        <target state="translated">Türlerdeki statik 'val' alanları değiştirilebilir, özel olmalı ve '[&lt;DefaultValue&gt;]' özniteliğiyle işaretlenmelidir. Bunlar türleri için 'null' veya 'zero' değerine başlatılır. Bir sınıf türünde 'static let mutable' bağlamasını kullanmayı da göz önünde bulundurun.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresName">
        <source>This field requires a name</source>
        <target state="translated">Bu alan için ad gerekiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNamespaceModuleTypeUnionName">
        <source>Invalid namespace, module, type or union case name</source>
        <target state="translated">Geçersiz ad alanı, modül, tür veya birleşim durumu adı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalFormForExplicitTypeDeclaration">
        <source>Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -&gt; resTy'. Parentheses may be required around 'resTy'</source>
        <target state="translated">Oluşturuculara yönelik açık tür bildirimleri 'ty1 * ... * tyN -&gt; resTy' biçiminde olmalıdır. 'resTy' ifadesinin parantez içine alınması gerekebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnTypesForUnionMustBeSameAsType">
        <source>Return types of union cases must be identical to the type being defined, up to abbreviations</source>
        <target state="translated">Birleşim durumlarının dönüş türleri tanımlanmakta olan türle kısaltmalara kadar özdeş olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumerationLiteral">
        <source>This is not a valid value for an enumeration literal</source>
        <target state="translated">Bu, sabit listesi değeri olarak geçerli bir değer değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType1">
        <source>The type '{0}' is not an interface type</source>
        <target state="translated">'{0}' türü bir arabirim türü değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDuplicateSpecOfInterface">
        <source>Duplicate specification of an interface</source>
        <target state="translated">Yinelenen arabirim belirtimi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldValIllegalHere">
        <source>A field/val declaration is not permitted here</source>
        <target state="translated">Alan/değer bildirimine burada izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritIllegalHere">
        <source>A inheritance declaration is not permitted here</source>
        <target state="translated">Devralma bildirimine burada izin verilmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleRequiresQualifiedAccess">
        <source>This declaration opens the module '{0}', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.</source>
        <target state="translated">Bu bildirim, 'RequireQualifiedAccess' olarak işaretlenmiş '{0}' modülünü açar. Bunun yerine, kodunuzu modülün öğelerine yapılan nitelikli başvuruları kullanacak şekilde ayarlayın, örn. 'map' yerine 'List.map'. Bu değişiklik, kitaplıklara yeni yapılar eklendikçe kodunuzun sağlam kalmasını sağlar.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenUsedWithPartiallyQualifiedPath">
        <source>This declaration opens the namespace or module '{0}' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.</source>
        <target state="translated">Bu bildirim, ad alanını veya '{0}' modülünü kısmen nitelenmiş yol aracılığıyla açıyor. Bu kodu, ad alanının tam yolunu kullanacak şekilde ayarlayın. Bu değişiklik, F# ve CLI kitaplıklarına yeni yapılar eklendikçe kodunuzun daha sağlam kılar.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLocalClassBindingsCannotBeInline">
        <source>Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.</source>
        <target state="translated">Yerel sınıf bağlamaları satır içi olarak işaretlenemez. Tanımı sınıftan çıkarmayı düşünün veya satır içi olarak işaretlemeyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsMayNotHaveMembers">
        <source>Type abbreviations cannot have members</source>
        <target state="translated">Tür kısaltmalarının üyeleri olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCheckedAtCompileTime">
        <source>As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.</source>
        <target state="translated">F# 4.1 ve sonrasında tür kısaltmalarının erişilebilirliği, derleme zamanında denetlenmektedir. Tür kısaltmasının erişilebilirliğini değiştirmeniz önerilir. Bu uyarıyı yoksaymak, çalışma zamanı hatalarına neden olabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsMayNotHaveMembers">
        <source>Enumerations cannot have members</source>
        <target state="translated">Sabit listelerinde üyeler olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembers">
        <source>Measure declarations may have only static members</source>
        <target state="translated">Ölçü bildirimlerinin yalnızca statik üyeleri olabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainDoBindings">
        <source>Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings</source>
        <target state="translated">Yapıların varsayılan oluşturucusu 'do' bağlamalarını yürütmeyeceği için yapılar bu bağlamaları içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainLetBindings">
        <source>Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.</source>
        <target state="translated">Yapıların varsayılan oluşturucusu bu bağlamaları yürütmeyeceği için yapılar değer tanımlarını içeremez. Türün birincil oluşturucusuna ek bağımsız değişkenler eklemeyi düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticLetBindingsRequireClassesWithImplicitConstructors">
        <source>Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Statik değer tanımları yalnızca birincil oluşturucusu olan türlerde kullanılabilir. Tür tanımına bağımsız değişkenler eklemeyi düşünün, örn. 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembersNotConstructors">
        <source>Measure declarations may have only static members: constructors are not available</source>
        <target state="translated">Ölçü bildirimlerinin yalnızca statik üyeleri olabilir: oluşturucular kullanılmaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberAndLocalClassBindingHaveSameName">
        <source>A member and a local class binding both have the name '{0}'</source>
        <target state="translated">Hem üyenin hem de yerel sınıf bağlamasının adı '{0}' olabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
        <source>Type abbreviations cannot have interface declarations</source>
        <target state="translated">Tür kısaltmalarının arabirim bildirimleri olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsCannotHaveInterfaceDeclaration">
        <source>Enumerations cannot have interface declarations</source>
        <target state="translated">Sabit listelerinde arabirim bildirimleri olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType0">
        <source>This type is not an interface type</source>
        <target state="translated">Bu tür bir arabirim türü değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllImplementedInterfacesShouldBeDeclared">
        <source>All implemented interfaces should be declared on the initial declaration of the type</source>
        <target state="translated">Türün ilk bildiriminde tüm uygulanan arabirimler tanımlanmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
        <source>A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type</source>
        <target state="translated">Bu arabirimin açık olarak uygulanması türün tanımında belirtilmediği için arabirimin varsayılan uygulaması zaten eklendi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberNotPermittedInInterfaceImplementation">
        <source>This member is not permitted in an interface implementation</source>
        <target state="translated">Arabirim uygulamasında bu üyeye izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclarationElementNotPermittedInAugmentation">
        <source>This declaration element is not permitted in an augmentation</source>
        <target state="translated">Bir genişletmede bu tanımlama öğesine izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotContainNestedTypes">
        <source>Types cannot contain nested type definitions</source>
        <target state="translated">Türler iç içe tür tanımları içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeExceptionOrModule">
        <source>type, exception or module</source>
        <target state="translated">tür, özel durum veya modül</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeOrModule">
        <source>type or module</source>
        <target state="translated">tür veya modül</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type.</source>
        <target state="translated">Yapı, kayıt veya birleşim türü '{0}', 'System.IStructuralEquatable' arabirimini açık olarak uyguluyor. Türe 'CustomEquality' özniteliğini uygulayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IEquatable&lt;_&gt;' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'.</source>
        <target state="translated">Yapı, kayıt veya birleşim türü '{0}', 'System.IEquatable&lt;_&gt;' arabirimini açıkça uyguluyor. Türe 'CustomEquality' özniteliğini uygulayın ve genel olmayan 'System.Object.Equals(obj)' geçersiz kılmasının tutarlı bir uygulamasını sağlayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
        <source>Explicit type specifications cannot be used for exception constructors</source>
        <target state="translated">Açık tür belirtimleri özel durum oluşturucuları için kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsShouldNotHaveArgumentList">
        <source>Exception abbreviations should not have argument lists</source>
        <target state="translated">Özel durum kısaltmalarının bağımsız değişken listeleri olmamalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
        <source>Abbreviations for Common IL exceptions cannot take arguments</source>
        <target state="translated">Ortak Ara Dil özel durumlarının kısaltmaları bağımsız değişken alamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsMustReferToValidExceptions">
        <source>Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception</source>
        <target state="translated">Özel durum kısaltmaları mevcut özel durumlara veya System.Exception'dan türeyen F# türlerine başvurmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
        <source>Abbreviations for Common IL exception types must have a matching object constructor</source>
        <target state="translated">Ortak Ara Dil özel durum türlerinin kısaltmalarının kendileriyle eşleşen nesne oluşturucuları olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotAnException">
        <source>Not an exception</source>
        <target state="translated">Özel durum değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidModuleName">
        <source>Invalid module name</source>
        <target state="translated">Geçersiz modül adı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeExtension">
        <source>Invalid type extension</source>
        <target state="translated">Geçersiz tür uzantısı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesOfTypeSpecifyMultipleKindsForType">
        <source>The attributes of this type specify multiple kinds for the type</source>
        <target state="translated">Bu tür öznitelikler türün birden çok çeşidini belirtir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcKindOfTypeSpecifiedDoesNotMatchDefinition">
        <source>The kind of the type specified by its attributes does not match the kind implied by its definition</source>
        <target state="translated">Öznitelikleriyle belirtilen türün çeşidi tanımıyla kastedilen çeşitle eşleşmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDefinitionsCannotHaveTypeParameters">
        <source>Measure definitions cannot have type parameters</source>
        <target state="translated">Ölçü tanımlarının tür parametreleri olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeRequiresDefinition">
        <source>This type requires a definition</source>
        <target state="translated">Bu tür için tanım gerekiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationHasTypeParametersMissingOnType">
        <source>This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C&lt;'a&gt; = C of ...'.</source>
        <target state="translated">Bu tür kısaltması, kısaltılan türde görünmeyen bir veya daha fazla bildirilen tür parametresine sahip. Tür kısaltmaları, kısaltılan türdeki tüm bildirilen tür parametrelerini kullanılmalıdır. Bir veya daha fazla tür parametresini kaldırmayı ya da temel bir türü sarmalayan 'type C&lt;'a&gt; = C of ...' gibi somut bir tür kullanmayı göz önünde bulundurun.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
        <source>Structs, interfaces, enums and delegates cannot inherit from other types</source>
        <target state="translated">Yapılar, arabirimler, sabit listeleri ve temsilciler diğer türlerden devralamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotInheritFromMultipleConcreteTypes">
        <source>Types cannot inherit from multiple concrete types</source>
        <target state="translated">Türler birden çok somut türden devralamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
        <source>Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute</source>
        <target state="translated">Kayıtlar, birleşim, kısaltmalar ve yapı türlerinin 'AllowNullLiteral' özniteliği olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
        <source>Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal</source>
        <target state="translated">'AllowNullLiteral' özniteliğine sahip türler yalnızca null sabit değerinin kullanılmasına da izin veren türlerden devralabilir veya böyle türleri uygulayabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericTypesCannotHaveStructLayout">
        <source>Generic types cannot be given the 'StructLayout' attribute</source>
        <target state="translated">Genel türlere 'StructLayout' özniteliği verilemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyStructsCanHaveStructLayout">
        <source>Only structs and classes without primary constructors may be given the 'StructLayout' attribute</source>
        <target state="translated">Yalnızca birincil oluşturucuları olmayan yapılara ve sınıflara 'StructLayout' özniteliği verilebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRepresentationOfTypeHiddenBySignature">
        <source>The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.</source>
        <target state="translated">Bu türün temsili imza tarafından gizlenmiş. Türün özelliklerinin belirtilmesi için türe [&lt;Sealed&gt;], [&lt;Class&gt;] veya [&lt;Interface&gt;] gibi bir öznitelik verilmelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyClassesCanHaveAbstract">
        <source>Only classes may be given the 'AbstractClass' attribute</source>
        <target state="translated">'AbstractClass' özniteliği yalnızca sınıflara verilebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
        <source>Only types representing units-of-measure may be given the 'Measure' attribute</source>
        <target state="translated">Yalnızca ölçü birimlerini temsil eden türlere 'Measure' özniteliği verilebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on overrides or interface implementations</source>
        <target state="translated">Geçersiz kılmalarda veya arabirim uygulamalarında erişilebilirlik değiştiricilerine izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDU">
        <source>Discriminated union types are always sealed</source>
        <target state="translated">Ayırt edici birleşim türleri her zaman mühürlüdür</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedRecord">
        <source>Record types are always sealed</source>
        <target state="translated">Kayıt türleri her zaman mühürlüdür</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedAssemblyCode">
        <source>Assembly code types are always sealed</source>
        <target state="translated">Bütünleştirilmiş kod türleri her zaman mühürlüdür</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedStruct">
        <source>Struct types are always sealed</source>
        <target state="translated">Yapı türleri her zaman mühürlüdür</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDelegate">
        <source>Delegate types are always sealed</source>
        <target state="translated">Temsilci türleri her zaman mühürlüdür</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedEnum">
        <source>Enum types are always sealed</source>
        <target state="translated">Sabit listesi türleri her zaman mühürlüdür</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesAndDelegatesCannotContainFields">
        <source>Interface types and delegate types cannot contain fields</source>
        <target state="translated">Arabirim türleri ve temsilci türleri alan içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviatedTypesCannotBeSealed">
        <source>Abbreviated types cannot be given the 'Sealed' attribute</source>
        <target state="translated">Kısaltılmış türlere 'Sealed' özniteliği verilemez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromSealedType">
        <source>Cannot inherit a sealed type</source>
        <target state="translated">Mühürlü tür devralınamıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromInterfaceType">
        <source>Cannot inherit from interface type. Use interface ... with instead.</source>
        <target state="translated">Arabirim türünden devralınamıyor. Onun yerine interface ... with kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructTypesCannotContainAbstractMembers">
        <source>Struct types cannot contain abstract members</source>
        <target state="translated">Struct türleri soyut üyeler içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesCannotBeSealed">
        <source>Interface types cannot be sealed</source>
        <target state="translated">Arabirim türleri mühürlü olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDelegateSpecification">
        <source>Delegate specifications must be of the form 'typ -&gt; typ'</source>
        <target state="translated">Temsilci belirtimleri 'typ -&gt; typ' biçiminde olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegatesCannotBeCurried">
        <source>Delegate specifications must not be curried types. Use 'typ * ... * typ -&gt; typ' for multi-argument delegates, and 'typ -&gt; (typ -&gt; typ)' for delegates returning function values.</source>
        <target state="translated">Temsilci belirtimleri Curry biçimli türler olmamalıdır. Birden çok bağımsız değişken temsilcisi için 'typ * ... * typ -&gt; typ', işlev değerleri döndüren temsilciler için 'typ -&gt; (typ -&gt; typ)' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForLiteralEnumeration">
        <source>Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char</source>
        <target state="translated">Sabit değer listelerinde int, uint, int16, uint16, int64, uint64, byte, sbyte veya char türü olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclic">
        <source>This type definition involves an immediate cyclic reference through an abbreviation</source>
        <target state="translated">Bu tür tanımı, kısaltma aracılığıyla anlık döngüsel başvuru içeriyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclicThroughInheritance">
        <source>This type definition involves an immediate cyclic reference through a struct field or inheritance relation</source>
        <target state="translated">Bu tür tanımı, yapı alanı veya devralma ilişkisi aracılığıyla anlık döngüsel başvuru içeriyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReservedSyntaxForAugmentation">
        <source>The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[&lt;Sealed&gt;] attribute to the type definition in the signature</source>
        <target state="translated">'type X with ...' söz dizimi genişletmelere ayrılmıştır. Temsilleri gizli olan ancak üyeleri olan türler artık imzada 'type X = ...' kullanılarak bildirilir. İmzada tür tanımına '[&lt;Sealed&gt;] özniteliğini de eklemeniz gerekebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
        <source>Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.</source>
        <target state="translated">Arabirim, temsilci veya sabit listesi türlerini genişleten üyeler türün tanımından ayrı bir modüle yerleştirilmelidir. Bu modülün ya AutoOpen özniteliği olmalıdır ya da uzantı üyelerini kapsama çıkarmak için istemci kodu aracılığıyla açık olarak açılmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal">
        <source>One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '{0}'</source>
        <target state="translated">Bu tür uzantısı için bildirilen tür parametrelerinden bir veya daha fazlası, '{0}' üzerindeki özgün tür tür kısıtlamaları ile eşleşmeyen eksik veya yanlış bir tür kısıtlaması içeriyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
        <source>Type definitions may only have one 'inherit' specification and it must be the first declaration</source>
        <target state="translated">Tür tanımlarının yalnızca bir 'inherit' belirtimi olabilir ve bu ilk bildirim olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
        <source>'let' and 'do' bindings must come before member and interface definitions in type definitions</source>
        <target state="translated">'let' ve 'do' bağlamaları tür tanımlarında üye ve arabirim tanımlarından önce gelmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritDeclarationMissingArguments">
        <source>This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'.</source>
        <target state="translated">Bu 'inherit' bildirimi devralınan türü belirtiyor ancak hiç bağımsız değişken yok. Bağımsız değişkenleri sağlamayı düşünün, örn. 'inherit BaseType(args)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritConstructionCallNotPartOfImplicitSequence">
        <source>This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Bu 'inherit' bildiriminin bağımsız değişkenleri var, ancak birincil oluşturucuya sahip bir türde bulunmuyor. Tür tanımınıza bağımsız değişkenler eklemeyi düşünün, örn. 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLetAndDoRequiresImplicitConstructionSequence">
        <source>This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Bu tanım yalnızca birincil oluşturucusu olan bir türde kullanılabilir. Tür tanımınıza bağımsız değişkenler eklemeyi düşünün, örn. 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveAugmentations">
        <source>Type abbreviations cannot have augmentations</source>
        <target state="translated">Tür kısaltmalarının genişletmeleri olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbreviationForNamespace">
        <source>The path '{0}' is a namespace. A module abbreviation may not abbreviate a namespace.</source>
        <target state="translated">'{0}' yolu bir ad alanı. Modül kısaltması bir ad alanını kısaltamaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeUsedInInvalidWay">
        <source>The type '{0}' is used in an invalid way. A value prior to '{1}' has an inferred type involving '{2}', which is an invalid forward reference.</source>
        <target state="translated">{0}' türü geçersiz biçimde kullanılmış. '{1}' öğesinden önceki bir değer '{2}' içeren çıkarılmış türüne sahip, bu geçersiz bir ileriye doğru başvurudur.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to the definition of '{2}', which is an invalid forward reference.</source>
        <target state="translated">{0}' üyesi geçersiz bir biçimde kullanılmış. '{1}' kullanımı, '{2}' tanımından önce çıkarılmış, bu geçersiz bir ileriye doğru başvurudur.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeAutoOpenWasIgnored">
        <source>The attribute 'AutoOpen(\"{0}\")' in the assembly '{1}' did not refer to a valid module or namespace in that assembly and has been ignored</source>
        <target state="translated">{1}' bütünleştirilmiş kodundaki 'AutoOpen(\"{0}\")' özniteliği bu bütünleştirilmiş koddaki geçerli bir modüle veya ad alanına başvurmadığından yok sayıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUndefinedValue">
        <source>Undefined value '{0}'</source>
        <target state="translated">Tanımsız değer '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLabelNotFound">
        <source>Label {0} not found</source>
        <target state="translated">{0} etiketi bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="ilIncorrectNumberOfTypeArguments">
        <source>Incorrect number of type arguments to local call</source>
        <target state="translated">Yerel çağrı için hatalı sayıda tür bağımsız değişkeni</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDynamicInvocationNotSupported">
        <source>Dynamic invocation of {0} is not supported</source>
        <target state="translated">Dinamik {0} çağırma desteklenmiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfLiteralFieldIsInvalid">
        <source>Taking the address of a literal field is invalid</source>
        <target state="translated">Sabit değer alanının adresini almak geçersizdir</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfValueHereIsInvalid">
        <source>This operation involves taking the address of a value '{0}' represented using a local variable or other special representation. This is invalid.</source>
        <target state="translated">Bu işlem, yerel değişken kullanılarak veya başka bir özel gösterimle sunulan '{0}' değerinin adresini almayı içeriyor. Bu geçersizdir.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilCustomMarshallersCannotBeUsedInFSharp">
        <source>Custom marshallers cannot be specified in F# code. Consider using a C# helper function.</source>
        <target state="translated">F# kodunda özel hazırlayıcılar belirtilemez. C# yardım işlevi kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMarshalAsAttributeCannotBeDecoded">
        <source>The MarshalAs attribute could not be decoded</source>
        <target state="translated">MarshalAs özniteliğinin kodu çözülemedi</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignatureForExternalFunctionContainsTypeParameters">
        <source>The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.</source>
        <target state="translated">Bu dış işlevin imzası tür parametreleri içeriyor. Karşılık gelen C işlevi türlerini belirtmek için bağımsız değişkeni ve dönüş türlerini kısıtlayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDllImportAttributeCouldNotBeDecoded">
        <source>The DllImport attribute could not be decoded</source>
        <target state="translated">DllImport özniteliğinin kodu çözülemedi</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLiteralFieldsCannotBeSet">
        <source>Literal fields cannot be set</source>
        <target state="translated">Sabit değer alanları ayarlanamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStaticMethodIsNotLambda">
        <source>GenSetStorage: {0} was represented as a static method but was not an appropriate lambda expression</source>
        <target state="translated">GenSetStorage: {0} statik metot olarak gösterildi ancak bu uygun bir lambda ifadesi değildi</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMutableVariablesCannotEscapeMethod">
        <source>Mutable variables cannot escape their method</source>
        <target state="translated">Değişebilir değişkenler metotlarından kaçamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedUnrealizedValue">
        <source>Compiler error: unexpected unrealized value</source>
        <target state="translated">Derleyici hatası: Beklenmeyen gerçekleşmemiş değer</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMainModuleEmpty">
        <source>Main module of program is empty: nothing will happen when it is run</source>
        <target state="translated">Ana program modülü boş: çalıştırıldığında hiçbir şey olmayacak</target>
        <note />
      </trans-unit>
      <trans-unit id="ilTypeCannotBeUsedForLiteralField">
        <source>This type cannot be used for a literal field</source>
        <target state="translated">Bu tür, sabit değer alanı için kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedGetSetAnnotation">
        <source>Unexpected GetSet annotation on a property</source>
        <target state="translated">Özellikte beklenmeyen GetSet ek açıklaması</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldOffsetAttributeCouldNotBeDecoded">
        <source>The FieldOffset attribute could not be decoded</source>
        <target state="translated">FieldOffset özniteliğinin kodu çözülemedi</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStructLayoutAttributeCouldNotBeDecoded">
        <source>The StructLayout attribute could not be decoded</source>
        <target state="translated">StructLayout özniteliğinin kodu çözülemedi</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDefaultAugmentationAttributeCouldNotBeDecoded">
        <source>The DefaultAugmentation attribute could not be decoded</source>
        <target state="translated">DefaultAugmentation özniteliğinin kodu çözülemedi</target>
        <note />
      </trans-unit>
      <trans-unit id="ilReflectedDefinitionsCannotUseSliceOperator">
        <source>Reflected definitions cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">Yansıtılmış tanımlar ön ek ekleme işleci '%' kullanımlarını içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="optsProblemWithCodepage">
        <source>Problem with codepage '{0}': {1}</source>
        <target state="translated">{0}' kod sayfasında sorun: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyright">
        <source>Copyright (c) Microsoft Corporation. All Rights Reserved.</source>
        <target state="translated">Telif hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyrightCommunity">
        <source>Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</source>
        <target state="translated">MIT Açık Kaynak Lisansı altında ücretsiz olarak dağıtılır. https://github.com/Microsoft/visualfsharp/blob/master/License.txt</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNameOfOutputFile">
        <source>Name of the output file (Short form: -o)</source>
        <target state="translated">Çıkış dosyasının adı (Kısa biçimi: -o)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildConsole">
        <source>Build a console executable</source>
        <target state="translated">Çalıştırılabilir konsol dosyası oluştur</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildWindows">
        <source>Build a Windows executable</source>
        <target state="translated">Windows yürütülebilir dosyası oluştur</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildLibrary">
        <source>Build a library (Short form: -a)</source>
        <target state="translated">Kitaplık oluştur (Kısa biçimi: -a)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildModule">
        <source>Build a module that can be added to another assembly</source>
        <target state="translated">Başka bir derlemeye eklenebilir bir modül oluştur</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDelaySign">
        <source>Delay-sign the assembly using only the public portion of the strong name key</source>
        <target state="translated">Derlemeyi tanımlayıcı ad anahtarının yalnızca ortak kısmını kullanarak gecikmeli imzala</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPublicSign">
        <source>Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed</source>
        <target state="translated">Tanımlayıcı ad anahtarının yalnızca genel bölümünü kullanarak, bütünleştirilmiş kodu genel olarak imzala ve bütünleştirilmiş kodu imzalanmış olarak işaretle</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWriteXml">
        <source>Write the xmldoc of the assembly to the given file</source>
        <target state="translated">Bütünleştirilmiş kodun xmldoc dosyasını verilen dosyaya yaz</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyFile">
        <source>Specify a strong name key file</source>
        <target state="translated">Tanımlayıcı ad anahtarı dosyası belirtin</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyContainer">
        <source>Specify a strong name key container</source>
        <target state="translated">Tanımlayıcı ad anahtarı kapsayıcısı belirtin</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPlatform">
        <source>Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.</source>
        <target state="translated">Bu kodun üzerinde çalışabileceği platformları sınırlandırın: x86, Itanium, x64, anycpu32bitpreferred veya anycpu. Varsayılan: anycpu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoOpt">
        <source>Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.</source>
        <target state="translated">Yalnızca satır içindeki yapıları uygulamak için gerekli iyileştirme bilgilerini ekleyin. Modüller arasında satır içine yerleştirmeyi kısıtlar ancak ikili uyumluluğunu geliştirir.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoInterface">
        <source>Don't add a resource to the generated assembly containing F#-specific metadata</source>
        <target state="translated">F#-özel meta verilerini içeren oluşturulmuş bütünleştirilmiş koda kaynak ekleme</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSig">
        <source>Print the inferred interface of the assembly to a file</source>
        <target state="translated">Bütünleştirilmiş kodun çıkartılan arabirimini dosyaya yazdır</target>
        <note />
      </trans-unit>
      <trans-unit id="optsReference">
        <source>Reference an assembly (Short form: -r)</source>
        <target state="translated">Bütünleştirilmiş koda başvur (Kısa biçimi: -r)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32res">
        <source>Specify a Win32 resource file (.res)</source>
        <target state="translated">Win32 kaynak dosyası (.res) belirtin</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32manifest">
        <source>Specify a Win32 manifest file</source>
        <target state="translated">Win32 bildirim dosyası belirt</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowin32manifest">
        <source>Do not include the default Win32 manifest</source>
        <target state="translated">Varsayılan Win32 bildirimini eklemeyin</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedAllSource">
        <source>Embed all source files in the portable PDB file</source>
        <target state="translated">Tüm kaynak dosyaları taşınabilir PDB dosyasına ekle</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedSource">
        <source>Embed specific source files in the portable PDB file</source>
        <target state="translated">Belirli kaynak dosyaları taşınabilir PDB dosyasına ekle</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLink">
        <source>Source link information file to embed in the portable PDB file</source>
        <target state="translated">Taşınabilir PDB dosyasına eklenecek kaynak bağlantı bilgileri dosyası</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbeddedSourceRequirePortablePDBs">
        <source>--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">--embed anahtarı yalnızca Taşınabilir PDB gösterilirken desteklenir (--debug:portable veya --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLinkRequirePortablePDBs">
        <source>--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">--sourcelink anahtarı yalnızca Taşınabilir PDB gösterilirken desteklenir (--debug:portable veya --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="srcFileTooLarge">
        <source>Source file is too large to embed in a portable PDB</source>
        <target state="translated">Kaynak dosya, taşınabilir PDB dosyasına eklemek için çok büyük</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResource">
        <source>Embed the specified managed resource</source>
        <target state="translated">Belirtilen yönetilen kaynağı katıştır</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLinkresource">
        <source>Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]</source>
        <target state="translated">Belirtilen kaynağı, resinfo biçimi &lt;file&gt;[,&lt;string name&gt;[,public|private]] olacak şekilde bu derlemeye bağlayın</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebugPM">
        <source>Emit debug information (Short form: -g)</source>
        <target state="translated">Hata ayıklama bilgilerini yay (Kısa biçimi: -g)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebug">
        <source>Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file).</source>
        <target state="translated">Hata ayıklama türünü belirtin: full, portable, embedded, pdbonly. (Hata ayıklama türü belirtilmemişse '{0}' varsayılandır ve çalışan bir programa hata ayıklayıcı iliştirmeyi etkinleştirir. 'portable' bir çoklu platform biçimidir, 'embedded' çıkış dosyasına gömülü bir çoklu platform biçimidir).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsOptimize">
        <source>Enable optimizations (Short form: -O)</source>
        <target state="translated">İyileştirmeleri etkinleştir (Kısa biçimi: -O)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTailcalls">
        <source>Enable or disable tailcalls</source>
        <target state="translated">Tail çağrılarını etkinleştir veya devre dışı bırak</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDeterministic">
        <source>Produce a deterministic assembly (including module version GUID and timestamp)</source>
        <target state="translated">Belirleyici bir bütünleştirilmiş kod oluşturun (modül sürümü GUID'i ve zaman damgası dahil)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCrossoptimize">
        <source>Enable or disable cross-module optimizations</source>
        <target state="translated">Modüller arası iyileştirmeleri etkinleştir veya devre dışı bırak</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserrorPM">
        <source>Report all warnings as errors</source>
        <target state="translated">Tüm uyarıları hata olarak bildir</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserror">
        <source>Report specific warnings as errors</source>
        <target state="translated">Belirli uyarıları hata olarak bildir</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarn">
        <source>Set a warning level (0-5)</source>
        <target state="translated">Uyarı düzeyini ayarla (0-5)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowarn">
        <source>Disable specific warning messages</source>
        <target state="translated">Belirli uyarı iletilerini devre dışı bırak</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnOn">
        <source>Enable specific warnings that may be off by default</source>
        <target state="translated">Varsayılan seçenek olarak kapalı olabilen özel uyarıları etkinleştir</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecked">
        <source>Generate overflow checks</source>
        <target state="translated">Taşma denetimleri oluştur</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDefine">
        <source>Define conditional compilation symbols (Short form: -d)</source>
        <target state="translated">Koşullu derleme simgelerini tanımla (Kısa biçimi: -d)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsMlcompatibility">
        <source>Ignore ML compatibility warnings</source>
        <target state="translated">ML uyumluluk uyarılarını yoksay</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNologo">
        <source>Suppress compiler copyright message</source>
        <target state="translated">Derleyici telif hakkı iletisini gösterme</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelp">
        <source>Display this usage message (Short form: -?)</source>
        <target state="translated">Bu kullanım iletisini görüntüle (Kısa biçimi: -?)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFile">
        <source>Read response file for more options</source>
        <target state="translated">Daha fazla seçenek için yanıt dosyasını okuyun</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCodepage">
        <source>Specify the codepage used to read source files</source>
        <target state="translated">Kaynak dosyaları okumak için kullanılan kod sayfasını belirtin</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUtf8output">
        <source>Output messages in UTF-8 encoding</source>
        <target state="translated">UTF-8 kodlamasında çıkış iletileri</target>
        <note />
      </trans-unit>
      <trans-unit id="optsFullpaths">
        <source>Output messages with fully qualified paths</source>
        <target state="translated">Tam yollu çıkış iletileri</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLib">
        <source>Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)</source>
        <target state="translated">Kaynak dosyalarını ve bütünleştirilmiş kodları çözümlemek için kullanılan ekleme yolu için bir dizin belirtin (Kısa biçimi: -I)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBaseaddress">
        <source>Base address for the library to be built</source>
        <target state="translated">Oluşturulacak kitaplığın temel adresi</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoframework">
        <source>Do not reference the default CLI assemblies by default</source>
        <target state="translated">Varsayılan seçenek olarak varsayılan CLI bütünleştirilmiş kodlarına başvurma</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStandalone">
        <source>Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated</source>
        <target state="translated">F# kitaplığını ve ona bağlı tüm başvurulan DLL'leri, oluşturulmakta olan bütünleştirilmiş koda statik olarak bağla</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStaticlink">
        <source>Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.</source>
        <target state="translated">Verilen bütünleştirilmiş kodu ve bu bütünleştirilmiş koda bağlı tüm başvurulan DLL'leri, statik olarak bağlayın. DLL adı değil bütünleştirilmiş kod adı kullanın, örn. mylib.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResident">
        <source>Use a resident background compilation service to improve compiler startup times.</source>
        <target state="translated">Derleyici başlatma sürelerini geliştirmek için yerleşik bir arka planda derleme hizmetini kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPdb">
        <source>Name the output debug file</source>
        <target state="translated">Çıkış hata ayıklama dosyasını adlandır</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSimpleresolution">
        <source>Resolve assembly references using directory-based rules rather than MSBuild resolution</source>
        <target state="translated">Bütünleştirilmiş kod başvurularını MSBuild çözümlemesi yerine dizin tabanlı kurallar kullanarak çözümle</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedTarget">
        <source>Unrecognized target '{0}', expected 'exe', 'winexe', 'library' or 'module'</source>
        <target state="translated">Tanınmayan hedef '{0}'; 'exe', 'winexe', 'library' veya 'module' bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedDebugType">
        <source>Unrecognized debug type '{0}', expected 'pdbonly' or 'full'</source>
        <target state="translated">Tanınmayan hata ayıklama türü: '{0}'; 'pdbonly' veya 'full' bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidWarningLevel">
        <source>Invalid warning level '{0}'</source>
        <target state="translated">Geçersiz uyarı düzeyi '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsShortFormOf">
        <source>Short form of '{0}'</source>
        <target state="translated">'{0}' öğesinin kısa biçimi</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDeprecatedMsg">
        <source>The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.</source>
        <target state="translated">Komut satırı seçeneği '--cliroot' kullanım dışı bırakıldı. Onun yerine özel bir mscorlib.dll kopyasına açık başvuru kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDescription">
        <source>Use to override where the compiler looks for mscorlib.dll and framework components</source>
        <target state="translated">Derleyicinin mscorlib.dll ve çerçeve bileşenlerini aradığı yeri geçersiz kılmak için kullanın</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerOutputFiles">
        <source>- OUTPUT FILES -</source>
        <target state="translated">- ÇIKIŞ DOSYALARI -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerInputFiles">
        <source>- INPUT FILES -</source>
        <target state="translated">- GİRİŞ DOSYALARI -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerResources">
        <source>- RESOURCES -</source>
        <target state="translated">- KAYNAKLAR -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerCodeGen">
        <source>- CODE GENERATION -</source>
        <target state="translated">- KOD ÜRETİMİ -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerAdvanced">
        <source>- ADVANCED -</source>
        <target state="translated">- GELİŞMİŞ -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerMisc">
        <source>- MISCELLANEOUS -</source>
        <target state="translated">- ÇEŞİTLİ -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerLanguage">
        <source>- LANGUAGE -</source>
        <target state="translated">- DİL -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerErrsAndWarns">
        <source>- ERRORS AND WARNINGS -</source>
        <target state="translated">- HATALAR VE UYARILAR -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownArgumentToTheTestSwitch">
        <source>Unknown --test argument: '{0}'</source>
        <target state="translated">Bilinmeyen --test bağımsız değişkeni: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownPlatform">
        <source>Unrecognized platform '{0}', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'</source>
        <target state="translated">Tanınmayan platform '{0}', geçerli değerler: 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred' ve 'anycpu'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInternalNoDescription">
        <source>The command-line option '{0}' is for test purposes only</source>
        <target state="translated">'{0}' komut satırı seçeneği yalnızca test amaçlıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLONoDescription">
        <source>The command-line option '{0}' has been deprecated</source>
        <target state="translated">Komut satırı seçeneği '{0}' kullanım dışı bırakıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLODeprecatedSuggestAlternative">
        <source>The command-line option '{0}' has been deprecated. Use '{1}' instead.</source>
        <target state="translated">Komut satırı seçeneği '{0}' kullanım dışı bırakıldı. Onun yerine '{1}' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLOHtmlDoc">
        <source>The command-line option '{0}' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.</source>
        <target state="translated">Komut satırı seçeneği '{0}' kullanım dışı bırakıldı. HTML belgesi oluşturma şimdi FsHtmlDoc.exe aracı yoluyla F# Power Pack'in bir parçası.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsConsoleColors">
        <source>Output warning and error messages in color</source>
        <target state="translated">Renkli çıkış uyarısı ve hata iletileri</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUseHighEntropyVA">
        <source>Enable high-entropy ASLR</source>
        <target state="translated">Yüksek entropili ASLR'yi etkinleştir</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSubSystemVersion">
        <source>Specify subsystem version of this assembly</source>
        <target state="translated">Bu derlemenin alt sistem sürümünü belirtin</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTargetProfile">
        <source>Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib</source>
        <target state="translated">Bu bütünleştirilmiş kodun hedef çerçeve profilini belirtin. Geçerli değerler: mscorlib, netcore veya netstandard. Varsayılan: - mscorlib</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmitDebugInfoInQuotations">
        <source>Emit debug information in quotations</source>
        <target state="translated">Tırnak içindeki hata ayıklama bilgilerini yay</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPreferredUiLang">
        <source>Specify the preferred output language culture name (e.g. es-ES, ja-JP)</source>
        <target state="translated">Tercih edilen çıkış dili kültür adını (örn. es-ES, ja-JP) belirtin</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoCopyFsharpCore">
        <source>Don't copy FSharp.Core.dll along the produced binaries</source>
        <target state="translated">FSharp.Core.dll dosyasını üretilen ikili dosyalarla birlikte kopyalama</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidSubSystemVersion">
        <source>Invalid version '{0}' for '--subsystemversion'. The version must be 4.00 or greater.</source>
        <target state="translated">'--subsystemversion' için geçersiz sürüm '{0}'. Sürümün 4.00 veya üzeri olması gerekir.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidTargetProfile">
        <source>Invalid value '{0}' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.</source>
        <target state="translated">'--targetprofile' için geçersiz değer: '{0}'; geçerli değerler: 'mscorlib', 'netcore' veya 'netstandard'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFullName">
        <source>Full name</source>
        <target state="translated">Tam ad</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoOtherOverloads">
        <source>and {0} other overloads</source>
        <target state="translated">ve {0} başka aşırı yükleme</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoUnionCase">
        <source>union case</source>
        <target state="translated">birleşim durumu</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActivePatternResult">
        <source>active pattern result</source>
        <target state="translated">etkin desen sonucu</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActiveRecognizer">
        <source>active recognizer</source>
        <target state="translated">etkin tanıyıcı</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoField">
        <source>field</source>
        <target state="translated">alan</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoEvent">
        <source>event</source>
        <target state="translated">olay</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoProperty">
        <source>property</source>
        <target state="translated">özellik</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoExtension">
        <source>extension</source>
        <target state="translated">uzantı</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCustomOperation">
        <source>custom operation</source>
        <target state="translated">özel işlem</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoArgument">
        <source>argument</source>
        <target state="translated">Bağımsız değişken</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoPatternVariable">
        <source>patvar</source>
        <target state="translated">patvar</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespace">
        <source>namespace</source>
        <target state="translated">ad alanı</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoModule">
        <source>module</source>
        <target state="translated">modül</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespaceOrModule">
        <source>namespace/module</source>
        <target state="translated">ad alanı/modül</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromFirst">
        <source>from {0}</source>
        <target state="translated">Şuradan: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromNext">
        <source>also from {0}</source>
        <target state="translated">ayrıca {0} öğesinden</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedProperty">
        <source>generated property</source>
        <target state="translated">oluşturulan özellik</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedType">
        <source>generated type</source>
        <target state="translated">oluşturulan tür</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersKey">
        <source>Found by AssemblyFolders registry key</source>
        <target state="translated">AssemblyFolders kayıt defteri anahtarı ile bulunur</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersExKey">
        <source>Found by AssemblyFoldersEx registry key</source>
        <target state="translated">AssemblyFoldersEx kayıt defteri anahtarı ile bulunur</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionNetFramework">
        <source>.NET Framework</source>
        <target state="translated">.NET Framework</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionGAC">
        <source>Global Assembly Cache</source>
        <target state="translated">Genel Bütünleştirilmiş Kod Önbelleği</target>
        <note />
      </trans-unit>
      <trans-unit id="recursiveClassHierarchy">
        <source>Recursive class hierarchy in type '{0}'</source>
        <target state="translated">'{0}' türünde özyinelemeli sınıf hiyerarşisi</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRecursiveReferenceToAbstractSlot">
        <source>Invalid recursive reference to an abstract slot</source>
        <target state="translated">Soyut yuvaya geçersiz özyinelemeli başvuru</target>
        <note />
      </trans-unit>
      <trans-unit id="eventHasNonStandardType">
        <source>The event '{0}' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit {1} and {2} methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent&lt;_&gt;' or 'IEvent&lt;_,_&gt;'.</source>
        <target state="translated">'{0}' olayının standart olmayan bir türü var. Bu olay başka bir CLI dilinde bildirilmişse, bu olaya olay için açık {1} ve {2} metotlarını kullanarak erişmeniz gerekebilir. Bu olay F# dilinde belirtilmişse olayın türünü 'IDelegateEvent&lt;_&gt;' veya 'IEvent&lt;_,_&gt;' örnek oluşturması yapın.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeIsNotAccessible">
        <source>The type '{0}' is not accessible from this code location</source>
        <target state="translated">Bu '{0}' türüne bu kod konumundan erişilemiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCasesAreNotAccessible">
        <source>The union cases or fields of the type '{0}' are not accessible from this code location</source>
        <target state="translated">'{0}' türünün birleşim durumlarına veya alanlarına bu kod konumundan erişilemiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="valueIsNotAccessible">
        <source>The value '{0}' is not accessible from this code location</source>
        <target state="translated">'{0}' değerine bu kod konumundan erişilemiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCaseIsNotAccessible">
        <source>The union case '{0}' is not accessible from this code location</source>
        <target state="translated">'{0}' birleşim durumuna bu kod konumundan erişilemiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="fieldIsNotAccessible">
        <source>The record, struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">Record, struct veya class alanı '{0}' öğesine bu kod konumundan erişilemiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="structOrClassFieldIsNotAccessible">
        <source>The struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">'{0}' yapısına veya sınıf alanına bu kod konumundan erişilemiyor</target>
        <note />
      </trans-unit>
      <trans-unit id="experimentalConstruct">
        <source>This construct is experimental</source>
        <target state="translated">Bu yapı deneyseldir</target>
        <note />
      </trans-unit>
      <trans-unit id="noInvokeMethodsFound">
        <source>No Invoke methods found for delegate type</source>
        <target state="translated">Temsilci türü için bir Invoke metodu bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="moreThanOneInvokeMethodFound">
        <source>More than one Invoke method found for delegate type</source>
        <target state="translated">Temsilci türü için birden fazla Invoke metodu bulundu</target>
        <note />
      </trans-unit>
      <trans-unit id="delegatesNotAllowedToHaveCurriedSignatures">
        <source>Delegates are not allowed to have curried signatures</source>
        <target state="translated">Temsilcilerin eksiltimli imzaları olmasına izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrUnexpectedTExpr">
        <source>Unexpected Expr.TyChoose</source>
        <target state="translated">Beklenmeyen Expr.TyChoose</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrLambdaLiftingOptimizationsNotApplied">
        <source>Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.</source>
        <target state="translated">Not: Yerel olarak kısıtlanmış bir genel işlev olan lambda kaldırma iyileştirmelerinin birinci sınıf değer olarak kullanılması nedeniyle bu iyileştirmeler uygulanmamıştır. Tür kısıtlamaları eklemek bu durumu çözebilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifiersContainingAtSymbolReserved">
        <source>Identifiers containing '@' are reserved for use in F# code generation</source>
        <target state="translated">'@' içeren tanımlayıcılar F# kodunu oluşturmada kullanmak için ayrılmıştır</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifierReserved">
        <source>The identifier '{0}' is reserved for future use by F#</source>
        <target state="translated">'{0}' tanımlayıcısı F# tarafından ileride kullanılmak üzere ayrılmıştır</target>
        <note />
      </trans-unit>
      <trans-unit id="patcMissingVariable">
        <source>Missing variable '{0}'</source>
        <target state="translated">Eksik değişken: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="patcPartialActivePatternsGenerateOneResult">
        <source>Partial active patterns may only generate one result</source>
        <target state="translated">Kısmen etkin desenler yalnızca bir sonuç oluşturabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="impTypeRequiredUnavailable">
        <source>The type '{0}' is required here and is unavailable. You must add a reference to assembly '{1}'.</source>
        <target state="translated">Burada '{0}' türü gerekiyor ancak tür bulunamıyor. '{1}' bütünleştirilmiş koduna başvuru eklemeniz gerekiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferencedTypeCouldNotBeFoundInAssembly">
        <source>A reference to the type '{0}' in assembly '{1}' was found, but the type could not be found in that assembly</source>
        <target state="translated">{1}' bütünleştirilmiş kodunda '{0}' türüne başvuru bulundu, ancak bu tür o bütünleştirilmiş kodda bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="impNotEnoughTypeParamsInScopeWhileImporting">
        <source>Internal error or badly formed metadata: not enough type parameters were in scope while importing</source>
        <target state="translated">İç hata veya hatalı oluşturulmuş meta veri: içeri aktarma sırasında kapsamda yeterli tür parametresi yoktu</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferenceToDllRequiredByAssembly">
        <source>A reference to the DLL {0} is required by assembly {1}. The imported type {2} is located in the first assembly and could not be resolved.</source>
        <target state="translated">{1} bütünleştirilmiş kodu için {0} DLL'sine başvuru gerekli oldu. İçeri aktarılan {2} türü ilk bütünleştirilmiş kodda bulunuyordu ve çözümlenemedi.</target>
        <note />
      </trans-unit>
      <trans-unit id="impImportedAssemblyUsesNotPublicType">
        <source>An imported assembly uses the type '{0}' but that type is not public</source>
        <target state="translated">İçeri aktarılmış bir bütünleştirilmiş kod '{0}' türünü kullanıyor bu tür ortak değil</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButIncomplete">
        <source>The value '{0}' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible</source>
        <target state="translated">'{0}' değeri satır içi olarak işaretlenmiş ancak uygulamasında yeterince erişilemeyen bir iç veya özel işlev kullanılıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButWasNotBoundInTheOptEnv">
        <source>The value '{0}' was marked inline but was not bound in the optimization environment</source>
        <target state="translated">'{0}' değeri satır içi olarak işaretlenmiş ancak iyileştirme ortamında bağlanmamış</target>
        <note />
      </trans-unit>
      <trans-unit id="optLocalValueNotFoundDuringOptimization">
        <source>Local value {0} not found during optimization</source>
        <target state="translated">İyileştirme sırasında {0} yerel değeri bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineHasUnexpectedValue">
        <source>A value marked as 'inline' has an unexpected value</source>
        <target state="translated">'inline' olarak işaretlenmiş değerde beklenmeyen bir değer var</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineCouldNotBeInlined">
        <source>A value marked as 'inline' could not be inlined</source>
        <target state="translated">'inline' olarak işaretlenmiş bir değer satır içine alınamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="optFailedToInlineValue">
        <source>Failed to inline the value '{0}' marked 'inline', perhaps because a recursive value was marked 'inline'</source>
        <target state="translated">Muhtemelen özyinelemeli bir değer 'inline' olarak işaretlendiği için 'inline' olarak işaretlenmiş '{0}' değeri satır içine alınamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="optRecursiveValValue">
        <source>Recursive ValValue {0}</source>
        <target state="translated">Özyinelemeli ValValue {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltIncorrentIndentationOfIn">
        <source>The indentation of this 'in' token is incorrect with respect to the corresponding 'let'</source>
        <target state="translated">Bu 'in' belirtecinin girintisi kendisine karşılık gelen 'let''e göre hatalı</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltTokenIsOffsideOfContextStartedEarlier">
        <source>Possible incorrect indentation: this token is offside of context started at position {0}. Try indenting this token further or using standard formatting conventions.</source>
        <target state="translated">Olası hatalı girinti: {0} konumundan başlatılan bu belirteç bağlam dışıdır. Bu belirteci daha fazla girintilemeyi veya standart biçimlendirme kurallarını kullanmayı deneyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltSeparatorTokensOfPatternMatchMisaligned">
        <source>The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.</source>
        <target state="translated">Bu desen eşleşmesinin ayırma kurallarındaki '|' belirteçleri bir sütun kadar yanlış hizalı. Kodunuzu yeniden hizalamayı veya daha fazla girinti kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidModuleExprType">
        <source>Invalid module/expression/type</source>
        <target state="translated">Geçersiz modül/ifade/tür</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationNeededToDisambiguateTypesWithSameName">
        <source>Multiple types exist called '{0}', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '{1}'.</source>
        <target state="translated">Farklı sayıda genel parametreler alan '{0}' adlı birden çok tür var. Tür çözümleme belirsizliğini gidermek için bir tür örneği sağlayın, örn. '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationIsMissingAndCouldNotBeInferred">
        <source>The instantiation of the generic type '{0}' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '{1}'.</source>
        <target state="translated">{0}' genel türünün örneklenmesi eksik ve bu üyenin bağımsız değişkenlerinden ya da dönüş türünden çıkartılamıyor. Bu türe erişirken bir tür örneği sağlamayı düşünün, örn. '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrGlobalUsedOnlyAsFirstName">
        <source>'global' may only be used as the first name in a qualified path</source>
        <target state="translated">'global' yalnızca tam yoldaki ilk ad olarak kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="nrIsNotConstructorOrLiteral">
        <source>This is not a constructor or literal, or a constructor is being used incorrectly</source>
        <target state="translated">Bu bir oluşturucu veya sabit değer değil ya da bir oluşturucu hatalı kullanılıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnexpectedEmptyLongId">
        <source>Unexpected empty long identifier</source>
        <target state="translated">Beklenmeyen boş long tanımlayıcısı</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordDoesNotContainSuchLabel">
        <source>The record type '{0}' does not contain a label '{1}'.</source>
        <target state="translated">{0}' kayıt türü bir '{1}' etiketi içermiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidFieldLabel">
        <source>Invalid field label</source>
        <target state="translated">Geçersiz alan etiketi</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidExpression">
        <source>Invalid expression '{0}'</source>
        <target state="translated">Geçersiz ifade: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="nrNoConstructorsAvailableForType">
        <source>No constructors are available for the type '{0}'</source>
        <target state="translated">'{0}' türü için kullanılabilir bir oluşturucu yok</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnionTypeNeedsQualifiedAccess">
        <source>The union type for union case '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('{1}') in the name you are using.</source>
        <target state="translated">{0}' birleşim durumunun birleşim türü RequireQualifiedAccessAttribute ile tanımlanmış. Kullandığınız ada birleşim türünün adını ('{1}') dahil edin.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordTypeNeedsQualifiedAccess">
        <source>The record type for the record field '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('{1}') in the name you are using.</source>
        <target state="translated">{0}' kayıt alanının kayıt türü RequireQualifiedAccessAttribute ile tanımlanmış. Kullandığınız ada kayıt türünün adını ('{1}') dahil edin.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingPdb">
        <source>Unexpected error creating debug information file '{0}'</source>
        <target state="translated">Hata ayıklama bilgileri dosyası '{0}' oluşturulurken beklenmeyen hata</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideIntegerRange">
        <source>This number is outside the allowable range for this integer type</source>
        <target state="translated">Bu sayı, bu tamsayı türü için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexCharNotAllowedInOperatorNames">
        <source>'{0}' is not permitted as a character in operator names and is reserved for future use</source>
        <target state="translated">İşleç adlarında karakter olarak '{0}' kullanılmasına izin verilmez; ileride kullanılmak üzere ayrılmıştır</target>
        <note />
      </trans-unit>
      <trans-unit id="lexUnexpectedChar">
        <source>Unexpected character '{0}'</source>
        <target state="translated">Beklenmeyen karakter: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteArrayCannotEncode">
        <source>This byte array literal contains characters that do not encode as a single byte</source>
        <target state="translated">Bu bayt dizisi sabit değeri tek bayt olarak kodlanmayan karakterler içeriyor</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIdentEndInMarkReserved">
        <source>Identifiers followed by '{0}' are reserved for future use</source>
        <target state="translated">Ardından '{0}' gelen tanımlayıcılar ileride kullanılmak üzere ayrılmıştır</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSigned">
        <source>This number is outside the allowable range for 8-bit signed integers</source>
        <target state="translated">Bu sayı, 8 bit işaretli tamsayılar için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSignedHex">
        <source>This number is outside the allowable range for hexadecimal 8-bit signed integers</source>
        <target state="translated">Bu sayı, onaltılık 8 bit işaretli tamsayılar için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitUnsigned">
        <source>This number is outside the allowable range for 8-bit unsigned integers</source>
        <target state="translated">Bu sayı, 8 bit işaretsiz tamsayılar için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitSigned">
        <source>This number is outside the allowable range for 16-bit signed integers</source>
        <target state="translated">Bu sayı, 16 bit işaretli tamsayılar için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitUnsigned">
        <source>This number is outside the allowable range for 16-bit unsigned integers</source>
        <target state="translated">Bu sayı, 16 bit işaretsiz tamsayılar için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitSigned">
        <source>This number is outside the allowable range for 32-bit signed integers</source>
        <target state="translated">Bu sayı, 32 bit işaretli tamsayılar için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitUnsigned">
        <source>This number is outside the allowable range for 32-bit unsigned integers</source>
        <target state="translated">Bu sayı, 32 bit işaretsiz tamsayılar için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitSigned">
        <source>This number is outside the allowable range for 64-bit signed integers</source>
        <target state="translated">Bu sayı, 64 bit işaretli tamsayılar için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitUnsigned">
        <source>This number is outside the allowable range for 64-bit unsigned integers</source>
        <target state="translated">Bu sayı, 64 bit işaretsiz tamsayılar için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeSigned">
        <source>This number is outside the allowable range for signed native integers</source>
        <target state="translated">Bu sayı, işaretli yerel tamsayılar için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeUnsigned">
        <source>This number is outside the allowable range for unsigned native integers</source>
        <target state="translated">Bu sayı, işaretsiz yerel tamsayılar için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidFloat">
        <source>Invalid floating point number</source>
        <target state="translated">Geçersiz kayan noktalı sayı</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideDecimal">
        <source>This number is outside the allowable range for decimal literals</source>
        <target state="translated">Bu sayı, ondalık sabit değerleri için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideThirtyTwoBitFloat">
        <source>This number is outside the allowable range for 32-bit floats</source>
        <target state="translated">Bu sayı, 32 bit kayan noktalı sayılar için izin verilen aralığın dışında</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidNumericLiteral">
        <source>This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0o1, 0b1, 1l (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</source>
        <target state="translated">Bu geçerli bir sayısal sabit değer değil. Geçerli sayısal sabit değerler şunları içerir: 1, 0x1, 0o1, 0b1, 1l (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidByteLiteral">
        <source>This is not a valid byte literal</source>
        <target state="translated">Bu geçerli bir bayt sabit değeri değil</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidCharLiteral">
        <source>This is not a valid character literal</source>
        <target state="translated">Bu geçerli bir karakter sabit değeri değil</target>
        <note />
      </trans-unit>
      <trans-unit id="lexThisUnicodeOnlyInStringLiterals">
        <source>This Unicode encoding is only valid in string literals</source>
        <target state="translated">Bu Unicode kodlaması yalnızca dize sabit değerlerinde geçerlidir</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTokenReserved">
        <source>This token is reserved for future use</source>
        <target state="translated">Bu belirteç ileride kullanılmak üzere ayrılmıştır</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTabsNotAllowed">
        <source>TABs are not allowed in F# code unless the #indent \"off\" option is used</source>
        <target state="translated">#indent \"off\" seçeneği kullanılmadığı sürece F# kodunda SEKMELERE izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidLineNumber">
        <source>Invalid line number: '{0}'</source>
        <target state="translated">Geçersiz satır numarası '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustBeFirst">
        <source>#if directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">#if yönergesi satırdaki ilk boşluk olmayan karakter olarak görünmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseNoMatchingIf">
        <source>#else has no matching #if</source>
        <target state="translated">#else ile eşleşen bir #if yok</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifRequiredForElse">
        <source>#endif required for #else</source>
        <target state="translated">#else için #endif gerekli</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseMustBeFirst">
        <source>#else directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">#else yönergesi satırdaki ilk boşluk olmayan karakter olarak görünmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndingNoMatchingIf">
        <source>#endif has no matching #if</source>
        <target state="translated">#endif ile eşleşen bir #if yok</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifMustBeFirst">
        <source>#endif directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">#endif yönergesi satırdaki ilk boşluk olmayan karakter olarak görünmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustHaveIdent">
        <source>#if directive should be immediately followed by an identifier</source>
        <target state="translated">#if yönergesinin hemen ardından tanımlayıcı gelmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="lexWrongNestedHashEndif">
        <source>Syntax error. Wrong nested #endif, unexpected tokens before it.</source>
        <target state="translated">Sözdizimi hatası. Yanlış girintiye yerleştirilmiş #endif, önünde beklenmeyen belirteçler var.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashBangMustBeFirstInFile">
        <source>#! may only appear as the first line at the start of a file.</source>
        <target state="translated">#! yalnızca bir dosyanın başlangıcında ilk satırda geçebilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexExpectedSingleLineComment">
        <source>Expected single line comment or end of line</source>
        <target state="translated">Tek satırlık açıklama veya satır sonu bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNoArguments">
        <source>Infix operator member '{0}' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">'{0}' Infix işleç üyesinde hiç bağımsız değişken yok. 2 bağımsız değişkenli bir demet bekleniyordu, ör. statik üye (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonPairArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Infix işleç üyesi '{0}', {1} başlangıç bağımsız değişkenine sahip. 2 bağımsız değişkenli bir demet bekleniyordu, ör. statik üye (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithCurriedArguments">
        <source>Infix operator member '{0}' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Infix işleç üyesi '{0}', fazladan eksiltimli bağımsız değişkenlere sahip. 2 bağımsız değişkenli bir demet bekleniyordu, ör. statik üye (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFSharpCoreRequiresExplicit">
        <source>All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'</source>
        <target state="translated">FSharp.Core.dll'sindeki tüm kayıt, birleşim ve yapı türleri 'StructuralComparison' veya 'NoComparison' ile açık olarak etiketlenmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the type parameter '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter</source>
        <target state="translated">Yapı, kayıt veya birleşim türü '{0}', 'StructuralComparison' özniteliğine sahip ancak tür parametresi '{1}' 'comparison' kısıtlamasını karşılamıyor. Tür parametresine 'comparison' kısıtlamasını eklemeyi düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the component type '{1}' does not satisfy the 'comparison' constraint</source>
        <target state="translated">Yapı, kayıt veya birleşim türü '{0}', 'StructuralComparison' özniteliğine sahip ancak bileşen türü '{1}' 'comparison' kısıtlamasını karşılamıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded1">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type parameter {1} does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">Tür parametresi {1} 'comparison' kısıtlamasını yerine getirmediği için yapı, kayıt veya birleşim türü '{0}' yapısal olarak karşılaştırılabilir değil. Türün karşılaştırılabilir olmadığını netleştirmek için '{2}' türüne 'NoComparison' özniteliği eklemeyi düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded2">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">{1}' türü 'comparison' kısıtlamasını yerine getirmediği için yapı, kayıt veya birleşim türü '{0}' yapısal olarak karşılaştırılabilir değil. Türün karşılaştırılabilir olmadığını netleştirmek için '{2}' türüne 'NoComparison' özniteliği eklemeyi düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded1">
        <source>The struct, record or union type '{0}' does not support structural equality because the type parameter {1} does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">Tür parametresi {1} 'equality' kısıtlamasını yerine getirmediği için yapı, kayıt veya birleşim türü '{0}' yapısal eşitliği desteklemez. Türün yapısal eşitliği desteklemediğini netleştirmek için '{2}' türüne 'NoEquality' özniteliği eklemeyi düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded2">
        <source>The struct, record or union type '{0}' does not support structural equality because the type '{1}' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">{1}' türü 'equality' kısıtlamasını yerine getirmediği için yapı, kayıt veya birleşim türü '{0}' yapısal eşitliği desteklemez. Türün yapısal eşitliği desteklemediğini netleştirmek için '{2}' türüne 'NoEquality' özniteliği eklemeyi düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the type parameter '{1}' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter</source>
        <target state="translated">Yapı, kayıt veya birleşim türü '{0}', 'StructuralEquality' özniteliğine sahip ancak tür parametresi '{1}' 'equality' kısıtlamasını karşılamıyor. Tür parametresine 'equality' kısıtlamasını eklemeyi düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the component type '{1}' does not satisfy the 'equality' constraint</source>
        <target state="translated">Yapı, kayıt veya birleşim türü '{0}', 'StructuralEquality' özniteliğine sahip ancak bileşen türü '{1}' 'equality' kısıtlamasını karşılamıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
        <source>Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct.</source>
        <target state="translated">Bir struct türünün birincil oluşturucusunun her bağımsız değişkenine bir tür verilmelidir, örneğin 'type S(x1:int, x2: int) = ...'. Bu bağımsız değişkenler yapının alanlarını belirler.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedValue">
        <source>The value '{0}' is unused</source>
        <target state="translated">'{0}' değeri kullanılmıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedThisVariable">
        <source>The recursive object reference '{0}' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.</source>
        <target state="translated">Özyinelemeli nesne başvurusu '{0}' kullanılmıyor. Özyinelemeli nesne başvurusunun varlığı, bu ve bundan türetilmiş türlerdeki üyelere çalışma zamanı başlatma denetimleri ekler. Bu özyinelemeli nesne başvurusunu kaldırmayı değerlendirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterAtMostOneArgument">
        <source>A getter property may have at most one argument group</source>
        <target state="translated">Alıcı özelliğinin en çok bir bağımsız değişken grubu olabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetterAtMostTwoArguments">
        <source>A setter property may have at most two argument groups</source>
        <target state="translated">Ayarlayıcı özelliğinin en çok iki bağımsız değişken grubu olabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidProperty">
        <source>Invalid property getter or setter</source>
        <target state="translated">Geçersiz özellik alıcı veya ayarlayıcı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIndexerPropertyRequiresAtLeastOneArgument">
        <source>An indexer property must be given at least one argument</source>
        <target state="translated">Dizin erişimcisi özelliğine en az bir bağımsız değişken verilmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidAddressOfMutableAcrossAssemblyBoundary">
        <source>This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation</source>
        <target state="translated">Bu işlem, başka bir bütünleştirilmiş kodda desteklenmeyen bir şekilde tanımlanmış değiştirilebilen bir üst düzey değere erişiyor. Değere adresi üzerinden erişilemiyor. İfadeyi değiştirilebilen bir yerel değere kopyalamayı, örn. 'let mutable x = ...' ve gerekirse işlem tamamlandıktan sonra değeri geri atamayı düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTypars">
        <source>Remove spaces between the type name and type parameter, e.g. \"type C&lt;'T&gt;\", not type \"C   &lt;'T&gt;\". Type parameters must be placed directly adjacent to the type name.</source>
        <target state="translated">Tür adı ile tür parametresi arasındaki boşlukları kaldırın, ör. \"C   &lt;'T&gt;\" değil \"type C&lt;'T&gt;\". Tür parametreleri doğrudan tür adına bitişik olarak yerleştirilmelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTyargs">
        <source>Remove spaces between the type name and type parameter, e.g. \"C&lt;'T&gt;\", not \"C &lt;'T&gt;\". Type parameters must be placed directly adjacent to the type name.</source>
        <target state="translated">Tür adı ile tür parametresi arasındaki boşlukları kaldırın (ör. \"C &lt;'T&gt;\" değil \"C&lt;'T&gt;\". Tür parametreleri doğrudan tür adına bitişik olarak yerleştirilmelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAtomicType">
        <source>The use of the type syntax 'int C' and 'C  &lt;int&gt;' is not permitted here. Consider adjusting this type to be written in the form 'C&lt;int&gt;'</source>
        <target state="translated">Burada 'int C' ve 'C  &lt;int&gt;' tür söz diziminin kullanılmasına izin verilmiyor. Bu türü şu biçimde yazılacak şekilde değiştirmeyi göz önünde bulundurun: 'C&lt;int&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespace">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the module/namespace '{2}'</source>
        <target state="translated">{1}' derleme birimindeki '{0}' modülü/ad alanı '{2}' modülünü/ad alanını içermiyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefVal">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the val '{2}'</source>
        <target state="translated">{1}' derleme birimindeki '{0}' modülü/ad alanı '{2}' değerini içermiyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespaceType">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the namespace, module or type '{2}'</source>
        <target state="translated">{1}' derleme birimindeki '{0}' modülü/ad alanı '{2}' ad alanını, modülünü veya türünü içermiyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseNullAsTrueValue">
        <source>The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case</source>
        <target state="translated">'UseNullAsTrueValue' öznitelik bayrağı yalnızca bir adet işlenensiz durumu ve en az bir adet işlenenli durumu olan birleşim türleriyle kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterInferredByref">
        <source>The parameter '{0}' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref&lt;int&gt;'. When used, a byref parameter is implicitly dereferenced.</source>
        <target state="translated">'{0}' parametresinin byref türüne sahip olduğu çıkarsandı. Byref türündeki parametrelere açık bir tür ek açıklaması verilmelidir, ör. 'x1: byref&lt;int&gt;'. Bir byref parametresi kullanılırsa parametre başvurusu örtük olarak kaldırılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonUniformMemberUse">
        <source>The generic member '{0}' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.</source>
        <target state="translated">'{0}' genel üyesi, bu program noktasından önce düzenli olmayan bir örneklemede kullanıldı. Bu üye önce olacak şekilde üyeleri yeniden sıralamayı düşünün. Alternatif olarak, bağımsız değişken türleri, dönüş türü ve diğer ek genel parametreler ve kısıtlamalar dahil üyenin tam türünü açık olarak belirtin.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttribArgsDiffer">
        <source>The attribute '{0}' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.</source>
        <target state="translated">'{0}' özniteliği hem uygulamada hem de imzada görünüyor ancak özniteliğin bağımsız değişkenleri farklı. Derlenmiş koda yalnızca imzadaki öznitelik eklenecek.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallAbstractBaseMember">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">Soyut bir temel üye çağrılamaz: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInUnmanaged">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position</source>
        <target state="translated">'unmanaged' kısıtlaması olan bir genel yapının bu konumda veya yakınında kullanılmasındaki belirsizlik çözümlenemedi</target>
        <note />
      </trans-unit>
      <trans-unit id="mlCompatMessage">
        <source>This construct is for ML compatibility. {0}. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'.</source>
        <target state="translated">Bu yapı ML uyumluluğu içindir. {0}. '--mlcompatibility' veya '--nowarn:62' kullanarak bu uyarıyı devre dışı bırakabilirsiniz.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldDoesNotHaveValidOffsetForStructureLayout">
        <source>The type '{0}' has been marked as having an Explicit layout, but the field '{1}' has not been marked with the 'FieldOffset' attribute</source>
        <target state="translated">{0}' türünün Açık düzeni olduğu işaretlenmiş, ancak '{1}' alanı 'FieldOffset' özniteliğiyle işaretlenmemiş</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfacesShouldUseInheritNotInterface">
        <source>Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'</source>
        <target state="translated">Diğer arabirimlerce devralınan arabirimler 'interface ...' yerine 'inherit ...' kullanılarak tanımlanmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperator">
        <source>Invalid prefix operator</source>
        <target state="translated">Geçersiz ön ek işleci</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperatorDefinition">
        <source>Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.</source>
        <target state="translated">Geçersiz işleç tanımı. Ön ek işleç tanımları geçerli bir ön ek işleci adı kullanmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCompilingExtensionIsForML">
        <source>The file extensions '.ml' and '.mli' are for ML compatibility</source>
        <target state="translated">'.ml' ve '.mli' dosya uzantıları ML uyumluluğu içindir</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIndentOffForML">
        <source>Consider using a file with extension '.ml' or '.mli' instead</source>
        <target state="translated">Bunun yerine uzantısı '.ml' veya '.mli' olan dosya kullanmayı düşünün</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternIdentIsNotFunctionTyped">
        <source>Active pattern '{0}' is not a function</source>
        <target state="translated">'{0}' etkin deseni bir işlev değil</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternChoiceHasFreeTypars">
        <source>Active pattern '{0}' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</source>
        <target state="translated">'{0}' etkin deseninin, giriş tarafından belirlenmeyen tür değişkenleri içeren bir sonuç türü var. Genellikle bunun nedeni, bir sonuç durumunun (ör. 'let (|A|B|) (x:int) = A x') belirtilmemesidir. Bu bir tür kısıtlamasıyla düzeltilebilir, ör. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldHasOffsetForSequentialLayout">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">FieldOffset özniteliği yalnızca StructLayout(LayoutKind.Explicit) ile işaretlenmiş türlerdeki üyelere koyulabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsMustComeAfterNonOptionalArgs">
        <source>Optional arguments must come at the end of the argument list, after any non-optional arguments</source>
        <target state="translated">İsteğe bağlı bağımsız değişkenler bağımsız değişken listesinin sonunda, isteğe bağlı olmayan tüm bağımsız değişkenlerden sonra gelmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeUsage">
        <source>Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes</source>
        <target state="translated">'System.Diagnostics.ConditionalAttribute' özniteliği yalnızca metotlarda veya öznitelik sınıflarında geçerlidir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOperatorDefinitionInExtrinsic">
        <source>Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.</source>
        <target state="translated">Uzantı üyeleri işleç aşırı yüklemeleri sağlayamaz. Bunun yerine işleci tür tanımının parçası olarak tanımlamayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBFileNameCannotBeChangedWarning">
        <source>The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.</source>
        <target state="translated">MDB dosyasının adı &lt;assembly-file-name&gt;.mdb olmalıdır. --pdb seçeneği yoksayılacak.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBMemberMissing">
        <source>MDB generation failed. Could not find compatible member {0}</source>
        <target state="translated">MDB oluşturulamadı. Uyumlu üye {0} bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingMdb">
        <source>Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly.</source>
        <target state="translated">MDB hata ayıklama bilgileri oluşturulamıyor. 'MonoSymbolWriter' türü 'Mono.CompilerServices.SymbolWriter.dll' bütünleştirilmiş kodundan yüklenemedi.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseNameConflictsWithGeneratedType">
        <source>The union case named '{0}' conflicts with the generated type '{1}'</source>
        <target state="translated">{0}' adlı birleşim durumu oluşturulan '{1}' türüyle çakışıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoReflectedDefinitionOnStructMember">
        <source>ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter</source>
        <target state="translated">Örnek üyesi örtük 'this' byref parametresini aldığı için ReflectedDefinitionAttribute, yapı türündeki bir örnek üyesine uygulanamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportNotAllowed">
        <source>DLLImport bindings must be static members in a class or function definitions in a module</source>
        <target state="translated">DLLImport bağlamaları bir sınıf içinde statik üyeler veya bir modül içinde işlev tanımları olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedSigdataFile">
        <source>FSharp.Core.sigdata not found alongside FSharp.Core. File expected in {0}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">FSharp.Core.sigdata, FSharp.Core ile birlikte bulunamadı. Dosyanın {0} içinde olması bekleniyordu. Bu dosyayı gerektirmeyen daha yeni bir FSharp.Core sürümüne yükseltmeniz önerilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedFileAlongSideFSharpCore">
        <source>File '{0}' not found alongside FSharp.Core. File expected in {1}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">{0}' dosyası FSharp.Core ile birlikte bulunamadı. Dosyanın {1} içinde olması bekleniyordu. Bu dosyayı gerektirmeyen daha yeni bir FSharp.Core sürümüne yükseltmeniz önerilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedFileNameCharacter">
        <source>Filename '{0}' contains invalid character '{1}'</source>
        <target state="translated">Dosya adı '{0}', geçersiz '{1}' karakterini içeriyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBinding">
        <source>'use!' bindings must be of the form 'use! &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">'use!' bağlamaları 'use! &lt;var&gt; = &lt;expr&gt;' biçiminde olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoInnerGenericsInQuotations">
        <source>Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.</source>
        <target state="translated">Tırnak içindeki ifadelerde iç genel işlevlere izin verilmez. Bu işlev artık genel olmayacak şekilde bazı tür kısıtlamaları eklemeyi düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumTypeCannotBeEnumerated">
        <source>The type '{0}' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property</source>
        <target state="translated">'{0}' türü geçerli bir numaralandırıcı türü değil, yani bool döndüren bir 'MoveNext()' metodu ve 'Current' özelliği yok</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteString">
        <source>End of file in triple-quote string begun at or before here</source>
        <target state="translated">Üç tırnak işaretli dizede dosya sonu burada veya daha önce başlatıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteStringInComment">
        <source>End of file in triple-quote string embedded in comment begun at or before here</source>
        <target state="translated">Üç tırnak işaretli açıklamaya gömülü dizede dosya sonu burada veya daha önce başlatıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLosesMeasures">
        <source>This type test or downcast will ignore the unit-of-measure '{0}'</source>
        <target state="translated">Bu tür testi veya alt türe çevirme işlemi '{0}' ölçü birimini yok sayacak</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingTypeArgs">
        <source>Expected type argument or static argument</source>
        <target state="translated">Tür bağımsız değişkeni veya statik bağımsız değişken bekleniyor</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingGreaterThan">
        <source>Unmatched '&lt;'. Expected closing '&gt;'</source>
        <target state="translated">Eşleşmeyen '&lt;'. Expected closing '&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
        <source>Unexpected quotation operator '&lt;@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '&lt;' and '@' characters.</source>
        <target state="translated">Tür tanımında beklenmeyen '&lt;@' alıntı işleci. Bir tür sağlayıcısına bir harf dizisini statik bağımsız değişken olarak geçirmek istiyorsanız '&lt;' ile '@' karakterinin arasına bir boşluk koyun.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorParsingAsOperatorName">
        <source>Attempted to parse this as an operator name, but failed</source>
        <target state="translated">Bu bir işleç adı olarak ayrıştırılmaya çalışıldı, ancak yapılamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidUnicodeLiteral">
        <source>\U{0} is not a valid Unicode character escape sequence</source>
        <target state="translated">\U{0} geçerli bir Unicode karakter kaçış sırası değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoWrongType">
        <source>'{0}' must be applied to an argument of type '{1}', but has been applied to an argument of type '{2}'</source>
        <target state="translated">'{0}', '{1}' türündeki bağımsız değişkene uygulanmalıdır, ancak '{2}' türündeki bağımsız değişkene uygulanmış</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoNotOptional">
        <source>'{0}' can only be applied to optional arguments</source>
        <target state="translated">'{0}' sadece isteğe bağlı bağımsız değişkenlere uygulanabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="toolLocationHelperUnsupportedFrameworkVersion">
        <source>The specified .NET Framework version '{0}' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
        <target state="translated">Belirtilen '{0}' .NET Framework sürümü desteklenmiyor. Lütfen Microsoft.Build.Utilities.TargetDotNetFrameworkVersion sabit listesinden bir değer belirtin.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidMagicValue">
        <source>Invalid Magic value in CLR Header</source>
        <target state="translated">CLR Üst Bilgisindeki Magic değeri geçersiz</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignBadImageFormat">
        <source>Bad image format</source>
        <target state="translated">Bozuk görüntü biçimi</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignPrivateKeyExpected">
        <source>Private key expected</source>
        <target state="translated">Özel anahtar bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignRsaKeyExpected">
        <source>RSA key expected</source>
        <target state="translated">RSA anahtarı bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidBitLen">
        <source>Invalid bit Length</source>
        <target state="translated">Bit Uzunluğu geçersiz</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidRSAParams">
        <source>Invalid RSAParameters structure - '{{0}}' expected</source>
        <target state="translated">Geçersiz RSAParameters yapısı - ' {{0}}' bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidAlgId">
        <source>Invalid algId - 'Exponent' expected</source>
        <target state="translated">Geçersiz algId - 'Üs' bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidSignatureSize">
        <source>Invalid signature size</source>
        <target state="translated">Geçersiz imza boyutu</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignNoSignatureDirectory">
        <source>No signature directory</source>
        <target state="translated">İmza dizini yok</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidPKBlob">
        <source>Invalid Public Key blob</source>
        <target state="translated">Ortak Anahtar blobu geçersiz</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTooManyErrors">
        <source>Exiting - too many errors</source>
        <target state="translated">Çıkılıyor - çok fazla hata var</target>
        <note />
      </trans-unit>
      <trans-unit id="docfileNoXmlSuffix">
        <source>The documentation file has no .xml suffix</source>
        <target state="translated">Belge dosyasında bir .xml son eki yok</target>
        <note />
      </trans-unit>
      <trans-unit id="fscNoImplementationFiles">
        <source>No implementation files specified</source>
        <target state="translated">Bir uygulama dosyası belirtilmedi</target>
        <note />
      </trans-unit>
      <trans-unit id="fscBadAssemblyVersion">
        <source>The attribute {0} specified version '{1}', but this value is invalid and has been ignored</source>
        <target state="translated">{0} özniteliğinde '{1}' sürümü belirtildi, ancak bu değer geçersiz olduğundan yoksayıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTwoResourceManifests">
        <source>Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used.</source>
        <target state="translated">Çakışan seçenekler belirtildi: 'win32manifest' ve 'win32res'. Bunlardan yalnızca biri kullanılabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking">
        <source>The code in assembly '{0}' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">'{0}' bütünleştirilmiş kodundaki kod tırnak içinde sabit değerler kullanıyor. Bütün bütünleştirilmiş kodlar en az F# 4.0 ile derlenmediği sürece, statik bağlama tırnak içinde sabit değerler kullanan bileşenler içeremez.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking0">
        <source>Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">Bu bütünleştirilmiş kod tırnak içinde sabit değerler kullanıyor. Tüm bütünleştirilmiş kodlar en az F# 4.0 ile derlenmediği sürece, statik bağlama tırnak içinde sabit değerler kullanan bileşenler içeremez.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoEXE">
        <source>Static linking may not include a .EXE</source>
        <target state="translated">Statik bağlama .EXE içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoMixedDLL">
        <source>Static linking may not include a mixed managed/unmanaged DLL</source>
        <target state="translated">Statik bağlama karışık bir yönetilen/yönetilmeyen DLL içeremez</target>
        <note />
      </trans-unit>
      <trans-unit id="fscIgnoringMixedWhenLinking">
        <source>Ignoring mixed managed/unmanaged assembly '{0}' during static linking</source>
        <target state="translated">Yönetilen/yönetilmeyen karışık '{0}' bütünleştirilmiş kodu statik bağlama sırasında yok sayılıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssumeStaticLinkContainsNoDependencies">
        <source>Assembly '{0}' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.</source>
        <target state="translated">'{0}' bütünleştirilmiş koduna geçişli olarak başvuruldu ve bütünleştirilmiş kod otomatik olarak çözümlenemedi. Statik bağlantı, bu DLL'nin F# kitaplığına veya statik bağlanmış diğer DLL'lere hiçbir bağımlılığı olmadığını kabul eder. Bu DLL'ye açık başvuru eklemeyi düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyNotFoundInDependencySet">
        <source>Assembly '{0}' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.</source>
        <target state="translated">'{0}' bütünleştirilmiş kodu hedef ikilinin bağımlılık kümesinde bulunamadı. Statik olarak bağlanmış kökler, DLL veya EXE uzantısı olmadan bütünleştirilmiş kod adı kullanılarak belirtilmelidir. Bu bütünleştirilmiş koda açık olarak başvurulmuşsa bütünleştirilmiş koda aslında oluşturulan ikili dosya tarafından ihtiyaç duyulmamış olması mümkündür ve bu durumda statik olarak bağlanmamalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileCouldNotBeOpened">
        <source>The key file '{0}' could not be opened</source>
        <target state="translated">Anahtar dosyası '{0}' açılamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="fscProblemWritingBinary">
        <source>A problem occurred writing the binary '{0}': {1}</source>
        <target state="translated">{0}' ikili dosyası yazılırken bir sorun oluştu: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyVersionAttributeIgnored">
        <source>The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option</source>
        <target state="translated">Komut satırı seçeneği kullanılarak sürüm verildiği için 'AssemblyVersionAttribute' yok sayıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyCultureAttributeError">
        <source>Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'</source>
        <target state="translated">'System.Reflection.AssemblyCultureAttribute' özniteliği yayılırken hata oluştu -- 'Çalıştırılabilir dosyalar uydu bütünleştirilmiş kodlar olamaz, Kültür her zaman boş olmalıdır'</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDelaySignWarning">
        <source>Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module</source>
        <target state="translated">'--delaysign' seçeneği kaynak dosyasında veya ekli modülde verilen 'System.Reflection.AssemblyDelaySignAttribute' özniteliğini geçersiz kılar</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileWarning">
        <source>Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module</source>
        <target state="translated">'--keyfile' seçeneği kaynak dosyasında veya ekli modülde verilen 'System.Reflection.AssemblyKeyFileAttribute' özniteliğini geçersiz kılar</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyNameWarning">
        <source>Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module</source>
        <target state="translated">'--keycontainer' seçeneği kaynak dosyasında veya ekli modülde verilen 'System.Reflection.AssemblyNameAttribute' özniteliğini geçersiz kılar</target>
        <note />
      </trans-unit>
      <trans-unit id="fscReferenceOnCommandLine">
        <source>The assembly '{0}' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'.</source>
        <target state="translated">'{0}' bütünleştirilmiş kodu komut satırında listeleniyor. Bütünleştirilmiş kodlara '-r' gibi bir komut satırı bayrağı kullanılarak başvurulmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscRemotingError">
        <source>The resident compilation service was not used because a problem occured in communicating with the server.</source>
        <target state="translated">Sunucuyla iletişimde bir sorun oluştuğu için yerleşik derleme hizmeti kullanılmadı.</target>
        <note />
      </trans-unit>
      <trans-unit id="pathIsInvalid">
        <source>Problem with filename '{0}': Illegal characters in path.</source>
        <target state="translated">'{0}' dosya adında sorun: Yolda geçersiz karakterler var.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscResxSourceFileDeprecated">
        <source>Passing a .resx file ({0}) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.</source>
        <target state="translated">Bir resx dosyasını ({0}) derleyiciye kaynak dosyası olarak geçirme işlemi kullanımdan kaldırılmıştır. .resx dosyasını bir --resource seçeneği olarak geçirmek için resgen.exe aracını kullanarak dosyayı bir .resources dosyasına dönüştürün. MSBuild kullanıyorsanız bu işlem .fsproj proje dosyasındaki bir &lt;EmbeddedResource&gt; öğesi aracılığıyla gerçekleştirilebilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoProfileMismatches">
        <source>Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).</source>
        <target state="translated">System.Runtime'a başvuran bir bütünleştirilmiş kod oluşturulurken (örneğin, .NET Core veya Taşınabilir bütünleştirilmiş kod), mscorlib'e başvuran bir bütünleştirilmiş kodda (örneğin, .NET Framework bütünleştirilmiş kodu) statik bağlama kullanılamaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyWildcardAndDeterminism">
        <source>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</source>
        <target state="translated">Bir {0} tarafından '{1}' sürümü belirtildi. Ancak siz belirleyici bir derleme istediniz, bu ise bir joker karakter ve bunlar çakışıyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDeterministicDebugRequiresPortablePdb">
        <source>Deterministic builds only support portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">Belirlenimci derlemeler yalnızca taşınabilir PDB'leri (--debug:portable veya --debug:embedded) destekler</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInNamespaceName">
        <source>Character '{0}' is not allowed in provided namespace name '{1}'</source>
        <target state="translated">{1}' sağlanan ad alanı adında '{0}' karakterine izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullOrEmptyMemberName">
        <source>The provided type '{0}' returned a member with a null or empty member name</source>
        <target state="translated">'{0}' sağlanan türü null veya boş üye adı olan bir üye döndürdü</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMember">
        <source>The provided type '{0}' returned a null member</source>
        <target state="translated">'{0}' sağlanan türü bir null üye döndürdü</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringType">
        <source>The provided type '{0}' member info '{1}' has null declaring type</source>
        <target state="translated">{0}' sağlanan türünün '{1}' üye bilgisinde null tanımlama türü var</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringTypeDifferentFromProvidedType">
        <source>The provided type '{0}' has member '{1}' which has declaring type '{2}'. Expected declaring type to be the same as provided type.</source>
        <target state="translated">{0}' sağlanan türünde '{2}' tanımlama türüne sahip '{1}' üyesi var. Tanımlama türünün sağlanan türle aynı olması bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="etHostingAssemblyFoundWithoutHosts">
        <source>Referenced assembly '{0}' has assembly level attribute '{1}' but no public type provider classes were found</source>
        <target state="translated">Başvurulan '{0}' bütünleştirilmiş kodunda '{1}' bütünleştirilmiş kod düzeyi özniteliği var ancak hiç ortak tür sağlayıcısı sınıfı bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceOfTypeNotAllowed">
        <source>Type '{0}' from type provider '{1}' has an empty namespace. Use 'null' for the global namespace.</source>
        <target state="translated">{1}' tür sağlayıcısından '{0}' türünün boş ad alanı var. Genel ad alanı için 'null' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceNotAllowed">
        <source>Empty namespace found from the type provider '{0}'. Use 'null' for the global namespace.</source>
        <target state="translated">'{0}' tür sağlayıcısından boş ad alanı bulundu. Genel ad alanı için 'null' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeGeneric">
        <source>Provided type '{0}' has 'IsGenericType' as true, but generic types are not supported.</source>
        <target state="translated">'{0}' sağlanan türünde 'IsGenericType' true olarak mevcut, ancak genel türler desteklenmiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeAnArray">
        <source>Provided type '{0}' has 'IsArray' as true, but array types are not supported.</source>
        <target state="translated">'{0}' sağlanan türünde 'IsArray' true olarak mevcut, ancak dizi türleri desteklenmiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMethodHasRequirements">
        <source>Invalid member '{0}' on provided type '{1}'. Provided type members must be public, and not be generic, virtual, or abstract.</source>
        <target state="translated">{1}' sağlanan türünde geçersiz '{0}' üyesi. Sağlanan tür üyeleri genel, sanal veya soyut değil ortak olmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedMemberKind">
        <source>Invalid member '{0}' on provided type '{1}'. Only properties, methods and constructors are allowed</source>
        <target state="translated">{1}' sağlanan türünde geçersiz '{0}' üyesi. Yalnızca özelliklere, metotlara ve oluşturuculara izin verilir</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanReadButHasNoGetter">
        <source>Property '{0}' on provided type '{1}' has CanRead=true but there was no value from GetGetMethod()</source>
        <target state="translated">{1}' sağlanan türündeki '{0}' özelliğinde CanRead=true var, ancak GetGetMethod() yönteminden bir değer yok</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasGetterButNoCanRead">
        <source>Property '{0}' on provided type '{1}' has CanRead=false but GetGetMethod() returned a method</source>
        <target state="translated">{1}' sağlanan türündeki '{0}' özelliğinde CanRead=false var, ancak GetGetMethod() metodu bir metot döndürdü</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanWriteButHasNoSetter">
        <source>Property '{0}' on provided type '{1}' has CanWrite=true but there was no value from GetSetMethod()</source>
        <target state="translated">{1}' sağlanan türündeki '{0}' özelliğinde CanWrite=true var, ancak GetSetMethod() yönteminden bir değer yok</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasSetterButNoCanWrite">
        <source>Property '{0}' on provided type '{1}' has CanWrite=false but GetSetMethod() returned a method</source>
        <target state="translated">{1}' sağlanan türündeki '{0}' özelliğinde CanWrite=false var, ancak GetSetMethod() metodu bir metot döndürdü</target>
        <note />
      </trans-unit>
      <trans-unit id="etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
        <source>One or more errors seen during provided type setup</source>
        <target state="translated">Sağlanan tür ayarları sırasında bir veya daha fazla hata görüldü</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedTypeMember">
        <source>Unexpected exception from provided type '{0}' member '{1}': {2}</source>
        <target state="translated">{0}' sağlanan türü '{1}' üyesinden beklenmeyen özel durum: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedConstantType">
        <source>Unsupported constant type '{0}'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal.</source>
        <target state="translated">Desteklenmeyen sabit türü '{0}'. Tür sağlayıcıları tarafından sağlanan alıntılar yalnızca basit sabitler içerebilir. Tür sağlayıcısı uygulamasının; sağlanmış alıntı sabit değerinin dışında bildirilen bir değer, alıntı sabit değerinin içindeki bir 'let' bağlaması olacak şekilde taşınarak ayarlanması gerekebilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedProvidedExpression">
        <source>Unsupported expression '{0}' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.</source>
        <target state="translated">Tür sağlayıcısından desteklenmeyen '{0}' ifadesi. Bu tür sağlayıcısının yazarı sizseniz, farklı bir sağlanan ifade sağlayacak şekilde ayarlamayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedName">
        <source>Expected provided type named '{0}' but provided type has 'Name' with value '{1}'</source>
        <target state="translated">{0}' adlı sağlanan tür bekleniyordu ancak sağlanan türde '{1}' değerli 'Name' öğesi var</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoAdd">
        <source>Event '{0}' on provided type '{1}' has no value from GetAddMethod()</source>
        <target state="translated">{1}' sağlanan türündeki '{0}' olayının bir GetAddMethod() değeri yok</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoRemove">
        <source>Event '{0}' on provided type '{1}' has no value from GetRemoveMethod()</source>
        <target state="translated">{1}' sağlanan türündeki '{0}' olayının bir GetRemoveMethod() değeri yok</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssembly">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded from path '{2}'. The exception reported was: {3} - {4}</source>
        <target state="translated">'{0}' bütünleştirilmiş kod özniteliği, '{2}' yolundan yüklenemeyen '{1}' tasarımcı bütünleştirilmiş koduna başvuruyor. Bildirilen özel durum: {3} - {4}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderDoesNotHaveValidConstructor">
        <source>The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected.</source>
        <target state="translated">Tür sağlayıcısının geçerli bir oluşturucusu yok. Hiç bağımsız değişken almayan veya 'TypeProviderConfig' türü bağımsız değişken alan bir oluşturucu bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderError">
        <source>The type provider '{0}' reported an error: {1}</source>
        <target state="translated">Tür sağlayıcısı '{0}' bir hata bildirdi: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectParameterExpression">
        <source>The type provider '{0}' used an invalid parameter in the ParameterExpression: {1}</source>
        <target state="translated">Tür sağlayıcısı '{0}', ParameterExpression ifadesinde geçersiz parametre kullandı: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedMethod">
        <source>The type provider '{0}' provided a method with a name '{1}' and metadata token '{2}', which is not reported among its methods of its declaring type '{3}'</source>
        <target state="translated">Tür sağlayıcısı '{0}', kendisinin '{3}' tanımlayan türünün metotları arasında bildirilmeyen '{1}' adlı ve meta veri belirteci '{2}' olan bir metot sağladı</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedConstructor">
        <source>The type provider '{0}' provided a constructor which is not reported among the constructors of its declaring type '{1}'</source>
        <target state="translated">Tür sağlayıcısı '{0}', kendisinin '{1}' tanımlayan türünün oluşturucuları arasında bildirilmeyen bir oluşturucu sağladı</target>
        <note />
      </trans-unit>
      <trans-unit id="etDirectReferenceToGeneratedTypeNotAllowed">
        <source>A direct reference to the generated type '{0}' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = &lt;path&gt;'. This indicates that a type provider adds generated types to your assembly.</source>
        <target state="translated">Oluşturulan '{0}' türüne doğrudan başvuruya izin verilmez. Bunun yerine bir tür tanımı (ör. 'type TypeAlias = &lt;path&gt;') kullanın. Bu, bir tür sağlayıcısının derlemeniz için oluşturulmuş türler eklediğini gösterir.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedPath">
        <source>Expected provided type with path '{0}' but provided type has path '{1}'</source>
        <target state="translated">Yolu '{0}' olan bir sağlanan tür bekleniyordu ancak sağlanan türde '{1}' yolu var</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedNullFromProvidedTypeMember">
        <source>Unexpected 'null' return value from provided type '{0}' member '{1}'</source>
        <target state="translated">{0}' sağlanan türü '{1}' üyesinden beklenmeyen 'null' dönüş değeri</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedMemberMember">
        <source>Unexpected exception from member '{0}' of provided type '{1}' member '{2}': {3}</source>
        <target state="translated">{1}' sağlanan türü '{2}' üyesinin '{0}' üyesinden beklenmeyen özel durum: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
        <source>Nested provided types do not take static arguments or generic parameters</source>
        <target state="translated">İç içe sağlanan türler bağımsız değişken veya genel parametre almaz</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidStaticArgument">
        <source>Invalid static argument to provided type. Expected an argument of kind '{0}'.</source>
        <target state="translated">Sağlanan türe, geçersiz statik bağımsız değişken verildi. '{0}' türünden bir bağımsız değişken bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToType">
        <source>An error occured applying the static arguments to a provided type</source>
        <target state="translated">Sağlanan türe statik bağımsız değişkenler uygulanırken bir hata oluştu</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnknownStaticArgumentKind">
        <source>Unknown static argument kind '{0}' when resolving a reference to a provided type or method '{1}'</source>
        <target state="translated">Sağlanan '{1}' türüne yapılan bir başvuru çözümlenirken '{0}' türünde bilinmeyen statik bağımsız değişken</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidNamespaceForProvidedType">
        <source>invalid namespace for provided type</source>
        <target state="translated">sağlanan tür için geçersiz ad alanı</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidFullNameForProvidedType">
        <source>invalid full name for provided type</source>
        <target state="translated">sağlanan tür için geçersiz tam ad</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderReturnedNull">
        <source>The type provider returned 'null', which is not a valid return value from '{0}'</source>
        <target state="translated">Tür sağlayıcısı 'null' döndürdü; bu '{0}' öğesinden gelen geçerli bir dönüş değeri değil</target>
        <note />
      </trans-unit>
      <trans-unit id="etTypeProviderConstructorException">
        <source>The type provider constructor has thrown an exception: {0}</source>
        <target state="translated">Tür sağlayıcısı oluşturucu bir özel durum oluşturdu: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullProvidedExpression">
        <source>Type provider '{0}' returned null from GetInvokerExpression.</source>
        <target state="translated">'{0}' tür sağlayıcısı GetInvokerExpression yönteminden null döndürdü.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedTypeHadWrongName">
        <source>The type provider '{0}' returned an invalid type from 'ApplyStaticArguments'. A type with name '{1}' was expected, but a type with name '{2}' was returned.</source>
        <target state="translated">{0}' tür sağlayıcısı 'ApplyStaticArguments' yönteminden geçersiz bir tür döndürdü. '{1}' adlı tür bekleniyordu, ancak '{2}' adlı tür döndürüldü.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedMethodHadWrongName">
        <source>The type provider '{0}' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '{1}' was expected, but a method with name '{2}' was returned.</source>
        <target state="translated">Tür sağlayıcısı '{0}', 'ApplyStaticArgumentsForMethod' öğesinden geçersiz bir metot döndürdü. '{1}' adlı bir metot bekleniyordu ancak '{2}' adlı bir metot döndürüldü.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLossy">
        <source>This type test or downcast will erase the provided type '{0}' to the type '{1}'</source>
        <target state="translated">Bu tür testi veya alt türe çevirme işlemi '{0}' sağlanan türünü '{1}' türüne silecek</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCastErased">
        <source>This downcast will erase the provided type '{0}' to the type '{1}'.</source>
        <target state="translated">Bu alt türe çevirme işlemi '{0}' sağlanan türünü '{1}' türüne siler.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestErased">
        <source>This type test with a provided type '{0}' is not allowed because this provided type will be erased to '{1}' at runtime.</source>
        <target state="translated">{0}' sağlanan türü çalışma zamanında '{1}' olarak silineceği için bu sağlanan türe sahip bu tür testine izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromErasedType">
        <source>Cannot inherit from erased provided type</source>
        <target state="translated">Silinmiş sağlanan türden devralınamıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidTypeProviderAssemblyName">
        <source>Assembly '{0}' hase TypeProviderAssembly attribute with invalid value '{1}'. The value should be a valid assembly name</source>
        <target state="translated">{0}' bütünleştirilmiş kodunun geçersiz '{1}' değerli TypeProviderAssembly özniteliği var. Bu değer geçerli bir bütünleştirilmiş kod adı olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameCtor">
        <source>Invalid member name. Members may not have name '.ctor' or '.cctor'</source>
        <target state="translated">Geçersiz üye adı. Üyelerin adı '.ctor' veya '.cctor' olamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInferredGenericTypeGivesRiseToInconsistency">
        <source>The function or member '{0}' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '{1}'.</source>
        <target state="translated">{0}' işlevi veya üyesi, çıkartılan türlerin tutarlı olmasını sağlamak için tanımında başka tür ek açıklamaları gerektirecek şekilde kullanılmış. Çıkartılan imza: '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentCount">
        <source>The number of type arguments did not match: '{0}' given, '{1}' expected. This may be related to a previously reported error.</source>
        <target state="translated">Tür bağımsız değişkenlerinin sayısı eşleşmedi: '{0}' verildi, '{1}' bekleniyordu. Bu, önceden bildirilmiş bir hatayla ilişkili olabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotOverrideSealedMethod">
        <source>Cannot override inherited member '{0}' because it is sealed</source>
        <target state="translated">Devralınan üye '{0}' mühürlü olduğu için geçersiz kılınamıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderErrorWithContext">
        <source>The type provider '{0}' reported an error in the context of provided type '{1}', member '{2}'. The error: {3}</source>
        <target state="translated">Tür sağlayıcısı '{0}', sağlanan tür '{1}', üye '{2}' bağlamında bir hata bildirdi. Hata: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNameException">
        <source>An exception occurred when accessing the '{0}' of a provided type: {1}</source>
        <target state="translated">{1} sağlanan türünün '{0}' öğesine erişirken bir özel durum oluştu</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNullOrEmptyName">
        <source>The '{0}' of a provided type was null or empty.</source>
        <target state="translated">Sağlanan türün '{0}' öğesi null veya boştu.</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInTypeName">
        <source>Character '{0}' is not allowed in provided type name '{1}'</source>
        <target state="translated">{1}' sağlanan tür adında '{0}' karakterine izin verilmez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcJoinMustUseSimplePattern">
        <source>In queries, '{0}' must use a simple pattern</source>
        <target state="translated">Sorgularda, '{0}' basit desen kullanmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMissingCustomOperation">
        <source>A custom query operation for '{0}' is required but not specified</source>
        <target state="translated">'{0}' için özel bir sorgu işlemi gerekiyor ancak belirtilmemiş</target>
        <note />
      </trans-unit>
      <trans-unit id="etBadUnnamedStaticArgs">
        <source>Named static arguments must come after all unnamed static arguments</source>
        <target state="translated">Adlandırılmış statik bağımsız değişkenler, adlandırılmamış statik bağımsız değişkenlerin tümünden sonra gelmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterRequiresAValue">
        <source>The static parameter '{0}' of the provided type or method '{1}' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '{2}&lt;{3}=...&gt;'.</source>
        <target state="translated">Sağlanan '{1}' türünün veya metodunun '{0}' statik parametresi bir değer gerektirir. İsteğe bağlı olarak, tür sağlayıcılarına yönelik statik parametreler adlandırılmış bağımsız değişkenler kullanılarak belirtilebilir, ör. '{2}&lt;{3}=...&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNoStaticParameterWithName">
        <source>No static parameter exists with name '{0}'</source>
        <target state="translated">'{0}' adında hiç statik parametre yok</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterAlreadyHasValue">
        <source>The static parameter '{0}' has already been given a value</source>
        <target state="translated">'{0}' statik parametresine zaten bir değer verildi</target>
        <note />
      </trans-unit>
      <trans-unit id="etMultipleStaticParameterWithName">
        <source>Multiple static parameters exist with name '{0}'</source>
        <target state="translated">'{0}' adında birden çok statik parametre var</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
        <source>A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression</source>
        <target state="translated">Özel işlem, bu hesaplama ifadesinin başka bir kısmında değersiz veya özyinelemeli 'let' bağlaması ile bağlantılı olarak kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedHere">
        <source>A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression</source>
        <target state="translated">Özel işlem, bu hesaplama ifadesi içinde 'use', 'try/with', 'try/finally', 'if/then/else' veya 'match' işleçleri ile bağlantılı olarak kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeOverloaded">
        <source>The custom operation '{0}' refers to a method which is overloaded. The implementations of custom operations may not be overloaded.</source>
        <target state="translated">'{0}' özel işlemi aşırı yüklenmiş bir metoda başvuruyor. Özel işlemlerin uygulamaları aşırı yüklenemez.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIfThenElseMayNotBeUsedWithinQueries">
        <source>An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.</source>
        <target state="translated">Sorgularda if/then/else ifadesi kullanılamaz. Ya if/then ifadesi kullanmayı düşünün ya da onun yerine dizi ifadesi kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
        <source>Invalid argument to 'methodhandleof' during codegen</source>
        <target state="translated">Kod oluşturma sırasında geçersiz 'methodhandleof' bağımsız değişkeni</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceMissingArgument">
        <source>A reference to a provided type was missing a value for the static parameter '{0}'. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">Sağlanan türe yapılan başvuruda '{0}' statik parametresinin bir değeri yoktu. Bir veya daha fazla başvurulan bütünleştirilmiş kodu yeniden derlemeniz gerekiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceInvalidText">
        <source>A reference to a provided type had an invalid value '{0}' for a static parameter. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">Sağlanan türe yapılan başvuruda statik parametre için geçersiz '{0}' değeri vardı. Bir veya daha fazla başvurulan bütünleştirilmiş kodu yeniden derlemeniz gerekiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly">
        <source>'{0}' is not used correctly. This is a custom operation in this query or computation expression.</source>
        <target state="translated">'{0}' doğru kullanılmadı. Bu, geçerli sorguda veya hesaplama ifadesinde özel bir işlemdir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly2">
        <source>'{0}' is not used correctly. Usage: {1}. This is a custom operation in this query or computation expression.</source>
        <target state="translated">'{0}' doğru kullanılmadı. Kullanım: {1}. Bu, geçerli sorgudaki veya hesaplama ifadesindeki özel bir işlemdir.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeJoin">
        <source>{0} var in collection {1} (outerKey = innerKey). Note that parentheses are required after '{2}'</source>
        <target state="translated">{1} koleksiyonunda {0} değişkeni (outerKey = innerKey). '{2}' öğesinden sonra parantez eklenmesi gerektiğini unutmayın</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeGroupJoin">
        <source>{0} var in collection {1} (outerKey = innerKey) into group. Note that parentheses are required after '{2}'</source>
        <target state="translated">{1} koleksiyonunda {0} değişkeni (outerKey = innerKey) gruba eklendi. '{2}' öğesinden sonra parantez eklenmesi gerektiğini unutmayın</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeZip">
        <source>{0} var in collection</source>
        <target state="translated">Koleksiyonda {0} değişkeni</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresVariable">
        <source>'{0}' must be followed by a variable name. Usage: {1}.</source>
        <target state="translated">'{0}' ifadesini değişken adı izlemelidir. Kullanım: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorIncorrectSyntax">
        <source>Incorrect syntax for '{0}'. Usage: {1}.</source>
        <target state="translated">{0}' için hatalı sözdizimi. Kullanım: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresBody">
        <source>'{0}' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... {1} ...</source>
        <target state="translated">'{0}' ifadesi bir 'for' seçim yan tümcesinden sonra gelmelidir ve bu ifadeyi sorgunun geri kalanı izlemelidir. Söz dizimi: ... {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationHasIncorrectArgCount">
        <source>'{0}' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected {1} argument(s), but given {2}.</source>
        <target state="translated">'{0}' hatalı sayıda bağımsız değişkenle kullanıldı. Bu, geçerli sorgudaki veya hesaplama ifadesindeki özel bir işlemdir. {1} bağımsız değişken bekleniyordu, ancak {2} verildi.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterToken">
        <source>Expected an expression after this point</source>
        <target state="translated">Bu noktadan sonra bir ifade bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedTypeAfterToken">
        <source>Expected a type after this point</source>
        <target state="translated">Bu noktadan sonra bir tür bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLBrackLess">
        <source>Unmatched '[&lt;'. Expected closing '&gt;]'</source>
        <target state="translated">Eşleşmeyen '[&lt;'. '&gt;]' kapanışı bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileMatch">
        <source>Unexpected end of input in 'match' expression. Expected 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</source>
        <target state="translated">'match' ifadesinde beklenmeyen giriş sonu. 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTry">
        <source>Unexpected end of input in 'try' expression. Expected 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;'.</source>
        <target state="translated">'try' ifadesinde beklenmeyen giriş sonu. 'try &lt;expr&gt; with &lt;rules&gt;' veya 'try &lt;expr&gt; finally &lt;expr&gt;' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWhile">
        <source>Unexpected end of input in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'while' ifadesinde beklenmeyen giriş sonu. 'while &lt;expr&gt; do &lt;expr&gt;' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFor">
        <source>Unexpected end of input in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'for' ifadesinde beklenmeyen giriş sonu. 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWith">
        <source>Unexpected end of input in 'match' or 'try' expression</source>
        <target state="translated">'match' veya 'try' ifadesinde beklenmeyen giriş sonu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileThen">
        <source>Unexpected end of input in 'then' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Koşullu ifadenin 'then' dalında beklenmeyen giriş sonu. 'if &lt;expr&gt; then &lt;expr&gt;' veya 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileElse">
        <source>Unexpected end of input in 'else' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Koşullu ifadenin 'else' dalında beklenmeyen giriş sonu. 'if &lt;expr&gt; then &lt;expr&gt;' veya 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFunBody">
        <source>Unexpected end of input in body of lambda expression. Expected 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</source>
        <target state="translated">Lambda ifadesinin gövdesinde beklenmeyen giriş sonu. 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeArgs">
        <source>Unexpected end of input in type arguments</source>
        <target state="translated">Tür bağımsız değişkenlerinde beklenmeyen giriş sonu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeSignature">
        <source>Unexpected end of input in type signature</source>
        <target state="translated">Tür imzasında beklenmeyen giriş sonu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeDefinition">
        <source>Unexpected end of input in type definition</source>
        <target state="translated">Tür tanımında beklenmeyen giriş sonu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileObjectMembers">
        <source>Unexpected end of input in object members</source>
        <target state="translated">Nesne üyelerinde beklenmeyen giriş sonu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileDefinition">
        <source>Unexpected end of input in value, function or member definition</source>
        <target state="translated">Değer, işlev veya üye tanımında beklenmeyen giriş sonu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileExpression">
        <source>Unexpected end of input in expression</source>
        <target state="translated">İfadede beklenmeyen giriş sonu</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedNameAfterToken">
        <source>Unexpected end of type. Expected a name after this point.</source>
        <target state="translated">Beklenmeyen tür sonu. Bu noktadan sonra bir ad bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLet">
        <source>Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.</source>
        <target state="translated">Eksik değer veya işlev tanımı. Bu bir ifadeyse ifadenin gövdesi 'let' anahtar sözcüğü ile aynı sütuna girintilenmelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLetBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword.</source>
        <target state="translated">Eksik değer tanımı. Bu bir ifadeyse ifadenin gövdesi 'let!' anahtar sözcüğü ile aynı sütuna girintilenmelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUseBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword.</source>
        <target state="translated">Eksik değer tanımı. Bu bir ifadeyse ifadenin gövdesi 'use!' anahtar sözcüğü ile aynı sütuna girintilenmelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUse">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword.</source>
        <target state="translated">Eksik değer tanımı. Bu bir ifadeyse ifadenin gövdesi 'use' anahtar sözcüğü ile aynı sütuna girintilenmelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsWhileDoExpected">
        <source>Missing 'do' in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'while' ifadesinde 'do' eksik. 'while &lt;expr&gt; do &lt;expr&gt;' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsForDoExpected">
        <source>Missing 'do' in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'for' ifadesinde 'do' eksik. &lt;expr&gt; do &lt;expr&gt;' içinde 'for &lt;pat&gt; bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRelationInJoin">
        <source>Invalid join relation in '{0}'. Expected 'expr &lt;op&gt; expr', where &lt;op&gt; is =, =?, ?= or ?=?.</source>
        <target state="translated">'{0}' içinde geçersiz birleştirme ilişkisi. &lt;op&gt; değerinin =, =?, ?= veya ?=? olduğu 'expr &lt;op&gt; expr' bekleniyordu.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCallsWord">
        <source>Calls</source>
        <target state="translated">Çağrılar</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidNumberOfGenericArguments">
        <source>Invalid number of generic arguments to type '{0}' in provided type. Expected '{1}' arguments, given '{2}'.</source>
        <target state="translated">Sağlanan türdeki '{0}' türünde geçersiz sayıda genel bağımsız değişken. '{1}' bağımsız değişken bekleniyordu, '{2}' verildi.</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument1">
        <source>Invalid value '{0}' for unit-of-measure parameter '{1}'</source>
        <target state="translated">Ölçü birimi parametresi '{1}' için geçersiz '{0}' değeri</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument2">
        <source>Invalid value unit-of-measure parameter '{0}'</source>
        <target state="translated">Geçersiz değerli ölçü birimi parametresi '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyNeedsCanWriteOrCanRead">
        <source>Property '{0}' on provided type '{1}' is neither readable nor writable as it has CanRead=false and CanWrite=false</source>
        <target state="translated">{1}' sağlanan türündeki '{0}' özelliğinde CanRead=false ve CanWrite=false olduğu için özellik okunabilir veya yazılabilir değil</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIntoNeedsRestOfQuery">
        <source>A use of 'into' must be followed by the remainder of the computation</source>
        <target state="translated">'into' kullanımını hesaplamanın geri kalanı izlemelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorDoesntAcceptInto">
        <source>The operator '{0}' does not accept the use of 'into'</source>
        <target state="translated">'{0}' işleci 'into' kullanımını kabul etmez</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationInvalid">
        <source>The definition of the custom operator '{0}' does not use a valid combination of attribute flags</source>
        <target state="translated">'{0}' özel işlecinin tanımı geçerli bir öznitelik bayrakları bileşimi kullanmıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisTypeMayNotHaveACLIMutableAttribute">
        <source>This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute.</source>
        <target state="translated">Bu tür tanımının 'CLIMutable' özniteliği olamaz. Yalnızca kayıt türleri bu özniteliğe sahip olabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAutoPropertyRequiresImplicitConstructionSequence">
        <source>'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">'member val' tanımlarına yalnızca birincil oluşturucusu olan türlerde izin verilir. Tür tanımınıza bağımsız değişkenler eklemeyi düşünün, örn. 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSet">
        <source>Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Özellik tanımları değişebilir olarak tanımlanamaz. Bu özelliğin ayarlanabileceğini belirtmek için 'member val PropertyName = expr with get,set' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
        <source>To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Bu özelliğin ayarlanabileceğini belirtmek için 'member val PropertyName = expr with get,set' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefsOfByrefs">
        <source>Type '{0}' is illegal because in byref&lt;T&gt;, T cannot contain byref types.</source>
        <target state="translated">byref&lt;T&gt;, içindeki T byref türleri içeremeyeceğinden '{0}' türü geçersizdir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastopsMaxArrayThirtyTwo">
        <source>F# supports array ranks between 1 and 32. The value {0} is not allowed.</source>
        <target state="translated">F#, 1 ile 32 arasındaki dizi derecelerini destekler. {0} değeri kullanılamaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoIntegerForLoopInQuery">
        <source>In queries, use the form 'for x in n .. m do ...' for ranging over integers</source>
        <target state="translated">Sorgularda, tamsayı aralığını belirlemek için 'for x in n .. m do ...' biçimini kullanın</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoWhileInQuery">
        <source>'while' expressions may not be used in queries</source>
        <target state="translated">'while' ifadeleri sorgularda kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoTryFinallyInQuery">
        <source>'try/finally' expressions may not be used in queries</source>
        <target state="translated">'try/finally' ifadeleri sorgularda kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseMayNotBeUsedInQueries">
        <source>'use' expressions may not be used in queries</source>
        <target state="translated">'use' ifadeleri sorgularda kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindMayNotBeUsedInQueries">
        <source>'let!', 'use!' and 'do!' expressions may not be used in queries</source>
        <target state="translated">'let!', 'use!' ve 'do!' ifadeleri sorgularda kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnMayNotBeUsedInQueries">
        <source>'return' and 'return!' may not be used in queries</source>
        <target state="translated">'return' ve 'return!' sorgularda kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryOperator">
        <source>This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type.</source>
        <target state="translated">Bu bilinen bir sorgu işleci değil. Sorgu işleçleri, 'QueryBuilder' türündeki ilgili metotlar kullanılarak tanımlanan 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' ve 'averageBy' gibi tanımlayıcılardır.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryWithMayNotBeUsedInQueries">
        <source>'try/with' expressions may not be used in queries</source>
        <target state="translated">'try/with' ifadeleri sorgularda kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonSimpleLetBindingInQuery">
        <source>This 'let' definition may not be used in a query. Only simple value definitions may be used in queries.</source>
        <target state="translated">Bu 'let' tanımı sorguda kullanılamaz. Sorgularda yalnızca basit değer tanımları kullanılabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTooManyStaticParameters">
        <source>Too many static parameters. Expected at most {0} parameters, but got {1} unnamed and {2} named parameters.</source>
        <target state="translated">Çok fazla statik parametre. En çok {0} parametre bekleniyordu, ancak {1} adlandırılmamış ve {2} adlandırılmış parametre alındı.</target>
        <note />
      </trans-unit>
      <trans-unit id="infosInvalidProvidedLiteralValue">
        <source>Invalid provided literal value '{0}'</source>
        <target state="translated">Sağlanan sabit değer '{0}' geçersiz</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidPlatformTarget">
        <source>The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead.</source>
        <target state="translated">'anycpu32bitpreferred' platformu yalnızca EXE hedefleriyle kullanılabilir. Onun yerine 'anycpu' kullanmalısınız.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisValueMayNotBeInlined">
        <source>This member, function or value declaration may not be declared 'inline'</source>
        <target state="translated">Bu üye, işlev veya değer bildirimi 'inline' olarak tanımlanamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="etErasedTypeUsedInGeneration">
        <source>The provider '{0}' returned a non-generated type '{1}' in the context of a set of generated types. Consider adjusting the type provider to only return generated types.</source>
        <target state="translated">{0}' sağlayıcısı, oluşturulmuş türler kümesi bağlamında oluşturulmamış '{1}' türünü döndürdü. Tür sağlayıcısını yalnızca oluşturulmuş türleri döndürecek şekilde ayarlamayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryBinaryOperator">
        <source>Arguments to query operators may require parentheses, e.g. 'where (x &gt; y)' or 'groupBy (x.Length / 10)'</source>
        <target state="translated">Sorgu işleçlerine yönelik bağımsız değişkenler parantez gerektirebilir, ör. 'where (x &gt; y)' veya 'groupBy (x.Length / 10)'</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoSetOfHole">
        <source>A quotation may not involve an assignment to or taking the address of a captured local variable</source>
        <target state="translated">Bir alıntı, yakalanan yerel değişkenin adresine atama içeremez veya bu adresi alamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloads1">
        <source>+ 1 overload</source>
        <target state="translated">+ 1 aşırı yükleme</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloadsN">
        <source>+ {0} overloads</source>
        <target state="translated">+ {0} aşırı yükleme</target>
        <note />
      </trans-unit>
      <trans-unit id="erasedTo">
        <source>Erased to</source>
        <target state="translated">Silindiği öğe:</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnfinishedExpression">
        <source>Unexpected token '{0}' or incomplete expression</source>
        <target state="translated">Beklenmeyen '{0}' belirteci veya eksik ifade</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributeOnIncompleteCode">
        <source>Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.</source>
        <target state="translated">Bu özniteliğin kod hedefi, muhtemelen öznitelikten sonraki kod eksik olduğu için bulunamıyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeNameCannotBeEmpty">
        <source>Type name cannot be empty.</source>
        <target state="translated">Tür adı boş olamaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemReadingAssembly">
        <source>Problem reading assembly '{0}': {1}</source>
        <target state="translated">Bütünleştirilmiş kod okuma hatası: '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTPFieldMustBeLiteral">
        <source>Invalid provided field. Provided fields of erased provided types must be literals.</source>
        <target state="translated">Geçersiz sağlanan alan. Silinmiş sağlanan türlerin sağlanan alanları sabit değerler olmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="loadingDescription">
        <source>(loading description...)</source>
        <target state="translated">(açıklama yükleniyor...)</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionUnavailable">
        <source>(description unavailable...)</source>
        <target state="translated">(açıklama yok...)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTyparMultipleClassConstraints">
        <source>A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.</source>
        <target state="translated">Bir tür değişkeni, birden çok farklı sınıf türü tarafından kısıtlanmış. Bir tür değişkeninin yalnızca bir sınıf kısıtlaması olabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMatchMayNotBeUsedWithQuery">
        <source>'match' expressions may not be used in queries</source>
        <target state="translated">'match' ifadeleri sorgularda kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonTripleArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 3 arguments</source>
        <target state="translated">Infix işleç üyesi '{0}', {1} başlangıç bağımsız değişkenine sahip. 3 bağımsız değişkenli bir demet bekleniyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="cannotResolveNullableOperators">
        <source>The operator '{0}' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">'{0}' işleci çözümlenemiyor. 'Microsoft.FSharp.Linq.NullableOperators' modülünü açmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorRequiresIn">
        <source>'{0}' must be followed by 'in'. Usage: {1}.</source>
        <target state="translated">'{0}' öğesinden sonra 'in' gelmelidir. Kullanım: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalMemberVarInObjectImplementation">
        <source>Neither 'member val' nor 'override val' definitions are permitted in object expressions.</source>
        <target state="translated">Nesne ifadelerinde 'member val' ve 'override val' tanımlarına izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyCopyAndUpdateRecordInvalid">
        <source>Copy-and-update record expressions must include at least one field.</source>
        <target state="translated">Kayıt kopyalama ve güncelleştirme ifadeleri en az bir alan içermelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnderscoreInvalidFieldName">
        <source>'_' cannot be used as field name</source>
        <target state="translated">'_' alan adı olarak kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGeneratedTypesShouldBeInternalOrPrivate">
        <source>The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'.</source>
        <target state="translated">Tür sağlayıcısının bu kullanımının oluşturduğu sağlanan türler diğer F# bütünleştirilmiş kodlarından kullanılamaz ve iç veya özel olarak işaretlenmeleri gerekir. 'type internal TypeName = ...' veya 'type private TypeName = ...' kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterAndSetterHaveSamePropertyType">
        <source>A property's getter and setter must have the same type. Property '{0}' has getter of type '{1}' but setter of type '{2}'.</source>
        <target state="translated">Bir özelliğin alıcısı ve ayarlayıcısı aynı türde olmalıdır. '{0}' özelliğinin alıcı türü '{1}' ancak ayarlayıcı türü '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRuntimeSuppliedMethodCannotBeUsedInUserCode">
        <source>Array method '{0}' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.</source>
        <target state="translated">Dizi metodu '{0}', çalışma zamanı tarafından sağlanır ve kodda doğrudan kullanılamaz. Dizi öğeleriyle işlemler için LanguagePrimitives.IntrinsicFunctions modülünden GetArray/SetArray işlev ailesini kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName">
        <source>The union case '{0}' does not have a field named '{1}'.</source>
        <target state="translated">'{0}' birleşim durumunun '{1}' adlı bir alanı yok.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseFieldCannotBeUsedMoreThanOnce">
        <source>Union case/exception field '{0}' cannot be used more than once.</source>
        <target state="translated">'{0}' birleşim durumu/özel durumu alanı birden çok kez kullanılamaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameIsUsedModeThanOnce">
        <source>Named field '{0}' is used more than once.</source>
        <target state="translated">Adlandırılmış alan '{0}', birden çok kez kullanıldı.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameConflictsWithGeneratedNameForAnonymousField">
        <source>Named field '{0}' conflicts with autogenerated name for anonymous field.</source>
        <target state="translated">Adlandırılmış alan '{0}', anonim alanın otomatik oluşturulmuş adıyla çakışıyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConstantExpressionOverflow">
        <source>This literal expression or attribute argument results in an arithmetic overflow.</source>
        <target state="translated">Bu sabit değer ifadesi veya öznitelik bağımsız değişkeni aritmetik taşma ile sonuçlanıyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalStructTypeForConstantExpression">
        <source>This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.</source>
        <target state="translated">Bu geçerli bir sabit değer ifadesi değil. [&lt;Literal&gt;] özniteliği yoksayılacak.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscSystemRuntimeInteropServicesIsRequired">
        <source>System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.</source>
        <target state="translated">UnknownWrapper\DispatchWrapper sınıflarını kullanmak için System.Runtime.InteropServices bütünleştirilmiş kodu gerekiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="abImplicitHeapAllocation">
        <source>The mutable local '{0}' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.</source>
        <target state="translated">Değişebilir yerel '{0}' bir kapanış tarafından yakalandığından, örtülü bir biçimde bir başvuru hücresi olarak ayrıldı. Bu uyarı, yalnızca örtülü ayırma işlemlerinin gerçekleştirildiğine dair bilgilendirme amacı taşır.</target>
        <note />
      </trans-unit>
      <trans-unit id="estApplyStaticArgumentsForMethodNotImplemented">
        <source>A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid</source>
        <target state="translated">Bir tür sağlayıcısı tarafından GetStaticParametersForMethod uygulandı, ancak ApplyStaticArgumentsForMethod uygulanmadı veya geçersiz</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToMethod">
        <source>An error occured applying the static arguments to a provided method</source>
        <target state="translated">Sağlanan metoda statik bağımsız değişkenler uygulanırken bir sorun oluştu</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexUnexpectedChar">
        <source>Unexpected character '{0}' in preprocessor expression</source>
        <target state="translated">Önişlemci ifadesinde beklenmeyen karakter: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsUnexpectedToken">
        <source>Unexpected token '{0}' in preprocessor expression</source>
        <target state="translated">Önişlemci ifadesinde beklenmeyen belirteç: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsIncompleteExpression">
        <source>Incomplete preprocessor expression</source>
        <target state="translated">Eksik önişlemci ifadesi</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsMissingToken">
        <source>Missing token '{0}' in preprocessor expression</source>
        <target state="translated">Önişlemci ifadesinde eksik belirteç: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleMissingDefinition">
        <source>An error occurred while reading the F# metadata node at position {0} in table '{1}' of assembly '{2}'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.</source>
        <target state="translated">{2}' bütünleştirilmiş kodunun '{1}' tablosundaki {0} konumunda bulunan F# meta veri düğümü okunurken bir hata oluştu. Düğüm, eşleşen bildirim içermiyor. Lütfen bu uyarıyı bildirin. Kullandığınız F# bütünleştirilmiş kodunu yeniden derlemeniz gerekebilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScope">
        <source>Type inference caused the type variable {0} to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.</source>
        <target state="translated">Tür çıkarımı, {0} tür değişkeninin kapsamından çıkmasına neden oldu. Açık bir tür parametresi bildirimi ekleyebilir ya da kodunuzu ayarlayarak daha az genel hale getirebilirsiniz.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScopeAnon">
        <source>Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.</source>
        <target state="translated">Tür çıkarımı, bir tür değişkeninin kapsamından çıkmasına neden oldu. Tür açıklamaları ekleyerek kodunuzu daha az genel hale getirebilirsiniz.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkRaiseFamilyFunctionArgumentCount">
        <source>Redundant arguments are being ignored in function '{0}'. Expected {1} but got {2} arguments.</source>
        <target state="translated">{0}' işlevindeki gereksiz bağımsız değişkenler yoksayılıyor. {1} bekleniyordu, ancak {2} bağımsız değişken alındı.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkLowercaseLiteralBindingInPattern">
        <source>Lowercase literal '{0}' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.</source>
        <target state="translated">Küçük harf '{0}' değişmez değeri aynı ada sahip yeni bir desen tarafından engelleniyor. Adlandırılmış desenler olarak yalnızca büyük harf ve module ön eki almış değişmez değerler kullanılabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralDoesNotTakeArguments">
        <source>This literal pattern does not take arguments</source>
        <target state="translated">Bu sabit değer deseninde bağımsız değişken kullanılamaz</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalInAugmentation">
        <source>Constructors are not permitted as extension members - they must be defined as part of the original definition of the type</source>
        <target state="translated">Oluşturucuların, uzantı üyesi olarak kullanılmalarına izin verilmez. Türün özgün tanımının bir parçası olarak tanımlanmaları gerekir.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidResponseFile">
        <source>Invalid response file '{0}' ( '{1}' )</source>
        <target state="translated">Geçersiz yanıt dosyası '{0}' ( '{1}' )</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNotFound">
        <source>Response file '{0}' not found in '{1}'</source>
        <target state="translated">Yanıt dosyası '{0}', '{1}' içinde bulunamadı</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNameInvalid">
        <source>Response file name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">Yanıt dosyası adı '{0}' boş, geçersiz karakter içeriyor, mutlak yolu olmayan bir sürücüyü belirtiyor veya çok uzun</target>
        <note />
      </trans-unit>
      <trans-unit id="fsharpCoreNotFoundToBeCopied">
        <source>Cannot find FSharp.Core.dll in compiler's directory</source>
        <target state="translated">Derleyici dizininde FSharp.Core.dll bulunamıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleStructMismatch">
        <source>One tuple type is a struct tuple, the other is a reference tuple</source>
        <target state="translated">Demetlerden biri yapı demeti, diğeri ise başvuru demeti</target>
        <note />
      </trans-unit>
      <trans-unit id="etMissingStaticArgumentsToMethod">
        <source>This provided method requires static parameters</source>
        <target state="translated">Sağlanan bu metot statik parametreler gerektirir</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcast">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'.</source>
        <target state="translated">{0} türünden {1} türüne dönüştürme, bir alt türe çevirme değil, derleme zamanında güvenli bir üst türe çevirmedir. 'downcast' yerine 'upcast' kullanmayı düşünün.</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcastOperator">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.</source>
        <target state="translated">{0}-{1} dönüşümü bir alt türe çevirme değil, derleme zamanında güvenli bir üst türe çevirmedir. :?&gt; (alt türe çevirme) işleci yerine :&gt; (üst türe çevirme) işlecini kullanmayı göz önünde bulundurun.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecImplied">
        <source>The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored</source>
        <target state="translated">Bu modüldeki 'rec', bir dış 'rec' bildirimi tarafından kapsanıyor ve yoksayılıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenFirstInMutRec">
        <source>In a recursive declaration group, 'open' declarations must come first in each module</source>
        <target state="translated">Özyinelemeli bir bildirim grubunda, 'open' bildirimleri her modülde en başta olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbrevFirstInMutRec">
        <source>In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations</source>
        <target state="translated">Özyinelemeli bir bildirim grubunda modül kısaltmaları, tüm 'open' bildirimleri ve diğer bildirimlerden sonra gelmelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedMutRecDecl">
        <source>This declaration is not supported in recursive declaration groups</source>
        <target state="translated">Bu bildirim, özyinelemeli bildirim gruplarında desteklenmez</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidUseOfRec">
        <source>Invalid use of 'rec' keyword</source>
        <target state="translated">'rec' anahtar sözcüğü geçersiz şekilde kullanıldı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructUnionMultiCaseDistinctFields">
        <source>If a union type has more than one case and is a struct, then all fields within the union type must be given unique names.</source>
        <target state="translated">Bir birleşim türü büyük ve küçük harfler içeriyorsa ve bir yapıysa, birleşim türü içindeki tüm alanlara benzersiz adlar verilmelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerMemberNameIsOverriden">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">{0}' parametresi için geçerli olan CallerMemberNameAttribute öğesinin hiçbir etkisi olmaz. CallerFilePathAttribute tarafından geçersiz kılındı.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFixedNotAllowed">
        <source>Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'</source>
        <target state="translated">Geçersiz 'fixed' kullanımı. 'fixed' yalnızca 'use x = fixed expr' biçimindeki bir bildirimde kullanılabilir. Burada ifade bir dizi, bir alanın adresi, bir dizi öğesinin adresi veya bir dizedir</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindOffsetToStringData">
        <source>Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression.</source>
        <target state="translated">'fixed' ifadesi derlenirken başvurularda System.Runtime.CompilerServices.OffsetToStringData metodu bulunamadı.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedActivePattern">
        <source>{0} is an active pattern and cannot be treated as a discriminated union case with named fields.</source>
        <target state="translated">{0} etkin bir desen ve adlandırılmış alanlar içeren bir ayırt edici birleşim durumu olarak değerlendirilemez.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultParameterValueNotAppropriateForArgument">
        <source>The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'.</source>
        <target state="translated">Varsayılan değer, bağımsız değişkenle aynı türde değil. DefaultParameterValue özniteliği ve tüm İsteğe Bağlı öznitelikler yoksayılacak. Not: 'null'un doğru tür ile eklenmesi gerekir, örneğin 'DefaultParameterValue(null:obj)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGlobalsSystemTypeNotFound">
        <source>The system type '{0}' was required but no referenced system DLL contained this type</source>
        <target state="translated">'{0}' sistem türü gerekiyordu, ancak başvurulan hiçbir sistem DLL'si bu türü içermiyordu</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberHasMultiplePossibleDispatchSlots">
        <source>The member '{0}' matches multiple overloads of the same method.\nPlease restrict it to one of the following:{1}.</source>
        <target state="translated">{0}' adlı üye, aynı metodun birden fazla aşırı yüklemesiyle eşleşiyor.\nLütfen şunlardan biriyle kısıtlayın: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="methodIsNotStatic">
        <source>Method or object constructor '{0}' is not static</source>
        <target state="translated">'{0}' metodu veya nesne oluşturucusu, statik değil</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolEqualsInsteadOfIn">
        <source>Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?</source>
        <target state="translated">İfadede beklenmeyen '=' sembolü. Bunun yerine 'for x in y .. z do' kullanmak mı istemiştiniz?</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAbstract">
        <source>Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</source>
        <target state="translated">İçinde bildirildiği türde hiç uygulaması olmayan veya sanal olup varsayılan uygulaması olan bir metodu belirtir.</target>
        <note />
      </trans-unit>
      <trans-unit id="keyworkDescriptionAnd">
        <source>Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</source>
        <target state="translated">Karşılıklı yinelemeli bağlamalarda, özellik bildirimlerinde ve genel parametreler üzerinde birden çok kısıtlamayla kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAs">
        <source>Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</source>
        <target state="translated">Geçerli sınıf nesnesine bir nesne adı vermek için kullanılır. Desen eşleştirmesi içindeki bir tam desene ad vermek için de kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAssert">
        <source>Used to verify code during debugging.</source>
        <target state="translated">Hata ayıklama sırasında kodu doğrulamak için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBase">
        <source>Used as the name of the base class object.</source>
        <target state="translated">Temel sınıf nesnesinin adı olarak kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBegin">
        <source>In verbose syntax, indicates the start of a code block.</source>
        <target state="translated">Ayrıntılı söz diziminde kod bloğunun başlangıcını gösterir.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionClass">
        <source>In verbose syntax, indicates the start of a class definition.</source>
        <target state="translated">Ayrıntılı söz diziminde, sınıf tanımının başlangıcını belirtir.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDefault">
        <source>Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</source>
        <target state="translated">Soyut bir metodun uygulamasını belirtir; sanal metot oluşturmak üzere soyut metot bildirimi ile birlikte kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDelegate">
        <source>Used to declare a delegate.</source>
        <target state="translated">Bir temsilci bildirmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDo">
        <source>Used in looping constructs or to execute imperative code.</source>
        <target state="translated">Döngü yapılarında veya kesinlik temelli kod yürütmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDone">
        <source>In verbose syntax, indicates the end of a block of code in a looping expression.</source>
        <target state="translated">Ayrıntılı söz diziminde, döngü ifadesindeki bir kod bloğunun sonunu gösterir.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDowncast">
        <source>Used to convert to a type that is lower in the inheritance chain.</source>
        <target state="translated">Devralma zincirinde daha aşağıda bulunan bir türe dönüştürmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDownto">
        <source>In a for expression, used when counting in reverse.</source>
        <target state="translated">Bir for ifadesinde, tersten sayım sırasında kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElif">
        <source>Used in conditional branching. A short form of else if.</source>
        <target state="translated">Koşullu dallanmada kullanılır. else if'in kısa bir biçimidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElse">
        <source>Used in conditional branching.</source>
        <target state="translated">Koşullu dallanmada kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionEnd">
        <source>In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</source>
        <target state="translated">Tür tanımlarında ve tür uzantılarında, üye tanımları bölümünün sonunu gösterir. Ayrıntılı söz diziminde, begin anahtar sözcüğü ile başlayan bir kod bloğunun sonunu belirtmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionException">
        <source>Used to declare an exception type.</source>
        <target state="translated">Bir özel durum türünü bildirmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionExtern">
        <source>Indicates that a declared program element is defined in another binary or assembly.</source>
        <target state="translated">Bildirilen bir program öğesinin başka bir ikili dosyada veya bütünleştirilmiş kodda tanımlandığını belirtir.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTrueFalse">
        <source>Used as a Boolean literal.</source>
        <target state="translated">Boolean sabit değeri olarak kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFinally">
        <source>Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</source>
        <target state="translated">Özel durumun oluşup oluşmadığına bakılmaksızın yürütülen bir kod bloğunu tanıtmak için try ile birlikte kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFor">
        <source>Used in looping constructs.</source>
        <target state="translated">Döngü yapılarında kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFun">
        <source>Used in lambda expressions, also known as anonymous functions.</source>
        <target state="translated">Anonim işlevler olarak da bilinen lambda ifadelerinde kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFunction">
        <source>Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</source>
        <target state="translated">Tek bir bağımsız değişkende desen eşleştirmesine sahip bir lambda ifadesinde fun anahtar sözcüğünün ve match ifadesinin daha kısa bir alternatifi olarak kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionGlobal">
        <source>Used to reference the top-level .NET namespace.</source>
        <target state="translated">En üst düzey .NET ad alanına başvurmak için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIf">
        <source>Used in conditional branching constructs.</source>
        <target state="translated">Koşullu dallanma yapılarında kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIn">
        <source>Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</source>
        <target state="translated">Dizi ifadeleri için ve ayrıntılı söz diziminde ifadeleri bağlamalardan ayırmak için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInherit">
        <source>Used to specify a base class or base interface.</source>
        <target state="translated">Temel sınıfı veya temel arabirimi belirtmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInline">
        <source>Used to indicate a function that should be integrated directly into the caller's code.</source>
        <target state="translated">Doğrudan çağıranın koduyla tümleştirilmesi gereken bir işlevi belirtmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInterface">
        <source>Used to declare and implement interfaces.</source>
        <target state="translated">Arabirimleri bildirmek ve uygulamak için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInternal">
        <source>Used to specify that a member is visible inside an assembly but not outside it.</source>
        <target state="translated">Bir üyenin bütünleştirilmiş kodun içinde görünür olduğunu, dışında ise görünmediğini belirtmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLazy">
        <source>Used to specify a computation that is to be performed only when a result is needed.</source>
        <target state="translated">Yalnızca bir sonuç gerekli olduğunda gerçekleştirilecek bir hesaplamayı belirtmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLet">
        <source>Used to associate, or bind, a name to a value or function.</source>
        <target state="translated">Adı bir değer veya işlevle ilişkilendirmek ya da bağlamak için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLetBang">
        <source>Used in computation expressions to bind a name to the result of another computation expression.</source>
        <target state="translated">Hesaplama ifadelerinde bir adın başka bir hesaplama ifadesinin sonucuna bağlanması için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatch">
        <source>Used to branch by comparing a value to a pattern.</source>
        <target state="translated">Değeri bir desenle karşılaştırarak dal oluşturmak için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMember">
        <source>Used to declare a property or method in an object type.</source>
        <target state="translated">Bir nesne türü içinde özellik veya metot bildirmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionModule">
        <source>Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</source>
        <target state="translated">Bir adı diğer kodlardan mantıksal olarak ayırmak amacıyla, birbiriyle ilişkili bir tür, değer ve işlev grubuyla ilişkilendirmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMutable">
        <source>Used to declare a variable, that is, a value that can be changed.</source>
        <target state="translated">Bir değişkeni, başka bir deyişle değiştirilebilir bir değeri bildirmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNamespace">
        <source>Used to associate a name with a group of related types and modules, to logically separate it from other code.</source>
        <target state="translated">Bir adı diğer kodlardan mantıksal olarak ayırmak amacıyla, birbiriyle ilişkili bir tür ve modül grubuyla ilişkilendirmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNew">
        <source>Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.</source>
        <target state="translated">Nesne oluşturan veya oluşturabilen bir oluşturucuyu bildirmek, tanımlamak veya çağırmak için kullanılır. Ayrıca bir türün belirli bir oluşturucusu olması gerektiğini belirtmek için genel parametre kısıtlamalarında kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNot">
        <source>Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</source>
        <target state="translated">Aslında bir anahtar sözcük değildir. Ancak not yapısı, bir genel parametre kısıtlaması olarak kombine şekilde kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNull">
        <source>Indicates the absence of an object. Also used in generic parameter constraints.</source>
        <target state="translated">Bir nesnenin olmadığını belirtir. Ayrıca genel parametre kısıtlamalarında kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOf">
        <source>Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</source>
        <target state="translated">Değer kategorilerinin türünü belirtmek için ayırt edici birleşimlerde, temsilci ve özel durum bildirimlerinde kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOpen">
        <source>Used to make the contents of a namespace or module available without qualification.</source>
        <target state="translated">Bir ad alanının veya modülün içeriğinin sınırlama olmaksızın kullanılabilmesini sağlamak için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOr">
        <source>Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.</source>
        <target state="translated">Bir Boolean değeri veya işleci olarak Boolean koşullarıyla birlikte kullanılır. Eşdeğeri || simgesidir. Ayrıca üye kısıtlamalarında kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOverride">
        <source>Used to implement a version of an abstract or virtual method that differs from the base version.</source>
        <target state="translated">Soyut veya sanal metodun temel sürümden farklı olan bir sürümünü uygulamak için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPrivate">
        <source>Restricts access to a member to code in the same type or module.</source>
        <target state="translated">Üyeye erişimi aynı türdeki veya modüldeki kodla sınırlandırır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPublic">
        <source>Allows access to a member from outside the type.</source>
        <target state="translated">Türün dışından üyeye erişim sağlar.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRec">
        <source>Used to indicate that a function is recursive.</source>
        <target state="translated">Bir işlevin özyinelemeli olduğunu belirtmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturn">
        <source>Used to provide a value for the result of the containing computation expression.</source>
        <target state="translated">Öğeyi içeren hesaplama ifadesinin sonucuna yönelik bir değer sağlanması için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturnBang">
        <source>Used to provide a value for the result of the containing computation expression, where that value itself comes from the result another computation expression.</source>
        <target state="translated">Öğeyi içeren hesaplama ifadesinin sonucuna yönelik bir değer sağlanması için kullanılır ve bu değerin kendisi, başka bir hesaplama ifadesinin sonucundan gelir.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionSelect">
        <source>Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</source>
        <target state="translated">Hangi alanların veya sütunların ayıklanacağını belirtmek için sorgu ifadelerinde kullanılır. Bunun bağlamsal bir anahtar sözcük olduğuna dikkat edin, yani aslında bir ayrılmış anahtar sözcük değildir ve yalnızca uygun bağlamda anahtar sözcük gibi davranır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStatic">
        <source>Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</source>
        <target state="translated">Bir türün örneği olmadan veya türün tüm örnekleri arasında paylaşılan bir değer üyesi olmadan çağrılabilecek bir metodu veya özelliği belirtmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStruct">
        <source>Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions.</source>
        <target state="translated">Yapı türü bildirmek için kullanılır. Ayrıca genel parametre kısıtlamaları içinde kullanılır. Modül tanımlarında OCaml uyumluluğu için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionThen">
        <source>Used in conditional expressions. Also used to perform side effects after object construction.</source>
        <target state="translated">Koşullu ifadelerde kullanılır. Ayrıca nesne oluşturmadan sonra yan etkileri gerçekleştirmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTo">
        <source>Used in for loops to indicate a range.</source>
        <target state="translated">For döngülerinde aralık belirtmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTry">
        <source>Used to introduce a block of code that might generate an exception. Used together with with or finally.</source>
        <target state="translated">Özel durum oluşturabilen bir kod bloğunu tanıtmak için kullanılır. with veya finally ile birlikte kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionType">
        <source>Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</source>
        <target state="translated">Bir sınıf, kayıt, yapı, ayırt edici birleşim, sabit listesi türü, ölçü birimi veya tür kısaltması bildirmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUpcast">
        <source>Used to convert to a type that is higher in the inheritance chain.</source>
        <target state="translated">Devralma zincirinde daha yukarıda bulunan bir türe dönüştürmek için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUse">
        <source>Used instead of let for values that implement IDisposable</source>
        <target state="translated">IDisposable uygulayan değerler için let yerine kullanılır</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUseBang">
        <source>Used instead of let! in computation expressions for computation expression results that implement IDisposable.</source>
        <target state="translated">IDisposable uygulayan hesaplama ifadesi sonuçları için hesaplama ifadelerinde let! yerine kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVal">
        <source>Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</source>
        <target state="translated">Değer belirtmek için imzada veya sınırlı durumlarda üye bildirmek için türde kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVoid">
        <source>Indicates the .NET void type. Used when interoperating with other .NET languages.</source>
        <target state="translated">.NET void türünü belirtir. Diğer .NET dilleriyle birlikte çalışırken kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhen">
        <source>Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.</source>
        <target state="translated">Desen eşleştirmelerde ve genel türde bir parametreye yönelik olarak bir kısıtlama yan tümcesi eklemek amacıyla Boolean koşulları (when korumaları) için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhile">
        <source>Introduces a looping construct.</source>
        <target state="translated">Döngü yapısını tanıtır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWith">
        <source>Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</source>
        <target state="translated">Desen eşleştirme ifadelerinde match anahtar sözcüğü ile birlikte kullanılır. Ayrıca nesne ifadelerinde, kayıt kopyalama ifadelerinde ve tür uzantılarında üye tanımlarını ve özel durum işleyicilerini tanıtmak için kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYield">
        <source>Used in a sequence expression to produce a value for a sequence.</source>
        <target state="translated">Diziye ait bir değer üretmek için dizi ifadesinde kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYieldBang">
        <source>Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</source>
        <target state="translated">Verilen bir hesaplama ifadesinin sonucunu, bu hesaplama ifadesinin içerdiği sonuç koleksiyonuna eklemek için hesaplama ifadelerinde kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRightArrow">
        <source>In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions</source>
        <target state="translated">İşlev türlerinde, bağımsız değişkenleri ve dönüş değerlerini ayırır. Bir ifade verir (dizi ifadelerinde); yield anahtar sözcüğüne eşdeğerdir. Eşleştirme ifadelerinde kullanılır</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLeftArrow">
        <source>Assigns a value to a variable.</source>
        <target state="translated">Değişkene değer atar.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionCast">
        <source>Converts a type to type that is higher in the hierarchy.</source>
        <target state="translated">Bir türü hiyerarşide daha yukarıdaki bir türe dönüştürür.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDynamicCast">
        <source>Converts a type to a type that is lower in the hierarchy.</source>
        <target state="translated">Bir türü hiyerarşide daha aşağıdaki bir türe dönüştürür.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTypedQuotation">
        <source>Delimits a typed code quotation.</source>
        <target state="translated">Türü belirtilmiş kod alıntısını ayırır.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUntypedQuotation">
        <source>Delimits a untyped code quotation.</source>
        <target state="translated">Türü belirtilmemiş kod alıntısını ayırır.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundDuringDynamicCodeGen">
        <source>{0} '{1}' not found in assembly '{2}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{2}' bütünleştirilmiş kodunda {0} '{1}' bulunamadı. Bunun nedeni sürüm uyumsuzluğu olabilir. Başvurulan tüm bileşenlerin doğru sürümü kullanmasına izin vermek için bu bütünleştirilmiş kodun doğru sürümüne açıkça başvurmanız gerekebilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundInTypeDuringDynamicCodeGen">
        <source>{0} '{1}' not found in type '{2}' from assembly '{3}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{3}' bütünleştirilmiş kodundaki '{2}' türünde {0} '{1}' bulunamadı. Bunun nedeni sürüm uyumsuzluğu olabilir. Başvurulan tüm bileşenlerin doğru sürümü kullanmasına izin vermek için bu bütünleştirilmiş kodun doğru sürümüne açıkça başvurmanız gerekebilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionWordIs">
        <source>is</source>
        <target state="translated">olan</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunction">
        <source>This value is not a function and cannot be applied.</source>
        <target state="translated">Bu değer, bir işlev değil ve uygulanamaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexerWithName">
        <source>This value is not a function and cannot be applied. Did you intend to access the indexer via {0}.[index] instead?</source>
        <target state="translated">Bu değer, bir işlev değil ve uygulanamaz. Dizin oluşturucuya bunun yerine {0}.[index] üzerinden erişmeye mi çalışıyordunuz?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexer">
        <source>This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?</source>
        <target state="translated">Bu ifade, bir işlev değil ve uygulanamaz. Dizin oluşturucuya bunun yerine expr.[index] üzerinden erişmeye mi çalışıyordunuz?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeDeclaration">
        <source>This value is not a function and cannot be applied. Did you forget to terminate a declaration?</source>
        <target state="translated">Bu değer bir işlev değil ve uygulanamaz. Bir bildirimi sonlandırmayı mı unuttunuz?</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentsInSigAndImplMismatch">
        <source>The argument names in the signature '{0}' and implementation '{1}' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling.</source>
        <target state="translated">{0}' imzası ve '{1}' uygulaması içindeki bağımsız değişken adları eşleşmiyor. İmza dosyasındaki bağımsız değişken adı kullanılacak. Bu, hata ayıklama veya profil oluşturma sırasında sorunlara neden olabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleUnexpectedNonZero">
        <source>An error occurred while reading the F# metadata of assembly '{0}'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct.</source>
        <target state="translated">'{0}' bütünleştirilmiş kodunun F# meta verileri okunurken bir hata oluştu. Ayrılmış bir yapı kullanıldı. F# derleyicinizi yükseltmeniz veya bütünleştirilmiş kodun belirli bir yapıyı kullanmayan daha eski bir sürümünü kullanmanız gerekebilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleMemberNotNormallyUsed">
        <source>This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.</source>
        <target state="translated">Bu metot veya özellik normalde F# kodundan kullanılmaz, bunun yerine ayrıştırma için açıkça bir demet deseni kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'.</source>
        <target state="translated">Bu ifade '{0}' türünde bir değer döndürür ancak örtük olarak atılır. Sonucu bir ada bağlamak için 'let' kullanabilirsiniz, örn. 'let sonuc = ifade'. İfadeyi dizide bir değer olarak kullanmayı amaçladıysanız açık bir 'yield' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedSequenceInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'.</source>
        <target state="translated">Bu ifade '{0}' türünde bir değer döndürür ancak örtük olarak atılır. Sonucu bir ada bağlamak için 'let' kullanabilirsiniz, örn. 'let sonuc = ifade'. İfadeyi dizide bir değer olarak kullanmayı amaçladıysanız açık bir 'yield!' kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatchBang">
        <source>Used in computation expressions to pattern match directly over the result of another computation expression.</source>
        <target state="translated">Başka bir hesaplama ifadesinin sonucu üzerinde doğrudan desen eşleştirmesi için hesaplama ifadelerinde kullanılır.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilreadFileChanged">
        <source>The file '{0}' changed on disk unexpectedly, please reload.</source>
        <target state="translated">Diskte '{0}' dosyası beklenmedik şekilde değiştirildi. Lütfen yeniden yükleyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="writeToReadOnlyByref">
        <source>The byref pointer is readonly, so this write is not permitted.</source>
        <target state="translated">Byref işaretçisi salt okunur olduğundan bu yazma işlemine izin verilmiyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeMutable">
        <source>A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'</source>
        <target state="translated">İçeriği değiştirmek veya değer türünün adresini almak için bir değerin değiştirilebilir olması gerekir, örn. 'let mutable x = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="readOnlyAttributeOnStructWithMutableField">
        <source>A ReadOnly attribute has been applied to a struct type with a mutable field.</source>
        <target state="translated">Değiştirilebilir bir alana sahip bir yapı türüne ReadOnly özniteliği uygulandı.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByrefReturnImplicitlyDereferenced">
        <source>A byref pointer returned by a function or method is implicitly dereferenced as of F# 4.5. To acquire the return value as a pointer, use the address-of operator, e.g. '&amp;f(x)' or '&amp;obj.Method(arg1, arg2)'.</source>
        <target state="translated">F# 4.5 sürümüyle birlikte, bir işlev veya metot tarafından döndürülen bir byref işaretçisinin referansı örtük olarak kaldırılır. Döndürülen değeri bir işaretçi olarak edinmek için address-of işlecini kullanın, ör. '&amp;f(x)' veya '&amp;obj.Method(arg1, arg2)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByRefLikeNotStruct">
        <source>A type annotated with IsByRefLike must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.</source>
        <target state="translated">IsByRefLike ek açıklamasına sahip bir tür, aynı zamanda bir yapı olmalıdır. Türe [&lt;Struct&gt;] özniteliğini eklemeyi göz önünde bulundurun.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAddressOfLocal">
        <source>The address of the variable '{0}' or a related expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">Bu noktada '{0}' değişkeninin veya ilgili bir değişkenin adresi kullanılamaz. Bunun amacı, yerel değerin adresinin kapsamı dışına kaçmasını engellemektir.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoWriteToLimitedSpan">
        <source>This value can't be assigned because the target '{0}' may refer to non-stack-local memory, while the expression being assigned is assessed to potentially refer to stack-local memory. This is to help prevent pointers to stack-bound memory escaping their scope.</source>
        <target state="translated">'{0}' hedefi yığında yerel olmayan belleğe başvurabileceğinden ve atanmakta olan ifadenin yığında yerel belleğe başvurma olasılığının olduğu tespit edildiğinden bu değer atanamaz. Bunun amacı, yığınla sınırlı belleğe yönelik işaretçilerin kapsamlarından kaçmasının önlenmesine yardımcı olmaktır.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeLocal">
        <source>A value defined in a module must be mutable in order to take its address, e.g. 'let mutable x = ...'</source>
        <target state="translated">Bir modülde tanımlanan bir değerin adresini alabilmesi için değiştirilebilir olması gerekir. Örn. 'let mutable x = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIsReadOnlyNotStruct">
        <source>A type annotated with IsReadOnly must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.</source>
        <target state="translated">IsReadOnly ek açıklamasına sahip bir tür, aynı zamanda bir yapı olmalıdır. Türe [&lt;Struct&gt;] özniteliğini eklemeyi göz önünde bulundurun.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkStructsMayNotReturnAddressesOfContents">
        <source>Struct members cannot return the address of fields of the struct by reference</source>
        <target state="translated">Yapı üyeleri, başvuruya göre yapı alanlarının adreslerini döndüremez</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefLikeFunctionCall">
        <source>The function or method call cannot be used at this point, because one argument that is a byref of a non-stack-local Span or IsByRefLike type is used with another argument that is a stack-local Span or IsByRefLike type. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">Yığında yerel olmayan bir Span veya IsByRefLike türünün byref’i olan bir bağımsız değişken yığında yerel olan başka bir Span veya IsByRefLike türüyle birlikte kullanıldığından işlev veya metot çağrısı bu noktada kullanılamaz. Bunun amacı, yerel değerin adresinin kapsamından kaçmasının önlenmesine yardımcı olmaktır.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAddressOfValueFromExpression">
        <source>The address of a value returned from the expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">Bu noktada ifadeden döndürülen bir değerin adresi kullanılamaz. Bunun amacı, yerel değerin adresinin kapsamı dışına kaçmasını engellemektir.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoSpanLikeVariable">
        <source>The Span or IsByRefLike variable '{0}' cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">Bu noktada Span veya IsByRefLike değişkeni '{0}' kullanılamaz. Bunun amacı, yerel değerin adresinin kapsamı dışına kaçmasını engellemektir.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoSpanLikeValueFromExpression">
        <source>A Span or IsByRefLike value returned from the expression cannot be used at ths point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">Bu noktada ifadeden döndürülen bir Span veya IsByRefLike değeri kullanılamaz. Bunun amacı, yerel değerin adresinin kapsamı dışına kaçmasını engellemektir.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastCantTakeAddressOfExpression">
        <source>Cannot take the address of the value returned from the expression. Assign the returned value to a let-bound value before taking the address.</source>
        <target state="translated">İfadeden döndürülen değerin adresi alınamaz. Adresi almadan önce, döndürülen değeri let ile bağlanmış bir değere atayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBraceBar">
        <source>Unmatched '{{|'</source>
        <target state="translated">Eşleşmeyen '{{|'</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoAnonRecdField">
        <source>anonymous record field</source>
        <target state="translated">anonim kayıt alanı</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionConstructorDoesNotHaveFieldWithGivenName">
        <source>The exception '{0}' does not have a field named '{1}'.</source>
        <target state="translated">'{0}' özel durumunun '{1}' adlı bir alanı yok.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcActivePatternsDoNotHaveFields">
        <source>Active patterns do not have fields. This syntax is invalid.</source>
        <target state="translated">Etkin desenlerin alanı olmaz. Bu söz dizimi geçersiz.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorDoesNotHaveFieldWithGivenName">
        <source>The constructor does not have a field named '{0}'.</source>
        <target state="translated">Oluşturucunun '{0}' adlı bir alanı yok.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdCcuMismatch">
        <source>Two anonymous record types are from different assemblies '{0}' and '{1}'</source>
        <target state="translated">İki anonim kayıt türü, birbirinden farklı olan '{0}' ve '{1}' derlemelerinden</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameMismatch">
        <source>This anonymous record does not exactly match the expected shape. Add the missing fields {0} and remove the extra fields {1}.</source>
        <target state="translated">Bu anonim kayıt, beklenen şekille tam olarak eşleşmiyor. Eksik {0} alanlarını ekleyin ve ek {1} alanlarını kaldırın.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallExtensionMethodInrefToByref">
        <source>Cannot call the byref extension method '{0}. The first parameter requires the value to be mutable or a non-readonly byref type.</source>
        <target state="translated">'{0}' byref genişletme metodu çağrılamıyor. İlk parametre, değerin değişebilir olmasını veya salt okunur olmayan bir byref türünde olmasını gerektiriyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByrefsMayNotHaveTypeExtensions">
        <source>Byref types are not allowed to have optional type extensions.</source>
        <target state="translated">Byref türlerinin isteğe bağlı tür genişletmelerine sahip olmasına izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotPartiallyApplyExtensionMethodForByref">
        <source>Cannot partially apply the extension method '{0}' because the first parameter is a byref type.</source>
        <target state="translated">İlk parametre bir byref türü olduğundan '{0}' genişletme metodunu kısmi olarak uygulayamazsınız.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDoesNotInheritAttribute">
        <source>This type does not inherit Attribute, it will not work correctly with other .NET languages.</source>
        <target state="translated">Bu tür Özniteliği devralmaz, diğer .NET dilleriyle düzgün çalışmaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidAnonRecdExpr">
        <source>Invalid anonymous record expression</source>
        <target state="translated">Geçersiz anonim kayıt ifadesi</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidAnonRecdType">
        <source>Invalid anonymous record type</source>
        <target state="translated">Geçersiz anonim kayıt türü</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCopyAndUpdateNeedsRecordType">
        <source>The input to a copy-and-update expression that creates an anonymous record must be either an anonymous record or a record</source>
        <target state="translated">Anonim kayıt oluşturan bir copy-and-update ifadesinin girişi anonim bir kayıt ya da bir kayıt olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidFunctionParameterType">
        <source>The parameter '{0}' has an invalid type '{1}'. This is not permitted by the rules of Common IL.</source>
        <target state="translated">'{0}' parametresi geçersiz '{1}' türünde. Ortak IL kuralları uyarınca buna izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidFunctionReturnType">
        <source>The function or method has an invalid return type '{0}'. This is not permitted by the rules of Common IL.</source>
        <target state="translated">İşlev veya metot geçersiz '{0}' dönüş türüne sahip. Ortak IL kuralları uyarınca buna izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveral">
        <source>No implementation was given for those members: {0}</source>
        <target state="translated">Bu üyelere uygulama verilmedi: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralWithSuggestion">
        <source>No implementation was given for those members: {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Bu üyelere uygulama verilmedi: {0}Tüm arabirim üyelerinin uygulanması ve uygun bir "arabirim" bildirimi (ör. "arabirim ... ile üye ..." kapsamında listelenmesi gerektiğini unutmayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralTruncated">
        <source>No implementation was given for those members (some results omitted): {0}</source>
        <target state="translated">Bu üyelere uygulama verilmedi (bazı sonuçlar atlandı): {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralTruncatedWithSuggestion">
        <source>No implementation was given for those members (some results omitted): {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Bu üyelere uygulama verilmedi (bazı sonuçlar atlandı): {0}Tüm arabirim üyelerinin uygulanması ve uygun bir "arabirim" bildirimi (ör. "arabirim ... ile üye ..." kapsamında listelenmesi gerektiğini unutmayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="expressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">İfade bir ada sahip değil.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassNameOf">
        <source>Using the 'nameof' operator as a first-class function value is not permitted.</source>
        <target state="translated">'Nameof' işlecinin birinci sınıf işlev değeri olarak kullanılmasına izin verilmez.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPathMap">
        <source>Maps physical paths to source path names output by the compiler</source>
        <target state="translated">Fiziksel yolları derleyiciye göre kaynak yol adları çıkışıyla eşler</target>
        <note />
      </trans-unit>
      <trans-unit id="fscPathMapDebugRequiresPortablePdb">
        <source>--pathmap can only be used with portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">--pathmap yalnızca taşınabilir PDB'ler (--debug:portable veya --debug:embedded) ile kullanılabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidPathMapFormat">
        <source>Invalid path map. Mappings must be comma separated and of the format 'path=sourcePath'</source>
        <target state="translated">Geçersiz yol eşlemesi. Eşlemeler virgülle ayrılmış ve 'path=sourcePath' biçiminde olmalıdır</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCompilerTool">
        <source>Reference an assembly or directory containing a design time tool (Short form: -t)</source>
        <target state="translated">Tasarım zamanı aracı içeren bir bütünleştirilmiş koda veya dizine başvurun (Kısa biçim: -t)</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagerUnknown">
        <source>Package manager key '{0}' was not registered in {1}. Currently registered: {2}</source>
        <target state="translated">'{0}' paket yöneticisi anahtarı {1} içinde kayıtlı değil. Şu anda kayıtlı: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagerError">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="couldNotLoadDependencyManagerExtension">
        <source>The dependency manager extension {0} could not be loaded. Message: {1}</source>
        <target state="translated">{0} bağımlılık yöneticisi uzantısı yüklenemedi. İleti: {1}</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>