<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="en" original="../FSComp.resx">
    <body>
      <trans-unit id="undefinedNameNamespace">
        <source>The namespace '{0}' is not defined.</source>
        <target state="new">The namespace '{0}' is not defined.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespaceOrModule">
        <source>The namespace or module '{0}' is not defined.</source>
        <target state="new">The namespace or module '{0}' is not defined.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMember">
        <source>The field, constructor or member '{0}' is not defined.</source>
        <target state="new">The field, constructor or member '{0}' is not defined.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueConstructorNamespaceOrType">
        <source>The value, constructor, namespace or type '{0}' is not defined.</source>
        <target state="new">The value, constructor, namespace or type '{0}' is not defined.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueOfConstructor">
        <source>The value or constructor '{0}' is not defined.</source>
        <target state="new">The value or constructor '{0}' is not defined.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueNamespaceTypeOrModule">
        <source>The value, namespace, type or module '{0}' is not defined.</source>
        <target state="new">The value, namespace, type or module '{0}' is not defined.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameConstructorModuleOrNamespace">
        <source>The constructor, module or namespace '{0}' is not defined.</source>
        <target state="new">The constructor, module or namespace '{0}' is not defined.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameType">
        <source>The type '{0}' is not defined.</source>
        <target state="new">The type '{0}' is not defined.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeIn">
        <source>The type '{0}' is not defined in '{1}'.</source>
        <target state="new">The type '{0}' is not defined in '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabelOrNamespace">
        <source>The record label or namespace '{0}' is not defined.</source>
        <target state="new">The record label or namespace '{0}' is not defined.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabel">
        <source>The record label '{0}' is not defined.</source>
        <target state="new">The record label '{0}' is not defined.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameSuggestionsIntro">
        <source>Maybe you want one of the following:</source>
        <target state="new">Maybe you want one of the following:</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeParameter">
        <source>The type parameter {0} is not defined.</source>
        <target state="new">The type parameter {0} is not defined.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNamePatternDiscriminator">
        <source>The pattern discriminator '{0}' is not defined.</source>
        <target state="new">The pattern discriminator '{0}' is not defined.</target>
        <note />
      </trans-unit>
      <trans-unit id="replaceWithSuggestion">
        <source>Replace with '{0}'</source>
        <target state="new">Replace with '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="addIndexerDot">
        <source>Add . for indexer access.</source>
        <target state="new">Add . for indexer access.</target>
        <note />
      </trans-unit>
      <trans-unit id="listElementHasWrongType">
        <source>All elements of a list constructor expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</source>
        <target state="new">All elements of a list constructor expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="arrayElementHasWrongType">
        <source>All elements of an array constructor expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</source>
        <target state="new">All elements of an array constructor expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="missingElseBranch">
        <source>The 'if' expression is missing an 'else' branch. The 'then' branch has type '{0}'. Because 'if' is an expression, and not a statement, add an 'else' branch which returns a value of the same type.</source>
        <target state="new">The 'if' expression is missing an 'else' branch. The 'then' branch has type '{0}'. Because 'if' is an expression, and not a statement, add an 'else' branch which returns a value of the same type.</target>
        <note />
      </trans-unit>
      <trans-unit id="ifExpression">
        <source>The 'if' expression needs to have type '{0}' to satisfy context type requirements. It currently has type '{1}'.</source>
        <target state="new">The 'if' expression needs to have type '{0}' to satisfy context type requirements. It currently has type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="elseBranchHasWrongType">
        <source>All branches of an 'if' expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</source>
        <target state="new">All branches of an 'if' expression must have the same type. This expression was expected to have type '{0}', but here has type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="followingPatternMatchClauseHasWrongType">
        <source>All branches of a pattern match expression must return values of the same type. The first branch returned a value of type '{0}', but this branch returned a value of type '{1}'.</source>
        <target state="new">All branches of a pattern match expression must return values of the same type. The first branch returned a value of type '{0}', but this branch returned a value of type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="patternMatchGuardIsNotBool">
        <source>A pattern match guard must be of type 'bool', but this 'when' expression is of type '{0}'.</source>
        <target state="new">A pattern match guard must be of type 'bool', but this 'when' expression is of type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="commaInsteadOfSemicolonInRecord">
        <source>A ';' is used to separate field values in records. Consider replacing ',' with ';'.</source>
        <target state="new">A ';' is used to separate field values in records. Consider replacing ',' with ';'.</target>
        <note />
      </trans-unit>
      <trans-unit id="derefInsteadOfNot">
        <source>The '!' operator is used to dereference a ref cell. Consider using 'not expr' here.</source>
        <target state="new">The '!' operator is used to dereference a ref cell. Consider using 'not expr' here.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedTypeArgs">
        <source>The non-generic type '{0}' does not expect any type arguments, but here is given {1} type argument(s)</source>
        <target state="new">The non-generic type '{0}' does not expect any type arguments, but here is given {1} type argument(s)</target>
        <note />
      </trans-unit>
      <trans-unit id="returnUsedInsteadOfReturnBang">
        <source>Consider using 'return!' instead of 'return'.</source>
        <target state="new">Consider using 'return!' instead of 'return'.</target>
        <note />
      </trans-unit>
      <trans-unit id="yieldUsedInsteadOfYieldBang">
        <source>Consider using 'yield!' instead of 'yield'.</source>
        <target state="new">Consider using 'yield!' instead of 'yield'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tupleRequiredInAbstractMethod">
        <source>\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.</source>
        <target state="new">\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidWarningNumber">
        <source>Invalid warning number '{0}'</source>
        <target state="new">Invalid warning number '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionString">
        <source>Invalid version string '{0}'</source>
        <target state="new">Invalid version string '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionFile">
        <source>Invalid version file '{0}'</source>
        <target state="new">Invalid version file '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProductName">
        <source>Microsoft (R) F# Compiler version {0}</source>
        <target state="new">Microsoft (R) F# Compiler version {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProductNameCommunity">
        <source>F# Compiler for F# {0}</source>
        <target state="new">F# Compiler for F# {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemWithFilename">
        <source>Problem with filename '{0}': {1}</source>
        <target state="new">Problem with filename '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildNoInputsSpecified">
        <source>No inputs specified</source>
        <target state="new">No inputs specified</target>
        <note />
      </trans-unit>
      <trans-unit id="buildPdbRequiresDebug">
        <source>The '--pdb' option requires the '--debug' option to be used</source>
        <target state="new">The '--pdb' option requires the '--debug' option to be used</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSearchDirectory">
        <source>The search directory '{0}' is invalid</source>
        <target state="new">The search directory '{0}' is invalid</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSearchDirectoryNotFound">
        <source>The search directory '{0}' could not be found</source>
        <target state="new">The search directory '{0}' could not be found</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidFilename">
        <source>'{0}' is not a valid filename</source>
        <target state="new">'{0}' is not a valid filename</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidAssemblyName">
        <source>'{0}' is not a valid assembly name</source>
        <target state="new">'{0}' is not a valid assembly name</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidPrivacy">
        <source>Unrecognized privacy setting '{0}' for managed resource, valid options are 'public' and 'private'</source>
        <target state="new">Unrecognized privacy setting '{0}' for managed resource, valid options are 'public' and 'private'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleReferencesNotAllowed">
        <source>Multiple references to '{0}.dll' are not permitted</source>
        <target state="new">Multiple references to '{0}.dll' are not permitted</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotReadVersionInfoFromMscorlib">
        <source>Could not read version from mscorlib.dll</source>
        <target state="new">Could not read version from mscorlib.dll</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCannotReadAssembly">
        <source>Unable to read assembly '{0}'</source>
        <target state="new">Unable to read assembly '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildAssemblyResolutionFailed">
        <source>Assembly resolution failure at or near this location</source>
        <target state="new">Assembly resolution failure at or near this location</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplicitModuleIsNotLegalIdentifier">
        <source>The declarations in this file will be placed in an implicit module '{0}' based on the file name '{1}'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file.</source>
        <target state="new">The declarations in this file will be placed in an implicit module '{0}' based on the file name '{1}'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultiFileRequiresNamespaceOrModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration.</source>
        <target state="new">Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration.</target>
        <note />
      </trans-unit>
      <trans-unit id="noEqualSignAfterModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.</source>
        <target state="new">Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleToplevelModules">
        <source>This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules.</source>
        <target state="new">This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildOptionRequiresParameter">
        <source>Option requires parameter: {0}</source>
        <target state="new">Option requires parameter: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotFindSourceFile">
        <source>Source file '{0}' could not be found</source>
        <target state="new">Source file '{0}' could not be found</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSourceFileExtension">
        <source>The file extension of '{0}' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.</source>
        <target state="new">The file extension of '{0}' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssembly">
        <source>Could not resolve assembly '{0}'</source>
        <target state="new">Could not resolve assembly '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssemblyRequiredByFile">
        <source>Could not resolve assembly '{0}' required by '{1}'</source>
        <target state="new">Could not resolve assembly '{0}' required by '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildErrorOpeningBinaryFile">
        <source>Error opening binary file '{0}': {1}</source>
        <target state="new">Error opening binary file '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDifferentVersionMustRecompile">
        <source>The F#-compiled DLL '{0}' needs to be recompiled to be used with this version of F#</source>
        <target state="new">The F#-compiled DLL '{0}' needs to be recompiled to be used with this version of F#</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashIDirective">
        <source>Invalid directive. Expected '#I \"&lt;path&gt;\"'.</source>
        <target state="new">Invalid directive. Expected '#I \"&lt;path&gt;\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashrDirective">
        <source>Invalid directive. Expected '#r \"&lt;file-or-assembly&gt;\"'.</source>
        <target state="new">Invalid directive. Expected '#r \"&lt;file-or-assembly&gt;\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashloadDirective">
        <source>Invalid directive. Expected '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</source>
        <target state="new">Invalid directive. Expected '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashtimeDirective">
        <source>Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'.</source>
        <target state="new">Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDirectivesInModulesAreIgnored">
        <source>Directives inside modules are ignored</source>
        <target state="new">Directives inside modules are ignored</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureAlreadySpecified">
        <source>A signature for the file or module '{0}' has already been specified</source>
        <target state="new">A signature for the file or module '{0}' has already been specified</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGivenDetail">
        <source>An implementation of file or module '{0}' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.</source>
        <target state="new">An implementation of file or module '{0}' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGiven">
        <source>An implementation of the file or module '{0}' has already been given</source>
        <target state="new">An implementation of the file or module '{0}' has already been given</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureWithoutImplementation">
        <source>The signature file '{0}' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match.</source>
        <target state="new">The signature file '{0}' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidInt">
        <source>'{0}' is not a valid integer argument</source>
        <target state="new">'{0}' is not a valid integer argument</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidFloat">
        <source>'{0}' is not a valid floating point argument</source>
        <target state="new">'{0}' is not a valid floating point argument</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnrecognizedOption">
        <source>Unrecognized option: '{0}'</source>
        <target state="new">Unrecognized option: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidModuleOrNamespaceName">
        <source>Invalid module or namespace name</source>
        <target state="new">Invalid module or namespace name</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleErrorReadingWritingMetadata">
        <source>Error reading/writing metadata for the F# compiled DLL '{0}'. Was the DLL compiled with an earlier version of the F# compiler? (error: '{1}').</source>
        <target state="new">Error reading/writing metadata for the F# compiled DLL '{0}'. Was the DLL compiled with an earlier version of the F# compiler? (error: '{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeOrModuleNotConcrete">
        <source>The type/module '{0}' is not a concrete module or type</source>
        <target state="new">The type/module '{0}' is not a concrete module or type</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeHasAssemblyCodeRepresentation">
        <source>The type '{0}' has an inline assembly code representation</source>
        <target state="new">The type '{0}' has an inline assembly code representation</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNamespaceAndModuleWithSameNameInAssembly">
        <source>A namespace and a module named '{0}' both occur in two parts of this assembly</source>
        <target state="new">A namespace and a module named '{0}' both occur in two parts of this assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTwoModulesWithSameNameInAssembly">
        <source>Two modules named '{0}' occur in two parts of this assembly</source>
        <target state="new">Two modules named '{0}' occur in two parts of this assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="tastDuplicateTypeDefinitionInAssembly">
        <source>Two type definitions named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="new">Two type definitions named '{0}' occur in namespace '{1}' in two parts of this assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConflictingModuleAndTypeDefinitionInAssembly">
        <source>A module and a type definition named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="new">A module and a type definition named '{0}' occur in namespace '{1}' in two parts of this assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMemberSignature">
        <source>Invalid member signature encountered because of an earlier error</source>
        <target state="new">Invalid member signature encountered because of an earlier error</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueDoesNotHaveSetterType">
        <source>This value does not have a valid property setter type</source>
        <target state="new">This value does not have a valid property setter type</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertyGetter">
        <source>Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax.</source>
        <target state="new">Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertySetter">
        <source>Invalid form for a property setter. At least one argument is required.</source>
        <target state="new">Invalid form for a property setter. At least one argument is required.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedByRef">
        <source>Unexpected use of a byref-typed variable</source>
        <target state="new">Unexpected use of a byref-typed variable</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeMutable">
        <source>A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'</source>
        <target state="new">A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMutationOfConstant">
        <source>Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'.</source>
        <target state="new">Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueHasBeenCopied">
        <source>The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed</source>
        <target state="new">The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeInConstructionOfTuple">
        <source>Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding</source>
        <target state="new">Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotAppearInConstructionOfType">
        <source>Recursive values cannot appear directly as a construction of the type '{0}' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.</source>
        <target state="new">Recursive values cannot appear directly as a construction of the type '{0}' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeAssignedToNonMutableField">
        <source>Recursive values cannot be directly assigned to the non-mutable field '{0}' of the type '{1}' within a recursive binding. Consider using a mutable field instead.</source>
        <target state="new">Recursive values cannot be directly assigned to the non-mutable field '{0}' of the type '{1}' within a recursive binding. Consider using a mutable field instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfAutoOpenAttribute">
        <source>Unexpected decode of AutoOpenAttribute</source>
        <target state="new">Unexpected decode of AutoOpenAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInternalsVisibleToAttribute">
        <source>Unexpected decode of InternalsVisibleToAttribute</source>
        <target state="new">Unexpected decode of InternalsVisibleToAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
        <source>Unexpected decode of InterfaceDataVersionAttribute</source>
        <target state="new">Unexpected decode of InterfaceDataVersionAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastActivePatternsLimitedToSeven">
        <source>Active patterns cannot return more than 7 possibilities</source>
        <target state="new">Active patterns cannot return more than 7 possibilities</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNotAConstantExpression">
        <source>This is not a valid constant expression or custom attribute value</source>
        <target state="new">This is not a valid constant expression or custom attribute value</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAttributesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe mutability attributes differ</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe mutability attributes differ</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe names differ</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe names differ</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityCompiledNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled names differ</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled names differ</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDisplayNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe display names differ</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe display names differ</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAccessibilityMore">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe accessibility specified in the signature is more than that specified in the implementation</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInlineFlagsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe inline flags differ</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe inline flags differ</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityLiteralConstantValuesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe literal constant values and/or attributes differ</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe literal constant values and/or attributes differ</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsTypeFunction">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityParameterCountsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe respective type parameter counts differ</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe respective type parameter counts differ</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityTypesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe types differ</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe types differ</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityExtensionsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is an extension member and the other is not</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is an extension member and the other is not</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityArityNotInferred">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nAn arity was not inferred for this value</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nAn arity was not inferred for this value</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe number of generic parameters in the signature and implementation differ (the signature declares {3} but the implementation declares {4}</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe number of generic parameters in the signature and implementation differ (the signature declares {3} but the implementation declares {4}</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersAreDifferentKinds">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAritiesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe arities in the signature and implementation differ. The signature specifies that '{3}' is function definition or lambda expression accepting at least {4} argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int.</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe arities in the signature and implementation differ. The signature specifies that '{3}' is function definition or lambda expression accepting at least {4} argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDotNetNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe CLI member names differ</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe CLI member names differ</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is static and the other isn't</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is static and the other isn't</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityVirtualsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is virtual and the other isn't</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is virtual and the other isn't</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAbstractsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is abstract and the other isn't</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is abstract and the other isn't</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityFinalsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is final and the other isn't</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is final and the other isn't</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOverridesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is marked as an override and the other isn't</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is marked as an override and the other isn't</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsConstructor">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a constructor/property and the other is not</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a constructor/property and the other is not</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticButInstance">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInstanceButStatic">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member</source>
        <target state="new">Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNamesDiffer">
        <source>The {0} definitions in the signature and implementation are not compatible because the names differ. The type is called '{1}' in the signature file but '{2}' in implementation.</source>
        <target state="new">The {0} definitions in the signature and implementation are not compatible because the names differ. The type is called '{1}' in the signature file but '{2}' in implementation.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the respective type parameter counts differ</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleMissingInterface">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature requires that the type supports the interface {2} but the interface has not been implemented</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature requires that the type supports the interface {2} but the interface has not been implemented</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types have different base types</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types have different base types</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNumbersDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the number of {2}s differ</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the number of {2}s differ</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature defines the {2} '{3}' but the implementation does not (or does, but not in the same order)</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature defines the {2} '{3}' but the implementation does not (or does, but not in the same order)</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines the {2} '{3}' but the signature does not (or does, but not in the same order)</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines the {2} '{3}' but the signature does not (or does, but not in the same order)</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a type representation is being hidden by a signature</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because a type representation is being hidden by a signature</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types are of different kinds</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types are of different kinds</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleILDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the IL representations differ</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the IL representations differ</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the representations differ</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the representations differ</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldWasPresent">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was present in the implementation but not in the signature</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was present in the implementation but not in the signature</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was required by the signature but was not specified by the implementation</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was required by the signature but was not specified by the implementation</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field '{2}' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'.</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field '{2}' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was required by the signature but was not specified by the implementation</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was required by the signature but was not specified by the implementation</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was present in the implementation but not in the signature</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was present in the implementation but not in the signature</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature declares a {2} while the implementation declares a {3}</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature declares a {2} while the implementation declares a {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abbreviations differ: {2} versus {3}</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abbreviations differ: {2} versus {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not</source>
        <target state="new">The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButNamesDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="new">The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButDataFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe respective number of data fields differ</source>
        <target state="new">The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe respective number of data fields differ</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButTypesOfFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe types of the fields differ</source>
        <target state="new">The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe types of the fields differ</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButAccessibilityDiffers">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="new">The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedNamesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="new">The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedAccessibilitiesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="new">The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedStaticsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'static' modifiers differ</source>
        <target state="new">The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'static' modifiers differ</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedMutablesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'mutable' modifiers differ</source>
        <target state="new">The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'mutable' modifiers differ</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedLiteralsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'literal' modifiers differ</source>
        <target state="new">The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'literal' modifiers differ</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedTypesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe types differ</source>
        <target state="new">The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe types differ</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveImplicitGenericInstantiation">
        <source>The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '{0}' and '{1}'. Consider using type annotations to resolve the ambiguity</source>
        <target state="new">The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '{0}' and '{1}'. Consider using type annotations to resolve the ambiguity</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInPrintf">
        <source>Could not resolve the ambiguity inherent in the use of a 'printf'-style format string</source>
        <target state="new">Could not resolve the ambiguity inherent in the use of a 'printf'-style format string</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInEnum">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position</source>
        <target state="new">Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInDelegate">
        <source>Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position</source>
        <target state="new">Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInvalidValue">
        <source>Invalid value</source>
        <target state="new">Invalid value</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleParamCountsDiffer">
        <source>The signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="new">The signature and implementation are not compatible because the respective type parameter counts differ</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
        <source>The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation</source>
        <target state="new">The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDiffer">
        <source>The signature and implementation are not compatible because the declaration of the type parameter '{0}' requires a constraint of the form {1}</source>
        <target state="new">The signature and implementation are not compatible because the declaration of the type parameter '{0}' requires a constraint of the form {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDifferRemove">
        <source>The signature and implementation are not compatible because the type parameter '{0}' has a constraint of the form {1} but the implementation does not. Either remove this constraint from the signature or add it to the implementation.</source>
        <target state="new">The signature and implementation are not compatible because the type parameter '{0}' has a constraint of the form {1} but the implementation does not. Either remove this constraint from the signature or add it to the implementation.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableShouldOverrideObjectEquals">
        <source>The type '{0}' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'</source>
        <target state="new">The type '{0}' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableDefaultObjectEqualsProvided">
        <source>The type '{0}' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly</source>
        <target state="new">The type '{0}' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCodeOrEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type</source>
        <target state="new">The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCode">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'</source>
        <target state="new">The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'</source>
        <target state="new">The struct, record or union type '{0}' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleHiddenBySignature">
        <source>The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="new">The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer">
        <source>The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="new">The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature">
        <source>The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="new">The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleSignaturesDiffer">
        <source>The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="new">The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer">
        <source>The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="new">The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInSigButNotImpl">
        <source>The exception definitions are not compatible because the field '{0}' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="new">The exception definitions are not compatible because the field '{0}' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInImplButNotSig">
        <source>The exception definitions are not compatible because the field '{0}' was present in the implementation but not in the signature. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="new">The exception definitions are not compatible because the field '{0}' was present in the implementation but not in the signature. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldOrderDiffers">
        <source>The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="new">The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelModuleNamespaceAttributesDifferInSigAndImpl">
        <source>The namespace or module attributes differ between signature and implementation</source>
        <target state="new">The namespace or module attributes differ between signature and implementation</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsOverconstrained">
        <source>This method is over-constrained in its type parameters</source>
        <target state="new">This method is over-constrained in its type parameters</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverloadNotFound">
        <source>No implementations of '{0}' had the correct number of arguments and type parameters. The required signature is '{1}'.</source>
        <target state="new">No implementations of '{0}' had the correct number of arguments and type parameters. The required signature is '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideWasAmbiguous">
        <source>The override for '{0}' was ambiguous</source>
        <target state="new">The override for '{0}' was ambiguous</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMoreThenOneOverride">
        <source>More than one override implements '{0}'</source>
        <target state="new">More than one override implements '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsSealed">
        <source>The method '{0}' is sealed and cannot be overridden</source>
        <target state="new">The method '{0}' is sealed and cannot be overridden</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideImplementsMoreThenOneSlot">
        <source>The override '{0}' implements more than one abstract slot, e.g. '{1}' and '{2}'</source>
        <target state="new">The override '{0}' implements more than one abstract slot, e.g. '{1}' and '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelDuplicateInterface">
        <source>Duplicate or redundant interface</source>
        <target state="new">Duplicate or redundant interface</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNeedExplicitImplementation">
        <source>The interface '{0}' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.</source>
        <target state="new">The interface '{0}' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNamedArgumentHasBeenAssignedMoreThenOnce">
        <source>A named argument has been assigned more than one value</source>
        <target state="new">A named argument has been assigned more than one value</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGiven">
        <source>No implementation was given for '{0}'</source>
        <target state="new">No implementation was given for '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenWithSuggestion">
        <source>No implementation was given for '{0}'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="new">No implementation was given for '{0}'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfArguments">
        <source>The member '{0}' does not have the correct number of arguments. The required signature is '{1}'.</source>
        <target state="new">The member '{0}' does not have the correct number of arguments. The required signature is '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters">
        <source>The member '{0}' does not have the correct number of method type parameters. The required signature is '{1}'.</source>
        <target state="new">The member '{0}' does not have the correct number of method type parameters. The required signature is '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters">
        <source>The member '{0}' does not have the correct kinds of generic parameters. The required signature is '{1}'.</source>
        <target state="new">The member '{0}' does not have the correct kinds of generic parameters. The required signature is '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberCannotImplement">
        <source>The member '{0}' cannot be used to implement '{1}'. The required signature is '{2}'.</source>
        <target state="new">The member '{0}' cannot be used to implement '{1}'. The required signature is '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILError">
        <source>Error while parsing embedded IL</source>
        <target state="new">Error while parsing embedded IL</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILTypeError">
        <source>Error while parsing embedded IL type</source>
        <target state="new">Error while parsing embedded IL type</target>
        <note />
      </trans-unit>
      <trans-unit id="astDeprecatedIndexerNotation">
        <source>This indexer notation has been removed from the F# language</source>
        <target state="new">This indexer notation has been removed from the F# language</target>
        <note />
      </trans-unit>
      <trans-unit id="astInvalidExprLeftHandOfAssignment">
        <source>Invalid expression on left of assignment</source>
        <target state="new">Invalid expression on left of assignment</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoRefEqualsOnStruct">
        <source>The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'.</source>
        <target state="new">The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="augInvalidAttrs">
        <source>This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'</source>
        <target state="new">This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqualityNeedsNoComparison">
        <source>The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute</source>
        <target state="new">The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructCompNeedsStructEquality">
        <source>The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute</source>
        <target state="new">The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructEqNeedsNoCompOrStructComp">
        <source>The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes</source>
        <target state="new">The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes</target>
        <note />
      </trans-unit>
      <trans-unit id="augTypeCantHaveRefEqAndStructAttrs">
        <source>A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes</source>
        <target state="new">A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes</target>
        <note />
      </trans-unit>
      <trans-unit id="augOnlyCertainTypesCanHaveAttrs">
        <source>Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes</source>
        <target state="new">Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes</target>
        <note />
      </trans-unit>
      <trans-unit id="augRefEqCantHaveObjEquals">
        <source>A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="new">A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsObjEquals">
        <source>A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="new">A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomCompareNeedsIComp">
        <source>A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'</source>
        <target state="new">A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqNeedsNoObjEquals">
        <source>A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="new">A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoCompCantImpIComp">
        <source>A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable&lt;_&gt;' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="new">A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable&lt;_&gt;' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsNoCompOrCustomComp">
        <source>The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes</source>
        <target state="new">The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes</target>
        <note />
      </trans-unit>
      <trans-unit id="forPositionalSpecifiersNotPermitted">
        <source>Positional specifiers are not permitted in format strings</source>
        <target state="new">Positional specifiers are not permitted in format strings</target>
        <note />
      </trans-unit>
      <trans-unit id="forMissingFormatSpecifier">
        <source>Missing format specifier</source>
        <target state="new">Missing format specifier</target>
        <note />
      </trans-unit>
      <trans-unit id="forFlagSetTwice">
        <source>'{0}' flag set twice</source>
        <target state="new">'{0}' flag set twice</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrefixFlagSpacePlusSetTwice">
        <source>Prefix flag (' ' or '+') set twice</source>
        <target state="new">Prefix flag (' ' or '+') set twice</target>
        <note />
      </trans-unit>
      <trans-unit id="forHashSpecifierIsInvalid">
        <source>The # formatting modifier is invalid in F#</source>
        <target state="new">The # formatting modifier is invalid in F#</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadPrecision">
        <source>Bad precision in format specifier</source>
        <target state="new">Bad precision in format specifier</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadWidth">
        <source>Bad width in format specifier</source>
        <target state="new">Bad width in format specifier</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportZeroFlag">
        <source>'{0}' format does not support '0' flag</source>
        <target state="new">'{0}' format does not support '0' flag</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrecisionMissingAfterDot">
        <source>Precision missing after the '.'</source>
        <target state="new">Precision missing after the '.'</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatDoesntSupportPrecision">
        <source>'{0}' format does not support precision</source>
        <target state="new">'{0}' format does not support precision</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifier">
        <source>Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="new">Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</target>
        <note />
      </trans-unit>
      <trans-unit id="forLIsUnnecessary">
        <source>The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="new">The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</target>
        <note />
      </trans-unit>
      <trans-unit id="forHIsUnnecessary">
        <source>The 'h' or 'H' in this format specifier is unnecessary. You can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="new">The 'h' or 'H' in this format specifier is unnecessary. You can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportPrefixFlag">
        <source>'{0}' does not support prefix '{1}' flag</source>
        <target state="new">'{0}' does not support prefix '{1}' flag</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifierGeneral">
        <source>Bad format specifier: '{0}'</source>
        <target state="new">Bad format specifier: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="elSysEnvExitDidntExit">
        <source>System.Environment.Exit did not exit</source>
        <target state="new">System.Environment.Exit did not exit</target>
        <note />
      </trans-unit>
      <trans-unit id="elDeprecatedOperator">
        <source>The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined</source>
        <target state="new">The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined</target>
        <note />
      </trans-unit>
      <trans-unit id="chkProtectedOrBaseCalled">
        <source>A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope.</source>
        <target state="new">A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkByrefUsedInInvalidWay">
        <source>The byref-typed variable '{0}' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.</source>
        <target state="new">The byref-typed variable '{0}' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkBaseUsedInInvalidWay">
        <source>The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.</source>
        <target state="new">The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkVariableUsedInInvalidWay">
        <source>The variable '{0}' is used in an invalid way</source>
        <target state="new">The variable '{0}' is used in an invalid way</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTypeLessAccessibleThanType">
        <source>The type '{0}' is less accessible than the value, member or type '{1}' it is used in.</source>
        <target state="new">The type '{0}' is less accessible than the value, member or type '{1}' it is used in.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSystemVoidOnlyInTypeof">
        <source>'System.Void' can only be used as 'typeof&lt;System.Void&gt;' in F#</source>
        <target state="new">'System.Void' can only be used as 'typeof&lt;System.Void&gt;' in F#</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorUseOfByref">
        <source>A type instantiation involves a byref type. This is not permitted by the rules of Common IL.</source>
        <target state="new">A type instantiation involves a byref type. This is not permitted by the rules of Common IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorContainsCallToRethrow">
        <source>Calls to 'reraise' may only occur directly in a handler of a try-with</source>
        <target state="new">Calls to 'reraise' may only occur directly in a handler of a try-with</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSplicingOnlyInQuotations">
        <source>Expression-splicing operators may only be used within quotations</source>
        <target state="new">Expression-splicing operators may only be used within quotations</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassSplicing">
        <source>First-class uses of the expression-splicing operator are not permitted</source>
        <target state="new">First-class uses of the expression-splicing operator are not permitted</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassAddressOf">
        <source>First-class uses of the address-of operators are not permitted</source>
        <target state="new">First-class uses of the address-of operators are not permitted</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassRethrow">
        <source>First-class uses of the 'reraise' function is not permitted</source>
        <target state="new">First-class uses of the 'reraise' function is not permitted</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAtThisPoint">
        <source>The byref typed value '{0}' cannot be used at this point</source>
        <target state="new">The byref typed value '{0}' cannot be used at this point</target>
        <note />
      </trans-unit>
      <trans-unit id="chkLimitationsOfBaseKeyword">
        <source>'base' values may only be used to make direct calls to the base implementations of overridden members</source>
        <target state="new">'base' values may only be used to make direct calls to the base implementations of overridden members</target>
        <note />
      </trans-unit>
      <trans-unit id="chkObjCtorsCantUseExceptionHandling">
        <source>Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.</source>
        <target state="new">Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfAtThisPoint">
        <source>The address of the variable '{0}' cannot be used at this point</source>
        <target state="new">The address of the variable '{0}' cannot be used at this point</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressStaticFieldAtThisPoint">
        <source>The address of the static field '{0}' cannot be used at this point</source>
        <target state="new">The address of the static field '{0}' cannot be used at this point</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressFieldAtThisPoint">
        <source>The address of the field '{0}' cannot be used at this point</source>
        <target state="new">The address of the field '{0}' cannot be used at this point</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfArrayElementAtThisPoint">
        <source>The address of an array element cannot be used at this point</source>
        <target state="new">The address of an array element cannot be used at this point</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFirstClassFuncNoByref">
        <source>The type of a first-class function cannot contain byrefs</source>
        <target state="new">The type of a first-class function cannot contain byrefs</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReturnTypeNoByref">
        <source>A method return type would contain byrefs which is not permitted</source>
        <target state="new">A method return type would contain byrefs which is not permitted</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidCustAttrVal">
        <source>Invalid custom attribute value (not a constant or literal)</source>
        <target state="new">Invalid custom attribute value (not a constant or literal)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkAttrHasAllowMultiFalse">
        <source>The attribute type '{0}' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element.</source>
        <target state="new">The attribute type '{0}' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to its definition at or near '{2}'. This is an invalid forward reference.</source>
        <target state="new">The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to its definition at or near '{2}'. This is an invalid forward reference.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAsTopValue">
        <source>A byref typed value would be stored here. Top-level let-bound byref values are not permitted.</source>
        <target state="new">A byref typed value would be stored here. Top-level let-bound byref values are not permitted.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReflectedDefCantSplice">
        <source>[&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator '%'</source>
        <target state="new">[&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator '%'</target>
        <note />
      </trans-unit>
      <trans-unit id="chkEntryPointUsage">
        <source>A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence.</source>
        <target state="new">A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseCompiledForm">
        <source>compiled form of the union case</source>
        <target state="new">compiled form of the union case</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseDefaultAugmentation">
        <source>default augmentation of the union case</source>
        <target state="new">default augmentation of the union case</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameMethod">
        <source>The property '{0}' has the same name as a method in type '{1}'.</source>
        <target state="new">The property '{0}' has the same name as a method in type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterSetterDoNotMatchAbstract">
        <source>The property '{0}' of type '{1}' has a getter and a setter that do not match. If one is abstract then the other must be as well.</source>
        <target state="new">The property '{0}' of type '{1}' has a getter and a setter that do not match. If one is abstract then the other must be as well.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameIndexer">
        <source>The property '{0}' has the same name as another property in type '{1}', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.</source>
        <target state="new">The property '{0}' has the same name as another property in type '{1}', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCantStoreByrefValue">
        <source>A type would store a byref typed value. This is not permitted by Common IL.</source>
        <target state="new">A type would store a byref typed value. This is not permitted by Common IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethod">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}'.</source>
        <target state="new">Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodWithSuffix">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="new">Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodCurried">
        <source>The method '{0}' has curried arguments but has the same name as another method in type '{1}'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.</source>
        <target state="new">The method '{0}' has curried arguments but has the same name as another method in type '{1}'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCurriedMethodsCantHaveOutParams">
        <source>Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments</source>
        <target state="new">Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateProperty">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}'.</source>
        <target state="new">Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicatePropertyWithSuffix">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="new">Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedType">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type.</source>
        <target state="new">Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedTypeWithSuffix">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="new">Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMultipleGenericInterfaceInstantiations">
        <source>This type implements the same interface at different generic instantiations '{0}' and '{1}'. This is not permitted in this version of F#.</source>
        <target state="new">This type implements the same interface at different generic instantiations '{0}' and '{1}'. This is not permitted in this version of F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkValueWithDefaultValueMustHaveDefaultValue">
        <source>The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check</source>
        <target state="new">The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefInTypeAbbrev">
        <source>The type abbreviation contains byrefs. This is not permitted by F#.</source>
        <target state="new">The type abbreviation contains byrefs. This is not permitted by F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefBoundVarUsedInSplice">
        <source>The variable '{0}' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.</source>
        <target state="new">The variable '{0}' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericExprs">
        <source>Quotations cannot contain uses of generic expressions</source>
        <target state="new">Quotations cannot contain uses of generic expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericFunctions">
        <source>Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.</source>
        <target state="new">Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainObjExprs">
        <source>Quotations cannot contain object expressions</source>
        <target state="new">Quotations cannot contain object expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainAddressOf">
        <source>Quotations cannot contain expressions that take the address of a field</source>
        <target state="new">Quotations cannot contain expressions that take the address of a field</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainStaticFieldRef">
        <source>Quotations cannot contain expressions that fetch static fields</source>
        <target state="new">Quotations cannot contain expressions that fetch static fields</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainInlineIL">
        <source>Quotations cannot contain inline assembly code or pattern matching on arrays</source>
        <target state="new">Quotations cannot contain inline assembly code or pattern matching on arrays</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainDescendingForLoops">
        <source>Quotations cannot contain descending for loops</source>
        <target state="new">Quotations cannot contain descending for loops</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantFetchUnionIndexes">
        <source>Quotations cannot contain expressions that fetch union case indexes</source>
        <target state="new">Quotations cannot contain expressions that fetch union case indexes</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetUnionFields">
        <source>Quotations cannot contain expressions that set union case fields</source>
        <target state="new">Quotations cannot contain expressions that set union case fields</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetExceptionFields">
        <source>Quotations cannot contain expressions that set fields in exception values</source>
        <target state="new">Quotations cannot contain expressions that set fields in exception values</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantRequireByref">
        <source>Quotations cannot contain expressions that require byref pointers</source>
        <target state="new">Quotations cannot contain expressions that require byref pointers</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantCallTraitMembers">
        <source>Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call</source>
        <target state="new">Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisConstant">
        <source>Quotations cannot contain this kind of constant</source>
        <target state="new">Quotations cannot contain this kind of constant</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisPatternMatch">
        <source>Quotations cannot contain this kind of pattern match</source>
        <target state="new">Quotations cannot contain this kind of pattern match</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainArrayPatternMatching">
        <source>Quotations cannot contain array pattern matching</source>
        <target state="new">Quotations cannot contain array pattern matching</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisType">
        <source>Quotations cannot contain this kind of type</source>
        <target state="new">Quotations cannot contain this kind of type</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeCannotBeResolvedAtCompileTime">
        <source>The declared type parameter '{0}' cannot be used here since the type parameter cannot be resolved at compile time</source>
        <target state="new">The declared type parameter '{0}' cannot be used here since the type parameter cannot be resolved at compile time</target>
        <note />
      </trans-unit>
      <trans-unit id="csCodeLessGeneric">
        <source>This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'.</source>
        <target state="new">This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInferenceMaxDepth">
        <source>Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.</source>
        <target state="new">Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectedArguments">
        <source>Expected arguments to an instance member</source>
        <target state="new">Expected arguments to an instance member</target>
        <note />
      </trans-unit>
      <trans-unit id="csIndexArgumentMismatch">
        <source>This indexer expects {0} arguments but is here given {1}</source>
        <target state="new">This indexer expects {0} arguments but is here given {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenFunction">
        <source>Expecting a type supporting the operator '{0}' but given a function type. You may be missing an argument to a function.</source>
        <target state="new">Expecting a type supporting the operator '{0}' but given a function type. You may be missing an argument to a function.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenTuple">
        <source>Expecting a type supporting the operator '{0}' but given a tuple type</source>
        <target state="new">Expecting a type supporting the operator '{0}' but given a tuple type</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperator">
        <source>None of the types '{0}' support the operator '{1}'</source>
        <target state="new">None of the types '{0}' support the operator '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperator">
        <source>The type '{0}' does not support the operator '{1}'</source>
        <target state="new">The type '{0}' does not support the operator '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperatorNullable">
        <source>None of the types '{0}' support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="new">None of the types '{0}' support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperatorNullable">
        <source>The type '{0}' does not support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="new">The type '{0}' does not support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportConversion">
        <source>The type '{0}' does not support a conversion to the type '{1}'</source>
        <target state="new">The type '{0}' does not support a conversion to the type '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is static</source>
        <target state="new">The type '{0}' has a method '{1}' (full name '{2}'), but the method is static</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsNotStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is not static</source>
        <target state="new">The type '{0}' has a method '{1}' (full name '{2}'), but the method is not static</target>
        <note />
      </trans-unit>
      <trans-unit id="csStructConstraintInconsistent">
        <source>The constraints 'struct' and 'not struct' are inconsistent</source>
        <target state="new">The constraints 'struct' and 'not struct' are inconsistent</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value</source>
        <target state="new">The type '{0}' does not have 'null' as a proper value</target>
        <note />
      </trans-unit>
      <trans-unit id="csNullableTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'.</source>
        <target state="new">The type '{0}' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison1">
        <source>The type '{0}' does not support the 'comparison' constraint because it has the 'NoComparison' attribute</source>
        <target state="new">The type '{0}' does not support the 'comparison' constraint because it has the 'NoComparison' attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison2">
        <source>The type '{0}' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface</source>
        <target state="new">The type '{0}' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison3">
        <source>The type '{0}' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison</source>
        <target state="new">The type '{0}' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality1">
        <source>The type '{0}' does not support the 'equality' constraint because it has the 'NoEquality' attribute</source>
        <target state="new">The type '{0}' does not support the 'equality' constraint because it has the 'NoEquality' attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality2">
        <source>The type '{0}' does not support the 'equality' constraint because it is a function type</source>
        <target state="new">The type '{0}' does not support the 'equality' constraint because it is a function type</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality3">
        <source>The type '{0}' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality</source>
        <target state="new">The type '{0}' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotEnumType">
        <source>The type '{0}' is not a CLI enum type</source>
        <target state="new">The type '{0}' is not a CLI enum type</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeHasNonStandardDelegateType">
        <source>The type '{0}' has a non-standard delegate type</source>
        <target state="new">The type '{0}' has a non-standard delegate type</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotDelegateType">
        <source>The type '{0}' is not a CLI delegate type</source>
        <target state="new">The type '{0}' is not a CLI delegate type</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeParameterCannotBeNullable">
        <source>This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values.</source>
        <target state="new">This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructType">
        <source>A generic construct requires that the type '{0}' is a CLI or F# struct type</source>
        <target state="new">A generic construct requires that the type '{0}' is a CLI or F# struct type</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresUnmanagedType">
        <source>A generic construct requires that the type '{0}' is an unmanaged type</source>
        <target state="new">A generic construct requires that the type '{0}' is an unmanaged type</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeNotCompatibleBecauseOfPrintf">
        <source>The type '{0}' is not compatible with any of the types {1}, arising from the use of a printf-style format string</source>
        <target state="new">The type '{0}' is not compatible with any of the types {1}, arising from the use of a printf-style format string</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresReferenceSemantics">
        <source>A generic construct requires that the type '{0}' have reference semantics, but it does not, i.e. it is a struct</source>
        <target state="new">A generic construct requires that the type '{0}' have reference semantics, but it does not, i.e. it is a struct</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresNonAbstract">
        <source>A generic construct requires that the type '{0}' be non-abstract</source>
        <target state="new">A generic construct requires that the type '{0}' be non-abstract</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresPublicDefaultConstructor">
        <source>A generic construct requires that the type '{0}' have a public default constructor</source>
        <target state="new">A generic construct requires that the type '{0}' have a public default constructor</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInstantiationLengthMismatch">
        <source>Type instantiation length mismatch</source>
        <target state="new">Type instantiation length mismatch</target>
        <note />
      </trans-unit>
      <trans-unit id="csOptionalArgumentNotPermittedHere">
        <source>Optional arguments not permitted here</source>
        <target state="new">Optional arguments not permitted here</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotStatic">
        <source>{0} is not a static member</source>
        <target state="new">{0} is not a static member</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotInstance">
        <source>{0} is not an instance member</source>
        <target state="new">{0} is not an instance member</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentLengthMismatch">
        <source>Argument length mismatch</source>
        <target state="new">Argument length mismatch</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentTypesDoNotMatch">
        <source>The argument types don't match</source>
        <target state="new">The argument types don't match</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodExpectsParams">
        <source>This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument</source>
        <target state="new">This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible">
        <source>The member or object constructor '{0}' is not {1}</source>
        <target state="new">The member or object constructor '{0}' is not {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible2">
        <source>The member or object constructor '{0}' is not {1}. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.</source>
        <target state="new">The member or object constructor '{0}' is not {1}. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAStaticMethod">
        <source>{0} is not a static method</source>
        <target state="new">{0} is not a static method</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAnInstanceMethod">
        <source>{0} is not an instance method</source>
        <target state="new">{0} is not an instance method</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberHasNoArgumentOrReturnProperty">
        <source>The member or object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="new">The member or object constructor '{0}' has no argument or settable return property '{1}'. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorHasNoArgumentOrReturnProperty">
        <source>The object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="new">The object constructor '{0}' has no argument or settable return property '{1}'. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csRequiredSignatureIs">
        <source>The required signature is {0}</source>
        <target state="new">The required signature is {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'.</source>
        <target state="new">The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch2">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'.</source>
        <target state="new">The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch3">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="new">The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch4">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="new">The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityNamed">
        <source>The member or object constructor '{0}' requires {1} argument(s) but is here given {2} unnamed and {3} named argument(s). The required signature is '{4}'.</source>
        <target state="new">The member or object constructor '{0}' requires {1} argument(s) but is here given {2} unnamed and {3} named argument(s). The required signature is '{4}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArity">
        <source>The member or object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="new">The member or object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArity">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="new">The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArityProp">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',').</source>
        <target state="new">The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',').</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityType">
        <source>The member or object constructor '{0}' takes {1} type argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="new">The member or object constructor '{0}' takes {1} type argument(s) but is here given {2}. The required signature is '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberNotAccessible">
        <source>A member or object constructor '{0}' taking {1} arguments is not accessible from this code location. All accessible versions of method '{2}' take {3} arguments.</source>
        <target state="new">A member or object constructor '{0}' taking {1} arguments is not accessible from this code location. All accessible versions of method '{2}' take {3} arguments.</target>
        <note />
      </trans-unit>
      <trans-unit id="csIncorrectGenericInstantiation">
        <source>Incorrect generic instantiation. No {0} member named '{1}' takes {2} generic arguments.</source>
        <target state="new">Incorrect generic instantiation. No {0} member named '{1}' takes {2} generic arguments.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberOverloadArityMismatch">
        <source>The member or object constructor '{0}' does not take {1} argument(s). An overload was found taking {2} arguments.</source>
        <target state="new">The member or object constructor '{0}' does not take {1} argument(s). An overload was found taking {2} arguments.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments</source>
        <target state="new">No {0} member or object constructor named '{1}' takes {2} arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments2">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. Note the call to this member also provides {3} named arguments.</source>
        <target state="new">No {0} member or object constructor named '{1}' takes {2} arguments. Note the call to this member also provides {3} named arguments.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments3">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. The named argument '{3}' doesn't correspond to any argument or settable return property for any overload.</source>
        <target state="new">No {0} member or object constructor named '{1}' takes {2} arguments. The named argument '{3}' doesn't correspond to any argument or settable return property for any overload.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodNotFound">
        <source>Method or object constructor '{0}' not found</source>
        <target state="new">Method or object constructor '{0}' not found</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFound">
        <source>No overloads match for method '{0}'.</source>
        <target state="new">No overloads match for method '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsOverloaded">
        <source>A unique overload for method '{0}' could not be determined based on type information prior to this program point. A type annotation may be needed.</source>
        <target state="new">A unique overload for method '{0}' could not be determined based on type information prior to this program point. A type annotation may be needed.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCandidates">
        <source>Candidates: {0}</source>
        <target state="new">Candidates: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csSeeAvailableOverloads">
        <source>The available overloads are shown below.</source>
        <target state="new">The available overloads are shown below.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsDoCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on 'do' bindings, but '{0}' was given.</source>
        <target state="new">Accessibility modifiers are not permitted on 'do' bindings, but '{0}' was given.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInHashIf">
        <source>End of file in #if section begun at or after here</source>
        <target state="new">End of file in #if section begun at or after here</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInString">
        <source>End of file in string begun at or before here</source>
        <target state="new">End of file in string begun at or before here</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimString">
        <source>End of file in verbatim string begun at or before here</source>
        <target state="new">End of file in verbatim string begun at or before here</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInComment">
        <source>End of file in comment begun at or before here</source>
        <target state="new">End of file in comment begun at or before here</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInStringInComment">
        <source>End of file in string embedded in comment begun at or before here</source>
        <target state="new">End of file in string embedded in comment begun at or before here</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimStringInComment">
        <source>End of file in verbatim string embedded in comment begun at or before here</source>
        <target state="new">End of file in verbatim string embedded in comment begun at or before here</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInIfOcaml">
        <source>End of file in IF-OCAML section begun at or before here</source>
        <target state="new">End of file in IF-OCAML section begun at or before here</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInDirective">
        <source>End of file in directive begun at or before here</source>
        <target state="new">End of file in directive begun at or before here</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoHashEndIfFound">
        <source>No #endif found for #if or #else</source>
        <target state="new">No #endif found for #if or #else</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIgnored">
        <source>Attributes have been ignored in this construct</source>
        <target state="new">Attributes have been ignored in this construct</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInImplicitClassConstructors">
        <source>'use' bindings are not permitted in primary constructors</source>
        <target state="new">'use' bindings are not permitted in primary constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInModules">
        <source>'use' bindings are not permitted in modules and are treated as 'let' bindings</source>
        <target state="new">'use' bindings are not permitted in modules and are treated as 'let' bindings</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIntegerForLoopRequiresSimpleIdentifier">
        <source>An integer for loop must use a simple identifier</source>
        <target state="new">An integer for loop must use a simple identifier</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyOneWithAugmentationAllowed">
        <source>At most one 'with' augmentation is permitted</source>
        <target state="new">At most one 'with' augmentation is permitted</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSemicolon">
        <source>A semicolon is not expected at this point</source>
        <target state="new">A semicolon is not expected at this point</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFile">
        <source>Unexpected end of input</source>
        <target state="new">Unexpected end of input</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedVisibilityDeclaration">
        <source>Accessibility modifiers are not permitted here, but '{0}' was given.</source>
        <target state="new">Accessibility modifiers are not permitted here, but '{0}' was given.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyHashDirectivesAllowed">
        <source>Only '#' compiler directives may occur prior to the first 'namespace' declaration</source>
        <target state="new">Only '#' compiler directives may occur prior to the first 'namespace' declaration</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityDeclarationsShouldComePriorToIdentifier">
        <source>Accessibility modifiers should come immediately prior to the identifier naming a construct</source>
        <target state="new">Accessibility modifiers should come immediately prior to the identifier naming a construct</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNamespaceOrModuleNotBoth">
        <source>Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'</source>
        <target state="new">Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleAbbreviationMustBeSimpleName">
        <source>A module abbreviation must be a simple name, not a path</source>
        <target state="new">A module abbreviation must be a simple name, not a path</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviation">
        <source>Ignoring attributes on module abbreviation</source>
        <target state="new">Ignoring attributes on module abbreviation</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="new">The '{0}' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="new">The '{0}' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnClosedBlockInHashLight">
        <source>Unclosed block</source>
        <target state="new">Unclosed block</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBeginOrStruct">
        <source>Unmatched 'begin' or 'struct'</source>
        <target state="new">Unmatched 'begin' or 'struct'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleDefnMustBeSimpleName">
        <source>A module name must be a simple name, not a path</source>
        <target state="new">A module name must be a simple name, not a path</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEmptyModuleDefn">
        <source>Unexpected empty type moduleDefn list</source>
        <target state="new">Unexpected empty type moduleDefn list</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesMustComeBeforeVal">
        <source>Attributes should be placed before 'val'</source>
        <target state="new">Attributes should be placed before 'val'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesAreNotPermittedOnInterfaceImplementations">
        <source>Attributes are not permitted on interface implementations</source>
        <target state="new">Attributes are not permitted on interface implementations</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxError">
        <source>Syntax error</source>
        <target state="new">Syntax error</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAugmentationsIllegalOnDelegateType">
        <source>Augmentations are not permitted on delegate type moduleDefns</source>
        <target state="new">Augmentations are not permitted on delegate type moduleDefns</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedClassInterfaceOrStruct">
        <source>Unmatched 'class', 'interface' or 'struct'</source>
        <target state="new">Unmatched 'class', 'interface' or 'struct'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyTypeDefinition">
        <source>A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'.</source>
        <target state="new">A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedWith">
        <source>Unmatched 'with' or badly formatted 'with' block</source>
        <target state="new">Unmatched 'with' or badly formatted 'with' block</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetOrSetRequired">
        <source>'get', 'set' or 'get,set' required</source>
        <target state="new">'get', 'set' or 'get,set' required</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyClassCanTakeValueArguments">
        <source>Only class types may take value arguments</source>
        <target state="new">Only class types may take value arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBegin">
        <source>Unmatched 'begin'</source>
        <target state="new">Unmatched 'begin'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidDeclarationSyntax">
        <source>Invalid declaration syntax</source>
        <target state="new">Invalid declaration syntax</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetAndOrSetRequired">
        <source>'get' and/or 'set' required</source>
        <target state="new">'get' and/or 'set' required</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAnnotationsOnGetSet">
        <source>Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'</source>
        <target state="new">Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterMustHaveAtLeastOneArgument">
        <source>A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'</source>
        <target state="new">A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultipleAccessibilitiesForGetSet">
        <source>Multiple accessibilities given for property getter or setter</source>
        <target state="new">Multiple accessibilities given for property getter or setter</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetSyntax">
        <source>Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '</source>
        <target state="new">Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInterfacesHaveSameVisibilityAsEnclosingType">
        <source>Interfaces always have the same visibility as the enclosing type</source>
        <target state="new">Interfaces always have the same visibility as the enclosing type</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAccessibilityModsIllegalForAbstract">
        <source>Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.</source>
        <target state="new">Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalOnInherit">
        <source>Attributes are not permitted on 'inherit' declarations</source>
        <target state="new">Attributes are not permitted on 'inherit' declarations</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityIllegalOnInherit">
        <source>Accessibility modifiers are not permitted on an 'inherits' declaration</source>
        <target state="new">Accessibility modifiers are not permitted on an 'inherits' declaration</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInheritDeclarationsCannotHaveAsBindings">
        <source>'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding.</source>
        <target state="new">'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalHere">
        <source>Attributes are not allowed here</source>
        <target state="new">Attributes are not allowed here</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for type abbreviations</source>
        <target state="new">Accessibility modifiers are not permitted in this position for type abbreviations</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumTypesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for enum types</source>
        <target state="new">Accessibility modifiers are not permitted in this position for enum types</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAllEnumFieldsRequireValues">
        <source>All enum fields must be given values</source>
        <target state="new">All enum fields must be given values</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInlineAssemblyCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on inline assembly code types</source>
        <target state="new">Accessibility modifiers are not permitted on inline assembly code types</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIdentifier">
        <source>Unexpected identifier: '{0}'</source>
        <target state="new">Unexpected identifier: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnionCasesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation.</source>
        <target state="new">Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on enumeration fields</source>
        <target state="new">Accessibility modifiers are not permitted on enumeration fields</target>
        <note />
      </trans-unit>
      <trans-unit id="parsConsiderUsingSeparateRecordType">
        <source>Consider using a separate record type instead</source>
        <target state="new">Consider using a separate record type instead</target>
        <note />
      </trans-unit>
      <trans-unit id="parsRecordFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation.</source>
        <target state="new">Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsLetAndForNonRecBindings">
        <source>The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings</source>
        <target state="new">The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedParen">
        <source>Unmatched '('</source>
        <target state="new">Unmatched '('</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessivePatternsShouldBeSpacedOrTupled">
        <source>Successive patterns should be separated by spaces or tupled</source>
        <target state="new">Successive patterns should be separated by spaces or tupled</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoMatchingInForLet">
        <source>No matching 'in' found for this 'let'</source>
        <target state="new">No matching 'in' found for this 'let'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorInReturnForLetIncorrectIndentation">
        <source>Error in the return expression for this 'let'. Possible incorrect indentation.</source>
        <target state="new">Error in the return expression for this 'let'. Possible incorrect indentation.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterLet">
        <source>The block following this '{0}' is unfinished. Every code block is an expression and must have a result. '{1}' cannot be the final code element in a block. Consider giving this block an explicit result.</source>
        <target state="new">The block following this '{0}' is unfinished. Every code block is an expression and must have a result. '{1}' cannot be the final code element in a block. Consider giving this block an explicit result.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIncompleteIf">
        <source>Incomplete conditional. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="new">Incomplete conditional. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAssertIsNotFirstClassValue">
        <source>'assert' may not be used as a first class value. Use 'assert &lt;expr&gt;' instead.</source>
        <target state="new">'assert' may not be used as a first class value. Use 'assert &lt;expr&gt;' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIdentifierExpected">
        <source>Identifier expected</source>
        <target state="new">Identifier expected</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInOrEqualExpected">
        <source>'in' or '=' expected</source>
        <target state="new">'in' or '=' expected</target>
        <note />
      </trans-unit>
      <trans-unit id="parsArrowUseIsLimited">
        <source>The use of '-&gt;' in sequence and computation expressions is limited to the form 'for pat in expr -&gt; expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions.</source>
        <target state="new">The use of '-&gt;' in sequence and computation expressions is limited to the form 'for pat in expr -&gt; expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessiveArgsShouldBeSpacedOrTupled">
        <source>Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized</source>
        <target state="new">Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracket">
        <source>Unmatched '['</source>
        <target state="new">Unmatched '['</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingQualificationAfterDot">
        <source>Missing qualification after '.'</source>
        <target state="new">Missing qualification after '.'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsParenFormIsForML">
        <source>In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array</source>
        <target state="new">In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuote">
        <source>Mismatched quotation, beginning with '{0}'</source>
        <target state="new">Mismatched quotation, beginning with '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatched">
        <source>Unmatched '{0}'</source>
        <target state="new">Unmatched '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracketBar">
        <source>Unmatched '[|'</source>
        <target state="new">Unmatched '[|'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBrace">
        <source>Unmatched '{{'</source>
        <target state="new">Unmatched '{{'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsFieldBinding">
        <source>Field bindings must have the form 'id = expr;'</source>
        <target state="new">Field bindings must have the form 'id = expr;'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMemberIllegalInObjectImplementation">
        <source>This member is not permitted in an object implementation</source>
        <target state="new">This member is not permitted in an object implementation</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingFunctionBody">
        <source>Missing function body</source>
        <target state="new">Missing function body</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxErrorInLabeledType">
        <source>Syntax error in labelled type argument</source>
        <target state="new">Syntax error in labelled type argument</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedInfixOperator">
        <source>Unexpected infix operator in type expression</source>
        <target state="new">Unexpected infix operator in type expression</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultiArgumentGenericTypeFormDeprecated">
        <source>The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident&lt;typ,...,typ&gt;' instead</source>
        <target state="new">The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident&lt;typ,...,typ&gt;' instead</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidLiteralInType">
        <source>Invalid literal in type</source>
        <target state="new">Invalid literal in type</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedOperatorForUnitOfMeasure">
        <source>Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'.</source>
        <target state="new">Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIntegerLiteralForUnitOfMeasure">
        <source>Unexpected integer literal in unit-of-measure expression</source>
        <target state="new">Unexpected integer literal in unit-of-measure expression</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedTypeParameter">
        <source>Syntax error: unexpected type parameter specification</source>
        <target state="new">Syntax error: unexpected type parameter specification</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuotationName">
        <source>Mismatched quotation operator name, beginning with '{0}'</source>
        <target state="new">Mismatched quotation operator name, beginning with '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseMustBeginWithUpperCase">
        <source>Active pattern case identifiers must begin with an uppercase letter</source>
        <target state="new">Active pattern case identifiers must begin with an uppercase letter</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseContainsPipe">
        <source>The '|' character is not permitted in active pattern case identifiers</source>
        <target state="new">The '|' character is not permitted in active pattern case identifiers</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalDenominatorForMeasureExponent">
        <source>Denominator must not be 0 in unit-of-measure exponent</source>
        <target state="new">Denominator must not be 0 in unit-of-measure exponent</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoEqualShouldFollowNamespace">
        <source>No '=' symbol should follow a 'namespace' declaration</source>
        <target state="new">No '=' symbol should follow a 'namespace' declaration</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleStructEndDeprecated">
        <source>The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="new">The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleSigEndDeprecated">
        <source>The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="new">The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticFieldUsedWhenInstanceFieldExpected">
        <source>A static field was used where an instance field is expected</source>
        <target state="new">A static field was used where an instance field is expected</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodNotAccessible">
        <source>Method '{0}' is not accessible from this code location</source>
        <target state="new">Method '{0}' is not accessible from this code location</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplicitMeasureFollowingSlash">
        <source>Implicit product of measures following /</source>
        <target state="new">Implicit product of measures following /</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedMeasureAnon">
        <source>Unexpected SynMeasure.Anon</source>
        <target state="new">Unexpected SynMeasure.Anon</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonZeroConstantCannotHaveGenericUnit">
        <source>Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.</source>
        <target state="new">Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSeqResultsUseYield">
        <source>In sequence expressions, results are generated using 'yield'</source>
        <target state="new">In sequence expressions, results are generated using 'yield'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedBigRationalConstant">
        <source>Unexpected big rational constant</source>
        <target state="new">Unexpected big rational constant</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForUnitsOfMeasure">
        <source>Units-of-measure supported only on float, float32, decimal and signed integer types</source>
        <target state="new">Units-of-measure supported only on float, float32, decimal and signed integer types</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstUint16Array">
        <source>Unexpected Const_uint16array</source>
        <target state="new">Unexpected Const_uint16array</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstByteArray">
        <source>Unexpected Const_bytearray</source>
        <target state="new">Unexpected Const_bytearray</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterRequiresName">
        <source>A parameter with attributes must also be given a name, e.g. '[&lt;Attribute&gt;] Name : Type'</source>
        <target state="new">A parameter with attributes must also be given a name, e.g. '[&lt;Attribute&gt;] Name : Type'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnValuesCannotHaveNames">
        <source>Return values cannot have names</source>
        <target state="new">Return values cannot have names</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberKindPropertyGetSetNotExpected">
        <source>MemberKind.PropertyGetSet only expected in parse trees</source>
        <target state="new">MemberKind.PropertyGetSet only expected in parse trees</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainValues">
        <source>Namespaces cannot contain values. Consider using a module to hold your value declarations.</source>
        <target state="new">Namespaces cannot contain values. Consider using a module to hold your value declarations.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainExtensionMembers">
        <source>Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.</source>
        <target state="new">Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributes">
        <source>Multiple visibility attributes have been specified for this identifier</source>
        <target state="new">Multiple visibility attributes have been specified for this identifier</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributesWithLet">
        <source>Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions.</source>
        <target state="new">Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForRelationalOperator">
        <source>The name '({0})' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="new">The name '({0})' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '{1}' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForEquality">
        <source>The name '({0})' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="new">The name '({0})' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '{1}' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberName">
        <source>The name '({0})' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="new">The name '({0})' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '{1}' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameFixedTypes">
        <source>The name '({0})' should not be used as a member name because it is given a standard definition in the F# library over fixed types</source>
        <target state="new">The name '({0})' should not be used as a member name because it is given a standard definition in the F# library over fixed types</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionRelational">
        <source>The '{0}' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type.</source>
        <target state="new">The '{0}' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionEquality">
        <source>The '{0}' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type.</source>
        <target state="new">The '{0}' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinition">
        <source>The '{0}' operator should not normally be redefined. Consider using a different operator name</source>
        <target state="new">The '{0}' operator should not normally be redefined. Consider using a different operator name</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexOperatorDefinition">
        <source>The '{0}' operator cannot be redefined. Consider using a different operator name</source>
        <target state="new">The '{0}' operator cannot be redefined. Consider using a different operator name</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectModuleOrNamespaceParent">
        <source>Expected module or namespace parent {0}</source>
        <target state="new">Expected module or namespace parent {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type.</source>
        <target state="new">The struct, record or union type '{0}' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsGenericIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable&lt;_&gt;' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.</source>
        <target state="new">The struct, record or union type '{0}' implements the interface 'System.IComparable&lt;_&gt;' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type.</source>
        <target state="new">The struct, record or union type '{0}' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordFieldInconsistentTypes">
        <source>This record contains fields from inconsistent types</source>
        <target state="new">This record contains fields from inconsistent types</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportStubsCannotBeInlined">
        <source>DLLImport stubs cannot be inlined</source>
        <target state="new">DLLImport stubs cannot be inlined</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCanOnlyBindThisAtMemberDeclaration">
        <source>Structs may only bind a 'this' parameter at member declarations</source>
        <target state="new">Structs may only bind a 'this' parameter at member declarations</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedExprAtRecInfPoint">
        <source>Unexpected expression at recursive inference point</source>
        <target state="new">Unexpected expression at recursive inference point</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLessGenericBecauseOfAnnotation">
        <source>This code is less generic than required by its annotations because the explicit type variable '{0}' could not be generalized. It was constrained to be '{1}'.</source>
        <target state="new">This code is less generic than required by its annotations because the explicit type variable '{0}' could not be generalized. It was constrained to be '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstrainedTypeVariableCannotBeGeneralized">
        <source>One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types</source>
        <target state="new">One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericParameterHasBeenConstrained">
        <source>A generic type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="new">A generic type parameter has been used in a way that constrains it to always be '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterHasBeenConstrained">
        <source>This type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="new">This type parameter has been used in a way that constrains it to always be '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParametersInferredAreNotStable">
        <source>The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</source>
        <target state="new">The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeParameterInvalid">
        <source>Explicit type parameters may only be used on module or member bindings</source>
        <target state="new">Explicit type parameters may only be used on module or member bindings</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridingMethodRequiresAllOrNoTypeParameters">
        <source>You must explicitly declare either all or no type parameters when overriding a generic abstract method</source>
        <target state="new">You must explicitly declare either all or no type parameters when overriding a generic abstract method</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldsDoNotDetermineUniqueRecordType">
        <source>The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type</source>
        <target state="new">The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldAppearsTwiceInRecord">
        <source>The field '{0}' appears twice in this record expression or pattern</source>
        <target state="new">The field '{0}' appears twice in this record expression or pattern</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnknownUnion">
        <source>Unknown union case</source>
        <target state="new">Unknown union case</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotSufficientlyGenericBecauseOfScope">
        <source>This code is not sufficiently generic. The type variable {0} could not be generalized because it would escape its scope.</source>
        <target state="new">This code is not sufficiently generic. The type variable {0} could not be generalized because it would escape its scope.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyRequiresExplicitTypeParameters">
        <source>A property cannot have explicit type parameters. Consider using a method instead.</source>
        <target state="new">A property cannot have explicit type parameters. Consider using a method instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorCannotHaveTypeParameters">
        <source>A constructor cannot have explicit type parameters. Consider using a static construction method instead.</source>
        <target state="new">A constructor cannot have explicit type parameters. Consider using a static construction method instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInstanceMemberRequiresTarget">
        <source>This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'.</source>
        <target state="new">This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertyInSyntaxTree">
        <source>Unexpected source-level property specification in syntax tree</source>
        <target state="new">Unexpected source-level property specification in syntax tree</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializerRequiresArgument">
        <source>A static initializer requires an argument</source>
        <target state="new">A static initializer requires an argument</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorRequiresArgument">
        <source>An object constructor requires an argument</source>
        <target state="new">An object constructor requires an argument</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticMemberShouldNotHaveThis">
        <source>This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'.</source>
        <target state="new">This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitStaticInitializerSyntax">
        <source>An explicit static initializer should use the syntax 'static new(args) = expr'</source>
        <target state="new">An explicit static initializer should use the syntax 'static new(args) = expr'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitObjectConstructorSyntax">
        <source>An explicit object constructor should use the syntax 'new(args) = expr'</source>
        <target state="new">An explicit object constructor should use the syntax 'new(args) = expr'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertySpec">
        <source>Unexpected source-level property specification</source>
        <target state="new">Unexpected source-level property specification</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionFormDeprecated">
        <source>This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions.</source>
        <target state="new">This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDeclaration">
        <source>Invalid declaration</source>
        <target state="new">Invalid declaration</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesInvalidInPatterns">
        <source>Attributes are not allowed within patterns</source>
        <target state="new">Attributes are not allowed within patterns</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitTypeArguments">
        <source>The generic function '{0}' must be given explicit type argument(s)</source>
        <target state="new">The generic function '{0}' must be given explicit type argument(s)</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoesNotAllowExplicitTypeArguments">
        <source>The method or function '{0}' should not be given explicit type argument(s) because it does not declare its type parameters explicitly</source>
        <target state="new">The method or function '{0}' should not be given explicit type argument(s) because it does not declare its type parameters explicitly</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterArityMismatch">
        <source>This value, type or method expects {0} type parameter(s) but was given {1}</source>
        <target state="new">This value, type or method expects {0} type parameter(s) but was given {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultStructConstructorCall">
        <source>The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization</source>
        <target state="new">The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindIDisposable">
        <source>Couldn't find Dispose on IDisposable, or it was overloaded</source>
        <target state="new">Couldn't find Dispose on IDisposable, or it was overloaded</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonLiteralCannotBeUsedInPattern">
        <source>This value is not a literal and cannot be used in a pattern</source>
        <target state="new">This value is not a literal and cannot be used in a pattern</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsReadonly">
        <source>This field is readonly</source>
        <target state="new">This field is readonly</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameArgumentsMustAppearLast">
        <source>Named arguments must appear after all other arguments</source>
        <target state="new">Named arguments must appear after all other arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitLambda">
        <source>This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking {0} arguments.</source>
        <target state="new">This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking {0} arguments.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCannotBeEnumerated">
        <source>The type '{0}' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method</source>
        <target state="new">The type '{0}' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMixtureOfRecursiveForms">
        <source>This recursive binding uses an invalid mixture of recursive forms</source>
        <target state="new">This recursive binding uses an invalid mixture of recursive forms</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectConstructionExpression">
        <source>This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.</source>
        <target state="new">This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraint">
        <source>Invalid constraint</source>
        <target state="new">Invalid constraint</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraintTypeSealed">
        <source>Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution</source>
        <target state="new">Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumConstraint">
        <source>An 'enum' constraint must be of the form 'enum&lt;type&gt;'</source>
        <target state="new">An 'enum' constraint must be of the form 'enum&lt;type&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNewConstraint">
        <source>'new' constraints must take one argument of type 'unit' and return the constructed type</source>
        <target state="new">'new' constraints must take one argument of type 'unit' and return the constructed type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPropertyType">
        <source>This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -&gt; ty3'. Properties returning functions should have types of the form '(ty1 -&gt; ty2)'.</source>
        <target state="new">This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -&gt; ty3'. Properties returning functions should have types of the form '(ty1 -&gt; ty2)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureMarkWithAttribute">
        <source>Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.</source>
        <target state="new">Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeParameter">
        <source>Expected type parameter, not unit-of-measure parameter</source>
        <target state="new">Expected type parameter, not unit-of-measure parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeNotUnitOfMeasure">
        <source>Expected type, not unit-of-measure</source>
        <target state="new">Expected type, not unit-of-measure</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureNotType">
        <source>Expected unit-of-measure, not type</source>
        <target state="new">Expected unit-of-measure, not type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUnitsOfMeasurePrefix">
        <source>Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.</source>
        <target state="new">Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnitsOfMeasureInvalidInTypeConstructor">
        <source>Unit-of-measure cannot be used in type constructor application</source>
        <target state="new">Unit-of-measure cannot be used in type constructor application</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireBuilderMethod">
        <source>This control construct may only be used if the computation expression builder defines a '{0}' method</source>
        <target state="new">This control construct may only be used if the computation expression builder defines a '{0}' method</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoNestedTypes">
        <source>This type has no nested types</source>
        <target state="new">This type has no nested types</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSymbolInTypeExpression">
        <source>Unexpected {0} in type expression</source>
        <target state="new">Unexpected {0} in type expression</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterInvalidAsTypeConstructor">
        <source>Type parameter cannot be used as type constructor</source>
        <target state="new">Type parameter cannot be used as type constructor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalSyntaxInTypeExpression">
        <source>Illegal syntax in type expression</source>
        <target state="new">Illegal syntax in type expression</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousUnitsOfMeasureCannotBeNested">
        <source>Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression</source>
        <target state="new">Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousTypeInvalidInDeclaration">
        <source>Anonymous type variables are not permitted in this declaration</source>
        <target state="new">Anonymous type variables are not permitted in this declaration</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSlashInType">
        <source>Unexpected / in type</source>
        <target state="new">Unexpected / in type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedTypeArguments">
        <source>Unexpected type arguments</source>
        <target state="new">Unexpected type arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsOnlyOnMembers">
        <source>Optional arguments are only permitted on type members</source>
        <target state="new">Optional arguments are only permitted on type members</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameNotBoundInPattern">
        <source>Name '{0}' not bound in pattern context</source>
        <target state="new">Name '{0}' not bound in pattern context</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNonPrimitiveLiteralInPatternMatch">
        <source>Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when &lt;variable&gt; = &lt;constant&gt;' at the end of the match clause.</source>
        <target state="new">Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when &lt;variable&gt; = &lt;constant&gt;' at the end of the match clause.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentUsage">
        <source>Type arguments cannot be specified here</source>
        <target state="new">Type arguments cannot be specified here</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireActivePatternWithOneResult">
        <source>Only active patterns returning exactly one result may accept arguments</source>
        <target state="new">Only active patterns returning exactly one result may accept arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidArgForParameterizedPattern">
        <source>Invalid argument to parameterized pattern label</source>
        <target state="new">Invalid argument to parameterized pattern label</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexIntoActivePatternArray">
        <source>Internal error. Invalid index into active pattern array</source>
        <target state="new">Internal error. Invalid index into active pattern array</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseDoesNotTakeArguments">
        <source>This union case does not take arguments</source>
        <target state="new">This union case does not take arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseRequiresOneArgument">
        <source>This union case takes one argument</source>
        <target state="new">This union case takes one argument</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseExpectsTupledArguments">
        <source>This union case expects {0} arguments in tupled form</source>
        <target state="new">This union case expects {0} arguments in tupled form</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotStatic">
        <source>Field '{0}' is not static</source>
        <target state="new">Field '{0}' is not static</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNotLiteralCannotBeUsedInPattern">
        <source>This field is not a literal and cannot be used in a pattern</source>
        <target state="new">This field is not a literal and cannot be used in a pattern</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireVarConstRecogOrLiteral">
        <source>This is not a variable, constant, active recognizer or literal</source>
        <target state="new">This is not a variable, constant, active recognizer or literal</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPattern">
        <source>This is not a valid pattern</source>
        <target state="new">This is not a valid pattern</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseWhenPatternGuard">
        <source>Character range matches have been removed in F#. Consider using a 'when' pattern guard instead.</source>
        <target state="new">Character range matches have been removed in F#. Consider using a 'when' pattern guard instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalPattern">
        <source>Illegal pattern</source>
        <target state="new">Illegal pattern</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxErrorUnexpectedQMark">
        <source>Syntax error - unexpected '?' symbol</source>
        <target state="new">Syntax error - unexpected '?' symbol</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionCountMisMatch">
        <source>Expected {0} expressions, got {1}</source>
        <target state="new">Expected {0} expressions, got {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExprUndelayed">
        <source>TcExprUndelayed: delayed</source>
        <target state="new">TcExprUndelayed: delayed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionRequiresSequence">
        <source>This expression form may only be used in sequence and computation expressions</source>
        <target state="new">This expression form may only be used in sequence and computation expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectExpressionSyntaxForm">
        <source>Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.</source>
        <target state="new">Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectSequenceOrRecordExpression">
        <source>Invalid object, sequence or record expression</source>
        <target state="new">Invalid object, sequence or record expression</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSequenceExpressionSyntaxForm">
        <source>Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq {{ ... }}'</source>
        <target state="new">Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq {{ ... }}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionWithIfRequiresParenthesis">
        <source>This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression</source>
        <target state="new">This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseFormatString">
        <source>Unable to parse format string '{0}'</source>
        <target state="new">Unable to parse format string '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcListLiteralMaxSize">
        <source>This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.</source>
        <target state="new">This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresObjectConstructor">
        <source>The expression form 'expr then expr' may only be used as part of an explicit object constructor</source>
        <target state="new">The expression form 'expr then expr' may only be used as part of an explicit object constructor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentsCannotBeUsedInMemberTraits">
        <source>Named arguments cannot be given to member trait calls</source>
        <target state="new">Named arguments cannot be given to member trait calls</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotValidEnumCaseName">
        <source>This is not a valid name for an enumeration case</source>
        <target state="new">This is not a valid name for an enumeration case</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotMutable">
        <source>This field is not mutable</source>
        <target state="new">This field is not mutable</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresListArrayOrSequence">
        <source>This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq {{ ... }}', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements</source>
        <target state="new">This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq {{ ... }}', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpressions">
        <source>This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'.</source>
        <target state="new">This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresSequenceOrComputations">
        <source>This construct may only be used within sequence or computation expressions</source>
        <target state="new">This construct may only be used within sequence or computation expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpression">
        <source>This construct may only be used within computation expressions</source>
        <target state="new">This construct may only be used within computation expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexerExpression">
        <source>Invalid indexer expression</source>
        <target state="new">Invalid indexer expression</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
        <source>The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints</source>
        <target state="new">The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromVariableType">
        <source>Cannot inherit from a variable type</source>
        <target state="new">Cannot inherit from a variable type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsOnTypeParametersCannotTakeArguments">
        <source>Calls to object constructors on type parameters cannot be given arguments</source>
        <target state="new">Calls to object constructors on type parameters cannot be given arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCompiledNameAttributeMisused">
        <source>The 'CompiledName' attribute cannot be used with this language element</source>
        <target state="new">The 'CompiledName' attribute cannot be used with this language element</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedTypeRequired">
        <source>'{0}' may only be used with named types</source>
        <target state="new">'{0}' may only be used with named types</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritCannotBeUsedOnInterfaceType">
        <source>'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead.</source>
        <target state="new">'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewCannotBeUsedOnInterfaceType">
        <source>'new' cannot be used on interface types. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="new">'new' cannot be used on interface types. Consider using an object expression '{{ new ... with ... }}' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractTypeCannotBeInstantiated">
        <source>Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="new">Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{{ new ... with ... }}' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIDisposableTypeShouldUseNew">
        <source>It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value</source>
        <target state="new">It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxCanOnlyBeUsedToCreateObjectTypes">
        <source>'{0}' may only be used to construct object types</source>
        <target state="new">'{0}' may only be used to construct object types</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresCall">
        <source>Constructors for the type '{0}' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.</source>
        <target state="new">Constructors for the type '{0}' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUndefinedField">
        <source>The field '{0}' has been given a value, but is not present in the type '{1}'</source>
        <target state="new">The field '{0}' has been given a value, but is not present in the type '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresAssignment">
        <source>No assignment given for field '{0}' of type '{1}'</source>
        <target state="new">No assignment given for field '{0}' of type '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExtraneousFieldsGivenValues">
        <source>Extraneous fields have been given values</source>
        <target state="new">Extraneous fields have been given values</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
        <source>Only overrides of abstract and virtual members may be specified in object expressions</source>
        <target state="new">Only overrides of abstract and virtual members may be specified in object expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoAbstractOrVirtualMemberFound">
        <source>The member '{0}' does not correspond to any abstract or virtual method available to override or implement.</source>
        <target state="new">The member '{0}' does not correspond to any abstract or virtual method available to override or implement.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberFoundIsNotAbstractOrVirtual">
        <source>The type {0} contains the member '{1}' but it is not a virtual or abstract method that is available to override or implement.</source>
        <target state="new">The type {0} contains the member '{1}' but it is not a virtual or abstract method that is available to override or implement.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatch">
        <source>The member '{0}' does not accept the correct number of arguments. {1} argument(s) are expected, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="new">The member '{0}' does not accept the correct number of arguments. {1} argument(s) are expected, but {2} were given. The required signature is '{3}'.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatchOneOverload">
        <source>The member '{0}' does not accept the correct number of arguments. One overload accepts {1} arguments, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="new">The member '{0}' does not accept the correct number of arguments. One overload accepts {1} arguments, but {2} were given. The required signature is '{3}'.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSimpleMethodNameRequired">
        <source>A simple method name is required here</source>
        <target state="new">A simple method name is required here</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPredefinedTypeCannotBeUsedAsSuperType">
        <source>The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class</source>
        <target state="new">The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMustBeUsedWithNamedType">
        <source>'new' must be used with a named type</source>
        <target state="new">'new' must be used with a named type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCreateExtensionOfSealedType">
        <source>Cannot create an extension of a sealed type</source>
        <target state="new">Cannot create an extension of a sealed type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoArgumentsForRecordValue">
        <source>No arguments may be given when constructing a record value</source>
        <target state="new">No arguments may be given when constructing a record value</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoInterfaceImplementationForConstructionExpression">
        <source>Interface implementations cannot be given on construction expressions</source>
        <target state="new">Interface implementations cannot be given on construction expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionCanOnlyBeUsedInClassTypes">
        <source>Object construction expressions may only be used to implement constructors in class types</source>
        <target state="new">Object construction expressions may only be used to implement constructors in class types</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
        <source>Only simple bindings of the form 'id = expr' can be used in construction expressions</source>
        <target state="new">Only simple bindings of the form 'id = expr' can be used in construction expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectsMustBeInitializedWithObjectExpression">
        <source>Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field</source>
        <target state="new">Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedInterfaceType">
        <source>Expected an interface type</source>
        <target state="new">Expected an interface type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorForInterfacesDoNotTakeArguments">
        <source>Constructor expressions for interfaces do not take arguments</source>
        <target state="new">Constructor expressions for interfaces do not take arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresArguments">
        <source>This object constructor requires arguments</source>
        <target state="new">This object constructor requires arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewRequiresObjectConstructor">
        <source>'new' may only be used with object constructors</source>
        <target state="new">'new' may only be used with object constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAtLeastOneOverrideIsInvalid">
        <source>At least one override did not correctly implement its corresponding abstract member</source>
        <target state="new">At least one override did not correctly implement its corresponding abstract member</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNumericLiteralRequiresModule">
        <source>This numeric literal requires that a module '{0}' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope</source>
        <target state="new">This numeric literal requires that a module '{0}' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRecordConstruction">
        <source>Invalid record construction</source>
        <target state="new">Invalid record construction</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresRecordTypes">
        <source>The expression form {{ expr with ... }} may only be used with record types. To build object types use {{ new Type(...) with ... }}</source>
        <target state="new">The expression form {{ expr with ... }} may only be used with record types. To build object types use {{ new Type(...) with ... }}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritedTypeIsNotObjectModelType">
        <source>The inherited type is not an object model type</source>
        <target state="new">The inherited type is not an object model type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
        <source>Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors</source>
        <target state="new">Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyRecordInvalid">
        <source>'{{ }}' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.</source>
        <target state="new">'{{ }}' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordTypeNeedConstructor">
        <source>This type is not a record type. Values of class and struct types must be created using calls to object constructors.</source>
        <target state="new">This type is not a record type. Values of class and struct types must be created using calls to object constructors.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordType">
        <source>This type is not a record type</source>
        <target state="new">This type is not a record type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInComputationExpression">
        <source>This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder {{ ... }}'.</source>
        <target state="new">This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder {{ ... }}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInSequenceExpression">
        <source>This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {{... }}'.</source>
        <target state="new">This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {{... }}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoBangIllegalInSequenceExpression">
        <source>'do!' cannot be used within sequence expressions</source>
        <target state="new">'do!' cannot be used within sequence expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseForInSequenceExpression">
        <source>The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead.</source>
        <target state="new">The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryIllegalInSequenceExpression">
        <source>'try'/'with' cannot be used within sequence expressions</source>
        <target state="new">'try'/'with' cannot be used within sequence expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseYieldBangForMultipleResults">
        <source>In sequence expressions, multiple results are generated using 'yield!'</source>
        <target state="new">In sequence expressions, multiple results are generated using 'yield!'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAssignment">
        <source>Invalid assignment</source>
        <target state="new">Invalid assignment</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfTypeName">
        <source>Invalid use of a type name</source>
        <target state="new">Invalid use of a type name</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoAccessibleConstructor">
        <source>This type has no accessible object constructors</source>
        <target state="new">This type has no accessible object constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfInterfaceType">
        <source>Invalid use of an interface type</source>
        <target state="new">Invalid use of an interface type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfDelegate">
        <source>Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'.</source>
        <target state="new">Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotStatic">
        <source>Property '{0}' is not static</source>
        <target state="new">Property '{0}' is not static</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotReadable">
        <source>Property '{0}' is not readable</source>
        <target state="new">Property '{0}' is not readable</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLookupMayNotBeUsedHere">
        <source>This lookup cannot be used here</source>
        <target state="new">This lookup cannot be used here</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsStatic">
        <source>Property '{0}' is static</source>
        <target state="new">Property '{0}' is static</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet1">
        <source>Property '{0}' cannot be set</source>
        <target state="new">Property '{0}' cannot be set</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsCannotBeFirstClassValues">
        <source>Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</source>
        <target state="new">Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
        <source>The syntax 'expr.id' may only be used with record labels, properties and fields</source>
        <target state="new">The syntax 'expr.id' may only be used with record labels, properties and fields</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsStatic">
        <source>Event '{0}' is static</source>
        <target state="new">Event '{0}' is static</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsNotStatic">
        <source>Event '{0}' is not static</source>
        <target state="new">Event '{0}' is not static</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentDidNotMatch">
        <source>The named argument '{0}' did not match any argument or mutable property</source>
        <target state="new">The named argument '{0}' did not match any argument or mutable property</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverloadsCannotHaveCurriedArguments">
        <source>One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.</source>
        <target state="new">One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnnamedArgumentsDoNotFormPrefix">
        <source>The unnamed arguments do not form a prefix of the arguments of the method called</source>
        <target state="new">The unnamed arguments do not form a prefix of the arguments of the method called</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
        <source>Static optimization conditionals are only for use within the F# library</source>
        <target state="new">Static optimization conditionals are only for use within the F# library</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFormalArgumentIsNotOptional">
        <source>The corresponding formal argument is not optional</source>
        <target state="new">The corresponding formal argument is not optional</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOptionalAssignmentToPropertyOrField">
        <source>Invalid optional assignment to a property or field</source>
        <target state="new">Invalid optional assignment to a property or field</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegateConstructorMustBePassed">
        <source>A delegate constructor must be passed a single function value</source>
        <target state="new">A delegate constructor must be passed a single function value</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindingCannotBeUseAndRec">
        <source>A binding cannot be marked both 'use' and 'rec'</source>
        <target state="new">A binding cannot be marked both 'use' and 'rec'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileOnlyOnClassLetBindings">
        <source>The 'VolatileField' attribute may only be used on 'let' bindings in classes</source>
        <target state="new">The 'VolatileField' attribute may only be used on 'let' bindings in classes</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesAreNotPermittedOnLetBindings">
        <source>Attributes are not permitted on 'let' bindings in expressions</source>
        <target state="new">Attributes are not permitted on 'let' bindings in expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultValueAttributeRequiresVal">
        <source>The 'DefaultValue' attribute may only be used on 'val' declarations</source>
        <target state="new">The 'DefaultValue' attribute may only be used on 'val' declarations</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeRequiresMembers">
        <source>The 'ConditionalAttribute' attribute may only be used on members</source>
        <target state="new">The 'ConditionalAttribute' attribute may only be used on members</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidActivePatternName">
        <source>This is not a valid name for an active pattern</source>
        <target state="new">This is not a valid name for an active pattern</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEntryPointAttributeRequiresFunctionInModule">
        <source>The 'EntryPointAttribute' attribute may only be used on function definitions in modules</source>
        <target state="new">The 'EntryPointAttribute' attribute may only be used on function definitions in modules</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesCannotBeInline">
        <source>Mutable values cannot be marked 'inline'</source>
        <target state="new">Mutable values cannot be marked 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesMayNotHaveGenericParameters">
        <source>Mutable values cannot have generic parameters</source>
        <target state="new">Mutable values cannot have generic parameters</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesSyntax">
        <source>Mutable function values should be written 'let mutable f = (fun args -&gt; ...)'</source>
        <target state="new">Mutable function values should be written 'let mutable f = (fun args -&gt; ...)'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyFunctionsCanBeInline">
        <source>Only functions may be marked 'inline'</source>
        <target state="new">Only functions may be marked 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalAttributesForLiteral">
        <source>A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes</source>
        <target state="new">A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeMutable">
        <source>A literal value cannot be marked 'mutable'</source>
        <target state="new">A literal value cannot be marked 'mutable'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeInline">
        <source>A literal value cannot be marked 'inline'</source>
        <target state="new">A literal value cannot be marked 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotHaveGenericParameters">
        <source>Literal values cannot have generic parameters</source>
        <target state="new">Literal values cannot have generic parameters</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstantExpression">
        <source>This is not a valid constant expression</source>
        <target state="new">This is not a valid constant expression</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsInaccessible">
        <source>This type is not accessible from this code location</source>
        <target state="new">This type is not accessible from this code location</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConditionInImportedAssembly">
        <source>Unexpected condition in imported assembly: failed to decode AttributeUsage attribute</source>
        <target state="new">Unexpected condition in imported assembly: failed to decode AttributeUsage attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedAttributeTarget">
        <source>Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</source>
        <target state="new">Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElementUseDo">
        <source>This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module.</source>
        <target state="new">This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElement">
        <source>This attribute is not valid for use on this language element</source>
        <target state="new">This attribute is not valid for use on this language element</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgumentsCannotBeUsedInCustomAttribute">
        <source>Optional arguments cannot be used in custom attributes</source>
        <target state="new">Optional arguments cannot be used in custom attributes</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet0">
        <source>This property cannot be set</source>
        <target state="new">This property cannot be set</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyOrFieldNotFoundInAttribute">
        <source>This property or field was not found on this custom attribute type</source>
        <target state="new">This property or field was not found on this custom attribute type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustBeReferenceType">
        <source>A custom attribute must be a reference type</source>
        <target state="new">A custom attribute must be a reference type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeArgumentMismatch">
        <source>The number of args for a custom attribute does not match the expected number of args for the attribute constructor</source>
        <target state="new">The number of args for a custom attribute does not match the expected number of args for the attribute constructor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustInvokeConstructor">
        <source>A custom attribute must invoke an object constructor</source>
        <target state="new">A custom attribute must invoke an object constructor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeExpressionsMustBeConstructorCalls">
        <source>Attribute expressions must be calls to object constructors</source>
        <target state="new">Attribute expressions must be calls to object constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedAttribute">
        <source>This attribute cannot be used in this version of F#</source>
        <target state="new">This attribute cannot be used in this version of F#</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidInlineSpecification">
        <source>Invalid inline specification</source>
        <target state="new">Invalid inline specification</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBinding">
        <source>'use' bindings must be of the form 'use &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="new">'use' bindings must be of the form 'use &lt;var&gt; = &lt;expr&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractMembersIllegalInAugmentation">
        <source>Abstract members are not permitted in an augmentation - they must be defined as part of the type itself</source>
        <target state="new">Abstract members are not permitted in an augmentation - they must be defined as part of the type itself</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodOverridesIllegalHere">
        <source>Method overrides and interface implementations are not permitted here</source>
        <target state="new">Method overrides and interface implementations are not permitted here</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoMemberFoundForOverride">
        <source>No abstract or interface member was found that corresponds to this override</source>
        <target state="new">No abstract or interface member was found that corresponds to this override</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverrideArityMismatch">
        <source>This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:{0}</source>
        <target state="new">This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationAlreadyExists">
        <source>This method already has a default implementation</source>
        <target state="new">This method already has a default implementation</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultAmbiguous">
        <source>The method implemented by this default is ambiguous</source>
        <target state="new">The method implemented by this default is ambiguous</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoPropertyFoundForOverride">
        <source>No abstract property was found that corresponds to this override</source>
        <target state="new">No abstract property was found that corresponds to this override</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractPropertyMissingGetOrSet">
        <source>This property overrides or implements an abstract property but the abstract property doesn't have a corresponding {0}</source>
        <target state="new">This property overrides or implements an abstract property but the abstract property doesn't have a corresponding {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSignatureForSet">
        <source>Invalid signature for set member</source>
        <target state="new">Invalid signature for set member</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMember">
        <source>This new member hides the abstract member '{0}'. Rename the member or use 'override' instead.</source>
        <target state="new">This new member hides the abstract member '{0}'. Rename the member or use 'override' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMemberWithSuffix">
        <source>This new member hides the abstract member '{0}' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead.</source>
        <target state="new">This new member hides the abstract member '{0}' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializersIllegalInInterface">
        <source>Interfaces cannot contain definitions of static initializers</source>
        <target state="new">Interfaces cannot contain definitions of static initializers</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsIllegalInInterface">
        <source>Interfaces cannot contain definitions of object constructors</source>
        <target state="new">Interfaces cannot contain definitions of object constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOverridesIllegalInInterface">
        <source>Interfaces cannot contain definitions of member overrides</source>
        <target state="new">Interfaces cannot contain definitions of member overrides</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConcreteMembersIllegalInInterface">
        <source>Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.</source>
        <target state="new">Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsDisallowedInExceptionAugmentation">
        <source>Constructors cannot be specified in exception augmentations</source>
        <target state="new">Constructors cannot be specified in exception augmentations</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCannotHaveConstructorWithNoArguments">
        <source>Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.</source>
        <target state="new">Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalForThisType">
        <source>Constructors cannot be defined for this type</source>
        <target state="new">Constructors cannot be defined for this type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
        <source>Recursive bindings that include member specifications can only occur as a direct augmentation of a type</source>
        <target state="new">Recursive bindings that include member specifications can only occur as a direct augmentation of a type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimplePatternsInLetRec">
        <source>Only simple variable patterns can be bound in 'let rec' constructs</source>
        <target state="new">Only simple variable patterns can be bound in 'let rec' constructs</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
        <source>Only record fields and simple, non-recursive 'let' bindings may be marked mutable</source>
        <target state="new">Only record fields and simple, non-recursive 'let' bindings may be marked mutable</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberIsNotSufficientlyGeneric">
        <source>This member is not sufficiently generic</source>
        <target state="new">This member is not sufficiently generic</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralAttributeRequiresConstantValue">
        <source>A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. 'val x : int = 1'</source>
        <target state="new">A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. 'val x : int = 1'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcValueInSignatureRequiresLiteralAttribute">
        <source>A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute</source>
        <target state="new">A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThreadStaticAndContextStaticMustBeStatic">
        <source>Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread</source>
        <target state="new">Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileFieldsMustBeMutable">
        <source>Volatile fields must be marked 'mutable' and cannot be thread-static</source>
        <target state="new">Volatile fields must be marked 'mutable' and cannot be thread-static</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUninitializedValFieldsMustBeMutable">
        <source>Uninitialized 'val' fields must be mutable and marked with the '[&lt;DefaultValue&gt;]' attribute. Consider using a 'let' binding instead of a 'val' field.</source>
        <target state="new">Uninitialized 'val' fields must be mutable and marked with the '[&lt;DefaultValue&gt;]' attribute. Consider using a 'let' binding instead of a 'val' field.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticValFieldsMustBeMutableAndPrivate">
        <source>Static 'val' fields in types must be mutable, private and marked with the '[&lt;DefaultValue&gt;]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type.</source>
        <target state="new">Static 'val' fields in types must be mutable, private and marked with the '[&lt;DefaultValue&gt;]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresName">
        <source>This field requires a name</source>
        <target state="new">This field requires a name</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNamespaceModuleTypeUnionName">
        <source>Invalid namespace, module, type or union case name</source>
        <target state="new">Invalid namespace, module, type or union case name</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalFormForExplicitTypeDeclaration">
        <source>Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -&gt; resTy'. Parentheses may be required around 'resTy'</source>
        <target state="new">Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -&gt; resTy'. Parentheses may be required around 'resTy'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnTypesForUnionMustBeSameAsType">
        <source>Return types of union cases must be identical to the type being defined, up to abbreviations</source>
        <target state="new">Return types of union cases must be identical to the type being defined, up to abbreviations</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumerationLiteral">
        <source>This is not a valid value for an enumeration literal</source>
        <target state="new">This is not a valid value for an enumeration literal</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType1">
        <source>The type '{0}' is not an interface type</source>
        <target state="new">The type '{0}' is not an interface type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDuplicateSpecOfInterface">
        <source>Duplicate specification of an interface</source>
        <target state="new">Duplicate specification of an interface</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldValIllegalHere">
        <source>A field/val declaration is not permitted here</source>
        <target state="new">A field/val declaration is not permitted here</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritIllegalHere">
        <source>A inheritance declaration is not permitted here</source>
        <target state="new">A inheritance declaration is not permitted here</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleRequiresQualifiedAccess">
        <source>This declaration opens the module '{0}', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.</source>
        <target state="new">This declaration opens the module '{0}', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenUsedWithPartiallyQualifiedPath">
        <source>This declaration opens the namespace or module '{0}' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.</source>
        <target state="new">This declaration opens the namespace or module '{0}' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLocalClassBindingsCannotBeInline">
        <source>Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.</source>
        <target state="new">Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsMayNotHaveMembers">
        <source>Type abbreviations cannot have members</source>
        <target state="new">Type abbreviations cannot have members</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCheckedAtCompileTime">
        <source>As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.</source>
        <target state="new">As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsMayNotHaveMembers">
        <source>Enumerations cannot have members</source>
        <target state="new">Enumerations cannot have members</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembers">
        <source>Measure declarations may have only static members</source>
        <target state="new">Measure declarations may have only static members</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainDoBindings">
        <source>Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings</source>
        <target state="new">Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainLetBindings">
        <source>Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.</source>
        <target state="new">Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticLetBindingsRequireClassesWithImplicitConstructors">
        <source>Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'.</source>
        <target state="new">Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembersNotConstructors">
        <source>Measure declarations may have only static members: constructors are not available</source>
        <target state="new">Measure declarations may have only static members: constructors are not available</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberAndLocalClassBindingHaveSameName">
        <source>A member and a local class binding both have the name '{0}'</source>
        <target state="new">A member and a local class binding both have the name '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
        <source>Type abbreviations cannot have interface declarations</source>
        <target state="new">Type abbreviations cannot have interface declarations</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsCannotHaveInterfaceDeclaration">
        <source>Enumerations cannot have interface declarations</source>
        <target state="new">Enumerations cannot have interface declarations</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType0">
        <source>This type is not an interface type</source>
        <target state="new">This type is not an interface type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllImplementedInterfacesShouldBeDeclared">
        <source>All implemented interfaces should be declared on the initial declaration of the type</source>
        <target state="new">All implemented interfaces should be declared on the initial declaration of the type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
        <source>A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type</source>
        <target state="new">A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberNotPermittedInInterfaceImplementation">
        <source>This member is not permitted in an interface implementation</source>
        <target state="new">This member is not permitted in an interface implementation</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclarationElementNotPermittedInAugmentation">
        <source>This declaration element is not permitted in an augmentation</source>
        <target state="new">This declaration element is not permitted in an augmentation</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotContainNestedTypes">
        <source>Types cannot contain nested type definitions</source>
        <target state="new">Types cannot contain nested type definitions</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeExceptionOrModule">
        <source>type, exception or module</source>
        <target state="new">type, exception or module</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeOrModule">
        <source>type or module</source>
        <target state="new">type or module</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type.</source>
        <target state="new">The struct, record or union type '{0}' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IEquatable&lt;_&gt;' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'.</source>
        <target state="new">The struct, record or union type '{0}' implements the interface 'System.IEquatable&lt;_&gt;' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
        <source>Explicit type specifications cannot be used for exception constructors</source>
        <target state="new">Explicit type specifications cannot be used for exception constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsShouldNotHaveArgumentList">
        <source>Exception abbreviations should not have argument lists</source>
        <target state="new">Exception abbreviations should not have argument lists</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
        <source>Abbreviations for Common IL exceptions cannot take arguments</source>
        <target state="new">Abbreviations for Common IL exceptions cannot take arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsMustReferToValidExceptions">
        <source>Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception</source>
        <target state="new">Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
        <source>Abbreviations for Common IL exception types must have a matching object constructor</source>
        <target state="new">Abbreviations for Common IL exception types must have a matching object constructor</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotAnException">
        <source>Not an exception</source>
        <target state="new">Not an exception</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidModuleName">
        <source>Invalid module name</source>
        <target state="new">Invalid module name</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeExtension">
        <source>Invalid type extension</source>
        <target state="new">Invalid type extension</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesOfTypeSpecifyMultipleKindsForType">
        <source>The attributes of this type specify multiple kinds for the type</source>
        <target state="new">The attributes of this type specify multiple kinds for the type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcKindOfTypeSpecifiedDoesNotMatchDefinition">
        <source>The kind of the type specified by its attributes does not match the kind implied by its definition</source>
        <target state="new">The kind of the type specified by its attributes does not match the kind implied by its definition</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDefinitionsCannotHaveTypeParameters">
        <source>Measure definitions cannot have type parameters</source>
        <target state="new">Measure definitions cannot have type parameters</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeRequiresDefinition">
        <source>This type requires a definition</source>
        <target state="new">This type requires a definition</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationHasTypeParametersMissingOnType">
        <source>This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C&lt;'a&gt; = C of ...'.</source>
        <target state="new">This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C&lt;'a&gt; = C of ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
        <source>Structs, interfaces, enums and delegates cannot inherit from other types</source>
        <target state="new">Structs, interfaces, enums and delegates cannot inherit from other types</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotInheritFromMultipleConcreteTypes">
        <source>Types cannot inherit from multiple concrete types</source>
        <target state="new">Types cannot inherit from multiple concrete types</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
        <source>Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute</source>
        <target state="new">Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
        <source>Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal</source>
        <target state="new">Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericTypesCannotHaveStructLayout">
        <source>Generic types cannot be given the 'StructLayout' attribute</source>
        <target state="new">Generic types cannot be given the 'StructLayout' attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyStructsCanHaveStructLayout">
        <source>Only structs and classes without primary constructors may be given the 'StructLayout' attribute</source>
        <target state="new">Only structs and classes without primary constructors may be given the 'StructLayout' attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRepresentationOfTypeHiddenBySignature">
        <source>The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.</source>
        <target state="new">The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyClassesCanHaveAbstract">
        <source>Only classes may be given the 'AbstractClass' attribute</source>
        <target state="new">Only classes may be given the 'AbstractClass' attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
        <source>Only types representing units-of-measure may be given the 'Measure' attribute</source>
        <target state="new">Only types representing units-of-measure may be given the 'Measure' attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on overrides or interface implementations</source>
        <target state="new">Accessibility modifiers are not permitted on overrides or interface implementations</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDU">
        <source>Discriminated union types are always sealed</source>
        <target state="new">Discriminated union types are always sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedRecord">
        <source>Record types are always sealed</source>
        <target state="new">Record types are always sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedAssemblyCode">
        <source>Assembly code types are always sealed</source>
        <target state="new">Assembly code types are always sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedStruct">
        <source>Struct types are always sealed</source>
        <target state="new">Struct types are always sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDelegate">
        <source>Delegate types are always sealed</source>
        <target state="new">Delegate types are always sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedEnum">
        <source>Enum types are always sealed</source>
        <target state="new">Enum types are always sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesAndDelegatesCannotContainFields">
        <source>Interface types and delegate types cannot contain fields</source>
        <target state="new">Interface types and delegate types cannot contain fields</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviatedTypesCannotBeSealed">
        <source>Abbreviated types cannot be given the 'Sealed' attribute</source>
        <target state="new">Abbreviated types cannot be given the 'Sealed' attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromSealedType">
        <source>Cannot inherit a sealed type</source>
        <target state="new">Cannot inherit a sealed type</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromInterfaceType">
        <source>Cannot inherit from interface type. Use interface ... with instead.</source>
        <target state="new">Cannot inherit from interface type. Use interface ... with instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructTypesCannotContainAbstractMembers">
        <source>Struct types cannot contain abstract members</source>
        <target state="new">Struct types cannot contain abstract members</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesCannotBeSealed">
        <source>Interface types cannot be sealed</source>
        <target state="new">Interface types cannot be sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDelegateSpecification">
        <source>Delegate specifications must be of the form 'typ -&gt; typ'</source>
        <target state="new">Delegate specifications must be of the form 'typ -&gt; typ'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegatesCannotBeCurried">
        <source>Delegate specifications must not be curried types. Use 'typ * ... * typ -&gt; typ' for multi-argument delegates, and 'typ -&gt; (typ -&gt; typ)' for delegates returning function values.</source>
        <target state="new">Delegate specifications must not be curried types. Use 'typ * ... * typ -&gt; typ' for multi-argument delegates, and 'typ -&gt; (typ -&gt; typ)' for delegates returning function values.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForLiteralEnumeration">
        <source>Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char</source>
        <target state="new">Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclic">
        <source>This type definition involves an immediate cyclic reference through an abbreviation</source>
        <target state="new">This type definition involves an immediate cyclic reference through an abbreviation</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclicThroughInheritance">
        <source>This type definition involves an immediate cyclic reference through a struct field or inheritance relation</source>
        <target state="new">This type definition involves an immediate cyclic reference through a struct field or inheritance relation</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReservedSyntaxForAugmentation">
        <source>The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[&lt;Sealed&gt;] attribute to the type definition in the signature</source>
        <target state="new">The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[&lt;Sealed&gt;] attribute to the type definition in the signature</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
        <source>Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.</source>
        <target state="new">Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal">
        <source>One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '{0}'</source>
        <target state="new">One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
        <source>Type definitions may only have one 'inherit' specification and it must be the first declaration</source>
        <target state="new">Type definitions may only have one 'inherit' specification and it must be the first declaration</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
        <source>'let' and 'do' bindings must come before member and interface definitions in type definitions</source>
        <target state="new">'let' and 'do' bindings must come before member and interface definitions in type definitions</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritDeclarationMissingArguments">
        <source>This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'.</source>
        <target state="new">This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritConstructionCallNotPartOfImplicitSequence">
        <source>This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="new">This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLetAndDoRequiresImplicitConstructionSequence">
        <source>This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="new">This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveAugmentations">
        <source>Type abbreviations cannot have augmentations</source>
        <target state="new">Type abbreviations cannot have augmentations</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbreviationForNamespace">
        <source>The path '{0}' is a namespace. A module abbreviation may not abbreviate a namespace.</source>
        <target state="new">The path '{0}' is a namespace. A module abbreviation may not abbreviate a namespace.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeUsedInInvalidWay">
        <source>The type '{0}' is used in an invalid way. A value prior to '{1}' has an inferred type involving '{2}', which is an invalid forward reference.</source>
        <target state="new">The type '{0}' is used in an invalid way. A value prior to '{1}' has an inferred type involving '{2}', which is an invalid forward reference.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to the definition of '{2}', which is an invalid forward reference.</source>
        <target state="new">The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to the definition of '{2}', which is an invalid forward reference.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeAutoOpenWasIgnored">
        <source>The attribute 'AutoOpen(\"{0}\")' in the assembly '{1}' did not refer to a valid module or namespace in that assembly and has been ignored</source>
        <target state="new">The attribute 'AutoOpen(\"{0}\")' in the assembly '{1}' did not refer to a valid module or namespace in that assembly and has been ignored</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUndefinedValue">
        <source>Undefined value '{0}'</source>
        <target state="new">Undefined value '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLabelNotFound">
        <source>Label {0} not found</source>
        <target state="new">Label {0} not found</target>
        <note />
      </trans-unit>
      <trans-unit id="ilIncorrectNumberOfTypeArguments">
        <source>Incorrect number of type arguments to local call</source>
        <target state="new">Incorrect number of type arguments to local call</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDynamicInvocationNotSupported">
        <source>Dynamic invocation of {0} is not supported</source>
        <target state="new">Dynamic invocation of {0} is not supported</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfLiteralFieldIsInvalid">
        <source>Taking the address of a literal field is invalid</source>
        <target state="new">Taking the address of a literal field is invalid</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfValueHereIsInvalid">
        <source>This operation involves taking the address of a value '{0}' represented using a local variable or other special representation. This is invalid.</source>
        <target state="new">This operation involves taking the address of a value '{0}' represented using a local variable or other special representation. This is invalid.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilCustomMarshallersCannotBeUsedInFSharp">
        <source>Custom marshallers cannot be specified in F# code. Consider using a C# helper function.</source>
        <target state="new">Custom marshallers cannot be specified in F# code. Consider using a C# helper function.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMarshalAsAttributeCannotBeDecoded">
        <source>The MarshalAs attribute could not be decoded</source>
        <target state="new">The MarshalAs attribute could not be decoded</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignatureForExternalFunctionContainsTypeParameters">
        <source>The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.</source>
        <target state="new">The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDllImportAttributeCouldNotBeDecoded">
        <source>The DllImport attribute could not be decoded</source>
        <target state="new">The DllImport attribute could not be decoded</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLiteralFieldsCannotBeSet">
        <source>Literal fields cannot be set</source>
        <target state="new">Literal fields cannot be set</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStaticMethodIsNotLambda">
        <source>GenSetStorage: {0} was represented as a static method but was not an appropriate lambda expression</source>
        <target state="new">GenSetStorage: {0} was represented as a static method but was not an appropriate lambda expression</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMutableVariablesCannotEscapeMethod">
        <source>Mutable variables cannot escape their method</source>
        <target state="new">Mutable variables cannot escape their method</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedUnrealizedValue">
        <source>Compiler error: unexpected unrealized value</source>
        <target state="new">Compiler error: unexpected unrealized value</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMainModuleEmpty">
        <source>Main module of program is empty: nothing will happen when it is run</source>
        <target state="new">Main module of program is empty: nothing will happen when it is run</target>
        <note />
      </trans-unit>
      <trans-unit id="ilTypeCannotBeUsedForLiteralField">
        <source>This type cannot be used for a literal field</source>
        <target state="new">This type cannot be used for a literal field</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedGetSetAnnotation">
        <source>Unexpected GetSet annotation on a property</source>
        <target state="new">Unexpected GetSet annotation on a property</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldOffsetAttributeCouldNotBeDecoded">
        <source>The FieldOffset attribute could not be decoded</source>
        <target state="new">The FieldOffset attribute could not be decoded</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStructLayoutAttributeCouldNotBeDecoded">
        <source>The StructLayout attribute could not be decoded</source>
        <target state="new">The StructLayout attribute could not be decoded</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDefaultAugmentationAttributeCouldNotBeDecoded">
        <source>The DefaultAugmentation attribute could not be decoded</source>
        <target state="new">The DefaultAugmentation attribute could not be decoded</target>
        <note />
      </trans-unit>
      <trans-unit id="ilReflectedDefinitionsCannotUseSliceOperator">
        <source>Reflected definitions cannot contain uses of the prefix splice operator '%'</source>
        <target state="new">Reflected definitions cannot contain uses of the prefix splice operator '%'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsProblemWithCodepage">
        <source>Problem with codepage '{0}': {1}</source>
        <target state="new">Problem with codepage '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyright">
        <source>Copyright (c) Microsoft Corporation. All Rights Reserved.</source>
        <target state="new">Copyright (c) Microsoft Corporation. All Rights Reserved.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyrightCommunity">
        <source>Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</source>
        <target state="new">Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNameOfOutputFile">
        <source>Name of the output file (Short form: -o)</source>
        <target state="new">Name of the output file (Short form: -o)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildConsole">
        <source>Build a console executable</source>
        <target state="new">Build a console executable</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildWindows">
        <source>Build a Windows executable</source>
        <target state="new">Build a Windows executable</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildLibrary">
        <source>Build a library (Short form: -a)</source>
        <target state="new">Build a library (Short form: -a)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildModule">
        <source>Build a module that can be added to another assembly</source>
        <target state="new">Build a module that can be added to another assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDelaySign">
        <source>Delay-sign the assembly using only the public portion of the strong name key</source>
        <target state="new">Delay-sign the assembly using only the public portion of the strong name key</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPublicSign">
        <source>Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed</source>
        <target state="new">Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWriteXml">
        <source>Write the xmldoc of the assembly to the given file</source>
        <target state="new">Write the xmldoc of the assembly to the given file</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyFile">
        <source>Specify a strong name key file</source>
        <target state="new">Specify a strong name key file</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyContainer">
        <source>Specify a strong name key container</source>
        <target state="new">Specify a strong name key container</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPlatform">
        <source>Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.</source>
        <target state="new">Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoOpt">
        <source>Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.</source>
        <target state="new">Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoInterface">
        <source>Don't add a resource to the generated assembly containing F#-specific metadata</source>
        <target state="new">Don't add a resource to the generated assembly containing F#-specific metadata</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSig">
        <source>Print the inferred interface of the assembly to a file</source>
        <target state="new">Print the inferred interface of the assembly to a file</target>
        <note />
      </trans-unit>
      <trans-unit id="optsReference">
        <source>Reference an assembly (Short form: -r)</source>
        <target state="new">Reference an assembly (Short form: -r)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32res">
        <source>Specify a Win32 resource file (.res)</source>
        <target state="new">Specify a Win32 resource file (.res)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32manifest">
        <source>Specify a Win32 manifest file</source>
        <target state="new">Specify a Win32 manifest file</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowin32manifest">
        <source>Do not include the default Win32 manifest</source>
        <target state="new">Do not include the default Win32 manifest</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedAllSource">
        <source>Embed all source files in the portable PDB file</source>
        <target state="new">Embed all source files in the portable PDB file</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedSource">
        <source>Embed specific source files in the portable PDB file</source>
        <target state="new">Embed specific source files in the portable PDB file</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLink">
        <source>Source link information file to embed in the portable PDB file</source>
        <target state="new">Source link information file to embed in the portable PDB file</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbeddedSourceRequirePortablePDBs">
        <source>--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="new">--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLinkRequirePortablePDBs">
        <source>--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="new">--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="srcFileTooLarge">
        <source>Source file is too large to embed in a portable PDB</source>
        <target state="new">Source file is too large to embed in a portable PDB</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResource">
        <source>Embed the specified managed resource</source>
        <target state="new">Embed the specified managed resource</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLinkresource">
        <source>Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]</source>
        <target state="new">Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebugPM">
        <source>Emit debug information (Short form: -g)</source>
        <target state="new">Emit debug information (Short form: -g)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebug">
        <source>Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file).</source>
        <target state="new">Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsOptimize">
        <source>Enable optimizations (Short form: -O)</source>
        <target state="new">Enable optimizations (Short form: -O)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTailcalls">
        <source>Enable or disable tailcalls</source>
        <target state="new">Enable or disable tailcalls</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDeterministic">
        <source>Produce a deterministic assembly (including module version GUID and timestamp)</source>
        <target state="new">Produce a deterministic assembly (including module version GUID and timestamp)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCrossoptimize">
        <source>Enable or disable cross-module optimizations</source>
        <target state="new">Enable or disable cross-module optimizations</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserrorPM">
        <source>Report all warnings as errors</source>
        <target state="new">Report all warnings as errors</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserror">
        <source>Report specific warnings as errors</source>
        <target state="new">Report specific warnings as errors</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarn">
        <source>Set a warning level (0-5)</source>
        <target state="new">Set a warning level (0-5)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowarn">
        <source>Disable specific warning messages</source>
        <target state="new">Disable specific warning messages</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnOn">
        <source>Enable specific warnings that may be off by default</source>
        <target state="new">Enable specific warnings that may be off by default</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecked">
        <source>Generate overflow checks</source>
        <target state="new">Generate overflow checks</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDefine">
        <source>Define conditional compilation symbols (Short form: -d)</source>
        <target state="new">Define conditional compilation symbols (Short form: -d)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsMlcompatibility">
        <source>Ignore ML compatibility warnings</source>
        <target state="new">Ignore ML compatibility warnings</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNologo">
        <source>Suppress compiler copyright message</source>
        <target state="new">Suppress compiler copyright message</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelp">
        <source>Display this usage message (Short form: -?)</source>
        <target state="new">Display this usage message (Short form: -?)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFile">
        <source>Read response file for more options</source>
        <target state="new">Read response file for more options</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCodepage">
        <source>Specify the codepage used to read source files</source>
        <target state="new">Specify the codepage used to read source files</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUtf8output">
        <source>Output messages in UTF-8 encoding</source>
        <target state="new">Output messages in UTF-8 encoding</target>
        <note />
      </trans-unit>
      <trans-unit id="optsFullpaths">
        <source>Output messages with fully qualified paths</source>
        <target state="new">Output messages with fully qualified paths</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLib">
        <source>Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)</source>
        <target state="new">Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBaseaddress">
        <source>Base address for the library to be built</source>
        <target state="new">Base address for the library to be built</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoframework">
        <source>Do not reference the default CLI assemblies by default</source>
        <target state="new">Do not reference the default CLI assemblies by default</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStandalone">
        <source>Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated</source>
        <target state="new">Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStaticlink">
        <source>Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.</source>
        <target state="new">Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResident">
        <source>Use a resident background compilation service to improve compiler startup times.</source>
        <target state="new">Use a resident background compilation service to improve compiler startup times.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPdb">
        <source>Name the output debug file</source>
        <target state="new">Name the output debug file</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSimpleresolution">
        <source>Resolve assembly references using directory-based rules rather than MSBuild resolution</source>
        <target state="new">Resolve assembly references using directory-based rules rather than MSBuild resolution</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedTarget">
        <source>Unrecognized target '{0}', expected 'exe', 'winexe', 'library' or 'module'</source>
        <target state="new">Unrecognized target '{0}', expected 'exe', 'winexe', 'library' or 'module'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedDebugType">
        <source>Unrecognized debug type '{0}', expected 'pdbonly' or 'full'</source>
        <target state="new">Unrecognized debug type '{0}', expected 'pdbonly' or 'full'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidWarningLevel">
        <source>Invalid warning level '{0}'</source>
        <target state="new">Invalid warning level '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsShortFormOf">
        <source>Short form of '{0}'</source>
        <target state="new">Short form of '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDeprecatedMsg">
        <source>The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.</source>
        <target state="new">The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDescription">
        <source>Use to override where the compiler looks for mscorlib.dll and framework components</source>
        <target state="new">Use to override where the compiler looks for mscorlib.dll and framework components</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerOutputFiles">
        <source>- OUTPUT FILES -</source>
        <target state="new">- OUTPUT FILES -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerInputFiles">
        <source>- INPUT FILES -</source>
        <target state="new">- INPUT FILES -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerResources">
        <source>- RESOURCES -</source>
        <target state="new">- RESOURCES -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerCodeGen">
        <source>- CODE GENERATION -</source>
        <target state="new">- CODE GENERATION -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerAdvanced">
        <source>- ADVANCED -</source>
        <target state="new">- ADVANCED -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerMisc">
        <source>- MISCELLANEOUS -</source>
        <target state="new">- MISCELLANEOUS -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerLanguage">
        <source>- LANGUAGE -</source>
        <target state="new">- LANGUAGE -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerErrsAndWarns">
        <source>- ERRORS AND WARNINGS -</source>
        <target state="new">- ERRORS AND WARNINGS -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownArgumentToTheTestSwitch">
        <source>Unknown --test argument: '{0}'</source>
        <target state="new">Unknown --test argument: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownPlatform">
        <source>Unrecognized platform '{0}', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'</source>
        <target state="new">Unrecognized platform '{0}', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInternalNoDescription">
        <source>The command-line option '{0}' is for test purposes only</source>
        <target state="new">The command-line option '{0}' is for test purposes only</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLONoDescription">
        <source>The command-line option '{0}' has been deprecated</source>
        <target state="new">The command-line option '{0}' has been deprecated</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLODeprecatedSuggestAlternative">
        <source>The command-line option '{0}' has been deprecated. Use '{1}' instead.</source>
        <target state="new">The command-line option '{0}' has been deprecated. Use '{1}' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLOHtmlDoc">
        <source>The command-line option '{0}' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.</source>
        <target state="new">The command-line option '{0}' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsConsoleColors">
        <source>Output warning and error messages in color</source>
        <target state="new">Output warning and error messages in color</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUseHighEntropyVA">
        <source>Enable high-entropy ASLR</source>
        <target state="new">Enable high-entropy ASLR</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSubSystemVersion">
        <source>Specify subsystem version of this assembly</source>
        <target state="new">Specify subsystem version of this assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTargetProfile">
        <source>Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib</source>
        <target state="new">Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmitDebugInfoInQuotations">
        <source>Emit debug information in quotations</source>
        <target state="new">Emit debug information in quotations</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPreferredUiLang">
        <source>Specify the preferred output language culture name (e.g. es-ES, ja-JP)</source>
        <target state="new">Specify the preferred output language culture name (e.g. es-ES, ja-JP)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoCopyFsharpCore">
        <source>Don't copy FSharp.Core.dll along the produced binaries</source>
        <target state="new">Don't copy FSharp.Core.dll along the produced binaries</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidSubSystemVersion">
        <source>Invalid version '{0}' for '--subsystemversion'. The version must be 4.00 or greater.</source>
        <target state="new">Invalid version '{0}' for '--subsystemversion'. The version must be 4.00 or greater.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidTargetProfile">
        <source>Invalid value '{0}' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.</source>
        <target state="new">Invalid value '{0}' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFullName">
        <source>Full name</source>
        <target state="new">Full name</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoOtherOverloads">
        <source>and {0} other overloads</source>
        <target state="new">and {0} other overloads</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoUnionCase">
        <source>union case</source>
        <target state="new">union case</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActivePatternResult">
        <source>active pattern result</source>
        <target state="new">active pattern result</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActiveRecognizer">
        <source>active recognizer</source>
        <target state="new">active recognizer</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoField">
        <source>field</source>
        <target state="new">field</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoEvent">
        <source>event</source>
        <target state="new">event</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoProperty">
        <source>property</source>
        <target state="new">property</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoExtension">
        <source>extension</source>
        <target state="new">extension</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCustomOperation">
        <source>custom operation</source>
        <target state="new">custom operation</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoArgument">
        <source>argument</source>
        <target state="new">argument</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoPatternVariable">
        <source>patvar</source>
        <target state="new">patvar</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespace">
        <source>namespace</source>
        <target state="new">namespace</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoModule">
        <source>module</source>
        <target state="new">module</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespaceOrModule">
        <source>namespace/module</source>
        <target state="new">namespace/module</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromFirst">
        <source>from {0}</source>
        <target state="new">from {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromNext">
        <source>also from {0}</source>
        <target state="new">also from {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedProperty">
        <source>generated property</source>
        <target state="new">generated property</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedType">
        <source>generated type</source>
        <target state="new">generated type</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersKey">
        <source>Found by AssemblyFolders registry key</source>
        <target state="new">Found by AssemblyFolders registry key</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersExKey">
        <source>Found by AssemblyFoldersEx registry key</source>
        <target state="new">Found by AssemblyFoldersEx registry key</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionNetFramework">
        <source>.NET Framework</source>
        <target state="new">.NET Framework</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionGAC">
        <source>Global Assembly Cache</source>
        <target state="new">Global Assembly Cache</target>
        <note />
      </trans-unit>
      <trans-unit id="recursiveClassHierarchy">
        <source>Recursive class hierarchy in type '{0}'</source>
        <target state="new">Recursive class hierarchy in type '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRecursiveReferenceToAbstractSlot">
        <source>Invalid recursive reference to an abstract slot</source>
        <target state="new">Invalid recursive reference to an abstract slot</target>
        <note />
      </trans-unit>
      <trans-unit id="eventHasNonStandardType">
        <source>The event '{0}' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit {1} and {2} methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent&lt;_&gt;' or 'IEvent&lt;_,_&gt;'.</source>
        <target state="new">The event '{0}' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit {1} and {2} methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent&lt;_&gt;' or 'IEvent&lt;_,_&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeIsNotAccessible">
        <source>The type '{0}' is not accessible from this code location</source>
        <target state="new">The type '{0}' is not accessible from this code location</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCasesAreNotAccessible">
        <source>The union cases or fields of the type '{0}' are not accessible from this code location</source>
        <target state="new">The union cases or fields of the type '{0}' are not accessible from this code location</target>
        <note />
      </trans-unit>
      <trans-unit id="valueIsNotAccessible">
        <source>The value '{0}' is not accessible from this code location</source>
        <target state="new">The value '{0}' is not accessible from this code location</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCaseIsNotAccessible">
        <source>The union case '{0}' is not accessible from this code location</source>
        <target state="new">The union case '{0}' is not accessible from this code location</target>
        <note />
      </trans-unit>
      <trans-unit id="fieldIsNotAccessible">
        <source>The record, struct or class field '{0}' is not accessible from this code location</source>
        <target state="new">The record, struct or class field '{0}' is not accessible from this code location</target>
        <note />
      </trans-unit>
      <trans-unit id="structOrClassFieldIsNotAccessible">
        <source>The struct or class field '{0}' is not accessible from this code location</source>
        <target state="new">The struct or class field '{0}' is not accessible from this code location</target>
        <note />
      </trans-unit>
      <trans-unit id="experimentalConstruct">
        <source>This construct is experimental</source>
        <target state="new">This construct is experimental</target>
        <note />
      </trans-unit>
      <trans-unit id="noInvokeMethodsFound">
        <source>No Invoke methods found for delegate type</source>
        <target state="new">No Invoke methods found for delegate type</target>
        <note />
      </trans-unit>
      <trans-unit id="moreThanOneInvokeMethodFound">
        <source>More than one Invoke method found for delegate type</source>
        <target state="new">More than one Invoke method found for delegate type</target>
        <note />
      </trans-unit>
      <trans-unit id="delegatesNotAllowedToHaveCurriedSignatures">
        <source>Delegates are not allowed to have curried signatures</source>
        <target state="new">Delegates are not allowed to have curried signatures</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrUnexpectedTExpr">
        <source>Unexpected Expr.TyChoose</source>
        <target state="new">Unexpected Expr.TyChoose</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrLambdaLiftingOptimizationsNotApplied">
        <source>Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.</source>
        <target state="new">Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifiersContainingAtSymbolReserved">
        <source>Identifiers containing '@' are reserved for use in F# code generation</source>
        <target state="new">Identifiers containing '@' are reserved for use in F# code generation</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifierReserved">
        <source>The identifier '{0}' is reserved for future use by F#</source>
        <target state="new">The identifier '{0}' is reserved for future use by F#</target>
        <note />
      </trans-unit>
      <trans-unit id="patcMissingVariable">
        <source>Missing variable '{0}'</source>
        <target state="new">Missing variable '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="patcPartialActivePatternsGenerateOneResult">
        <source>Partial active patterns may only generate one result</source>
        <target state="new">Partial active patterns may only generate one result</target>
        <note />
      </trans-unit>
      <trans-unit id="impTypeRequiredUnavailable">
        <source>The type '{0}' is required here and is unavailable. You must add a reference to assembly '{1}'.</source>
        <target state="new">The type '{0}' is required here and is unavailable. You must add a reference to assembly '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferencedTypeCouldNotBeFoundInAssembly">
        <source>A reference to the type '{0}' in assembly '{1}' was found, but the type could not be found in that assembly</source>
        <target state="new">A reference to the type '{0}' in assembly '{1}' was found, but the type could not be found in that assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="impNotEnoughTypeParamsInScopeWhileImporting">
        <source>Internal error or badly formed metadata: not enough type parameters were in scope while importing</source>
        <target state="new">Internal error or badly formed metadata: not enough type parameters were in scope while importing</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferenceToDllRequiredByAssembly">
        <source>A reference to the DLL {0} is required by assembly {1}. The imported type {2} is located in the first assembly and could not be resolved.</source>
        <target state="new">A reference to the DLL {0} is required by assembly {1}. The imported type {2} is located in the first assembly and could not be resolved.</target>
        <note />
      </trans-unit>
      <trans-unit id="impImportedAssemblyUsesNotPublicType">
        <source>An imported assembly uses the type '{0}' but that type is not public</source>
        <target state="new">An imported assembly uses the type '{0}' but that type is not public</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButIncomplete">
        <source>The value '{0}' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible</source>
        <target state="new">The value '{0}' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButWasNotBoundInTheOptEnv">
        <source>The value '{0}' was marked inline but was not bound in the optimization environment</source>
        <target state="new">The value '{0}' was marked inline but was not bound in the optimization environment</target>
        <note />
      </trans-unit>
      <trans-unit id="optLocalValueNotFoundDuringOptimization">
        <source>Local value {0} not found during optimization</source>
        <target state="new">Local value {0} not found during optimization</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineHasUnexpectedValue">
        <source>A value marked as 'inline' has an unexpected value</source>
        <target state="new">A value marked as 'inline' has an unexpected value</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineCouldNotBeInlined">
        <source>A value marked as 'inline' could not be inlined</source>
        <target state="new">A value marked as 'inline' could not be inlined</target>
        <note />
      </trans-unit>
      <trans-unit id="optFailedToInlineValue">
        <source>Failed to inline the value '{0}' marked 'inline', perhaps because a recursive value was marked 'inline'</source>
        <target state="new">Failed to inline the value '{0}' marked 'inline', perhaps because a recursive value was marked 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="optRecursiveValValue">
        <source>Recursive ValValue {0}</source>
        <target state="new">Recursive ValValue {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltIncorrentIndentationOfIn">
        <source>The indentation of this 'in' token is incorrect with respect to the corresponding 'let'</source>
        <target state="new">The indentation of this 'in' token is incorrect with respect to the corresponding 'let'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltTokenIsOffsideOfContextStartedEarlier">
        <source>Possible incorrect indentation: this token is offside of context started at position {0}. Try indenting this token further or using standard formatting conventions.</source>
        <target state="new">Possible incorrect indentation: this token is offside of context started at position {0}. Try indenting this token further or using standard formatting conventions.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltSeparatorTokensOfPatternMatchMisaligned">
        <source>The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.</source>
        <target state="new">The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidModuleExprType">
        <source>Invalid module/expression/type</source>
        <target state="new">Invalid module/expression/type</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationNeededToDisambiguateTypesWithSameName">
        <source>Multiple types exist called '{0}', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '{1}'.</source>
        <target state="new">Multiple types exist called '{0}', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationIsMissingAndCouldNotBeInferred">
        <source>The instantiation of the generic type '{0}' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '{1}'.</source>
        <target state="new">The instantiation of the generic type '{0}' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrGlobalUsedOnlyAsFirstName">
        <source>'global' may only be used as the first name in a qualified path</source>
        <target state="new">'global' may only be used as the first name in a qualified path</target>
        <note />
      </trans-unit>
      <trans-unit id="nrIsNotConstructorOrLiteral">
        <source>This is not a constructor or literal, or a constructor is being used incorrectly</source>
        <target state="new">This is not a constructor or literal, or a constructor is being used incorrectly</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnexpectedEmptyLongId">
        <source>Unexpected empty long identifier</source>
        <target state="new">Unexpected empty long identifier</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordDoesNotContainSuchLabel">
        <source>The record type '{0}' does not contain a label '{1}'.</source>
        <target state="new">The record type '{0}' does not contain a label '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidFieldLabel">
        <source>Invalid field label</source>
        <target state="new">Invalid field label</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidExpression">
        <source>Invalid expression '{0}'</source>
        <target state="new">Invalid expression '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="nrNoConstructorsAvailableForType">
        <source>No constructors are available for the type '{0}'</source>
        <target state="new">No constructors are available for the type '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnionTypeNeedsQualifiedAccess">
        <source>The union type for union case '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('{1}') in the name you are using.</source>
        <target state="new">The union type for union case '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('{1}') in the name you are using.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordTypeNeedsQualifiedAccess">
        <source>The record type for the record field '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('{1}') in the name you are using.</source>
        <target state="new">The record type for the record field '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('{1}') in the name you are using.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingPdb">
        <source>Unexpected error creating debug information file '{0}'</source>
        <target state="new">Unexpected error creating debug information file '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideIntegerRange">
        <source>This number is outside the allowable range for this integer type</source>
        <target state="new">This number is outside the allowable range for this integer type</target>
        <note />
      </trans-unit>
      <trans-unit id="lexCharNotAllowedInOperatorNames">
        <source>'{0}' is not permitted as a character in operator names and is reserved for future use</source>
        <target state="new">'{0}' is not permitted as a character in operator names and is reserved for future use</target>
        <note />
      </trans-unit>
      <trans-unit id="lexUnexpectedChar">
        <source>Unexpected character '{0}'</source>
        <target state="new">Unexpected character '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteArrayCannotEncode">
        <source>This byte array literal contains characters that do not encode as a single byte</source>
        <target state="new">This byte array literal contains characters that do not encode as a single byte</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIdentEndInMarkReserved">
        <source>Identifiers followed by '{0}' are reserved for future use</source>
        <target state="new">Identifiers followed by '{0}' are reserved for future use</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSigned">
        <source>This number is outside the allowable range for 8-bit signed integers</source>
        <target state="new">This number is outside the allowable range for 8-bit signed integers</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSignedHex">
        <source>This number is outside the allowable range for hexadecimal 8-bit signed integers</source>
        <target state="new">This number is outside the allowable range for hexadecimal 8-bit signed integers</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitUnsigned">
        <source>This number is outside the allowable range for 8-bit unsigned integers</source>
        <target state="new">This number is outside the allowable range for 8-bit unsigned integers</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitSigned">
        <source>This number is outside the allowable range for 16-bit signed integers</source>
        <target state="new">This number is outside the allowable range for 16-bit signed integers</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitUnsigned">
        <source>This number is outside the allowable range for 16-bit unsigned integers</source>
        <target state="new">This number is outside the allowable range for 16-bit unsigned integers</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitSigned">
        <source>This number is outside the allowable range for 32-bit signed integers</source>
        <target state="new">This number is outside the allowable range for 32-bit signed integers</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitUnsigned">
        <source>This number is outside the allowable range for 32-bit unsigned integers</source>
        <target state="new">This number is outside the allowable range for 32-bit unsigned integers</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitSigned">
        <source>This number is outside the allowable range for 64-bit signed integers</source>
        <target state="new">This number is outside the allowable range for 64-bit signed integers</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitUnsigned">
        <source>This number is outside the allowable range for 64-bit unsigned integers</source>
        <target state="new">This number is outside the allowable range for 64-bit unsigned integers</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeSigned">
        <source>This number is outside the allowable range for signed native integers</source>
        <target state="new">This number is outside the allowable range for signed native integers</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeUnsigned">
        <source>This number is outside the allowable range for unsigned native integers</source>
        <target state="new">This number is outside the allowable range for unsigned native integers</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidFloat">
        <source>Invalid floating point number</source>
        <target state="new">Invalid floating point number</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideDecimal">
        <source>This number is outside the allowable range for decimal literals</source>
        <target state="new">This number is outside the allowable range for decimal literals</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideThirtyTwoBitFloat">
        <source>This number is outside the allowable range for 32-bit floats</source>
        <target state="new">This number is outside the allowable range for 32-bit floats</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidNumericLiteral">
        <source>This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</source>
        <target state="new">This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidByteLiteral">
        <source>This is not a valid byte literal</source>
        <target state="new">This is not a valid byte literal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidCharLiteral">
        <source>This is not a valid character literal</source>
        <target state="new">This is not a valid character literal</target>
        <note />
      </trans-unit>
      <trans-unit id="lexThisUnicodeOnlyInStringLiterals">
        <source>This Unicode encoding is only valid in string literals</source>
        <target state="new">This Unicode encoding is only valid in string literals</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTokenReserved">
        <source>This token is reserved for future use</source>
        <target state="new">This token is reserved for future use</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTabsNotAllowed">
        <source>TABs are not allowed in F# code unless the #indent \"off\" option is used</source>
        <target state="new">TABs are not allowed in F# code unless the #indent \"off\" option is used</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidLineNumber">
        <source>Invalid line number: '{0}'</source>
        <target state="new">Invalid line number: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustBeFirst">
        <source>#if directive must appear as the first non-whitespace character on a line</source>
        <target state="new">#if directive must appear as the first non-whitespace character on a line</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseNoMatchingIf">
        <source>#else has no matching #if</source>
        <target state="new">#else has no matching #if</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifRequiredForElse">
        <source>#endif required for #else</source>
        <target state="new">#endif required for #else</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseMustBeFirst">
        <source>#else directive must appear as the first non-whitespace character on a line</source>
        <target state="new">#else directive must appear as the first non-whitespace character on a line</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndingNoMatchingIf">
        <source>#endif has no matching #if</source>
        <target state="new">#endif has no matching #if</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifMustBeFirst">
        <source>#endif directive must appear as the first non-whitespace character on a line</source>
        <target state="new">#endif directive must appear as the first non-whitespace character on a line</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustHaveIdent">
        <source>#if directive should be immediately followed by an identifier</source>
        <target state="new">#if directive should be immediately followed by an identifier</target>
        <note />
      </trans-unit>
      <trans-unit id="lexWrongNestedHashEndif">
        <source>Syntax error. Wrong nested #endif, unexpected tokens before it.</source>
        <target state="new">Syntax error. Wrong nested #endif, unexpected tokens before it.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashBangMustBeFirstInFile">
        <source>#! may only appear as the first line at the start of a file.</source>
        <target state="new">#! may only appear as the first line at the start of a file.</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexExpectedSingleLineComment">
        <source>Expected single line comment or end of line</source>
        <target state="new">Expected single line comment or end of line</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNoArguments">
        <source>Infix operator member '{0}' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="new">Infix operator member '{0}' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonPairArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="new">Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithCurriedArguments">
        <source>Infix operator member '{0}' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="new">Infix operator member '{0}' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFSharpCoreRequiresExplicit">
        <source>All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'</source>
        <target state="new">All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the type parameter '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter</source>
        <target state="new">The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the type parameter '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the component type '{1}' does not satisfy the 'comparison' constraint</source>
        <target state="new">The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the component type '{1}' does not satisfy the 'comparison' constraint</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded1">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type parameter {1} does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="new">The struct, record or union type '{0}' is not structurally comparable because the type parameter {1} does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded2">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="new">The struct, record or union type '{0}' is not structurally comparable because the type '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded1">
        <source>The struct, record or union type '{0}' does not support structural equality because the type parameter {1} does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="new">The struct, record or union type '{0}' does not support structural equality because the type parameter {1} does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded2">
        <source>The struct, record or union type '{0}' does not support structural equality because the type '{1}' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="new">The struct, record or union type '{0}' does not support structural equality because the type '{1}' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the type parameter '{1}' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter</source>
        <target state="new">The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the type parameter '{1}' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the component type '{1}' does not satisfy the 'equality' constraint</source>
        <target state="new">The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the component type '{1}' does not satisfy the 'equality' constraint</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
        <source>Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct.</source>
        <target state="new">Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedValue">
        <source>The value '{0}' is unused</source>
        <target state="new">The value '{0}' is unused</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedThisVariable">
        <source>The recursive object reference '{0}' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.</source>
        <target state="new">The recursive object reference '{0}' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterAtMostOneArgument">
        <source>A getter property may have at most one argument group</source>
        <target state="new">A getter property may have at most one argument group</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetterAtMostTwoArguments">
        <source>A setter property may have at most two argument groups</source>
        <target state="new">A setter property may have at most two argument groups</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidProperty">
        <source>Invalid property getter or setter</source>
        <target state="new">Invalid property getter or setter</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIndexerPropertyRequiresAtLeastOneArgument">
        <source>An indexer property must be given at least one argument</source>
        <target state="new">An indexer property must be given at least one argument</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidAddressOfMutableAcrossAssemblyBoundary">
        <source>This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation</source>
        <target state="new">This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTypars">
        <source>Type parameters must be placed directly adjacent to the type name, e.g. \"type C&lt;'T&gt;\", not     type \"C   &lt;'T&gt;\"</source>
        <target state="new">Type parameters must be placed directly adjacent to the type name, e.g. \"type C&lt;'T&gt;\", not     type \"C   &lt;'T&gt;\"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTyargs">
        <source>Type arguments must be placed directly adjacent to the type name, e.g. \"C&lt;'T&gt;\", not \"C  &lt;'T&gt;\"</source>
        <target state="new">Type arguments must be placed directly adjacent to the type name, e.g. \"C&lt;'T&gt;\", not \"C  &lt;'T&gt;\"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAtomicType">
        <source>The use of the type syntax 'int C' and 'C  &lt;int&gt;' is not permitted here. Consider adjusting this type to be written in the form 'C&lt;int&gt;'</source>
        <target state="new">The use of the type syntax 'int C' and 'C  &lt;int&gt;' is not permitted here. Consider adjusting this type to be written in the form 'C&lt;int&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespace">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the module/namespace '{2}'</source>
        <target state="new">The module/namespace '{0}' from compilation unit '{1}' did not contain the module/namespace '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefVal">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the val '{2}'</source>
        <target state="new">The module/namespace '{0}' from compilation unit '{1}' did not contain the val '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespaceType">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the namespace, module or type '{2}'</source>
        <target state="new">The module/namespace '{0}' from compilation unit '{1}' did not contain the namespace, module or type '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseNullAsTrueValue">
        <source>The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case</source>
        <target state="new">The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterInferredByref">
        <source>The parameter '{0}' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref&lt;int&gt;'. When used, a byref parameter is implicitly dereferenced.</source>
        <target state="new">The parameter '{0}' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref&lt;int&gt;'. When used, a byref parameter is implicitly dereferenced.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonUniformMemberUse">
        <source>The generic member '{0}' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.</source>
        <target state="new">The generic member '{0}' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttribArgsDiffer">
        <source>The attribute '{0}' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.</source>
        <target state="new">The attribute '{0}' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallAbstractBaseMember">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="new">Cannot call an abstract base member: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInUnmanaged">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position</source>
        <target state="new">Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position</target>
        <note />
      </trans-unit>
      <trans-unit id="mlCompatMessage">
        <source>This construct is for ML compatibility. {0}. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'.</source>
        <target state="new">This construct is for ML compatibility. {0}. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldDoesNotHaveValidOffsetForStructureLayout">
        <source>The type '{0}' has been marked as having an Explicit layout, but the field '{1}' has not been marked with the 'FieldOffset' attribute</source>
        <target state="new">The type '{0}' has been marked as having an Explicit layout, but the field '{1}' has not been marked with the 'FieldOffset' attribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfacesShouldUseInheritNotInterface">
        <source>Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'</source>
        <target state="new">Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperator">
        <source>Invalid prefix operator</source>
        <target state="new">Invalid prefix operator</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperatorDefinition">
        <source>Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.</source>
        <target state="new">Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCompilingExtensionIsForML">
        <source>The file extensions '.ml' and '.mli' are for ML compatibility</source>
        <target state="new">The file extensions '.ml' and '.mli' are for ML compatibility</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIndentOffForML">
        <source>Consider using a file with extension '.ml' or '.mli' instead</source>
        <target state="new">Consider using a file with extension '.ml' or '.mli' instead</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternIdentIsNotFunctionTyped">
        <source>Active pattern '{0}' is not a function</source>
        <target state="new">Active pattern '{0}' is not a function</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternChoiceHasFreeTypars">
        <source>Active pattern '{0}' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</source>
        <target state="new">Active pattern '{0}' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldHasOffsetForSequentialLayout">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="new">The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsMustComeAfterNonOptionalArgs">
        <source>Optional arguments must come at the end of the argument list, after any non-optional arguments</source>
        <target state="new">Optional arguments must come at the end of the argument list, after any non-optional arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeUsage">
        <source>Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes</source>
        <target state="new">Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOperatorDefinitionInExtrinsic">
        <source>Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.</source>
        <target state="new">Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBFileNameCannotBeChangedWarning">
        <source>The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.</source>
        <target state="new">The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBMemberMissing">
        <source>MDB generation failed. Could not find compatible member {0}</source>
        <target state="new">MDB generation failed. Could not find compatible member {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingMdb">
        <source>Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly.</source>
        <target state="new">Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseNameConflictsWithGeneratedType">
        <source>The union case named '{0}' conflicts with the generated type '{1}'</source>
        <target state="new">The union case named '{0}' conflicts with the generated type '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoReflectedDefinitionOnStructMember">
        <source>ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter</source>
        <target state="new">ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportNotAllowed">
        <source>DLLImport bindings must be static members in a class or function definitions in a module</source>
        <target state="new">DLLImport bindings must be static members in a class or function definitions in a module</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExplicitCoreLibRequiresNoFramework">
        <source>When mscorlib.dll or FSharp.Core.dll is explicitly referenced the {0} option must also be passed</source>
        <target state="new">When mscorlib.dll or FSharp.Core.dll is explicitly referenced the {0} option must also be passed</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedSigdataFile">
        <source>FSharp.Core.sigdata not found alongside FSharp.Core. File expected in {0}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="new">FSharp.Core.sigdata not found alongside FSharp.Core. File expected in {0}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedFileAlongSideFSharpCore">
        <source>File '{0}' not found alongside FSharp.Core. File expected in {1}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="new">File '{0}' not found alongside FSharp.Core. File expected in {1}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedFileNameCharacter">
        <source>Filename '{0}' contains invalid character '{1}'</source>
        <target state="new">Filename '{0}' contains invalid character '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBinding">
        <source>'use!' bindings must be of the form 'use! &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="new">'use!' bindings must be of the form 'use! &lt;var&gt; = &lt;expr&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoInnerGenericsInQuotations">
        <source>Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.</source>
        <target state="new">Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumTypeCannotBeEnumerated">
        <source>The type '{0}' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property</source>
        <target state="new">The type '{0}' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteString">
        <source>End of file in triple-quote string begun at or before here</source>
        <target state="new">End of file in triple-quote string begun at or before here</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteStringInComment">
        <source>End of file in triple-quote string embedded in comment begun at or before here</source>
        <target state="new">End of file in triple-quote string embedded in comment begun at or before here</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLosesMeasures">
        <source>This type test or downcast will ignore the unit-of-measure '{0}'</source>
        <target state="new">This type test or downcast will ignore the unit-of-measure '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingTypeArgs">
        <source>Expected type argument or static argument</source>
        <target state="new">Expected type argument or static argument</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingGreaterThan">
        <source>Unmatched '&lt;'. Expected closing '&gt;'</source>
        <target state="new">Unmatched '&lt;'. Expected closing '&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
        <source>Unexpected quotation operator '&lt;@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '&lt;' and '@' characters.</source>
        <target state="new">Unexpected quotation operator '&lt;@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '&lt;' and '@' characters.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorParsingAsOperatorName">
        <source>Attempted to parse this as an operator name, but failed</source>
        <target state="new">Attempted to parse this as an operator name, but failed</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidUnicodeLiteral">
        <source>\U{0} is not a valid Unicode character escape sequence</source>
        <target state="new">\U{0} is not a valid Unicode character escape sequence</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoWrongType">
        <source>'{0}' must be applied to an argument of type '{1}', but has been applied to an argument of type '{2}'</source>
        <target state="new">'{0}' must be applied to an argument of type '{1}', but has been applied to an argument of type '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoNotOptional">
        <source>'{0}' can only be applied to optional arguments</source>
        <target state="new">'{0}' can only be applied to optional arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="toolLocationHelperUnsupportedFrameworkVersion">
        <source>The specified .NET Framework version '{0}' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
        <target state="new">The specified .NET Framework version '{0}' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidMagicValue">
        <source>Invalid Magic value in CLR Header</source>
        <target state="new">Invalid Magic value in CLR Header</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignBadImageFormat">
        <source>Bad image format</source>
        <target state="new">Bad image format</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignPrivateKeyExpected">
        <source>Private key expected</source>
        <target state="new">Private key expected</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignRsaKeyExpected">
        <source>RSA key expected</source>
        <target state="new">RSA key expected</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidBitLen">
        <source>Invalid bit Length</source>
        <target state="new">Invalid bit Length</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidRSAParams">
        <source>Invalid RSAParameters structure - '{{0}}' expected</source>
        <target state="new">Invalid RSAParameters structure - '{{0}}' expected</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidAlgId">
        <source>Invalid algId - 'Exponent' expected</source>
        <target state="new">Invalid algId - 'Exponent' expected</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidSignatureSize">
        <source>Invalid signature size</source>
        <target state="new">Invalid signature size</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignNoSignatureDirectory">
        <source>No signature directory</source>
        <target state="new">No signature directory</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidPKBlob">
        <source>Invalid Public Key blob</source>
        <target state="new">Invalid Public Key blob</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTooManyErrors">
        <source>Exiting - too many errors</source>
        <target state="new">Exiting - too many errors</target>
        <note />
      </trans-unit>
      <trans-unit id="docfileNoXmlSuffix">
        <source>The documentation file has no .xml suffix</source>
        <target state="new">The documentation file has no .xml suffix</target>
        <note />
      </trans-unit>
      <trans-unit id="fscNoImplementationFiles">
        <source>No implementation files specified</source>
        <target state="new">No implementation files specified</target>
        <note />
      </trans-unit>
      <trans-unit id="fscBadAssemblyVersion">
        <source>The attribute {0} specified version '{1}', but this value is invalid and has been ignored</source>
        <target state="new">The attribute {0} specified version '{1}', but this value is invalid and has been ignored</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTwoResourceManifests">
        <source>Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used.</source>
        <target state="new">Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking">
        <source>The code in assembly '{0}' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="new">The code in assembly '{0}' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking0">
        <source>Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="new">Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoEXE">
        <source>Static linking may not include a .EXE</source>
        <target state="new">Static linking may not include a .EXE</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoMixedDLL">
        <source>Static linking may not include a mixed managed/unmanaged DLL</source>
        <target state="new">Static linking may not include a mixed managed/unmanaged DLL</target>
        <note />
      </trans-unit>
      <trans-unit id="fscIgnoringMixedWhenLinking">
        <source>Ignoring mixed managed/unmanaged assembly '{0}' during static linking</source>
        <target state="new">Ignoring mixed managed/unmanaged assembly '{0}' during static linking</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssumeStaticLinkContainsNoDependencies">
        <source>Assembly '{0}' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.</source>
        <target state="new">Assembly '{0}' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyNotFoundInDependencySet">
        <source>Assembly '{0}' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.</source>
        <target state="new">Assembly '{0}' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileCouldNotBeOpened">
        <source>The key file '{0}' could not be opened</source>
        <target state="new">The key file '{0}' could not be opened</target>
        <note />
      </trans-unit>
      <trans-unit id="fscProblemWritingBinary">
        <source>A problem occurred writing the binary '{0}': {1}</source>
        <target state="new">A problem occurred writing the binary '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyVersionAttributeIgnored">
        <source>The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option</source>
        <target state="new">The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyCultureAttributeError">
        <source>Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'</source>
        <target state="new">Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDelaySignWarning">
        <source>Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module</source>
        <target state="new">Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileWarning">
        <source>Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module</source>
        <target state="new">Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyNameWarning">
        <source>Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module</source>
        <target state="new">Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module</target>
        <note />
      </trans-unit>
      <trans-unit id="fscReferenceOnCommandLine">
        <source>The assembly '{0}' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'.</source>
        <target state="new">The assembly '{0}' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscRemotingError">
        <source>The resident compilation service was not used because a problem occured in communicating with the server.</source>
        <target state="new">The resident compilation service was not used because a problem occured in communicating with the server.</target>
        <note />
      </trans-unit>
      <trans-unit id="pathIsInvalid">
        <source>Problem with filename '{0}': Illegal characters in path.</source>
        <target state="new">Problem with filename '{0}': Illegal characters in path.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscResxSourceFileDeprecated">
        <source>Passing a .resx file ({0}) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.</source>
        <target state="new">Passing a .resx file ({0}) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoProfileMismatches">
        <source>Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).</source>
        <target state="new">Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyWildcardAndDeterminism">
        <source>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</source>
        <target state="new">An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDeterministicDebugRequiresPortablePdb">
        <source>Determinstic builds only support portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="new">Determinstic builds only support portable PDBs (--debug:portable or --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInNamespaceName">
        <source>Character '{0}' is not allowed in provided namespace name '{1}'</source>
        <target state="new">Character '{0}' is not allowed in provided namespace name '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullOrEmptyMemberName">
        <source>The provided type '{0}' returned a member with a null or empty member name</source>
        <target state="new">The provided type '{0}' returned a member with a null or empty member name</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMember">
        <source>The provided type '{0}' returned a null member</source>
        <target state="new">The provided type '{0}' returned a null member</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringType">
        <source>The provided type '{0}' member info '{1}' has null declaring type</source>
        <target state="new">The provided type '{0}' member info '{1}' has null declaring type</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringTypeDifferentFromProvidedType">
        <source>The provided type '{0}' has member '{1}' which has declaring type '{2}'. Expected declaring type to be the same as provided type.</source>
        <target state="new">The provided type '{0}' has member '{1}' which has declaring type '{2}'. Expected declaring type to be the same as provided type.</target>
        <note />
      </trans-unit>
      <trans-unit id="etHostingAssemblyFoundWithoutHosts">
        <source>Referenced assembly '{0}' has assembly level attribute '{1}' but no public type provider classes were found</source>
        <target state="new">Referenced assembly '{0}' has assembly level attribute '{1}' but no public type provider classes were found</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceOfTypeNotAllowed">
        <source>Type '{0}' from type provider '{1}' has an empty namespace. Use 'null' for the global namespace.</source>
        <target state="new">Type '{0}' from type provider '{1}' has an empty namespace. Use 'null' for the global namespace.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceNotAllowed">
        <source>Empty namespace found from the type provider '{0}'. Use 'null' for the global namespace.</source>
        <target state="new">Empty namespace found from the type provider '{0}'. Use 'null' for the global namespace.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeGeneric">
        <source>Provided type '{0}' has 'IsGenericType' as true, but generic types are not supported.</source>
        <target state="new">Provided type '{0}' has 'IsGenericType' as true, but generic types are not supported.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeAnArray">
        <source>Provided type '{0}' has 'IsArray' as true, but array types are not supported.</source>
        <target state="new">Provided type '{0}' has 'IsArray' as true, but array types are not supported.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMethodHasRequirements">
        <source>Invalid member '{0}' on provided type '{1}'. Provided type members must be public, and not be generic, virtual, or abstract.</source>
        <target state="new">Invalid member '{0}' on provided type '{1}'. Provided type members must be public, and not be generic, virtual, or abstract.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedMemberKind">
        <source>Invalid member '{0}' on provided type '{1}'. Only properties, methods and constructors are allowed</source>
        <target state="new">Invalid member '{0}' on provided type '{1}'. Only properties, methods and constructors are allowed</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanReadButHasNoGetter">
        <source>Property '{0}' on provided type '{1}' has CanRead=true but there was no value from GetGetMethod()</source>
        <target state="new">Property '{0}' on provided type '{1}' has CanRead=true but there was no value from GetGetMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasGetterButNoCanRead">
        <source>Property '{0}' on provided type '{1}' has CanRead=false but GetGetMethod() returned a method</source>
        <target state="new">Property '{0}' on provided type '{1}' has CanRead=false but GetGetMethod() returned a method</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanWriteButHasNoSetter">
        <source>Property '{0}' on provided type '{1}' has CanWrite=true but there was no value from GetSetMethod()</source>
        <target state="new">Property '{0}' on provided type '{1}' has CanWrite=true but there was no value from GetSetMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasSetterButNoCanWrite">
        <source>Property '{0}' on provided type '{1}' has CanWrite=false but GetSetMethod() returned a method</source>
        <target state="new">Property '{0}' on provided type '{1}' has CanWrite=false but GetSetMethod() returned a method</target>
        <note />
      </trans-unit>
      <trans-unit id="etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
        <source>One or more errors seen during provided type setup</source>
        <target state="new">One or more errors seen during provided type setup</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedTypeMember">
        <source>Unexpected exception from provided type '{0}' member '{1}': {2}</source>
        <target state="new">Unexpected exception from provided type '{0}' member '{1}': {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedConstantType">
        <source>Unsupported constant type '{0}'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal.</source>
        <target state="new">Unsupported constant type '{0}'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedProvidedExpression">
        <source>Unsupported expression '{0}' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.</source>
        <target state="new">Unsupported expression '{0}' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedName">
        <source>Expected provided type named '{0}' but provided type has 'Name' with value '{1}'</source>
        <target state="new">Expected provided type named '{0}' but provided type has 'Name' with value '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoAdd">
        <source>Event '{0}' on provided type '{1}' has no value from GetAddMethod()</source>
        <target state="new">Event '{0}' on provided type '{1}' has no value from GetAddMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoRemove">
        <source>Event '{0}' on provided type '{1}' has no value from GetRemoveMethod()</source>
        <target state="new">Event '{0}' on provided type '{1}' has no value from GetRemoveMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssembly">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded or doesn't exist. {2}</source>
        <target state="new">Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded or doesn't exist. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderDoesNotHaveValidConstructor">
        <source>The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected.</source>
        <target state="new">The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderError">
        <source>The type provider '{0}' reported an error: {1}</source>
        <target state="new">The type provider '{0}' reported an error: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectParameterExpression">
        <source>The type provider '{0}' used an invalid parameter in the ParameterExpression: {1}</source>
        <target state="new">The type provider '{0}' used an invalid parameter in the ParameterExpression: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedMethod">
        <source>The type provider '{0}' provided a method with a name '{1}' and metadata token '{2}', which is not reported among its methods of its declaring type '{3}'</source>
        <target state="new">The type provider '{0}' provided a method with a name '{1}' and metadata token '{2}', which is not reported among its methods of its declaring type '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedConstructor">
        <source>The type provider '{0}' provided a constructor which is not reported among the constructors of its declaring type '{1}'</source>
        <target state="new">The type provider '{0}' provided a constructor which is not reported among the constructors of its declaring type '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etDirectReferenceToGeneratedTypeNotAllowed">
        <source>A direct reference to the generated type '{0}' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = &lt;path&gt;'. This indicates that a type provider adds generated types to your assembly.</source>
        <target state="new">A direct reference to the generated type '{0}' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = &lt;path&gt;'. This indicates that a type provider adds generated types to your assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedPath">
        <source>Expected provided type with path '{0}' but provided type has path '{1}'</source>
        <target state="new">Expected provided type with path '{0}' but provided type has path '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedNullFromProvidedTypeMember">
        <source>Unexpected 'null' return value from provided type '{0}' member '{1}'</source>
        <target state="new">Unexpected 'null' return value from provided type '{0}' member '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedMemberMember">
        <source>Unexpected exception from member '{0}' of provided type '{1}' member '{2}': {3}</source>
        <target state="new">Unexpected exception from member '{0}' of provided type '{1}' member '{2}': {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
        <source>Nested provided types do not take static arguments or generic parameters</source>
        <target state="new">Nested provided types do not take static arguments or generic parameters</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidStaticArgument">
        <source>Invalid static argument to provided type. Expected an argument of kind '{0}'.</source>
        <target state="new">Invalid static argument to provided type. Expected an argument of kind '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToType">
        <source>An error occured applying the static arguments to a provided type</source>
        <target state="new">An error occured applying the static arguments to a provided type</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnknownStaticArgumentKind">
        <source>Unknown static argument kind '{0}' when resolving a reference to a provided type or method '{1}'</source>
        <target state="new">Unknown static argument kind '{0}' when resolving a reference to a provided type or method '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidNamespaceForProvidedType">
        <source>invalid namespace for provided type</source>
        <target state="new">invalid namespace for provided type</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidFullNameForProvidedType">
        <source>invalid full name for provided type</source>
        <target state="new">invalid full name for provided type</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderReturnedNull">
        <source>The type provider returned 'null', which is not a valid return value from '{0}'</source>
        <target state="new">The type provider returned 'null', which is not a valid return value from '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etTypeProviderConstructorException">
        <source>The type provider constructor has thrown an exception: {0}</source>
        <target state="new">The type provider constructor has thrown an exception: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullProvidedExpression">
        <source>Type provider '{0}' returned null from GetInvokerExpression.</source>
        <target state="new">Type provider '{0}' returned null from GetInvokerExpression.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedTypeHadWrongName">
        <source>The type provider '{0}' returned an invalid type from 'ApplyStaticArguments'. A type with name '{1}' was expected, but a type with name '{2}' was returned.</source>
        <target state="new">The type provider '{0}' returned an invalid type from 'ApplyStaticArguments'. A type with name '{1}' was expected, but a type with name '{2}' was returned.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedMethodHadWrongName">
        <source>The type provider '{0}' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '{1}' was expected, but a method with name '{2}' was returned.</source>
        <target state="new">The type provider '{0}' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '{1}' was expected, but a method with name '{2}' was returned.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLossy">
        <source>This type test or downcast will erase the provided type '{0}' to the type '{1}'</source>
        <target state="new">This type test or downcast will erase the provided type '{0}' to the type '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCastErased">
        <source>This downcast will erase the provided type '{0}' to the type '{1}'.</source>
        <target state="new">This downcast will erase the provided type '{0}' to the type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestErased">
        <source>This type test with a provided type '{0}' is not allowed because this provided type will be erased to '{1}' at runtime.</source>
        <target state="new">This type test with a provided type '{0}' is not allowed because this provided type will be erased to '{1}' at runtime.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromErasedType">
        <source>Cannot inherit from erased provided type</source>
        <target state="new">Cannot inherit from erased provided type</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidTypeProviderAssemblyName">
        <source>Assembly '{0}' hase TypeProviderAssembly attribute with invalid value '{1}'. The value should be a valid assembly name</source>
        <target state="new">Assembly '{0}' hase TypeProviderAssembly attribute with invalid value '{1}'. The value should be a valid assembly name</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameCtor">
        <source>Invalid member name. Members may not have name '.ctor' or '.cctor'</source>
        <target state="new">Invalid member name. Members may not have name '.ctor' or '.cctor'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInferredGenericTypeGivesRiseToInconsistency">
        <source>The function or member '{0}' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '{1}'.</source>
        <target state="new">The function or member '{0}' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentCount">
        <source>The number of type arguments did not match: '{0}' given, '{1}' expected. This may be related to a previously reported error.</source>
        <target state="new">The number of type arguments did not match: '{0}' given, '{1}' expected. This may be related to a previously reported error.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotOverrideSealedMethod">
        <source>Cannot override inherited member '{0}' because it is sealed</source>
        <target state="new">Cannot override inherited member '{0}' because it is sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderErrorWithContext">
        <source>The type provider '{0}' reported an error in the context of provided type '{1}', member '{2}'. The error: {3}</source>
        <target state="new">The type provider '{0}' reported an error in the context of provided type '{1}', member '{2}'. The error: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNameException">
        <source>An exception occurred when accessing the '{0}' of a provided type: {1}</source>
        <target state="new">An exception occurred when accessing the '{0}' of a provided type: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNullOrEmptyName">
        <source>The '{0}' of a provided type was null or empty.</source>
        <target state="new">The '{0}' of a provided type was null or empty.</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInTypeName">
        <source>Character '{0}' is not allowed in provided type name '{1}'</source>
        <target state="new">Character '{0}' is not allowed in provided type name '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcJoinMustUseSimplePattern">
        <source>In queries, '{0}' must use a simple pattern</source>
        <target state="new">In queries, '{0}' must use a simple pattern</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMissingCustomOperation">
        <source>A custom query operation for '{0}' is required but not specified</source>
        <target state="new">A custom query operation for '{0}' is required but not specified</target>
        <note />
      </trans-unit>
      <trans-unit id="etBadUnnamedStaticArgs">
        <source>Named static arguments must come after all unnamed static arguments</source>
        <target state="new">Named static arguments must come after all unnamed static arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterRequiresAValue">
        <source>The static parameter '{0}' of the provided type or method '{1}' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '{2}&lt;{3}=...&gt;'.</source>
        <target state="new">The static parameter '{0}' of the provided type or method '{1}' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '{2}&lt;{3}=...&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNoStaticParameterWithName">
        <source>No static parameter exists with name '{0}'</source>
        <target state="new">No static parameter exists with name '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterAlreadyHasValue">
        <source>The static parameter '{0}' has already been given a value</source>
        <target state="new">The static parameter '{0}' has already been given a value</target>
        <note />
      </trans-unit>
      <trans-unit id="etMultipleStaticParameterWithName">
        <source>Multiple static parameters exist with name '{0}'</source>
        <target state="new">Multiple static parameters exist with name '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
        <source>A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression</source>
        <target state="new">A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedHere">
        <source>A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression</source>
        <target state="new">A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeOverloaded">
        <source>The custom operation '{0}' refers to a method which is overloaded. The implementations of custom operations may not be overloaded.</source>
        <target state="new">The custom operation '{0}' refers to a method which is overloaded. The implementations of custom operations may not be overloaded.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIfThenElseMayNotBeUsedWithinQueries">
        <source>An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.</source>
        <target state="new">An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
        <source>Invalid argument to 'methodhandleof' during codegen</source>
        <target state="new">Invalid argument to 'methodhandleof' during codegen</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceMissingArgument">
        <source>A reference to a provided type was missing a value for the static parameter '{0}'. You may need to recompile one or more referenced assemblies.</source>
        <target state="new">A reference to a provided type was missing a value for the static parameter '{0}'. You may need to recompile one or more referenced assemblies.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceInvalidText">
        <source>A reference to a provided type had an invalid value '{0}' for a static parameter. You may need to recompile one or more referenced assemblies.</source>
        <target state="new">A reference to a provided type had an invalid value '{0}' for a static parameter. You may need to recompile one or more referenced assemblies.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly">
        <source>'{0}' is not used correctly. This is a custom operation in this query or computation expression.</source>
        <target state="new">'{0}' is not used correctly. This is a custom operation in this query or computation expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly2">
        <source>'{0}' is not used correctly. Usage: {1}. This is a custom operation in this query or computation expression.</source>
        <target state="new">'{0}' is not used correctly. Usage: {1}. This is a custom operation in this query or computation expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeJoin">
        <source>{0} var in collection {1} (outerKey = innerKey). Note that parentheses are required after '{2}'</source>
        <target state="new">{0} var in collection {1} (outerKey = innerKey). Note that parentheses are required after '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeGroupJoin">
        <source>{0} var in collection {1} (outerKey = innerKey) into group. Note that parentheses are required after '{2}'</source>
        <target state="new">{0} var in collection {1} (outerKey = innerKey) into group. Note that parentheses are required after '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeZip">
        <source>{0} var in collection</source>
        <target state="new">{0} var in collection</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresVariable">
        <source>'{0}' must be followed by a variable name. Usage: {1}.</source>
        <target state="new">'{0}' must be followed by a variable name. Usage: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorIncorrectSyntax">
        <source>Incorrect syntax for '{0}'. Usage: {1}.</source>
        <target state="new">Incorrect syntax for '{0}'. Usage: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresBody">
        <source>'{0}' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... {1} ...</source>
        <target state="new">'{0}' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationHasIncorrectArgCount">
        <source>'{0}' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected {1} argument(s), but given {2}.</source>
        <target state="new">'{0}' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected {1} argument(s), but given {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterToken">
        <source>Expected an expression after this point</source>
        <target state="new">Expected an expression after this point</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedTypeAfterToken">
        <source>Expected a type after this point</source>
        <target state="new">Expected a type after this point</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLBrackLess">
        <source>Unmatched '[&lt;'. Expected closing '&gt;]'</source>
        <target state="new">Unmatched '[&lt;'. Expected closing '&gt;]'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileMatch">
        <source>Unexpected end of input in 'match' expression. Expected 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</source>
        <target state="new">Unexpected end of input in 'match' expression. Expected 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTry">
        <source>Unexpected end of input in 'try' expression. Expected 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;'.</source>
        <target state="new">Unexpected end of input in 'try' expression. Expected 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWhile">
        <source>Unexpected end of input in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="new">Unexpected end of input in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFor">
        <source>Unexpected end of input in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="new">Unexpected end of input in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWith">
        <source>Unexpected end of input in 'match' or 'try' expression</source>
        <target state="new">Unexpected end of input in 'match' or 'try' expression</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileThen">
        <source>Unexpected end of input in 'then' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="new">Unexpected end of input in 'then' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileElse">
        <source>Unexpected end of input in 'else' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="new">Unexpected end of input in 'else' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFunBody">
        <source>Unexpected end of input in body of lambda expression. Expected 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</source>
        <target state="new">Unexpected end of input in body of lambda expression. Expected 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeArgs">
        <source>Unexpected end of input in type arguments</source>
        <target state="new">Unexpected end of input in type arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeSignature">
        <source>Unexpected end of input in type signature</source>
        <target state="new">Unexpected end of input in type signature</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeDefinition">
        <source>Unexpected end of input in type definition</source>
        <target state="new">Unexpected end of input in type definition</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileObjectMembers">
        <source>Unexpected end of input in object members</source>
        <target state="new">Unexpected end of input in object members</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileDefinition">
        <source>Unexpected end of input in value, function or member definition</source>
        <target state="new">Unexpected end of input in value, function or member definition</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileExpression">
        <source>Unexpected end of input in expression</source>
        <target state="new">Unexpected end of input in expression</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedNameAfterToken">
        <source>Unexpected end of type. Expected a name after this point.</source>
        <target state="new">Unexpected end of type. Expected a name after this point.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLet">
        <source>Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.</source>
        <target state="new">Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLetBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword.</source>
        <target state="new">Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUseBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword.</source>
        <target state="new">Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUse">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword.</source>
        <target state="new">Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsWhileDoExpected">
        <source>Missing 'do' in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="new">Missing 'do' in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsForDoExpected">
        <source>Missing 'do' in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="new">Missing 'do' in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRelationInJoin">
        <source>Invalid join relation in '{0}'. Expected 'expr &lt;op&gt; expr', where &lt;op&gt; is =, =?, ?= or ?=?.</source>
        <target state="new">Invalid join relation in '{0}'. Expected 'expr &lt;op&gt; expr', where &lt;op&gt; is =, =?, ?= or ?=?.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCallsWord">
        <source>Calls</source>
        <target state="new">Calls</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidNumberOfGenericArguments">
        <source>Invalid number of generic arguments to type '{0}' in provided type. Expected '{1}' arguments, given '{2}'.</source>
        <target state="new">Invalid number of generic arguments to type '{0}' in provided type. Expected '{1}' arguments, given '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument1">
        <source>Invalid value '{0}' for unit-of-measure parameter '{1}'</source>
        <target state="new">Invalid value '{0}' for unit-of-measure parameter '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument2">
        <source>Invalid value unit-of-measure parameter '{0}'</source>
        <target state="new">Invalid value unit-of-measure parameter '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyNeedsCanWriteOrCanRead">
        <source>Property '{0}' on provided type '{1}' is neither readable nor writable as it has CanRead=false and CanWrite=false</source>
        <target state="new">Property '{0}' on provided type '{1}' is neither readable nor writable as it has CanRead=false and CanWrite=false</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIntoNeedsRestOfQuery">
        <source>A use of 'into' must be followed by the remainder of the computation</source>
        <target state="new">A use of 'into' must be followed by the remainder of the computation</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorDoesntAcceptInto">
        <source>The operator '{0}' does not accept the use of 'into'</source>
        <target state="new">The operator '{0}' does not accept the use of 'into'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationInvalid">
        <source>The definition of the custom operator '{0}' does not use a valid combination of attribute flags</source>
        <target state="new">The definition of the custom operator '{0}' does not use a valid combination of attribute flags</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisTypeMayNotHaveACLIMutableAttribute">
        <source>This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute.</source>
        <target state="new">This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAutoPropertyRequiresImplicitConstructionSequence">
        <source>'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="new">'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSet">
        <source>Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="new">Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
        <source>To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="new">To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefsOfByrefs">
        <source>Type '{0}' is illegal because in byref&lt;T&gt;, T cannot contain byref types.</source>
        <target state="new">Type '{0}' is illegal because in byref&lt;T&gt;, T cannot contain byref types.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastopsMaxArrayThirtyTwo">
        <source>F# supports array ranks between 1 and 32. The value {0} is not allowed.</source>
        <target state="new">F# supports array ranks between 1 and 32. The value {0} is not allowed.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoIntegerForLoopInQuery">
        <source>In queries, use the form 'for x in n .. m do ...' for ranging over integers</source>
        <target state="new">In queries, use the form 'for x in n .. m do ...' for ranging over integers</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoWhileInQuery">
        <source>'while' expressions may not be used in queries</source>
        <target state="new">'while' expressions may not be used in queries</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoTryFinallyInQuery">
        <source>'try/finally' expressions may not be used in queries</source>
        <target state="new">'try/finally' expressions may not be used in queries</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseMayNotBeUsedInQueries">
        <source>'use' expressions may not be used in queries</source>
        <target state="new">'use' expressions may not be used in queries</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindMayNotBeUsedInQueries">
        <source>'let!', 'use!' and 'do!' expressions may not be used in queries</source>
        <target state="new">'let!', 'use!' and 'do!' expressions may not be used in queries</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnMayNotBeUsedInQueries">
        <source>'return' and 'return!' may not be used in queries</source>
        <target state="new">'return' and 'return!' may not be used in queries</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryOperator">
        <source>This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type.</source>
        <target state="new">This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryWithMayNotBeUsedInQueries">
        <source>'try/with' expressions may not be used in queries</source>
        <target state="new">'try/with' expressions may not be used in queries</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonSimpleLetBindingInQuery">
        <source>This 'let' definition may not be used in a query. Only simple value definitions may be used in queries.</source>
        <target state="new">This 'let' definition may not be used in a query. Only simple value definitions may be used in queries.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTooManyStaticParameters">
        <source>Too many static parameters. Expected at most {0} parameters, but got {1} unnamed and {2} named parameters.</source>
        <target state="new">Too many static parameters. Expected at most {0} parameters, but got {1} unnamed and {2} named parameters.</target>
        <note />
      </trans-unit>
      <trans-unit id="infosInvalidProvidedLiteralValue">
        <source>Invalid provided literal value '{0}'</source>
        <target state="new">Invalid provided literal value '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidPlatformTarget">
        <source>The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead.</source>
        <target state="new">The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisValueMayNotBeInlined">
        <source>This member, function or value declaration may not be declared 'inline'</source>
        <target state="new">This member, function or value declaration may not be declared 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="etErasedTypeUsedInGeneration">
        <source>The provider '{0}' returned a non-generated type '{1}' in the context of a set of generated types. Consider adjusting the type provider to only return generated types.</source>
        <target state="new">The provider '{0}' returned a non-generated type '{1}' in the context of a set of generated types. Consider adjusting the type provider to only return generated types.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryBinaryOperator">
        <source>Arguments to query operators may require parentheses, e.g. 'where (x &gt; y)' or 'groupBy (x.Length / 10)'</source>
        <target state="new">Arguments to query operators may require parentheses, e.g. 'where (x &gt; y)' or 'groupBy (x.Length / 10)'</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoSetOfHole">
        <source>A quotation may not involve an assignment to or taking the address of a captured local variable</source>
        <target state="new">A quotation may not involve an assignment to or taking the address of a captured local variable</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloads1">
        <source>+ 1 overload</source>
        <target state="new">+ 1 overload</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloadsN">
        <source>+ {0} overloads</source>
        <target state="new">+ {0} overloads</target>
        <note />
      </trans-unit>
      <trans-unit id="erasedTo">
        <source>Erased to</source>
        <target state="new">Erased to</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnfinishedExpression">
        <source>Unexpected token '{0}' or incomplete expression</source>
        <target state="new">Unexpected token '{0}' or incomplete expression</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributeOnIncompleteCode">
        <source>Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.</source>
        <target state="new">Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeNameCannotBeEmpty">
        <source>Type name cannot be empty.</source>
        <target state="new">Type name cannot be empty.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemReadingAssembly">
        <source>Problem reading assembly '{0}': {1}</source>
        <target state="new">Problem reading assembly '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTPFieldMustBeLiteral">
        <source>Invalid provided field. Provided fields of erased provided types must be literals.</source>
        <target state="new">Invalid provided field. Provided fields of erased provided types must be literals.</target>
        <note />
      </trans-unit>
      <trans-unit id="loadingDescription">
        <source>(loading description...)</source>
        <target state="new">(loading description...)</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionUnavailable">
        <source>(description unavailable...)</source>
        <target state="new">(description unavailable...)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTyparMultipleClassConstraints">
        <source>A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.</source>
        <target state="new">A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMatchMayNotBeUsedWithQuery">
        <source>'match' expressions may not be used in queries</source>
        <target state="new">'match' expressions may not be used in queries</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonTripleArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 3 arguments</source>
        <target state="new">Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 3 arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="cannotResolveNullableOperators">
        <source>The operator '{0}' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="new">The operator '{0}' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorRequiresIn">
        <source>'{0}' must be followed by 'in'. Usage: {1}.</source>
        <target state="new">'{0}' must be followed by 'in'. Usage: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalMemberVarInObjectImplementation">
        <source>Neither 'member val' nor 'override val' definitions are permitted in object expressions.</source>
        <target state="new">Neither 'member val' nor 'override val' definitions are permitted in object expressions.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyCopyAndUpdateRecordInvalid">
        <source>Copy-and-update record expressions must include at least one field.</source>
        <target state="new">Copy-and-update record expressions must include at least one field.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnderscoreInvalidFieldName">
        <source>'_' cannot be used as field name</source>
        <target state="new">'_' cannot be used as field name</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGeneratedTypesShouldBeInternalOrPrivate">
        <source>The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'.</source>
        <target state="new">The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterAndSetterHaveSamePropertyType">
        <source>A property's getter and setter must have the same type. Property '{0}' has getter of type '{1}' but setter of type '{2}'.</source>
        <target state="new">A property's getter and setter must have the same type. Property '{0}' has getter of type '{1}' but setter of type '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRuntimeSuppliedMethodCannotBeUsedInUserCode">
        <source>Array method '{0}' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.</source>
        <target state="new">Array method '{0}' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName">
        <source>Union case/exception '{0}' does not have field named '{1}'.</source>
        <target state="new">Union case/exception '{0}' does not have field named '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseFieldCannotBeUsedMoreThanOnce">
        <source>Union case/exception field '{0}' cannot be used more than once.</source>
        <target state="new">Union case/exception field '{0}' cannot be used more than once.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameIsUsedModeThanOnce">
        <source>Named field '{0}' is used more than once.</source>
        <target state="new">Named field '{0}' is used more than once.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameConflictsWithGeneratedNameForAnonymousField">
        <source>Named field '{0}' conflicts with autogenerated name for anonymous field.</source>
        <target state="new">Named field '{0}' conflicts with autogenerated name for anonymous field.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConstantExpressionOverflow">
        <source>This literal expression or attribute argument results in an arithmetic overflow.</source>
        <target state="new">This literal expression or attribute argument results in an arithmetic overflow.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalStructTypeForConstantExpression">
        <source>This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.</source>
        <target state="new">This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscSystemRuntimeInteropServicesIsRequired">
        <source>System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.</source>
        <target state="new">System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.</target>
        <note />
      </trans-unit>
      <trans-unit id="abImplicitHeapAllocation">
        <source>The mutable local '{0}' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.</source>
        <target state="new">The mutable local '{0}' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.</target>
        <note />
      </trans-unit>
      <trans-unit id="estApplyStaticArgumentsForMethodNotImplemented">
        <source>A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid</source>
        <target state="new">A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToMethod">
        <source>An error occured applying the static arguments to a provided method</source>
        <target state="new">An error occured applying the static arguments to a provided method</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexUnexpectedChar">
        <source>Unexpected character '{0}' in preprocessor expression</source>
        <target state="new">Unexpected character '{0}' in preprocessor expression</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsUnexpectedToken">
        <source>Unexpected token '{0}' in preprocessor expression</source>
        <target state="new">Unexpected token '{0}' in preprocessor expression</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsIncompleteExpression">
        <source>Incomplete preprocessor expression</source>
        <target state="new">Incomplete preprocessor expression</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsMissingToken">
        <source>Missing token '{0}' in preprocessor expression</source>
        <target state="new">Missing token '{0}' in preprocessor expression</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleMissingDefinition">
        <source>An error occurred while reading the F# metadata node at position {0} in table '{1}' of assembly '{2}'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.</source>
        <target state="new">An error occurred while reading the F# metadata node at position {0} in table '{1}' of assembly '{2}'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScope">
        <source>Type inference caused the type variable {0} to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.</source>
        <target state="new">Type inference caused the type variable {0} to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScopeAnon">
        <source>Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.</source>
        <target state="new">Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkRaiseFamilyFunctionArgumentCount">
        <source>Redundant arguments are being ignored in function '{0}'. Expected {1} but got {2} arguments.</source>
        <target state="new">Redundant arguments are being ignored in function '{0}'. Expected {1} but got {2} arguments.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkLowercaseLiteralBindingInPattern">
        <source>Lowercase literal '{0}' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.</source>
        <target state="new">Lowercase literal '{0}' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralDoesNotTakeArguments">
        <source>This literal pattern does not take arguments</source>
        <target state="new">This literal pattern does not take arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalInAugmentation">
        <source>Constructors are not permitted as extension members - they must be defined as part of the original definition of the type</source>
        <target state="new">Constructors are not permitted as extension members - they must be defined as part of the original definition of the type</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidResponseFile">
        <source>Invalid response file '{0}' ( '{1}' )</source>
        <target state="new">Invalid response file '{0}' ( '{1}' )</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNotFound">
        <source>Response file '{0}' not found in '{1}'</source>
        <target state="new">Response file '{0}' not found in '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNameInvalid">
        <source>Response file name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="new">Response file name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</target>
        <note />
      </trans-unit>
      <trans-unit id="fsharpCoreNotFoundToBeCopied">
        <source>Cannot find FSharp.Core.dll in compiler's directory</source>
        <target state="new">Cannot find FSharp.Core.dll in compiler's directory</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleStructMismatch">
        <source>One tuple type is a struct tuple, the other is a reference tuple</source>
        <target state="new">One tuple type is a struct tuple, the other is a reference tuple</target>
        <note />
      </trans-unit>
      <trans-unit id="etMissingStaticArgumentsToMethod">
        <source>This provided method requires static parameters</source>
        <target state="new">This provided method requires static parameters</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcast">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'.</source>
        <target state="new">The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'.</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcastOperator">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.</source>
        <target state="new">The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecImplied">
        <source>The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored</source>
        <target state="new">The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenFirstInMutRec">
        <source>In a recursive declaration group, 'open' declarations must come first in each module</source>
        <target state="new">In a recursive declaration group, 'open' declarations must come first in each module</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbrevFirstInMutRec">
        <source>In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations</source>
        <target state="new">In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedMutRecDecl">
        <source>This declaration is not supported in recursive declaration groups</source>
        <target state="new">This declaration is not supported in recursive declaration groups</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidUseOfRec">
        <source>Invalid use of 'rec' keyword</source>
        <target state="new">Invalid use of 'rec' keyword</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructUnionMultiCaseDistinctFields">
        <source>If a union type has more than one case and is a struct, then all fields within the union type must be given unique names.</source>
        <target state="new">If a union type has more than one case and is a struct, then all fields within the union type must be given unique names.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerMemberNameIsOverriden">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="new">The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFixedNotAllowed">
        <source>Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'</source>
        <target state="new">Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindOffsetToStringData">
        <source>Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression.</source>
        <target state="new">Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefReturnOfLocal">
        <source>The address of the variable '{0}' cannot be used at this point. A method or function may not return the address of this local value.</source>
        <target state="new">The address of the variable '{0}' cannot be used at this point. A method or function may not return the address of this local value.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedActivePattern">
        <source>{0} is an active pattern and cannot be treated as a discriminated union case with named fields.</source>
        <target state="new">{0} is an active pattern and cannot be treated as a discriminated union case with named fields.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultParameterValueNotAppropriateForArgument">
        <source>The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'.</source>
        <target state="new">The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGlobalsSystemTypeNotFound">
        <source>The system type '{0}' was required but no referenced system DLL contained this type</source>
        <target state="new">The system type '{0}' was required but no referenced system DLL contained this type</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberHasMultiplePossibleDispatchSlots">
        <source>The member '{0}' matches multiple overloads of the same method.\nPlease restrict it to one of the following:{1}.</source>
        <target state="new">The member '{0}' matches multiple overloads of the same method.\nPlease restrict it to one of the following:{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="methodIsNotStatic">
        <source>Method or object constructor '{0}' is not static</source>
        <target state="new">Method or object constructor '{0}' is not static</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolEqualsInsteadOfIn">
        <source>Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?</source>
        <target state="new">Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAbstract">
        <source>Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</source>
        <target state="new">Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</target>
        <note />
      </trans-unit>
      <trans-unit id="keyworkDescriptionAnd">
        <source>Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</source>
        <target state="new">Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAs">
        <source>Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</source>
        <target state="new">Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAssert">
        <source>Used to verify code during debugging.</source>
        <target state="new">Used to verify code during debugging.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBase">
        <source>Used as the name of the base class object.</source>
        <target state="new">Used as the name of the base class object.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBegin">
        <source>In verbose syntax, indicates the start of a code block.</source>
        <target state="new">In verbose syntax, indicates the start of a code block.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionClass">
        <source>In verbose syntax, indicates the start of a class definition.</source>
        <target state="new">In verbose syntax, indicates the start of a class definition.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDefault">
        <source>Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</source>
        <target state="new">Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDelegate">
        <source>Used to declare a delegate.</source>
        <target state="new">Used to declare a delegate.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDo">
        <source>Used in looping constructs or to execute imperative code.</source>
        <target state="new">Used in looping constructs or to execute imperative code.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDone">
        <source>In verbose syntax, indicates the end of a block of code in a looping expression.</source>
        <target state="new">In verbose syntax, indicates the end of a block of code in a looping expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDowncast">
        <source>Used to convert to a type that is lower in the inheritance chain.</source>
        <target state="new">Used to convert to a type that is lower in the inheritance chain.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDownto">
        <source>In a for expression, used when counting in reverse.</source>
        <target state="new">In a for expression, used when counting in reverse.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElif">
        <source>Used in conditional branching. A short form of else if.</source>
        <target state="new">Used in conditional branching. A short form of else if.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElse">
        <source>Used in conditional branching.</source>
        <target state="new">Used in conditional branching.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionEnd">
        <source>In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</source>
        <target state="new">In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionException">
        <source>Used to declare an exception type.</source>
        <target state="new">Used to declare an exception type.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionExtern">
        <source>Indicates that a declared program element is defined in another binary or assembly.</source>
        <target state="new">Indicates that a declared program element is defined in another binary or assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTrueFalse">
        <source>Used as a Boolean literal.</source>
        <target state="new">Used as a Boolean literal.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFinally">
        <source>Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</source>
        <target state="new">Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFor">
        <source>Used in looping constructs.</source>
        <target state="new">Used in looping constructs.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFun">
        <source>Used in lambda expressions, also known as anonymous functions.</source>
        <target state="new">Used in lambda expressions, also known as anonymous functions.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFunction">
        <source>Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</source>
        <target state="new">Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionGlobal">
        <source>Used to reference the top-level .NET namespace.</source>
        <target state="new">Used to reference the top-level .NET namespace.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIf">
        <source>Used in conditional branching constructs.</source>
        <target state="new">Used in conditional branching constructs.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIn">
        <source>Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</source>
        <target state="new">Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInherit">
        <source>Used to specify a base class or base interface.</source>
        <target state="new">Used to specify a base class or base interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInline">
        <source>Used to indicate a function that should be integrated directly into the caller's code.</source>
        <target state="new">Used to indicate a function that should be integrated directly into the caller's code.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInterface">
        <source>Used to declare and implement interfaces.</source>
        <target state="new">Used to declare and implement interfaces.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInternal">
        <source>Used to specify that a member is visible inside an assembly but not outside it.</source>
        <target state="new">Used to specify that a member is visible inside an assembly but not outside it.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLazy">
        <source>Used to specify a computation that is to be performed only when a result is needed.</source>
        <target state="new">Used to specify a computation that is to be performed only when a result is needed.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLet">
        <source>Used to associate, or bind, a name to a value or function.</source>
        <target state="new">Used to associate, or bind, a name to a value or function.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLetBang">
        <source>Used in asynchronous workflows to bind a name to the result of an asynchronous computation, or, in other computation expressions, used to bind a name to a result, which is of the computation type.</source>
        <target state="new">Used in asynchronous workflows to bind a name to the result of an asynchronous computation, or, in other computation expressions, used to bind a name to a result, which is of the computation type.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatch">
        <source>Used to branch by comparing a value to a pattern.</source>
        <target state="new">Used to branch by comparing a value to a pattern.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMember">
        <source>Used to declare a property or method in an object type.</source>
        <target state="new">Used to declare a property or method in an object type.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionModule">
        <source>Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</source>
        <target state="new">Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMutable">
        <source>Used to declare a variable, that is, a value that can be changed.</source>
        <target state="new">Used to declare a variable, that is, a value that can be changed.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNamespace">
        <source>Used to associate a name with a group of related types and modules, to logically separate it from other code.</source>
        <target state="new">Used to associate a name with a group of related types and modules, to logically separate it from other code.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNew">
        <source>Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.</source>
        <target state="new">Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNot">
        <source>Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</source>
        <target state="new">Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNull">
        <source>Indicates the absence of an object. Also used in generic parameter constraints.</source>
        <target state="new">Indicates the absence of an object. Also used in generic parameter constraints.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOf">
        <source>Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</source>
        <target state="new">Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOpen">
        <source>Used to make the contents of a namespace or module available without qualification.</source>
        <target state="new">Used to make the contents of a namespace or module available without qualification.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOr">
        <source>Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.</source>
        <target state="new">Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOverride">
        <source>Used to implement a version of an abstract or virtual method that differs from the base version.</source>
        <target state="new">Used to implement a version of an abstract or virtual method that differs from the base version.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPrivate">
        <source>Restricts access to a member to code in the same type or module.</source>
        <target state="new">Restricts access to a member to code in the same type or module.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPublic">
        <source>Allows access to a member from outside the type.</source>
        <target state="new">Allows access to a member from outside the type.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRec">
        <source>Used to indicate that a function is recursive.</source>
        <target state="new">Used to indicate that a function is recursive.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturn">
        <source>Used to indicate a value to provide as the result of a computation expression.</source>
        <target state="new">Used to indicate a value to provide as the result of a computation expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturnBang">
        <source>Used to indicate a computation expression that, when evaluated, provides the result of the containing computation expression.</source>
        <target state="new">Used to indicate a computation expression that, when evaluated, provides the result of the containing computation expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionSelect">
        <source>Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</source>
        <target state="new">Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStatic">
        <source>Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</source>
        <target state="new">Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStruct">
        <source>Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions.</source>
        <target state="new">Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionThen">
        <source>Used in conditional expressions. Also used to perform side effects after object construction.</source>
        <target state="new">Used in conditional expressions. Also used to perform side effects after object construction.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTo">
        <source>Used in for loops to indicate a range.</source>
        <target state="new">Used in for loops to indicate a range.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTry">
        <source>Used to introduce a block of code that might generate an exception. Used together with with or finally.</source>
        <target state="new">Used to introduce a block of code that might generate an exception. Used together with with or finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionType">
        <source>Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</source>
        <target state="new">Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUpcast">
        <source>Used to convert to a type that is higher in the inheritance chain.</source>
        <target state="new">Used to convert to a type that is higher in the inheritance chain.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUse">
        <source>Used instead of let for values that require Dispose to be called to free resources.</source>
        <target state="new">Used instead of let for values that require Dispose to be called to free resources.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUseBang">
        <source>Used instead of let! in asynchronous workflows and other computation expressions for values that require Dispose to be called to free resources.</source>
        <target state="new">Used instead of let! in asynchronous workflows and other computation expressions for values that require Dispose to be called to free resources.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVal">
        <source>Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</source>
        <target state="new">Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVoid">
        <source>Indicates the .NET void type. Used when interoperating with other .NET languages.</source>
        <target state="new">Indicates the .NET void type. Used when interoperating with other .NET languages.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhen">
        <source>Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.</source>
        <target state="new">Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhile">
        <source>Introduces a looping construct.</source>
        <target state="new">Introduces a looping construct.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWith">
        <source>Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</source>
        <target state="new">Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYield">
        <source>Used in a sequence expression to produce a value for a sequence.</source>
        <target state="new">Used in a sequence expression to produce a value for a sequence.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYieldBang">
        <source>Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</source>
        <target state="new">Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRightArrow">
        <source>In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions</source>
        <target state="new">In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLeftArrow">
        <source>Assigns a value to a variable.</source>
        <target state="new">Assigns a value to a variable.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionCast">
        <source>Converts a type to type that is higher in the hierarchy.</source>
        <target state="new">Converts a type to type that is higher in the hierarchy.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDynamicCast">
        <source>Converts a type to a type that is lower in the hierarchy.</source>
        <target state="new">Converts a type to a type that is lower in the hierarchy.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTypedQuotation">
        <source>Delimits a typed code quotation.</source>
        <target state="new">Delimits a typed code quotation.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUntypedQuotation">
        <source>Delimits a untyped code quotation.</source>
        <target state="new">Delimits a untyped code quotation.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundDuringDynamicCodeGen">
        <source>{0} '{1}' not found in assembly '{2}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="new">{0} '{1}' not found in assembly '{2}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundInTypeDuringDynamicCodeGen">
        <source>{0} '{1}' not found in type '{2}' from assembly '{3}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="new">{0} '{1}' not found in type '{2}' from assembly '{3}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionWordIs">
        <source>is</source>
        <target state="new">is</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunction">
        <source>This value is not a function and cannot be applied.</source>
        <target state="new">This value is not a function and cannot be applied.</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexerWithName">
        <source>This value is not a function and cannot be applied. Did you intend to access the indexer via {0}.[index] instead?</source>
        <target state="new">This value is not a function and cannot be applied. Did you intend to access the indexer via {0}.[index] instead?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexer">
        <source>This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?</source>
        <target state="new">This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeDeclaration">
        <source>This value is not a function and cannot be applied. Did you forget to terminate a declaration?</source>
        <target state="new">This value is not a function and cannot be applied. Did you forget to terminate a declaration?</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentsInSigAndImplMismatch">
        <source>The argument names in the signature '{0}' and implementation '{1}' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling.</source>
        <target state="new">The argument names in the signature '{0}' and implementation '{1}' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleUnexpectedNonZero">
        <source>An error occurred while reading the F# metadata of assembly '{0}'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct.</source>
        <target state="new">An error occurred while reading the F# metadata of assembly '{0}'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleMemberNotNormallyUsed">
        <source>This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.</source>
        <target state="new">This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'.</source>
        <target state="new">This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedSequenceInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'.</source>
        <target state="new">This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatchBang">
        <source>Used in computation expressions to pattern match directly over the result of another computation expression.</source>
        <target state="new">Used in computation expressions to pattern match directly over the result of another computation expression.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilreadFileChanged">
        <source>The file '{0}' changed on disk unexpectedly, please reload.</source>
        <target state="new">The file '{0}' changed on disk unexpectedly, please reload.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>