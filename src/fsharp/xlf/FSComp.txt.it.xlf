<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="it" original="../FSComp.resx">
    <body>
      <trans-unit id="chkFeatureNotLanguageSupported">
        <source>Feature '{0}' is not available in F# {1}. Please use language version {2} or greater.</source>
        <target state="translated">La funzionalità '{0}' non è disponibile in F# {1}. Usare la versione {2} o versioni successive del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFeatureNotRuntimeSupported">
        <source>Feature '{0}' is not supported by target runtime.</source>
        <target state="translated">La funzionalità '{0}' non è supportata dal runtime di destinazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFeatureNotSupportedInLibrary">
        <source>Feature '{0}' requires the F# library for language version {1} or greater.</source>
        <target state="translated">Con la funzionalità '{0}' è richiesta la libreria F# per la versione {1} o successiva del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="csAvailableOverloads">
        <source>Available overloads:\n{0}</source>
        <target state="translated">Overload disponibili:\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructOrReferenceConstraint">
        <source>A generic construct requires that a generic type parameter be known as a struct or reference type. Consider adding a type annotation.</source>
        <target state="translated">Un costrutto generico richiede che un parametro di tipo generico sia noto come tipo riferimento o struct. Provare ad aggiungere un'annotazione di tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundArgumentsPrefixPlural">
        <source>Known types of arguments: {0}</source>
        <target state="translated">Tipi di argomenti noti: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundArgumentsPrefixSingular">
        <source>Known type of argument: {0}</source>
        <target state="translated">Tipo di argomento noto: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundReturnType">
        <source>Known return type: {0}</source>
        <target state="translated">Tipo restituito noto: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundTypeParametersPrefixPlural">
        <source>Known type parameters: {0}</source>
        <target state="translated">Parametri di tipo noti: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundTypeParametersPrefixSingular">
        <source>Known type parameter: {0}</source>
        <target state="translated">Parametro di tipo noto: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csOverloadCandidateIndexedArgumentTypeMismatch">
        <source>Argument at index {0} doesn't match</source>
        <target state="translated">L'argomento alla posizione di indice {0} non corrisponde</target>
        <note />
      </trans-unit>
      <trans-unit id="csOverloadCandidateNamedArgumentTypeMismatch">
        <source>Argument '{0}' doesn't match</source>
        <target state="translated">L'argomento '{0}' non corrisponde</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasDesignerAssemblyDependency">
        <source>The type provider designer assembly '{0}' could not be loaded from folder '{1}' because a dependency was missing or could not loaded. All dependencies of the type provider designer assembly must be located in the same folder as that assembly. The exception reported was: {2} - {3}</source>
        <target state="translated">Non è stato possibile caricare l'assembly '{0}' della finestra di progettazione del provider di tipi dalla cartella '{1}' perché una dipendenza non è presente o non è stato possibile caricarla. Tutte le dipendenze dell'assembly della finestra di progettazione del provider di tipi devono trovarsi nella stessa cartella dell'assembly. L'eccezione restituita è {2} - {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasDesignerAssemblyException">
        <source>The type provider designer assembly '{0}' could not be loaded from folder '{1}'. The exception reported was: {2} - {3}</source>
        <target state="translated">Non è stato possibile caricare l'assembly '{0}' della finestra di progettazione del provider di tipi dalla cartella '{1}'. L'eccezione restituita è {2} - {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssemblyNoPath">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded or doesn't exist. The exception reported was: {2} - {3}</source>
        <target state="translated">L'attributo di assembly '{0}' fa riferimento a un assembly '{1}' della finestra di progettazione che non è stato caricato o non esiste. L'eccezione restituita è {2} - {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="featureAndBang">
        <source>applicative computation expressions</source>
        <target state="translated">espressioni di calcolo applicativo</target>
        <note />
      </trans-unit>
      <trans-unit id="featureDefaultInterfaceMemberConsumption">
        <source>default interface member consumption</source>
        <target state="translated">utilizzo predefinito dei membri di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="featureDotlessFloat32Literal">
        <source>dotless float32 literal</source>
        <target state="translated">valore letterale float32 senza punti</target>
        <note />
      </trans-unit>
      <trans-unit id="featureExpandedMeasurables">
        <source>more types support units of measure</source>
        <target state="new">more types support units of measure</target>
        <note />
      </trans-unit>
      <trans-unit id="featureFixedIndexSlice3d4d">
        <source>fixed-index slice 3d/4d</source>
        <target state="translated">sezione a indice fisso 3D/4D</target>
        <note />
      </trans-unit>
      <trans-unit id="featureFromEndSlicing">
        <source>from-end slicing</source>
        <target state="translated">sezionamento dalla fine</target>
        <note />
      </trans-unit>
      <trans-unit id="featureImplicitYield">
        <source>implicit yield</source>
        <target state="translated">istruzione yield implicita</target>
        <note />
      </trans-unit>
      <trans-unit id="featureInterfacesWithMultipleGenericInstantiation">
        <source>interfaces with multiple generic instantiation</source>
        <target state="translated">interfacce con più creazioni di istanze generiche</target>
        <note />
      </trans-unit>
      <trans-unit id="featureNameOf">
        <source>nameof</source>
        <target state="translated">nameof</target>
        <note />
      </trans-unit>
      <trans-unit id="featureNullableOptionalInterop">
        <source>nullable optional interop</source>
        <target state="translated">Interop facoltativo nullable</target>
        <note />
      </trans-unit>
      <trans-unit id="featureOpenTypeDeclaration">
        <source>open type declaration</source>
        <target state="translated">dichiarazione di tipo aperto</target>
        <note />
      </trans-unit>
      <trans-unit id="featureOverloadsForCustomOperations">
        <source>overloads for custom operations</source>
        <target state="translated">overload per le operazioni personalizzate</target>
        <note />
      </trans-unit>
      <trans-unit id="featurePackageManagement">
        <source>package management</source>
        <target state="translated">gestione pacchetti</target>
        <note />
      </trans-unit>
      <trans-unit id="featureRelaxWhitespace">
        <source>whitespace relexation</source>
        <target state="translated">uso meno restrittivo degli spazi vuoti</target>
        <note />
      </trans-unit>
      <trans-unit id="featureSingleUnderscorePattern">
        <source>single underscore pattern</source>
        <target state="translated">criterio per carattere di sottolineatura singolo</target>
        <note />
      </trans-unit>
      <trans-unit id="featureStringInterpolation">
        <source>string interpolation</source>
        <target state="translated">interpolazione di stringhe</target>
        <note />
      </trans-unit>
      <trans-unit id="featureWildCardInForLoop">
        <source>wild card in for loop</source>
        <target state="translated">carattere jolly nel ciclo for</target>
        <note />
      </trans-unit>
      <trans-unit id="featureWitnessPassing">
        <source>witness passing for trait constraints in F# quotations</source>
        <target state="translated">Passaggio del testimone per vincoli di tratto in quotation F#</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated">
        <source>Interpolated strings may not use '%' format specifiers unless each is given an expression, e.g. '%d{{1+1}}'.</source>
        <target state="translated">Nelle stringhe interpolate non è possibile usare gli identificatori di formato '%' a meno che non si indichi un'espressione per ognuno di essi, ad esempio '%d{{1+1}}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated2">
        <source>.NET-style format specifiers such as '{{x,3}}' or '{{x:N5}}' may not be mixed with '%' format specifiers.</source>
        <target state="translated">Non è possibile combinare gli identificatori di formato di tipo .NET, come '{{x,3}}' o '{{x:N5}}', con gli identificatori di formato '%'.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated3">
        <source>The '%P' specifier may not be used explicitly.</source>
        <target state="translated">Non è possibile usare in modo esplicito l'identificatore '%P'.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated4">
        <source>Interpolated strings used as type IFormattable or type FormattableString may not use '%' specifiers, only .NET-style interpolands such as '{{expr}}', '{{expr,3}}' or '{{expr:N5}}' may be used.</source>
        <target state="translated">Nelle stringhe interpolate usate come tipo IFormattable o FormattableString non è possibile usare gli identificatori '%', ma è possibile usare solo interpolanti di tipo .NET, come '{{expr}}', '{{expr,3}}' o '{{expr:N5}}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="formatDashItem">
        <source> - {0}</source>
        <target state="translated"> - {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="fromEndSlicingRequiresVFive">
        <source>From the end slicing with requires language version 5.0, use /langversion:preview.</source>
        <target state="translated">Con il sezionamento dalla fine è richiesta la versione 5.0 del linguaggio. Usare /langversion:preview.</target>
        <note />
      </trans-unit>
      <trans-unit id="fsiInvalidDirective">
        <source>Invalid directive '#{0} {1}'</source>
        <target state="translated">Direttiva '#{0} {1}' non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionConst">
        <source>Keyword to specify a constant literal as a type parameter argument in Type Providers.</source>
        <target state="translated">Parola chiave per specificare un valore letterale di costante come argomento del parametro di tipo in Provider di tipi.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteStringMayNotBeInterpolated">
        <source>a byte string may not be interpolated</source>
        <target state="translated">non è possibile interpolare una stringa di byte</target>
        <note />
      </trans-unit>
      <trans-unit id="lexRBraceInInterpolatedString">
        <source>A '}}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">In una stringa interpolata è necessario specificare il carattere di escape di un carattere '}}' raddoppiandolo.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexSingleQuoteInSingleQuote">
        <source>Invalid interpolated string. Single quote or verbatim string literals may not be used in interpolated expressions in single quote or verbatim strings. Consider using an explicit 'let' binding for the interpolation expression or use a triple quote string as the outer string literal.</source>
        <target state="translated">La stringa interpolata non è valida. Non è possibile usare valori letterali stringa tra virgolette singole o verbatim in espressioni interpolate in stringhe verbatim o tra virgolette singole. Provare a usare un binding 'let' esplicito per l'espressione di interpolazione oppure usare una stringa tra virgolette triple come valore letterale stringa esterno.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTripleQuoteInTripleQuote">
        <source>Invalid interpolated string. Triple quote string literals may not be used in interpolated expressions. Consider using an explicit 'let' binding for the interpolation expression.</source>
        <target state="translated">La stringa interpolata non è valida. Non è possibile usare valori letterali stringa tra virgolette triple in espressioni interpolate. Provare a usare un binding 'let' esplicito per l'espressione di interpolazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="nativeResourceFormatError">
        <source>Stream does not begin with a null resource and is not in '.RES' format.</source>
        <target state="translated">Il flusso non inizia con una risorsa Null e non è in formato '.RES'.</target>
        <note />
      </trans-unit>
      <trans-unit id="nativeResourceHeaderMalformed">
        <source>Resource header beginning at offset {0} is malformed.</source>
        <target state="translated">L'intestazione di risorsa che inizia a partire dall'offset {0} non è valida.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLangVersion">
        <source>Display the allowed values for language version, specify language version such as 'latest' or 'preview'</source>
        <target state="translated">Visualizza i valori consentiti per la versione del linguaggio. Specificare la versione del linguaggio, ad esempio 'latest' o 'preview'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSupportedLangVersions">
        <source>Supported language versions:</source>
        <target state="translated">Versioni del linguaggio supportate:</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedLanguageVersion">
        <source>Unrecognized value '{0}' for --langversion use --langversion:? for complete list</source>
        <target state="translated">Valore '{0}' non riconosciuto per --langversion. Per l'elenco completo usare --langversion:?</target>
        <note />
      </trans-unit>
      <trans-unit id="optsVersion">
        <source>Display compiler version banner and exit</source>
        <target state="new">Display compiler version banner and exit</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagementRequiresVFive">
        <source>The package management feature requires language version 5.0 use /langversion:preview</source>
        <target state="translated">Con la funzionalità di gestione pacchetti è richiesta la versione 5.0 del linguaggio. Usare /langversion:preview</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyFillInInterpolatedString">
        <source>Invalid interpolated string. This interpolated string expression fill is empty, an expression was expected.</source>
        <target state="translated">La stringa interpolata non è valida. Il riempimento espressione di questa stringa interpolata è vuoto, mentre era prevista un'espressione.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedString">
        <source>Incomplete interpolated string begun at or before here</source>
        <target state="translated">La stringa interpolata incompleta inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedStringFill">
        <source>Incomplete interpolated string expression fill begun at or before here</source>
        <target state="translated">Il riempimento espressione della stringa interpolata incompleta inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedTripleQuoteString">
        <source>Incomplete interpolated triple-quote string begun at or before here</source>
        <target state="translated">La stringa interpolata incompleta tra virgolette triple inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedVerbatimString">
        <source>Incomplete interpolated verbatim string begun at or before here</source>
        <target state="translated">La stringa verbatim interpolata incompleta inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEqualsMissingInTypeDefinition">
        <source>Unexpected token in type definition. Expected '=' after the type '{0}'.</source>
        <target state="new">Unexpected token in type definition. Expected '=' after the type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolDot">
        <source>Unexpected symbol '.' in member definition. Expected 'with', '=' or other token.</source>
        <target state="translated">Simbolo '.' imprevisto nella definizione di membro. È previsto 'with', '=' o un altro token.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecksumAlgorithm">
        <source>Specify algorithm for calculating source file checksum stored in PDB. Supported values are: SHA1 or SHA256 (default)</source>
        <target state="translated">Consente di specificare l'algoritmo per calcolare il checksum del file di origine archiviato nel file PDB. I valori supportati sono SHA1 e SHA256 (predefinito).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">L'algoritmo '{0}' non è supportato</target>
        <note />
      </trans-unit>
      <trans-unit id="poundiNotSupportedByRegisteredDependencyManagers">
        <source>#i is not supported by the registered PackageManagers</source>
        <target state="translated">#i non è supportato dagli elementi PackageManager registrati</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAndBangNotSupported">
        <source>This feature is not supported in this version of F#. You may need to add /langversion:preview to use this feature.</source>
        <target state="translated">Questa funzionalità non è supportata in questa versione di F#. Per usare questa funzionalità, potrebbe essere necessario aggiungere /langversion:preview.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameDifferent">
        <source>This is the wrong anonymous record. It should have the fields {0}.</source>
        <target state="translated">Si tratta del record anonimo errato. Deve includere i campi {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameSubset">
        <source>This anonymous record does not have enough fields. Add the missing fields {0}.</source>
        <target state="translated">Questo record anonimo non contiene un numero sufficiente di campi. Aggiungere i campi mancanti {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameSuperset">
        <source>This anonymous record has too many fields. Remove the extra fields {0}.</source>
        <target state="translated">Questo record anonimo contiene troppi campi. Rimuovere i campi aggiuntivi {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdInvalid">
        <source>Invalid Anonymous Record type declaration.</source>
        <target state="translated">La dichiarazione di tipo Record anonimo non è valida.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAugmentationsCannotHaveAttributes">
        <source>Attributes cannot be applied to type extensions.</source>
        <target state="translated">Gli attributi non possono essere applicati a estensioni di tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalByrefsInOpenTypeDeclaration">
        <source>Byref types are not allowed in an open type declaration.</source>
        <target state="translated">I tipi byref non sono consentiti in una dichiarazione di tipo aperto.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterpolationMixedWithPercent">
        <source>Mismatch in interpolated string. Interpolated strings may not use '%' format specifiers unless each is given an expression, e.g. '%d{{1+1}}'</source>
        <target state="translated">Mancata corrispondenza nella stringa interpolata. Nelle stringhe interpolate non è possibile usare gli identificatori di formato '%' a meno che non si indichi un'espressione per ognuno di essi, ad esempio '%d{{1+1}}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAlignmentInInterpolatedString">
        <source>Invalid alignment in interpolated string</source>
        <target state="translated">Allineamento non valido nella stringa interpolata</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBindingNoAndBangs">
        <source>use! may not be combined with and!</source>
        <target state="translated">Non è possibile combinare use! con and!</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralFieldAssignmentNoArg">
        <source>Cannot assign a value to another value marked literal</source>
        <target state="translated">Non è possibile assegnare un valore a un altro valore contrassegnato come letterale</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralFieldAssignmentWithArg">
        <source>Cannot assign '{0}' to a value marked literal</source>
        <target state="translated">Non è possibile assegnare '{0}' a un valore contrassegnato come letterale</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireMergeSourcesOrBindN">
        <source>The 'let! ... and! ...' construct may only be used if the computation expression builder defines either a '{0}' method or appropriate 'MergeSource' and 'Bind' methods</source>
        <target state="translated">È possibile usare il costrutto 'let! ... and! ...' solo se il generatore di espressioni di calcolo definisce un metodo '{0}' o metodi 'MergeSource' e 'Bind' appropriati</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseInterpolatedString">
        <source>Invalid interpolated string. {0}</source>
        <target state="translated">La stringa interpolata non è valida. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceMemberNoMostSpecificImplementation">
        <source>Interface member '{0}' does not have a most specific implementation.</source>
        <target state="translated">Il membro di interfaccia '{0}' non contiene un'implementazione più specifica.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceWithConcreteAndVariable">
        <source>'{0}' cannot implement the interface '{1}' with the two instantiations '{2}' and '{3}' because they may unify.</source>
        <target state="translated">'{0}' non può implementare l'interfaccia '{1}' con le due creazioni di istanze '{2}' e '{3}' perché possono essere unificate.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceWithConcreteAndVariableObjectExpression">
        <source>You cannot implement the interface '{0}' with the two instantiations '{1}' and '{2}' because they may unify.</source>
        <target state="translated">Non è possibile implementare l'interfaccia '{0}' con le due creazioni di istanze '{1}' e '{2}' perché possono essere unificate.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMemberWhenTypeIsKnown">
        <source>The type '{0}' does not define the field, constructor or member '{1}'.</source>
        <target state="translated">Il tipo '{0}' non definisce il campo, il costruttore o il membro '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespace">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">Lo spazio dei nomi '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespaceOrModule">
        <source>The namespace or module '{0}' is not defined.</source>
        <target state="translated">Lo spazio dei nomi o il modulo '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMember">
        <source>The field, constructor or member '{0}' is not defined.</source>
        <target state="translated">Il campo, il costruttore o il membro '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueConstructorNamespaceOrType">
        <source>The value, constructor, namespace or type '{0}' is not defined.</source>
        <target state="translated">Il valore, il costruttore, lo spazio dei nomi o il tipo '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueOfConstructor">
        <source>The value or constructor '{0}' is not defined.</source>
        <target state="translated">Il valore o il costruttore '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueNamespaceTypeOrModule">
        <source>The value, namespace, type or module '{0}' is not defined.</source>
        <target state="translated">Il valore, lo spazio dei nomi, il tipo o il modulo '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameConstructorModuleOrNamespace">
        <source>The constructor, module or namespace '{0}' is not defined.</source>
        <target state="translated">Il costruttore, il modulo o lo spazio dei nomi '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameType">
        <source>The type '{0}' is not defined.</source>
        <target state="translated">Il tipo '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeIn">
        <source>The type '{0}' is not defined in '{1}'.</source>
        <target state="translated">Il tipo '{0}' non è definito in '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabelOrNamespace">
        <source>The record label or namespace '{0}' is not defined.</source>
        <target state="translated">L'etichetta record o lo spazio dei nomi '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabel">
        <source>The record label '{0}' is not defined.</source>
        <target state="translated">L'etichetta del record '{0}' non è definita.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameSuggestionsIntro">
        <source>Maybe you want one of the following:</source>
        <target state="translated">Si può specificare uno dei nomi seguenti:</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeParameter">
        <source>The type parameter {0} is not defined.</source>
        <target state="translated">Il parametro di tipo '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNamePatternDiscriminator">
        <source>The pattern discriminator '{0}' is not defined.</source>
        <target state="translated">Il discriminatore di criteri '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="replaceWithSuggestion">
        <source>Replace with '{0}'</source>
        <target state="translated">Sostituisci con '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="addIndexerDot">
        <source>Add . for indexer access.</source>
        <target state="translated">Aggiunge . per l'accesso all'indicizzatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="listElementHasWrongType">
        <source>All elements of a list must be of the same type as the first element, which here is '{0}'. This element has type '{1}'.</source>
        <target state="translated">Il tipo di tutti gli elementi di un'espressione di costruttore di elenco deve essere lo stesso. Il tipo previsto di questa espressione è '{0}', ma quello effettivo è '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="arrayElementHasWrongType">
        <source>All elements of an array must be of the same type as the first element, which here is '{0}'. This element has type '{1}'.</source>
        <target state="translated">Il tipo di tutti gli elementi di un'espressione di costruttore di matrice deve essere lo stesso. Il tipo previsto di questa espressione è '{0}', ma quello effettivo è '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="missingElseBranch">
        <source>This 'if' expression is missing an 'else' branch. Because 'if' is an expression, and not a statement, add an 'else' branch which also returns a value of type '{0}'.</source>
        <target state="translated">Nell'espressione 'if' manca un ramo 'else'. Il tipo del ramo 'then' è '{0}'. Dal momento che 'if' è un'espressione e non un'istruzione, aggiungere un ramo 'else' che restituisca un valore dello stesso tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ifExpression">
        <source>The 'if' expression needs to have type '{0}' to satisfy context type requirements. It currently has type '{1}'.</source>
        <target state="translated">Per soddisfare i requisiti relativi al tipo di contesto, il tipo dell'espressione 'if' deve essere '{0}', ma è attualmente '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="elseBranchHasWrongType">
        <source>All branches of an 'if' expression must return values of the same type as the first branch, which here is '{0}'. This branch returns a value of type '{1}'.</source>
        <target state="translated">Il tipo di tutti i rami di un'espressione 'if' deve essere lo stesso. Il tipo previsto di questa espressione è '{0}', ma quello effettivo è '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="followingPatternMatchClauseHasWrongType">
        <source>All branches of a pattern match expression must return values of the same type as the first branch, which here is '{0}'. This branch returns a value of type '{1}'.</source>
        <target state="translated">Tutti i rami di un'espressione di criteri di ricerca devono restituire valori dello stesso tipo. Il primo ramo ha restituito un valore di tipo '{0}', ma questo ramo ha restituito un valore di tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="patternMatchGuardIsNotBool">
        <source>A pattern match guard must be of type 'bool', but this 'when' expression is of type '{0}'.</source>
        <target state="translated">Il guard dei criteri di ricerca deve essere di tipo 'bool', ma questa espressione 'when' è di tipo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="commaInsteadOfSemicolonInRecord">
        <source>A ';' is used to separate field values in records. Consider replacing ',' with ';'.</source>
        <target state="translated">Per separare i valori di campo nei record si usa il punto e virgola (';'). Provare a sostituire la virgola (',') con il punto e virgola (';').</target>
        <note />
      </trans-unit>
      <trans-unit id="derefInsteadOfNot">
        <source>The '!' operator is used to dereference a ref cell. Consider using 'not expr' here.</source>
        <target state="translated">L'operatore '!' viene usato per dereferenziare una cella di riferimento. In questo punto provare a usare 'not expr'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedTypeArgs">
        <source>The non-generic type '{0}' does not expect any type arguments, but here is given {1} type argument(s)</source>
        <target state="translated">Il tipo non generico '{0}' non prevede alcun argomento tipo, tuttavia è stata rilevata la presenza di {1} argomento/i tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="returnUsedInsteadOfReturnBang">
        <source>Consider using 'return!' instead of 'return'.</source>
        <target state="translated">Provare a usare 'return!' invece di 'return'.</target>
        <note />
      </trans-unit>
      <trans-unit id="useSdkRefs">
        <source>Use reference assemblies for .NET framework references when available (Enabled by default).</source>
        <target state="translated">Usa gli assembly di riferimento per i riferimenti a .NET Framework quando disponibili (abilitato per impostazione predefinita).</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocBadlyFormed">
        <source>This XML comment is invalid: '{0}'</source>
        <target state="translated">Questo commento XML non è valido: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocDuplicateParameter">
        <source>This XML comment is invalid: multiple documentation entries for parameter '{0}'</source>
        <target state="translated">Questo commento XML non è valido: sono presenti più voci della documentazione per il parametro '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocInvalidParameterName">
        <source>This XML comment is invalid: unknown parameter '{0}'</source>
        <target state="translated">Questo commento XML non è valido: il parametro '{0}' è sconosciuto</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingCrossReference">
        <source>This XML comment is invalid: missing 'cref' attribute for cross-reference</source>
        <target state="translated">Questo commento XML non è valido: manca l'attributo 'cref' per il riferimento incrociato</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingParameter">
        <source>This XML comment is incomplete: no documentation for parameter '{0}'</source>
        <target state="translated">Questo commento XML è incompleto: non è presente la documentazione per il parametro '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingParameterName">
        <source>This XML comment is invalid: missing 'name' attribute for parameter or parameter reference</source>
        <target state="translated">Questo commento XML non è valido: manca l'attributo 'name' per il parametro o il riferimento a parametro</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocUnresolvedCrossReference">
        <source>This XML comment is invalid: unresolved cross-reference '{0}'</source>
        <target state="translated">Questo commento XML non è valido: il riferimento incrociato '{0}' non è stato risolto</target>
        <note />
      </trans-unit>
      <trans-unit id="yieldUsedInsteadOfYieldBang">
        <source>Consider using 'yield!' instead of 'yield'.</source>
        <target state="translated">Provare a usare 'yield!' invece di 'yield'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tupleRequiredInAbstractMethod">
        <source>\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.</source>
        <target state="translated">\nPer uno o più argomenti è necessario un tipo di tupla. Provare a racchiudere gli argomenti specificati tra parentesi aggiuntive o a rivedere la definizione dell'interfaccia.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidWarningNumber">
        <source>Invalid warning number '{0}'</source>
        <target state="translated">Numero di avviso '{0}' non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionString">
        <source>Invalid version string '{0}'</source>
        <target state="translated">Stringa di versione '{0}' non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionFile">
        <source>Invalid version file '{0}'</source>
        <target state="translated">File di versione '{0}' non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemWithFilename">
        <source>Problem with filename '{0}': {1}</source>
        <target state="translated">Problema con il nome di file '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildNoInputsSpecified">
        <source>No inputs specified</source>
        <target state="translated">Nessun input specificato</target>
        <note />
      </trans-unit>
      <trans-unit id="buildPdbRequiresDebug">
        <source>The '--pdb' option requires the '--debug' option to be used</source>
        <target state="translated">L'opzione '--pdb' richiede l'utilizzo dell'opzione '--debug'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSearchDirectory">
        <source>The search directory '{0}' is invalid</source>
        <target state="translated">Directory di ricerca '{0}' non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSearchDirectoryNotFound">
        <source>The search directory '{0}' could not be found</source>
        <target state="translated">La directory di ricerca '{0}' non è stata trovata</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidFilename">
        <source>'{0}' is not a valid filename</source>
        <target state="translated">'{0}' non è un nome di file valido</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidAssemblyName">
        <source>'{0}' is not a valid assembly name</source>
        <target state="translated">'{0}' non è un nome di assembly valido</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidPrivacy">
        <source>Unrecognized privacy setting '{0}' for managed resource, valid options are 'public' and 'private'</source>
        <target state="translated">Impostazione di privacy '{0}' non riconosciuta per una risorsa gestita. Le opzioni valide sono 'public' e 'private'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCannotReadAssembly">
        <source>Unable to read assembly '{0}'</source>
        <target state="translated">Non è possibile leggere l'assembly '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildAssemblyResolutionFailed">
        <source>Assembly resolution failure at or near this location</source>
        <target state="translated">Errore di risoluzione assembly in questa posizione o in prossimità di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplicitModuleIsNotLegalIdentifier">
        <source>The declarations in this file will be placed in an implicit module '{0}' based on the file name '{1}'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file.</source>
        <target state="translated">Le dichiarazioni presenti in questo file verranno inserite in un modulo implicito '{0}' in base al nome di file '{1}'. Questo non è tuttavia un identificatore F# valido, pertanto i contenuti non saranno accessibili da altri file. Provare a rinominare il file o ad aggiungere una dichiarazione 'module' o 'namespace' all'inizio del file.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultiFileRequiresNamespaceOrModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration.</source>
        <target state="translated">I file delle librerie o delle applicazioni con più file devono iniziare con una dichiarazione di spazio dei nomi o di modulo, ad esempio 'namespace SomeNamespace.SubNamespace' o 'module SomeNamespace.SomeModule'. Solo l'ultimo file di origine di un'applicazione può omettere tale dichiarazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="noEqualSignAfterModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.</source>
        <target state="translated">I file in librerie o in applicazioni con più file devono iniziare con una dichiarazione di modulo o di spazio dei nomi. Quando si usa una dichiarazione di modulo all'inizio del file, il segno '=' non è consentito. Se questo è un modulo di primo livello, provare a rimuovere il segno = per risolvere l'errore.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleToplevelModules">
        <source>This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules.</source>
        <target state="translated">Il file contiene più dichiarazioni nel formato 'module SpazioNomi.Modulo'. In un file è consentita una sola dichiarazione di questo tipo. Modificare il file in modo che utilizzi una dichiarazione di spazio dei nomi iniziale e/o 'module NomeModulo = ...' per definire i moduli.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildOptionRequiresParameter">
        <source>Option requires parameter: {0}</source>
        <target state="translated">Parametro necessario per l'opzione: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotFindSourceFile">
        <source>Source file '{0}' could not be found</source>
        <target state="translated">Il file di origine '{0}' non è stato trovato</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSourceFileExtension">
        <source>The file extension of '{0}' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.</source>
        <target state="translated">Estensione di file di '{0}' non riconosciuta. I file di origine devono avere estensione .fs, .fsi, .fsx, .fsscript, .ml o .mli.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssembly">
        <source>Could not resolve assembly '{0}'</source>
        <target state="translated">Non è stato possibile risolvere l'assembly '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssemblyRequiredByFile">
        <source>Could not resolve assembly '{0}' required by '{1}'</source>
        <target state="translated">Non è stato possibile risolvere l'assembly '{0}' richiesto da '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildErrorOpeningBinaryFile">
        <source>Error opening binary file '{0}': {1}</source>
        <target state="translated">Errore durante l'apertura del file binario '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDifferentVersionMustRecompile">
        <source>The F#-compiled DLL '{0}' needs to be recompiled to be used with this version of F#</source>
        <target state="translated">È necessario ricompilare la DLL compilata in F# '{0}' per poterla utilizzare con questa versione di F#</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashIDirective">
        <source>Invalid directive. Expected '#I \"&lt;path&gt;\"'.</source>
        <target state="translated">Direttiva non valida. È previsto '#I \"&lt;percorso&gt;\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashrDirective">
        <source>Invalid directive. Expected '#r \"&lt;file-or-assembly&gt;\"'.</source>
        <target state="translated">Direttiva non valida. È previsto '#r \"&lt;file-oppure-assembly&gt;\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashloadDirective">
        <source>Invalid directive. Expected '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</source>
        <target state="translated">Direttiva non valida. È previsto '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashtimeDirective">
        <source>Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'.</source>
        <target state="translated">Direttiva non valida. Previsto '#time', '#time \"on\"' o '#time \"off\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDirectivesInModulesAreIgnored">
        <source>Directives inside modules are ignored</source>
        <target state="translated">Le direttive all'interno dei moduli vengono ignorate</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureAlreadySpecified">
        <source>A signature for the file or module '{0}' has already been specified</source>
        <target state="translated">È già stata specificata una firma per il file o modulo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGivenDetail">
        <source>An implementation of file or module '{0}' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.</source>
        <target state="translated">È già stata specificata un'implementazione del file o modulo '{0}'. In F# l'ordine di compilazione è significativo a causa dell'inferenza del tipo. Potrebbe essere necessario modificare l'ordine dei file per inserire il file di firma prima dell'implementazione. In Visual Studio il controllo del tipo viene eseguito nei file nell'ordine in cui questi ultimi sono inclusi nel file di progetto. Tale ordine può essere modificato manualmente oppure tramite Esplora soluzioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGiven">
        <source>An implementation of the file or module '{0}' has already been given</source>
        <target state="translated">È già stata specificata un'implementazione del file o modulo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureWithoutImplementation">
        <source>The signature file '{0}' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match.</source>
        <target state="translated">Il file di firma '{0}' non dispone di un file di implementazione corrispondente. Se è disponibile un file di implementazione, verificare che le dichiarazioni 'module' e 'namespace' nei file di firma e di implementazione corrispondano.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidInt">
        <source>'{0}' is not a valid integer argument</source>
        <target state="translated">'{0}' non è un argomento Integer valido</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidFloat">
        <source>'{0}' is not a valid floating point argument</source>
        <target state="translated">'{0}' non è un argomento a virgola mobile valido</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnrecognizedOption">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">Opzione non riconosciuta: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidModuleOrNamespaceName">
        <source>Invalid module or namespace name</source>
        <target state="translated">Nome di modulo o spazio dei nomi non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleErrorReadingWritingMetadata">
        <source>Error reading/writing metadata for the F# compiled DLL '{0}'. Was the DLL compiled with an earlier version of the F# compiler? (error: '{1}').</source>
        <target state="translated">Errore durante la lettura/scrittura di metadati per la DLL F# compilata '{0}'. Verificare se la DLL è stata compilata con una versione precedente del compilatore F#. Errore: '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeOrModuleNotConcrete">
        <source>The type/module '{0}' is not a concrete module or type</source>
        <target state="translated">Il tipo/modulo '{0}' non è un modulo o un tipo concreto</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeHasAssemblyCodeRepresentation">
        <source>The type '{0}' has an inline assembly code representation</source>
        <target state="translated">Il tipo '{0}' contiene una rappresentazione di codice assembly inline</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNamespaceAndModuleWithSameNameInAssembly">
        <source>A namespace and a module named '{0}' both occur in two parts of this assembly</source>
        <target state="translated">In due parti di questo assembly sono presenti uno spazio dei nomi e un modulo entrambi denominati '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTwoModulesWithSameNameInAssembly">
        <source>Two modules named '{0}' occur in two parts of this assembly</source>
        <target state="translated">Due moduli con nome '{0}' sono presenti in due parti dell'assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="tastDuplicateTypeDefinitionInAssembly">
        <source>Two type definitions named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">Due definizioni di tipo con nome '{0}' nello spazio dei nomi '{1}' sono presenti in due parti dell'assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConflictingModuleAndTypeDefinitionInAssembly">
        <source>A module and a type definition named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">Modulo e definizione di tipo con nome '{0}' nello spazio dei nomi '{1}' presenti in due parti dell'assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMemberSignature">
        <source>Invalid member signature encountered because of an earlier error</source>
        <target state="translated">Rilevata firma di membro non valida a causa di un errore precedente</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueDoesNotHaveSetterType">
        <source>This value does not have a valid property setter type</source>
        <target state="translated">Questo valore non contiene un tipo di setter di proprietà valido</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertyGetter">
        <source>Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax.</source>
        <target state="translated">Formato non valido per un getter di proprietà. Quando si usa la sintassi esplicita, è necessario almeno un argomento '()'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertySetter">
        <source>Invalid form for a property setter. At least one argument is required.</source>
        <target state="translated">Formato non valido per un setter di proprietà. È necessario almeno un argomento.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedByRef">
        <source>Unexpected use of a byref-typed variable</source>
        <target state="translated">Utilizzo non previsto di una variabile di tipo byref</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMutationOfConstant">
        <source>Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'.</source>
        <target state="translated">Modifica non valida di un'espressione costante. Provare a copiare l'espressione in un locale modificabile, ad esempio 'let mutable x = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueHasBeenCopied">
        <source>The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed</source>
        <target state="translated">Il valore è stato copiato per assicurare che durante l'operazione l'originale non venga modificato</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeInConstructionOfTuple">
        <source>Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding</source>
        <target state="translated">I valori definiti in modo ricorsivo non possono rappresentare direttamente parte della costruzione di un valore di tupla in un binding ricorsivo</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotAppearInConstructionOfType">
        <source>Recursive values cannot appear directly as a construction of the type '{0}' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.</source>
        <target state="translated">I valori ricorsivi non possono rappresentare direttamente una costruzione del tipo '{0}' in un binding ricorsivo. Questa funzionalità è stata rimossa dal linguaggio F#. Provare a usare un record.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeAssignedToNonMutableField">
        <source>Recursive values cannot be directly assigned to the non-mutable field '{0}' of the type '{1}' within a recursive binding. Consider using a mutable field instead.</source>
        <target state="translated">I valori ricorsivi non possono essere assegnati direttamente al campo non modificabile '{0}' del tipo '{1}' in un binding ricorsivo. Provare a usare un campo modificabile.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfAutoOpenAttribute">
        <source>Unexpected decode of AutoOpenAttribute</source>
        <target state="translated">Decodifica non prevista di AutoOpenAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInternalsVisibleToAttribute">
        <source>Unexpected decode of InternalsVisibleToAttribute</source>
        <target state="translated">Decodifica non prevista di InternalsVisibleToAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
        <source>Unexpected decode of InterfaceDataVersionAttribute</source>
        <target state="translated">Decodifica non prevista di InterfaceDataVersionAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastActivePatternsLimitedToSeven">
        <source>Active patterns cannot return more than 7 possibilities</source>
        <target state="translated">I criteri attivi non possono restituire più di 7 possibilità</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNotAConstantExpression">
        <source>This is not a valid constant expression or custom attribute value</source>
        <target state="translated">L'elemento non è un'espressione costante o un valore di attributo personalizzato valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAttributesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe mutability attributes differ</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nGli attributi di modificabilità sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe names differ</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI nomi sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityCompiledNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled names differ</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI nomi compilati sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDisplayNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe display names differ</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI nomi visualizzati sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAccessibilityMore">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la firma specifica\n    {2}    \nL'accessibilità specificata nella firma è maggiore rispetto a quella specificata nell'implementazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInlineFlagsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe inline flags differ</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI flag inline sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityLiteralConstantValuesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe literal constant values and/or attributes differ</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI valori costanti letterali e/o gli attributi sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsTypeFunction">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è una funzione di tipo, l'altro no. La firma richiede parametri di tipo esplicito se questi sono presenti nell'implementazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityParameterCountsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe respective type parameter counts differ</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI rispettivi conteggi di parametri di tipo sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityTypesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe types differ</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI tipi sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityExtensionsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is an extension member and the other is not</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è un membro di estensione, l'altro no</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityArityNotInferred">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nAn arity was not inferred for this value</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nNon è stato dedotto un grado per questo valore</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe number of generic parameters in the signature and implementation differ (the signature declares {3} but the implementation declares {4}</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nIl numero di parametri generici nella firma e nell'implementazione è diverso (la firma dichiara {3}, mentre l'implementazione dichiara {4})</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersAreDifferentKinds">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \nma la relativa firma specifica\n    {2}    \nI parametri generici nella firma e nell'implementazione sono di tipo diverso. È possibile che manchi l'attributo [&lt;Measure&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAritiesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe arities in the signature and implementation differ. The signature specifies that '{3}' is function definition or lambda expression accepting at least {4} argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int.</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \nma la relativa firma specifica\n    {2}    \nI gradi nella firma e nell'implementazione sono diversi. La firma specifica che '{3}' è una definizione di funzione o un'espressione lambda che accetta un numero di argomenti almeno pari a {4}, tuttavia l'implementazione è un valore di funzione calcolato. Per dichiarare che un valore di funzione calcolato è un'implementazione consentita, è sufficiente racchiudere tra parentesi il relativo tipo nella firma, ad esempio\n\tval {5}: int -&gt; (int -&gt; int)\ninvece di\n\tval {6}: int -&gt; int -&gt; int.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDotNetNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe CLI member names differ</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI nomi dei membri CLI sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is static and the other isn't</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è statico, l'altro no</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityVirtualsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is virtual and the other isn't</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è virtuale, l'altro no</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAbstractsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is abstract and the other isn't</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è astratto, l'altro no</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityFinalsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is final and the other isn't</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è finale, l'altro no</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOverridesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is marked as an override and the other isn't</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è contrassegnato come override, l'altro no</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsConstructor">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a constructor/property and the other is not</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \nma la relativa firma specifica\n    {2}    \nUno è un costruttore o una proprietà, l'altro no</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticButInstance">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nLa rappresentazione compilata di questo metodo è un membro statico, tuttavia la firma indica che essa è un membro di istanza</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInstanceButStatic">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member</source>
        <target state="translated">Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nLa rappresentazione compilata di questo metodo è un membro di istanza, tuttavia la firma indica che essa è un membro statico</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNamesDiffer">
        <source>The {0} definitions in the signature and implementation are not compatible because the names differ. The type is called '{1}' in the signature file but '{2}' in implementation.</source>
        <target state="translated">Le definizioni di {0} nella firma e nell'implementazione non sono compatibili perché i nomi sono diversi. Il nome del tipo è '{1}' nel file della firma e '{2}' nell'implementazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché i rispettivi conteggi dei parametri di tipo sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché l'accessibilità specificata nella firma è maggiore rispetto a quella specificata nell'implementazione</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleMissingInterface">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature requires that the type supports the interface {2} but the interface has not been implemented</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché la firma richiede che il tipo supporti l'interfaccia {2}, ma quest'ultima non è stata implementata</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché in base all'implementazione questo tipo e non la firma può usare come rappresentazione valori Null</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché in base all'implementazione questo tipo e non la firma può usare come valore aggiuntivo valori Null</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché in base alla firma questo tipo e non l'implementazione può usare come rappresentazione valori Null</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché in base alla firma questo tipo e non l'implementazione può usare come valore aggiuntivo valori Null</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché il tipo di implementazione è sealed ma la firma implica che non lo sia. Provare ad aggiungere l'attributo [&lt;Sealed&gt;] alla firma.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché il tipo di implementazione non è sealed ma la firma implica che lo sia. Provare ad aggiungere l'attributo [&lt;Sealed&gt;] all'implementazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché, a differenza della firma, l'implementazione è una classe astratta. Provare ad aggiungere l'attributo [&lt;AbstractClass&gt;] alla firma.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché, a differenza dell'implementazione, la firma è una classe astratta. Provare ad aggiungere l'attributo [&lt;AbstractClass&gt;] all'implementazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types have different base types</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché i tipi hanno tipi di base diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNumbersDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the number of {2}s differ</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché il numero di elementi {2} è diverso</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature defines the {2} '{3}' but the implementation does not (or does, but not in the same order)</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché la firma definisce l'elemento {2} '{3}', il quale non è definito oppure è definito in un ordine diverso nell'implementazione</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines the {2} '{3}' but the signature does not (or does, but not in the same order)</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché l'implementazione definisce l'elemento {2} '{3}', il quale non è definito oppure è definito in un ordine diverso nella firma</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché l'implementazione definisce uno struct, ma la firma definisce un tipo con una rappresentazione nascosta</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché una rappresentazione di tipo CLI è nascosta da una firma</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a type representation is being hidden by a signature</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché una rappresentazione di tipo è nascosta da una firma</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types are of different kinds</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché i tipi sono di genere diverso</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleILDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the IL representations differ</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché le rappresentazioni IL sono diverse</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the representations differ</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché le rappresentazioni sono diverse</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldWasPresent">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was present in the implementation but not in the signature</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché il campo {2} è presente nell'implementazione ma non nella firma</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché l'ordine dei campi nella firma e nell'implementazione è diverso</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was required by the signature but was not specified by the implementation</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché per la firma è necessario il campo {2}, che però non è stato specificato dall'implementazione</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field '{2}' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'.</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché il campo '{2}' è presente nell'implementazione ma non nella firma. I tipi struct devono ora mostrare i relativi campi nella firma per il tipo, nonostante i campi possano comunque essere associati alle etichette 'private' o 'internal'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was required by the signature but was not specified by the implementation</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché per la firma è necessario il membro astratto '{2}', che però non è stato specificato dall'implementazione</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was present in the implementation but not in the signature</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché il membro astratto '{2}' è presente nell'implementazione ma non nella firma</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature declares a {2} while the implementation declares a {3}</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché la firma dichiara {2} mentre l'implementazione dichiara {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abbreviations differ: {2} versus {3}</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché le abbreviazioni sono diverse: {2} invece di {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché un'abbreviazione è nascosta da una firma. L'abbreviazione deve essere visibile ad altri linguaggi CLI. Provare a rendere visibile l'abbreviazione nella firma.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not</source>
        <target state="translated">Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché, a differenza dell'implementazione, la firma contiene un'abbreviazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButNamesDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">Il modulo contiene il costruttore\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI nomi sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButDataFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe respective number of data fields differ</source>
        <target state="translated">Il modulo contiene il costruttore\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI rispettivi numeri di campi dati sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButTypesOfFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe types of the fields differ</source>
        <target state="translated">Il modulo contiene il costruttore\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI tipi dei campi sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButAccessibilityDiffers">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Il modulo contiene il costruttore\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nL'accessibilità specificata nella firma è maggiore rispetto a quella specificata nell'implementazione</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedNamesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">Il modulo contiene il campo\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI nomi sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedAccessibilitiesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Il modulo contiene il campo\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nL'accessibilità specificata nella firma è maggiore rispetto a quella specificata nell'implementazione</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedStaticsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'static' modifiers differ</source>
        <target state="translated">Il modulo contiene il campo\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI modificatori 'static' sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedMutablesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'mutable' modifiers differ</source>
        <target state="translated">Il modulo contiene il campo\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI modificatori 'mutable' sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedLiteralsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'literal' modifiers differ</source>
        <target state="translated">Il modulo contiene il campo\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI modificatori 'literal' sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedTypesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe types differ</source>
        <target state="translated">Il modulo contiene il campo\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI tipi sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveImplicitGenericInstantiation">
        <source>The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '{0}' and '{1}'. Consider using type annotations to resolve the ambiguity</source>
        <target state="translated">Non è stato possibile risolvere la creazione di istanza implicita di un costrutto generico in questo punto o in prossimità di esso perché la risoluzione potrebbe restituire più tipi non correlati, ad esempio '{0}' e '{1}'. Provare a usare annotazioni di tipo per risolvere l'ambiguità</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInPrintf">
        <source>Could not resolve the ambiguity inherent in the use of a 'printf'-style format string</source>
        <target state="translated">Non è stato possibile risolvere l'ambiguità relativa all'uso della stringa di formato di stile 'printf'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInEnum">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position</source>
        <target state="translated">Non è stato possibile risolvere l'ambiguità relativa all'uso di un costrutto generico con un vincolo 'enum' in questa posizione o in prossimità di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInDelegate">
        <source>Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position</source>
        <target state="translated">Non è stato possibile risolvere l'ambiguità relativa all'uso di un costrutto generico con un vincolo 'delegate' in questa posizione o in prossimità di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInvalidValue">
        <source>Invalid value</source>
        <target state="translated">Valore non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleParamCountsDiffer">
        <source>The signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">La firma e l'implementazione non sono compatibili perché i rispettivi conteggi di parametri di tipo sono diversi</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
        <source>The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation</source>
        <target state="translated">La firma e l'implementazione non sono compatibili perché il parametro di tipo nella classe/firma ha un requisito della fase di compilazione diverso rispetto a quello nel membro/implementazione</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDiffer">
        <source>The signature and implementation are not compatible because the declaration of the type parameter '{0}' requires a constraint of the form {1}</source>
        <target state="translated">La firma e l'implementazione non sono compatibili perché la dichiarazione del parametro di tipo '{0}' richiede un vincolo nel formato {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDifferRemove">
        <source>The signature and implementation are not compatible because the type parameter '{0}' has a constraint of the form {1} but the implementation does not. Either remove this constraint from the signature or add it to the implementation.</source>
        <target state="translated">La firma e l'implementazione non sono compatibili perché il parametro di tipo '{0}' ha un vincolo nel formato {1} non presente tuttavia nell'implementazione. Rimuovere il vincolo dalla firma oppure aggiungerlo all'implementazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableShouldOverrideObjectEquals">
        <source>The type '{0}' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'</source>
        <target state="translated">Il tipo '{0}' implementa 'System.IComparable'. Provare inoltre ad aggiungere un override esplicito per 'Object.Equals'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableDefaultObjectEqualsProvided">
        <source>The type '{0}' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly</source>
        <target state="translated">Il tipo '{0}' implementa 'System.IComparable' in modo esplicito, tuttavia non fornisce l'override corrispondente per 'Object.Equals'. È stata specificata automaticamente un'implementazione di 'Object.Equals', eseguita tramite 'System.IComparable'. Provare a implementare l'override di 'Object.Equals' in modo esplicito</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCodeOrEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type</source>
        <target state="translated">Il tipo di unione, struct o record '{0}' ha un'implementazione esplicita di 'Object.GetHashCode' o 'Object.Equals'. È necessario applicare l'attributo 'CustomEquality' al tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCode">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'</source>
        <target state="translated">Il tipo di unione, struct o record '{0}' ha un'implementazione esplicita di 'Object.GetHashCode'. Provare a implementare un override corrispondente per 'Object.Equals(obj)'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'</source>
        <target state="translated">Il tipo di unione, struct o record '{0}' ha un'implementazione esplicita di 'Object.Equals'. Provare a implementare un override corrispondente per 'Object.GetHashCode()'</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleHiddenBySignature">
        <source>The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">Le definizioni di eccezione non sono compatibili perché un mapping delle eccezioni CLI è nascosto da una firma. Il mapping delle eccezioni deve essere visibile ad altri moduli. Il modulo contiene la definizione di eccezione\n    {0}    \ntuttavia la relativa firma specifica\n\t{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer">
        <source>The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">Le definizioni di eccezione non sono compatibili perché le rappresentazioni CLI sono diverse. Il modulo contiene la definizione di eccezione\n    {0}    \ntuttavia la relativa firma specifica\n\t{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature">
        <source>The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Le definizioni di eccezione non sono compatibili perché l'abbreviazione dell'eccezione è nascosta dalla firma. L'abbreviazione deve essere visibile ad altri linguaggi CLI. Provare a rendere visibile l'abbreviazione nella firma. Il modulo contiene la definizione di eccezione \n    {0}    \ntuttavia la relativa firma specifica\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleSignaturesDiffer">
        <source>The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Le definizioni di eccezione non sono compatibili perché le abbreviazioni delle eccezioni nella firma e nell'implementazione sono diverse. Il modulo contiene la definizione di eccezione\n    {0}    \ntuttavia la relativa firma specifica\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer">
        <source>The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Le definizioni di eccezione non sono compatibili perché le dichiarazioni di eccezione sono diverse. Il modulo contiene la definizione di eccezione\n    {0}    \ntuttavia la relativa firma specifica\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInSigButNotImpl">
        <source>The exception definitions are not compatible because the field '{0}' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">Le definizioni di eccezione non sono compatibili perché il campo '{0}' è necessario per la firma ma non è stato specificato dall'implementazione. Il modulo contiene la definizione di eccezione\n    {1}    \ntuttavia la relativa firma specifica\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInImplButNotSig">
        <source>The exception definitions are not compatible because the field '{0}' was present in the implementation but not in the signature. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">Le definizioni di eccezione non sono compatibili perché il campo '{0}' è presente nell'implementazione ma non nella firma. Il modulo contiene la definizione di eccezione\n    {1}    \ntuttavia la relativa firma specifica\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldOrderDiffers">
        <source>The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Le definizioni di eccezione non sono compatibili perché l'ordine dei campi nella firma e nell'implementazione è diverso. Il modulo contiene la definizione di eccezione\n    {0}    \ntuttavia la relativa firma specifica\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelModuleNamespaceAttributesDifferInSigAndImpl">
        <source>The namespace or module attributes differ between signature and implementation</source>
        <target state="translated">Gli attributi dello spazio dei nomi o del modulo sono diversi nella firma e nell'implementazione</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsOverconstrained">
        <source>This method is over-constrained in its type parameters</source>
        <target state="translated">Questo metodo contiene troppi vincoli nei relativi parametri di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverloadNotFound">
        <source>No implementations of '{0}' had the correct number of arguments and type parameters. The required signature is '{1}'.</source>
        <target state="translated">Nessuna implementazione di '{0}' dispone del numero di argomenti e parametri di tipo corretto. La firma necessaria è '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideWasAmbiguous">
        <source>The override for '{0}' was ambiguous</source>
        <target state="translated">L'override per '{0}' è ambiguo</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMoreThenOneOverride">
        <source>More than one override implements '{0}'</source>
        <target state="translated">Più override implementano '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsSealed">
        <source>The method '{0}' is sealed and cannot be overridden</source>
        <target state="translated">Il metodo '{0}' è Sealed e non è possibile eseguirne l'override</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideImplementsMoreThenOneSlot">
        <source>The override '{0}' implements more than one abstract slot, e.g. '{1}' and '{2}'</source>
        <target state="translated">L'override '{0}' implementa più slot astratti, ad esempio '{1}' e '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelDuplicateInterface">
        <source>Duplicate or redundant interface</source>
        <target state="translated">Interfaccia duplicata o ridondante</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNeedExplicitImplementation">
        <source>The interface '{0}' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.</source>
        <target state="translated">L'interfaccia '{0}' è inclusa in più tipi di interfaccia implementati in modo esplicito. Aggiungere un'implementazione esplicita dell'interfaccia.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNamedArgumentHasBeenAssignedMoreThenOnce">
        <source>The named argument '{0}' has been assigned more than one value</source>
        <target state="translated">All'argomento denominato '{0}' sono stati assegnati più valori</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGiven">
        <source>No implementation was given for '{0}'</source>
        <target state="translated">Nessuna implementazione specificata per '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenWithSuggestion">
        <source>No implementation was given for '{0}'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Nessuna implementazione specificata per '{0}'. Si noti che tutti i membri dell'interfaccia devono essere implementati ed elencati in una dichiarazione 'interface' appropriata, ad esempio 'interface ... with member ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfArguments">
        <source>The member '{0}' does not have the correct number of arguments. The required signature is '{1}'.</source>
        <target state="translated">Il membro '{0}' non dispone del numero di argomenti corretto. La firma necessaria è '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters">
        <source>The member '{0}' does not have the correct number of method type parameters. The required signature is '{1}'.</source>
        <target state="translated">Il membro '{0}' non dispone del numero corretto di parametri di tipo del metodo. La firma necessaria è '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters">
        <source>The member '{0}' does not have the correct kinds of generic parameters. The required signature is '{1}'.</source>
        <target state="translated">Il membro '{0}' non dispone dei tipi di parametri generici corretti. La firma necessaria è '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberCannotImplement">
        <source>The member '{0}' cannot be used to implement '{1}'. The required signature is '{2}'.</source>
        <target state="translated">Il membro '{0}' non può essere utilizzato per implementare '{1}'. La firma necessaria è '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILError">
        <source>Error while parsing embedded IL</source>
        <target state="translated">Errore durante l'analisi di IL incorporato</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILTypeError">
        <source>Error while parsing embedded IL type</source>
        <target state="translated">Errore durante l'analisi del tipo IL incorporato</target>
        <note />
      </trans-unit>
      <trans-unit id="astDeprecatedIndexerNotation">
        <source>This indexer notation has been removed from the F# language</source>
        <target state="translated">Notazione indicizzatore rimossa dal linguaggio F#</target>
        <note />
      </trans-unit>
      <trans-unit id="astInvalidExprLeftHandOfAssignment">
        <source>Invalid expression on left of assignment</source>
        <target state="translated">Espressione non valida a sinistra dell'assegnazione</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoRefEqualsOnStruct">
        <source>The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'.</source>
        <target state="translated">Non è possibile usare l'attributo 'ReferenceEquality' in struct. Provare a usare invece l'attributo 'StructuralEquality' oppure a implementare un override per 'System.Object.Equals(obj)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="augInvalidAttrs">
        <source>This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'</source>
        <target state="translated">Questo tipo usa una combinazione non valida degli attributi 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' e 'StructuralComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqualityNeedsNoComparison">
        <source>The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute</source>
        <target state="translated">L'attributo 'NoEquality' deve essere utilizzato insieme all'attributo 'NoComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructCompNeedsStructEquality">
        <source>The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute</source>
        <target state="translated">L'attributo 'StructuralComparison' deve essere utilizzato insieme all'attributo 'StructuralEquality'</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructEqNeedsNoCompOrStructComp">
        <source>The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes</source>
        <target state="translated">L'attributo 'StructuralEquality' deve essere utilizzato insieme agli attributi 'NoComparison' o 'StructuralComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="augTypeCantHaveRefEqAndStructAttrs">
        <source>A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes</source>
        <target state="translated">Un tipo non può avere sia l'attributo 'ReferenceEquality' sia 'StructuralEquality' o 'StructuralComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="augOnlyCertainTypesCanHaveAttrs">
        <source>Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes</source>
        <target state="translated">Con gli attributi 'ReferenceEquality', 'StructuralEquality' e 'StructuralComparison' è possibile aumentare solo tipi di struct, record, unione ed eccezione</target>
        <note />
      </trans-unit>
      <trans-unit id="augRefEqCantHaveObjEquals">
        <source>A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">Un tipo con attributo 'ReferenceEquality' non può avere un'implementazione esplicita di 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' o 'System.Collections.IStructuralEquatable'</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsObjEquals">
        <source>A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">Un tipo con attributo 'CustomEquality' deve avere un'implementazione esplicita di almeno uno degli elementi 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' o 'System.Collections.IStructuralEquatable'</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomCompareNeedsIComp">
        <source>A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'</source>
        <target state="translated">Un tipo con attributo 'CustomComparison' deve avere un'implementazione esplicita di almeno uno degli elementi 'System.IComparable' o 'System.Collections.IStructuralComparable'</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqNeedsNoObjEquals">
        <source>A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">Un tipo con attributo 'NoEquality' non deve avere in genere un'implementazione esplicita di 'Object.Equals(obj)'. Disabilitare questo avviso se ciò è intenzionale a fini di interoperabilità</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoCompCantImpIComp">
        <source>A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable&lt;_&gt;' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">Un tipo con attributo 'NoComparison' non deve avere in genere un'implementazione esplicita di 'System.IComparable', 'System.IComparable&lt;_&gt;' o 'System.Collections.IStructuralComparable'. Disabilitare questo avviso se questa scelta è intenzionale per garantire l'interoperabilità</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsNoCompOrCustomComp">
        <source>The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes</source>
        <target state="translated">L'attributo 'CustomEquality' deve essere utilizzato insieme agli attributi 'NoComparison' o 'CustomComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="forPositionalSpecifiersNotPermitted">
        <source>Positional specifiers are not permitted in format strings</source>
        <target state="translated">Identificatori di posizione non consentiti in stringhe di formato</target>
        <note />
      </trans-unit>
      <trans-unit id="forMissingFormatSpecifier">
        <source>Missing format specifier</source>
        <target state="translated">Identificatore di formato mancante</target>
        <note />
      </trans-unit>
      <trans-unit id="forFlagSetTwice">
        <source>'{0}' flag set twice</source>
        <target state="translated">Flag '{0}' impostato due volte</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrefixFlagSpacePlusSetTwice">
        <source>Prefix flag (' ' or '+') set twice</source>
        <target state="translated">Flag di prefisso (' ' o '+') impostato due volte</target>
        <note />
      </trans-unit>
      <trans-unit id="forHashSpecifierIsInvalid">
        <source>The # formatting modifier is invalid in F#</source>
        <target state="translated">Il modificatore di formattazione # non è valido in F#</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadPrecision">
        <source>Bad precision in format specifier</source>
        <target state="translated">Precisione non valida in identificatore di formato</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadWidth">
        <source>Bad width in format specifier</source>
        <target state="translated">Larghezza non valida in identificatore di formato</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportZeroFlag">
        <source>'{0}' format does not support '0' flag</source>
        <target state="translated">Il formato '{0}' non supporta il flag '0'</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrecisionMissingAfterDot">
        <source>Precision missing after the '.'</source>
        <target state="translated">Precisione mancante dopo '.'</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatDoesntSupportPrecision">
        <source>'{0}' format does not support precision</source>
        <target state="translated">Il formato '{0}' non supporta la precisione</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifier">
        <source>Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Identificatore di formato non valido (dopo l o L): è previsto ld,li,lo,lu,lx o lX. Nel codice F# è invece possibile usare %d, %x, %o o %u, di cui viene eseguito l'overload affinché funzionino con tutti i tipi di Integer di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="forLIsUnnecessary">
        <source>The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">'l' o 'L' non è necessario nell'identificatore di formato. Nel codice F# è invece possibile usare %d, %x, %o o %u, di cui viene eseguito l'overload affinché funzionino con tutti i tipi di Integer di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="forHIsUnnecessary">
        <source>The 'h' or 'H' in this format specifier is unnecessary. You can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">'h' o 'H' non è necessario nell'identificatore di formato. È possibile usare %d, %x, %o o %u, di cui viene eseguito l'overload affinché funzionino con tutti i tipi di Integer di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportPrefixFlag">
        <source>'{0}' does not support prefix '{1}' flag</source>
        <target state="translated">'{0}' non supporta il flag '{1}' del prefisso</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifierGeneral">
        <source>Bad format specifier: '{0}'</source>
        <target state="translated">Identificatore di formato non valido: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="elSysEnvExitDidntExit">
        <source>System.Environment.Exit did not exit</source>
        <target state="translated">System.Environment.Exit inesistente</target>
        <note />
      </trans-unit>
      <trans-unit id="elDeprecatedOperator">
        <source>The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined</source>
        <target state="translated">La modalità di gestione di questo operatore dipende ora direttamente dal compilatore F# e non è possibile ridefinirne il significato</target>
        <note />
      </trans-unit>
      <trans-unit id="chkProtectedOrBaseCalled">
        <source>A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope.</source>
        <target state="translated">È presente una chiamata a un membro protetto oppure viene usata la parola chiave 'base'. Ciò è consentito solo nell'implementazione diretta di membri perché questi ultimi potrebbero uscire dal relativo ambito di oggetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkByrefUsedInInvalidWay">
        <source>The byref-typed variable '{0}' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.</source>
        <target state="translated">La variabile di tipo byref '{0}' è utilizzata in modo non valido. Le variabili di tipo byref non possono essere acquisite dalle chiusure o passate a funzioni interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkBaseUsedInInvalidWay">
        <source>The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.</source>
        <target state="translated">La parola chiave 'base' è usata in modo non valido. Le chiamate di base non possono essere usate nelle chiusure. Provare a usare un membro privato per effettuare le chiamate di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkVariableUsedInInvalidWay">
        <source>The variable '{0}' is used in an invalid way</source>
        <target state="translated">La variabile '{0}' è usata in modo non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTypeLessAccessibleThanType">
        <source>The type '{0}' is less accessible than the value, member or type '{1}' it is used in.</source>
        <target state="translated">Il tipo '{0}' è meno accessibile del valore, del membro o del tipo '{1}' in cui viene usato.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSystemVoidOnlyInTypeof">
        <source>'System.Void' can only be used as 'typeof&lt;System.Void&gt;' in F#</source>
        <target state="translated">'System.Void' può essere usato solo come 'typeof&lt;System.Void&gt;' in F#</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorUseOfByref">
        <source>A type instantiation involves a byref type. This is not permitted by the rules of Common IL.</source>
        <target state="translated">La creazione dell'istanza di un tipo prevede un tipo byref. Ciò non è consentito dalle regole di IL comune.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorContainsCallToRethrow">
        <source>Calls to 'reraise' may only occur directly in a handler of a try-with</source>
        <target state="translated">Le chiamate a 'reraise' possono essere presenti solo direttamente all'interno di un gestore di un'espressione try-with</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSplicingOnlyInQuotations">
        <source>Expression-splicing operators may only be used within quotations</source>
        <target state="translated">Gli operatori di splicing delle espressioni possono essere utilizzati solo in quotation</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassSplicing">
        <source>First-class uses of the expression-splicing operator are not permitted</source>
        <target state="translated">Utilizzi di prima classe dell'operatore di splicing delle espressioni non consentiti</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassAddressOf">
        <source>First-class uses of the address-of operators are not permitted</source>
        <target state="translated">Utilizzi di prima classe di operatori address-of non consentiti</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassRethrow">
        <source>First-class uses of the 'reraise' function is not permitted</source>
        <target state="translated">Utilizzi di prima classe della funzione 'reraise' non consentiti</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAtThisPoint">
        <source>The byref typed value '{0}' cannot be used at this point</source>
        <target state="translated">Non è possibile usare il valore di tipo byref '{0}' in questo punto</target>
        <note />
      </trans-unit>
      <trans-unit id="chkLimitationsOfBaseKeyword">
        <source>'base' values may only be used to make direct calls to the base implementations of overridden members</source>
        <target state="translated">I valori 'base' possono essere utilizzati esclusivamente per effettuare chiamate dirette alle implementazioni di base dei membri sottoposti a override</target>
        <note />
      </trans-unit>
      <trans-unit id="chkObjCtorsCantUseExceptionHandling">
        <source>Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.</source>
        <target state="translated">I costruttori di oggetti non possono utilizzare direttamente try/with e try/finally prima dell'inizializzazione dell'oggetto. Ciò include costrutti quali 'for x in ...' che potrebbero essere elaborati negli utilizzi di tali costrutti. Si tratta di una limitazione imposta dall'IL comune.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfAtThisPoint">
        <source>The address of the variable '{0}' cannot be used at this point</source>
        <target state="translated">Non è possibile usare l'indirizzo della variabile '{0}' in questo punto</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressStaticFieldAtThisPoint">
        <source>The address of the static field '{0}' cannot be used at this point</source>
        <target state="translated">Non è possibile usare l'indirizzo del campo statico '{0}' in questo punto</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressFieldAtThisPoint">
        <source>The address of the field '{0}' cannot be used at this point</source>
        <target state="translated">Non è possibile usare l'indirizzo del campo '{0}' in questo punto</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfArrayElementAtThisPoint">
        <source>The address of an array element cannot be used at this point</source>
        <target state="translated">Non è possibile usare l'indirizzo di un elemento di matrice in questo punto</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFirstClassFuncNoByref">
        <source>The type of a first-class function cannot contain byrefs</source>
        <target state="translated">Il tipo di una funzione di prima classe non può contenere byref</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReturnTypeNoByref">
        <source>A method return type would contain byrefs which is not permitted</source>
        <target state="translated">Il tipo restituito di un metodo conterrebbe byref, il che non è consentito</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidCustAttrVal">
        <source>Invalid custom attribute value (not a constant or literal)</source>
        <target state="translated">Valore di attributo personalizzato non valido (non è una costante o un valore letterale)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkAttrHasAllowMultiFalse">
        <source>The attribute type '{0}' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element.</source>
        <target state="translated">Per il tipo di attributo '{0}' è specificato 'AllowMultiple=false'. Non è possibile collegare più istanze di questo attributo a un singolo elemento del linguaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to its definition at or near '{2}'. This is an invalid forward reference.</source>
        <target state="translated">Il membro '{0}' è utilizzato in modo non valido. Un utilizzo di '{1}' è stato dedotto prima della relativa definizione in o in prossimità di '{2}'. Si tratta di un riferimento in avanti non valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAsTopValue">
        <source>A byref typed value would be stored here. Top-level let-bound byref values are not permitted.</source>
        <target state="translated">In questa posizione verrebbe archiviato un valore di tipo byref. Non sono consentiti valori byref associati a let di livello superiore.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReflectedDefCantSplice">
        <source>[&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">I termini [&lt;ReflectedDefinition&gt;] non possono contenere usi dell'operatore di splicing del prefisso '%'</target>
        <note />
      </trans-unit>
      <trans-unit id="chkEntryPointUsage">
        <source>A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence.</source>
        <target state="translated">Una funzione con l'attributo 'EntryPointAttribute' come etichetta deve essere l'ultima dichiarazione nell'ultimo file della sequenza di compilazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseCompiledForm">
        <source>compiled form of the union case</source>
        <target state="translated">form compilato del case di unione</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseDefaultAugmentation">
        <source>default augmentation of the union case</source>
        <target state="translated">aumento predefinito del case di unione</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameMethod">
        <source>The property '{0}' has the same name as a method in type '{1}'.</source>
        <target state="translated">Il nome della proprietà '{0}' corrisponde a quello di un metodo nel tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterSetterDoNotMatchAbstract">
        <source>The property '{0}' of type '{1}' has a getter and a setter that do not match. If one is abstract then the other must be as well.</source>
        <target state="translated">La proprietà '{0}' di tipo '{1}' contiene un getter e un setter che non corrispondono. Se uno di essi è astratto, è necessario che lo sia anche l'altro.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameIndexer">
        <source>The property '{0}' has the same name as another property in type '{1}', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.</source>
        <target state="translated">Il nome della proprietà '{0}' corrisponde a quello di un'altra proprietà nel tipo '{1}', tuttavia una accetta argomenti di indicizzatore e l'altra no. È possibile che in una delle proprietà manchi un argomento di indicizzatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCantStoreByrefValue">
        <source>A type would store a byref typed value. This is not permitted by Common IL.</source>
        <target state="translated">Un valore di tipo byref verrebbe archiviato in un tipo. Ciò non è consentito dall'IL comune.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethod">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}'.</source>
        <target state="translated">Metodo duplicato. Il nome e la firma del metodo '{0}' corrispondono a quelli di un altro metodo nel tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodWithSuffix">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Metodo duplicato. Il nome e la firma del metodo '{0}' corrispondono a quelli di un altro metodo nel tipo '{1}' dopo la cancellazione di tuple, funzioni, unità di misura e/o tipi forniti.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodCurried">
        <source>The method '{0}' has curried arguments but has the same name as another method in type '{1}'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.</source>
        <target state="translated">Il nome del metodo '{0}' con argomenti sottoposti a currying corrisponde a quello di un altro metodo nel tipo '{1}'. Non è possibile eseguire l'overload di metodi con argomenti sottoposti a currying. Provare a usare un metodo che usa argomenti di tupla.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCurriedMethodsCantHaveOutParams">
        <source>Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments</source>
        <target state="translated">I metodi con argomenti sottoposti a currying non possono dichiarare argomenti 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName' o 'CallerFilePath'</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateProperty">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}'.</source>
        <target state="translated">Proprietà duplicata. Il nome e la firma della proprietà '{0}' corrispondono a quelli di un'altra proprietà nel tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicatePropertyWithSuffix">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Proprietà duplicata. Il nome e la firma della proprietà '{0}' corrispondono a quelli di un'altra proprietà nel tipo '{1}' dopo la cancellazione di tuple, funzioni, unità di misura e/o tipi forniti.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedType">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type.</source>
        <target state="translated">Metodo duplicato. Il nome e la firma del metodo astratto '{0}' corrispondono a quelli di un metodo astratto in un tipo ereditato.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedTypeWithSuffix">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Metodo duplicato. Il nome e la firma del metodo astratto '{0}' corrispondono a quelli di un metodo astratto in un tipo ereditato dopo la cancellazione di tuple, funzioni, unità di misura e/o tipi forniti.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMultipleGenericInterfaceInstantiations">
        <source>This type implements the same interface at different generic instantiations '{0}' and '{1}'. This is not permitted in this version of F#.</source>
        <target state="translated">Questo tipo implementa la stessa interfaccia in creazioni di istanze generiche diverse '{0}' e '{1}'. Ciò non è consentito in questa versione di F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkValueWithDefaultValueMustHaveDefaultValue">
        <source>The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check</source>
        <target state="translated">Il tipo di un campo che utilizza l'attributo 'DefaultValue' deve accettare l'inizializzazione predefinita, ovvero deve prevedere 'null' come valore valido oppure essere un tipo di struct i cui campi accettano tutti l'inizializzazione predefinita. È possibile utilizzare 'DefaultValue(false)' per disabilitare questa verifica</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefInTypeAbbrev">
        <source>The type abbreviation contains byrefs. This is not permitted by F#.</source>
        <target state="translated">L'abbreviazione del tipo contiene byref. Ciò non è consentito da F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefBoundVarUsedInSplice">
        <source>The variable '{0}' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.</source>
        <target state="translated">La variabile '{0}' è associata in una quotation ma viene usata come parte di un'espressione sottoposta a splicing. Ciò non è consentito perché la variabile potrebbe uscire dal relativo ambito.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericExprs">
        <source>Quotations cannot contain uses of generic expressions</source>
        <target state="translated">Le quotation non possono contenere utilizzi di espressioni generiche</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericFunctions">
        <source>Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.</source>
        <target state="translated">Le quotation non possono contenere definizioni di funzioni dedotte o dichiarate in modo da essere generiche. Provare ad aggiungere alcuni vincoli di tipo per rendere l'espressione in quotation valida.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainObjExprs">
        <source>Quotations cannot contain object expressions</source>
        <target state="translated">Le quotation non possono contenere espressioni di oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainAddressOf">
        <source>Quotations cannot contain expressions that take the address of a field</source>
        <target state="translated">Le quotation non possono contenere espressioni che utilizzano l'indirizzo di un campo</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainStaticFieldRef">
        <source>Quotations cannot contain expressions that fetch static fields</source>
        <target state="translated">Le quotation non possono contenere espressioni che recuperano campi statici</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainInlineIL">
        <source>Quotations cannot contain inline assembly code or pattern matching on arrays</source>
        <target state="translated">Le quotation non possono contenere codice assembly inline o criteri di ricerca in matrici</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainDescendingForLoops">
        <source>Quotations cannot contain descending for loops</source>
        <target state="translated">Le quotation non possono contenere elementi di ordinamento decrescente per i cicli</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantFetchUnionIndexes">
        <source>Quotations cannot contain expressions that fetch union case indexes</source>
        <target state="translated">Le quotation non possono contenere espressioni che recuperano indici di case di unione</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetUnionFields">
        <source>Quotations cannot contain expressions that set union case fields</source>
        <target state="translated">Le quotation non possono contenere espressioni che impostano campi di case di unione</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetExceptionFields">
        <source>Quotations cannot contain expressions that set fields in exception values</source>
        <target state="translated">Le quotation non possono contenere espressioni che impostano campi in valori di eccezione</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantRequireByref">
        <source>Quotations cannot contain expressions that require byref pointers</source>
        <target state="translated">Le quotation non possono contenere espressioni che richiedono puntatori byref</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantCallTraitMembers">
        <source>Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call</source>
        <target state="translated">Le quotation non possono contenere espressioni che effettuano chiamate a vincoli di membro o utilizzi di operatori che vengono risolti in modo implicito in una chiamata a vincolo di membro</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisConstant">
        <source>Quotations cannot contain this kind of constant</source>
        <target state="translated">Le quotation non possono contenere questo tipo di costante</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisPatternMatch">
        <source>Quotations cannot contain this kind of pattern match</source>
        <target state="translated">Le quotation non possono contenere questo tipo di carattere jolly</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainArrayPatternMatching">
        <source>Quotations cannot contain array pattern matching</source>
        <target state="translated">Le quotation non possono contenere criteri di ricerca per identificare matrici</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisType">
        <source>Quotations cannot contain this kind of type</source>
        <target state="translated">Le quotation non possono contenere questo genere di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeCannotBeResolvedAtCompileTime">
        <source>The declared type parameter '{0}' cannot be used here since the type parameter cannot be resolved at compile time</source>
        <target state="translated">Non è possibile usare il parametro di tipo dichiarato '{0}' in questa posizione perché non può essere risolto in fase di compilazione</target>
        <note />
      </trans-unit>
      <trans-unit id="csCodeLessGeneric">
        <source>This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'.</source>
        <target state="translated">Il codice è meno generico di quanto indicato dalle relative annotazioni. Un'unità di misura specificata mediante '_' risulta essere '1', ovvero senza dimensione. Provare a rendere il codice generico oppure a rimuovere l'utilizzo di '_'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInferenceMaxDepth">
        <source>Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.</source>
        <target state="translated">Problema di inferenza del tipo troppo complesso (raggiunta profondità di iterazione massima). Provare ad aggiungere ulteriori annotazioni di tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectedArguments">
        <source>Expected arguments to an instance member</source>
        <target state="translated">Argomenti previsti in un membro di istanza</target>
        <note />
      </trans-unit>
      <trans-unit id="csIndexArgumentMismatch">
        <source>This indexer expects {0} arguments but is here given {1}</source>
        <target state="translated">L'indicizzatore prevede {0} argomenti, tuttavia ne è stato rilevato un numero pari a {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenFunction">
        <source>Expecting a type supporting the operator '{0}' but given a function type. You may be missing an argument to a function.</source>
        <target state="translated">È previsto un tipo che supporti l'operatore '{0}', tuttavia è specificato un tipo di funzione. Probabilmente manca un argomento in una funzione.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenTuple">
        <source>Expecting a type supporting the operator '{0}' but given a tuple type</source>
        <target state="translated">È previsto un tipo che supporti l'operatore '{0}', tuttavia è specificato un tipo di tuple</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperator">
        <source>None of the types '{0}' support the operator '{1}'</source>
        <target state="translated">Nessuno dei tipi '{0}' supporta l'operatore '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperator">
        <source>The type '{0}' does not support the operator '{1}'</source>
        <target state="translated">Il tipo '{0}' non supporta l'operatore '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperatorNullable">
        <source>None of the types '{0}' support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Nessun tipo '{0}' supporta l'operatore '{1}'. Provare ad aprire il modulo 'Microsoft.FSharp.Linq.NullableOperators'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperatorNullable">
        <source>The type '{0}' does not support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Il tipo '{0}' non supporta l'operatore '{1}'. Provare ad aprire il modulo 'Microsoft.FSharp.Linq.NullableOperators'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportConversion">
        <source>The type '{0}' does not support a conversion to the type '{1}'</source>
        <target state="translated">Il tipo '{0}' non supporta una conversione nel tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is static</source>
        <target state="translated">Il tipo '{0}' ha un metodo '{1}' (nome completo '{2}'), tuttavia il metodo è statico</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsNotStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is not static</source>
        <target state="translated">Il tipo '{0}' ha un metodo '{1}' (nome completo '{2}'), tuttavia il metodo non è statico</target>
        <note />
      </trans-unit>
      <trans-unit id="csStructConstraintInconsistent">
        <source>The constraints 'struct' and 'not struct' are inconsistent</source>
        <target state="translated">I vincoli 'struct' e 'not struct' sono incoerenti</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value</source>
        <target state="translated">Il tipo '{0}' non prevede 'null' come valore valido</target>
        <note />
      </trans-unit>
      <trans-unit id="csNullableTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'.</source>
        <target state="translated">Il tipo '{0}' non prevede 'null' come valore valido. Per creare un valore null per un tipo Nullable utilizzare 'System.Nullable()'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison1">
        <source>The type '{0}' does not support the 'comparison' constraint because it has the 'NoComparison' attribute</source>
        <target state="translated">Il tipo '{0}' non supporta il vincolo 'comparison' perché contiene l'attributo 'NoComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison2">
        <source>The type '{0}' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface</source>
        <target state="translated">Il tipo '{0}' non supporta il vincolo 'comparison'. Non supporta ad esempio l'interfaccia 'System.IComparable'</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison3">
        <source>The type '{0}' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison</source>
        <target state="translated">Il tipo '{0}' non supporta il vincolo 'comparison' perché è un record, un'unione o uno struct con uno o più tipi di elementi strutturali che non supportano il vincolo 'comparison'. Evitare l'uso del confronto con questo tipo oppure aggiungere l'attributo 'StructuralComparison' al tipo per determinare quale tipo di campo non supporta il confronto</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality1">
        <source>The type '{0}' does not support the 'equality' constraint because it has the 'NoEquality' attribute</source>
        <target state="translated">Il tipo '{0}' non supporta il vincolo 'equality' perché contiene l'attributo 'NoEquality'</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality2">
        <source>The type '{0}' does not support the 'equality' constraint because it is a function type</source>
        <target state="translated">Il tipo '{0}' non supporta il vincolo 'equality' perché si tratta di un tipo di funzione</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality3">
        <source>The type '{0}' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality</source>
        <target state="translated">Il tipo '{0}' non supporta il vincolo 'equality' perché è un record, un'unione o uno struct con uno o più tipi di elementi strutturali che non supportano il vincolo 'equality'. Evitare l'uso dell'uguaglianza con questo tipo oppure aggiungere l'attributo 'StructuralEquality' al tipo per determinare quale tipo di campo non supporta l'uguaglianza</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotEnumType">
        <source>The type '{0}' is not a CLI enum type</source>
        <target state="translated">Il tipo '{0}' non è un tipo enumerazione CLI</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeHasNonStandardDelegateType">
        <source>The type '{0}' has a non-standard delegate type</source>
        <target state="translated">Il tipo '{0}' dispone di un tipo delegato non standard</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotDelegateType">
        <source>The type '{0}' is not a CLI delegate type</source>
        <target state="translated">Il tipo '{0}' non è un tipo delegato CLI</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeParameterCannotBeNullable">
        <source>This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values.</source>
        <target state="translated">Non è possibile creare un'istanza di questo parametro di tipo come 'Nullable'. Si tratta di una limitazione imposta per assicurare che il significato di 'null' in alcuni linguaggi CLI non venga confuso se usato in combinazione con valori 'Nullable'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructType">
        <source>A generic construct requires that the type '{0}' is a CLI or F# struct type</source>
        <target state="translated">Per i costrutti generici è necessario che il tipo '{0}' sia un tipo di struct CLI o F#</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresUnmanagedType">
        <source>A generic construct requires that the type '{0}' is an unmanaged type</source>
        <target state="translated">Un costruttore generico richiede che il tipo '{0}' sia un tipo non gestito</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeNotCompatibleBecauseOfPrintf">
        <source>The type '{0}' is not compatible with any of the types {1}, arising from the use of a printf-style format string</source>
        <target state="translated">Il tipo '{0}' non è compatibile con alcuno dei tipi {1}, derivanti dall'utilizzo di una stringa di formato printf-style</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresReferenceSemantics">
        <source>A generic construct requires that the type '{0}' have reference semantics, but it does not, i.e. it is a struct</source>
        <target state="translated">Per i costrutti generici è necessario che il tipo '{0}' disponga di semantica di riferimento, la quale è in questo caso assente, ovvero si tratta di uno struct</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresNonAbstract">
        <source>A generic construct requires that the type '{0}' be non-abstract</source>
        <target state="translated">Per i costrutti generici è necessario che il tipo '{0}' non sia astratto</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresPublicDefaultConstructor">
        <source>A generic construct requires that the type '{0}' have a public default constructor</source>
        <target state="translated">Per i costrutti generici è necessario che il tipo '{0}' disponga di un costruttore predefinito pubblico</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInstantiationLengthMismatch">
        <source>Type instantiation length mismatch</source>
        <target state="translated">Lunghezza creazione dell'istanza del tipo non corrispondente</target>
        <note />
      </trans-unit>
      <trans-unit id="csOptionalArgumentNotPermittedHere">
        <source>Optional arguments not permitted here</source>
        <target state="translated">In questa posizione non sono consentiti argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotStatic">
        <source>{0} is not a static member</source>
        <target state="translated">{0} non è un membro statico</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotInstance">
        <source>{0} is not an instance member</source>
        <target state="translated">{0} non è un membro di istanza</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentLengthMismatch">
        <source>Argument length mismatch</source>
        <target state="translated">Lunghezza argomenti non corrispondente</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentTypesDoNotMatch">
        <source>The argument types don't match</source>
        <target state="translated">Tipi di argomento non corrispondenti</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodExpectsParams">
        <source>This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument</source>
        <target state="translated">Questo metodo prevede un parametro CLI 'params' in questa posizione. Il parametro 'params' rappresenta un modo per passare un numero di argomenti variabile a un metodo in linguaggi quali C#. Provare a passare una matrice per questo argomento</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible">
        <source>The member or object constructor '{0}' is not {1}</source>
        <target state="translated">Il costruttore di oggetti o membro '{0}' non è {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible2">
        <source>The member or object constructor '{0}' is not {1}. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.</source>
        <target state="translated">Il costruttore di oggetti o membro '{0}' non è {1}. È possibile accedere ai membri privati solo dall'interno del tipo dichiarante. I membri privati sono invece accessibili solo da un tipo di estensione e non da espressioni lambda interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAStaticMethod">
        <source>{0} is not a static method</source>
        <target state="translated">{0} non è un metodo statico</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAnInstanceMethod">
        <source>{0} is not an instance method</source>
        <target state="translated">{0} non è un metodo di istanza</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberHasNoArgumentOrReturnProperty">
        <source>The member or object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">Il costruttore di oggetti o membro '{0}' non dispone di un argomento o di una proprietà restituita impostabile '{1}'. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorHasNoArgumentOrReturnProperty">
        <source>The object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">Per il costruttore di oggetti '{0}' non esiste un argomento o una proprietà restituita impostabile '{1}'. {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csRequiredSignatureIs">
        <source>The required signature is {0}</source>
        <target state="translated">La firma obbligatoria è {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'.</source>
        <target state="translated">Il costruttore di oggetti o membro '{0}' richiede {1} argomento/i. La firma necessaria è '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch2">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'.</source>
        <target state="translated">Il costruttore di oggetti o membro '{0}' richiede {1} argomento/i aggiuntivo/i. La firma necessaria è '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch3">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">Il costruttore di oggetti o membro '{0}' richiede {1} argomento/i. La firma necessaria è '{2}'. Alcuni nomi di argomenti mancanti sono {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch4">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">Il costruttore di oggetti o membro '{0}' richiede {1} argomento/i aggiuntivo/i. La firma necessaria è '{2}'. Alcuni nomi di argomenti mancanti sono {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityNamed">
        <source>The member or object constructor '{0}' requires {1} argument(s) but is here given {2} unnamed and {3} named argument(s). The required signature is '{4}'.</source>
        <target state="translated">Il costruttore di oggetti o membro '{0}' richiede {1} argomento/i, tuttavia sono specificati {2} argomento/i non denominato/i e {3} argomento/i denominato/i. La firma necessaria è '{4}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArity">
        <source>The member or object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Il costruttore di oggetti o membro '{0}' utilizza {1} argomento/i, tuttavia il numero di argomenti specificati è pari a {2}. La firma necessaria è '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArity">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Il costruttore di oggetti '{0}' accetta {1} argomento/i, ma ne sono stati specificati {2}. La firma obbligatoria è '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArityProp">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',').</source>
        <target state="translated">Il costruttore di oggetti '{0}' accetta {1} argomento/i, ma ne sono stati specificati {2}. La firma obbligatoria è '{3}'. Se alcuni degli argomenti vengono usati per assegnare valori alle proprietà, provare a delimitarli con una virgola (',').</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityType">
        <source>The member or object constructor '{0}' takes {1} type argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Il costruttore di oggetti o membro '{0}' utilizza {1} argomento/i di tipo, tuttavia il numero di argomenti specificati è pari a {2}. La firma necessaria è '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberNotAccessible">
        <source>A member or object constructor '{0}' taking {1} arguments is not accessible from this code location. All accessible versions of method '{2}' take {3} arguments.</source>
        <target state="translated">Da questa posizione del codice non è possibile accedere a un costruttore di oggetti o membri '{0}' che accetta {1} argomenti. Tutte le versioni accessibili del metodo '{2}' accettano {3} argomenti.</target>
        <note />
      </trans-unit>
      <trans-unit id="csIncorrectGenericInstantiation">
        <source>Incorrect generic instantiation. No {0} member named '{1}' takes {2} generic arguments.</source>
        <target state="translated">Creazione di istanza generica non corretta. Nessun membro {0} denominato '{1}' utilizza {2} argomenti generici.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberOverloadArityMismatch">
        <source>The member or object constructor '{0}' does not take {1} argument(s). An overload was found taking {2} arguments.</source>
        <target state="translated">Il costruttore di oggetti o membro '{0}' non utilizza {1} argomento/i. Trovato overload con {2} argomenti.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments</source>
        <target state="translated">Nessun costruttore di oggetti o membro {0} denominato '{1}' utilizza {2} argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments2">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. Note the call to this member also provides {3} named arguments.</source>
        <target state="translated">Nessun costruttore di oggetti o membro {0} denominato '{1}' accetta {2} argomenti. Si noti che la chiamata a questo membro fornisce inoltre {3} argomenti denominati.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments3">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. The named argument '{3}' doesn't correspond to any argument or settable return property for any overload.</source>
        <target state="translated">Nessun costruttore di oggetti o membro {0} denominato '{1}' utilizza {2} argomenti. L'argomento denominato '{3}' non corrisponde ad alcun argomento o proprietà restituita impostabile per alcun overload.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodNotFound">
        <source>Method or object constructor '{0}' not found</source>
        <target state="translated">Costruttore di oggetti o metodo '{0}' non trovato</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFound">
        <source>No overloads match for method '{0}'.</source>
        <target state="translated">Nessun overload corrispondente per il metodo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsOverloaded">
        <source>A unique overload for method '{0}' could not be determined based on type information prior to this program point. A type annotation may be needed.</source>
        <target state="translated">Non è stato possibile determinare un overload univoco per il metodo '{0}' in base alle informazioni sui tipi prima di questo punto del programma. Potrebbe essere necessaria un'annotazione di tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCandidates">
        <source>Candidates:\n{0}</source>
        <target state="translated">Candidati:\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="parsDoCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on 'do' bindings, but '{0}' was given.</source>
        <target state="translated">I modificatori di accessibilità non sono consentiti nei binding 'do', ma è stato specificato '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInHashIf">
        <source>End of file in #if section begun at or after here</source>
        <target state="translated">La fine del file nella sezione #if inizia in questa posizione o dopo di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInString">
        <source>End of file in string begun at or before here</source>
        <target state="translated">La fine del file nella stringa inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimString">
        <source>End of file in verbatim string begun at or before here</source>
        <target state="translated">La fine del file nella stringa verbatim inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInComment">
        <source>End of file in comment begun at or before here</source>
        <target state="translated">La fine del file nel commento inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInStringInComment">
        <source>End of file in string embedded in comment begun at or before here</source>
        <target state="translated">La fine del file nella stringa incorporata nel commento inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimStringInComment">
        <source>End of file in verbatim string embedded in comment begun at or before here</source>
        <target state="translated">La fine del file nella stringa verbatim incorporata nel commento inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInIfOcaml">
        <source>End of file in IF-OCAML section begun at or before here</source>
        <target state="translated">La fine del file nella sezione IF-OCAML inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInDirective">
        <source>End of file in directive begun at or before here</source>
        <target state="translated">La fine del file nella direttiva inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoHashEndIfFound">
        <source>No #endif found for #if or #else</source>
        <target state="translated">Nessun #endif trovato per #if o #else</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIgnored">
        <source>Attributes have been ignored in this construct</source>
        <target state="translated">Attributi ignorati nel costrutto</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInImplicitClassConstructors">
        <source>'use' bindings are not permitted in primary constructors</source>
        <target state="translated">Binding 'use' non consentiti in costruttori primari</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInModules">
        <source>'use' bindings are not permitted in modules and are treated as 'let' bindings</source>
        <target state="translated">Binding 'use' non consentiti nei moduli e considerati come binding 'let'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIntegerForLoopRequiresSimpleIdentifier">
        <source>An integer for loop must use a simple identifier</source>
        <target state="translated">Un Integer per un ciclo deve usare un identificatore semplice</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyOneWithAugmentationAllowed">
        <source>At most one 'with' augmentation is permitted</source>
        <target state="translated">È consentito al massimo un aumento 'with'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSemicolon">
        <source>A semicolon is not expected at this point</source>
        <target state="translated">Punto e virgola non previsto in questo punto</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFile">
        <source>Unexpected end of input</source>
        <target state="translated">Fine di input non prevista</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedVisibilityDeclaration">
        <source>Accessibility modifiers are not permitted here, but '{0}' was given.</source>
        <target state="translated">I modificatori di accessibilità non sono consentiti in questa posizione, ma è stato specificato '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyHashDirectivesAllowed">
        <source>Only '#' compiler directives may occur prior to the first 'namespace' declaration</source>
        <target state="translated">Prima della prima dichiarazione 'namespace' possono essere presenti solo direttive '#' del compilatore</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityDeclarationsShouldComePriorToIdentifier">
        <source>Accessibility modifiers should come immediately prior to the identifier naming a construct</source>
        <target state="translated">I modificatori di accessibilità devono trovarsi immediatamente prima dell'identificatore di denominazione di un costrutto</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNamespaceOrModuleNotBoth">
        <source>Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'</source>
        <target state="translated">I file devono iniziare con una dichiarazione di modulo o di spazio dei nomi, ad esempio 'namespace SpazioNomi.SottoSpazioNomi' oppure 'module SpazioNomi.Modulo', ma non con entrambe. Per definire un modulo all'interno di uno spazio dei nomi utilizzare 'module Modulo = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleAbbreviationMustBeSimpleName">
        <source>A module abbreviation must be a simple name, not a path</source>
        <target state="translated">L'abbreviazione di un modulo deve essere un nome semplice, non un percorso</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviation">
        <source>Ignoring attributes on module abbreviation</source>
        <target state="translated">Gli attributi nell'abbreviazione del modulo verranno ignorati</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">L'attributo di accessibilità '{0}' non è consentito nell'abbreviazione del modulo. Le abbreviazioni dei moduli sono sempre private.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">L'attributo di visibilità '{0}' non è consentito nell'abbreviazione del modulo. Le abbreviazioni dei moduli sono sempre private.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnClosedBlockInHashLight">
        <source>Unclosed block</source>
        <target state="translated">Blocco non risolto</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBeginOrStruct">
        <source>Unmatched 'begin' or 'struct'</source>
        <target state="translated">'begin' o 'struct' senza corrispondenza</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleDefnMustBeSimpleName">
        <source>A module name must be a simple name, not a path</source>
        <target state="translated">Il nome di un modulo deve essere un nome semplice, non un percorso</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEmptyModuleDefn">
        <source>Unexpected empty type moduleDefn list</source>
        <target state="translated">Elenco moduleDefn di tipo vuoto non previsto</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesMustComeBeforeVal">
        <source>Attributes should be placed before 'val'</source>
        <target state="translated">Gli attributi devono trovarsi prima di 'val'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesAreNotPermittedOnInterfaceImplementations">
        <source>Attributes are not permitted on interface implementations</source>
        <target state="translated">Attributi non consentiti in implementazioni di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxError">
        <source>Syntax error</source>
        <target state="translated">Errore di sintassi</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAugmentationsIllegalOnDelegateType">
        <source>Augmentations are not permitted on delegate type moduleDefns</source>
        <target state="translated">Aumenti non consentiti in elementi moduleDefns di tipo delegato</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedClassInterfaceOrStruct">
        <source>Unmatched 'class', 'interface' or 'struct'</source>
        <target state="translated">'class', 'interface' o 'struct' senza corrispondenza</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyTypeDefinition">
        <source>A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'.</source>
        <target state="translated">In una definizione di tipo sono necessari uno o più membri oppure altre dichiarazioni. Se si vuole definire una classe, un'interfaccia o uno struct vuoto, usare 'type ... = class end', 'interface end' o 'struct end'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedWith">
        <source>Unmatched 'with' or badly formatted 'with' block</source>
        <target state="translated">'with' senza corrispondenza o blocco 'with' in formato non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetOrSetRequired">
        <source>'get', 'set' or 'get,set' required</source>
        <target state="translated">Necessari 'get', 'set' o 'get,set'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyClassCanTakeValueArguments">
        <source>Only class types may take value arguments</source>
        <target state="translated">Gli argomenti value possono essere usati solo da tipi di classe</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBegin">
        <source>Unmatched 'begin'</source>
        <target state="translated">'begin' senza corrispondenza</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidDeclarationSyntax">
        <source>Invalid declaration syntax</source>
        <target state="translated">Sintassi di dichiarazione non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetAndOrSetRequired">
        <source>'get' and/or 'set' required</source>
        <target state="translated">Necessari 'get' e/o 'set'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAnnotationsOnGetSet">
        <source>Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'</source>
        <target state="translated">Le annotazioni di tipo nei getter e setter di proprietà devono essere specificate dopo 'get()' o 'set(v)', ad esempio 'with get() : string = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterMustHaveAtLeastOneArgument">
        <source>A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'</source>
        <target state="translated">Un proprietà di getter deve essere una funzione, ad esempio 'get() = ...' oppure 'get(index) = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultipleAccessibilitiesForGetSet">
        <source>Multiple accessibilities given for property getter or setter</source>
        <target state="translated">Sono state assegnate più accessibilità per il getter o il setter della proprietà</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetSyntax">
        <source>Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '</source>
        <target state="translated">I setter di proprietà devono essere definiti con 'set value = ', 'set idx value = ' o 'set (idx1,...,idxN) value = ... '</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInterfacesHaveSameVisibilityAsEnclosingType">
        <source>Interfaces always have the same visibility as the enclosing type</source>
        <target state="translated">Le interfacce hanno sempre la stessa visibilità del tipo di inclusione</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAccessibilityModsIllegalForAbstract">
        <source>Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.</source>
        <target state="translated">Modificatori di accessibilità non consentiti in questo membro. Gli slot astratti hanno sempre la stessa visibilità del tipo di inclusione.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalOnInherit">
        <source>Attributes are not permitted on 'inherit' declarations</source>
        <target state="translated">Gli attributi non sono consentiti in dichiarazioni 'inherit'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityIllegalOnInherit">
        <source>Accessibility modifiers are not permitted on an 'inherits' declaration</source>
        <target state="translated">Modificatori di accessibilità non consentiti in una dichiarazione 'inherits'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInheritDeclarationsCannotHaveAsBindings">
        <source>'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding.</source>
        <target state="translated">Le dichiarazioni 'inherit' non possono contenere binding 'as'. Per accedere ai membri della classe di base quando si esegue l'override di un metodo, è possibile usare la sintassi 'base.SomeMember' dove 'base' è una parola chiave. Rimuovere il binding 'as'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalHere">
        <source>Attributes are not allowed here</source>
        <target state="translated">Gli attributi non sono consentiti in questa posizione</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for type abbreviations</source>
        <target state="translated">Modificatori di accessibilità non consentiti in questa posizione per le abbreviazioni di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumTypesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for enum types</source>
        <target state="translated">I modificatori di accessibilità non sono consentiti in questa posizione per i tipi enumerazione</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAllEnumFieldsRequireValues">
        <source>All enum fields must be given values</source>
        <target state="translated">È necessario assegnare valori a tutti i campi di enumerazione</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInlineAssemblyCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on inline assembly code types</source>
        <target state="translated">Modificatori di accessibilità non consentiti in tipi di codice assembly inline</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIdentifier">
        <source>Unexpected identifier: '{0}'</source>
        <target state="translated">Identificatore non previsto: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnionCasesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">I modificatori di accessibilità non sono consentiti in casi di unione. Usare 'type U = internal ...' o 'type U = private ...' per assegnare un'accessibilità all'intera rappresentazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on enumeration fields</source>
        <target state="translated">Modificatori di accessibilità non consentiti in campi di enumerazione</target>
        <note />
      </trans-unit>
      <trans-unit id="parsConsiderUsingSeparateRecordType">
        <source>Consider using a separate record type instead</source>
        <target state="translated">Provare invece a utilizzare un tipo di record separato</target>
        <note />
      </trans-unit>
      <trans-unit id="parsRecordFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Modificatori di accessibilità non consentiti in campi di record. Utilizzare 'type R = internal ...' o 'type R = private ...' per assegnare un'accessibilità all'intera rappresentazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsLetAndForNonRecBindings">
        <source>The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings</source>
        <target state="translated">Il formato di dichiarazione 'let ... and ...' per binding non ricorsivi non è usato nel codice F#. Provare a usare una sequenza di binding 'let'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedParen">
        <source>Unmatched '('</source>
        <target state="translated">'(' senza corrispondenza</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessivePatternsShouldBeSpacedOrTupled">
        <source>Successive patterns should be separated by spaces or tupled</source>
        <target state="translated">I criteri successivi devono essere separati da spazi o inclusi in tuple</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoMatchingInForLet">
        <source>No matching 'in' found for this 'let'</source>
        <target state="translated">Nessun 'in' corrispondente trovato per 'let'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorInReturnForLetIncorrectIndentation">
        <source>Error in the return expression for this 'let'. Possible incorrect indentation.</source>
        <target state="translated">Errore nell'espressione restituita per 'let'. Il rientro potrebbe non essere corretto.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterLet">
        <source>The block following this '{0}' is unfinished. Every code block is an expression and must have a result. '{1}' cannot be the final code element in a block. Consider giving this block an explicit result.</source>
        <target state="translated">Il blocco che segue questo elemento '{0}' non contiene un elemento finale. Ogni blocco di codice è un'espressione e deve includere un risultato. '{1}' non può essere l'elemento di codice finale di un blocco. Provare ad assegnare un risultato esplicito a questo blocco.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIncompleteIf">
        <source>Incomplete conditional. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Espressione condizionale incompleta. È previsto 'if &lt;expr&gt; then &lt;expr&gt;' o 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAssertIsNotFirstClassValue">
        <source>'assert' may not be used as a first class value. Use 'assert &lt;expr&gt;' instead.</source>
        <target state="translated">Non è possibile usare 'assert' come valore di prima classe. Usare 'assert &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">È previsto un identificatore</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInOrEqualExpected">
        <source>'in' or '=' expected</source>
        <target state="translated">Previsto 'in' o '='</target>
        <note />
      </trans-unit>
      <trans-unit id="parsArrowUseIsLimited">
        <source>The use of '-&gt;' in sequence and computation expressions is limited to the form 'for pat in expr -&gt; expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions.</source>
        <target state="translated">L'uso di '-&gt;' in espressioni sequenza e di calcolo è limitato al formato 'for crit in expr -&gt; expr'. Usare la sintassi 'for ... in ... do ... yield...' per generare elementi in espressioni sequenza più complesse.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessiveArgsShouldBeSpacedOrTupled">
        <source>Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized</source>
        <target state="translated">Gli argomenti successivi devono essere separati da spazi o inclusi in tuple, mentre gli argomenti che prevedono applicazioni di metodi o funzioni devono essere racchiusi tra parentesi</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracket">
        <source>Unmatched '['</source>
        <target state="translated">'[' senza corrispondenza</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingQualificationAfterDot">
        <source>Missing qualification after '.'</source>
        <target state="translated">Qualificazione mancante dopo '.'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsParenFormIsForML">
        <source>In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array</source>
        <target state="translated">Nel codice F# è possibile usare 'espr.[espr]'. Per indicare che la prima espressione è una matrice, potrebbe essere necessaria un'annotazione di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuote">
        <source>Mismatched quotation, beginning with '{0}'</source>
        <target state="translated">Quotation non corrispondente con '{0}' iniziale</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatched">
        <source>Unmatched '{0}'</source>
        <target state="translated">'{0}' senza corrispondenza</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracketBar">
        <source>Unmatched '[|'</source>
        <target state="translated">'[|' senza corrispondenza</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBrace">
        <source>Unmatched '{{'</source>
        <target state="translated">'{{' senza corrispondenza</target>
        <note />
      </trans-unit>
      <trans-unit id="parsFieldBinding">
        <source>Field bindings must have the form 'id = expr;'</source>
        <target state="translated">Il formato dei binding di campi deve essere 'id = expr;'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMemberIllegalInObjectImplementation">
        <source>This member is not permitted in an object implementation</source>
        <target state="translated">Membro non consentito in un'implementazione di oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingFunctionBody">
        <source>Missing function body</source>
        <target state="translated">Corpo funzione mancante</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxErrorInLabeledType">
        <source>Syntax error in labelled type argument</source>
        <target state="translated">Errore di sintassi in argomento tipo con etichetta</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedInfixOperator">
        <source>Unexpected infix operator in type expression</source>
        <target state="translated">Operatore infisso non previsto in espressione di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultiArgumentGenericTypeFormDeprecated">
        <source>The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident&lt;typ,...,typ&gt;' instead</source>
        <target state="translated">La sintassi '(typ,...,typ) ident' non è usata nel codice F#. Provare a usare 'ident&lt;typ,...,typ&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidLiteralInType">
        <source>Invalid literal in type</source>
        <target state="translated">Valore letterale non valido nel tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedOperatorForUnitOfMeasure">
        <source>Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'.</source>
        <target state="translated">Operatore infisso non previsto in espressione di unità di misura. Operatori validi: '*', '/' e '^'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIntegerLiteralForUnitOfMeasure">
        <source>Unexpected integer literal in unit-of-measure expression</source>
        <target state="translated">Valore letterale Integer non previsto in espressione di unità di misura</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedTypeParameter">
        <source>Syntax error: unexpected type parameter specification</source>
        <target state="translated">Errore di sintassi: specifica di parametro di tipo non prevista</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuotationName">
        <source>Mismatched quotation operator name, beginning with '{0}'</source>
        <target state="translated">Nome operatore di quotation non corrispondente con '{0}' iniziale</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseMustBeginWithUpperCase">
        <source>Active pattern case identifiers must begin with an uppercase letter</source>
        <target state="translated">Gli identificatori di distinzione tra maiuscole e minuscole nei criteri di ricerca attivi devono iniziare con una lettera maiuscola</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseContainsPipe">
        <source>The '|' character is not permitted in active pattern case identifiers</source>
        <target state="translated">Il carattere '|' non è consentito in identificatori di distinzione tra maiuscole e minuscole di criteri attivi</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalDenominatorForMeasureExponent">
        <source>Denominator must not be 0 in unit-of-measure exponent</source>
        <target state="translated">Il denominatore non deve essere 0 nell'esponente dell'unità di misura</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoEqualShouldFollowNamespace">
        <source>No '=' symbol should follow a 'namespace' declaration</source>
        <target state="translated">La dichiarazione 'namespace' non deve essere seguita da simboli '='</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleStructEndDeprecated">
        <source>The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">La sintassi 'module ... = struct .. end' non è usata nel codice F#. Provare a usare 'module ... = begin .. end'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleSigEndDeprecated">
        <source>The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">La sintassi 'module ... : sig .. end' non è usata nel codice F#. Provare a usare 'module ... = begin .. end'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticFieldUsedWhenInstanceFieldExpected">
        <source>A static field was used where an instance field is expected</source>
        <target state="translated">È stato utilizzato un campo statico in una posizione in cui era previsto un campo di istanza</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodNotAccessible">
        <source>Method '{0}' is not accessible from this code location</source>
        <target state="translated">Il metodo '{0}' non è accessibile da questa posizione di codice</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplicitMeasureFollowingSlash">
        <source>Implicit product of measures following /</source>
        <target state="translated">Prodotto di misure implicito dopo /</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedMeasureAnon">
        <source>Unexpected SynMeasure.Anon</source>
        <target state="translated">SynMeasure.Anon imprevisto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonZeroConstantCannotHaveGenericUnit">
        <source>Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.</source>
        <target state="translated">Le costanti non zero non possono avere unità generiche. Per lo zero generico, scrivere 0.0&lt;_&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSeqResultsUseYield">
        <source>In sequence expressions, results are generated using 'yield'</source>
        <target state="translated">Nelle espressioni sequenza i risultati sono generati mediante 'yield'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedBigRationalConstant">
        <source>Unexpected big rational constant</source>
        <target state="translated">Costante razionale grande non prevista</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForUnitsOfMeasure">
        <source>Units-of-measure are only supported on float, float32, decimal, and integer types.</source>
        <target state="translated">Unità di misura supportata solo in tipi float, float32, decimal e Integer con segno</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstUint16Array">
        <source>Unexpected Const_uint16array</source>
        <target state="translated">Const_uint16array non previsto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstByteArray">
        <source>Unexpected Const_bytearray</source>
        <target state="translated">Const_bytearray non previsto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterRequiresName">
        <source>A parameter with attributes must also be given a name, e.g. '[&lt;Attribute&gt;] Name : Type'</source>
        <target state="translated">A un parametro con attributi deve essere inoltre assegnato un nome, ad esempio '[&lt;Attribute&gt;] Name : Type'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnValuesCannotHaveNames">
        <source>Return values cannot have names</source>
        <target state="translated">I valori restituiti non possono avere nomi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberKindPropertyGetSetNotExpected">
        <source>MemberKind.PropertyGetSet only expected in parse trees</source>
        <target state="translated">MemberKind.PropertyGetSet previsto solo in strutture ad albero di analisi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainValues">
        <source>Namespaces cannot contain values. Consider using a module to hold your value declarations.</source>
        <target state="translated">Gli spazi dei nomi non possono contenere valori. Provare a utilizzare un modulo che contenga le dichiarazioni dei valori.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainExtensionMembers">
        <source>Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.</source>
        <target state="translated">Gli spazi dei nomi non possono contenere membri di estensione, tranne che nello stesso gruppo di dichiarazione di file e spazio dei nomi in cui è definito il tipo. Provare a usare un modulo che contenga le dichiarazioni dei membri di estensione.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributes">
        <source>Multiple visibility attributes have been specified for this identifier</source>
        <target state="translated">Più attributi di visibilità specificati per l'identificatore</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributesWithLet">
        <source>Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions.</source>
        <target state="translated">Sono stati specificati più attributi di visibilità per l'identificatore. I binding 'let' nelle classi sono sempre privati, così come eventuali binding 'let' nelle espressioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForRelationalOperator">
        <source>The name '({0})' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">Il nome '({0})' non può essere utilizzato come nome di membro. Per definire semantica di confronto per un tipo, implementare l'interfaccia 'System.IComparable'. Se si definisce un membro statico per l'utilizzo da parte di altri linguaggi CLI, utilizzare il nome '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForEquality">
        <source>The name '({0})' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">Il nome '({0})' non può essere utilizzato come nome di membro. Per definire semantica di uguaglianza per un tipo, eseguire l'override del membro 'Object.Equals'. Se si definisce un membro statico per l'utilizzo da parte di altri linguaggi CLI, utilizzare il nome '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberName">
        <source>The name '({0})' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">Il nome '({0})' non può essere usato come nome di membro. Se si definisce un membro statico per l'uso da parte di altri linguaggi CLI, usare il nome '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameFixedTypes">
        <source>The name '({0})' should not be used as a member name because it is given a standard definition in the F# library over fixed types</source>
        <target state="translated">Il nome '({0})' non può essere usato come nome di membro perché è associato a una definizione standard nella libreria F# sui tipi fissi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionRelational">
        <source>The '{0}' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type.</source>
        <target state="translated">In genere, l'operatore '{0}' non deve essere ridefinito. Per definire semantica di confronto con overload per un determinato tipo, implementare l'interfaccia 'System.IComparable' nella definizione del tipo stesso.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionEquality">
        <source>The '{0}' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type.</source>
        <target state="translated">In genere, l'operatore '{0}' non deve essere ridefinito. Per definire semantica di uguaglianza per un tipo, eseguire l'override del membro 'Object.Equals' nella definizione del tipo stesso.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinition">
        <source>The '{0}' operator should not normally be redefined. Consider using a different operator name</source>
        <target state="translated">In genere, l'operatore '{0}' non deve essere ridefinito. Provare a utilizzare un altro nome di operatore</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexOperatorDefinition">
        <source>The '{0}' operator cannot be redefined. Consider using a different operator name</source>
        <target state="translated">Non è possibile ridefinire l'operatore '{0}'. Provare a usare un altro nome di operatore</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectModuleOrNamespaceParent">
        <source>Expected module or namespace parent {0}</source>
        <target state="translated">Previsto elemento padre di modulo o spazio dei nomi {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">Il tipo di struct, record o unione '{0}' implementa l'interfaccia 'System.IComparable' in modo esplicito. È necessario applicare l'attributo 'CustomComparison' al tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsGenericIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable&lt;_&gt;' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.</source>
        <target state="translated">Il tipo di struct, record o unione '{0}' implementa l'interfaccia 'System.IComparable&lt;_&gt;' in modo esplicito. È necessario applicare l'attributo 'CustomComparison' al tipo, nonché fornire un'implementazione coerente dell'interfaccia non generica System.IComparable.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">Il tipo di struct, record o unione '{0}' implementa l'interfaccia 'System.IStructuralComparable' in modo esplicito. Applicare l'attributo 'CustomComparison' al tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordFieldInconsistentTypes">
        <source>This record contains fields from inconsistent types</source>
        <target state="translated">Questo record contiene campi di tipi incoerenti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportStubsCannotBeInlined">
        <source>DLLImport stubs cannot be inlined</source>
        <target state="translated">Non è possibile impostare come inline gli stub DLLImport</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCanOnlyBindThisAtMemberDeclaration">
        <source>Structs may only bind a 'this' parameter at member declarations</source>
        <target state="translated">Gli struct possono eseguire il binding solo di un parametro 'this' in dichiarazioni di membro</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedExprAtRecInfPoint">
        <source>Unexpected expression at recursive inference point</source>
        <target state="translated">Espressione non prevista in punto di inferenza ricorsiva</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLessGenericBecauseOfAnnotation">
        <source>This code is less generic than required by its annotations because the explicit type variable '{0}' could not be generalized. It was constrained to be '{1}'.</source>
        <target state="translated">Il codice è meno generico di quanto richiesto dalle relative annotazioni perché non è possibile generalizzare la variabile di tipo esplicito '{0}'. Sono presenti vincoli per i quali essa deve essere '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstrainedTypeVariableCannotBeGeneralized">
        <source>One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types</source>
        <target state="translated">Non è stato possibile generalizzare una o più variabili di tipi di funzione o classi esplicite per questo binding perché sono state vincolate ad altri tipi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericParameterHasBeenConstrained">
        <source>A generic type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Un parametro di tipo generico è utilizzato in modo da dovere essere sempre '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterHasBeenConstrained">
        <source>This type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Questo parametro di tipo è stato utilizzato in modo da dover essere sempre '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParametersInferredAreNotStable">
        <source>The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</source>
        <target state="translated">I parametri di tipo dedotti per il valore non sono stabili nell'ambito della cancellazione di abbreviazioni di tipo. Questa condizione è dovuta all'uso di abbreviazioni di tipo che eliminano o riordinano i parametri di tipo, ad esempio \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nProvare a dichiarare i parametri di tipo per questo valore in modo esplicito, ad esempio \n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeParameterInvalid">
        <source>Explicit type parameters may only be used on module or member bindings</source>
        <target state="translated">I parametri di tipo esplicito possono essere usati solo in binding di membri o moduli</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridingMethodRequiresAllOrNoTypeParameters">
        <source>You must explicitly declare either all or no type parameters when overriding a generic abstract method</source>
        <target state="translated">È necessario dichiarare in modo esplicito tutti o nessuno dei parametri di tipo quando si esegue l'override di un metodo astratto generico</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldsDoNotDetermineUniqueRecordType">
        <source>The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type</source>
        <target state="translated">Le etichette di campo e il tipo previsto di questo criterio o espressione del record non determinano in modo univoco un tipo di record corrispondente</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldAppearsTwiceInRecord">
        <source>The field '{0}' appears twice in this record expression or pattern</source>
        <target state="translated">Il campo '{0}' è presente due volte nei criteri o nell'espressione del record</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnknownUnion">
        <source>Unknown union case</source>
        <target state="translated">Case di unione sconosciuto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotSufficientlyGenericBecauseOfScope">
        <source>This code is not sufficiently generic. The type variable {0} could not be generalized because it would escape its scope.</source>
        <target state="translated">Questo codice non è sufficientemente generico. Non è stato possibile generalizzare la variabile di tipo {0} perché non sarebbe compresa nel relativo ambito.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyRequiresExplicitTypeParameters">
        <source>A property cannot have explicit type parameters. Consider using a method instead.</source>
        <target state="translated">Una proprietà non può avere parametri di tipo esplicito. Provare a utilizzare invece un metodo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorCannotHaveTypeParameters">
        <source>A constructor cannot have explicit type parameters. Consider using a static construction method instead.</source>
        <target state="translated">Un costruttore non può avere parametri di tipo esplicito. Provare a utilizzare invece un metodo di costruzione statico.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInstanceMemberRequiresTarget">
        <source>This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'.</source>
        <target state="translated">In questo membro di istanza è necessario un parametro per rappresentare l'oggetto richiamato. Rendere il membro statico oppure utilizzare la notazione 'member x.Member(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertyInSyntaxTree">
        <source>Unexpected source-level property specification in syntax tree</source>
        <target state="translated">Specifica di proprietà a livello di origine non prevista nella struttura ad albero della sintassi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializerRequiresArgument">
        <source>A static initializer requires an argument</source>
        <target state="translated">Un inizializzatore statico richiede un argomento</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorRequiresArgument">
        <source>An object constructor requires an argument</source>
        <target state="translated">Un costruttore di oggetto richiede un argomento</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticMemberShouldNotHaveThis">
        <source>This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'.</source>
        <target state="translated">Questo membro statico non deve contenere un parametro 'this'. Provare a utilizzare la notazione 'member Member(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitStaticInitializerSyntax">
        <source>An explicit static initializer should use the syntax 'static new(args) = expr'</source>
        <target state="translated">Un inizializzatore statico esplicito deve utilizzare la sintassi 'static new(args) = expr'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitObjectConstructorSyntax">
        <source>An explicit object constructor should use the syntax 'new(args) = expr'</source>
        <target state="translated">Un costruttore di oggetto esplicito deve usare la sintassi 'new(args) = expr'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertySpec">
        <source>Unexpected source-level property specification</source>
        <target state="translated">Specifica di proprietà a livello di origine non prevista</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionFormDeprecated">
        <source>This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions.</source>
        <target state="translated">Questo formato di espressione di oggetto non è utilizzato in F#. Utilizzare 'member this.MemberName... = ...' per definire implementazioni di membro in espressioni di oggetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDeclaration">
        <source>Invalid declaration</source>
        <target state="translated">Dichiarazione non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesInvalidInPatterns">
        <source>Attributes are not allowed within patterns</source>
        <target state="translated">Attributi non consentiti all'interno di criteri</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitTypeArguments">
        <source>The generic function '{0}' must be given explicit type argument(s)</source>
        <target state="translated">Alla funzione generica '{0}' devono essere assegnati uno o più argomenti tipo espliciti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoesNotAllowExplicitTypeArguments">
        <source>The method or function '{0}' should not be given explicit type argument(s) because it does not declare its type parameters explicitly</source>
        <target state="translated">Al metodo o funzione '{0}' non devono essere assegnati argomenti tipo espliciti perché i relativi parametri di tipo non vengono dichiarati in modo esplicito</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterArityMismatch">
        <source>This value, type or method expects {0} type parameter(s) but was given {1}</source>
        <target state="translated">Questo valore, tipo o metodo prevede {0} parametro/i di tipo, tuttavia il numero di parametri specificati è pari a {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultStructConstructorCall">
        <source>The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization</source>
        <target state="translated">Il costruttore di inizializzazione zero predefinito di un tipo di struct può essere utilizzato solo se tutti i campi del tipo di struct accettano l'inizializzazione predefinita</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindIDisposable">
        <source>Couldn't find Dispose on IDisposable, or it was overloaded</source>
        <target state="translated">Dispose non è stato trovato in IDisposable oppure si è verificato un overload</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonLiteralCannotBeUsedInPattern">
        <source>This value is not a literal and cannot be used in a pattern</source>
        <target state="translated">Questo valore non è un valore letterale e non è possibile utilizzarlo in un criterio</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsReadonly">
        <source>This field is readonly</source>
        <target state="translated">Il campo è di sola lettura</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameArgumentsMustAppearLast">
        <source>Named arguments must appear after all other arguments</source>
        <target state="translated">Gli argomenti denominati devono essere aggiunti dopo tutti gli altri argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitLambda">
        <source>This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking {0} arguments.</source>
        <target state="translated">Questo valore di funzione è utilizzato per costruire un tipo delegato la cui firma include un argomento byref. È necessario utilizzare un'espressione lambda esplicita con {0} argomenti.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCannotBeEnumerated">
        <source>The type '{0}' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method</source>
        <target state="translated">Il tipo '{0}' non è un tipo i cui valori possono essere enumerati con questa sintassi, ovvero non è compatibile con seq&lt;_&gt;, IEnumerable&lt;_&gt; o IEnumerable e non dispone di un metodo GetEnumerator</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMixtureOfRecursiveForms">
        <source>This recursive binding uses an invalid mixture of recursive forms</source>
        <target state="translated">Questo binding ricorsivo usa una combinazione non valida di formati ricorsivi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectConstructionExpression">
        <source>This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.</source>
        <target state="translated">Espressione di costruzione di oggetti non valida. I costruttori di oggetto espliciti devono chiamare un costruttore alternativo o inizializzare tutti i campi dell'oggetto e specificare una chiamata al costruttore di super classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraint">
        <source>Invalid constraint</source>
        <target state="translated">Vincolo non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraintTypeSealed">
        <source>Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution</source>
        <target state="translated">Vincolo non valido: il tipo usato per il vincolo è sealed, il che significa che il vincolo può essere soddisfatto al massimo da una soluzione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumConstraint">
        <source>An 'enum' constraint must be of the form 'enum&lt;type&gt;'</source>
        <target state="translated">Il formato di un vincolo 'enum' deve essere 'enum&lt;tipo&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNewConstraint">
        <source>'new' constraints must take one argument of type 'unit' and return the constructed type</source>
        <target state="translated">I vincoli 'new' devono usare un argomento di tipo 'unit' e restituire il tipo costruito</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPropertyType">
        <source>This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -&gt; ty3'. Properties returning functions should have types of the form '(ty1 -&gt; ty2)'.</source>
        <target state="translated">La proprietà contiene un tipo non valido. Le proprietà che usano più argomenti di indicizzatore devono avere tipi nel formato 'ty1 * ty2 -&gt; ty3'. Le proprietà che restituiscono funzioni devono avere tipi nel formato '(ti1 -&gt; ti2)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureMarkWithAttribute">
        <source>Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.</source>
        <target state="translated">È previsto un parametro di unità di misura, non di tipo. I parametri di unità di misura espliciti devono essere contrassegnati con l'attributo [&lt;Measure&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeParameter">
        <source>Expected type parameter, not unit-of-measure parameter</source>
        <target state="translated">È previsto un parametro di tipo, non di unità di misura</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeNotUnitOfMeasure">
        <source>Expected type, not unit-of-measure</source>
        <target state="translated">È previsto un tipo, non un'unità di misura</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureNotType">
        <source>Expected unit-of-measure, not type</source>
        <target state="translated">È prevista un'unità di misura, non un tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUnitsOfMeasurePrefix">
        <source>Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.</source>
        <target state="translated">Non è possibile usare l'unità di misura come argomenti di prefisso per un tipo. Riscrivere come argomenti di suffisso tra parentesi quadre.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnitsOfMeasureInvalidInTypeConstructor">
        <source>Unit-of-measure cannot be used in type constructor application</source>
        <target state="translated">Non è possibile usare un'unità di misura in un'applicazione del costruttore di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireBuilderMethod">
        <source>This control construct may only be used if the computation expression builder defines a '{0}' method</source>
        <target state="translated">Questo costrutto di controllo può essere utilizzato solo se il generatore di espressioni di calcolo definisce un metodo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoNestedTypes">
        <source>This type has no nested types</source>
        <target state="translated">Questo tipo non dispone di tipi annidati</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSymbolInTypeExpression">
        <source>Unexpected {0} in type expression</source>
        <target state="translated">Elemento {0} non previsto in espressione di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterInvalidAsTypeConstructor">
        <source>Type parameter cannot be used as type constructor</source>
        <target state="translated">Non è possibile usare un parametro di tipo come costruttore di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalSyntaxInTypeExpression">
        <source>Illegal syntax in type expression</source>
        <target state="translated">Sintassi non valida in espressione di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousUnitsOfMeasureCannotBeNested">
        <source>Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression</source>
        <target state="translated">Non è possibile annidare unità di misura anonime all'interno di un'altra espressione di unità di misura</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousTypeInvalidInDeclaration">
        <source>Anonymous type variables are not permitted in this declaration</source>
        <target state="translated">Variabili di tipo anonime non consentite in questa dichiarazione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSlashInType">
        <source>Unexpected / in type</source>
        <target state="translated">/ non previsto in tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedTypeArguments">
        <source>Unexpected type arguments</source>
        <target state="translated">Argomenti tipo non previsti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsOnlyOnMembers">
        <source>Optional arguments are only permitted on type members</source>
        <target state="translated">Gli argomenti facoltativi sono consentiti solo in membri di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameNotBoundInPattern">
        <source>Name '{0}' not bound in pattern context</source>
        <target state="translated">Nome '{0}' non associato nel contesto dei criteri</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNonPrimitiveLiteralInPatternMatch">
        <source>Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when &lt;variable&gt; = &lt;constant&gt;' at the end of the match clause.</source>
        <target state="translated">Le costanti letterali numeriche non primitive non possono essere usate in criteri di ricerca perché è possibile mapparle a più tipi diversi tramite un modulo NumericLiteral. Provare a sostituire con una variabile e usare 'when &lt;variabile&gt; = &lt;costante&gt;' alla fine della clausola di ricerca.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentUsage">
        <source>Type arguments cannot be specified here</source>
        <target state="translated">Non è possibile specificare argomenti tipo in questa posizione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireActivePatternWithOneResult">
        <source>Only active patterns returning exactly one result may accept arguments</source>
        <target state="translated">Solo i criteri attivi che restituiscono esattamente un risultato possono accettare argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidArgForParameterizedPattern">
        <source>Invalid argument to parameterized pattern label</source>
        <target state="translated">Argomento non valido per un'etichetta di criterio con parametri</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexIntoActivePatternArray">
        <source>Internal error. Invalid index into active pattern array</source>
        <target state="translated">Errore interno. Indice non valido nella matrice di criteri attivi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseDoesNotTakeArguments">
        <source>This union case does not take arguments</source>
        <target state="translated">Questo case di unione non accetta argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseRequiresOneArgument">
        <source>This union case takes one argument</source>
        <target state="translated">Questo case di unione accetta un argomento</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseExpectsTupledArguments">
        <source>This union case expects {0} arguments in tupled form</source>
        <target state="translated">Questo case di unione prevede {0} argomenti sotto forma di tupla</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotStatic">
        <source>Field '{0}' is not static</source>
        <target state="translated">Il campo '{0}' non è statico</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNotLiteralCannotBeUsedInPattern">
        <source>This field is not a literal and cannot be used in a pattern</source>
        <target state="translated">Questo campo non è un valore letterale e non è possibile utilizzarlo in un criterio</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireVarConstRecogOrLiteral">
        <source>This is not a variable, constant, active recognizer or literal</source>
        <target state="translated">Questo elemento non è una variabile, una costante, un valore letterale o un riconoscimento attivo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPattern">
        <source>This is not a valid pattern</source>
        <target state="translated">Questo non è un criterio valido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseWhenPatternGuard">
        <source>Character range matches have been removed in F#. Consider using a 'when' pattern guard instead.</source>
        <target state="translated">Corrispondenze dell'intervallo di caratteri rimosse in F#. Provare a utilizzare invece un'espressione guard con criterio 'when'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalPattern">
        <source>Illegal pattern</source>
        <target state="translated">Criterio non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxErrorUnexpectedQMark">
        <source>Syntax error - unexpected '?' symbol</source>
        <target state="translated">Errore di sintassi: previsto simbolo '?'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionCountMisMatch">
        <source>Expected {0} expressions, got {1}</source>
        <target state="translated">Previste {0} espressioni, ottenute {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExprUndelayed">
        <source>TcExprUndelayed: delayed</source>
        <target state="translated">TcExprUndelayed: con ritardo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionRequiresSequence">
        <source>This expression form may only be used in sequence and computation expressions</source>
        <target state="translated">Questo formato di espressione può essere utilizzato solo in espressioni sequenza e di calcolo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectExpressionSyntaxForm">
        <source>Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.</source>
        <target state="translated">Espressione oggetto non valida. Gli oggetti senza override o interfacce devono usare il formato di espressione 'new Type(args)' senza parentesi graffe.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectSequenceOrRecordExpression">
        <source>Invalid object, sequence or record expression</source>
        <target state="translated">Espressione record, sequenza o oggetto non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSequenceExpressionSyntaxForm">
        <source>Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq {{ ... }}'</source>
        <target state="translated">Espressione di calcolo, sequenza o record non valida. Il formato delle espressioni sequenza deve essere 'seq {{ ... }}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionWithIfRequiresParenthesis">
        <source>This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression</source>
        <target state="translated">Questa espressione elenco o matrice include un elemento nel formato 'if ... then ... else'. Racchiudere l'espressione in parentesi per indicare che si tratta di un elemento singolo dell'elenco o della matrice allo scopo di eliminare l'ambiguità rispetto a un elenco generato mediante un'espressione sequenza</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseFormatString">
        <source>Unable to parse format string '{0}'</source>
        <target state="translated">Non è possibile analizzare la stringa di formato '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcListLiteralMaxSize">
        <source>This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.</source>
        <target state="translated">Questa espressione elenco supera la dimensione massima per i valori letterali di elenco. Usare una matrice per valori letterali più grandi e chiamare Array.ToList.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresObjectConstructor">
        <source>The expression form 'expr then expr' may only be used as part of an explicit object constructor</source>
        <target state="translated">Il formato di espressione 'expr then expr' può essere utilizzato solo all'interno di un costruttore di oggetto esplicito</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentsCannotBeUsedInMemberTraits">
        <source>Named arguments cannot be given to member trait calls</source>
        <target state="translated">Non è possibile assegnare argomenti denominati a chiamate di tratti del membro</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotValidEnumCaseName">
        <source>This is not a valid name for an enumeration case</source>
        <target state="translated">Nome non valido per un case di enumerazione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotMutable">
        <source>This field is not mutable</source>
        <target state="translated">Questo campo non è modificabile</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresListArrayOrSequence">
        <source>This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq {{ ... }}', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements</source>
        <target state="translated">Il costrutto può essere usato solo in espressioni sequenza, elenco e matrice, ad esempio espressioni nel formato 'seq {{ ... }}', '[ ... ]' o '[| ... |]'. Viene usata la sintassi 'for ... in ... do ... yield...' per generare elementi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpressions">
        <source>This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'.</source>
        <target state="translated">Questo costrutto può essere utilizzato solo in espressioni di calcolo. Per restituire un valore da una funzione ordinaria, è sufficiente scrivere l'espressione senza 'return'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresSequenceOrComputations">
        <source>This construct may only be used within sequence or computation expressions</source>
        <target state="translated">Questo costrutto può essere utilizzato solo in espressioni sequenza o di calcolo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpression">
        <source>This construct may only be used within computation expressions</source>
        <target state="translated">Questo costrutto può essere utilizzato solo in espressioni di calcolo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexerExpression">
        <source>Invalid indexer expression</source>
        <target state="translated">Espressione di indicizzatore non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
        <source>The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints</source>
        <target state="translated">L'operatore 'expr.[idx]' è stato usato in un oggetto di tipo non determinato in base alle informazioni precedenti a questo punto del programma. Provare ad aggiungere ulteriori vincoli di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromVariableType">
        <source>Cannot inherit from a variable type</source>
        <target state="translated">Non è possibile ereditare da un tipo di variabile</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsOnTypeParametersCannotTakeArguments">
        <source>Calls to object constructors on type parameters cannot be given arguments</source>
        <target state="translated">Non è possibile assegnare argomenti a chiamate a costruttori di oggetto in parametri di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCompiledNameAttributeMisused">
        <source>The 'CompiledName' attribute cannot be used with this language element</source>
        <target state="translated">Non è possibile usare l'attributo 'CompiledName' con questo elemento del linguaggio</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedTypeRequired">
        <source>'{0}' may only be used with named types</source>
        <target state="translated">'{0}' è utilizzabile solo con tipi denominati</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritCannotBeUsedOnInterfaceType">
        <source>'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead.</source>
        <target state="translated">Non è possibile usare 'inherit' in tipi di interfaccia. Provare invece a implementare l'interfaccia mediante 'interface ... with ... end'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewCannotBeUsedOnInterfaceType">
        <source>'new' cannot be used on interface types. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">Non è possibile usare 'new' in tipi di interfaccia. Provare a usare invece un'espressione di oggetto '{{ new ... with ... }}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractTypeCannotBeInstantiated">
        <source>Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">Non è possibile creare istanze di questo tipo perché è stato contrassegnato come astratto oppure non a tutti i metodi sono state assegnate implementazioni. Provare a usare invece un'espressione di oggetto '{{ new ... with ... }}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIDisposableTypeShouldUseNew">
        <source>It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value</source>
        <target state="translated">Per indicare che le risorse possono essere di proprietà del valore generato, è consigliabile usare la sintassi 'new Type(args)', invece di 'Type(args)' o di 'Type' come valore della funzione che rappresenta il costruttore, per creare oggetti che supportano l'interfaccia IDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxCanOnlyBeUsedToCreateObjectTypes">
        <source>'{0}' may only be used to construct object types</source>
        <target state="translated">'{0}' è utilizzabile solo per costruire tipi di oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresCall">
        <source>Constructors for the type '{0}' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.</source>
        <target state="translated">I costruttori per il tipo '{0}' devono chiamare direttamente o indirettamente il relativo costruttore di oggetto implicito. Utilizzare una chiamata al costruttore di oggetto implicito invece di un'espressione di record.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUndefinedField">
        <source>The field '{0}' has been given a value, but is not present in the type '{1}'</source>
        <target state="translated">Al campo '{0}' è stato assegnato un valore, tuttavia non è presente nel tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresAssignment">
        <source>No assignment given for field '{0}' of type '{1}'</source>
        <target state="translated">Nessuna assegnazione specificata per il campo '{0}' di tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExtraneousFieldsGivenValues">
        <source>Extraneous fields have been given values</source>
        <target state="translated">Sono stati assegnati valori a campi estranei</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
        <source>Only overrides of abstract and virtual members may be specified in object expressions</source>
        <target state="translated">Nelle espressioni di oggetto possono essere specificati solo override di membri astratti e virtuali</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoAbstractOrVirtualMemberFound">
        <source>The member '{0}' does not correspond to any abstract or virtual method available to override or implement.</source>
        <target state="translated">Il membro '{0}' non corrisponde ad alcun metodo astratto o virtuale disponibile per l'override o l'implementazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberFoundIsNotAbstractOrVirtual">
        <source>The type {0} contains the member '{1}' but it is not a virtual or abstract method that is available to override or implement.</source>
        <target state="translated">Il tipo {0} contiene il membro '{1}', ma non è un metodo virtuale o astratto disponibile per l'override o l'implementazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatch">
        <source>The member '{0}' does not accept the correct number of arguments. {1} argument(s) are expected, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">Il membro '{0}' non accetta il numero corretto di argomenti. Sono previsti {1} argomenti, ma ne sono stati specificati {2}. La firma richiesta è '{3}'.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatchOneOverload">
        <source>The member '{0}' does not accept the correct number of arguments. One overload accepts {1} arguments, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">Il membro '{0}' non accetta il numero corretto di argomenti. Un overload accetta {1} argomenti, ma ne sono stati specificati {2}. La firma richiesta è '{3}'.{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSimpleMethodNameRequired">
        <source>A simple method name is required here</source>
        <target state="translated">In questa posizione è necessario un nome di metodo semplice</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPredefinedTypeCannotBeUsedAsSuperType">
        <source>The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class</source>
        <target state="translated">I tipi System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate e System.Array non possono essere usati come tipi super in una classe o un'espressione di oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMustBeUsedWithNamedType">
        <source>'new' must be used with a named type</source>
        <target state="translated">'new' deve essere utilizzato con un tipo denominato</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCreateExtensionOfSealedType">
        <source>Cannot create an extension of a sealed type</source>
        <target state="translated">Non è possibile creare un'estensione di tipo Sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoArgumentsForRecordValue">
        <source>No arguments may be given when constructing a record value</source>
        <target state="translated">Non è possibile specificare argomenti durante la costruzione di un valore di record</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoInterfaceImplementationForConstructionExpression">
        <source>Interface implementations cannot be given on construction expressions</source>
        <target state="translated">Non è possibile specificare implementazioni di interfaccia in espressioni di costruzione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionCanOnlyBeUsedInClassTypes">
        <source>Object construction expressions may only be used to implement constructors in class types</source>
        <target state="translated">Le espressioni di costruzione degli oggetti possono essere utilizzate solo per implementare costruttori in tipi di classe</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
        <source>Only simple bindings of the form 'id = expr' can be used in construction expressions</source>
        <target state="translated">Solo i binding semplici nel formato 'id = expr' possono essere usati in espressioni di costruzione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectsMustBeInitializedWithObjectExpression">
        <source>Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field</source>
        <target state="translated">Gli oggetti devono essere inizializzati da un'espressione di costruzione degli oggetti che chiama un costruttore di oggetto ereditato e assegna un valore a ogni campo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedInterfaceType">
        <source>Expected an interface type</source>
        <target state="translated">Previsto tipo di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorForInterfacesDoNotTakeArguments">
        <source>Constructor expressions for interfaces do not take arguments</source>
        <target state="translated">Le espressioni dei costruttori per le interfacce non utilizzano argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresArguments">
        <source>This object constructor requires arguments</source>
        <target state="translated">Argomenti necessari per il costruttore di oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewRequiresObjectConstructor">
        <source>'new' may only be used with object constructors</source>
        <target state="translated">'new' può essere usato solo con costruttori di oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAtLeastOneOverrideIsInvalid">
        <source>At least one override did not correctly implement its corresponding abstract member</source>
        <target state="translated">Almeno un override non implementa correttamente il membro astratto corrispondente</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNumericLiteralRequiresModule">
        <source>This numeric literal requires that a module '{0}' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope</source>
        <target state="translated">Il valore letterale numerico richiede che nell'ambito sia presente un modulo '{0}' che definisce funzioni FromZero, FromOne, FromInt32, FromInt64 e FromString</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRecordConstruction">
        <source>Invalid record construction</source>
        <target state="translated">Costruzione record non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresRecordTypes">
        <source>The expression form {{ expr with ... }} may only be used with record types. To build object types use {{ new Type(...) with ... }}</source>
        <target state="translated">Il formato di espressione {{ expr with ... }} può essere utilizzato solo con tipi di record. Per compilare tipi di oggetto utilizzare {{ new Type(...) with ... }}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritedTypeIsNotObjectModelType">
        <source>The inherited type is not an object model type</source>
        <target state="translated">Il tipo ereditato non è un tipo di modello a oggetti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
        <source>Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors</source>
        <target state="translated">Le espressioni di costruzione degli oggetti (ad esempio espressioni di record con specifiche di ereditarietà) possono essere utilizzate solo per implementare costruttori in tipi di modello a oggetti. Utilizzare 'new ObjectType(args)' per costruire istanze di tipi di modello a oggetti all'esterno di costruttori</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyRecordInvalid">
        <source>'{{ }}' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.</source>
        <target state="translated">'{{ }}' non è un'espressione valida. I record devono includere almeno un campo. Le sequenze vuote vengono specificate mediante Seq.empty o un elenco vuoto '[]'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordTypeNeedConstructor">
        <source>This type is not a record type. Values of class and struct types must be created using calls to object constructors.</source>
        <target state="translated">Questo tipo non è un tipo di record. I valori di tipi di struct e classi devono essere creati mediante chiamate a costruttori di oggetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordType">
        <source>This type is not a record type</source>
        <target state="translated">Questo tipo non è un tipo di record</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInComputationExpression">
        <source>This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder {{ ... }}'.</source>
        <target state="translated">Questo costrutto è ambiguo all'interno di un'espressione di calcolo. È possibile scrivere le espressioni annidate con 'let _ = (...)' e i calcoli annidati con 'let! res = builder {{ ... }}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInSequenceExpression">
        <source>This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {{... }}'.</source>
        <target state="translated">Questo costrutto è ambiguo all'interno di un'espressione sequenza. È possibile scrivere le espressioni annidate con 'let _ = (...)' e le sequenze annidate con 'yield! seq {{... }}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoBangIllegalInSequenceExpression">
        <source>'do!' cannot be used within sequence expressions</source>
        <target state="translated">'do!' non può essere utilizzato in espressioni sequenza</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseForInSequenceExpression">
        <source>The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead.</source>
        <target state="translated">L'utilizzo di 'let! x = coll' in espressioni sequenza non è consentito. Utilizzare invece 'for x in coll'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryIllegalInSequenceExpression">
        <source>'try'/'with' cannot be used within sequence expressions</source>
        <target state="translated">Non è possibile usare 'try'/'with' in espressioni sequenza</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseYieldBangForMultipleResults">
        <source>In sequence expressions, multiple results are generated using 'yield!'</source>
        <target state="translated">Nelle espressioni sequenza più risultati sono generati mediante 'yield!'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAssignment">
        <source>Invalid assignment</source>
        <target state="translated">Assegnazione non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfTypeName">
        <source>Invalid use of a type name</source>
        <target state="translated">Uso non valido di un nome di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoAccessibleConstructor">
        <source>This type has no accessible object constructors</source>
        <target state="translated">Questo tipo non dispone di costruttori di oggetto accessibili</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfInterfaceType">
        <source>Invalid use of an interface type</source>
        <target state="translated">Uso non valido di un tipo di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfDelegate">
        <source>Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'.</source>
        <target state="translated">Utilizzo non valido di un costruttore di delegato. Utilizzare la sintassi 'new Type(args)' o semplicemente 'Type(args)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotStatic">
        <source>Property '{0}' is not static</source>
        <target state="translated">La proprietà '{0}' non è statica</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotReadable">
        <source>Property '{0}' is not readable</source>
        <target state="translated">La proprietà '{0}' non è leggibile</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLookupMayNotBeUsedHere">
        <source>This lookup cannot be used here</source>
        <target state="translated">Non è possibile usare questa ricerca in questa posizione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsStatic">
        <source>Property '{0}' is static</source>
        <target state="translated">La proprietà '{0}' è statica</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet1">
        <source>Property '{0}' cannot be set</source>
        <target state="translated">Non è possibile impostare la proprietà '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsCannotBeFirstClassValues">
        <source>Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</source>
        <target state="translated">I costruttori devono essere applicati ad argomenti e non possono essere usati come valori di prima classe. Se necessario, usare una funzione anonima '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
        <source>The syntax 'expr.id' may only be used with record labels, properties and fields</source>
        <target state="translated">La sintassi 'expr.id' è utilizzabile solo con campi, proprietà ed etichette di record</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsStatic">
        <source>Event '{0}' is static</source>
        <target state="translated">L'evento '{0}' è statico</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsNotStatic">
        <source>Event '{0}' is not static</source>
        <target state="translated">L'evento '{0}' non è statico</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentDidNotMatch">
        <source>The named argument '{0}' did not match any argument or mutable property</source>
        <target state="translated">L'argomento denominato '{0}' non corrisponde ad alcuna proprietà modificabile o argomento</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverloadsCannotHaveCurriedArguments">
        <source>One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.</source>
        <target state="translated">Uno o più overload del metodo hanno argomenti sottoposti a currying. Provare a riprogettare i membri in modo che accettino argomenti in tupla.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnnamedArgumentsDoNotFormPrefix">
        <source>The unnamed arguments do not form a prefix of the arguments of the method called</source>
        <target state="translated">Gli argomenti non denominati non costituiscono un prefisso degli argomenti del metodo chiamato</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
        <source>Static optimization conditionals are only for use within the F# library</source>
        <target state="translated">Le istruzioni condizionali di ottimizzazione statiche sono solo per l'utilizzo all'interno della libreria F#</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFormalArgumentIsNotOptional">
        <source>The corresponding formal argument is not optional</source>
        <target state="translated">L'argomento formale corrispondente non è facoltativo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOptionalAssignmentToPropertyOrField">
        <source>Invalid optional assignment to a property or field</source>
        <target state="translated">Assegnazione facoltativa non valida a proprietà o campo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegateConstructorMustBePassed">
        <source>A delegate constructor must be passed a single function value</source>
        <target state="translated">A un costruttore di delegato deve essere passato un singolo valore di funzione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindingCannotBeUseAndRec">
        <source>A binding cannot be marked both 'use' and 'rec'</source>
        <target state="translated">Un binding non può essere contrassegnato sia con 'use' che con 'rec'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileOnlyOnClassLetBindings">
        <source>The 'VolatileField' attribute may only be used on 'let' bindings in classes</source>
        <target state="translated">L'attributo 'VolatileField' può essere usato solo in binding 'let' nelle classi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesAreNotPermittedOnLetBindings">
        <source>Attributes are not permitted on 'let' bindings in expressions</source>
        <target state="translated">Attributi non consentiti in binding 'let' nelle espressioni</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultValueAttributeRequiresVal">
        <source>The 'DefaultValue' attribute may only be used on 'val' declarations</source>
        <target state="translated">L'attributo 'DefaultValue' può essere utilizzato solo in dichiarazioni 'val'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeRequiresMembers">
        <source>The 'ConditionalAttribute' attribute may only be used on members</source>
        <target state="translated">L'attributo 'ConditionalAttribute' può essere utilizzato solo nei membri</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidActivePatternName">
        <source>This is not a valid name for an active pattern</source>
        <target state="translated">Questo non è un nome valido per un criterio attivo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEntryPointAttributeRequiresFunctionInModule">
        <source>The 'EntryPointAttribute' attribute may only be used on function definitions in modules</source>
        <target state="translated">L'attributo 'EntryPointAttribute' può essere utilizzato solo in definizioni di funzioni nei moduli</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesCannotBeInline">
        <source>Mutable values cannot be marked 'inline'</source>
        <target state="translated">Non è possibile contrassegnare valori modificabili come 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesMayNotHaveGenericParameters">
        <source>Mutable values cannot have generic parameters</source>
        <target state="translated">I valori modificabili non possono avere parametri generici</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesSyntax">
        <source>Mutable function values should be written 'let mutable f = (fun args -&gt; ...)'</source>
        <target state="translated">I valori di funzione modificabili devono essere scritti come 'let mutable f = (fun args -&gt; ...)'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyFunctionsCanBeInline">
        <source>Only functions may be marked 'inline'</source>
        <target state="translated">Solo le funzioni possono essere contrassegnate come 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalAttributesForLiteral">
        <source>A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes</source>
        <target state="translated">Non è possibile assegnare l'attributo [&lt;ThreadStatic&gt;] o [&lt;ContextStatic&gt;] a un valore letterale</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeMutable">
        <source>A literal value cannot be marked 'mutable'</source>
        <target state="translated">Non è possibile contrassegnare un valore letterale come 'mutable'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeInline">
        <source>A literal value cannot be marked 'inline'</source>
        <target state="translated">Non è possibile contrassegnare un valore letterale come 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotHaveGenericParameters">
        <source>Literal values cannot have generic parameters</source>
        <target state="translated">I valori letterali non possono avere parametri generici</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstantExpression">
        <source>This is not a valid constant expression</source>
        <target state="translated">Espressione costante non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsInaccessible">
        <source>This type is not accessible from this code location</source>
        <target state="translated">Questo tipo non è accessibile da questa posizione di codice</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConditionInImportedAssembly">
        <source>Unexpected condition in imported assembly: failed to decode AttributeUsage attribute</source>
        <target state="translated">Condizione imprevista in assembly importato: non è stato possibile decodificare l'attributo AttributeUsage</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedAttributeTarget">
        <source>Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</source>
        <target state="translated">Destinazione attributo non riconosciuta. Le destinazioni valide sono 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElementUseDo">
        <source>This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module.</source>
        <target state="translated">Attributo non valido per l'utilizzo in questo elemento del linguaggio. Gli attributi degli assembly devono essere collegati a una dichiarazione 'do ()', se necessario all'interno di un modulo F#.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElement">
        <source>This attribute is not valid for use on this language element</source>
        <target state="translated">Attributo non valido per l'utilizzo in questo elemento del linguaggio</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgumentsCannotBeUsedInCustomAttribute">
        <source>Optional arguments cannot be used in custom attributes</source>
        <target state="translated">Non è possibile usare argomenti facoltativi in attributi personalizzati</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet0">
        <source>This property cannot be set</source>
        <target state="translated">Non è possibile impostare questa proprietà</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyOrFieldNotFoundInAttribute">
        <source>This property or field was not found on this custom attribute type</source>
        <target state="translated">La proprietà o il campo non è stato trovato in questo tipo di attributo personalizzato</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustBeReferenceType">
        <source>A custom attribute must be a reference type</source>
        <target state="translated">Un attributo personalizzato deve essere un tipo di riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeArgumentMismatch">
        <source>The number of args for a custom attribute does not match the expected number of args for the attribute constructor</source>
        <target state="translated">Il numero di argomenti per un attributo personalizzato non corrisponde al numero di argomenti previsti per il costruttore di attributo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustInvokeConstructor">
        <source>A custom attribute must invoke an object constructor</source>
        <target state="translated">Un attributo personalizzato deve richiamare un costruttore di oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeExpressionsMustBeConstructorCalls">
        <source>Attribute expressions must be calls to object constructors</source>
        <target state="translated">Le espressioni attributo devono costituire chiamate a costruttori di oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedAttribute">
        <source>This attribute cannot be used in this version of F#</source>
        <target state="translated">Non è possibile usare questo attributo in questa versione di F#</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidInlineSpecification">
        <source>Invalid inline specification</source>
        <target state="translated">Specifica inline non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBinding">
        <source>'use' bindings must be of the form 'use &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">Il formato dei binding 'use' deve essere 'use &lt;var&gt; = &lt;expr&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractMembersIllegalInAugmentation">
        <source>Abstract members are not permitted in an augmentation - they must be defined as part of the type itself</source>
        <target state="translated">Membri astratti non consentiti in un aumento. È necessario definirli come parte del tipo stesso</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodOverridesIllegalHere">
        <source>Method overrides and interface implementations are not permitted here</source>
        <target state="translated">Override di metodo e implementazioni di interfaccia non consentiti in questa posizione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoMemberFoundForOverride">
        <source>No abstract or interface member was found that corresponds to this override</source>
        <target state="translated">Nessun membro astratto o di interfaccia trovato corrispondente all'override</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverrideArityMismatch">
        <source>This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:{0}</source>
        <target state="translated">Questo override accetta un numero di argomenti diverso rispetto al membro astratto corrispondente. Sono stati trovati i membri astratti seguenti: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationAlreadyExists">
        <source>This method already has a default implementation</source>
        <target state="translated">Questo metodo dispone già di un'implementazione predefinita</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultAmbiguous">
        <source>The method implemented by this default is ambiguous</source>
        <target state="translated">Il metodo implementato da questa implementazione predefinita è ambiguo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoPropertyFoundForOverride">
        <source>No abstract property was found that corresponds to this override</source>
        <target state="translated">Nessuna proprietà astratta trovata corrispondente all'override</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractPropertyMissingGetOrSet">
        <source>This property overrides or implements an abstract property but the abstract property doesn't have a corresponding {0}</source>
        <target state="translated">Questa proprietà esegue l'override o l'implementazione di una proprietà astratta, tuttavia quest'ultima non dispone di un elemento {0} corrispondente</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSignatureForSet">
        <source>Invalid signature for set member</source>
        <target state="translated">Firma non valida per membro set</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMember">
        <source>This new member hides the abstract member '{0}'. Rename the member or use 'override' instead.</source>
        <target state="translated">Il nuovo membro nasconde il membro astratto '{0}'. Rinominare il membro o utilizzare 'override'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMemberWithSuffix">
        <source>This new member hides the abstract member '{0}' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead.</source>
        <target state="translated">Il nuovo membro nasconde il membro astratto '{0}' dopo la cancellazione di tuple, funzioni, unità di misura e/o tipi forniti. Rinominare il membro o utilizzare 'override'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializersIllegalInInterface">
        <source>Interfaces cannot contain definitions of static initializers</source>
        <target state="translated">Le interfacce non possono contenere definizioni di inizializzatori statici</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsIllegalInInterface">
        <source>Interfaces cannot contain definitions of object constructors</source>
        <target state="translated">Le interfacce non possono contenere definizioni di costruttori di oggetto</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOverridesIllegalInInterface">
        <source>Interfaces cannot contain definitions of member overrides</source>
        <target state="translated">Le interfacce non possono contenere definizioni di override di membri</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConcreteMembersIllegalInInterface">
        <source>Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.</source>
        <target state="translated">Le interfacce non possono contenere definizioni di membri concreti. Potrebbe essere necessario definire un costruttore nel tipo utilizzato per indicare che il tipo è una classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsDisallowedInExceptionAugmentation">
        <source>Constructors cannot be specified in exception augmentations</source>
        <target state="translated">I costruttori non possono essere specificati in aumenti di eccezione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCannotHaveConstructorWithNoArguments">
        <source>Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.</source>
        <target state="translated">Gli struct non possono avere un costruttore di oggetto senza argomenti. Si tratta di una limitazione imposta in tutti i linguaggi CLI perché gli struct supportano automaticamente un costruttore predefinito.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalForThisType">
        <source>Constructors cannot be defined for this type</source>
        <target state="translated">Non è possibile definire costruttori per questo tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
        <source>Recursive bindings that include member specifications can only occur as a direct augmentation of a type</source>
        <target state="translated">I binding ricorsivi che includono specifiche di membro possono rappresentare solo un aumento diretto di un tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimplePatternsInLetRec">
        <source>Only simple variable patterns can be bound in 'let rec' constructs</source>
        <target state="translated">Solo i criteri variabili semplici possono essere associati in costrutti 'let rec'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
        <source>Mutable 'let' bindings can't be recursive or defined in recursive modules or namespaces</source>
        <target state="translated">I binding 'let' modificabili non possono essere ricorsivi o definiti in moduli o spazi dei nomi ricorsivi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberIsNotSufficientlyGeneric">
        <source>This member is not sufficiently generic</source>
        <target state="translated">Questo membro non è sufficientemente generico</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralAttributeRequiresConstantValue">
        <source>A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. 'val x : int = 1'</source>
        <target state="translated">Una dichiarazione può essere solo l'attributo [&lt;Literal&gt;] se è specificato anche un valore costante, ad esempio 'val x : int = 1'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcValueInSignatureRequiresLiteralAttribute">
        <source>A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute</source>
        <target state="translated">In una firma è possibile assegnare solo un valore a una dichiarazione se quest'ultima contiene l'attributo [&lt;Literal&gt;]</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThreadStaticAndContextStaticMustBeStatic">
        <source>Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread</source>
        <target state="translated">Le variabili statiche a livello di thread e a livello di contesto devono essere statiche e associate all'attributo [&lt;DefaultValue&gt;] per indicare che il valore viene inizializzato sul valore predefinito in ogni nuovo thread</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileFieldsMustBeMutable">
        <source>Volatile fields must be marked 'mutable' and cannot be thread-static</source>
        <target state="translated">I campi volatili devono essere contrassegnati come 'mutable' e non possono essere statici a livello di thread</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUninitializedValFieldsMustBeMutable">
        <source>Uninitialized 'val' fields must be mutable and marked with the '[&lt;DefaultValue&gt;]' attribute. Consider using a 'let' binding instead of a 'val' field.</source>
        <target state="translated">I campi 'val' non inizializzati devono essere modificabili e contrassegnati con l'attributo '[&lt;DefaultValue&gt;]'. Provare a usare un binding 'let' invece di un campo 'val'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticValFieldsMustBeMutableAndPrivate">
        <source>Static 'val' fields in types must be mutable, private and marked with the '[&lt;DefaultValue&gt;]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type.</source>
        <target state="translated">I campi 'val' statici nei tipi devono essere modificabili, privati e contrassegnati con l'attributo '[&lt;DefaultValue&gt;]'. Tali campi vengono inizializzati sul valore 'Null' o 'zero' per il relativo tipo. Provare inoltre a usare un binding 'static let mutable' in un tipo di classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresName">
        <source>This field requires a name</source>
        <target state="translated">Per questo campo è necessario un nome</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNamespaceModuleTypeUnionName">
        <source>Invalid namespace, module, type or union case name</source>
        <target state="translated">Nome di case di unione, tipo, modulo o spazio dei nomi non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalFormForExplicitTypeDeclaration">
        <source>Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -&gt; resTy'. Parentheses may be required around 'resTy'</source>
        <target state="translated">Le dichiarazioni di tipo esplicito per i costruttori devono essere nel formato 'ty1 * ... * tyN -&gt; resTy'. Potrebbe essere necessario racchiudere 'resTy' tra parentesi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnTypesForUnionMustBeSameAsType">
        <source>Return types of union cases must be identical to the type being defined, up to abbreviations</source>
        <target state="translated">I tipi restituiti di case di unione devono essere identici al tipo in fase di definizione, fino alle abbreviazioni</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumerationLiteral">
        <source>This is not a valid value for an enumeration literal</source>
        <target state="translated">Valore non valido per un valore letterale di enumerazione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType1">
        <source>The type '{0}' is not an interface type</source>
        <target state="translated">Il tipo '{0}' non è un tipo di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDuplicateSpecOfInterface">
        <source>Duplicate specification of an interface</source>
        <target state="translated">Specifica di un'interfaccia duplicata</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldValIllegalHere">
        <source>A field/val declaration is not permitted here</source>
        <target state="translated">Dichiarazione di campo/valore non consentita in questa posizione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritIllegalHere">
        <source>A inheritance declaration is not permitted here</source>
        <target state="translated">Dichiarazione di ereditarietà non consentita in questa posizione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleRequiresQualifiedAccess">
        <source>This declaration opens the module '{0}', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.</source>
        <target state="translated">La dichiarazione apre il modulo '{0}' che è contrassegnato come 'RequireQualifiedAccess'. Modificare il codice in modo da utilizzare riferimenti qualificati agli elementi del modulo, ad esempio 'List.map' invece di 'map'. Questa modifica assicurerà l'affidabilità del codice quando verranno aggiunti nuovi costrutti alle librerie.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenUsedWithPartiallyQualifiedPath">
        <source>This declaration opens the namespace or module '{0}' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.</source>
        <target state="translated">Questa dichiarazione apre lo spazio dei nomi o modulo '{0}' tramite un percorso parziale. Modificare il codice in modo da utilizzare il percorso completo dello spazio dei nomi. Questa modifica renderà il codice più affidabile in caso di aggiunta di nuovi costrutti alle librerie F# e CLI.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLocalClassBindingsCannotBeInline">
        <source>Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.</source>
        <target state="translated">I binding di classe locali non possono essere contrassegnati come inline. Provare a spostare la definizione fuori della classe oppure non contrassegnarla come inline.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsMayNotHaveMembers">
        <source>Type abbreviations cannot have members</source>
        <target state="translated">Le abbreviazioni di tipo non possono avere membri</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCheckedAtCompileTime">
        <source>As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.</source>
        <target state="translated">A partire da F# 4.1, l'accessibilità delle abbreviazioni dei tipi viene verificata in fase di compilazione. Provare a modificare l'accessibilità dell'abbreviazione dei tipi. Se si ignora questo avviso, potrebbero verificarsi errori di runtime.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsMayNotHaveMembers">
        <source>Enumerations cannot have members</source>
        <target state="translated">Le enumerazione non possono avere membri</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembers">
        <source>Measure declarations may have only static members</source>
        <target state="translated">Le dichiarazioni di misura possono avere solo membri statici</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainDoBindings">
        <source>Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings</source>
        <target state="translated">Gli struct non possono contenere binding 'do' perché il costruttore predefinito per gli struct non è in grado di eseguire tali binding</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainLetBindings">
        <source>Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.</source>
        <target state="translated">Gli struct non possono contenere definizioni di valore perché il costruttore predefinito per gli struct non è in grado di eseguire tali binding. Provare ad aggiungere altri argomenti al costruttore primario per il tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticLetBindingsRequireClassesWithImplicitConstructors">
        <source>Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Le definizioni di valore statiche possono essere utilizzate solo nei tipi con un costruttore primario. Provare ad aggiungere argomenti alla definizione di tipo, ad esempio 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembersNotConstructors">
        <source>Measure declarations may have only static members: constructors are not available</source>
        <target state="translated">Le dichiarazioni di misura possono avere solo membri statici: costruttori non disponibili</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberAndLocalClassBindingHaveSameName">
        <source>A member and a local class binding both have the name '{0}'</source>
        <target state="translated">Un binding di una classe locale e un membro non possono avere entrambi il nome '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
        <source>Type abbreviations cannot have interface declarations</source>
        <target state="translated">Le abbreviazioni di tipo non possono avere dichiarazioni di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsCannotHaveInterfaceDeclaration">
        <source>Enumerations cannot have interface declarations</source>
        <target state="translated">Le enumerazioni non possono avere dichiarazioni di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType0">
        <source>This type is not an interface type</source>
        <target state="translated">Questo tipo non è un tipo di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllImplementedInterfacesShouldBeDeclared">
        <source>All implemented interfaces should be declared on the initial declaration of the type</source>
        <target state="translated">Tutte le interfacce implementate devono essere dichiarate nella dichiarazione iniziale del tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
        <source>A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type</source>
        <target state="translated">È stata già aggiunta un'implementazione predefinita di questa interfaccia perché l'implementazione esplicita dell'interfaccia stessa non è specificata nella definizione del tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberNotPermittedInInterfaceImplementation">
        <source>This member is not permitted in an interface implementation</source>
        <target state="translated">Membro non consentito in un'implementazione di interfaccia</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclarationElementNotPermittedInAugmentation">
        <source>This declaration element is not permitted in an augmentation</source>
        <target state="translated">Elemento di dichiarazione non consentito in un aumento</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotContainNestedTypes">
        <source>Types cannot contain nested type definitions</source>
        <target state="translated">I tipi non possono contenere definizioni di tipo annidate</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeExceptionOrModule">
        <source>type, exception or module</source>
        <target state="translated">tipo, eccezione o modulo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeOrModule">
        <source>type or module</source>
        <target state="translated">tipo o modulo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type.</source>
        <target state="translated">Il tipo di struct, record o unione '{0}' implementa l'interfaccia 'System.IStructuralEquatable' in modo esplicito. Applicare l'attributo 'CustomEquality' al tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IEquatable&lt;_&gt;' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'.</source>
        <target state="translated">Il tipo di struct, record o unione '{0}' implementa l'interfaccia 'System.IEquatable&lt;_&gt;' in modo esplicito. Applicare l'attributo 'CustomEquality' al tipo e fornire un'implementazione coerente dell'override non generico 'System.Object.Equals(obj)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
        <source>Explicit type specifications cannot be used for exception constructors</source>
        <target state="translated">Le specifiche di tipo esplicito possono essere utilizzate per i costruttori di eccezione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsShouldNotHaveArgumentList">
        <source>Exception abbreviations should not have argument lists</source>
        <target state="translated">Le abbreviazioni di eccezioni non possono avere elenchi di argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
        <source>Abbreviations for Common IL exceptions cannot take arguments</source>
        <target state="translated">Le abbreviazioni per le eccezioni di IL comune non accettano argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsMustReferToValidExceptions">
        <source>Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception</source>
        <target state="translated">Le abbreviazioni di eccezioni devono fare riferimento a eccezioni esistenti o a tipi F# derivanti da System.Exception</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
        <source>Abbreviations for Common IL exception types must have a matching object constructor</source>
        <target state="translated">Le abbreviazioni dei tipi di eccezione di IL comune devono disporre di un costruttore di oggetto corrispondente</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotAnException">
        <source>Not an exception</source>
        <target state="translated">Non si tratta di un'eccezione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidModuleName">
        <source>Invalid module name</source>
        <target state="translated">Nome modulo non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeExtension">
        <source>Invalid type extension</source>
        <target state="translated">Estensione di tipo non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesOfTypeSpecifyMultipleKindsForType">
        <source>The attributes of this type specify multiple kinds for the type</source>
        <target state="translated">Gli attributi di questo tipo specificano più generi per il tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcKindOfTypeSpecifiedDoesNotMatchDefinition">
        <source>The kind of the type specified by its attributes does not match the kind implied by its definition</source>
        <target state="translated">Il genere di tipo specificato dai relativi attributi non corrisponde a quello che implica la sua definizione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDefinitionsCannotHaveTypeParameters">
        <source>Measure definitions cannot have type parameters</source>
        <target state="translated">Le definizioni di misura non possono avere parametri di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeRequiresDefinition">
        <source>This type requires a definition</source>
        <target state="translated">Questo tipo richiede una definizione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationHasTypeParametersMissingOnType">
        <source>This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C&lt;'a&gt; = C of ...'.</source>
        <target state="translated">Questa abbreviazione di tipo ha uno o più parametri di tipo dichiarati non inclusi nel tipo da abbreviare. Le abbreviazioni di tipo devono usare tutti i parametri di tipo dichiarati nel tipo da abbreviare. Provare a rimuovere uno o più parametri di tipo oppure a usare una definizione di tipo concreto che esegue il wrapping di un tipo sottostante, ad esempio 'type C&lt;'a&gt; = C of ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
        <source>Structs, interfaces, enums and delegates cannot inherit from other types</source>
        <target state="translated">Struct, interfacce, enumerazioni e delegati non possono ereditare da altri tipi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotInheritFromMultipleConcreteTypes">
        <source>Types cannot inherit from multiple concrete types</source>
        <target state="translated">I tipo non possono ereditare da più tipi concreti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
        <source>Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute</source>
        <target state="translated">Tipi di struct, record, unioni e abbreviazioni non possono avere l'attributo 'AllowNullLiteral'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
        <source>Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal</source>
        <target state="translated">I tipi con attributo 'AllowNullLiteral' possono solo implementare o ereditare da tipi che consentono anche l'utilizzo di valori letterali Null</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericTypesCannotHaveStructLayout">
        <source>Generic types cannot be given the 'StructLayout' attribute</source>
        <target state="translated">Non è possibile assegnare l'attributo 'StructLayout' a tipi generici</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyStructsCanHaveStructLayout">
        <source>Only structs and classes without primary constructors may be given the 'StructLayout' attribute</source>
        <target state="translated">L'attributo 'StructLayout' può essere assegnato solo a struct e classi senza costruttori primari</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRepresentationOfTypeHiddenBySignature">
        <source>The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.</source>
        <target state="translated">La rappresentazione di questo tipo è nascosta dalla firma. È necessario assegnare un attributo quale [&lt;Sealed&gt;], [&lt;Class&gt;] o [&lt;Interface&gt;] per indicare le caratteristiche del tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyClassesCanHaveAbstract">
        <source>Only classes may be given the 'AbstractClass' attribute</source>
        <target state="translated">L'attributo 'AbstractClass' può essere assegnato solo a classi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
        <source>Only types representing units-of-measure may be given the 'Measure' attribute</source>
        <target state="translated">L'attributo 'Measure' può essere assegnato solo a tipi che rappresentano un'unità di misura</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on overrides or interface implementations</source>
        <target state="translated">Modificatori di accessibilità non consentiti in implementazioni di interfaccia o override</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDU">
        <source>Discriminated union types are always sealed</source>
        <target state="translated">I tipi di unione discriminati sono sempre Sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedRecord">
        <source>Record types are always sealed</source>
        <target state="translated">I tipi di record sono sempre Sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedAssemblyCode">
        <source>Assembly code types are always sealed</source>
        <target state="translated">I tipi di codice assembly sono sempre Sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedStruct">
        <source>Struct types are always sealed</source>
        <target state="translated">I tipi di struct sono sempre Sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDelegate">
        <source>Delegate types are always sealed</source>
        <target state="translated">I tipi delegati sono sempre Sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedEnum">
        <source>Enum types are always sealed</source>
        <target state="translated">I tipi enumerazione sono sempre sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesAndDelegatesCannotContainFields">
        <source>Interface types and delegate types cannot contain fields</source>
        <target state="translated">I tipi di interfaccia e i tipi delegati non possono contenere campi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviatedTypesCannotBeSealed">
        <source>Abbreviated types cannot be given the 'Sealed' attribute</source>
        <target state="translated">Non è possibile assegnare l'attributo 'Sealed' a tipi abbreviati</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromSealedType">
        <source>Cannot inherit a sealed type</source>
        <target state="translated">Non è possibile ereditare un tipo Sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromInterfaceType">
        <source>Cannot inherit from interface type. Use interface ... with instead.</source>
        <target state="translated">Non è possibile ereditare da un tipo di interfaccia. Usare invece interface ... with.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructTypesCannotContainAbstractMembers">
        <source>Struct types cannot contain abstract members</source>
        <target state="translated">I tipi di struct non possono contenere membri astratti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesCannotBeSealed">
        <source>Interface types cannot be sealed</source>
        <target state="translated">I tipi di interfaccia non possono essere Sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDelegateSpecification">
        <source>Delegate specifications must be of the form 'typ -&gt; typ'</source>
        <target state="translated">Il formato delle specifiche di delegato deve essere 'tip -&gt; tip'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegatesCannotBeCurried">
        <source>Delegate specifications must not be curried types. Use 'typ * ... * typ -&gt; typ' for multi-argument delegates, and 'typ -&gt; (typ -&gt; typ)' for delegates returning function values.</source>
        <target state="translated">Le specifiche di delegato non devono essere tipi sottoposti a currying. Usare 'typ * ... * typ -&gt; typ' per delegati con più argomenti e 'typ -&gt; (typ -&gt; typ)' per delegati che restituiscono valori di funzione.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForLiteralEnumeration">
        <source>Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char</source>
        <target state="translated">Le enumerazioni di valori letterali devono avere tipo int, uint, int16, uint16, int64, uint64, byte, sbyte o char</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclic">
        <source>This type definition involves an immediate cyclic reference through an abbreviation</source>
        <target state="translated">Questa definizione di tipo prevede un riferimento ciclico immediato tramite un'abbreviazione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclicThroughInheritance">
        <source>This type definition involves an immediate cyclic reference through a struct field or inheritance relation</source>
        <target state="translated">Questa definizione di tipo prevede un riferimento ciclico immediato tramite un campo struct o una relazione di ereditarietà</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReservedSyntaxForAugmentation">
        <source>The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[&lt;Sealed&gt;] attribute to the type definition in the signature</source>
        <target state="translated">La sintassi 'type X with ...' è riservata agli aumenti. I tipi le cui rappresentazioni sono nascoste ma contenenti membri vengono ora dichiarati in firme mediante 'type X = ...'. Potrebbe essere inoltre necessario aggiungere l'attributo '[&lt;Sealed&gt;] alla definizione di tipo nella firma</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
        <source>Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.</source>
        <target state="translated">I membri che estendono tipi delegati, interfaccia o enumerazione devono trovarsi in un modulo separato rispetto alla definizione del tipo. Il modulo deve avere l'attributo AutoOpen oppure essere aperto in modo esplicito dal codice client in modo da portare i membri di estensione nell'ambito.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal">
        <source>One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '{0}'</source>
        <target state="translated">Uno o più parametri di tipo dichiarati per questa estensione del tipo contengono un vincolo di tipo mancante o errato non corrispondente ai vincoli di tipo originali in '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
        <source>Type definitions may only have one 'inherit' specification and it must be the first declaration</source>
        <target state="translated">Le definizioni di tipo possono avere solo una specifica 'inherit' nella prima dichiarazione</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
        <source>'let' and 'do' bindings must come before member and interface definitions in type definitions</source>
        <target state="translated">I binding 'let' e 'do' devono precedere le definizioni di membro e interfaccia nelle definizioni di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritDeclarationMissingArguments">
        <source>This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'.</source>
        <target state="translated">La dichiarazione 'inherit' specifica il tipo ereditato, ma senza argomenti. Provare a specificare argomenti, ad esempio 'inherit BaseType(args)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritConstructionCallNotPartOfImplicitSequence">
        <source>This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">La dichiarazione 'inherit' contiene argomenti ma non è in un tipo con un costruttore primario. Provare ad aggiungere argomenti alla definizione di tipo utilizzata, ad esempio 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLetAndDoRequiresImplicitConstructionSequence">
        <source>This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Questa definizione può essere utilizzata solo in un tipo con un costruttore primario. Provare ad aggiungere argomenti alla definizione di tipo utilizzata, ad esempio 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveAugmentations">
        <source>Type abbreviations cannot have augmentations</source>
        <target state="translated">Le abbreviazioni di tipo non possono avere aumenti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbreviationForNamespace">
        <source>The path '{0}' is a namespace. A module abbreviation may not abbreviate a namespace.</source>
        <target state="translated">Il percorso '{0}' è uno spazio dei nomi. L'abbreviazione del modulo non può abbreviare uno spazio dei nomi.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeUsedInInvalidWay">
        <source>The type '{0}' is used in an invalid way. A value prior to '{1}' has an inferred type involving '{2}', which is an invalid forward reference.</source>
        <target state="translated">Il tipo '{0}' è utilizzato in modo non valido. Un valore prima di '{1}' ha un tipo dedotto che prevede '{2}', il che costituisce un riferimento in avanti non valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to the definition of '{2}', which is an invalid forward reference.</source>
        <target state="translated">Il membro '{0}' è utilizzato in modo non valido. Uso di '{1}' dedotto prima della definizione di '{2}', il che costituisce un riferimento in avanti non valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeAutoOpenWasIgnored">
        <source>The attribute 'AutoOpen(\"{0}\")' in the assembly '{1}' did not refer to a valid module or namespace in that assembly and has been ignored</source>
        <target state="translated">L'attributo 'AutoOpen(\"{0}\")' nell'assembly '{1}' non fa riferimento a un modulo o a uno spazio dei nomi valido in tale assembly ed è stato pertanto ignorato</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUndefinedValue">
        <source>Undefined value '{0}'</source>
        <target state="translated">Valore non definito '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLabelNotFound">
        <source>Label {0} not found</source>
        <target state="translated">Etichetta {0} non trovata</target>
        <note />
      </trans-unit>
      <trans-unit id="ilIncorrectNumberOfTypeArguments">
        <source>Incorrect number of type arguments to local call</source>
        <target state="translated">Numero di argomenti tipo non corretto per la chiamata locale</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDynamicInvocationNotSupported">
        <source>Dynamic invocation of {0} is not supported</source>
        <target state="translated">Chiamata dinamica di {0} non supportata</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfLiteralFieldIsInvalid">
        <source>Taking the address of a literal field is invalid</source>
        <target state="translated">L'utilizzo dell'indirizzo di un campo del valore letterale non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfValueHereIsInvalid">
        <source>This operation involves taking the address of a value '{0}' represented using a local variable or other special representation. This is invalid.</source>
        <target state="translated">Questa operazione prevede l'uso dell'indirizzo di un valore '{0}' rappresentato mediante una variabile locale o altra rappresentazione speciale. Questo comportamento non è valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilCustomMarshallersCannotBeUsedInFSharp">
        <source>Custom marshallers cannot be specified in F# code. Consider using a C# helper function.</source>
        <target state="translated">Non è possibile specificare gestori del marshalling personalizzati nel codice F#. Provare a usare una funzione helper C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMarshalAsAttributeCannotBeDecoded">
        <source>The MarshalAs attribute could not be decoded</source>
        <target state="translated">Non è stato possibile decodificare l'attributo MarshalAs</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignatureForExternalFunctionContainsTypeParameters">
        <source>The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.</source>
        <target state="translated">La firma per la funzione esterna contiene parametri di tipo. Vincolare l'argomento e i tipi restituiti per indicare i tipi della funzione C corrispondente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDllImportAttributeCouldNotBeDecoded">
        <source>The DllImport attribute could not be decoded</source>
        <target state="translated">Non è stato possibile decodificare l'attributo DllImport</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLiteralFieldsCannotBeSet">
        <source>Literal fields cannot be set</source>
        <target state="translated">Non è possibile impostare campi di valori letterali</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStaticMethodIsNotLambda">
        <source>GenSetStorage: {0} was represented as a static method but was not an appropriate lambda expression</source>
        <target state="translated">GenSetStorage: {0} è rappresentato come metodo statico, ma non è un'espressione lambda appropriata</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMutableVariablesCannotEscapeMethod">
        <source>Mutable variables cannot escape their method</source>
        <target state="translated">Le variabili modificabili non possono uscire dal relativo metodo</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedUnrealizedValue">
        <source>Compiler error: unexpected unrealized value</source>
        <target state="translated">Errore compilatore: valore non realizzato imprevisto</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMainModuleEmpty">
        <source>Main module of program is empty: nothing will happen when it is run</source>
        <target state="translated">Il modulo principale del programma è vuoto. L'esecuzione non produrrà alcun effetto</target>
        <note />
      </trans-unit>
      <trans-unit id="ilTypeCannotBeUsedForLiteralField">
        <source>This type cannot be used for a literal field</source>
        <target state="translated">Non è possibile usare questo tipo per un campo di valore letterale</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedGetSetAnnotation">
        <source>Unexpected GetSet annotation on a property</source>
        <target state="translated">Annotazione GetSet imprevista in una proprietà</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldOffsetAttributeCouldNotBeDecoded">
        <source>The FieldOffset attribute could not be decoded</source>
        <target state="translated">Non è stato possibile decodificare l'attributo FieldOffset</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStructLayoutAttributeCouldNotBeDecoded">
        <source>The StructLayout attribute could not be decoded</source>
        <target state="translated">Non è stato possibile decodificare l'attributo StructLayout</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDefaultAugmentationAttributeCouldNotBeDecoded">
        <source>The DefaultAugmentation attribute could not be decoded</source>
        <target state="translated">Non è stato possibile decodificare l'attributo DefaultAugmentation</target>
        <note />
      </trans-unit>
      <trans-unit id="ilReflectedDefinitionsCannotUseSliceOperator">
        <source>Reflected definitions cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">Le definizioni riflesse non possono contenere utilizzi dell'operatore di splicing del prefisso '%'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsProblemWithCodepage">
        <source>Problem with codepage '{0}': {1}</source>
        <target state="translated">Problema con la tabella codici '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyright">
        <source>Copyright (c) Microsoft Corporation. All Rights Reserved.</source>
        <target state="translated">Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyrightCommunity">
        <source>Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</source>
        <target state="translated">Distribuito gratuitamente in conformità ai termini della licenza Open Source di MIT. https://github.com/Microsoft/visualfsharp/blob/master/License.txt</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNameOfOutputFile">
        <source>Name of the output file (Short form: -o)</source>
        <target state="translated">Nome del file di output (forma breve: -o)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildConsole">
        <source>Build a console executable</source>
        <target state="translated">Compila un file eseguibile da console</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildWindows">
        <source>Build a Windows executable</source>
        <target state="translated">Compila un file eseguibile Windows</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildLibrary">
        <source>Build a library (Short form: -a)</source>
        <target state="translated">Compila una libreria (forma breve: -a)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildModule">
        <source>Build a module that can be added to another assembly</source>
        <target state="translated">Compila un modulo che può essere aggiunto ad altro assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDelaySign">
        <source>Delay-sign the assembly using only the public portion of the strong name key</source>
        <target state="translated">Ritarda la firma dell'assembly utilizzando solo la parte pubblica della chiave con nome sicuro</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPublicSign">
        <source>Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed</source>
        <target state="translated">Firma pubblicamente l'assembly usando solo la parte pubblica della chiave con nome sicuro e contrassegna l'assembly come firmato</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWriteXml">
        <source>Write the xmldoc of the assembly to the given file</source>
        <target state="translated">Scrive lo xmldoc dell'assembly nel file specificato</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyFile">
        <source>Specify a strong name key file</source>
        <target state="translated">Specifica un file di chiave con nome sicuro</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyContainer">
        <source>Specify a strong name key container</source>
        <target state="translated">Specifica un contenitore di chiavi con nome sicuro</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPlatform">
        <source>Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.</source>
        <target state="translated">Limita le piattaforme in cui è possibile eseguire il codice: x86, Itanium, x64, anycpu32bitpreferred o anycpu. Il valore predefinito è anycpu.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoOpt">
        <source>Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.</source>
        <target state="translated">Include solo informazioni di ottimizzazione essenziali per l'implementazione dei costrutti inline. Impedisce l'incorporamento tra moduli ma migliora la compatibilità binaria.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoInterface">
        <source>Don't add a resource to the generated assembly containing F#-specific metadata</source>
        <target state="translated">Non aggiunge una risorsa all'assembly generato contenente metadati specifici di F#</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSig">
        <source>Print the inferred interface of the assembly to a file</source>
        <target state="translated">Stampa l'interfaccia dedotta dell'assembly in un file</target>
        <note />
      </trans-unit>
      <trans-unit id="optsReference">
        <source>Reference an assembly (Short form: -r)</source>
        <target state="translated">Fa riferimento a un assembly (forma breve: -r)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32res">
        <source>Specify a Win32 resource file (.res)</source>
        <target state="translated">Specifica un file di risorse Win32 (.res)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32manifest">
        <source>Specify a Win32 manifest file</source>
        <target state="translated">Specifica un file manifesto Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowin32manifest">
        <source>Do not include the default Win32 manifest</source>
        <target state="translated">Non includere il manifesto Win32 predefinito</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedAllSource">
        <source>Embed all source files in the portable PDB file</source>
        <target state="translated">Incorpora tutti i file di origine nel file PDB portabile</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedSource">
        <source>Embed specific source files in the portable PDB file</source>
        <target state="translated">Incorpora file di origine specifici nel file PDB portabile</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLink">
        <source>Source link information file to embed in the portable PDB file</source>
        <target state="translated">File di informazioni sul collegamento all'origine da incorporare nel file PDB portabile</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbeddedSourceRequirePortablePDBs">
        <source>--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">Opzione --embed supportata solo quando si crea un file PDB portabile (--debug:portable o --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLinkRequirePortablePDBs">
        <source>--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">Opzione --sourcelink supportata solo quando si crea un file PDB portatile (--debug:portable o --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="srcFileTooLarge">
        <source>Source file is too large to embed in a portable PDB</source>
        <target state="translated">Le dimensioni del file di origine sono eccessive per consentirne l'incorporamento in un PDB portabile</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResource">
        <source>Embed the specified managed resource</source>
        <target state="translated">Incorpora la risorsa gestita specificata</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLinkresource">
        <source>Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]</source>
        <target state="translated">Collega la risorsa specificata all'assembly in cui il formato di resinfo è &lt;file&gt;[,&lt;nome stringa&gt;[,public|private]]</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebugPM">
        <source>Emit debug information (Short form: -g)</source>
        <target state="translated">Crea informazioni di debug (forma breve: -g)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebug">
        <source>Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file).</source>
        <target state="translated">Consente di specificare il tipo di debug: full, portable, embedded, pdbonly. '{0}' è l'impostazione predefinita se non viene specificato il tipo di debug e consente di associare un debugger a un programma in esecuzione. 'portable' è un formato multipiattaforma. 'embedded' è un formato multipiattaforma incorporato nel file di output.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsOptimize">
        <source>Enable optimizations (Short form: -O)</source>
        <target state="translated">Abilita le ottimizzazioni (forma breve: -O)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTailcalls">
        <source>Enable or disable tailcalls</source>
        <target state="translated">Abilita o disabilita le chiamate tail</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDeterministic">
        <source>Produce a deterministic assembly (including module version GUID and timestamp)</source>
        <target state="translated">Produce un assembly (che include GUID e timestamp della versione del modulo)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCrossoptimize">
        <source>Enable or disable cross-module optimizations</source>
        <target state="translated">Abilita o disabilita le ottimizzazioni tra i moduli</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserrorPM">
        <source>Report all warnings as errors</source>
        <target state="translated">Segnala tutti gli avvisi come errori</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserror">
        <source>Report specific warnings as errors</source>
        <target state="translated">Segnala determinati avvisi come errori</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarn">
        <source>Set a warning level (0-5)</source>
        <target state="translated">Imposta un livello di avviso (0-5)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowarn">
        <source>Disable specific warning messages</source>
        <target state="translated">Disabilita messaggi di avviso specifici</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnOn">
        <source>Enable specific warnings that may be off by default</source>
        <target state="translated">Abilita avvisi specifici che possono essere disattivati per impostazione predefinita</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecked">
        <source>Generate overflow checks</source>
        <target state="translated">Genera controlli dell'overflow</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDefine">
        <source>Define conditional compilation symbols (Short form: -d)</source>
        <target state="translated">Definisce simboli di compilazione condizionale (forma breve: -d)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsMlcompatibility">
        <source>Ignore ML compatibility warnings</source>
        <target state="translated">Ignora avvisi di compatibilità ML</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNologo">
        <source>Suppress compiler copyright message</source>
        <target state="translated">Non visualizza il messaggio di copyright del compilatore</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelp">
        <source>Display this usage message (Short form: -?)</source>
        <target state="translated">Visualizza questo messaggio relativo all'uso (forma breve: -?)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFile">
        <source>Read response file for more options</source>
        <target state="translated">Per ulteriori opzioni, leggere il file di risposta</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCodepage">
        <source>Specify the codepage used to read source files</source>
        <target state="translated">Specificare la tabella codici utilizzata per leggere i file di origine</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUtf8output">
        <source>Output messages in UTF-8 encoding</source>
        <target state="translated">Genera messaggi con codifica UTF-8</target>
        <note />
      </trans-unit>
      <trans-unit id="optsFullpaths">
        <source>Output messages with fully qualified paths</source>
        <target state="translated">Messaggi di output con percorsi completi</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLib">
        <source>Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)</source>
        <target state="translated">Specifica una directory per il percorso di inclusione utilizzato per risolvere assembly e file di origine (forma breve: -I)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBaseaddress">
        <source>Base address for the library to be built</source>
        <target state="translated">Indirizzo di base della libreria da compilare</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoframework">
        <source>Do not reference the default CLI assemblies by default</source>
        <target state="translated">Per impostazione predefinita, non fa riferimento agli assembly CLI predefiniti</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStandalone">
        <source>Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated</source>
        <target state="translated">Collega in modo statico la libreria F# e tutte le DLL da questa dipendenti a cui viene fatto riferimento nell'assembly in fase di generazione</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStaticlink">
        <source>Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.</source>
        <target state="translated">Collega in modo statico l'assembly specificato e tutte le DLL da questo dipendenti a cui viene fatto riferimento. Usare un nome di assembly, ad esempio lib, non un nome di DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResident">
        <source>Use a resident background compilation service to improve compiler startup times.</source>
        <target state="translated">Utilizzare un servizio di compilazione residente in background per migliorare i tempi di avvio del compilatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPdb">
        <source>Name the output debug file</source>
        <target state="translated">Nome del file di debug di output</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSimpleresolution">
        <source>Resolve assembly references using directory-based rules rather than MSBuild resolution</source>
        <target state="translated">Risolvere i riferimenti ad assembly mediante regole basate su directory anziché mediante la risoluzione MSBuild</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedTarget">
        <source>Unrecognized target '{0}', expected 'exe', 'winexe', 'library' or 'module'</source>
        <target state="translated">Destinazione '{0}' non riconosciuta. Previsto 'exe', 'winexe', 'library' o 'module'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedDebugType">
        <source>Unrecognized debug type '{0}', expected 'pdbonly' or 'full'</source>
        <target state="translated">Tipo debug '{0}' non riconosciuto. Previsto 'pdbonly' o 'full'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidWarningLevel">
        <source>Invalid warning level '{0}'</source>
        <target state="translated">Livello di avviso '{0}' non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="optsShortFormOf">
        <source>Short form of '{0}'</source>
        <target state="translated">Forma breve di '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDeprecatedMsg">
        <source>The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.</source>
        <target state="translated">Opzione della riga di comando '--cliroot' deprecata. Al suo posto usare un riferimento esplicito a una copia specifica di mscorlib.dll.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDescription">
        <source>Use to override where the compiler looks for mscorlib.dll and framework components</source>
        <target state="translated">Da utilizzare per eseguire l'override nella posizione in cui il compilatore cerca mscorlib.dll e i componenti del framework</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerOutputFiles">
        <source>- OUTPUT FILES -</source>
        <target state="translated">- FILE DI OUTPUT -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerInputFiles">
        <source>- INPUT FILES -</source>
        <target state="translated">- FILE DI INPUT -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerResources">
        <source>- RESOURCES -</source>
        <target state="translated">- RISORSE -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerCodeGen">
        <source>- CODE GENERATION -</source>
        <target state="translated">- GENERAZIONE CODICE -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerAdvanced">
        <source>- ADVANCED -</source>
        <target state="translated">- AVANZATE -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerMisc">
        <source>- MISCELLANEOUS -</source>
        <target state="translated">- VARIE -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerLanguage">
        <source>- LANGUAGE -</source>
        <target state="translated">- LINGUAGGIO -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerErrsAndWarns">
        <source>- ERRORS AND WARNINGS -</source>
        <target state="translated">- ERRORI E AVVISI -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownArgumentToTheTestSwitch">
        <source>Unknown --test argument: '{0}'</source>
        <target state="translated">Argomento --test sconosciuto: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownPlatform">
        <source>Unrecognized platform '{0}', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'</source>
        <target state="translated">Piattaforma '{0}' non riconosciuta. I valori validi sono 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred' e 'anycpu'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInternalNoDescription">
        <source>The command-line option '{0}' is for test purposes only</source>
        <target state="translated">L'opzione della riga di comando '{0}' deve essere usata solo per i test</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLONoDescription">
        <source>The command-line option '{0}' has been deprecated</source>
        <target state="translated">Opzione della riga di comando '{0}' deprecata</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLODeprecatedSuggestAlternative">
        <source>The command-line option '{0}' has been deprecated. Use '{1}' instead.</source>
        <target state="translated">Opzione della riga di comando '{0}' deprecata. Al suo posto usare '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLOHtmlDoc">
        <source>The command-line option '{0}' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.</source>
        <target state="translated">Opzione della riga di comando '{0}' deprecata. La generazione di documenti HTML è ora inclusa in F# Power Pack, tramite lo strumento FsHtmlDoc.exe.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsConsoleColors">
        <source>Output warning and error messages in color</source>
        <target state="translated">Visualizzare messaggi di errore e di avviso a colori</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUseHighEntropyVA">
        <source>Enable high-entropy ASLR</source>
        <target state="translated">Abilita ASLR a entropia elevata</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSubSystemVersion">
        <source>Specify subsystem version of this assembly</source>
        <target state="translated">Specificare la versione del sottosistema di questo assembly</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTargetProfile">
        <source>Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib</source>
        <target state="translated">Consente di specificare il profilo del framework di destinazione di questo assembly. I valori validi sono mscorlib, netcore o netstandard. Impostazione predefinita: mscorlib</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmitDebugInfoInQuotations">
        <source>Emit debug information in quotations</source>
        <target state="translated">Crea informazioni di debug in quotation</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPreferredUiLang">
        <source>Specify the preferred output language culture name (e.g. es-ES, ja-JP)</source>
        <target state="translated">Consente di specificare il nome delle impostazioni cultura di output preferite, ad esempio es-ES, it-IT</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoCopyFsharpCore">
        <source>Don't copy FSharp.Core.dll along the produced binaries</source>
        <target state="translated">Non copia FSharp.Core.dll con i file binari prodotti</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidSubSystemVersion">
        <source>Invalid version '{0}' for '--subsystemversion'. The version must be 4.00 or greater.</source>
        <target state="translated">Versione '{0}' non valida per '--subsystemversion'. La versione deve essere 4.00 o successiva.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidTargetProfile">
        <source>Invalid value '{0}' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.</source>
        <target state="translated">Valore '{0}' non valido per '--targetprofile'. I valori validi sono 'mscorlib', 'netcore' o 'netstandard'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFullName">
        <source>Full name</source>
        <target state="translated">Nome completo</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoOtherOverloads">
        <source>and {0} other overloads</source>
        <target state="translated">e altri {0} overload</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoUnionCase">
        <source>union case</source>
        <target state="translated">case di unione</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActivePatternResult">
        <source>active pattern result</source>
        <target state="translated">risultato criteri attivi</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActiveRecognizer">
        <source>active recognizer</source>
        <target state="translated">riconoscimento attivo</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoField">
        <source>field</source>
        <target state="translated">campo</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoEvent">
        <source>event</source>
        <target state="translated">evento</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoProperty">
        <source>property</source>
        <target state="translated">proprietà</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoExtension">
        <source>extension</source>
        <target state="translated">Estensione</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCustomOperation">
        <source>custom operation</source>
        <target state="translated">operazione personalizzata</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoArgument">
        <source>argument</source>
        <target state="translated">Argomento</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoPatternVariable">
        <source>patvar</source>
        <target state="translated">patvar</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespace">
        <source>namespace</source>
        <target state="translated">spazio dei nomi</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoModule">
        <source>module</source>
        <target state="translated">modulo</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespaceOrModule">
        <source>namespace/module</source>
        <target state="translated">spazio dei nomi/modulo</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromFirst">
        <source>from {0}</source>
        <target state="translated">da {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromNext">
        <source>also from {0}</source>
        <target state="translated">anche da {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedProperty">
        <source>generated property</source>
        <target state="translated">proprietà generata</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedType">
        <source>generated type</source>
        <target state="translated">tipo generato</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersKey">
        <source>Found by AssemblyFolders registry key</source>
        <target state="translated">Trovata mediante la chiave del Registro di sistema AssemblyFolders</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersExKey">
        <source>Found by AssemblyFoldersEx registry key</source>
        <target state="translated">Trovata mediante chiave del Registro di sistema AssemblyFoldersEx</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionNetFramework">
        <source>.NET Framework</source>
        <target state="translated">.NET Framework</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionGAC">
        <source>Global Assembly Cache</source>
        <target state="translated">Global Assembly Cache</target>
        <note />
      </trans-unit>
      <trans-unit id="recursiveClassHierarchy">
        <source>Recursive class hierarchy in type '{0}'</source>
        <target state="translated">Gerarchia di classi ricorsiva nel tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRecursiveReferenceToAbstractSlot">
        <source>Invalid recursive reference to an abstract slot</source>
        <target state="translated">Riferimento ricorsivo non valido a uno slot astratto</target>
        <note />
      </trans-unit>
      <trans-unit id="eventHasNonStandardType">
        <source>The event '{0}' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit {1} and {2} methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent&lt;_&gt;' or 'IEvent&lt;_,_&gt;'.</source>
        <target state="translated">L'evento '{0}' ha un tipo non standard. Se l'evento è dichiarato in un altro linguaggio CLI, potrebbe essere necessario accedere all'evento mediante i metodi espliciti {1} e {2} per l'evento stesso. Se l'evento è dichiarato in F#, rendere il tipo dell'evento una creazione di istanza di 'IDelegateEvent&lt;_&gt;' o 'IEvent&lt;_,_&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeIsNotAccessible">
        <source>The type '{0}' is not accessible from this code location</source>
        <target state="translated">Il tipo '{0}' non è accessibile da questa posizione di codice</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCasesAreNotAccessible">
        <source>The union cases or fields of the type '{0}' are not accessible from this code location</source>
        <target state="translated">I campi o i case di unione del tipo '{0}' non sono accessibili da questa posizione di codice</target>
        <note />
      </trans-unit>
      <trans-unit id="valueIsNotAccessible">
        <source>The value '{0}' is not accessible from this code location</source>
        <target state="translated">Il valore '{0}' non è accessibile da questa posizione di codice</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCaseIsNotAccessible">
        <source>The union case '{0}' is not accessible from this code location</source>
        <target state="translated">Il case di unione '{0}' non è accessibile da questa posizione di codice</target>
        <note />
      </trans-unit>
      <trans-unit id="fieldIsNotAccessible">
        <source>The record, struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">Il campo di classe, record o struct '{0}' non è accessibile da questa posizione di codice</target>
        <note />
      </trans-unit>
      <trans-unit id="structOrClassFieldIsNotAccessible">
        <source>The struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">Il campo di classe o struct '{0}' non è accessibile da questa posizione di codice</target>
        <note />
      </trans-unit>
      <trans-unit id="experimentalConstruct">
        <source>This construct is experimental</source>
        <target state="translated">Questo costrutto è sperimentale</target>
        <note />
      </trans-unit>
      <trans-unit id="noInvokeMethodsFound">
        <source>No Invoke methods found for delegate type</source>
        <target state="translated">Nessun metodo Invoke trovato per il tipo delegato</target>
        <note />
      </trans-unit>
      <trans-unit id="moreThanOneInvokeMethodFound">
        <source>More than one Invoke method found for delegate type</source>
        <target state="translated">Trovati più metodi Invoke per il tipo delegato</target>
        <note />
      </trans-unit>
      <trans-unit id="delegatesNotAllowedToHaveCurriedSignatures">
        <source>Delegates are not allowed to have curried signatures</source>
        <target state="translated">I delegati non possono disporre di firme sottoposte a currying</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrUnexpectedTExpr">
        <source>Unexpected Expr.TyChoose</source>
        <target state="translated">Expr.TyChoose imprevisto</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrLambdaLiftingOptimizationsNotApplied">
        <source>Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.</source>
        <target state="translated">Nota: le ottimizzazioni lifted lambda non sono state applicate a causa dell'utilizzo di questa funzione generica vincolata locale come valore di prima classe. Questa condizione potrebbe essere risolta con l'aggiunta di vincoli di tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifiersContainingAtSymbolReserved">
        <source>Identifiers containing '@' are reserved for use in F# code generation</source>
        <target state="translated">Gli identificatori contenenti '@' sono riservati per l'utilizzo nella generazione di codice F#</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifierReserved">
        <source>The identifier '{0}' is reserved for future use by F#</source>
        <target state="translated">L'identificatore '{0}' è riservato per utilizzi futuri in F#</target>
        <note />
      </trans-unit>
      <trans-unit id="patcMissingVariable">
        <source>Missing variable '{0}'</source>
        <target state="translated">Variabile '{0}' mancante</target>
        <note />
      </trans-unit>
      <trans-unit id="patcPartialActivePatternsGenerateOneResult">
        <source>Partial active patterns may only generate one result</source>
        <target state="translated">Criteri attivi parziali possono generare un solo risultato</target>
        <note />
      </trans-unit>
      <trans-unit id="impTypeRequiredUnavailable">
        <source>The type '{0}' is required here and is unavailable. You must add a reference to assembly '{1}'.</source>
        <target state="translated">In questa posizione è necessario il tipo '{0}', il quale non è disponibile. Aggiungere un riferimento all'assembly '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferencedTypeCouldNotBeFoundInAssembly">
        <source>A reference to the type '{0}' in assembly '{1}' was found, but the type could not be found in that assembly</source>
        <target state="translated">Nell'assembly '{1}' è stato trovato un riferimento al tipo '{0}', ma non è stato trovato il tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="impNotEnoughTypeParamsInScopeWhileImporting">
        <source>Internal error or badly formed metadata: not enough type parameters were in scope while importing</source>
        <target state="translated">Errore interno o metadati in formato non valido: parametri di tipo insufficienti nell'ambito durante l'importazione</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferenceToDllRequiredByAssembly">
        <source>A reference to the DLL {0} is required by assembly {1}. The imported type {2} is located in the first assembly and could not be resolved.</source>
        <target state="translated">È necessario un riferimento alla DLL {0} per l'assembly {1}. Il tipo importato {2} si trova nel primo assembly e non è stato possibile risolverlo.</target>
        <note />
      </trans-unit>
      <trans-unit id="impImportedAssemblyUsesNotPublicType">
        <source>An imported assembly uses the type '{0}' but that type is not public</source>
        <target state="translated">Un assembly importato usa il tipo '{0}', il quale tuttavia non è pubblico</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButIncomplete">
        <source>The value '{0}' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible</source>
        <target state="translated">Il valore '{0}' è stato contrassegnato come inline, tuttavia la relativa implementazione utilizza una funzione interna o privata con accessibilità insufficiente</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButWasNotBoundInTheOptEnv">
        <source>The value '{0}' was marked inline but was not bound in the optimization environment</source>
        <target state="translated">Il valore '{0}' è stato contrassegnato come inline, tuttavia non è stato associato nell'ambiente di ottimizzazione</target>
        <note />
      </trans-unit>
      <trans-unit id="optLocalValueNotFoundDuringOptimization">
        <source>Local value {0} not found during optimization</source>
        <target state="translated">Valore locale {0} non trovato durante l'ottimizzazione</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineHasUnexpectedValue">
        <source>A value marked as 'inline' has an unexpected value</source>
        <target state="translated">Valore imprevisto contrassegnato come 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineCouldNotBeInlined">
        <source>A value marked as 'inline' could not be inlined</source>
        <target state="translated">Non è stato possibile impostare come inline un valore contrassegnato come 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="optFailedToInlineValue">
        <source>Failed to inline the value '{0}' marked 'inline', perhaps because a recursive value was marked 'inline'</source>
        <target state="translated">Non è stato possibile incorporare il valore '{0}' contrassegnato come 'inline', probabilmente a causa di un valore ricorsivo contrassegnato come 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="optRecursiveValValue">
        <source>Recursive ValValue {0}</source>
        <target state="translated">ValValue ricorsivo {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltIncorrentIndentationOfIn">
        <source>The indentation of this 'in' token is incorrect with respect to the corresponding 'let'</source>
        <target state="translated">Il rientro di questo token 'in' non è corretto rispetto al 'let' corrispondente</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltTokenIsOffsideOfContextStartedEarlier">
        <source>Possible incorrect indentation: this token is offside of context started at position {0}. Try indenting this token further or using standard formatting conventions.</source>
        <target state="translated">Possibile rientro non corretto: il token si trova oltre il limite del contesto iniziato alla posizione {0}. Provare ad applicare un ulteriore rientro al token oppure a utilizzare convenzioni di formattazione standard.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltSeparatorTokensOfPatternMatchMisaligned">
        <source>The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.</source>
        <target state="translated">Le regole di separazione dei token '|' di questi criteri di ricerca sono disallineate di una colonna. Provare a riallineare il codice o a utilizzare ulteriore rientro.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidModuleExprType">
        <source>Invalid module/expression/type</source>
        <target state="translated">Modulo/espressione/tipo non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationNeededToDisambiguateTypesWithSameName">
        <source>Multiple types exist called '{0}', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '{1}'.</source>
        <target state="translated">Sono presenti più tipi chiamati '{0}', i quali utilizzano numeri diversi di parametri generici. Fornire una creazione dell'istanza del tipo per evitare ambiguità nella risoluzione del tipo, ad esempio '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationIsMissingAndCouldNotBeInferred">
        <source>The instantiation of the generic type '{0}' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '{1}'.</source>
        <target state="translated">La creazione dell'istanza del tipo generico '{0}' non è presente e non può essere dedotta dagli argomenti o dal tipo restituito di questo membro. Provare a fornire una creazione dell'istanza del tipo all'accesso al tipo, ad esempio '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrGlobalUsedOnlyAsFirstName">
        <source>'global' may only be used as the first name in a qualified path</source>
        <target state="translated">'global' può essere utilizzato solo come primo nome in un percorso completo</target>
        <note />
      </trans-unit>
      <trans-unit id="nrIsNotConstructorOrLiteral">
        <source>This is not a constructor or literal, or a constructor is being used incorrectly</source>
        <target state="translated">Questo elemento non è un costruttore o un valore letterale oppure un costruttore è utilizzato in modo non corretto</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnexpectedEmptyLongId">
        <source>Unexpected empty long identifier</source>
        <target state="translated">Identificatore lungo vuoto imprevisto</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordDoesNotContainSuchLabel">
        <source>The record type '{0}' does not contain a label '{1}'.</source>
        <target state="translated">Il tipo di record '{0}' non contiene un'etichetta '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidFieldLabel">
        <source>Invalid field label</source>
        <target state="translated">Etichetta di campo non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidExpression">
        <source>Invalid expression '{0}'</source>
        <target state="translated">Espressione '{0}' non valida</target>
        <note />
      </trans-unit>
      <trans-unit id="nrNoConstructorsAvailableForType">
        <source>No constructors are available for the type '{0}'</source>
        <target state="translated">Nessun costruttore disponibile per il tipo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnionTypeNeedsQualifiedAccess">
        <source>The union type for union case '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('{1}') in the name you are using.</source>
        <target state="translated">Il tipo di unione per il case di unione '{0}' è stato definito con RequireQualifiedAccessAttribute. Includere il nome del tipo di unione ('{1}') nel nome da usare.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordTypeNeedsQualifiedAccess">
        <source>The record type for the record field '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('{1}') in the name you are using.</source>
        <target state="translated">Il tipo di record per il campo di record '{0}' è stato definito con RequireQualifiedAccessAttribute. Includere il nome del tipo di record ('{1}') nel nome da usare.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingPdb">
        <source>Unexpected error creating debug information file '{0}'</source>
        <target state="translated">Errore imprevisto durante la creazione del file di informazioni di debug '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideIntegerRange">
        <source>This number is outside the allowable range for this integer type</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per questo tipo di Integer</target>
        <note />
      </trans-unit>
      <trans-unit id="lexCharNotAllowedInOperatorNames">
        <source>'{0}' is not permitted as a character in operator names and is reserved for future use</source>
        <target state="translated">'{0}' non è consentito come carattere nei nomi degli operatori ed è riservato per utilizzi futuri</target>
        <note />
      </trans-unit>
      <trans-unit id="lexUnexpectedChar">
        <source>Unexpected character '{0}'</source>
        <target state="translated">Il carattere '{0}' è imprevisto</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteArrayCannotEncode">
        <source>This byte array literal contains characters that do not encode as a single byte</source>
        <target state="translated">Questo valore letterale della matrice di byte contiene caratteri non codificabili come singoli byte</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIdentEndInMarkReserved">
        <source>Identifiers followed by '{0}' are reserved for future use</source>
        <target state="translated">Gli identificatori seguiti da '{0}' sono riservati per utilizzi futuri</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSigned">
        <source>This number is outside the allowable range for 8-bit signed integers</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per interi con segno a 8 bit</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSignedHex">
        <source>This number is outside the allowable range for hexadecimal 8-bit signed integers</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per interi con segno a 8 bit esadecimali</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitUnsigned">
        <source>This number is outside the allowable range for 8-bit unsigned integers</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per interi senza segno a 8 bit</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitSigned">
        <source>This number is outside the allowable range for 16-bit signed integers</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per interi con segno a 16 bit</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitUnsigned">
        <source>This number is outside the allowable range for 16-bit unsigned integers</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per interi senza segno a 16 bit</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitSigned">
        <source>This number is outside the allowable range for 32-bit signed integers</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per interi con segno a 32 bit</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitUnsigned">
        <source>This number is outside the allowable range for 32-bit unsigned integers</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per interi senza segno a 32 bit</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitSigned">
        <source>This number is outside the allowable range for 64-bit signed integers</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per interi con segno a 64 bit</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitUnsigned">
        <source>This number is outside the allowable range for 64-bit unsigned integers</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per interi senza segno a 64 bit</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeSigned">
        <source>This number is outside the allowable range for signed native integers</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per interi con segno nativi</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeUnsigned">
        <source>This number is outside the allowable range for unsigned native integers</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per interi senza segno nativi</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidFloat">
        <source>Invalid floating point number</source>
        <target state="translated">Numero a virgola mobile non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideDecimal">
        <source>This number is outside the allowable range for decimal literals</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per valori letterali decimali</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideThirtyTwoBitFloat">
        <source>This number is outside the allowable range for 32-bit floats</source>
        <target state="translated">Questo numero non è compreso nell'intervallo consentito per valori float a 32 bit</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidNumericLiteral">
        <source>This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0o1, 0b1, 1l (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</source>
        <target state="translated">Questo non è un valore letterale numerico valido. I valori letterali numerici validi includono 1, 0x1, 0o1, 0b1, 1l (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidByteLiteral">
        <source>This is not a valid byte literal</source>
        <target state="translated">Valore letterale byte non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidCharLiteral">
        <source>This is not a valid character literal</source>
        <target state="translated">Valore letterale carattere non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="lexThisUnicodeOnlyInStringLiterals">
        <source>This Unicode encoding is only valid in string literals</source>
        <target state="translated">Questa codifica Unicode è valida solo in valori letterali stringa</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTokenReserved">
        <source>This token is reserved for future use</source>
        <target state="translated">Token riservato per utilizzi futuri</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTabsNotAllowed">
        <source>TABs are not allowed in F# code unless the #indent \"off\" option is used</source>
        <target state="translated">I caratteri di tabulazione non sono consentiti nel codice F# a meno che non si utilizzi l'opzione #indent \"off\"</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidLineNumber">
        <source>Invalid line number: '{0}'</source>
        <target state="translated">Numero di riga non valido: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustBeFirst">
        <source>#if directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">La direttiva #if deve trovarsi all'inizio di una riga</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseNoMatchingIf">
        <source>#else has no matching #if</source>
        <target state="translated">#else senza #if corrispondente</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifRequiredForElse">
        <source>#endif required for #else</source>
        <target state="translated">#endif necessario per #else</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseMustBeFirst">
        <source>#else directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">La direttiva #else deve trovarsi all'inizio di una riga</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndingNoMatchingIf">
        <source>#endif has no matching #if</source>
        <target state="translated">#endif senza #if corrispondente</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifMustBeFirst">
        <source>#endif directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">La direttiva #endif deve trovarsi all'inizio di una riga</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustHaveIdent">
        <source>#if directive should be immediately followed by an identifier</source>
        <target state="translated">La direttiva #if deve essere immediatamente seguita da un identificatore</target>
        <note />
      </trans-unit>
      <trans-unit id="lexWrongNestedHashEndif">
        <source>Syntax error. Wrong nested #endif, unexpected tokens before it.</source>
        <target state="translated">Errore di sintassi. Direttiva #endif annidata non corretta, preceduta da token non previsti.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashBangMustBeFirstInFile">
        <source>#! may only appear as the first line at the start of a file.</source>
        <target state="translated">#! è ammesso solo come prima riga all'inizio di un file.</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexExpectedSingleLineComment">
        <source>Expected single line comment or end of line</source>
        <target state="translated">È previsto un commento a riga singola o la fine della riga</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNoArguments">
        <source>Infix operator member '{0}' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Il membro dell'operatore infisso '{0}' non ha argomenti. Prevista una tupla di 2 argomenti, ad esempio un membro statico (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonPairArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Il membro dell'operatore infisso '{0}' ha {1} argomento/i iniziale/i. Prevista una tupla di 2 argomenti, ad esempio un membro statico (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithCurriedArguments">
        <source>Infix operator member '{0}' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Il membro dell'operatore infisso '{0}' contiene argomenti sottoposti a currying aggiuntivi. Prevista una tupla di 2 argomenti, ad esempio un membro statico (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFSharpCoreRequiresExplicit">
        <source>All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'</source>
        <target state="translated">A tutti i tipi di struct, record e unione in FSharp.Core.dll deve essere assegnata in modo esplicito l'etichetta 'StructuralComparison' o 'NoComparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the type parameter '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter</source>
        <target state="translated">Il tipo di unione, struct o record '{0}' contiene l'attributo 'StructuralComparison' ma il parametro di tipo '{1}' non soddisfa il vincolo 'comparison'. Provare ad aggiungere il vincolo 'comparison' al parametro di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the component type '{1}' does not satisfy the 'comparison' constraint</source>
        <target state="translated">Il tipo di unione, struct o record '{0}' contiene l'attributo 'StructuralComparison' ma il tipo di componente '{1}' non soddisfa il vincolo 'comparison'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded1">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type parameter {1} does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">Il tipo di unione, struct o record '{0}' non è confrontabile a livello di struttura perché il parametro di tipo {1} non soddisfa il vincolo 'comparison'. Provare ad aggiungere l'attributo 'NoComparison' al tipo '{2}' per chiarire che il tipo non è confrontabile</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded2">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">Il tipo di unione, struct o record '{0}' non è confrontabile a livello di struttura perché il tipo '{1}' non soddisfa il vincolo 'comparison'. Provare ad aggiungere l'attributo 'NoComparison' al tipo '{2}' per chiarire che il tipo non è confrontabile</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded1">
        <source>The struct, record or union type '{0}' does not support structural equality because the type parameter {1} does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">Il tipo di unione, struct o record '{0}' non supporta l'uguaglianza strutturale perché il parametro di tipo {1} non soddisfa il vincolo 'equality'. Provare ad aggiungere l'attributo 'NoEquality' al tipo '{2}' per chiarire che il tipo non supporta l'uguaglianza strutturale</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded2">
        <source>The struct, record or union type '{0}' does not support structural equality because the type '{1}' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">Il tipo di unione, struct o record '{0}' non supporta l'uguaglianza strutturale perché il tipo '{1}' non soddisfa il vincolo 'equality'. Provare ad aggiungere l'attributo 'NoEquality' al tipo '{2}' per chiarire che il tipo non supporta l'uguaglianza strutturale</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the type parameter '{1}' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter</source>
        <target state="translated">Il tipo di unione, struct o record '{0}' contiene l'attributo 'StructuralEquality' ma il parametro di tipo '{1}' non soddisfa il vincolo 'equality'. Provare ad aggiungere il vincolo 'equality' al parametro di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the component type '{1}' does not satisfy the 'equality' constraint</source>
        <target state="translated">Il tipo di unione, struct o record '{0}' contiene l'attributo 'StructuralEquality' ma il tipo di componente '{1}' non soddisfa il vincolo 'equality'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
        <source>Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct.</source>
        <target state="translated">A ogni argomento del costruttore primario per uno struct deve essere assegnato un tipo, ad esempio 'type S(x1:int, x2: int) = ...'. Tali argomenti determinano i campi dello struct.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedValue">
        <source>The value '{0}' is unused</source>
        <target state="translated">Valore '{0}' non utilizzato</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedThisVariable">
        <source>The recursive object reference '{0}' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.</source>
        <target state="translated">Riferimento ricorsivo a oggetto '{0}' non usato. La presenza di un riferimento ricorsivo a un oggetto aggiunge verifiche di inizializzazione del runtime ai membri in questo tipo e nei relativi tipi derivati. Provare a rimuovere il riferimento ricorsivo all'oggetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterAtMostOneArgument">
        <source>A getter property may have at most one argument group</source>
        <target state="translated">Una proprietà di getter può contenere al massimo un gruppo di argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetterAtMostTwoArguments">
        <source>A setter property may have at most two argument groups</source>
        <target state="translated">Una proprietà di setter può contenere al massimo due gruppi di argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidProperty">
        <source>Invalid property getter or setter</source>
        <target state="translated">Getter o setter della proprietà non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIndexerPropertyRequiresAtLeastOneArgument">
        <source>An indexer property must be given at least one argument</source>
        <target state="translated">A una proprietà di indicizzatore deve essere assegnato almeno un argomento</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidAddressOfMutableAcrossAssemblyBoundary">
        <source>This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation</source>
        <target state="translated">Questa operazione accede a un valore di livello superiore modificabile definito in un altro assembly in un modo non supportato. Non è possibile accedere al valore tramite il relativo indirizzo. Provare a copiare l'espressione in un valore locale modificabile, ad esempio 'let mutable x = ...' e, se necessario, ad assegnare nuovamente il valore dopo il completamento dell'operazione</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTypars">
        <source>Remove spaces between the type name and type parameter, e.g. \"type C&lt;'T&gt;\", not type \"C   &lt;'T&gt;\". Type parameters must be placed directly adjacent to the type name.</source>
        <target state="translated">Rimuovere gli spazi tra il nome del tipo e il parametro di tipo, ad esempio \"type C&lt;'T&gt;\", non \"type C   &lt;'T&gt;\". I parametri di tipo devono essere direttamente adiacenti al nome del tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTyargs">
        <source>Remove spaces between the type name and type parameter, e.g. \"C&lt;'T&gt;\", not \"C &lt;'T&gt;\". Type parameters must be placed directly adjacent to the type name.</source>
        <target state="translated">Rimuovere gli spazi tra il nome del tipo e il parametro di tipo, ad esempio \"C&lt;'T&gt;\", non \"C &lt;'T&gt;\". I parametri di tipo devono essere direttamente adiacenti al nome del tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAtomicType">
        <source>The use of the type syntax 'int C' and 'C  &lt;int&gt;' is not permitted here. Consider adjusting this type to be written in the form 'C&lt;int&gt;'</source>
        <target state="translated">Uso della sintassi di tipo 'int C' e 'C  &lt;int&gt;' non consentito in questa posizione. Provare a modificare il tipo in modo che sia scritto nel formato 'C&lt;int&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespace">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the module/namespace '{2}'</source>
        <target state="translated">Il modulo/spazio dei nomi '{0}' dell'unità di compilazione '{1}' non contiene il modulo/spazio dei nomi '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefVal">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the val '{2}'</source>
        <target state="translated">Il modulo/spazio dei nomi '{0}' dell'unità di compilazione '{1}' non contiene il valore '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespaceType">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the namespace, module or type '{2}'</source>
        <target state="translated">Il modulo/spazio dei nomi '{0}' dell'unità di compilazione '{1}' non contiene lo spazio dei nomi, il modulo o il tipo '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseNullAsTrueValue">
        <source>The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case</source>
        <target state="translated">Il flag di attributo 'UseNullAsTrueValue' può essere utilizzato solo con tipi di unione che hanno un case nullary e almeno un case non nullary</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterInferredByref">
        <source>The parameter '{0}' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref&lt;int&gt;'. When used, a byref parameter is implicitly dereferenced.</source>
        <target state="translated">Per il parametro '{0}' è stato dedotto il tipo byref. Ai parametri di tipo byref deve essere associata un'annotazione di tipo esplicita, ad esempio 'x1: byref&lt;int&gt;'. Se usato, un parametro byref viene dereferenziato in modo implicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonUniformMemberUse">
        <source>The generic member '{0}' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.</source>
        <target state="translated">Il membro generico '{0}' è stato utilizzato in una creazione di istanza non uniforme prima di questo punto del programma. Provare a riordinare i membri in modo che questo si trovi prima. In alternativa, specificare il tipo completo del membro in modo esplicito, con tipi di argomento, tipo restituito ed eventuali vincoli e parametri generici aggiuntivi.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttribArgsDiffer">
        <source>The attribute '{0}' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.</source>
        <target state="translated">L'attributo '{0}' è presente nell'implementazione e nella firma, ma gli argomenti degli attributi differiscono. Nel codice compilato verrà incluso solo l'attributo della firma.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallAbstractBaseMember">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">Non è possibile chiamare un membro di base astratto: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInUnmanaged">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position</source>
        <target state="translated">Non è stato possibile risolvere l'ambiguità relativa all'uso di un costrutto generico con un vincolo 'unmanaged' in questa posizione o in prossimità di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="mlCompatMessage">
        <source>This construct is for ML compatibility. {0}. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'.</source>
        <target state="translated">Il costruttore è per la compatibilità ML. {0}. È possibile disabilitare questo avviso tramite '--mlcompatibility' o '--nowarn:62'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldDoesNotHaveValidOffsetForStructureLayout">
        <source>The type '{0}' has been marked as having an Explicit layout, but the field '{1}' has not been marked with the 'FieldOffset' attribute</source>
        <target state="translated">Il tipo '{0}' è stato contrassegnato con il layout esplicito, ma il campo '{1}' non è stato contrassegnato con l'attributo 'FieldOffset'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfacesShouldUseInheritNotInterface">
        <source>Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'</source>
        <target state="translated">Le interfacce ereditate da altre interfacce devono essere dichiarate tramite 'inherit ...' anziché 'interface ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperator">
        <source>Invalid prefix operator</source>
        <target state="translated">Operatore prefisso non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperatorDefinition">
        <source>Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.</source>
        <target state="translated">Definizione di operatore non valida. Le definizioni di operatore prefisso devono utilizzare un nome di operatore prefisso valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCompilingExtensionIsForML">
        <source>The file extensions '.ml' and '.mli' are for ML compatibility</source>
        <target state="translated">Le estensioni di file '.ml' e '.mli' sono per la compatibilità ML</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIndentOffForML">
        <source>Consider using a file with extension '.ml' or '.mli' instead</source>
        <target state="translated">Provare a utilizzare un file con estensione '.ml' o '.mli'</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternIdentIsNotFunctionTyped">
        <source>Active pattern '{0}' is not a function</source>
        <target state="translated">I criteri attivi '{0}' non sono una funzione</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternChoiceHasFreeTypars">
        <source>Active pattern '{0}' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</source>
        <target state="translated">I criteri attivi '{0}' hanno un tipo di risultati contenente variabili di tipo che non sono determinate dall'input. Probabilmente il case di risultato non è menzionato, ad esempio 'let (|A|B|) (x:int) = A x'. Il problema può essere risolto con un vincolo di tipo, ad esempio 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldHasOffsetForSequentialLayout">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">L'attributo FieldOffset può essere usato solo in membri di tipo contrassegnati con StructLayout(LayoutKind.Explicit)</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsMustComeAfterNonOptionalArgs">
        <source>Optional arguments must come at the end of the argument list, after any non-optional arguments</source>
        <target state="translated">Gli argomenti facoltativi devono essere aggiungi alla fine dell'elenco degli argomenti, dopo quelli obbligatori</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeUsage">
        <source>Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes</source>
        <target state="translated">L'attributo 'System.Diagnostics.ConditionalAttribute' è valido solo in classi di attributi o metodi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOperatorDefinitionInExtrinsic">
        <source>Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.</source>
        <target state="translated">I membri di estensione non possono fornire overload di operatori. Provare a definire l'operatore come parte della definizione del tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBFileNameCannotBeChangedWarning">
        <source>The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.</source>
        <target state="translated">Il nome del file MDB deve essere &lt;nome-file-assembly&gt;.mdb. L'opzione --pdb verrà ignorata.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBMemberMissing">
        <source>MDB generation failed. Could not find compatible member {0}</source>
        <target state="translated">La generazione del file MDB non è riuscita. Il membro compatibile {0} non è stato trovato</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingMdb">
        <source>Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly.</source>
        <target state="translated">Non è possibile generare informazioni di debug MDB. Non è stato possibile caricare il tipo 'MonoSymbolWriter' dall'assembly 'Mono.CompilerServices.SymbolWriter.dll'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseNameConflictsWithGeneratedType">
        <source>The union case named '{0}' conflicts with the generated type '{1}'</source>
        <target state="translated">Il case di unione denominato '{0}' è in conflitto con il tipo generato '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoReflectedDefinitionOnStructMember">
        <source>ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter</source>
        <target state="translated">ReflectedDefinitionAttribute non può essere applicato a un membro di istanza in un tipo di struct perché il membro di istanza accetta un parametro byref implicito 'this'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportNotAllowed">
        <source>DLLImport bindings must be static members in a class or function definitions in a module</source>
        <target state="translated">I binding DLLImport devono essere membri statici in una classe o definizioni di funzione in un modulo</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedSigdataFile">
        <source>FSharp.Core.sigdata not found alongside FSharp.Core. File expected in {0}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">Il file FSharp.Core.sigdata non è stato trovato con FSharp.Core. Il file deve trovarsi in {0}. Provare a eseguire l'aggiornamento a una versione più recente di FSharp.Core, in cui questo file non è più obbligatorio.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedFileAlongSideFSharpCore">
        <source>File '{0}' not found alongside FSharp.Core. File expected in {1}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">Il file '{0}' non è stato trovato con FSharp.Core. Il file deve trovarsi in {1}. Provare a eseguire l'aggiornamento a una versione più recente di FSharp.Core, in cui questo file non è più obbligatorio.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedFileNameCharacter">
        <source>Filename '{0}' contains invalid character '{1}'</source>
        <target state="translated">Il nome file '{0}' contiene il carattere non valido '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBinding">
        <source>'use!' bindings must be of the form 'use! &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">Il formato dei binding 'use!' deve essere 'use! &lt;var&gt; = &lt;expr&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoInnerGenericsInQuotations">
        <source>Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.</source>
        <target state="translated">Nelle espressioni in quotation non sono consentite funzioni generiche interne. Provare ad aggiungere alcuni vincoli di tipo in modo che la funzione non sia più generica.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumTypeCannotBeEnumerated">
        <source>The type '{0}' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property</source>
        <target state="translated">Il tipo '{0}' non è un tipo di enumeratore valido, ad esempio non contiene un metodo 'MoveNext()' che restituisce un valore bool e una proprietà 'Current'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteString">
        <source>End of file in triple-quote string begun at or before here</source>
        <target state="translated">La fine del file nella stringa con virgolette triple inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteStringInComment">
        <source>End of file in triple-quote string embedded in comment begun at or before here</source>
        <target state="translated">La fine del file nella stringa con virgolette triple incorporata nel commento inizia in questa posizione o prima di essa</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLosesMeasures">
        <source>This type test or downcast will ignore the unit-of-measure '{0}'</source>
        <target state="translated">Questo test di tipo o downcast ignorerà l'unità di misura '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingTypeArgs">
        <source>Expected type argument or static argument</source>
        <target state="translated">Previsto argomento tipo o statico</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingGreaterThan">
        <source>Unmatched '&lt;'. Expected closing '&gt;'</source>
        <target state="translated">'&lt;' senza corrispondenza. È previsto '&gt;' di chiusura</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
        <source>Unexpected quotation operator '&lt;@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '&lt;' and '@' characters.</source>
        <target state="translated">Operatore di quotation '&lt;@' imprevisto nella definizione di tipo. Se si vuole passare una stringa verbatim come argomento statico a un provider di tipi, mettere uno spazio tra i caratteri '&lt;' e '@'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorParsingAsOperatorName">
        <source>Attempted to parse this as an operator name, but failed</source>
        <target state="translated">Si è tentato di analizzare questo elemento come nome operatore, ma l'operazione non è riuscita</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidUnicodeLiteral">
        <source>\U{0} is not a valid Unicode character escape sequence</source>
        <target state="translated">\U{0} non è una sequenza di escape di caratteri Unicode valida</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoWrongType">
        <source>'{0}' must be applied to an argument of type '{1}', but has been applied to an argument of type '{2}'</source>
        <target state="translated">'{0}' deve essere applicato a un argomento di tipo '{1}', ma è stato applicato a un argomento di tipo '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoNotOptional">
        <source>'{0}' can only be applied to optional arguments</source>
        <target state="translated">'{0}' può essere applicato solo ad argomenti facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="toolLocationHelperUnsupportedFrameworkVersion">
        <source>The specified .NET Framework version '{0}' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
        <target state="translated">La versione di .NET Framework '{0}' specificata non è supportata. Specificare un valore dall'enumerazione Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidMagicValue">
        <source>Invalid Magic value in CLR Header</source>
        <target state="translated">Il valore di Magic non è valido nell'intestazione CLR</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignBadImageFormat">
        <source>Bad image format</source>
        <target state="translated">Il formato dell'immagine non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignPrivateKeyExpected">
        <source>Private key expected</source>
        <target state="translated">È prevista la chiave privata</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignRsaKeyExpected">
        <source>RSA key expected</source>
        <target state="translated">È prevista la chiave RSA</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidBitLen">
        <source>Invalid bit Length</source>
        <target state="translated">La lunghezza in bit non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidRSAParams">
        <source>Invalid RSAParameters structure - '{{0}}' expected</source>
        <target state="translated">La struttura RSAParameters non è valida. È previsto '{{0}}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidAlgId">
        <source>Invalid algId - 'Exponent' expected</source>
        <target state="translated">Il valore di algId non è valido. È previsto 'Exponent'</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidSignatureSize">
        <source>Invalid signature size</source>
        <target state="translated">Le dimensioni della firma non sono valide</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignNoSignatureDirectory">
        <source>No signature directory</source>
        <target state="translated">Non esiste alcuna directory delle firme</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidPKBlob">
        <source>Invalid Public Key blob</source>
        <target state="translated">Il BLOB di chiave pubblica non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTooManyErrors">
        <source>Exiting - too many errors</source>
        <target state="translated">Uscita in corso: troppi errori</target>
        <note />
      </trans-unit>
      <trans-unit id="docfileNoXmlSuffix">
        <source>The documentation file has no .xml suffix</source>
        <target state="translated">Il file della documentazione non ha suffisso .xml</target>
        <note />
      </trans-unit>
      <trans-unit id="fscNoImplementationFiles">
        <source>No implementation files specified</source>
        <target state="translated">Nessun file di implementazione specificato</target>
        <note />
      </trans-unit>
      <trans-unit id="fscBadAssemblyVersion">
        <source>The attribute {0} specified version '{1}', but this value is invalid and has been ignored</source>
        <target state="translated">L'attributo {0} ha specificato la versione '{1}', ma questo valore non è valido ed è stato ignorato</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTwoResourceManifests">
        <source>Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used.</source>
        <target state="translated">Specificate opzioni in conflitto: 'win32manifest' e 'win32res'. È possibile utilizzarne solo una.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking">
        <source>The code in assembly '{0}' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">Il codice nell'assembly '{0}' usa valori letterali di quotation. Il collegamento statico non può includere componenti che usano valori letterali di quotation a meno che tutti gli assembly non siano compilati con almeno F# 4.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking0">
        <source>Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">Il codice in questo assembly usa valori letterali di quotation. Il collegamento statico non può includere componenti che usano valori letterali di quotation a meno che tutti gli assembly non siano compilati con almeno F# 4.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoEXE">
        <source>Static linking may not include a .EXE</source>
        <target state="translated">Il collegamento statico non può includere un .EXE</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoMixedDLL">
        <source>Static linking may not include a mixed managed/unmanaged DLL</source>
        <target state="translated">Il collegamento dinamico non può includere una DLL mista gestita/non gestita</target>
        <note />
      </trans-unit>
      <trans-unit id="fscIgnoringMixedWhenLinking">
        <source>Ignoring mixed managed/unmanaged assembly '{0}' during static linking</source>
        <target state="translated">L'assembly misto gestito/non gestito '{0}' verrà ignorato durante il collegamento statico</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssumeStaticLinkContainsNoDependencies">
        <source>Assembly '{0}' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.</source>
        <target state="translated">All'assembly '{0}' viene fatto riferimento in modo transitivo e non è stato possibile risolvere l'assembly automaticamente. Ai fini del collegamento statico si presuppone che la DLL non abbia dipendenze nella libreria F# o in altre DLL collegate in modo statico. Provare ad aggiungere un riferimento esplicito alla DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyNotFoundInDependencySet">
        <source>Assembly '{0}' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.</source>
        <target state="translated">Assembly '{0}' non trovato nel set di dipendenze del file binario di destinazione. Le radici collegate in modo statico devono essere specificate mediante un nome di assembly, senza estensione dll o exe. Se viene fatto riferimento all'assembly in modo esplicito, è possibile che l'assembly non sia effettivamente necessario per il file binario generato. In tal caso, non deve essere collegato in modo statico.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileCouldNotBeOpened">
        <source>The key file '{0}' could not be opened</source>
        <target state="translated">Non è stato possibile aprire il file di chiave '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="fscProblemWritingBinary">
        <source>A problem occurred writing the binary '{0}': {1}</source>
        <target state="translated">Si è verificato un problema durante la scrittura del binario '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyVersionAttributeIgnored">
        <source>The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option</source>
        <target state="translated">'AssemblyVersionAttribute' ignorato. È stata specificata una versione mediante un'opzione della riga di comando</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyCultureAttributeError">
        <source>Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'</source>
        <target state="translated">Errore durante la creazione dell'attributo 'System.Reflection.AssemblyCultureAttribute' -- Gli eseguibili non possono essere assembly satellite e Culture deve essere sempre vuoto'</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDelaySignWarning">
        <source>Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module</source>
        <target state="translated">L'opzione '--delaysign' esegue l'override dell'attributo 'System.Reflection.AssemblyDelaySignAttribute' specificato in un file di codice sorgente o in un modulo aggiunto</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileWarning">
        <source>Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module</source>
        <target state="translated">L'opzione '--keyfile' esegue l'override dell'attributo 'System.Reflection.AssemblyKeyFileAttribute' specificato in un file di codice sorgente o in un modulo aggiunto</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyNameWarning">
        <source>Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module</source>
        <target state="translated">L'opzione '--keycontainer' esegue l'override dell'attributo 'System.Reflection.AssemblyNameAttribute' specificato in un file di codice sorgente o in un modulo aggiunto</target>
        <note />
      </trans-unit>
      <trans-unit id="fscReferenceOnCommandLine">
        <source>The assembly '{0}' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'.</source>
        <target state="translated">L'assembly '{0}' è elencato nella riga di comando. È necessario fare riferimento agli assembly utilizzando un flag della riga di comando quale '-r'.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscRemotingError">
        <source>The resident compilation service was not used because a problem occured in communicating with the server.</source>
        <target state="translated">Il servizio di compilazione residente non è stato usato perché si è verificato un problema nella comunicazione con il server.</target>
        <note />
      </trans-unit>
      <trans-unit id="pathIsInvalid">
        <source>Problem with filename '{0}': Illegal characters in path.</source>
        <target state="translated">Problema con il nome file '{0}': caratteri non validi nel percorso.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscResxSourceFileDeprecated">
        <source>Passing a .resx file ({0}) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.</source>
        <target state="translated">Il passaggio di un file con estensione resx ({0}) come file di origine al compilatore è deprecato. Usare resgen.exe per trasformare il file con estensione resx in un file con estensione resources da passare come opzione --resource. Se si usa MSBuild, tale operazione può esser eseguita mediante un elemento &lt;EmbeddedResource&gt; nel file di progetto con estensione fsproj.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoProfileMismatches">
        <source>Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).</source>
        <target state="translated">Non è possibile usare il collegamento statico in un assembly che fa riferimento a mscorlib (ad esempio un assembly .NET Framework) durante la generazione di un assembly che fa riferimento a System.Runtime (ad esempio un assembly .NET Core o Portable).</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyWildcardAndDeterminism">
        <source>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</source>
        <target state="translated">In un attributo {0} è stata specificata la versione '{1}', ma questo valore è un carattere jolly ed è stata richiesta una compilazione deterministica. Tali opzioni sono in conflitto.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDeterministicDebugRequiresPortablePdb">
        <source>Deterministic builds only support portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">Le compilazioni deterministiche supportano solo file PDB portabili (--debug:portable o --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInNamespaceName">
        <source>Character '{0}' is not allowed in provided namespace name '{1}'</source>
        <target state="translated">Il carattere '{0}' non è consentito nel nome dello spazio dei nomi fornito '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullOrEmptyMemberName">
        <source>The provided type '{0}' returned a member with a null or empty member name</source>
        <target state="translated">Membro con nome Null o vuoto restituito dal tipo fornito '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMember">
        <source>The provided type '{0}' returned a null member</source>
        <target state="translated">Membro Null restituito dal tipo fornito '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringType">
        <source>The provided type '{0}' member info '{1}' has null declaring type</source>
        <target state="translated">Le informazioni sul membro '{1}' del tipo fornito '{0}' contengono un tipo dichiarante Null</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringTypeDifferentFromProvidedType">
        <source>The provided type '{0}' has member '{1}' which has declaring type '{2}'. Expected declaring type to be the same as provided type.</source>
        <target state="translated">Il tipo fornito '{0}' contiene il membro '{1}' con il tipo dichiarante '{2}'. Il tipo dichiarante previsto deve essere dello stesso tipo di quello fornito.</target>
        <note />
      </trans-unit>
      <trans-unit id="etHostingAssemblyFoundWithoutHosts">
        <source>Referenced assembly '{0}' has assembly level attribute '{1}' but no public type provider classes were found</source>
        <target state="translated">L'assembly '{0}' a cui viene fatto riferimento contiene l'attributo a livello di assembly '{1}' ma non è stata trovata alcuna classe di provider di tipi pubblica</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceOfTypeNotAllowed">
        <source>Type '{0}' from type provider '{1}' has an empty namespace. Use 'null' for the global namespace.</source>
        <target state="translated">Il tipo '{0}' nel provider di tipi '{1}' contiene uno spazio dei nomi vuoto. Usare 'null' per lo spazio dei nomi globale.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceNotAllowed">
        <source>Empty namespace found from the type provider '{0}'. Use 'null' for the global namespace.</source>
        <target state="translated">Spazio dei nomi vuoto trovato nel provider di tipi '{0}'. Utilizzare 'null' per lo spazio dei nomi globale.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeGeneric">
        <source>Provided type '{0}' has 'IsGenericType' as true, but generic types are not supported.</source>
        <target state="translated">Nel tipo fornito '{0}' 'IsGenericType' è impostato su true, ma i tipi generici non sono supportati.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeAnArray">
        <source>Provided type '{0}' has 'IsArray' as true, but array types are not supported.</source>
        <target state="translated">Nel tipo fornito '{0}' 'IsArray' è impostato su true, ma i tipi matrice non sono supportati.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMethodHasRequirements">
        <source>Invalid member '{0}' on provided type '{1}'. Provided type members must be public, and not be generic, virtual, or abstract.</source>
        <target state="translated">Membro '{0}' non valido nel tipo fornito '{1}'. I membri dei tipi forniti devono essere pubblici e non generici, virtuali o astratti.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedMemberKind">
        <source>Invalid member '{0}' on provided type '{1}'. Only properties, methods and constructors are allowed</source>
        <target state="translated">Membro '{0}' non valido nel tipo fornito '{1}'. Sono consentiti solo costruttori, metodi e proprietà.</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanReadButHasNoGetter">
        <source>Property '{0}' on provided type '{1}' has CanRead=true but there was no value from GetGetMethod()</source>
        <target state="translated">La proprietà '{0}' nel tipo fornito '{1}' contiene CanRead=true ma non era presente alcun valore da GetGetMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasGetterButNoCanRead">
        <source>Property '{0}' on provided type '{1}' has CanRead=false but GetGetMethod() returned a method</source>
        <target state="translated">La proprietà '{0}' nel tipo fornito '{1}' contiene CanRead=false ma GetGetMethod() ha restituito un metodo</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanWriteButHasNoSetter">
        <source>Property '{0}' on provided type '{1}' has CanWrite=true but there was no value from GetSetMethod()</source>
        <target state="translated">La proprietà '{0}' nel tipo fornito '{1}' contiene CanWrite=true ma non era presente alcun valore da GetSetMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasSetterButNoCanWrite">
        <source>Property '{0}' on provided type '{1}' has CanWrite=false but GetSetMethod() returned a method</source>
        <target state="translated">La proprietà '{0}' nel tipo fornito '{1}' contiene CanWrite=false ma GetSetMethod() ha restituito un metodo</target>
        <note />
      </trans-unit>
      <trans-unit id="etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
        <source>One or more errors seen during provided type setup</source>
        <target state="translated">Uno o più errori visualizzati durante l'impostazione del tipo fornito</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedTypeMember">
        <source>Unexpected exception from provided type '{0}' member '{1}': {2}</source>
        <target state="translated">Eccezione imprevista dal tipo fornito '{0}' membro '{1}': {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedConstantType">
        <source>Unsupported constant type '{0}'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal.</source>
        <target state="translated">Il tipo di costante '{0}' non è supportato. Le quotation fornite da provider di tipi possono contenere solo costanti semplici. Potrebbe essere necessario modificare l'implementazione del provider di tipi spostando un valore dichiarato all'esterno di un valore letterale di tipo quotation in modo che sia un binding 'let' all'interno del valore letterale di tipo quotation.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedProvidedExpression">
        <source>Unsupported expression '{0}' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.</source>
        <target state="translated">Espressione '{0}' non supportata dal provider di tipi. Se l'utente è l'autore di questo provider di tipi, provare a fornire un'espressione differente.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedName">
        <source>Expected provided type named '{0}' but provided type has 'Name' with value '{1}'</source>
        <target state="translated">Era previsto un tipo fornito denominato '{0}', mentre il tipo fornito contiene 'Name' con valore '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoAdd">
        <source>Event '{0}' on provided type '{1}' has no value from GetAddMethod()</source>
        <target state="translated">L'evento '{0}' nel tipo fornito '{1}' non contiene un valore di GetAddMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoRemove">
        <source>Event '{0}' on provided type '{1}' has no value from GetRemoveMethod()</source>
        <target state="translated">L'evento '{0}' nel tipo fornito '{1}' non contiene un valore di GetRemoveMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssembly">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded from path '{2}'. The exception reported was: {3} - {4}</source>
        <target state="translated">L'attributo di assembly '{0}' fa riferimento a un assembly '{1}' della finestra di progettazione che non può essere caricato dal percorso '{2}'. L'eccezione restituita è {3} - {4}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderDoesNotHaveValidConstructor">
        <source>The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected.</source>
        <target state="translated">Il provider di tipi non contiene un costruttore valido. Era previsto un costruttore che non accetta argomenti o che accetta un solo argomento di tipo 'TypeProviderConfig'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderError">
        <source>The type provider '{0}' reported an error: {1}</source>
        <target state="translated">Errore segnalato dal provider di tipi '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectParameterExpression">
        <source>The type provider '{0}' used an invalid parameter in the ParameterExpression: {1}</source>
        <target state="translated">Parametro non valido utilizzato dal provider di tipi '{0}' in ParameterExpression: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedMethod">
        <source>The type provider '{0}' provided a method with a name '{1}' and metadata token '{2}', which is not reported among its methods of its declaring type '{3}'</source>
        <target state="translated">Il provider di tipi '{0}' ha fornito un metodo con nome '{1}' e token metadati '{2}' che non è indicato tra i metodi del tipo dichiarante '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedConstructor">
        <source>The type provider '{0}' provided a constructor which is not reported among the constructors of its declaring type '{1}'</source>
        <target state="translated">Il costruttore fornito dal provider di tipi '{0}' non è riportato tra i costruttori del tipo dichiarante '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etDirectReferenceToGeneratedTypeNotAllowed">
        <source>A direct reference to the generated type '{0}' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = &lt;path&gt;'. This indicates that a type provider adds generated types to your assembly.</source>
        <target state="translated">Un riferimento diretto al tipo generato '{0}' non è consentito. Usare invece una definizione di tipo, ad esempio 'type TypeAlias = &lt;path&gt;'. Questa definizione indica che un provider di tipi aggiunge tipi generati all'assembly usato.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedPath">
        <source>Expected provided type with path '{0}' but provided type has path '{1}'</source>
        <target state="translated">Era previsto un tipo fornito con percorso '{0}', mentre il tipo fornito contiene il percorso '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedNullFromProvidedTypeMember">
        <source>Unexpected 'null' return value from provided type '{0}' member '{1}'</source>
        <target state="translated">Valore restituito 'null' imprevisto dal tipo fornito '{0}' membro '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedMemberMember">
        <source>Unexpected exception from member '{0}' of provided type '{1}' member '{2}': {3}</source>
        <target state="translated">Eccezione imprevista dal membro '{0}' del tipo fornito '{1}' membro '{2}': {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
        <source>Nested provided types do not take static arguments or generic parameters</source>
        <target state="translated">I tipi forniti annidati non accettano argomenti statici né parametrici generici</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidStaticArgument">
        <source>Invalid static argument to provided type. Expected an argument of kind '{0}'.</source>
        <target state="translated">Argomento statico non valido nel tipo fornito. È previsto un argomento di tipo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToType">
        <source>An error occured applying the static arguments to a provided type</source>
        <target state="translated">Errore durante l'applicazione degli argomenti statici a un tipo fornito</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnknownStaticArgumentKind">
        <source>Unknown static argument kind '{0}' when resolving a reference to a provided type or method '{1}'</source>
        <target state="translated">Tipo di argomento statico '{0}' sconosciuto durante la risoluzione di un riferimento a un tipo o a un metodo fornito '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidNamespaceForProvidedType">
        <source>invalid namespace for provided type</source>
        <target state="translated">spazio dei nomi non valido per il tipo fornito</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidFullNameForProvidedType">
        <source>invalid full name for provided type</source>
        <target state="translated">nome completo non valido per il tipo fornito</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderReturnedNull">
        <source>The type provider returned 'null', which is not a valid return value from '{0}'</source>
        <target state="translated">Il provider di tipi ha restituito 'null', che non è un valore restituito valido per '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etTypeProviderConstructorException">
        <source>The type provider constructor has thrown an exception: {0}</source>
        <target state="translated">Eccezione generata dal costruttore del provider di tipi: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullProvidedExpression">
        <source>Type provider '{0}' returned null from GetInvokerExpression.</source>
        <target state="translated">Valore Null restituito da GetInvokerExpression dal provider di tipi '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedTypeHadWrongName">
        <source>The type provider '{0}' returned an invalid type from 'ApplyStaticArguments'. A type with name '{1}' was expected, but a type with name '{2}' was returned.</source>
        <target state="translated">Tipo non valido restituito da 'ApplyStaticArguments' dal provider di tipi '{0}'. Era previsto un tipo con nome '{1}', mentre è stato restituito un tipo con nome '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedMethodHadWrongName">
        <source>The type provider '{0}' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '{1}' was expected, but a method with name '{2}' was returned.</source>
        <target state="translated">Il provider di tipi '{0}' ha restituito un metodo non valido da 'ApplyStaticArgumentsForMethod'. Era previsto un metodo con nome '{1}', mentre ne è stato restituito uno con nome '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLossy">
        <source>This type test or downcast will erase the provided type '{0}' to the type '{1}'</source>
        <target state="translated">Questo test di tipo o downcast cancellerà il tipo fornito '{0}' nel tipo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCastErased">
        <source>This downcast will erase the provided type '{0}' to the type '{1}'.</source>
        <target state="translated">Questo downcast cancellerà il tipo fornito '{0}' nel tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestErased">
        <source>This type test with a provided type '{0}' is not allowed because this provided type will be erased to '{1}' at runtime.</source>
        <target state="translated">Questo test di tipo con un tipo fornito '{0}' non è consentito perché il tipo fornito verrà cancellato in '{1}' in fase di esecuzione.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromErasedType">
        <source>Cannot inherit from erased provided type</source>
        <target state="translated">Non è possibile ereditare dal tipo fornito cancellato</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidTypeProviderAssemblyName">
        <source>Assembly '{0}' hase TypeProviderAssembly attribute with invalid value '{1}'. The value should be a valid assembly name</source>
        <target state="translated">Valore '{1}' non valido dell'attributo TypeProviderAssembly nell'assembly '{0}'. Il valore deve essere un nome di assembly valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameCtor">
        <source>Invalid member name. Members may not have name '.ctor' or '.cctor'</source>
        <target state="translated">Nome del membro non valido. I membri non possono avere '.ctor' o '.cctor' come nome.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInferredGenericTypeGivesRiseToInconsistency">
        <source>The function or member '{0}' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '{1}'.</source>
        <target state="translated">La funzione o il membro '{0}' viene usato in un modo che richiede ulteriori annotazioni di tipo in corrispondenza della relativa definizione per garantire la coerenza dei tipi dedotti. La firma dedotta è '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentCount">
        <source>The number of type arguments did not match: '{0}' given, '{1}' expected. This may be related to a previously reported error.</source>
        <target state="translated">Il numero di argomenti tipo non corrisponde: '{0}' specificati, '{1}' previsti. Tale condizione potrebbe essere correlata a un errore segnalato in precedenza.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotOverrideSealedMethod">
        <source>Cannot override inherited member '{0}' because it is sealed</source>
        <target state="translated">Non è possibile eseguire l'override del membro ereditato '{0}' perché è sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderErrorWithContext">
        <source>The type provider '{0}' reported an error in the context of provided type '{1}', member '{2}'. The error: {3}</source>
        <target state="translated">Errore segnalato dal provider di tipi '{0}' nel contesto del tipo fornito '{1}', membro '{2}'. Errore: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNameException">
        <source>An exception occurred when accessing the '{0}' of a provided type: {1}</source>
        <target state="translated">Eccezione durante l'accesso all'oggetto '{0}' di un tipo fornito: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNullOrEmptyName">
        <source>The '{0}' of a provided type was null or empty.</source>
        <target state="translated">L'oggetto '{0}' di un tipo fornito è Null o vuoto.</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInTypeName">
        <source>Character '{0}' is not allowed in provided type name '{1}'</source>
        <target state="translated">Il carattere '{0}' non è consentito nel nome del tipo fornito '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcJoinMustUseSimplePattern">
        <source>In queries, '{0}' must use a simple pattern</source>
        <target state="translated">Nelle query '{0}' deve essere un modello semplice</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMissingCustomOperation">
        <source>A custom query operation for '{0}' is required but not specified</source>
        <target state="translated">Un'operazione di query personalizzata per '{0}' è obbligatoria ma non è stata specificata</target>
        <note />
      </trans-unit>
      <trans-unit id="etBadUnnamedStaticArgs">
        <source>Named static arguments must come after all unnamed static arguments</source>
        <target state="translated">Gli argomenti statici denominati devono seguire tutti gli argomenti statici non denominati</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterRequiresAValue">
        <source>The static parameter '{0}' of the provided type or method '{1}' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '{2}&lt;{3}=...&gt;'.</source>
        <target state="translated">Il parametro statico '{0}' del tipo o del metodo specificato '{1}' richiede un valore. I parametri statici per i provider di tipi possono essere specificati facoltativamente mediante argomenti denominati, ad esempio '{2}&lt;{3}=...&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNoStaticParameterWithName">
        <source>No static parameter exists with name '{0}'</source>
        <target state="translated">Non sono presenti parametri statici denominati '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterAlreadyHasValue">
        <source>The static parameter '{0}' has already been given a value</source>
        <target state="translated">Al parametro statico '{0}' è già stato assegnato un valore</target>
        <note />
      </trans-unit>
      <trans-unit id="etMultipleStaticParameterWithName">
        <source>Multiple static parameters exist with name '{0}'</source>
        <target state="translated">Esistono più parametri statici con il nome '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
        <source>A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression</source>
        <target state="translated">Non è possibile usare un'operazione personalizzata unitamente a un non valore o a un binding 'let' ricorsivo in un'altra parte di questa espressione di calcolo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedHere">
        <source>A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression</source>
        <target state="translated">Un'operazione personalizzata non può essere utilizzata insieme agli operatori 'use', 'try/with', 'try/finally', 'if/then/else' o 'match' all'interno dell'espressione di calcolo corrente</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeOverloaded">
        <source>The custom operation '{0}' refers to a method which is overloaded. The implementations of custom operations may not be overloaded.</source>
        <target state="translated">L'operazione personalizzata '{0}' fa riferimento a un metodo sottoposto a overload. Non è possibile eseguire l'overload delle implementazioni delle operazioni personalizzate.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIfThenElseMayNotBeUsedWithinQueries">
        <source>An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.</source>
        <target state="translated">Un'espressione if/then/else non può essere utilizzata nelle query. Provare a utilizzare un'espressione if/then o un'espressione sequenza.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
        <source>Invalid argument to 'methodhandleof' during codegen</source>
        <target state="translated">Argomento non valido in 'methodhandleof' durante codegen</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceMissingArgument">
        <source>A reference to a provided type was missing a value for the static parameter '{0}'. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">In un riferimento a un tipo fornito manca un valore per il parametro statico '{0}'. Potrebbe essere necessario ricompilare uno o più assembly a cui viene fatto riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceInvalidText">
        <source>A reference to a provided type had an invalid value '{0}' for a static parameter. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">Un riferimento a un tipo fornito contiene un valore '{0}' non valido per un parametro statico. Potrebbe essere necessario ricompilare uno o più assembly a cui viene fatto riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly">
        <source>'{0}' is not used correctly. This is a custom operation in this query or computation expression.</source>
        <target state="translated">'{0}' non è utilizzato correttamente. Si tratta di un'operazione personalizzata nella query o nell'espressione di calcolo corrente.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly2">
        <source>'{0}' is not used correctly. Usage: {1}. This is a custom operation in this query or computation expression.</source>
        <target state="translated">'{0}' non è usato correttamente. Utilizzo: {1}. Si tratta di un'operazione personalizzata nella query o nell'espressione di calcolo corrente.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeJoin">
        <source>{0} var in collection {1} (outerKey = innerKey). Note that parentheses are required after '{2}'</source>
        <target state="translated">{0} var nella raccolta {1} (outerKey = innerKey). Si noti che dopo '{2}' le parentesi sono obbligatorie</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeGroupJoin">
        <source>{0} var in collection {1} (outerKey = innerKey) into group. Note that parentheses are required after '{2}'</source>
        <target state="translated">{0} var nella raccolta {1} (outerKey = innerKey) nel gruppo. Si noti che dopo '{2}' le parentesi sono obbligatorie</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeZip">
        <source>{0} var in collection</source>
        <target state="translated">{0} var nella raccolta</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresVariable">
        <source>'{0}' must be followed by a variable name. Usage: {1}.</source>
        <target state="translated">'{0}' deve essere seguito da un nome di variabile. Utilizzo: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorIncorrectSyntax">
        <source>Incorrect syntax for '{0}'. Usage: {1}.</source>
        <target state="translated">Sintassi non corretta per '{0}'. Utilizzo: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresBody">
        <source>'{0}' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... {1} ...</source>
        <target state="translated">'{0}' deve essere preceduto da una clausola di selezione 'for' e seguito dal resto della query. Sintassi: ... {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationHasIncorrectArgCount">
        <source>'{0}' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected {1} argument(s), but given {2}.</source>
        <target state="translated">'{0}' è usato con un numero di argomenti non corretto. Si tratta di un'operazione personalizzata nella query o nell'espressione di calcolo corrente. Argomenti previsti: {1}. Argomenti specificati: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterToken">
        <source>Expected an expression after this point</source>
        <target state="translated">Prevista un'espressione dopo questa posizione</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedTypeAfterToken">
        <source>Expected a type after this point</source>
        <target state="translated">Previsto un tipo dopo questa posizione</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLBrackLess">
        <source>Unmatched '[&lt;'. Expected closing '&gt;]'</source>
        <target state="translated">'[&lt;' senza corrispondenza. È previsto '&gt;]' di chiusura</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileMatch">
        <source>Unexpected end of input in 'match' expression. Expected 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</source>
        <target state="translated">Fine dell'input imprevista nell'espressione 'match'. È previsto 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTry">
        <source>Unexpected end of input in 'try' expression. Expected 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;'.</source>
        <target state="translated">Fine dell'input imprevista nell'espressione 'try'. È previsto 'try &lt;expr&gt; with &lt;rules&gt;' o 'try &lt;expr&gt; finally &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWhile">
        <source>Unexpected end of input in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Fine dell'input imprevista nell'espressione 'while'. È previsto 'while &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFor">
        <source>Unexpected end of input in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Fine dell'input imprevista nell'espressione 'for'. È previsto 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWith">
        <source>Unexpected end of input in 'match' or 'try' expression</source>
        <target state="translated">Fine dell'input imprevista nell'espressione 'match' o 'try'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileThen">
        <source>Unexpected end of input in 'then' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Fine dell'input imprevista nel ramo 'then' dell'espressione condizionale. È previsto 'if &lt;expr&gt; then &lt;expr&gt;' o 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileElse">
        <source>Unexpected end of input in 'else' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Fine dell'input imprevista nel ramo 'else' dell'espressione condizionale. È previsto 'if &lt;expr&gt; then &lt;expr&gt;' o 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFunBody">
        <source>Unexpected end of input in body of lambda expression. Expected 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</source>
        <target state="translated">Fine dell'input imprevista nel corpo dell'espressione lambda. È previsto 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeArgs">
        <source>Unexpected end of input in type arguments</source>
        <target state="translated">Fine dell'input imprevista negli argomenti tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeSignature">
        <source>Unexpected end of input in type signature</source>
        <target state="translated">Fine dell'input imprevista nella firma del tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeDefinition">
        <source>Unexpected end of input in type definition</source>
        <target state="translated">Fine dell'input imprevista nella definizione di tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileObjectMembers">
        <source>Unexpected end of input in object members</source>
        <target state="translated">Fine dell'input imprevista nei membri di oggetti</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileDefinition">
        <source>Unexpected end of input in value, function or member definition</source>
        <target state="translated">Fine dell'input imprevista nella definizione di membro, funzione o valore</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileExpression">
        <source>Unexpected end of input in expression</source>
        <target state="translated">Fine dell'input imprevista nell'espressione</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedNameAfterToken">
        <source>Unexpected end of type. Expected a name after this point.</source>
        <target state="translated">Fine del tipo imprevista. Previsto un nome dopo questa posizione.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLet">
        <source>Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.</source>
        <target state="translated">Definizione di funzione o di valore incompleta. Se presente in un'espressione, il corpo dell'espressione deve essere rientrato alla stessa colonna della parola chiave 'let'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLetBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword.</source>
        <target state="translated">Definizione di valore incompleta. Se presente in un'espressione, il corpo dell'espressione deve essere rientrato alla stessa colonna della parola chiave 'let!'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUseBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword.</source>
        <target state="translated">Definizione di valore incompleta. Se presente in un'espressione, il corpo dell'espressione deve essere rientrato alla stessa colonna della parola chiave 'use!'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUse">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword.</source>
        <target state="translated">Definizione di valore incompleta. Se presente in un'espressione, il corpo dell'espressione deve essere rientrato alla stessa colonna della parola chiave 'use'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsWhileDoExpected">
        <source>Missing 'do' in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'do' mancante nell'espressione 'while'. È previsto 'while &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsForDoExpected">
        <source>Missing 'do' in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">'do' mancante nell'espressione 'for'. È previsto 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRelationInJoin">
        <source>Invalid join relation in '{0}'. Expected 'expr &lt;op&gt; expr', where &lt;op&gt; is =, =?, ?= or ?=?.</source>
        <target state="translated">Relazione join non valida in '{0}'. È previsto 'expr &lt;op&gt; expr', dove &lt;op&gt; è =, =?, ?= o ?=?.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCallsWord">
        <source>Calls</source>
        <target state="translated">Chiamate</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidNumberOfGenericArguments">
        <source>Invalid number of generic arguments to type '{0}' in provided type. Expected '{1}' arguments, given '{2}'.</source>
        <target state="translated">Numero di argomenti generici non valido nel tipo '{0}' del tipo fornito. Previsti '{1}' argomenti, specificati '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument1">
        <source>Invalid value '{0}' for unit-of-measure parameter '{1}'</source>
        <target state="translated">Valore '{0}' non valido per il parametro di unità di misura '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument2">
        <source>Invalid value unit-of-measure parameter '{0}'</source>
        <target state="translated">Valore non valido per il parametro di unità di misura '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyNeedsCanWriteOrCanRead">
        <source>Property '{0}' on provided type '{1}' is neither readable nor writable as it has CanRead=false and CanWrite=false</source>
        <target state="translated">La proprietà '{0}' nel tipo fornito '{1}' non è né leggibile né scrivibile perché contiene CanRead=false e CanWrite=false</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIntoNeedsRestOfQuery">
        <source>A use of 'into' must be followed by the remainder of the computation</source>
        <target state="translated">L'uso di 'into' deve essere seguito dal resto del calcolo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorDoesntAcceptInto">
        <source>The operator '{0}' does not accept the use of 'into'</source>
        <target state="translated">L'operatore '{0}' non accetta l'utilizzo di 'into'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationInvalid">
        <source>The definition of the custom operator '{0}' does not use a valid combination of attribute flags</source>
        <target state="translated">Nella definizione dell'operatore personalizzato '{0}' non viene usata una combinazione valida di flag di attributo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisTypeMayNotHaveACLIMutableAttribute">
        <source>This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute.</source>
        <target state="translated">Questa definizione di tipo non può contenere l'attributo 'CLIMutable'. Solo i tipi di record possono contenere tale attributo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAutoPropertyRequiresImplicitConstructionSequence">
        <source>'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Le definizioni 'member val' sono consentite solo nei tipi con un costruttore primario. Provare ad aggiungere argomenti alla definizione di tipo utilizzata, ad esempio 'type X(args) = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSet">
        <source>Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Le definizioni di proprietà non possono essere dichiarate modificabili. Per indicare che questa proprietà può essere impostata, utilizzare 'member val PropertyName = expr with get,set'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
        <source>To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Per indicare che questa proprietà può essere impostata, utilizzare 'member val PropertyName = expr with get,set'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefsOfByrefs">
        <source>Type '{0}' is illegal because in byref&lt;T&gt;, T cannot contain byref types.</source>
        <target state="translated">Il tipo '{0}' non è valido perché in byref&lt;T&gt; T non può contenere tipi byref.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastopsMaxArrayThirtyTwo">
        <source>F# supports array ranks between 1 and 32. The value {0} is not allowed.</source>
        <target state="translated">F# supporta dimensioni matrice comprese tra 1 e 32. Il valore {0} non è consentito.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoIntegerForLoopInQuery">
        <source>In queries, use the form 'for x in n .. m do ...' for ranging over integers</source>
        <target state="translated">Nelle query usare il formato 'for x in n .. m do ...' per gestire interi</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoWhileInQuery">
        <source>'while' expressions may not be used in queries</source>
        <target state="translated">Le espressioni 'while' non possono essere utilizzate nelle query</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoTryFinallyInQuery">
        <source>'try/finally' expressions may not be used in queries</source>
        <target state="translated">Le espressioni 'try/finally' non possono essere utilizzate nelle query</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseMayNotBeUsedInQueries">
        <source>'use' expressions may not be used in queries</source>
        <target state="translated">Le espressioni 'use' non possono essere utilizzate nelle query</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindMayNotBeUsedInQueries">
        <source>'let!', 'use!' and 'do!' expressions may not be used in queries</source>
        <target state="translated">Le espressioni 'let!', 'use!' e 'do!' non possono essere utilizzate nelle query</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnMayNotBeUsedInQueries">
        <source>'return' and 'return!' may not be used in queries</source>
        <target state="translated">'return' e 'return!' non possono essere usati nelle query</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryOperator">
        <source>This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type.</source>
        <target state="translated">Operatore di query sconosciuto. Gli operatori di query sono identificatori come 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' e 'averageBy', definiti mediante i metodi corrispondenti nel tipo 'QueryBuilder'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryWithMayNotBeUsedInQueries">
        <source>'try/with' expressions may not be used in queries</source>
        <target state="translated">Le espressioni 'try/with' non possono essere utilizzate nelle query</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonSimpleLetBindingInQuery">
        <source>This 'let' definition may not be used in a query. Only simple value definitions may be used in queries.</source>
        <target state="translated">La definizione 'let' non può essere utilizzata in una query. Nelle query è possibile utilizzare solo definizioni di valore semplici.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTooManyStaticParameters">
        <source>Too many static parameters. Expected at most {0} parameters, but got {1} unnamed and {2} named parameters.</source>
        <target state="translated">Troppi parametri statici. Previsti al massimo {0} parametri, mentre sono stati ottenuti {1} parametri senza nome e {2} parametri denominati.</target>
        <note />
      </trans-unit>
      <trans-unit id="infosInvalidProvidedLiteralValue">
        <source>Invalid provided literal value '{0}'</source>
        <target state="translated">Valore letterale fornito '{0}' non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidPlatformTarget">
        <source>The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead.</source>
        <target state="translated">La piattaforma 'anycpu32bitpreferred' può essere utilizzata solo con destinazioni EXE. Utilizzare invece 'anycpu'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisValueMayNotBeInlined">
        <source>This member, function or value declaration may not be declared 'inline'</source>
        <target state="translated">Questa dichiarazione di valore, funzione o membro non può essere dichiarata 'inline'</target>
        <note />
      </trans-unit>
      <trans-unit id="etErasedTypeUsedInGeneration">
        <source>The provider '{0}' returned a non-generated type '{1}' in the context of a set of generated types. Consider adjusting the type provider to only return generated types.</source>
        <target state="translated">Il provider '{0}' ha restituito un tipo non generato '{1}' nel contesto di un set di tipi generati. Provare a modificare il provider di tipi in modo che restituisca solo tipi generati.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryBinaryOperator">
        <source>Arguments to query operators may require parentheses, e.g. 'where (x &gt; y)' or 'groupBy (x.Length / 10)'</source>
        <target state="translated">Gli argomenti negli operatori di query possono richiedere le parentesi, ad esempio 'where (x &gt; y)' o 'groupBy (x.Length / 10)'</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoSetOfHole">
        <source>A quotation may not involve an assignment to or taking the address of a captured local variable</source>
        <target state="translated">Una quotation non può comportare un'assegnazione a una variabile locale acquisita o l'utilizzo dell'indirizzo di una variabile locale acquisita</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloads1">
        <source>+ 1 overload</source>
        <target state="translated">+ 1 overload</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloadsN">
        <source>+ {0} overloads</source>
        <target state="translated">+ {0} overload</target>
        <note />
      </trans-unit>
      <trans-unit id="erasedTo">
        <source>Erased to</source>
        <target state="translated">Cancellato in</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnfinishedExpression">
        <source>Unexpected token '{0}' or incomplete expression</source>
        <target state="translated">Token imprevisto '{0}' o espressione incompleta</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributeOnIncompleteCode">
        <source>Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.</source>
        <target state="translated">La destinazione del codice per questo attributo non è stata trovata, probabilmente perché il codice dopo l'attributo è incompleto.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeNameCannotBeEmpty">
        <source>Type name cannot be empty.</source>
        <target state="translated">Il nome del tipo non può essere vuoto.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemReadingAssembly">
        <source>Problem reading assembly '{0}': {1}</source>
        <target state="translated">Problema durante la lettura dell'assembly '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTPFieldMustBeLiteral">
        <source>Invalid provided field. Provided fields of erased provided types must be literals.</source>
        <target state="translated">Campo specificato non valido. I campi specificati dei tipi forniti cancellati devono essere valori letterali.</target>
        <note />
      </trans-unit>
      <trans-unit id="loadingDescription">
        <source>(loading description...)</source>
        <target state="translated">(caricamento descrizione...)</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionUnavailable">
        <source>(description unavailable...)</source>
        <target state="translated">(descrizione non disponibile...)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTyparMultipleClassConstraints">
        <source>A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.</source>
        <target state="translated">Una variabile di tipo è stata vincolata da più tipi di classe differenti. Una variabile di tipo può disporre di un solo vincolo di classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMatchMayNotBeUsedWithQuery">
        <source>'match' expressions may not be used in queries</source>
        <target state="translated">Le espressioni 'match' non possono essere utilizzate nelle query</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonTripleArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 3 arguments</source>
        <target state="translated">Il membro dell'operatore infisso '{0}' ha {1} argomento/i iniziale/i. Prevista una tupla di 3 argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="cannotResolveNullableOperators">
        <source>The operator '{0}' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Non è possibile risolvere l'operatore '{0}'. Provare ad aprire il modulo 'Microsoft.FSharp.Linq.NullableOperators'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorRequiresIn">
        <source>'{0}' must be followed by 'in'. Usage: {1}.</source>
        <target state="translated">'{0}' deve essere seguito da 'in'. Utilizzo: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalMemberVarInObjectImplementation">
        <source>Neither 'member val' nor 'override val' definitions are permitted in object expressions.</source>
        <target state="translated">Le definizioni 'member val' e 'override val' non sono consentite nelle espressioni dell'oggetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyCopyAndUpdateRecordInvalid">
        <source>Copy-and-update record expressions must include at least one field.</source>
        <target state="translated">Le espressioni del record Copia e aggiorna devono includere almeno un campo.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnderscoreInvalidFieldName">
        <source>'_' cannot be used as field name</source>
        <target state="translated">Non è possibile usare '_' come nome di campo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGeneratedTypesShouldBeInternalOrPrivate">
        <source>The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'.</source>
        <target state="translated">I tipi forniti generati da questo utilizzo di un provider di tipi potrebbero non essere utilizzati da altri assembly F# e devono essere contrassegnati come interni o privati. Provare a utilizzare 'type internal TypeName = ...' o 'type private TypeName = ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterAndSetterHaveSamePropertyType">
        <source>A property's getter and setter must have the same type. Property '{0}' has getter of type '{1}' but setter of type '{2}'.</source>
        <target state="translated">Il getter e il setter di una proprietà devono essere dello stesso tipo. Il getter della proprietà '{0}' è di tipo '{1}', mentre il setter è di tipo '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRuntimeSuppliedMethodCannotBeUsedInUserCode">
        <source>Array method '{0}' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.</source>
        <target state="translated">Il metodo di matrice '{0}' è fornito dal runtime e non può essere utilizzato direttamente nel codice. Per operazioni con elementi di matrice, considerare l'impiego della famiglia di funzioni GetArray/SetArray dal modulo LanguagePrimitives.IntrinsicFunctions.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName">
        <source>The union case '{0}' does not have a field named '{1}'.</source>
        <target state="translated">Il case di unione '{0}' non include un campo denominato '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseFieldCannotBeUsedMoreThanOnce">
        <source>Union case/exception field '{0}' cannot be used more than once.</source>
        <target state="translated">Il campo case di unione/eccezione '{0}' non può essere utilizzato più di una volta.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameIsUsedModeThanOnce">
        <source>Named field '{0}' is used more than once.</source>
        <target state="translated">Il campo denominato '{0}' viene utilizzato più di una volta.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameConflictsWithGeneratedNameForAnonymousField">
        <source>Named field '{0}' conflicts with autogenerated name for anonymous field.</source>
        <target state="translated">Il campo denominato '{0}' è in conflitto con il nome generato automaticamente per il campo anonimo.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConstantExpressionOverflow">
        <source>This literal expression or attribute argument results in an arithmetic overflow.</source>
        <target state="translated">L'espressione letterale o l'argomento dell'attributo restituisce un overflow aritmetico.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalStructTypeForConstantExpression">
        <source>This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.</source>
        <target state="translated">Espressione letterale non valida. L'attributo [&lt;Literal&gt;] verrà ignorato.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscSystemRuntimeInteropServicesIsRequired">
        <source>System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.</source>
        <target state="translated">L'assembly System.Runtime.InteropServices è necessario per usare le classi UnknownWrapper\DispatchWrapper.</target>
        <note />
      </trans-unit>
      <trans-unit id="abImplicitHeapAllocation">
        <source>The mutable local '{0}' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.</source>
        <target state="translated">Il valore locale modificabile '{0}' è allocato implicitamente come cella di riferimento perché è stato acquisito da una chiusura. Questo avviso viene visualizzato a solo scopo informativo per indicare il punto in cui vengono eseguite allocazioni implicite.</target>
        <note />
      </trans-unit>
      <trans-unit id="estApplyStaticArgumentsForMethodNotImplemented">
        <source>A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid</source>
        <target state="translated">Un provider di tipi ha implementato GetStaticParametersForMethod, ma ApplyStaticArgumentsForMethod non è stato implementato oppure non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToMethod">
        <source>An error occured applying the static arguments to a provided method</source>
        <target state="translated">Si è verificato un errore durante l'applicazione degli argomenti statici a un metodo fornito</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexUnexpectedChar">
        <source>Unexpected character '{0}' in preprocessor expression</source>
        <target state="translated">Il carattere '{0}' non è previsto nell'espressione per il preprocessore</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsUnexpectedToken">
        <source>Unexpected token '{0}' in preprocessor expression</source>
        <target state="translated">Il token '{0}' non è previsto nell'espressione per il preprocessore</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsIncompleteExpression">
        <source>Incomplete preprocessor expression</source>
        <target state="translated">L'espressione per il preprocessore non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsMissingToken">
        <source>Missing token '{0}' in preprocessor expression</source>
        <target state="translated">Nell'espressione per il preprocessore manca il token '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleMissingDefinition">
        <source>An error occurred while reading the F# metadata node at position {0} in table '{1}' of assembly '{2}'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.</source>
        <target state="translated">Si è verificato un errore durante la lettura del nodo dei metadati F# alla posizione {0} della tabella '{1}' dell'assembly '{2}'. Il nodo non include una dichiarazione corrispondente. Segnalare la visualizzazione di questo avviso. Potrebbe essere necessario ricompilare l'assembly F# in uso.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScope">
        <source>Type inference caused the type variable {0} to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.</source>
        <target state="translated">A seguito dell'inferenza del tipo, la variabile di tipo {0} non ha rispettato il proprio ambito. Provare ad aggiungere una dichiarazione di parametro di tipo esplicita oppure a modificare il codice in modo che sia meno generico.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScopeAnon">
        <source>Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.</source>
        <target state="translated">A seguito dell'inferenza del tipo, una variabile di inferenza del tipo non ha rispettato il proprio ambito. Per rendere il codice meno generico, provare ad aggiungere annotazioni di tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkRaiseFamilyFunctionArgumentCount">
        <source>Redundant arguments are being ignored in function '{0}'. Expected {1} but got {2} arguments.</source>
        <target state="translated">Gli argomenti ridondanti verranno ignorati nella funzione '{0}'. Erano previsti {1} argomenti, ma ne sono stati ottenuti {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkLowercaseLiteralBindingInPattern">
        <source>Lowercase literal '{0}' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.</source>
        <target state="translated">Il valore letterale '{0}' verrà nascosto da un nuovo criterio con lo stesso nome. Come criteri denominati è possibile usare solo valori letterali in maiuscolo e che includono un modulo come prefisso.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralDoesNotTakeArguments">
        <source>This literal pattern does not take arguments</source>
        <target state="translated">Questo criterio di valore letterale non accetta argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalInAugmentation">
        <source>Constructors are not permitted as extension members - they must be defined as part of the original definition of the type</source>
        <target state="translated">I costruttori non sono consentiti come membri di estensione. Devono essere definiti come parte della definizione originale del tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidResponseFile">
        <source>Invalid response file '{0}' ( '{1}' )</source>
        <target state="translated">File di risposta '{0}' ('{1}') non valido</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNotFound">
        <source>Response file '{0}' not found in '{1}'</source>
        <target state="translated">Il file di risposta '{0}' non è stato trovato in '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNameInvalid">
        <source>Response file name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">Il nome del file di risposta '{0}' è vuoto, contiene caratteri non validi, include una specifica di unità senza percorso assoluto oppure è troppo lungo</target>
        <note />
      </trans-unit>
      <trans-unit id="fsharpCoreNotFoundToBeCopied">
        <source>Cannot find FSharp.Core.dll in compiler's directory</source>
        <target state="translated">Il file FSharp.Core.dll non è stato trovato nella directory del compilatore</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleStructMismatch">
        <source>One tuple type is a struct tuple, the other is a reference tuple</source>
        <target state="translated">Un tipo di tupla è una tupla di struttura, mentre l'altra è una tupla di riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="etMissingStaticArgumentsToMethod">
        <source>This provided method requires static parameters</source>
        <target state="translated">Con il metodo specificato sono richiesti parametri statici</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcast">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'.</source>
        <target state="translated">La conversione da {0} a {1} è un'espressione upcast sicura della fase di compilazione e non di downcast. Provare a usare 'upcast' invece di 'downcast'.</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcastOperator">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.</source>
        <target state="translated">La conversione da {0} a {1} è un'espressione upcast sicura della fase di compilazione e non di downcast. Provare a usare l'operatore :&gt; (upcast) invece di quello :?&gt; (downcast).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecImplied">
        <source>The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored</source>
        <target state="translated">La dichiarazione 'rec' in questo modulo è specificata implicitamente da una dichiarazione 'rec' esterna e verrà ignorata</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenFirstInMutRec">
        <source>In a recursive declaration group, 'open' declarations must come first in each module</source>
        <target state="translated">In un gruppo di dichiarazioni ricorsive le dichiarazioni 'open' devono essere inserite per prime in ogni modulo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbrevFirstInMutRec">
        <source>In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations</source>
        <target state="translated">In un gruppo di dichiarazioni ricorsive le abbreviazioni dei moduli devono essere inserite dopo tutte le dichiarazioni 'open' e prima di altre dichiarazioni</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedMutRecDecl">
        <source>This declaration is not supported in recursive declaration groups</source>
        <target state="translated">Questa dichiarazione non è supportata nei gruppi di dichiarazioni ricorsive</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidUseOfRec">
        <source>Invalid use of 'rec' keyword</source>
        <target state="translated">Uso non valido della parola chiave 'rec'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructUnionMultiCaseDistinctFields">
        <source>If a union type has more than one case and is a struct, then all fields within the union type must be given unique names.</source>
        <target state="translated">Se un tipo di unione contiene più di un case ed è una struttura, è necessario assegnare nomi univoci a tutti i campi all'interno del tipo di unione.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerMemberNameIsOverriden">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">CallerMemberNameAttribute applicato al parametro '{0}' non avrà alcun effetto. CallerFilePathAttribute ne eseguirà l'override.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFixedNotAllowed">
        <source>Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'</source>
        <target state="translated">Uso non valido di 'fixed'. 'fixed' può essere usato solo in una dichiarazione in formato 'use x = fixed expr', in cui l'espressione è una matrice, l'indirizzo di un campo, l'indirizzo di un elemento di matrice oppure una stringa</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindOffsetToStringData">
        <source>Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression.</source>
        <target state="translated">Il metodo System.Runtime.CompilerServices.OffsetToStringData non è stato trovato nei riferimenti durante la compilazione dell'espressione 'fixed'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedActivePattern">
        <source>{0} is an active pattern and cannot be treated as a discriminated union case with named fields.</source>
        <target state="translated">{0} è un criterio attivo e non può essere considerato come un case di unione discriminato con campi denominati.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultParameterValueNotAppropriateForArgument">
        <source>The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'.</source>
        <target state="translated">Il tipo del valore predefinito non è uguale a quello dell'argomento. L'attributo DefaultParameterValue e l'eventuale attributo Optional verranno ignorati. Nota: 'null' deve essere annotato con il tipo corretto, ad esempio 'DefaultParameterValue(null:obj)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGlobalsSystemTypeNotFound">
        <source>The system type '{0}' was required but no referenced system DLL contained this type</source>
        <target state="translated">È richiesto il tipo di sistema '{0}', ma nessuna DLL di sistema di riferimento contiene questo tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberHasMultiplePossibleDispatchSlots">
        <source>The member '{0}' matches multiple overloads of the same method.\nPlease restrict it to one of the following:{1}.</source>
        <target state="translated">Il membro '{0}' corrisponde a più overload dello stesso metodo.\nLimitarlo a uno dei seguenti:{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="methodIsNotStatic">
        <source>Method or object constructor '{0}' is not static</source>
        <target state="translated">Il costruttore di oggetto o metodo '{0}' non è statico</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolEqualsInsteadOfIn">
        <source>Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?</source>
        <target state="translated">Simbolo '=' imprevisto nell'espressione. Si intendeva usare 'for x in y .. z do'?</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAbstract">
        <source>Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</source>
        <target state="translated">Indica un metodo per il quale non esiste alcuna implementazione nel tipo in cui viene dichiarato oppure che è virtuale e per il quale esiste un'implementazione predefinita.</target>
        <note />
      </trans-unit>
      <trans-unit id="keyworkDescriptionAnd">
        <source>Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</source>
        <target state="translated">Usata in binding ricorsivi reciproci, dichiarazioni di proprietà e con più vincoli su parametri generici.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAs">
        <source>Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</source>
        <target state="translated">Usata per assegnare un nome di oggetto all'oggetto classe corrente. Usata inoltre per assegnare un nome a un intero criterio nell'ambito dei criteri di ricerca.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAssert">
        <source>Used to verify code during debugging.</source>
        <target state="translated">Usata per verificare il codice durante il debug.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBase">
        <source>Used as the name of the base class object.</source>
        <target state="translated">Usata come nome dell'oggetto classe di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBegin">
        <source>In verbose syntax, indicates the start of a code block.</source>
        <target state="translated">Nella sintassi dettagliata indica l'inizio di un blocco di codice.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionClass">
        <source>In verbose syntax, indicates the start of a class definition.</source>
        <target state="translated">Nella sintassi dettagliata indica l'inizio di una definizione di classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDefault">
        <source>Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</source>
        <target state="translated">Indica un'implementazione di un metodo astratto. Usata insieme a una dichiarazione di metodo astratto per creare un metodo virtuale.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDelegate">
        <source>Used to declare a delegate.</source>
        <target state="translated">Usata per dichiarare un delegato.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDo">
        <source>Used in looping constructs or to execute imperative code.</source>
        <target state="translated">Usata in costrutti di ciclo oppure per eseguire codice imperativo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDone">
        <source>In verbose syntax, indicates the end of a block of code in a looping expression.</source>
        <target state="translated">Nella sintassi dettagliata indica la fine di un blocco di codice in un'espressione di ciclo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDowncast">
        <source>Used to convert to a type that is lower in the inheritance chain.</source>
        <target state="translated">Usata per eseguire la conversione in un tipo che occupa una posizione più bassa nella catena di ereditarietà.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDownto">
        <source>In a for expression, used when counting in reverse.</source>
        <target state="translated">Usata in un'espressione for per il conteggio in ordine inverso.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElif">
        <source>Used in conditional branching. A short form of else if.</source>
        <target state="translated">Usata nella diramazione condizionale. Forma abbreviata di else if.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElse">
        <source>Used in conditional branching.</source>
        <target state="translated">Usata nella diramazione condizionale.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionEnd">
        <source>In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</source>
        <target state="translated">Nelle definizioni dei tipi e nelle estensioni dei tipi indica la fine di una sezione di definizioni dei membri. Nella sintassi dettagliata viene usata per specificare la fine di un blocco di codice che inizia con la parola chiave begin.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionException">
        <source>Used to declare an exception type.</source>
        <target state="translated">Usata per dichiarare un tipo di eccezione.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionExtern">
        <source>Indicates that a declared program element is defined in another binary or assembly.</source>
        <target state="translated">Indica che un elemento dichiarato del programma è definito in un altro assembly o file binario.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTrueFalse">
        <source>Used as a Boolean literal.</source>
        <target state="translated">Usata come valore letterale booleano.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFinally">
        <source>Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</source>
        <target state="translated">Usata insieme a try per introdurre un blocco di codice che viene eseguito indipendentemente dal fatto che si verifichi un'eccezione.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFor">
        <source>Used in looping constructs.</source>
        <target state="translated">Usata in costrutti di ciclo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFun">
        <source>Used in lambda expressions, also known as anonymous functions.</source>
        <target state="translated">Usata nelle espressioni lambda, note anche come funzioni anonime.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFunction">
        <source>Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</source>
        <target state="translated">Usata come alternativa più breve alla parola chiave fun e a un'espressione match in un'espressione lambda con criteri di ricerca su un singolo argomento.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionGlobal">
        <source>Used to reference the top-level .NET namespace.</source>
        <target state="translated">Usata per fare riferimento allo spazio dei nomi .NET di primo livello.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIf">
        <source>Used in conditional branching constructs.</source>
        <target state="translated">Usata nei costrutti di diramazione condizionale.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIn">
        <source>Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</source>
        <target state="translated">Usata per le espressioni di sequenza e, nella sintassi dettagliata, per separare le espressioni dai binding.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInherit">
        <source>Used to specify a base class or base interface.</source>
        <target state="translated">Usata per specificare una classe di base o un'interfaccia di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInline">
        <source>Used to indicate a function that should be integrated directly into the caller's code.</source>
        <target state="translated">Usata per indicare una funzione che deve essere integrata direttamente nel codice del chiamante.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInterface">
        <source>Used to declare and implement interfaces.</source>
        <target state="translated">Usata per dichiarare e implementare interfacce.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInternal">
        <source>Used to specify that a member is visible inside an assembly but not outside it.</source>
        <target state="translated">Usata per specificare che un membro è visibile all'interno ma non all'esterno di un assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLazy">
        <source>Used to specify a computation that is to be performed only when a result is needed.</source>
        <target state="translated">Usata per specificare un calcolo che deve essere eseguito solo quando è necessario un risultato.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLet">
        <source>Used to associate, or bind, a name to a value or function.</source>
        <target state="translated">Usata per associare o eseguire il binding di un nome a un valore o a una funzione.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLetBang">
        <source>Used in computation expressions to bind a name to the result of another computation expression.</source>
        <target state="translated">Usata nelle espressioni di calcolo per associare un nome al risultato di un'altra espressione di calcolo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatch">
        <source>Used to branch by comparing a value to a pattern.</source>
        <target state="translated">Usata per creare un ramo confrontando un valore con un criterio.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMember">
        <source>Used to declare a property or method in an object type.</source>
        <target state="translated">Usata per dichiarare una proprietà o un metodo in un tipo di oggetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionModule">
        <source>Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</source>
        <target state="translated">Usata per associare un nome a un gruppo di valori, funzioni e tipi correlati allo scopo di separare il gruppo in modo logico da altro codice.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMutable">
        <source>Used to declare a variable, that is, a value that can be changed.</source>
        <target state="translated">Usata per dichiarare una variabile, ovvero un valore che può essere modificato.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNamespace">
        <source>Used to associate a name with a group of related types and modules, to logically separate it from other code.</source>
        <target state="translated">Usata per associare un nome a un gruppo di moduli e tipi correlati allo scopo di separare il gruppo in modo logico da altro codice.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNew">
        <source>Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.</source>
        <target state="translated">Usata per dichiarare, definire o richiamare un costruttore che crea o che è in grado di creare un oggetto. Usata anche nei vincoli di parametri generici per indicare che un tipo deve contenere un determinato costruttore.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNot">
        <source>Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</source>
        <target state="translated">Non è una vera e propria parola chiave. In combinazione con not struct viene tuttavia usata come vincolo di parametro generico.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNull">
        <source>Indicates the absence of an object. Also used in generic parameter constraints.</source>
        <target state="translated">Indica l'assenza di un oggetto. Usata anche nei vincoli di parametri generici.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOf">
        <source>Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</source>
        <target state="translated">Usata nelle unioni discriminate per indicare il tipo di categorie di valori, nonché nelle dichiarazioni di delegati ed eccezioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOpen">
        <source>Used to make the contents of a namespace or module available without qualification.</source>
        <target state="translated">Usata per rendere disponibile il contenuto di uno spazio dei nomi o di un modulo senza qualificazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOr">
        <source>Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.</source>
        <target state="translated">Usata con le condizioni booleane come operatore or booleano. Equivalente a ||. Usata anche nei vincoli di membro.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOverride">
        <source>Used to implement a version of an abstract or virtual method that differs from the base version.</source>
        <target state="translated">Usata per implementare una versione di un metodo astratto o virtuale diversa dalla versione di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPrivate">
        <source>Restricts access to a member to code in the same type or module.</source>
        <target state="translated">Limita l'accesso al codice a un membro nello stesso tipo o modulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPublic">
        <source>Allows access to a member from outside the type.</source>
        <target state="translated">Consente l'accesso a un membro dall'esterno del tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRec">
        <source>Used to indicate that a function is recursive.</source>
        <target state="translated">Usata per indicare che una funzione è ricorsiva.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturn">
        <source>Used to provide a value for the result of the containing computation expression.</source>
        <target state="translated">Usata per specificare un valore per il risultato dell'espressione di calcolo contenitore.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturnBang">
        <source>Used to provide a value for the result of the containing computation expression, where that value itself comes from the result another computation expression.</source>
        <target state="translated">Usata per specificare un valore per il risultato dell'espressione di calcolo contenitore, in cui tale valore proviene dal risultato di un'altra espressione di calcolo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionSelect">
        <source>Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</source>
        <target state="translated">Usata nelle espressioni di query per specificare i campi o le colonne da estrarre. Si noti che questa è una parola chiave contestuale, pertanto non è in realtà una parola riservata e funge solo da parola chiave nel contesto appropriato.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStatic">
        <source>Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</source>
        <target state="translated">Usata per indicare un metodo o una proprietà che è possibile chiamare senza un'istanza di un tipo oppure un membro valore condiviso tra tutte le istanze di un tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStruct">
        <source>Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions.</source>
        <target state="translated">Usata per dichiarare un tipo di struttura. Usata anche nei vincoli di parametri generici. Usata per garantire la compatibilità con OCaml nelle definizioni di moduli.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionThen">
        <source>Used in conditional expressions. Also used to perform side effects after object construction.</source>
        <target state="translated">Usata nelle espressioni condizionali. Usata anche per ottenere effetti collaterali dopo la costruzione di oggetti.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTo">
        <source>Used in for loops to indicate a range.</source>
        <target state="translated">Usata nei cicli for per indicare un intervallo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTry">
        <source>Used to introduce a block of code that might generate an exception. Used together with with or finally.</source>
        <target state="translated">Usata per introdurre un blocco di codice che potrebbe generare un'eccezione. Usata insieme a with o finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionType">
        <source>Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</source>
        <target state="translated">Usata per dichiarare una classe, un record, una struttura, un'unione discriminata, un tipo di enumerazione, un'unità di misura o un'abbreviazione di un tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUpcast">
        <source>Used to convert to a type that is higher in the inheritance chain.</source>
        <target state="translated">Usata per eseguire la conversione in un tipo che occupa una posizione più alta nella catena di ereditarietà.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUse">
        <source>Used instead of let for values that implement IDisposable</source>
        <target state="translated">Usata al posto di let per valori che implementano IDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUseBang">
        <source>Used instead of let! in computation expressions for computation expression results that implement IDisposable.</source>
        <target state="translated">Usata al posto di let! in espressioni di calcolo per risultati di espressioni di calcolo che implementano IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVal">
        <source>Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</source>
        <target state="translated">Usata in una firma per indicare un valore oppure in un tipo per dichiarare un membro, in situazioni limitate.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVoid">
        <source>Indicates the .NET void type. Used when interoperating with other .NET languages.</source>
        <target state="translated">Indica il tipo void .NET. Usata in caso di interoperatività con altri linguaggi .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhen">
        <source>Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.</source>
        <target state="translated">Usata per le condizioni booleane (when guards) nei criteri di ricerca e per introdurre una clausola di vincolo per un parametro di tipo generico.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhile">
        <source>Introduces a looping construct.</source>
        <target state="translated">Introduce un costrutto di ciclo.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWith">
        <source>Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</source>
        <target state="translated">Usata insieme alla parola chiave match nelle espressioni di criteri di ricerca. Usata anche in espressioni di oggetti, espressioni di copia di record e in estensioni dei tipi per introdurre definizioni di membro, nonché per introdurre gestori di eccezioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYield">
        <source>Used in a sequence expression to produce a value for a sequence.</source>
        <target state="translated">Usata in un'espressione di sequenza per produrre un valore per una sequenza.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYieldBang">
        <source>Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</source>
        <target state="translated">Usata in un'espressione di calcolo per aggiungere il risultato di un'espressione di calcolo specificata a una raccolta di risultati per l'espressione di calcolo contenitore.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRightArrow">
        <source>In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions</source>
        <target state="translated">Nei tipi di funzione delimita argomenti e valori restituiti. Produce un'espressione (nelle espressioni di sequenza); equivalente alla parola chiave yield. Usata nelle espressioni match</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLeftArrow">
        <source>Assigns a value to a variable.</source>
        <target state="translated">Assegna un valore a una variabile.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionCast">
        <source>Converts a type to type that is higher in the hierarchy.</source>
        <target state="translated">Converte un tipo nel tipo che occupa una posizione più alta nella gerarchia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDynamicCast">
        <source>Converts a type to a type that is lower in the hierarchy.</source>
        <target state="translated">Converte un tipo in un tipo che occupa una posizione più bassa nella gerarchia.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTypedQuotation">
        <source>Delimits a typed code quotation.</source>
        <target state="translated">Delimita una quotation di codice tipizzato.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUntypedQuotation">
        <source>Delimits a untyped code quotation.</source>
        <target state="translated">Delimita una quotation di codice non tipizzato.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundDuringDynamicCodeGen">
        <source>{0} '{1}' not found in assembly '{2}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">L'elemento {0} '{1}' non è stato trovato nell'assembly '{2}'. Il problema potrebbe essere causato da versioni incompatibili. Per consentire a tutti i componenti di riferimento di usare la versione corretta, potrebbe essere necessario fare riferimento alla versione corretta.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundInTypeDuringDynamicCodeGen">
        <source>{0} '{1}' not found in type '{2}' from assembly '{3}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">L'elemento {0} '{1}' non è stato trovato nel tipo '{2}' dell'assembly '{3}'. Il problema potrebbe essere causato da versioni incompatibili. Per consentire a tutti i componenti di riferimento di usare la versione corretta, potrebbe essere necessario fare riferimento alla versione corretta.</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionWordIs">
        <source>is</source>
        <target state="translated">è</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunction">
        <source>This value is not a function and cannot be applied.</source>
        <target state="translated">Questo valore non è una funzione e non può essere applicato.</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexerWithName">
        <source>This value is not a function and cannot be applied. Did you intend to access the indexer via {0}.[index] instead?</source>
        <target state="translated">Questo valore non è una funzione e non può essere applicato. Si intendeva accedere all'indicizzatore tramite la sintassi {0}.[indice]?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexer">
        <source>This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?</source>
        <target state="translated">Questa espressione non è una funzione e non può essere applicata. Si intendeva accedere all'indicizzatore tramite la sintassi espressione.[indice]?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeDeclaration">
        <source>This value is not a function and cannot be applied. Did you forget to terminate a declaration?</source>
        <target state="translated">Questo valore non è una funzione e non può essere applicato. Potrebbe essere presente una dichiarazione non terminata.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentsInSigAndImplMismatch">
        <source>The argument names in the signature '{0}' and implementation '{1}' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling.</source>
        <target state="translated">I nomi degli argomenti nella firma '{0}' e nell'implementazione '{1}' non corrispondono. Verrà usato il nome dell'argomento del file di firma. Questa situazione potrebbe causare problemi durante il debug o la profilatura.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleUnexpectedNonZero">
        <source>An error occurred while reading the F# metadata of assembly '{0}'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct.</source>
        <target state="translated">Si è verificato un errore durante la lettura dei metadati F# dell'assembly '{0}'. È stato utilizzato un costrutto riservato. Potrebbe essere necessario aggiornare il compilatore F# o usare una versione precedente dell'assembly che non usa un costrutto specifico.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleMemberNotNormallyUsed">
        <source>This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.</source>
        <target state="translated">Questo metodo o questa proprietà non è in genere usato dal codice F#. Per la decostruzione usare invece un criterio di tupla esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'.</source>
        <target state="translated">Questa espressione restituisce un valore di tipo '{0}' ma viene rimossa in modo implicito. Provare a usare 'let' per eseguire il binding del risultato a un nome, ad esempio 'let risultato = espressione'. Se si intende usare l'espressione come valore nella sequenza, usare l'operando 'yield' esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedSequenceInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'.</source>
        <target state="translated">Questa espressione restituisce un valore di tipo '{0}' ma viene rimossa in modo implicito. Provare a usare 'let' per eseguire il binding del risultato a un nome, ad esempio 'let risultato = espressione'. Se si intende usare l'espressione come valore nella sequenza, usare l'operando 'yield!' esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatchBang">
        <source>Used in computation expressions to pattern match directly over the result of another computation expression.</source>
        <target state="translated">Usata nelle espressioni di calcolo per includere direttamente nei criteri di ricerca il risultato di un'altra espressione di calcolo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilreadFileChanged">
        <source>The file '{0}' changed on disk unexpectedly, please reload.</source>
        <target state="translated">Il file '{0}' è stato modificato su disco in modo imprevisto. Ricaricare.</target>
        <note />
      </trans-unit>
      <trans-unit id="writeToReadOnlyByref">
        <source>The byref pointer is readonly, so this write is not permitted.</source>
        <target state="translated">Il puntatore byref è di sola lettura, di conseguenza questa operazione di scrittura non è consentita.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeMutable">
        <source>A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'</source>
        <target state="translated">Un valore deve essere modificabile per poter modificare i contenuti oppure utilizzare l'indirizzo di un tipo di valore, ad esempio 'let mutable x = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="readOnlyAttributeOnStructWithMutableField">
        <source>A ReadOnly attribute has been applied to a struct type with a mutable field.</source>
        <target state="translated">Un attributo ReadOnly è stato applicato a un tipo struct con campo modificabile.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByrefReturnImplicitlyDereferenced">
        <source>A byref pointer returned by a function or method is implicitly dereferenced as of F# 4.5. To acquire the return value as a pointer, use the address-of operator, e.g. '&amp;f(x)' or '&amp;obj.Method(arg1, arg2)'.</source>
        <target state="translated">Un puntatore byref restituito da una funzione o da un metodo è deferenziato in modo implicito a partire da F# 4.5. Per acquisire il valore restituito come puntatore, usare l'operatore address-of, ad esempio '&amp;f(x)' or '&amp;obj.Method(arg1, arg2)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByRefLikeNotStruct">
        <source>A type annotated with IsByRefLike must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.</source>
        <target state="translated">Un tipo annotato con IsByRefLike deve essere anche uno struct. Provare ad aggiungere l'attributo [&lt;Struct&gt;] al tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAddressOfLocal">
        <source>The address of the variable '{0}' or a related expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">In questo punto non è possibile usare l'indirizzo della variabile '{0}' o un'espressione correlata. Questo serve ad assicurare che l'indirizzo del valore locale non ignori il relativo ambito.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoWriteToLimitedSpan">
        <source>This value can't be assigned because the target '{0}' may refer to non-stack-local memory, while the expression being assigned is assessed to potentially refer to stack-local memory. This is to help prevent pointers to stack-bound memory escaping their scope.</source>
        <target state="translated">Non è possibile assegnare questo valore perché l'elemento '{0}' di destinazione può fare riferimento alla memoria locale non stack, mentre l'espressione da assegnare viene valutata in modo da fare potenzialmente riferimento alla memoria locale stack. Tale comportamento consente di evitare puntatori a memoria associata allo stack che ignorano il relativo ambito.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeLocal">
        <source>A value defined in a module must be mutable in order to take its address, e.g. 'let mutable x = ...'</source>
        <target state="translated">Un valore definito in un modulo deve essere modificabile per poterne accettare l'indirizzo, ad esempio 'let mutable x = ...'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIsReadOnlyNotStruct">
        <source>A type annotated with IsReadOnly must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.</source>
        <target state="translated">Un tipo annotato con IsReadOnly deve essere anche uno struct. Provare ad aggiungere l'attributo [&lt;Struct&gt;] al tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkStructsMayNotReturnAddressesOfContents">
        <source>Struct members cannot return the address of fields of the struct by reference</source>
        <target state="translated">I membri struct non possono restituire l'indirizzo di campi dello struct per riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefLikeFunctionCall">
        <source>The function or method call cannot be used at this point, because one argument that is a byref of a non-stack-local Span or IsByRefLike type is used with another argument that is a stack-local Span or IsByRefLike type. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">In questo punto non è possibile usare la chiamata al metodo o alla funzione perché un argomento che è un byref di un tipo Span o IsByRefLike locale non stack viene usato con un altro argomento che è un tipo Span o IsByRefLike locale stack. Questo serve ad assicurare che l'indirizzo del valore locale non ignori il relativo ambito.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAddressOfValueFromExpression">
        <source>The address of a value returned from the expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">In questo punto non è possibile usare l'indirizzo di un valore restituito dall'espressione. Questo serve ad assicurare che l'indirizzo del valore locale non ignori il relativo ambito.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoSpanLikeVariable">
        <source>The Span or IsByRefLike variable '{0}' cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">In questo punto non è possibile usare la variabile '{0}' di Span o IsByRefLike. Questo serve ad assicurare che l'indirizzo del valore locale non ignori il relativo ambito.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoSpanLikeValueFromExpression">
        <source>A Span or IsByRefLike value returned from the expression cannot be used at ths point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">In questo punto non è possibile usare un valore Span o IsByRefLike restituito dall'espressione. Questo serve ad assicurare che l'indirizzo del valore locale non ignori il relativo ambito.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastCantTakeAddressOfExpression">
        <source>Cannot take the address of the value returned from the expression. Assign the returned value to a let-bound value before taking the address.</source>
        <target state="translated">Non è possibile accettare l'indirizzo del valore restituito dall'espressione. Assegnare il valore restituito a un valore associato a let prima di accettare l'indirizzo.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBraceBar">
        <source>Unmatched '{{|'</source>
        <target state="translated">'{{|' senza corrispondenza</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoAnonRecdField">
        <source>anonymous record field</source>
        <target state="translated">campo del record anonimo</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionConstructorDoesNotHaveFieldWithGivenName">
        <source>The exception '{0}' does not have a field named '{1}'.</source>
        <target state="translated">L'eccezione '{0}' non include un campo denominato '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcActivePatternsDoNotHaveFields">
        <source>Active patterns do not have fields. This syntax is invalid.</source>
        <target state="translated">Non esistono campi per i criteri attivi. Questa sintassi non è valida.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorDoesNotHaveFieldWithGivenName">
        <source>The constructor does not have a field named '{0}'.</source>
        <target state="translated">Il costruttore non include un campo denominato '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdCcuMismatch">
        <source>Two anonymous record types are from different assemblies '{0}' and '{1}'</source>
        <target state="translated">Due tipi di record anonimo provengono da assembly diversi, '{0}' e '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameMismatch">
        <source>This anonymous record does not exactly match the expected shape. Add the missing fields {0} and remove the extra fields {1}.</source>
        <target state="translated">Questo record anonimo non corrisponde esattamente alla forma prevista. Aggiungere i campi mancanti {0} e rimuovere i campi aggiuntivi {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallExtensionMethodInrefToByref">
        <source>Cannot call the byref extension method '{0}. The first parameter requires the value to be mutable or a non-readonly byref type.</source>
        <target state="translated">Non è possibile chiamare il metodo di estensione byref '{0}. Il valore del primo parametro deve essere modificabile oppure un tipo byref non di sola lettura.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByrefsMayNotHaveTypeExtensions">
        <source>Byref types are not allowed to have optional type extensions.</source>
        <target state="translated">Con i tipi byref non sono consentite estensioni di tipo facoltative.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotPartiallyApplyExtensionMethodForByref">
        <source>Cannot partially apply the extension method '{0}' because the first parameter is a byref type.</source>
        <target state="translated">Non è possibile applicare parzialmente il metodo di estensione '{0}' perché il primo parametro è un tipo byref.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDoesNotInheritAttribute">
        <source>This type does not inherit Attribute, it will not work correctly with other .NET languages.</source>
        <target state="translated">Questo tipo non eredita Attribute e non funzionerà correttamente con altri linguaggi .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidAnonRecdExpr">
        <source>Invalid anonymous record expression</source>
        <target state="translated">L'espressione del record anonimo non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidAnonRecdType">
        <source>Invalid anonymous record type</source>
        <target state="translated">Il tipo di record anonimo non è valido</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCopyAndUpdateNeedsRecordType">
        <source>The input to a copy-and-update expression that creates an anonymous record must be either an anonymous record or a record</source>
        <target state="translated">Il valore di input di un'espressione di copia e aggiornamento che crea un record anonimo deve essere un record anonimo o un record</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidFunctionParameterType">
        <source>The parameter '{0}' has an invalid type '{1}'. This is not permitted by the rules of Common IL.</source>
        <target state="translated">Il parametro '{0}' contiene un tipo non valido '{1}'. Questo comportamento non è consentito dalle regole di Common IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidFunctionReturnType">
        <source>The function or method has an invalid return type '{0}'. This is not permitted by the rules of Common IL.</source>
        <target state="translated">La funzione o il metodo contiene un tipo restituito non valido '{0}'. Questo comportamento non è consentito dalle regole di Common IL.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveral">
        <source>No implementation was given for those members: {0}</source>
        <target state="translated">Non è stata specificata alcuna implementazione per tali membri: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralWithSuggestion">
        <source>No implementation was given for those members: {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Non è stata specificata alcuna implementazione per tali membri: {0}. Si noti che tutti i membri dell'interfaccia devono essere implementati ed elencati in una dichiarazione 'interface' appropriata, ad esempio 'interface ... with member ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralTruncated">
        <source>No implementation was given for those members (some results omitted): {0}</source>
        <target state="translated">Non è stata specificata alcuna implementazione per tali membri (alcuni risultati sono stati omessi): {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralTruncatedWithSuggestion">
        <source>No implementation was given for those members (some results omitted): {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Non è stata specificata alcuna implementazione per tali membri (alcuni risultati sono stati omessi): {0}. Si noti che tutti i membri dell'interfaccia devono essere implementati ed elencati in una dichiarazione 'interface' appropriata, ad esempio 'interface ... with member ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="expressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">L'espressione non ha un nome.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassNameOf">
        <source>Using the 'nameof' operator as a first-class function value is not permitted.</source>
        <target state="translated">L'operatore 'nameof' non è consentito come valore di funzione di prima classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPathMap">
        <source>Maps physical paths to source path names output by the compiler</source>
        <target state="translated">Esegue il mapping dei percorsi fisici ai nomi di percorso di origine restituiti dal compilatore</target>
        <note />
      </trans-unit>
      <trans-unit id="fscPathMapDebugRequiresPortablePdb">
        <source>--pathmap can only be used with portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">--pathmap può essere usato solo con file PDB portabili (--debug:portable o --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidPathMapFormat">
        <source>Invalid path map. Mappings must be comma separated and of the format 'path=sourcePath'</source>
        <target state="translated">Mapping di percorso non valido. I mapping devono essere delimitati da virgole e specificati in formato 'percorso=percorsoOrigine'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCompilerTool">
        <source>Reference an assembly or directory containing a design time tool (Short form: -t)</source>
        <target state="translated">Fa riferimento a un assembly o una directory contenente uno strumento della fase di progettazione. Forma breve: -t</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagerUnknown">
        <source>Package manager key '{0}' was not registered in {1}. Currently registered: {2}</source>
        <target state="translated">La chiave di gestione pacchetti '{0}' non è stata registrata in {1}. Attualmente registrata: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagerError">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="couldNotLoadDependencyManagerExtension">
        <source>The dependency manager extension {0} could not be loaded. Message: {1}</source>
        <target state="translated">Non è stato possibile caricare l'estensione {0} di gestione delle dipendenze. Messaggio: {1}</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>