<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ru" original="../FSComp.resx">
    <body>
      <trans-unit id="chkFeatureNotLanguageSupported">
        <source>Feature '{0}' is not available in F# {1}. Please use language version {2} or greater.</source>
        <target state="translated">Компонент "{0}" недоступен в F# {1}. Используйте версию языка {2} или выше.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFeatureNotRuntimeSupported">
        <source>Feature '{0}' is not supported by target runtime.</source>
        <target state="translated">Компонент "{0}" не поддерживается целевой средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFeatureNotSupportedInLibrary">
        <source>Feature '{0}' requires the F# library for language version {1} or greater.</source>
        <target state="translated">Компоненту "{0}" требуется библиотека F# для языка версии {1} или более поздней.</target>
        <note />
      </trans-unit>
      <trans-unit id="csAvailableOverloads">
        <source>Available overloads:\n{0}</source>
        <target state="translated">Доступные перегрузки:\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructOrReferenceConstraint">
        <source>A generic construct requires that a generic type parameter be known as a struct or reference type. Consider adding a type annotation.</source>
        <target state="translated">В универсальной конструкции требуется использовать параметр универсального типа, известный как структура или ссылочный тип. Рекомендуется добавить заметку с типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundArgumentsPrefixPlural">
        <source>Known types of arguments: {0}</source>
        <target state="translated">Известные типы аргументов: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundArgumentsPrefixSingular">
        <source>Known type of argument: {0}</source>
        <target state="translated">Известный тип аргумента: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundReturnType">
        <source>Known return type: {0}</source>
        <target state="translated">Известный тип возвращаемого значения: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundTypeParametersPrefixPlural">
        <source>Known type parameters: {0}</source>
        <target state="translated">Известные параметры типа: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFoundTypeParametersPrefixSingular">
        <source>Known type parameter: {0}</source>
        <target state="translated">Известный параметр типа: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="csOverloadCandidateIndexedArgumentTypeMismatch">
        <source>Argument at index {0} doesn't match</source>
        <target state="translated">Аргумент в индексе {0} не соответствует</target>
        <note />
      </trans-unit>
      <trans-unit id="csOverloadCandidateNamedArgumentTypeMismatch">
        <source>Argument '{0}' doesn't match</source>
        <target state="translated">Аргумент "{0}" не соответствует</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasDesignerAssemblyDependency">
        <source>The type provider designer assembly '{0}' could not be loaded from folder '{1}' because a dependency was missing or could not loaded. All dependencies of the type provider designer assembly must be located in the same folder as that assembly. The exception reported was: {2} - {3}</source>
        <target state="translated">Не удалось загрузить сборку конструктора поставщика типа "{0}" из папки "{1}", так как зависимость отсутствует или не может быть загружена. Все зависимости для сборки конструктора поставщика типа должны находиться в папке сборки. Получено исключение: {2} — {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasDesignerAssemblyException">
        <source>The type provider designer assembly '{0}' could not be loaded from folder '{1}'. The exception reported was: {2} - {3}</source>
        <target state="translated">Не удалось загрузить сборку конструктора поставщика типа "{0}" из папки "{1}". Получено исключение: {2} — {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssemblyNoPath">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded or doesn't exist. The exception reported was: {2} - {3}</source>
        <target state="translated">Атрибут сборки "{0}" ссылается на сборку конструктора "{1}", которая не может быть загружена или не существует. Получено исключение: {2} — {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="featureAndBang">
        <source>applicative computation expressions</source>
        <target state="translated">применимые вычислительные выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="featureDefaultInterfaceMemberConsumption">
        <source>default interface member consumption</source>
        <target state="translated">использование элемента интерфейса по умолчанию</target>
        <note />
      </trans-unit>
      <trans-unit id="featureDotlessFloat32Literal">
        <source>dotless float32 literal</source>
        <target state="translated">литерал float32 без точки</target>
        <note />
      </trans-unit>
      <trans-unit id="featureExpandedMeasurables">
        <source>more types support units of measure</source>
        <target state="new">more types support units of measure</target>
        <note />
      </trans-unit>
      <trans-unit id="featureFixedIndexSlice3d4d">
        <source>fixed-index slice 3d/4d</source>
        <target state="translated">срез с фиксированным индексом 3d/4d</target>
        <note />
      </trans-unit>
      <trans-unit id="featureFromEndSlicing">
        <source>from-end slicing</source>
        <target state="translated">срезы от конца</target>
        <note />
      </trans-unit>
      <trans-unit id="featureImplicitYield">
        <source>implicit yield</source>
        <target state="translated">неявное использование yield</target>
        <note />
      </trans-unit>
      <trans-unit id="featureInterfacesWithMultipleGenericInstantiation">
        <source>interfaces with multiple generic instantiation</source>
        <target state="translated">интерфейсы с множественным универсальным созданием экземпляра</target>
        <note />
      </trans-unit>
      <trans-unit id="featureNameOf">
        <source>nameof</source>
        <target state="translated">nameof</target>
        <note />
      </trans-unit>
      <trans-unit id="featureNullableOptionalInterop">
        <source>nullable optional interop</source>
        <target state="translated">необязательное взаимодействие, допускающее значение NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="featureOpenTypeDeclaration">
        <source>open type declaration</source>
        <target state="translated">объявление открытого типа</target>
        <note />
      </trans-unit>
      <trans-unit id="featureOverloadsForCustomOperations">
        <source>overloads for custom operations</source>
        <target state="translated">перегрузки для настраиваемых операций</target>
        <note />
      </trans-unit>
      <trans-unit id="featurePackageManagement">
        <source>package management</source>
        <target state="translated">управление пакетами</target>
        <note />
      </trans-unit>
      <trans-unit id="featureRelaxWhitespace">
        <source>whitespace relexation</source>
        <target state="translated">уменьшение строгости для пробелов</target>
        <note />
      </trans-unit>
      <trans-unit id="featureSingleUnderscorePattern">
        <source>single underscore pattern</source>
        <target state="translated">шаблон с одним подчеркиванием</target>
        <note />
      </trans-unit>
      <trans-unit id="featureStringInterpolation">
        <source>string interpolation</source>
        <target state="translated">интерполяция строк</target>
        <note />
      </trans-unit>
      <trans-unit id="featureWildCardInForLoop">
        <source>wild card in for loop</source>
        <target state="translated">подстановочный знак в цикле for</target>
        <note />
      </trans-unit>
      <trans-unit id="featureWitnessPassing">
        <source>witness passing for trait constraints in F# quotations</source>
        <target state="translated">Передача свидетеля для ограничений признаков в цитированиях F#</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated">
        <source>Interpolated strings may not use '%' format specifiers unless each is given an expression, e.g. '%d{{1+1}}'.</source>
        <target state="translated">В интерполированных строках запрещено использовать описатели формата "%", если только каждому из них не назначено выражение, например "'%d{{1+1}}".</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated2">
        <source>.NET-style format specifiers such as '{{x,3}}' or '{{x:N5}}' may not be mixed with '%' format specifiers.</source>
        <target state="translated">Описатели формата в стиле .NET, такие как "{{x,3}}" или "{{x:N5}}", запрещено смешивать с описателями формата "%".</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated3">
        <source>The '%P' specifier may not be used explicitly.</source>
        <target state="translated">Описатель "%P" запрещено использовать явно.</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatInvalidForInterpolated4">
        <source>Interpolated strings used as type IFormattable or type FormattableString may not use '%' specifiers, only .NET-style interpolands such as '{{expr}}', '{{expr,3}}' or '{{expr:N5}}' may be used.</source>
        <target state="translated">Интерполированные строки, используемые в качестве типа IFormattable или FormattableString, не могут использовать описатели "%". Можно использовать только описатели в стиле .NET, такие как "{{expr}}", "{{expr,3}}" или "{{expr:N5}}".</target>
        <note />
      </trans-unit>
      <trans-unit id="formatDashItem">
        <source> - {0}</source>
        <target state="translated"> - {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="fromEndSlicingRequiresVFive">
        <source>From the end slicing with requires language version 5.0, use /langversion:preview.</source>
        <target state="translated">Для конечного среза, для которого требуется версия языка 5.0, используйте параметр /langversion:preview.</target>
        <note />
      </trans-unit>
      <trans-unit id="fsiInvalidDirective">
        <source>Invalid directive '#{0} {1}'</source>
        <target state="translated">Недопустимая директива "#{0} {1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionConst">
        <source>Keyword to specify a constant literal as a type parameter argument in Type Providers.</source>
        <target state="translated">Ключевое слово для указания константного литерала в качестве аргумента параметра типа в поставщиках типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteStringMayNotBeInterpolated">
        <source>a byte string may not be interpolated</source>
        <target state="translated">невозможно выполнить интерполяцию для строки байтов</target>
        <note />
      </trans-unit>
      <trans-unit id="lexRBraceInInterpolatedString">
        <source>A '}}' character must be escaped (by doubling) in an interpolated string.</source>
        <target state="translated">Символ "}}" необходимо экранировать (путем дублирования) в интерполированной строке.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexSingleQuoteInSingleQuote">
        <source>Invalid interpolated string. Single quote or verbatim string literals may not be used in interpolated expressions in single quote or verbatim strings. Consider using an explicit 'let' binding for the interpolation expression or use a triple quote string as the outer string literal.</source>
        <target state="translated">Недопустимая интерполированная строка. Строковые литералы с одинарными кавычками или буквальные строковые литералы запрещено использовать в интерполированных выражениях в строках с одинарными кавычками или буквальных строках. Рекомендуется использовать явную привязку "let" для выражения интерполяции или использовать строку с тройными кавычками как внешний строковый литерал.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTripleQuoteInTripleQuote">
        <source>Invalid interpolated string. Triple quote string literals may not be used in interpolated expressions. Consider using an explicit 'let' binding for the interpolation expression.</source>
        <target state="translated">Недопустимая интерполированная строка. Строковые литералы с тройными кавычками запрещено использовать в интерполированных выражениях. Рекомендуется использовать явную привязку "let" для выражения интерполяции.</target>
        <note />
      </trans-unit>
      <trans-unit id="nativeResourceFormatError">
        <source>Stream does not begin with a null resource and is not in '.RES' format.</source>
        <target state="translated">Поток не начинается с нулевого ресурса и не соответствует формату ".RES".</target>
        <note />
      </trans-unit>
      <trans-unit id="nativeResourceHeaderMalformed">
        <source>Resource header beginning at offset {0} is malformed.</source>
        <target state="translated">Заголовок ресурса некорректен начиная со смещения {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLangVersion">
        <source>Display the allowed values for language version, specify language version such as 'latest' or 'preview'</source>
        <target state="translated">Отображение допустимых значений для версии языка. Укажите версию языка, например, "latest" или "preview".</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSupportedLangVersions">
        <source>Supported language versions:</source>
        <target state="translated">Поддерживаемые языковые версии:</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedLanguageVersion">
        <source>Unrecognized value '{0}' for --langversion use --langversion:? for complete list</source>
        <target state="translated">Не удалось распознать значение "{0}" для параметра --langversion. Для получения полного списка допустимых значений выполните команду use --langversion:?</target>
        <note />
      </trans-unit>
      <trans-unit id="optsVersion">
        <source>Display compiler version banner and exit</source>
        <target state="new">Display compiler version banner and exit</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagementRequiresVFive">
        <source>The package management feature requires language version 5.0 use /langversion:preview</source>
        <target state="translated">Для функции управления пакетами требуется версия языка 5.0, используйте параметр /langversion:preview</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyFillInInterpolatedString">
        <source>Invalid interpolated string. This interpolated string expression fill is empty, an expression was expected.</source>
        <target state="translated">Недопустимая интерполированная строка. Выражение этой интерполированной строки является пустым. Ожидается выражение.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedString">
        <source>Incomplete interpolated string begun at or before here</source>
        <target state="translated">Неполная интерполированная строка, начатая в этой позиции или до нее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedStringFill">
        <source>Incomplete interpolated string expression fill begun at or before here</source>
        <target state="translated">Заполнение выражения неполной интерполированной строки, начатое в этой позиции или до нее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedTripleQuoteString">
        <source>Incomplete interpolated triple-quote string begun at or before here</source>
        <target state="translated">Неполная интерполированная строка с тройными кавычками, начатая в этой позиции или до нее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInInterpolatedVerbatimString">
        <source>Incomplete interpolated verbatim string begun at or before here</source>
        <target state="translated">Неполная интерполированная буквальная строка, начатая в этой позиции или до нее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEqualsMissingInTypeDefinition">
        <source>Unexpected token in type definition. Expected '=' after the type '{0}'.</source>
        <target state="new">Unexpected token in type definition. Expected '=' after the type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolDot">
        <source>Unexpected symbol '.' in member definition. Expected 'with', '=' or other token.</source>
        <target state="translated">Неожиданный символ "." в определении члена. Ожидаемые инструкции: "with", "=" или другие токены.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecksumAlgorithm">
        <source>Specify algorithm for calculating source file checksum stored in PDB. Supported values are: SHA1 or SHA256 (default)</source>
        <target state="translated">Укажите алгоритм для вычисления контрольной суммы исходного файла, хранящейся в файле PDB. Поддерживаемые значения: SHA1 или SHA256 (по умолчанию)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">Алгоритм "{0}" не поддерживается</target>
        <note />
      </trans-unit>
      <trans-unit id="poundiNotSupportedByRegisteredDependencyManagers">
        <source>#i is not supported by the registered PackageManagers</source>
        <target state="translated">#i не поддерживается зарегистрированными диспетчерами пакетов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAndBangNotSupported">
        <source>This feature is not supported in this version of F#. You may need to add /langversion:preview to use this feature.</source>
        <target state="translated">Эта функция не поддерживается в данной версии F#. Возможно, потребуется добавить/langversion:preview, чтобы использовать эту функцию.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameDifferent">
        <source>This is the wrong anonymous record. It should have the fields {0}.</source>
        <target state="translated">Неправильная анонимная запись. Она должна содержать поля {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameSubset">
        <source>This anonymous record does not have enough fields. Add the missing fields {0}.</source>
        <target state="translated">В этой анонимной записи недостаточно полей. Добавьте недостающие поля {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameSuperset">
        <source>This anonymous record has too many fields. Remove the extra fields {0}.</source>
        <target state="translated">Эта анонимная запись содержит слишком много полей. Удалите лишние поля {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdInvalid">
        <source>Invalid Anonymous Record type declaration.</source>
        <target state="translated">Недопустимое объявление типа анонимной записи.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAugmentationsCannotHaveAttributes">
        <source>Attributes cannot be applied to type extensions.</source>
        <target state="translated">Атрибуты не могут быть применены к расширениям типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalByrefsInOpenTypeDeclaration">
        <source>Byref types are not allowed in an open type declaration.</source>
        <target state="translated">Типы ByRef запрещены в объявлении открытого типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterpolationMixedWithPercent">
        <source>Mismatch in interpolated string. Interpolated strings may not use '%' format specifiers unless each is given an expression, e.g. '%d{{1+1}}'</source>
        <target state="translated">Несоответствие в интерполированной строке. В интерполированных строках запрещено использовать описатели формата "%", если только каждому из них не назначено выражение, например "'%d{{1+1}}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAlignmentInInterpolatedString">
        <source>Invalid alignment in interpolated string</source>
        <target state="translated">Недопустимое выравнивание в интерполированной строке</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBindingNoAndBangs">
        <source>use! may not be combined with and!</source>
        <target state="translated">use! запрещено сочетать с and!</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralFieldAssignmentNoArg">
        <source>Cannot assign a value to another value marked literal</source>
        <target state="translated">Невозможно присвоить значение другому значению, помеченному как литерал</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralFieldAssignmentWithArg">
        <source>Cannot assign '{0}' to a value marked literal</source>
        <target state="translated">Невозможно присвоить "{0}" значению, помеченному как литерал</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireMergeSourcesOrBindN">
        <source>The 'let! ... and! ...' construct may only be used if the computation expression builder defines either a '{0}' method or appropriate 'MergeSource' and 'Bind' methods</source>
        <target state="translated">Конструкцию "let! ... and! ..." можно использовать только в том случае, если построитель выражений с вычислениями определяет либо метод "{0}", либо соответствующие методы "MergeSource" и "Bind"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseInterpolatedString">
        <source>Invalid interpolated string. {0}</source>
        <target state="translated">Недопустимая интерполированная строка. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceMemberNoMostSpecificImplementation">
        <source>Interface member '{0}' does not have a most specific implementation.</source>
        <target state="translated">Элемент интерфейса "{0}" не имеет наиболее конкретной реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceWithConcreteAndVariable">
        <source>'{0}' cannot implement the interface '{1}' with the two instantiations '{2}' and '{3}' because they may unify.</source>
        <target state="translated">"{0}" не может реализовать интерфейс "{1}" с двумя созданиями экземпляра "{2}" и "{3}", так как они могут быть объединены.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInterfaceWithConcreteAndVariableObjectExpression">
        <source>You cannot implement the interface '{0}' with the two instantiations '{1}' and '{2}' because they may unify.</source>
        <target state="translated">Невозможно реализовать интерфейс "{0}" с двумя созданиями экземпляра "{1}" и "{2}", так как они могут быть объединены.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMemberWhenTypeIsKnown">
        <source>The type '{0}' does not define the field, constructor or member '{1}'.</source>
        <target state="translated">Тип "{0}" не определяет поле, конструктор или член "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespace">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">Пространство имен "{0}" не определено.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameNamespaceOrModule">
        <source>The namespace or module '{0}' is not defined.</source>
        <target state="translated">Пространство имен или модуль "{0}" не определены.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameFieldConstructorOrMember">
        <source>The field, constructor or member '{0}' is not defined.</source>
        <target state="translated">Поле, конструктор или элемент "{0}" не определены.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueConstructorNamespaceOrType">
        <source>The value, constructor, namespace or type '{0}' is not defined.</source>
        <target state="translated">Значение, конструктор, пространство имен или тип "{0}" не определены.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueOfConstructor">
        <source>The value or constructor '{0}' is not defined.</source>
        <target state="translated">Значение или конструктор "{0}" не определены.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameValueNamespaceTypeOrModule">
        <source>The value, namespace, type or module '{0}' is not defined.</source>
        <target state="translated">Значение, пространство имен, тип или модуль "{0}" не определены.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameConstructorModuleOrNamespace">
        <source>The constructor, module or namespace '{0}' is not defined.</source>
        <target state="translated">Конструктор, модуль или пространство имен "{0}" не определены.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameType">
        <source>The type '{0}' is not defined.</source>
        <target state="translated">Тип "{0}" не определен.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeIn">
        <source>The type '{0}' is not defined in '{1}'.</source>
        <target state="translated">Тип "{0}" не определен в "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabelOrNamespace">
        <source>The record label or namespace '{0}' is not defined.</source>
        <target state="translated">Метка записи или пространство имен "{0}" не определены.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameRecordLabel">
        <source>The record label '{0}' is not defined.</source>
        <target state="translated">Метка записи "{0}" не определена.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameSuggestionsIntro">
        <source>Maybe you want one of the following:</source>
        <target state="translated">Возможно, требуется одно из следующих:</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNameTypeParameter">
        <source>The type parameter {0} is not defined.</source>
        <target state="translated">Параметр типа {0} не определен.</target>
        <note />
      </trans-unit>
      <trans-unit id="undefinedNamePatternDiscriminator">
        <source>The pattern discriminator '{0}' is not defined.</source>
        <target state="translated">Дискриминатор шаблона "{0}" не определен.</target>
        <note />
      </trans-unit>
      <trans-unit id="replaceWithSuggestion">
        <source>Replace with '{0}'</source>
        <target state="translated">Заменить на "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="addIndexerDot">
        <source>Add . for indexer access.</source>
        <target state="translated">Добавьте "." для доступа к индексатору.</target>
        <note />
      </trans-unit>
      <trans-unit id="listElementHasWrongType">
        <source>All elements of a list must be of the same type as the first element, which here is '{0}'. This element has type '{1}'.</source>
        <target state="translated">Все элементы выражения конструктора списка должны иметь один и тот же тип. В этом выражении ожидалось использование типа "{0}", но используется тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="arrayElementHasWrongType">
        <source>All elements of an array must be of the same type as the first element, which here is '{0}'. This element has type '{1}'.</source>
        <target state="translated">Все элементы выражения конструктора массива должны иметь один и тот же тип. В этом выражении ожидалось использование типа "{0}", но используется тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="missingElseBranch">
        <source>This 'if' expression is missing an 'else' branch. Because 'if' is an expression, and not a statement, add an 'else' branch which also returns a value of type '{0}'.</source>
        <target state="translated">Выражение "if" не содержит ветвь "else". Ветвь "then" включает тип "{0}". Так как "if" является выражением, а не оператором, добавьте ветвь "else", которая возвращает значение того же типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ifExpression">
        <source>The 'if' expression needs to have type '{0}' to satisfy context type requirements. It currently has type '{1}'.</source>
        <target state="translated">Для соблюдения требований к типу контекста в выражении "if" должен использоваться тип "{0}". Сейчас используется тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="elseBranchHasWrongType">
        <source>All branches of an 'if' expression must return values of the same type as the first branch, which here is '{0}'. This branch returns a value of type '{1}'.</source>
        <target state="translated">Все ветви выражения "if" должны иметь один и тот же тип. В этом выражении ожидалось использование типа "{0}", но используется тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="followingPatternMatchClauseHasWrongType">
        <source>All branches of a pattern match expression must return values of the same type as the first branch, which here is '{0}'. This branch returns a value of type '{1}'.</source>
        <target state="translated">Все ветви выражения сопоставления шаблонов должны возвращать значения одного типа. Первая ветвь возвратила значение типа "{0}", а эта ветвь — типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="patternMatchGuardIsNotBool">
        <source>A pattern match guard must be of type 'bool', but this 'when' expression is of type '{0}'.</source>
        <target state="translated">Условие соответствия шаблону должно иметь тип "bool", но это выражение "when" имеет тип "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="commaInsteadOfSemicolonInRecord">
        <source>A ';' is used to separate field values in records. Consider replacing ',' with ';'.</source>
        <target state="translated">Символ ";" используется для разделения значений поля в записях. Рекомендуется заменить "," на ";".</target>
        <note />
      </trans-unit>
      <trans-unit id="derefInsteadOfNot">
        <source>The '!' operator is used to dereference a ref cell. Consider using 'not expr' here.</source>
        <target state="translated">Оператор "!" используется для разыменования ссылочной ячейки. Рассмотрите использование здесь "not expr".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedTypeArgs">
        <source>The non-generic type '{0}' does not expect any type arguments, but here is given {1} type argument(s)</source>
        <target state="translated">Для не являющегося универсальным типа "{0}" не требуются аргументы типа, однако здесь задано следующее число аргументов типа: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="returnUsedInsteadOfReturnBang">
        <source>Consider using 'return!' instead of 'return'.</source>
        <target state="translated">Рекомендуется использовать "return!" вместо "return".</target>
        <note />
      </trans-unit>
      <trans-unit id="useSdkRefs">
        <source>Use reference assemblies for .NET framework references when available (Enabled by default).</source>
        <target state="translated">Использовать базовые сборки для ссылок на платформу .NET, если базовые сборки доступны (включено по умолчанию).</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocBadlyFormed">
        <source>This XML comment is invalid: '{0}'</source>
        <target state="translated">Недопустимый XML-комментарий: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocDuplicateParameter">
        <source>This XML comment is invalid: multiple documentation entries for parameter '{0}'</source>
        <target state="translated">Недопустимый XML-комментарий: несколько записей документации для параметра "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocInvalidParameterName">
        <source>This XML comment is invalid: unknown parameter '{0}'</source>
        <target state="translated">Недопустимый XML-комментарий: неизвестный параметр "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingCrossReference">
        <source>This XML comment is invalid: missing 'cref' attribute for cross-reference</source>
        <target state="translated">Недопустимый XML-комментарий: отсутствует атрибут "cref" для перекрестной ссылки</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingParameter">
        <source>This XML comment is incomplete: no documentation for parameter '{0}'</source>
        <target state="translated">Неполный XML-комментарий: отсутствует документация для параметра "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocMissingParameterName">
        <source>This XML comment is invalid: missing 'name' attribute for parameter or parameter reference</source>
        <target state="translated">Недопустимый XML-комментарий: отсутствует атрибут "name" для параметра или ссылки на параметр</target>
        <note />
      </trans-unit>
      <trans-unit id="xmlDocUnresolvedCrossReference">
        <source>This XML comment is invalid: unresolved cross-reference '{0}'</source>
        <target state="translated">Недопустимый XML-комментарий: неразрешенная перекрестная ссылка "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="yieldUsedInsteadOfYieldBang">
        <source>Consider using 'yield!' instead of 'yield'.</source>
        <target state="translated">Рекомендуется использовать "yield!" вместо "yield".</target>
        <note />
      </trans-unit>
      <trans-unit id="tupleRequiredInAbstractMethod">
        <source>\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.</source>
        <target state="translated">\nНеобходимо указать тип кортежа для одного аргумента (или нескольких). Рекомендуется заключить эти аргументы в дополнительные скобки или проверить определение интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidWarningNumber">
        <source>Invalid warning number '{0}'</source>
        <target state="translated">Недопустимый номер предупреждения "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionString">
        <source>Invalid version string '{0}'</source>
        <target state="translated">Недопустимая строка версии "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidVersionFile">
        <source>Invalid version file '{0}'</source>
        <target state="translated">Недопустимый файл версии "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemWithFilename">
        <source>Problem with filename '{0}': {1}</source>
        <target state="translated">Ошибка в имени файла "{0}": {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildNoInputsSpecified">
        <source>No inputs specified</source>
        <target state="translated">Не указаны входные данные</target>
        <note />
      </trans-unit>
      <trans-unit id="buildPdbRequiresDebug">
        <source>The '--pdb' option requires the '--debug' option to be used</source>
        <target state="translated">Для параметра "--pdb" требуется использовать параметр "--debug"</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSearchDirectory">
        <source>The search directory '{0}' is invalid</source>
        <target state="translated">Недопустимый каталог поиска "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSearchDirectoryNotFound">
        <source>The search directory '{0}' could not be found</source>
        <target state="translated">Не удалось найти каталог поиска "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidFilename">
        <source>'{0}' is not a valid filename</source>
        <target state="translated">{0} не является допустимым именем файла</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidAssemblyName">
        <source>'{0}' is not a valid assembly name</source>
        <target state="translated">{0} не является допустимым именем сборки</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidPrivacy">
        <source>Unrecognized privacy setting '{0}' for managed resource, valid options are 'public' and 'private'</source>
        <target state="translated">Нераспознанный параметр конфиденциальности "{0}" для управляемого ресурса. Допускается использование параметров "public" и "private"</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCannotReadAssembly">
        <source>Unable to read assembly '{0}'</source>
        <target state="translated">Не удается прочитать сборку "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="buildAssemblyResolutionFailed">
        <source>Assembly resolution failure at or near this location</source>
        <target state="translated">Сбой при разрешении сборки в этой или близлежащих строках</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplicitModuleIsNotLegalIdentifier">
        <source>The declarations in this file will be placed in an implicit module '{0}' based on the file name '{1}'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file.</source>
        <target state="translated">Объявления, содержащиеся в этом файле, будут помещены в неявный модуль "{0}" на основе имени файла "{1}". Тем не менее, поскольку этот идентификатор не является допустимым идентификатором F#, содержимое будет недоступно из других файлов. Рекомендуется переименовать файл либо добавить объявление "module" или "namespace" в начало файла.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultiFileRequiresNamespaceOrModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration.</source>
        <target state="translated">Файлы в библиотеках или многофайловых приложениях должны начинаться с объявления пространства имен или модуля, например, "namespace SomeNamespace.SubNamespace" или "module SomeNamespace.SomeModule". Такое объявление может отсутствовать только в последнем файле исходного кода приложения.</target>
        <note />
      </trans-unit>
      <trans-unit id="noEqualSignAfterModule">
        <source>Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.</source>
        <target state="translated">Файлы в библиотеках или многофайловых приложениях должны начинаться с объявления пространства имен или модуля. При использовании объявления модуля в начале файла знак "=" не разрешен. Если это модуль верхнего уровня, рекомендуется удалить "=", чтобы устранить эту ошибку.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildMultipleToplevelModules">
        <source>This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules.</source>
        <target state="translated">Этот файл содержит несколько объявлений вида "module SomeNamespace.SomeModule". В одном файле может присутствовать только одно объявление такого вида. Измените файл, объявив в нем исходное пространство имен или определив модули с помощью объявления "module ModuleName = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildOptionRequiresParameter">
        <source>Option requires parameter: {0}</source>
        <target state="translated">Требуется параметр: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotFindSourceFile">
        <source>Source file '{0}' could not be found</source>
        <target state="translated">Исходный файл "{0}" не найден</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidSourceFileExtension">
        <source>The file extension of '{0}' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.</source>
        <target state="translated">Нераспознанное расширение файла "{0}". Исходные файлы должны иметь расширения .fs, .fsi, .fsx, .fsscript, .ml или .mli.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssembly">
        <source>Could not resolve assembly '{0}'</source>
        <target state="translated">Не удалось разрешить сборку "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCouldNotResolveAssemblyRequiredByFile">
        <source>Could not resolve assembly '{0}' required by '{1}'</source>
        <target state="translated">Не удалось разрешить сборку "{0}", необходимую для "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="buildErrorOpeningBinaryFile">
        <source>Error opening binary file '{0}': {1}</source>
        <target state="translated">Ошибка при открытии двоичного файла "{0}": {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDifferentVersionMustRecompile">
        <source>The F#-compiled DLL '{0}' needs to be recompiled to be used with this version of F#</source>
        <target state="translated">Чтобы использовать библиотеку DLL "{0}", скомпилированную на языке F#, в этой версии F#, необходимо перекомпилировать ее</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashIDirective">
        <source>Invalid directive. Expected '#I \"&lt;path&gt;\"'.</source>
        <target state="translated">Недопустимая директива. Ожидается '#I \"&lt;путь&gt;\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashrDirective">
        <source>Invalid directive. Expected '#r \"&lt;file-or-assembly&gt;\"'.</source>
        <target state="translated">Недопустимая директива. Ожидаемая директива: '#r \"&lt;file-or-assembly&gt;\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashloadDirective">
        <source>Invalid directive. Expected '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</source>
        <target state="translated">Недопустимая директива. Ожидаемая директива: '#load \"&lt;файл&gt;\" ... \"&lt;файл&gt;\"'.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidHashtimeDirective">
        <source>Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'.</source>
        <target state="translated">Недопустимая директива. Требуется ''#time'', ''#time \"on\"'' или ''#time \"off\"''.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildDirectivesInModulesAreIgnored">
        <source>Directives inside modules are ignored</source>
        <target state="translated">Директивы внутри модулей пропущены</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureAlreadySpecified">
        <source>A signature for the file or module '{0}' has already been specified</source>
        <target state="translated">Сигнатура файла или модуля "{0}" уже указана</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGivenDetail">
        <source>An implementation of file or module '{0}' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.</source>
        <target state="translated">Реализация файла или модуля "{0}" уже задана. В связи с использованием определения типа в F# имеет значение порядок компиляции. Перед выполнением реализации может потребоваться изменение порядка для размещения файла сигнатур. В среде Visual Studio файлы проверяются на типы в том порядке, в котором они отображаются в файле проекта, который можно изменить вручную или с помощью обозревателя решений.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildImplementationAlreadyGiven">
        <source>An implementation of the file or module '{0}' has already been given</source>
        <target state="translated">Реализация файла или модуля "{0}" уже задана</target>
        <note />
      </trans-unit>
      <trans-unit id="buildSignatureWithoutImplementation">
        <source>The signature file '{0}' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match.</source>
        <target state="translated">Отсутствует соответствующий файл реализации для файла сигнатур "{0}". Если файл реализации существует, убедитесь, что объявления "module" и "namespace" в файлах сигнатур и реализации совпадают.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidInt">
        <source>'{0}' is not a valid integer argument</source>
        <target state="translated">{0} не является действительным целочисленным аргументом</target>
        <note />
      </trans-unit>
      <trans-unit id="buildArgInvalidFloat">
        <source>'{0}' is not a valid floating point argument</source>
        <target state="translated">{0} не является действительным аргументом с плавающей запятой</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnrecognizedOption">
        <source>Unrecognized option: '{0}'</source>
        <target state="translated">Нераспознанный параметр: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="buildInvalidModuleOrNamespaceName">
        <source>Invalid module or namespace name</source>
        <target state="translated">Недопустимое имя модуля или пространства имен</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleErrorReadingWritingMetadata">
        <source>Error reading/writing metadata for the F# compiled DLL '{0}'. Was the DLL compiled with an earlier version of the F# compiler? (error: '{1}').</source>
        <target state="translated">Ошибка при чтении или записи метаданных для скомпилированной на языке F# библиотеки DLL "{0}". Была ли библиотека DLL скомпилирована с использованием более ранней версии компилятора F#? (ошибка: "{1}").</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeOrModuleNotConcrete">
        <source>The type/module '{0}' is not a concrete module or type</source>
        <target state="translated">Тип или модуль "{0}" не является конкретным модулем или типом</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTypeHasAssemblyCodeRepresentation">
        <source>The type '{0}' has an inline assembly code representation</source>
        <target state="translated">Тип "{0}" имеет представление встроенного кода сборки</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNamespaceAndModuleWithSameNameInAssembly">
        <source>A namespace and a module named '{0}' both occur in two parts of this assembly</source>
        <target state="translated">Пространство имен и модуль с именем "{0}" одновременно встречаются в двух частях этой сборки</target>
        <note />
      </trans-unit>
      <trans-unit id="tastTwoModulesWithSameNameInAssembly">
        <source>Two modules named '{0}' occur in two parts of this assembly</source>
        <target state="translated">Два модуля с именем "{0}" встречаются в двух частях этой сборки</target>
        <note />
      </trans-unit>
      <trans-unit id="tastDuplicateTypeDefinitionInAssembly">
        <source>Two type definitions named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">Два определения типа с именем "{0}" встречаются в пространстве имен "{1}" в двух разных частях этой сборки</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConflictingModuleAndTypeDefinitionInAssembly">
        <source>A module and a type definition named '{0}' occur in namespace '{1}' in two parts of this assembly</source>
        <target state="translated">Определение модуля и типа с именем "{0}" встречаются в пространстве имен "{1}" в двух разных частях этой сборки</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMemberSignature">
        <source>Invalid member signature encountered because of an earlier error</source>
        <target state="translated">Обнаружена недопустимая сигнатура элемента, связанная с предшествующей ошибкой</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueDoesNotHaveSetterType">
        <source>This value does not have a valid property setter type</source>
        <target state="translated">Это значение имеет недопустимый тип метода присваивания значения свойства</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertyGetter">
        <source>Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax.</source>
        <target state="translated">Недопустимая форма метода получения свойства. При использовании явного синтаксиса требуется как минимум один аргумент "()".</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidFormForPropertySetter">
        <source>Invalid form for a property setter. At least one argument is required.</source>
        <target state="translated">Недопустимая форма метода присваивания значения свойства. Требуется как минимум один аргумент.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedByRef">
        <source>Unexpected use of a byref-typed variable</source>
        <target state="translated">Недопустимое использование переменной типа byref</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidMutationOfConstant">
        <source>Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'.</source>
        <target state="translated">Недопустимое изменение константного выражения. Рекомендуется скопировать выражение в изменяемую локальную переменную, например, "let mutable x = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueHasBeenCopied">
        <source>The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed</source>
        <target state="translated">Значение было скопировано, чтобы не допустить изменения исходного значения этой операцией, или так как копирование выполняется неявно при возвращении структуры из члена и последующего получения доступа к другому члену</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeInConstructionOfTuple">
        <source>Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding</source>
        <target state="translated">Рекурсивно определяемые значения не могут использоваться непосредственно в составе конструкции или значения кортежа внутри рекурсивной привязки</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotAppearInConstructionOfType">
        <source>Recursive values cannot appear directly as a construction of the type '{0}' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.</source>
        <target state="translated">Рекурсивные значения не могут использоваться непосредственно в конструкциях вида "{0}" внутри рекурсивной привязки. Эта функция удалена из языка F#. Вместо этого рекомендуется использовать запись.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastRecursiveValuesMayNotBeAssignedToNonMutableField">
        <source>Recursive values cannot be directly assigned to the non-mutable field '{0}' of the type '{1}' within a recursive binding. Consider using a mutable field instead.</source>
        <target state="translated">Не допускается непосредственное присваивание рекурсивных значений неизменяемому полю "{0}" типа "{1}" внутри рекурсивной привязки. Вместо этого рекомендуется использовать изменяемое поле.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfAutoOpenAttribute">
        <source>Unexpected decode of AutoOpenAttribute</source>
        <target state="translated">Недопустимое декодирование атрибута AutoOpenAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInternalsVisibleToAttribute">
        <source>Unexpected decode of InternalsVisibleToAttribute</source>
        <target state="translated">Недопустимое декодирование атрибута InternalsVisibleToAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
        <source>Unexpected decode of InterfaceDataVersionAttribute</source>
        <target state="translated">Недопустимое декодирование атрибута InterfaceDataVersionAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="tastActivePatternsLimitedToSeven">
        <source>Active patterns cannot return more than 7 possibilities</source>
        <target state="translated">Активные шаблоны не могут возвращать более 7 возможностей</target>
        <note />
      </trans-unit>
      <trans-unit id="tastNotAConstantExpression">
        <source>This is not a valid constant expression or custom attribute value</source>
        <target state="translated">Это выражение не является допустимым константным выражением или значением пользовательского атрибута</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAttributesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe mutability attributes differ</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nИзменяемость атрибутов различается</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe names differ</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nИмена различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityCompiledNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled names differ</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако в его сигнатуре указано\n    {2}    \nСкомпилированные имена различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDisplayNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe display names differ</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако в его сигнатуре указано\n    {2}    \nОтображаемые имена различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAccessibilityMore">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nДоступность, заданная в сигнатуре, шире указанной в реализации</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInlineFlagsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe inline flags differ</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nВстроенные флаги различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityLiteralConstantValuesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe literal constant values and/or attributes differ</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nЗначения литеральных констант и (или) атрибутов различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsTypeFunction">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является функциональным типом, другой - нет Сигнатура требует явных параметров типов, если они присутствуют в реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityParameterCountsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe respective type parameter counts differ</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nСоответствующие количества параметров типов различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityTypesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe types differ</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nТипы различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityExtensionsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is an extension member and the other is not</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является элементом расширения, другой - нет</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityArityNotInferred">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nAn arity was not inferred for this value</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nАрность не была выведена для этого значения</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe number of generic parameters in the signature and implementation differ (the signature declares {3} but the implementation declares {4}</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nЧисло универсальных параметров в сигнатуре и реализации различаются (сигнатура объявляет {3}, однако реализация объявляет {4})</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityGenericParametersAreDifferentKinds">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.</source>
        <target state="translated">Модуль "{0}" содержит\n {1}, \nно в его подписи указано\n {2} \nУниверсальные параметры в подписи и реализации имеют различные типы. Возможно, отсутствует атрибут [&lt;Measure&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAritiesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe arities in the signature and implementation differ. The signature specifies that '{3}' is function definition or lambda expression accepting at least {4} argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval {5}: int -&gt; (int -&gt; int)\ninstead of\n\tval {6}: int -&gt; int -&gt; int.</source>
        <target state="translated">Модуль '{0}' содержит\n    {1},    \nно в его подписи указано\n    {2}    \nКоличество аргументов в подписи и реализации различаются. В подписи указано, что '{3}' является определением функции или лямбда-выражением, которое принимает не менее {4} аргументов, но в реализации это значение является значением вычисляемой функции. Чтобы объявить, что в реализации может использоваться значение вычисляемой функции, просто заключите его в скобки в подписи, например, \n\tval {5}: int -&gt; (int -&gt; int)\nвместо\n\tval {6}: int -&gt; int -&gt; int.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityDotNetNamesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe CLI member names differ</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nИмена элементов CLI различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is static and the other isn't</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является статическим, другой - нет</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityVirtualsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is virtual and the other isn't</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является виртуальным, другой - нет</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityAbstractsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is abstract and the other isn't</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является абстрактным, другой - нет</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityFinalsDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is final and the other isn't</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является финальным, другой - нет</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOverridesDiffer">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is marked as an override and the other isn't</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин помечен как "override", другой - нет</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityOneIsConstructor">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nOne is a constructor/property and the other is not</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является конструктором или свойством, другой - нет</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityStaticButInstance">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОткомпилированное представление этого метода является статическим элементом, однако его сигнатура указывает, что его откомпилированное представление является экземплярным элементом</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueNotContainedMutabilityInstanceButStatic">
        <source>Module '{0}' contains\n    {1}    \nbut its signature specifies\n    {2}    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member</source>
        <target state="translated">Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОткомпилированное представление этого метода является экземплярным элементом, однако его сигнатура указывает, что его откомпилированное представление является статическим элементом</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNamesDiffer">
        <source>The {0} definitions in the signature and implementation are not compatible because the names differ. The type is called '{1}' in the signature file but '{2}' in implementation.</source>
        <target state="translated">Определения {0} в сигнатуре и реализации несовместимы, так как названия различаются. Название типа — "{1}" в файле сигнатуры, но "{2}" в реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как соответствующие количества параметров типов различаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как доступность, заданная в сигнатуре, шире указанной в реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleMissingInterface">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature requires that the type supports the interface {2} but the interface has not been implemented</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как в сигнатуре указано, что тип поддерживает интерфейс {2}, который не реализован.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как реализация (в отличие от сигнатуры) определяет, что этот тип может использовать значение NULL в качестве представления.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как реализация (в отличие от сигнатуры) определяет, что этот тип может использовать значение NULL в качестве дополнительного значения.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сигнатура (в отличие от реализации) определяет, что этот тип может использовать значение NULL в качестве представления.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сигнатура (в отличие от реализации) определяет, что этот тип может использовать значение NULL в качестве дополнительного значения.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.</source>
        <target state="translated">Определения {0} типа '{1}' в подписи и реализации несовместимы, так как тип реализации закрыт, но он не должен быть закрыт согласно подписи. Добавьте в подпись атрибут [&lt;Sealed&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.</source>
        <target state="translated">Определения {0} типа '{1}' в подписи и реализации несовместимы, так как тип реализации не закрыт, однако в соответствии с подписью он должен быть закрыт. Добавьте атрибут [&lt;Sealed&gt;] в реализацию.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.</source>
        <target state="translated">Определения {0} типа '{1}' в подписи и реализации несовместимы, так как реализация представляет собой абстрактный класс, а подпись — нет. Добавьте атрибут [&lt;AbstractClass&gt;] к подписи.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.</source>
        <target state="translated">Определения {0} для типа '{1}' в подписи и реализации несовместимы, так как подпись является абстрактным классом, а реализация — нет. Добавьте атрибут [&lt;AbstractClass&gt;] к реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types have different base types</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как типы имеют разные базовые типы.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleNumbersDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the number of {2}s differ</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как количества {2} различаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature defines the {2} '{3}' but the implementation does not (or does, but not in the same order)</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сигнатура определяет {2} "{3}", а реализация — нет (или определяет, но не в том же порядке).</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines the {2} '{3}' but the signature does not (or does, but not in the same order)</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как реализация определяет {2} "{3}", а сигнатура — нет (или определяет, но не в том же порядке).</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как реализация определяет структуру, а сигнатура определяет тип со скрытым представлением.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как представление типа CLI скрывается сигнатурой.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsHidden">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because a type representation is being hidden by a signature</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как представление типа скрывается сигнатурой.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the types are of different kinds</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как типы принадлежат разным разновидностям.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleILDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the IL representations differ</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как представления IL различаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the representations differ</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как представления различаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldWasPresent">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was present in the implementation but not in the signature</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как поле {2} присутствует в реализации, но отсутствует в сигнатуре.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как порядок полей в сигнатуре и реализации различается.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field {2} was required by the signature but was not specified by the implementation</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как поле {2} является обязательным в сигнатуре, но не указано в реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the field '{2}' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'.</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как поле "{2}" присутствует в реализации, но отсутствует в сигнатуре. Типы-структуры теперь должны показывать свои поля в сигнатуре для типа, несмотря на то что поля по-прежнему могут помечаться как private или internal.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was required by the signature but was not specified by the implementation</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как абстрактный элемент "{2}" задан в сигнатуре, но не указан в реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abstract member '{2}' was present in the implementation but not in the signature</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как абстрактный элемент "{2}" присутствует в реализации, но отсутствует в сигнатуре.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature declares a {2} while the implementation declares a {3}</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сигнатура объявляет {2}, а реализация — {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the abbreviations differ: {2} versus {3}</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сокращения различаются: {2} в сравнении с {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сокращение скрывается сигнатурой. Сокращение должно быть видимым для других языков CLI. Попробуйте сделать сокращение видимым в сигнатуре.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation">
        <source>The {0} definitions for type '{1}' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not</source>
        <target state="translated">Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сигнатура имеет сокращение, а реализация — нет.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButNamesDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">Модуль содержит конструктор\n    {0}    \nоднако его сигнатура задает\n    {1}    \nИмена различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButDataFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe respective number of data fields differ</source>
        <target state="translated">Модуль содержит конструктор\n    {0}    \nоднако его сигнатура задает\n    {1}    \nСоответствующие количества полей данных различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButTypesOfFieldsDiffer">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nThe types of the fields differ</source>
        <target state="translated">Модуль содержит конструктор\n    {0}    \nоднако его сигнатура задает\n    {1}    \nТипы полей различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleContainsConstructorButAccessibilityDiffers">
        <source>The module contains the constructor\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Модуль содержит конструктор\n    {0}    \nоднако его сигнатура задает\n    {1}    \nдоступность, заданная в сигнатуре, шире указанной в реализации</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedNamesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe names differ</source>
        <target state="translated">Модуль содержит поле\n    {0}    \nоднако его сигнатура задает\n    {1}    \nИмена различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedAccessibilitiesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nthe accessibility specified in the signature is more than that specified in the implementation</source>
        <target state="translated">Модуль содержит поле\n    {0}    \nоднако его сигнатура задает\n    {1}    \nдоступность, заданная в сигнатуре, шире указанной в реализации</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedStaticsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'static' modifiers differ</source>
        <target state="translated">Модуль содержит поле\n    {0}    \nоднако его сигнатура задает\n    {1}    \nМодификаторы "static" различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedMutablesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'mutable' modifiers differ</source>
        <target state="translated">Модуль содержит поле\n    {0}    \nоднако его сигнатура задает\n    {1}    \nМодификаторы "mutable" различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedLiteralsDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe 'literal' modifiers differ</source>
        <target state="translated">Модуль содержит поле\n    {0}    \nоднако его сигнатура задает\n    {1}    \nМодификаторы "literal" различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldNotContainedTypesDiffer">
        <source>The module contains the field\n    {0}    \nbut its signature specifies\n    {1}    \nThe types differ</source>
        <target state="translated">Модуль содержит поле\n    {0}    \nоднако его сигнатура задает\n    {1}    \nТипы различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveImplicitGenericInstantiation">
        <source>The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '{0}' and '{1}'. Consider using type annotations to resolve the ambiguity</source>
        <target state="translated">Неявное создание экземпляров базовой конструкции в данной точке или рядом с ней не может быть разрешено, так как тогда возможно разрешение в несколько несвязанных типов, напр. "{0}" и "{1}". Рекомендуется использовать аннотации типа для решения неоднозначности</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInPrintf">
        <source>Could not resolve the ambiguity inherent in the use of a 'printf'-style format string</source>
        <target state="translated">Не удалось разрешить неоднозначность, унаследованную в использовании строки формата вида "printf"</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInEnum">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position</source>
        <target state="translated">Не удалось разрешить неоднозначность в использовании базовой конструкции с ограничением "enum" в этой позиции или рядом с ней</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInDelegate">
        <source>Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position</source>
        <target state="translated">Не удалось разрешить неоднозначность в использовании базовой конструкции с ограничением "delegate" в этой позиции или рядом с ней</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelInvalidValue">
        <source>Invalid value</source>
        <target state="translated">Недопустимое значение</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleParamCountsDiffer">
        <source>The signature and implementation are not compatible because the respective type parameter counts differ</source>
        <target state="translated">Сигнатура и реализация несовместимы, поскольку соответствующие количества параметров типов различаются</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
        <source>The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation</source>
        <target state="translated">Сигнатура и реализация несовместимы, так как параметр типа в классе/сигнатуре имеет требования по времени компилирования, отличные от требований в элементе/реализации</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDiffer">
        <source>The signature and implementation are not compatible because the declaration of the type parameter '{0}' requires a constraint of the form {1}</source>
        <target state="translated">Сигнатура и реализация несовместимы, так как объявление параметра типа "{0}" требует ограничения формы {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelSigImplNotCompatibleConstraintsDifferRemove">
        <source>The signature and implementation are not compatible because the type parameter '{0}' has a constraint of the form {1} but the implementation does not. Either remove this constraint from the signature or add it to the implementation.</source>
        <target state="translated">Сигнатура и реализация несовместимы, поскольку параметр типа "{0}" имеет ограничение формы {1}, а реализация не имеет. Удалите это ограничение из сигнатуры либо добавьте его к реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableShouldOverrideObjectEquals">
        <source>The type '{0}' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'</source>
        <target state="translated">Тип "{0}" реализует "System.IComparable". Рекомендуется также добавить явное переопределение для "Object.Equals"</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelTypeImplementsIComparableDefaultObjectEqualsProvided">
        <source>The type '{0}' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly</source>
        <target state="translated">Тип "{0}" явно реализует "System.IComparable", но не предоставляет соответствующего переопределения для "Object.Equals". Была автоматически предоставлена реализация "Object.Equals"; реализация выполнена через "System.IComparable". Рекомендуется явно реализовывать переопределение "Object.Equals"</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCodeOrEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" содержит явную реализацию "Object.GetHashCode" или "Object.Equals". Необходимо применить к типу атрибут "CustomEquality"</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfGetHashCode">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" содержит явную реализацию "Object.GetHashCode". Попробуйте реализовать соответствующее переопределение для "Object.Equals(obj)"</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelExplicitImplementationOfEquals">
        <source>The struct, record or union type '{0}' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" содержит явную реализацию "Object.Equals". Попробуйте реализовать соответствующее переопределение для "Object.GetHashCode()"</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleHiddenBySignature">
        <source>The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">Определения исключений несовместимы, поскольку сопоставление исключений CLI скрыто сигнатурой. Сопоставление исключений должно быть видимо в других модулях. Модуль содержит определение исключения\n    {0}    \nоднако его сигнатура задает\n\t{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer">
        <source>The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}</source>
        <target state="translated">Определения исключений несовместимы из-за различий в представлениях CLI. Модуль содержит определение исключения\n    {0}    \nоднако его сигнатура задает\n\t{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature">
        <source>The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Определения исключений несовместимы, поскольку сокращенная форма исключения скрыта сигнатурой. Сокращение должно быть видимым для других языков CLI. Попробуйте сделать сокращение видимым в сигнатуре. Модуль содержит определение исключения\n    {0}    \nоднако его сигнатура задает\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleSignaturesDiffer">
        <source>The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Определения исключений несовместимы, поскольку их сокращенные формы в сигнатуре и реализации различаются. Модуль содержит определение исключения\n    {0}    \nоднако его сигнатура задает\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer">
        <source>The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Определения исключений несовместимы из-за различий в объявлениях исключений. Модуль содержит определение исключения\n    {0}    \nоднако его сигнатура задает\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInSigButNotImpl">
        <source>The exception definitions are not compatible because the field '{0}' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">Определения исключений несовместимы, поскольку поле "{0}" требуется в сигнатуре, но не задано в реализации. Модуль содержит определение исключения\n    {1}    \nоднако его сигнатура задает\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldInImplButNotSig">
        <source>The exception definitions are not compatible because the field '{0}' was present in the implementation but not in the signature. The module contains the exception definition\n    {1}    \nbut its signature specifies\n\t{2}.</source>
        <target state="translated">Определения исключений несовместимы, поскольку поле "{0}" присутствует в реализации, но не в сигнатуре. Модуль содержит определение исключения\n    {1}    \nоднако его сигнатура задает\n\t{2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionDefsNotCompatibleFieldOrderDiffers">
        <source>The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    {0}    \nbut its signature specifies\n\t{1}.</source>
        <target state="translated">Определения исключений несовместимы, поскольку отличается порядок полей в сигнатуре и реализации. Модуль содержит определение исключения\n    {0}    \nоднако его сигнатура задает\n\t{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelModuleNamespaceAttributesDifferInSigAndImpl">
        <source>The namespace or module attributes differ between signature and implementation</source>
        <target state="translated">Атрибуты пространства имен или модуля различаются в сигнатуре и реализации</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsOverconstrained">
        <source>This method is over-constrained in its type parameters</source>
        <target state="translated">Данный метод чрезмерно ограничен в параметрах типа</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverloadNotFound">
        <source>No implementations of '{0}' had the correct number of arguments and type parameters. The required signature is '{1}'.</source>
        <target state="translated">Ни одна реализация "{0}" не имеет нужного числа аргументов и параметров типа. Необходимая сигнатура: "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideWasAmbiguous">
        <source>The override for '{0}' was ambiguous</source>
        <target state="translated">Переопределение для "{0}" было неоднозначным</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMoreThenOneOverride">
        <source>More than one override implements '{0}'</source>
        <target state="translated">{0} реализуется более чем одним переопределением</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMethodIsSealed">
        <source>The method '{0}' is sealed and cannot be overridden</source>
        <target state="translated">Метод "{0}" запечатан и не может быть переопределен</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelOverrideImplementsMoreThenOneSlot">
        <source>The override '{0}' implements more than one abstract slot, e.g. '{1}' and '{2}'</source>
        <target state="translated">Переопределение "{0}" реализует более одного абстрактного слота, напр. "{1}" и "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelDuplicateInterface">
        <source>Duplicate or redundant interface</source>
        <target state="translated">Повторяющийся или избыточный интерфейс</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNeedExplicitImplementation">
        <source>The interface '{0}' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.</source>
        <target state="translated">Интерфейс "{0}" включен в несколько явно реализованных типов интерфейса. Добавьте явную реализацию данного интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNamedArgumentHasBeenAssignedMoreThenOnce">
        <source>The named argument '{0}' has been assigned more than one value</source>
        <target state="translated">Именованному аргументу "{0}" было присвоено несколько значений</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGiven">
        <source>No implementation was given for '{0}'</source>
        <target state="translated">Для "{0}" не было дано реализации</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenWithSuggestion">
        <source>No implementation was given for '{0}'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Для "{0}" не было дано реализации. Обратите внимание на то, что все элементы интерфейса должны быть реализованы и перечислены в соответствующем объявлении "interface", например "interface ... with member ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfArguments">
        <source>The member '{0}' does not have the correct number of arguments. The required signature is '{1}'.</source>
        <target state="translated">Элемент "{0}" не имеет нужного числа аргументов. Необходимая сигнатура: "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters">
        <source>The member '{0}' does not have the correct number of method type parameters. The required signature is '{1}'.</source>
        <target state="translated">Элемент "{0}" не имеет нужного числа параметров типа метода. Необходимая сигнатура: "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters">
        <source>The member '{0}' does not have the correct kinds of generic parameters. The required signature is '{1}'.</source>
        <target state="translated">Элемент "{0}" не имеет нужных базовых параметров. Необходимая сигнатура: "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberCannotImplement">
        <source>The member '{0}' cannot be used to implement '{1}'. The required signature is '{2}'.</source>
        <target state="translated">Использование элемента "{0}" для реализации "{1}" невозможно. Необходимая сигнатура: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILError">
        <source>Error while parsing embedded IL</source>
        <target state="translated">Ошибка при синтаксическом анализе встроенного IL</target>
        <note />
      </trans-unit>
      <trans-unit id="astParseEmbeddedILTypeError">
        <source>Error while parsing embedded IL type</source>
        <target state="translated">Ошибка при синтаксическом анализе встроенного типа IL</target>
        <note />
      </trans-unit>
      <trans-unit id="astDeprecatedIndexerNotation">
        <source>This indexer notation has been removed from the F# language</source>
        <target state="translated">Эта нотация индексатора удалена из языка F#</target>
        <note />
      </trans-unit>
      <trans-unit id="astInvalidExprLeftHandOfAssignment">
        <source>Invalid expression on left of assignment</source>
        <target state="translated">Недопустимое выражение в левой части оператора присваивания</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoRefEqualsOnStruct">
        <source>The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'.</source>
        <target state="translated">Атрибут "ReferenceEquality" не может использоваться в структурах. Вместо этого рекомендуется использовать атрибут "StructuralEquality" или реализовать переопределение метода "System.Object.Equals(obj)".</target>
        <note />
      </trans-unit>
      <trans-unit id="augInvalidAttrs">
        <source>This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'</source>
        <target state="translated">В этом типе используется недопустимое сочетание атрибутов "NoEquality", "ReferenceEquality", "StructuralEquality", "NoComparison" и "StructuralComparison"</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqualityNeedsNoComparison">
        <source>The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute</source>
        <target state="translated">Атрибут "NoEquality" необходимо использовать в сочетании с атрибутом "NoComparison"</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructCompNeedsStructEquality">
        <source>The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute</source>
        <target state="translated">Атрибут "StructuralComparison" необходимо использовать в сочетании с атрибутом "StructuralEquality"</target>
        <note />
      </trans-unit>
      <trans-unit id="augStructEqNeedsNoCompOrStructComp">
        <source>The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes</source>
        <target state="translated">Атрибут "StructuralEquality" необходимо использовать в сочетании с атрибутами "NoComparison" или "StructuralComparison"</target>
        <note />
      </trans-unit>
      <trans-unit id="augTypeCantHaveRefEqAndStructAttrs">
        <source>A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes</source>
        <target state="translated">Тип не может содержать одновременно атрибуты "ReferenceEquality" и "StructuralEquality" или "StructuralComparison"</target>
        <note />
      </trans-unit>
      <trans-unit id="augOnlyCertainTypesCanHaveAttrs">
        <source>Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes</source>
        <target state="translated">Атрибуты "ReferenceEquality", "StructuralEquality" и "StructuralComparison" можно использовать только для приращения типов записи, объединения, исключения и структуры</target>
        <note />
      </trans-unit>
      <trans-unit id="augRefEqCantHaveObjEquals">
        <source>A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">Тип с атрибутом 'ReferenceEquality' не может иметь явную реализацию 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' или 'System.Collections.IStructuralEquatable'</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsObjEquals">
        <source>A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' or 'System.Collections.IStructuralEquatable'</source>
        <target state="translated">Тип с атрибутом 'CustomEquality' должен иметь явную реализацию с одним из выражений 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' или 'System.Collections.IStructuralEquatable'</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomCompareNeedsIComp">
        <source>A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'</source>
        <target state="translated">Тип с атрибутом "CustomComparison" должен как минимум содержать явную реализацию интерфейса "System.IComparable" или "System.Collections.IStructuralComparable"</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoEqNeedsNoObjEquals">
        <source>A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">Тип с атрибутом "NoEquality" обычно не должен содержать явную реализацию метода "Object.Equals(obj)". Если эта операция выполняется в целях обеспечения совместимости, отключите это предупреждение</target>
        <note />
      </trans-unit>
      <trans-unit id="augNoCompCantImpIComp">
        <source>A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable&lt;_&gt;' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes</source>
        <target state="translated">Тип с атрибутом 'NoComparison' обычно не должен иметь явной реализации 'System.IComparable', 'System.IComparable&lt;_&gt;' или 'System.Collections.IStructuralComparable'. Отключите это предупреждение, если это сделано намеренно для целей взаимодействия</target>
        <note />
      </trans-unit>
      <trans-unit id="augCustomEqNeedsNoCompOrCustomComp">
        <source>The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes</source>
        <target state="translated">Атрибут "CustomEquality" необходимо использовать в сочетании с атрибутами "NoComparison" или "CustomComparison"</target>
        <note />
      </trans-unit>
      <trans-unit id="forPositionalSpecifiersNotPermitted">
        <source>Positional specifiers are not permitted in format strings</source>
        <target state="translated">Использование позиционных спецификаторов в строках формата не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="forMissingFormatSpecifier">
        <source>Missing format specifier</source>
        <target state="translated">Отсутствует указатель формата</target>
        <note />
      </trans-unit>
      <trans-unit id="forFlagSetTwice">
        <source>'{0}' flag set twice</source>
        <target state="translated">флаг "{0}" установлен дважды</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrefixFlagSpacePlusSetTwice">
        <source>Prefix flag (' ' or '+') set twice</source>
        <target state="translated">Флаг префикса (" " или "+") установлен дважды</target>
        <note />
      </trans-unit>
      <trans-unit id="forHashSpecifierIsInvalid">
        <source>The # formatting modifier is invalid in F#</source>
        <target state="translated">Модификатор форматирования # в F# недопустим.</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadPrecision">
        <source>Bad precision in format specifier</source>
        <target state="translated">Недопустимая точность спецификатора формата</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadWidth">
        <source>Bad width in format specifier</source>
        <target state="translated">Недопустимая ширина спецификатора формата</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportZeroFlag">
        <source>'{0}' format does not support '0' flag</source>
        <target state="translated">{0} не поддерживает флаг "0"</target>
        <note />
      </trans-unit>
      <trans-unit id="forPrecisionMissingAfterDot">
        <source>Precision missing after the '.'</source>
        <target state="translated">Отсутствует точность после "."</target>
        <note />
      </trans-unit>
      <trans-unit id="forFormatDoesntSupportPrecision">
        <source>'{0}' format does not support precision</source>
        <target state="translated">формат "{0}" не поддерживает точность</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifier">
        <source>Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Недопустимый спецификатор формата (после l или L): требуется ld,li,lo,lu,lx или lX. В коде F# можно использовать %d, %x, %o или %u, которые перегружаются и поддерживают работу со всеми базовыми целочисленными типами.</target>
        <note />
      </trans-unit>
      <trans-unit id="forLIsUnnecessary">
        <source>The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Использовать "l" или "L" в этом спецификаторе формата необязательно. В коде F# можно использовать %d, %x, %o или %u, которые перегружаются и поддерживают работу со всеми базовыми целочисленными типами.</target>
        <note />
      </trans-unit>
      <trans-unit id="forHIsUnnecessary">
        <source>The 'h' or 'H' in this format specifier is unnecessary. You can use %d, %x, %o or %u instead, which are overloaded to work with all basic integer types.</source>
        <target state="translated">Использовать "h" или "H" в этом описателе формата необязательно. Вместо них можно использовать %d, %x, %o или %u, которые перегружаются и поддерживают работу со всеми базовыми целочисленными типами.</target>
        <note />
      </trans-unit>
      <trans-unit id="forDoesNotSupportPrefixFlag">
        <source>'{0}' does not support prefix '{1}' flag</source>
        <target state="translated">"{0}" не поддерживает флаг префикса "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="forBadFormatSpecifierGeneral">
        <source>Bad format specifier: '{0}'</source>
        <target state="translated">Неправильный спецификатор формата: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="elSysEnvExitDidntExit">
        <source>System.Environment.Exit did not exit</source>
        <target state="translated">System.Environment.Exit не был выполнен</target>
        <note />
      </trans-unit>
      <trans-unit id="elDeprecatedOperator">
        <source>The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined</source>
        <target state="translated">Этот оператор обрабатывается непосредственно компилятором F#, в связи с чем его значение не может быть повторно определено</target>
        <note />
      </trans-unit>
      <trans-unit id="chkProtectedOrBaseCalled">
        <source>A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope.</source>
        <target state="translated">Вызывается защищенный элемент, или используется класс "base". Это допускается только в прямых реализациях элементов, поскольку при этом возможен выход за пределы области видимости объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkByrefUsedInInvalidWay">
        <source>The byref-typed variable '{0}' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.</source>
        <target state="translated">Недопустимый способ использования переменной "{0}" типа byref. Переменные типа byref нельзя зафиксировать с помощью замкнутых выражений или передать во внутренние функции.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkBaseUsedInInvalidWay">
        <source>The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.</source>
        <target state="translated">Недопустимый способ использования ключевого слова "base". Вызовы базового (base) класса не могут использоваться в замкнутых выражениях. Для вызовов базового класса рекомендуется использовать закрытый элемент.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkVariableUsedInInvalidWay">
        <source>The variable '{0}' is used in an invalid way</source>
        <target state="translated">Недопустимый способ использования переменной "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTypeLessAccessibleThanType">
        <source>The type '{0}' is less accessible than the value, member or type '{1}' it is used in.</source>
        <target state="translated">Тип "{0}" является менее доступным, чем значение, элемент или тип "{1}", в которых он используется.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSystemVoidOnlyInTypeof">
        <source>'System.Void' can only be used as 'typeof&lt;System.Void&gt;' in F#</source>
        <target state="translated">'System.Void' может использоваться только как 'typeof&lt;System.Void&gt;' в F#</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorUseOfByref">
        <source>A type instantiation involves a byref type. This is not permitted by the rules of Common IL.</source>
        <target state="translated">Создание экземпляра типа с использованием типа byref. В правилах общего промежуточного языка это не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkErrorContainsCallToRethrow">
        <source>Calls to 'reraise' may only occur directly in a handler of a try-with</source>
        <target state="translated">Вызовы "reraise" могут выполняться только непосредственно из обработчика блока try-with</target>
        <note />
      </trans-unit>
      <trans-unit id="chkSplicingOnlyInQuotations">
        <source>Expression-splicing operators may only be used within quotations</source>
        <target state="translated">Операторы expression-splicing можно использовать только в кавычках</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassSplicing">
        <source>First-class uses of the expression-splicing operator are not permitted</source>
        <target state="translated">Использование операторов expression-splicing в первом классе не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassAddressOf">
        <source>First-class uses of the address-of operators are not permitted</source>
        <target state="translated">Использование операторов address-of в первом классе не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassRethrow">
        <source>First-class uses of the 'reraise' function is not permitted</source>
        <target state="translated">Использование функции "reraise" в первом классе не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAtThisPoint">
        <source>The byref typed value '{0}' cannot be used at this point</source>
        <target state="translated">В этой точке нельзя использовать значение типа byref "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="chkLimitationsOfBaseKeyword">
        <source>'base' values may only be used to make direct calls to the base implementations of overridden members</source>
        <target state="translated">Значения "base" можно использовать только для выполнения прямых вызовов реализаций класса base для переопределенных элементов</target>
        <note />
      </trans-unit>
      <trans-unit id="chkObjCtorsCantUseExceptionHandling">
        <source>Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.</source>
        <target state="translated">В конструкторе объекта нельзя прямо использовать блоки try/with и try/finally до инициализации объекта. К таким вариантам использования также относятся и конструкции вида "for x in ...", применение которых может привести к использованию указанных конструкций. Это ограничение связано с требованиями общего промежуточного языка.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfAtThisPoint">
        <source>The address of the variable '{0}' cannot be used at this point</source>
        <target state="translated">В этой точке нельзя использовать адрес переменной "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressStaticFieldAtThisPoint">
        <source>The address of the static field '{0}' cannot be used at this point</source>
        <target state="translated">В этой точке нельзя использовать адрес статического поля "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressFieldAtThisPoint">
        <source>The address of the field '{0}' cannot be used at this point</source>
        <target state="translated">В этой точке нельзя использовать адрес поля "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoAddressOfArrayElementAtThisPoint">
        <source>The address of an array element cannot be used at this point</source>
        <target state="translated">В этой точке нельзя использовать адрес элемента массива</target>
        <note />
      </trans-unit>
      <trans-unit id="chkFirstClassFuncNoByref">
        <source>The type of a first-class function cannot contain byrefs</source>
        <target state="translated">Тип функции первого класса не может содержать параметры типа byref</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReturnTypeNoByref">
        <source>A method return type would contain byrefs which is not permitted</source>
        <target state="translated">Тип возвращаемого значения метода будет содержать параметры типа byref, что не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidCustAttrVal">
        <source>Invalid custom attribute value (not a constant or literal)</source>
        <target state="translated">Недопустимое значение пользовательского атрибута (не является константой или литералом)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkAttrHasAllowMultiFalse">
        <source>The attribute type '{0}' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element.</source>
        <target state="translated">Тип атрибута "{0}" имеет значение "AllowMultiple=false". Нельзя присоединить несколько экземпляров этого атрибута к одному элементу языка.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to its definition at or near '{2}'. This is an invalid forward reference.</source>
        <target state="translated">Недопустимый способ использования элемента "{0}". Использование "{1}" выведено до его определения в строке "{2}" или близлежащих строках. Недопустимая опережающая ссылка.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAsTopValue">
        <source>A byref typed value would be stored here. Top-level let-bound byref values are not permitted.</source>
        <target state="translated">Здесь будет храниться значение типа byref. Использование значений верхнего уровня типа byref с привязкой let не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkReflectedDefCantSplice">
        <source>[&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">В условиях [&lt;ReflectedDefinition&gt;] не может использоваться оператор объединения префикса '%'</target>
        <note />
      </trans-unit>
      <trans-unit id="chkEntryPointUsage">
        <source>A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence.</source>
        <target state="translated">Функция, помеченная атрибутом "EntryPointAttribute", должна быть последним объявлением в последнем файле последовательности компиляции.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseCompiledForm">
        <source>compiled form of the union case</source>
        <target state="translated">откомпилированная форма ветви объединения</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnionCaseDefaultAugmentation">
        <source>default augmentation of the union case</source>
        <target state="translated">приращение по умолчанию для ветви объединения</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameMethod">
        <source>The property '{0}' has the same name as a method in type '{1}'.</source>
        <target state="translated">Имя свойства "{0}" аналогично имени метода в типе "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterSetterDoNotMatchAbstract">
        <source>The property '{0}' of type '{1}' has a getter and a setter that do not match. If one is abstract then the other must be as well.</source>
        <target state="translated">Свойство "{0}" типа "{1}" содержит несовпадающие методы получения и задания. Если один из этих методов является абстрактным, второй также должен быть абстрактным.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkPropertySameNameIndexer">
        <source>The property '{0}' has the same name as another property in type '{1}', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.</source>
        <target state="translated">Имена свойства "{0}" и другого свойства в типе "{1}" совпадают, но только одно из этих свойств принимает аргументы индексатора. Возможно, в одном из свойств отсутствует аргумент индексатора.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCantStoreByrefValue">
        <source>A type would store a byref typed value. This is not permitted by Common IL.</source>
        <target state="translated">Тип обычно используется для хранения значения типа byref. В общем промежуточном языке это не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethod">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}'.</source>
        <target state="translated">Повторяющийся метод. Имя и сигнатура метода "{0}" аналогичны другому методу в типе "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodWithSuffix">
        <source>Duplicate method. The method '{0}' has the same name and signature as another method in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Повторяющийся метод. Имя и сигнатура метода "{0}" аналогичны другому методу в типе "{1}" после удаления кортежей, функций, единиц измерения и предоставляемых типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodCurried">
        <source>The method '{0}' has curried arguments but has the same name as another method in type '{1}'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.</source>
        <target state="translated">Метод "{0}" содержит каррированные аргументы, но его имя и сигнатура аналогичны другому методу в типе "{1}". Перегрузка методов с каррированными аргументами не допускается. Рекомендуется использовать метод, принимающий аргументы в форме кортежа.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkCurriedMethodsCantHaveOutParams">
        <source>Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments</source>
        <target state="translated">В методах с каррированными аргументами не допускается объявление аргументов "out", "ParamArray", "optional", "ReflectedDefinition", "byref", "CallerLineNumber", "CallerMemberName" или "CallerFilePath"</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateProperty">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}'.</source>
        <target state="translated">Повторяющееся свойство. Имя и сигнатура свойства "{0}" аналогичны другому свойству в типе "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicatePropertyWithSuffix">
        <source>Duplicate property. The property '{0}' has the same name and signature as another property in type '{1}' once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Повторяющееся свойство. Имя и сигнатура свойства "{0}" аналогичны другому свойству в типе "{1}" после удаления кортежей, функций, единиц измерения и предоставляемых типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedType">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type.</source>
        <target state="translated">Повторяющийся метод. Имя и сигнатура абстрактного метода "{0}" аналогичны абстрактному методу унаследованного типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkDuplicateMethodInheritedTypeWithSuffix">
        <source>Duplicate method. The abstract method '{0}' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.</source>
        <target state="translated">Повторяющийся метод. Имя и сигнатура абстрактного метода "{0}" аналогичны абстрактному методу унаследованного типа после удаления кортежей, функций, единиц измерения и предоставляемых типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkMultipleGenericInterfaceInstantiations">
        <source>This type implements the same interface at different generic instantiations '{0}' and '{1}'. This is not permitted in this version of F#.</source>
        <target state="translated">В этом типе реализуется один и тот же интерфейс в различных универсальных установках "{0}" и "{1}". В данной версии F# это не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkValueWithDefaultValueMustHaveDefaultValue">
        <source>The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check</source>
        <target state="translated">Тип поля, использующего атрибут "DefaultValue", должен поддерживать инициализацию по умолчанию, т. е. должен содержать собственное значение "null" или являться типом структуры, все поля которого поддерживают инициализацию по умолчанию. Чтобы отключить эту проверку, используйте "DefaultValue(false)"</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefInTypeAbbrev">
        <source>The type abbreviation contains byrefs. This is not permitted by F#.</source>
        <target state="translated">Сокращенная форма типа содержит параметры типа byref. В языке F# это не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefBoundVarUsedInSplice">
        <source>The variable '{0}' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.</source>
        <target state="translated">Переменная "{0}" заключена в кавычки, однако используется в составе соединенного выражения. Это не допускается, поскольку может привести к выходу за пределы области видимости.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericExprs">
        <source>Quotations cannot contain uses of generic expressions</source>
        <target state="translated">В кавычки нельзя заключать универсальные выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainGenericFunctions">
        <source>Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.</source>
        <target state="translated">В кавычки нельзя заключать определения выведенных функций или функций, объявленных как универсальные. Рекомендуется добавить ограничения типа, преобразующие это выражение в допустимое выражение с кавычками.</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainObjExprs">
        <source>Quotations cannot contain object expressions</source>
        <target state="translated">Цитаты не могут содержать выражения объектов</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainAddressOf">
        <source>Quotations cannot contain expressions that take the address of a field</source>
        <target state="translated">В кавычки нельзя заключать выражения, используемые для получения адреса поля</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainStaticFieldRef">
        <source>Quotations cannot contain expressions that fetch static fields</source>
        <target state="translated">Цитаты не могут содержать выражения, извлекающие статические поля</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainInlineIL">
        <source>Quotations cannot contain inline assembly code or pattern matching on arrays</source>
        <target state="translated">Цитаты не могут содержать встроенный код сборки или сопоставление по шаблону для массивов</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainDescendingForLoops">
        <source>Quotations cannot contain descending for loops</source>
        <target state="translated">В кавычки нельзя заключать нисходящие циклы for</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantFetchUnionIndexes">
        <source>Quotations cannot contain expressions that fetch union case indexes</source>
        <target state="translated">В кавычки нельзя заключать выражения, извлекающие индексы вариантов объединения</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetUnionFields">
        <source>Quotations cannot contain expressions that set union case fields</source>
        <target state="translated">В кавычки нельзя заключать выражения, задающие поля вариантов объединения</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantSetExceptionFields">
        <source>Quotations cannot contain expressions that set fields in exception values</source>
        <target state="translated">В кавычки нельзя заключать выражения, задающие поля в значениях исключений</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantRequireByref">
        <source>Quotations cannot contain expressions that require byref pointers</source>
        <target state="translated">В кавычки нельзя заключать выражения, требующие использования указателей byref</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantCallTraitMembers">
        <source>Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call</source>
        <target state="translated">В кавычки нельзя заключать выражения, выполняющие вызовы ограничения элементов или использующие операторы, которые явным образом разрешаются в вызовы элементов ограничения</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisConstant">
        <source>Quotations cannot contain this kind of constant</source>
        <target state="translated">Цитаты не могут содержать эту разновидность константы</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisPatternMatch">
        <source>Quotations cannot contain this kind of pattern match</source>
        <target state="translated">Цитаты не могут содержать эту разновидность сопоставления шаблону</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainArrayPatternMatching">
        <source>Quotations cannot contain array pattern matching</source>
        <target state="translated">В кавычки нельзя заключать сопоставления шаблонов массивов</target>
        <note />
      </trans-unit>
      <trans-unit id="crefQuotationsCantContainThisType">
        <source>Quotations cannot contain this kind of type</source>
        <target state="translated">Цитаты не могут содержать эту разновидность типа</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeCannotBeResolvedAtCompileTime">
        <source>The declared type parameter '{0}' cannot be used here since the type parameter cannot be resolved at compile time</source>
        <target state="translated">Не удается использовать объявленный параметр типа "{0}", поскольку не удается разрешить его во время выполнения</target>
        <note />
      </trans-unit>
      <trans-unit id="csCodeLessGeneric">
        <source>This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'.</source>
        <target state="translated">Этот код является менее универсальным, чем указано в соответствующих аннотациях. Значение единицы измерения, заданной с помощью знака "_", определено как "1" (безразмерная). Рекомендуется сделать код универсальным или удалить знак "_".</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInferenceMaxDepth">
        <source>Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.</source>
        <target state="translated">Слишком сложная проблема определения типа (достигнута максимальная глубина итераций). Рекомендуется добавить дополнительные аннотации типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectedArguments">
        <source>Expected arguments to an instance member</source>
        <target state="translated">Требуются аргументы элемента экземпляра</target>
        <note />
      </trans-unit>
      <trans-unit id="csIndexArgumentMismatch">
        <source>This indexer expects {0} arguments but is here given {1}</source>
        <target state="translated">Для индексатора требуется аргумент {0}, однако задан аргумент {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenFunction">
        <source>Expecting a type supporting the operator '{0}' but given a function type. You may be missing an argument to a function.</source>
        <target state="translated">Требуется тип, поддерживающий оператор "{0}", однако задан тип функции. Возможно, отсутствует аргумент функции.</target>
        <note />
      </trans-unit>
      <trans-unit id="csExpectTypeWithOperatorButGivenTuple">
        <source>Expecting a type supporting the operator '{0}' but given a tuple type</source>
        <target state="translated">Ожидался тип, поддерживающий оператор "{0}", однако указан кортежный тип</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperator">
        <source>None of the types '{0}' support the operator '{1}'</source>
        <target state="translated">Ни один из типов "{0}" не поддерживает оператор "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperator">
        <source>The type '{0}' does not support the operator '{1}'</source>
        <target state="translated">Тип "{0}" не поддерживает оператор "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypesDoNotSupportOperatorNullable">
        <source>None of the types '{0}' support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Ни один из типов "{0}" не поддерживает оператор "{1}". Попробуйте открыть модуль Microsoft.FSharp.Linq.NullableOperators.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportOperatorNullable">
        <source>The type '{0}' does not support the operator '{1}'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Тип "{0}" не поддерживает оператор "{1}". Попробуйте открыть модуль Microsoft.FSharp.Linq.NullableOperators.</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportConversion">
        <source>The type '{0}' does not support a conversion to the type '{1}'</source>
        <target state="translated">Тип "{0}" не поддерживает преобразование в тип "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is static</source>
        <target state="translated">Тип "{0}" содержит метод "{1}" (полное имя "{2}"), являющийся статическим</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodFoundButIsNotStatic">
        <source>The type '{0}' has a method '{1}' (full name '{2}'), but the method is not static</source>
        <target state="translated">Тип "{0}" содержит метод "{1}" (полное имя "{2}"), не являющийся статическим</target>
        <note />
      </trans-unit>
      <trans-unit id="csStructConstraintInconsistent">
        <source>The constraints 'struct' and 'not struct' are inconsistent</source>
        <target state="translated">Противоречивые ограничения "struct" и "not struct"</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value</source>
        <target state="translated">Тип "{0}" не содержит собственное значение "null"</target>
        <note />
      </trans-unit>
      <trans-unit id="csNullableTypeDoesNotHaveNull">
        <source>The type '{0}' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'.</source>
        <target state="translated">NULL не является собственным значением типа "{0}". Чтобы создать значение NULL для типа, допускающего это значение, используйте структуру System.Nullable().</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison1">
        <source>The type '{0}' does not support the 'comparison' constraint because it has the 'NoComparison' attribute</source>
        <target state="translated">Тип "{0}" не поддерживает ограничение "comparison", поскольку содержит атрибут "NoComparison"</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison2">
        <source>The type '{0}' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface</source>
        <target state="translated">Тип "{0}" не поддерживает ограничение "comparison". Например, он не поддерживает интерфейс "System.IComparable"</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportComparison3">
        <source>The type '{0}' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison</source>
        <target state="translated">Тип "{0}" не поддерживает ограничение "comparison", поскольку он является записью, объединением или структурой с одним или несколькими типами структурных элементов, которые не поддерживают ограничение "comparison". Исключите ограничение "comparison" из типа или добавьте в него атрибут "StructuralComparison", определяющий типы полей, которые не поддерживают ограничение "comparison"</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality1">
        <source>The type '{0}' does not support the 'equality' constraint because it has the 'NoEquality' attribute</source>
        <target state="translated">Тип "{0}" не поддерживает ограничение "equality", поскольку содержит атрибут "NoEquality"</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality2">
        <source>The type '{0}' does not support the 'equality' constraint because it is a function type</source>
        <target state="translated">Тип "{0}" не поддерживает ограничение "equality", поскольку он является типом функции</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeDoesNotSupportEquality3">
        <source>The type '{0}' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality</source>
        <target state="translated">Тип "{0}" не поддерживает ограничение "equality", поскольку он является записью, объединением или структурой с одним или несколькими типами структурных элементов, которые не поддерживают ограничение "equality". Исключите ограничение "equality" из типа или добавьте в него атрибут "StructuralEquality", определяющий типы полей, которые не поддерживают ограничение "equality"</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotEnumType">
        <source>The type '{0}' is not a CLI enum type</source>
        <target state="translated">Тип "{0}" не является перечисляемым типом CLI</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeHasNonStandardDelegateType">
        <source>The type '{0}' has a non-standard delegate type</source>
        <target state="translated">Тип "{0}" имеет нестандартный тип делегата</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeIsNotDelegateType">
        <source>The type '{0}' is not a CLI delegate type</source>
        <target state="translated">Тип "{0}" не является делегатным типом CLI</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeParameterCannotBeNullable">
        <source>This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values.</source>
        <target state="translated">Не удается создать экземпляр "Nullable" для этого параметра типа. Это ограничение позволяет отличить значение "null" в некоторых языках CLI от используемых совместно с ним значений "Nullable".</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresStructType">
        <source>A generic construct requires that the type '{0}' is a CLI or F# struct type</source>
        <target state="translated">В универсальной конструкции требуется использовать тип "{0}", являющийся типом структуры CLI или F#</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresUnmanagedType">
        <source>A generic construct requires that the type '{0}' is an unmanaged type</source>
        <target state="translated">В универсальной конструкции тип "{0}" должен быть неуправляемым</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeNotCompatibleBecauseOfPrintf">
        <source>The type '{0}' is not compatible with any of the types {1}, arising from the use of a printf-style format string</source>
        <target state="translated">Тип "{0}" несовместим с любыми типами {1}, возникающими при использовании строки формата printf-style</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresReferenceSemantics">
        <source>A generic construct requires that the type '{0}' have reference semantics, but it does not, i.e. it is a struct</source>
        <target state="translated">В универсальной конструкции требуется использовать тип "{0}", содержащий семантику ссылки, однако заданный тип эту семантику не содержит, т. е. является структурой</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresNonAbstract">
        <source>A generic construct requires that the type '{0}' be non-abstract</source>
        <target state="translated">В универсальной конструкции требуется использовать неабстрактный тип "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="csGenericConstructRequiresPublicDefaultConstructor">
        <source>A generic construct requires that the type '{0}' have a public default constructor</source>
        <target state="translated">В универсальной конструкции требуется использовать тип "{0}", содержащий открытый конструктор по умолчанию</target>
        <note />
      </trans-unit>
      <trans-unit id="csTypeInstantiationLengthMismatch">
        <source>Type instantiation length mismatch</source>
        <target state="translated">Несоответствие длины создаваемого экземпляра типа</target>
        <note />
      </trans-unit>
      <trans-unit id="csOptionalArgumentNotPermittedHere">
        <source>Optional arguments not permitted here</source>
        <target state="translated">Использование дополнительных аргументов не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotStatic">
        <source>{0} is not a static member</source>
        <target state="translated">{0} не является статическим элементом</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotInstance">
        <source>{0} is not an instance member</source>
        <target state="translated">{0} не является экземплярным элементом</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentLengthMismatch">
        <source>Argument length mismatch</source>
        <target state="translated">Несоответствие длин аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="csArgumentTypesDoNotMatch">
        <source>The argument types don't match</source>
        <target state="translated">Типы аргументов не совпадают</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodExpectsParams">
        <source>This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument</source>
        <target state="translated">В этой позиции метода требуется параметр CLI "params". В таких языках, как C#, параметр "params" используется для передачи переменного числа аргументов в метод. Рекомендуется передавать в качестве аргумента массив</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible">
        <source>The member or object constructor '{0}' is not {1}</source>
        <target state="translated">Конструктор элемента или объекта "{0}" не является {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberIsNotAccessible2">
        <source>The member or object constructor '{0}' is not {1}. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.</source>
        <target state="translated">Конструктор элемента или объекта "{0}" не является {1}. Закрытые элементы доступны только внутри типа, в котором они объявляются. Защищенные типы доступны только из расширяющего типа и недоступны из внутренних лямбда-выражений.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAStaticMethod">
        <source>{0} is not a static method</source>
        <target state="translated">{0} не является статическим методом</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsNotAnInstanceMethod">
        <source>{0} is not an instance method</source>
        <target state="translated">{0} не является экземплярным методом</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberHasNoArgumentOrReturnProperty">
        <source>The member or object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">Конструктор элемента или объекта "{0}" не содержит аргумент или задаваемое возвращаемое свойство "{1}". {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorHasNoArgumentOrReturnProperty">
        <source>The object constructor '{0}' has no argument or settable return property '{1}'. {2}.</source>
        <target state="translated">Конструктор объектов "{0}" не содержит аргумент или задаваемое возвращаемое свойство "{1}". {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csRequiredSignatureIs">
        <source>The required signature is {0}</source>
        <target state="translated">Необходимая сигнатура: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'.</source>
        <target state="translated">Для конструктора элемента или объекта "{0}" требуется следующее число аргументов: {1}. Необходимая сигнатура: "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch2">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'.</source>
        <target state="translated">Для конструктора элемента или объекта "{0}" требуется следующее число дополнительных аргументов: {1}. Необходимая сигнатура: "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch3">
        <source>The member or object constructor '{0}' requires {1} argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">Для конструктора элемента или объекта "{0}" требуется следующее число аргументов: {1}. Необходимая сигнатура: "{2}". Некоторые имена отсутствующих аргументов: {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatch4">
        <source>The member or object constructor '{0}' requires {1} additional argument(s). The required signature is '{2}'. Some names for missing arguments are {3}.</source>
        <target state="translated">Для конструктора элемента или объекта "{0}" требуется следующее число дополнительных аргументов: {1}. Необходимая сигнатура: "{2}". Некоторые имена отсутствующих аргументов: {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityNamed">
        <source>The member or object constructor '{0}' requires {1} argument(s) but is here given {2} unnamed and {3} named argument(s). The required signature is '{4}'.</source>
        <target state="translated">Для конструктора элемента или объекта "{0}" требуется следующее число аргументов: {1}, однако здесь задано следующее число аргументов: неименованные ({2}) и именованные ({3}). Необходимая сигнатура: "{4}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArity">
        <source>The member or object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Для конструктора элемента или объекта "{0}" требуется следующее число аргументов: {1}, однако здесь задано следующее число аргументов: {2}. Необходимая сигнатура: "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArity">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Конструктор объектов "{0}" принимает определенное число аргументов (а именно: {1}), но здесь ему предоставлено {2}. Требуется сигнатура "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csCtorSignatureMismatchArityProp">
        <source>The object constructor '{0}' takes {1} argument(s) but is here given {2}. The required signature is '{3}'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',').</source>
        <target state="translated">Конструктор объектов "{0}" принимает определенное число аргументов (а именно: {1}), но здесь ему предоставлено {2}. Требуется сигнатура "{3}". Если некоторые аргументы предполагают назначение значений свойствам, рекомендуется отделить их запятой (",").</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberSignatureMismatchArityType">
        <source>The member or object constructor '{0}' takes {1} type argument(s) but is here given {2}. The required signature is '{3}'.</source>
        <target state="translated">Для конструктора элемента или объекта "{0}" требуется следующее число аргументов типа: {1}, однако здесь задано следующее число аргументов: {2}. Необходимая сигнатура: "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberNotAccessible">
        <source>A member or object constructor '{0}' taking {1} arguments is not accessible from this code location. All accessible versions of method '{2}' take {3} arguments.</source>
        <target state="translated">Конструктор элементов или объектов "{0}", принимающий следующее число аргументов: {1}, недоступен из этой точки кода. Все доступные версии метода "{2}" принимают следующее число аргументов: {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csIncorrectGenericInstantiation">
        <source>Incorrect generic instantiation. No {0} member named '{1}' takes {2} generic arguments.</source>
        <target state="translated">Недопустимое создание универсального экземпляра. Отсутствует элемент "{0}" с именем "{1}", принимающий универсальные аргументы {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMemberOverloadArityMismatch">
        <source>The member or object constructor '{0}' does not take {1} argument(s). An overload was found taking {2} arguments.</source>
        <target state="translated">Конструктор элемента или объекта "{0}" не принимает следующее число аргументов: {1}. Обнаружена перегрузка, принимающая следующее число аргументов: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments</source>
        <target state="translated">Отсутствуют конструкторы элемента или объекта {0} с именем "{1}", принимающие следующее число аргументов: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments2">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. Note the call to this member also provides {3} named arguments.</source>
        <target state="translated">Отсутствуют конструкторы элемента или объекта {0} с именем "{1}", принимающие следующее число аргументов: {2}. Обратите внимание, что при вызове этого члена также предоставляется следующее число именованных аргументов: {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoMemberTakesTheseArguments3">
        <source>No {0} member or object constructor named '{1}' takes {2} arguments. The named argument '{3}' doesn't correspond to any argument or settable return property for any overload.</source>
        <target state="translated">Отсутствуют конструкторы элемента или объекта {0} с именем "{1}", принимающие следующее число аргументов: {2}. Именованный аргумент "{3}" не соответствует какому-либо аргументу или задаваемому возвращаемому свойству для какой-либо перегрузки.</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodNotFound">
        <source>Method or object constructor '{0}' not found</source>
        <target state="translated">Не найден конструктор метода или объекта "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="csNoOverloadsFound">
        <source>No overloads match for method '{0}'.</source>
        <target state="translated">Отсутствуют перегрузки метода "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="csMethodIsOverloaded">
        <source>A unique overload for method '{0}' could not be determined based on type information prior to this program point. A type annotation may be needed.</source>
        <target state="translated">Невозможно определить уникальную перегрузку метода "{0}" на основе сведений о типе, заданных до данной точки программы. Возможно, требуется аннотация типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="csCandidates">
        <source>Candidates:\n{0}</source>
        <target state="translated">Кандидаты:\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="parsDoCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on 'do' bindings, but '{0}' was given.</source>
        <target state="translated">Использование модификаторов доступности в привязках "do" не допускается, но указан "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInHashIf">
        <source>End of file in #if section begun at or after here</source>
        <target state="translated">Конец файла в директиве #if начался в этой позиции или после нее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInString">
        <source>End of file in string begun at or before here</source>
        <target state="translated">Конец файла в строке начался в этой позиции или до нее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimString">
        <source>End of file in verbatim string begun at or before here</source>
        <target state="translated">Конец файла в строке verbatim начался в этой позиции или до нее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInComment">
        <source>End of file in comment begun at or before here</source>
        <target state="translated">Конец файла в комментарии начался в этой позиции или до нее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInStringInComment">
        <source>End of file in string embedded in comment begun at or before here</source>
        <target state="translated">Конец файла во встроенной в комментарий строке начался в этой позиции или до нее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInVerbatimStringInComment">
        <source>End of file in verbatim string embedded in comment begun at or before here</source>
        <target state="translated">Конец файла во встроенной в комментарий строке verbatim начался в этой позиции или до нее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInIfOcaml">
        <source>End of file in IF-OCAML section begun at or before here</source>
        <target state="translated">Конец файла в разделе IF-OCAML начался в этой позиции или до нее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInDirective">
        <source>End of file in directive begun at or before here</source>
        <target state="translated">Конец файла в директиве начался в этой позиции или до нее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoHashEndIfFound">
        <source>No #endif found for #if or #else</source>
        <target state="translated">Отсутствует директива #endif для директивы #if или #else</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIgnored">
        <source>Attributes have been ignored in this construct</source>
        <target state="translated">Атрибуты в этой конструкции пропущены</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInImplicitClassConstructors">
        <source>'use' bindings are not permitted in primary constructors</source>
        <target state="translated">Использование привязок use в первичных конструкторах не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUseBindingsIllegalInModules">
        <source>'use' bindings are not permitted in modules and are treated as 'let' bindings</source>
        <target state="translated">привязки "use" недопустимы в модулях и обрабатываются как привязки "let"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIntegerForLoopRequiresSimpleIdentifier">
        <source>An integer for loop must use a simple identifier</source>
        <target state="translated">В целочисленном цикле for необходимо использовать простой идентификатор</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyOneWithAugmentationAllowed">
        <source>At most one 'with' augmentation is permitted</source>
        <target state="translated">Допускается использование не более одного приращения "with"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSemicolon">
        <source>A semicolon is not expected at this point</source>
        <target state="translated">В этой точке кода не требуется точка с запятой</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFile">
        <source>Unexpected end of input</source>
        <target state="translated">Непредвиденный конец входных данных</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedVisibilityDeclaration">
        <source>Accessibility modifiers are not permitted here, but '{0}' was given.</source>
        <target state="translated">Использование модификаторов доступности не допускается, но указан "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyHashDirectivesAllowed">
        <source>Only '#' compiler directives may occur prior to the first 'namespace' declaration</source>
        <target state="translated">Перед первым объявлением "namespace" можно указывать только директивы компилятора "#"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityDeclarationsShouldComePriorToIdentifier">
        <source>Accessibility modifiers should come immediately prior to the identifier naming a construct</source>
        <target state="translated">Модификаторы доступности следует указывать непосредственно перед идентификатором, определяющим имя конструкции</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNamespaceOrModuleNotBoth">
        <source>Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'</source>
        <target state="translated">В начале файла необходимо указывать либо пространство имен либо объявление модуля, например "namespace SomeNamespace.SubNamespace" или "module SomeNamespace.SomeModule". Чтобы определить модуль внутри пространства имен, используйте синтаксис "module SomeModule = ..."</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleAbbreviationMustBeSimpleName">
        <source>A module abbreviation must be a simple name, not a path</source>
        <target state="translated">Сокращенная форма модуля может быть простым именем, но не путем</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviation">
        <source>Ignoring attributes on module abbreviation</source>
        <target state="translated">Пропуск атрибутов в сокращенной форме модуля</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">Атрибут доступности "{0}" запрещен в сокращенной форме модуля. В сокращенных формах модуля всегда используются закрытые атрибуты.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate">
        <source>The '{0}' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.</source>
        <target state="translated">Атрибут видимости "{0}" запрещен в сокращенной форме модуля. В сокращенных формах модуля всегда используются закрытые атрибуты.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnClosedBlockInHashLight">
        <source>Unclosed block</source>
        <target state="translated">Незакрытый блок</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBeginOrStruct">
        <source>Unmatched 'begin' or 'struct'</source>
        <target state="translated">Несогласованный "begin" или "struct"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsModuleDefnMustBeSimpleName">
        <source>A module name must be a simple name, not a path</source>
        <target state="translated">Имя модуля может быть простым именем, но не путем</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEmptyModuleDefn">
        <source>Unexpected empty type moduleDefn list</source>
        <target state="translated">Недопустимый пустой список типа moduleDefn</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesMustComeBeforeVal">
        <source>Attributes should be placed before 'val'</source>
        <target state="translated">Атрибуты не должны располагаться перед выражением "val"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesAreNotPermittedOnInterfaceImplementations">
        <source>Attributes are not permitted on interface implementations</source>
        <target state="translated">Использование атрибутов в реализациях интерфейса не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxError">
        <source>Syntax error</source>
        <target state="translated">синтаксическая ошибка</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAugmentationsIllegalOnDelegateType">
        <source>Augmentations are not permitted on delegate type moduleDefns</source>
        <target state="translated">Использование приращений для типа делегата moduleDefns не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedClassInterfaceOrStruct">
        <source>Unmatched 'class', 'interface' or 'struct'</source>
        <target state="translated">Несогласованный "class", "interface" или "struct"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEmptyTypeDefinition">
        <source>A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'.</source>
        <target state="translated">В определении типа требуются один или несколько элементов или других объявлений. Если предполагается определение пустых класса, структуры или объединения, используйте выражения "type ... = class end", "interface end" или "struct end".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedWith">
        <source>Unmatched 'with' or badly formatted 'with' block</source>
        <target state="translated">Несоответствующий или неправильно отформатированный блок "with"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetOrSetRequired">
        <source>'get', 'set' or 'get,set' required</source>
        <target state="translated">Требуется "get", "set" и (или) "get,set"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsOnlyClassCanTakeValueArguments">
        <source>Only class types may take value arguments</source>
        <target state="translated">Только типы класса могут принимать аргументы "значение"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBegin">
        <source>Unmatched 'begin'</source>
        <target state="translated">Несогласованный "begin"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidDeclarationSyntax">
        <source>Invalid declaration syntax</source>
        <target state="translated">Недопустимый синтаксис объявления</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetAndOrSetRequired">
        <source>'get' and/or 'set' required</source>
        <target state="translated">Требуется "get" и (или) "set"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAnnotationsOnGetSet">
        <source>Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'</source>
        <target state="translated">Аннотации типов для методов получения или задания свойства необходимо указывать после выражений "get()" или "set(v)", например, "with get() : string = ..."</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterMustHaveAtLeastOneArgument">
        <source>A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'</source>
        <target state="translated">Свойство метода получения должно быть функцией, например, "get() = ..." или "get(index) = ..."</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultipleAccessibilitiesForGetSet">
        <source>Multiple accessibilities given for property getter or setter</source>
        <target state="translated">Задано несколько модификаторов доступности для метода получения или задания свойства</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetSyntax">
        <source>Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '</source>
        <target state="translated">Для определения методов присваивания свойств необходимо использовать синтаксис "set value = ", "set idx value = " или "set (idx1,...,idxN) value = ... '</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInterfacesHaveSameVisibilityAsEnclosingType">
        <source>Interfaces always have the same visibility as the enclosing type</source>
        <target state="translated">Видимость интерфейсов всегда соответствует видимости включающего их типа</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAccessibilityModsIllegalForAbstract">
        <source>Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.</source>
        <target state="translated">Использование модификаторов доступности для этого элемента не допускается. Видимость абстрактных слотов всегда соответствует видимости включающего их типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalOnInherit">
        <source>Attributes are not permitted on 'inherit' declarations</source>
        <target state="translated">Использование атрибутов в объявлениях "inherit" не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="parsVisibilityIllegalOnInherit">
        <source>Accessibility modifiers are not permitted on an 'inherits' declaration</source>
        <target state="translated">Использование модификаторов доступности в объявлении "inherits" не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInheritDeclarationsCannotHaveAsBindings">
        <source>'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding.</source>
        <target state="translated">Объявления "inherit" не могут содержать привязки "as". Для доступа к элементам базового класса при переопределении метода можно использовать синтаксис "base.SomeMember", где "base" -- это ключевое слово. Удалить эту привязку "as".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributesIllegalHere">
        <source>Attributes are not allowed here</source>
        <target state="translated">Использование атрибутов не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for type abbreviations</source>
        <target state="translated">Использование модификаторов доступности в этой позиции для сокращенных форм типов не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumTypesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted in this position for enum types</source>
        <target state="translated">Использование модификаторов доступности в этой позиции для перечисляемых типов не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAllEnumFieldsRequireValues">
        <source>All enum fields must be given values</source>
        <target state="translated">Всем перечисляемым полям необходимо присвоить значения</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInlineAssemblyCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on inline assembly code types</source>
        <target state="translated">Использование модификаторов доступности в типах встроенного кода сборки не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIdentifier">
        <source>Unexpected identifier: '{0}'</source>
        <target state="translated">Недопустимый идентификатор: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnionCasesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Использование модификаторов доступности в вариантах объединения не допускается. Чтобы обеспечить доступность всего представления, используйте синтаксис "type U = internal ..." или "type U = private ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEnumFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on enumeration fields</source>
        <target state="translated">Использование модификаторов доступности в полях перечисления не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="parsConsiderUsingSeparateRecordType">
        <source>Consider using a separate record type instead</source>
        <target state="translated">Вместо этого рекомендуется использовать отдельный тип записи</target>
        <note />
      </trans-unit>
      <trans-unit id="parsRecordFieldsCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation.</source>
        <target state="translated">Использование модификаторов доступности в полях записи не допускается. Чтобы обеспечить доступность всего представления, используйте синтаксис "type R = internal ..." или "type R = private ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsLetAndForNonRecBindings">
        <source>The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings</source>
        <target state="translated">Форма объявления "let ... and ..." для нерекурсивных привязок не используется в коде F#. Рекомендуется использовать последовательность привязок "let"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedParen">
        <source>Unmatched '('</source>
        <target state="translated">Несогласованный "("</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessivePatternsShouldBeSpacedOrTupled">
        <source>Successive patterns should be separated by spaces or tupled</source>
        <target state="translated">Последовательные шаблоны следует разделять пробелами или включать в кортежи</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoMatchingInForLet">
        <source>No matching 'in' found for this 'let'</source>
        <target state="translated">Отсутствует маркер "in", соответствующий этому маркеру "let"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorInReturnForLetIncorrectIndentation">
        <source>Error in the return expression for this 'let'. Possible incorrect indentation.</source>
        <target state="translated">Ошибка в выражении return для этого выражения "let". Возможно, неправильные отступы.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterLet">
        <source>The block following this '{0}' is unfinished. Every code block is an expression and must have a result. '{1}' cannot be the final code element in a block. Consider giving this block an explicit result.</source>
        <target state="translated">Блок, следующий за блоком "{0}", не закончен. Каждый блок кода является выражением и должен иметь результат. "{1}" не может быть заключительным элементом кода в блоке. Рекомендуется предоставить для этого блока явный результат.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIncompleteIf">
        <source>Incomplete conditional. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Неполное условие. Ожидается 'if &lt;expr&gt; then &lt;expr&gt;' или 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAssertIsNotFirstClassValue">
        <source>'assert' may not be used as a first class value. Use 'assert &lt;expr&gt;' instead.</source>
        <target state="translated">'assert' не может использоваться как значение первого класса. Используйте 'assert &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIdentifierExpected">
        <source>Identifier expected</source>
        <target state="translated">Требуется идентификатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInOrEqualExpected">
        <source>'in' or '=' expected</source>
        <target state="translated">Ожидалось "in" или "="</target>
        <note />
      </trans-unit>
      <trans-unit id="parsArrowUseIsLimited">
        <source>The use of '-&gt;' in sequence and computation expressions is limited to the form 'for pat in expr -&gt; expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions.</source>
        <target state="translated">Конструкция '-&gt;' в последовательностях и вычисляемых выражениях может использоваться только в виде 'for pat in expr -&gt; expr'. Используйте синтаксис 'for ... in ... do ... yield...' для создания элементов в более сложных выражениях последовательностей.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSuccessiveArgsShouldBeSpacedOrTupled">
        <source>Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized</source>
        <target state="translated">Последовательные аргументы следует разделять пробелами или включать в кортежи; аргументы, предполагающие применение функции или метода, следует заключать в круглые скобки</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracket">
        <source>Unmatched '['</source>
        <target state="translated">Несогласованный "["</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingQualificationAfterDot">
        <source>Missing qualification after '.'</source>
        <target state="translated">Отсутствует квалификация после "."</target>
        <note />
      </trans-unit>
      <trans-unit id="parsParenFormIsForML">
        <source>In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array</source>
        <target state="translated">В коде F# вы можете использовать выражения вида "expr.[expr]". Может потребоваться заметка с типом, чтобы указать, что первое выражение это массив</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuote">
        <source>Mismatched quotation, beginning with '{0}'</source>
        <target state="translated">Несоответствующие кавычки, начиная с "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatched">
        <source>Unmatched '{0}'</source>
        <target state="translated">Несогласованный "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBracketBar">
        <source>Unmatched '[|'</source>
        <target state="translated">Несогласованный "[|"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBrace">
        <source>Unmatched '{{'</source>
        <target state="translated">Несогласованный "{{"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsFieldBinding">
        <source>Field bindings must have the form 'id = expr;'</source>
        <target state="translated">Привязка поля должна иметь вид "id = expr;"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMemberIllegalInObjectImplementation">
        <source>This member is not permitted in an object implementation</source>
        <target state="translated">Использование этого элемента в реализации объекта не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingFunctionBody">
        <source>Missing function body</source>
        <target state="translated">Отсутствует тело функции</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxErrorInLabeledType">
        <source>Syntax error in labelled type argument</source>
        <target state="translated">Ошибка синтаксиса в аргументе типа с меткой</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedInfixOperator">
        <source>Unexpected infix operator in type expression</source>
        <target state="translated">Недопустимый инфиксный оператор в выражении типа</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMultiArgumentGenericTypeFormDeprecated">
        <source>The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident&lt;typ,...,typ&gt;' instead</source>
        <target state="translated">Синтаксис '(typ,...,typ) ident' не используется в коде F#. Используйте синтаксис 'ident&lt;typ,...,typ&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidLiteralInType">
        <source>Invalid literal in type</source>
        <target state="translated">Недопустимый литерал в типе</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedOperatorForUnitOfMeasure">
        <source>Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'.</source>
        <target state="translated">Недопустимый инфиксный оператор в выражении единицы измерения. Допустимые операторы: "*", "/" и "^".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedIntegerLiteralForUnitOfMeasure">
        <source>Unexpected integer literal in unit-of-measure expression</source>
        <target state="translated">Недопустимый целочисленный литерал в выражении единицы измерения</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedTypeParameter">
        <source>Syntax error: unexpected type parameter specification</source>
        <target state="translated">Синтаксическая ошибка: недопустимая спецификация параметра типа</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMismatchedQuotationName">
        <source>Mismatched quotation operator name, beginning with '{0}'</source>
        <target state="translated">Несоответствующее имя оператора кавычки, начиная с "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseMustBeginWithUpperCase">
        <source>Active pattern case identifiers must begin with an uppercase letter</source>
        <target state="translated">Активные идентификаторы вариантов шаблона должны начинаться с прописной буквы</target>
        <note />
      </trans-unit>
      <trans-unit id="parsActivePatternCaseContainsPipe">
        <source>The '|' character is not permitted in active pattern case identifiers</source>
        <target state="translated">Символ "|" запрещено использовать в идентификаторах вариантов активного шаблона</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalDenominatorForMeasureExponent">
        <source>Denominator must not be 0 in unit-of-measure exponent</source>
        <target state="translated">Делитель в экспоненте единицы измерения не должен равняться 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNoEqualShouldFollowNamespace">
        <source>No '=' symbol should follow a 'namespace' declaration</source>
        <target state="translated">После объявления "namespace" отсутствует символ "="</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleStructEndDeprecated">
        <source>The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">Синтаксис "module ... = struct .. end" не используется в код F#. Рекомендуется использовать синтаксис "module ... = begin .. end"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSyntaxModuleSigEndDeprecated">
        <source>The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'</source>
        <target state="translated">Синтаксис "module ... : sig .. end" не используется в коде F#. Рекомендуется использовать синтаксис "module ... = begin .. end"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticFieldUsedWhenInstanceFieldExpected">
        <source>A static field was used where an instance field is expected</source>
        <target state="translated">Там, где требовалось поле экземпляра, было использовано статическое поле</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodNotAccessible">
        <source>Method '{0}' is not accessible from this code location</source>
        <target state="translated">Метод "{0}" недоступен из данного расположения в коде</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplicitMeasureFollowingSlash">
        <source>Implicit product of measures following /</source>
        <target state="translated">Далее неявный результат измерений /</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedMeasureAnon">
        <source>Unexpected SynMeasure.Anon</source>
        <target state="translated">Непредвиденное значение SynMeasure.Anon</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonZeroConstantCannotHaveGenericUnit">
        <source>Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.</source>
        <target state="translated">Ненулевые константы не могут иметь универсальных единиц измерения. Для универсальных нулевых констант используйте 0.0&lt;_&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSeqResultsUseYield">
        <source>In sequence expressions, results are generated using 'yield'</source>
        <target state="translated">В выражениях последовательности результаты создаются с помощью "yield"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedBigRationalConstant">
        <source>Unexpected big rational constant</source>
        <target state="translated">Недопустимая большая рациональная константа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForUnitsOfMeasure">
        <source>Units-of-measure are only supported on float, float32, decimal, and integer types.</source>
        <target state="needs-review-translation">Единицы измерения поддерживаются только с типами float, float32, decimal и signed integer</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstUint16Array">
        <source>Unexpected Const_uint16array</source>
        <target state="translated">Недопустимый Const_uint16array</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConstByteArray">
        <source>Unexpected Const_bytearray</source>
        <target state="translated">Недопустимый Const_bytearray</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterRequiresName">
        <source>A parameter with attributes must also be given a name, e.g. '[&lt;Attribute&gt;] Name : Type'</source>
        <target state="translated">Необходимо также указать имя параметра с атрибутами, например, '[&lt;Атрибут&gt;] имя : тип'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnValuesCannotHaveNames">
        <source>Return values cannot have names</source>
        <target state="translated">Значения возврата не могут иметь имен</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberKindPropertyGetSetNotExpected">
        <source>MemberKind.PropertyGetSet only expected in parse trees</source>
        <target state="translated">MemberKind.PropertyGetSet требуется только в деревьях синтаксического анализа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainValues">
        <source>Namespaces cannot contain values. Consider using a module to hold your value declarations.</source>
        <target state="translated">Пространство имен не может содержать значений. Рекомендуется использовать модуль для удержания объявлений значений.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamespaceCannotContainExtensionMembers">
        <source>Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.</source>
        <target state="translated">Пространства имен не могут содержать элементы расширения, кроме элементов в том же файле и группе объявлений пространства имен, где определен тип. Рекомендуется использовать модуль для объявлений элементов расширения.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributes">
        <source>Multiple visibility attributes have been specified for this identifier</source>
        <target state="translated">Для данного идентификатора были указаны множественные атрибуты видимости</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMultipleVisibilityAttributesWithLet">
        <source>Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions.</source>
        <target state="translated">Для данного идентификатора были указаны множественные атрибуты видимости. привязки "let" в классах всегда являются закрытыми, так же, как и привязки "let" внутри выражений.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForRelationalOperator">
        <source>The name '({0})' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">Имя "({0})" не может использоваться в качестве имени элемента. Чтобы определить для типа семантику сравнения, реализуйте интерфейс "System.IComparable". При определении статического элемента для использования из других языков CLI, используйте имя "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMethodNameForEquality">
        <source>The name '({0})' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">Имя "({0})" не может использоваться в качестве имени элемента. Чтобы определить для типа семантику равенства, переопределите элемент "Object.Equals". При определении статического элемента для использования из других языков CLI, используйте имя "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberName">
        <source>The name '({0})' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '{1}' instead.</source>
        <target state="translated">Имя "({0})" не может использоваться в качестве имени элемента. При определении статического элемента для использования из других языков CLI, используйте имя "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameFixedTypes">
        <source>The name '({0})' should not be used as a member name because it is given a standard definition in the F# library over fixed types</source>
        <target state="translated">Имя "({0})" не должно использоваться в качестве имени элемента, так как оно получает стандартное определение в библиотеке F# поверх исправленных типов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionRelational">
        <source>The '{0}' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type.</source>
        <target state="translated">Оператор "{0}" обычно не должен быть переопределен. Чтобы определить для типа семантику сравнения, реализуйте интерфейс "System.IComparable" в определении этого типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinitionEquality">
        <source>The '{0}' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type.</source>
        <target state="translated">Оператор "{0}" обычно не должен быть переопределен. Чтобы определить для типа семантику равенства, переопределите элемент "Object.Equals" в определении этого типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOperatorDefinition">
        <source>The '{0}' operator should not normally be redefined. Consider using a different operator name</source>
        <target state="translated">Оператор "{0}" обычно не должен быть переопределен. Рекомендуется использовать другое имя оператора</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexOperatorDefinition">
        <source>The '{0}' operator cannot be redefined. Consider using a different operator name</source>
        <target state="translated">Оператор "{0}" не может быть переопределен. Рекомендуется использовать другое имя оператора</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectModuleOrNamespaceParent">
        <source>Expected module or namespace parent {0}</source>
        <target state="translated">Требуется модуль или родительский элемент пространства имен {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" явно реализует интерфейс "System.IComparable". Необходимо применить к типу атрибут "CustomComparison".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsGenericIComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IComparable&lt;_&gt;' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.</source>
        <target state="translated">Тип структуры, записи или объединения '{0}' явно реализует интерфейс 'System.IComparable&lt;_&gt;'. Необходимо применить атрибут 'CustomComparison' к типу и подготовить постоянную реализацию необщего интерфейса System.IComparable.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralComparableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type.</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" явно реализует интерфейс "System.IStructuralComparable". Необходимо применить к типу атрибут "CustomComparison".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordFieldInconsistentTypes">
        <source>This record contains fields from inconsistent types</source>
        <target state="translated">Данная запись содержит поля из несогласованных типов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportStubsCannotBeInlined">
        <source>DLLImport stubs cannot be inlined</source>
        <target state="translated">Заглушки DLLImport не могут быть подставлены</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCanOnlyBindThisAtMemberDeclaration">
        <source>Structs may only bind a 'this' parameter at member declarations</source>
        <target state="translated">Структуры могут выполнять привязку параметра "this" только в объявлениях элементов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedExprAtRecInfPoint">
        <source>Unexpected expression at recursive inference point</source>
        <target state="translated">Недопустимое выражение в точке рекурсивного выведения</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLessGenericBecauseOfAnnotation">
        <source>This code is less generic than required by its annotations because the explicit type variable '{0}' could not be generalized. It was constrained to be '{1}'.</source>
        <target state="translated">Данный код является менее базовым, чем требуется его аннотациями, так как переменная явного типа "{0}" не может быть обобщена. Она была ограничена до "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstrainedTypeVariableCannotBeGeneralized">
        <source>One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types</source>
        <target state="translated">Один или несколько явных классов или переменных типов функций для данной привязки не могут быть обобщены, так как они были ограничены на другие типы.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericParameterHasBeenConstrained">
        <source>A generic type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Был использован базовый параметр типа таким образом, что он всегда ограничен до "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterHasBeenConstrained">
        <source>This type parameter has been used in a way that constrains it to always be '{0}'</source>
        <target state="translated">Данный параметр типа был использован так, что был ограничен до постоянного значения "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParametersInferredAreNotStable">
        <source>The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</source>
        <target state="translated">Параметры типа, полученные для этого значения, не являются стабильными в случае удаления сокращенных обозначений типа. Это вызвано использованием сокращенных обозначений типа, которые удаляются или вызывают изменение порядка параметров типа, например, \n\ttype taggedInt&lt;'a&gt; = int или\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nОбъявите параметры типа для этого значения явным образом, например, \n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeParameterInvalid">
        <source>Explicit type parameters may only be used on module or member bindings</source>
        <target state="translated">Явные параметры типа могут быть использованы только в модуле или привязках элемента</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridingMethodRequiresAllOrNoTypeParameters">
        <source>You must explicitly declare either all or no type parameters when overriding a generic abstract method</source>
        <target state="translated">Необходимо явно объявить либо все параметры типа, либо не объявлять их вообще при переопределении базового абстрактного метода</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldsDoNotDetermineUniqueRecordType">
        <source>The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type</source>
        <target state="translated">Метки поля и требуемый тип данного выражения записи или шаблона не определяют уникально соответствующий тип записи</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldAppearsTwiceInRecord">
        <source>The field '{0}' appears twice in this record expression or pattern</source>
        <target state="translated">Поле "{0}" появляется дважды в данном выражении записи или шаблоне</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnknownUnion">
        <source>Unknown union case</source>
        <target state="translated">Неизвестная ветвь объединения</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotSufficientlyGenericBecauseOfScope">
        <source>This code is not sufficiently generic. The type variable {0} could not be generalized because it would escape its scope.</source>
        <target state="translated">Этот код является недостаточно базовым Переменная типа {0} не может быть обобщена, так как тогда она выйдет за пределы области.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyRequiresExplicitTypeParameters">
        <source>A property cannot have explicit type parameters. Consider using a method instead.</source>
        <target state="translated">Свойство не может иметь явных параметров типа. Вместо этого рекомендуется использовать метод.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorCannotHaveTypeParameters">
        <source>A constructor cannot have explicit type parameters. Consider using a static construction method instead.</source>
        <target state="translated">Конструктор не может иметь явных параметров типа. Возможно, требуется использовать статический метод.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInstanceMemberRequiresTarget">
        <source>This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'.</source>
        <target state="translated">Для данного элемента экземпляра требуется параметр для представления вызываемого объекта. Сделайте элемент статическим, или же используйте нотацию "member x.Member(args) = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertyInSyntaxTree">
        <source>Unexpected source-level property specification in syntax tree</source>
        <target state="translated">Недопустимая спецификация свойства уровня источника в синтаксическом дереве</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializerRequiresArgument">
        <source>A static initializer requires an argument</source>
        <target state="translated">Для статического инициализатора требуется аргумент</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorRequiresArgument">
        <source>An object constructor requires an argument</source>
        <target state="translated">Конструктор объекта требует аргумент</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticMemberShouldNotHaveThis">
        <source>This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'.</source>
        <target state="translated">Данный статический элемент не должен иметь параметр "this". Рекомендуется использовать нотацию "member Member(args) = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitStaticInitializerSyntax">
        <source>An explicit static initializer should use the syntax 'static new(args) = expr'</source>
        <target state="translated">Явный статический инициализатор должен использовать синтаксис "new(args) = expr"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitObjectConstructorSyntax">
        <source>An explicit object constructor should use the syntax 'new(args) = expr'</source>
        <target state="translated">Конструктор явного объекта должен использовать синтаксис "new(args) = expr"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedPropertySpec">
        <source>Unexpected source-level property specification</source>
        <target state="translated">Недопустимая спецификация свойства уровня источника</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionFormDeprecated">
        <source>This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions.</source>
        <target state="translated">Эта форма выражения объекта не используется в F#. Используйте "member this.MemberName ... = ...' для определения реализации элемента в выражениях объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDeclaration">
        <source>Invalid declaration</source>
        <target state="translated">Недопустимое объявление</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesInvalidInPatterns">
        <source>Attributes are not allowed within patterns</source>
        <target state="translated">Использование атрибутов внутри шаблонов не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitTypeArguments">
        <source>The generic function '{0}' must be given explicit type argument(s)</source>
        <target state="translated">Базовой функции "{0}" должны быть даны явные аргументы типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoesNotAllowExplicitTypeArguments">
        <source>The method or function '{0}' should not be given explicit type argument(s) because it does not declare its type parameters explicitly</source>
        <target state="translated">метод или функция "{0}" не должна получать явные аргументы типа, так как она не объявляет свои параметры типа явно</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterArityMismatch">
        <source>This value, type or method expects {0} type parameter(s) but was given {1}</source>
        <target state="translated">Для данного значения, типа или метода требуется {0} параметров типа, но получено {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultStructConstructorCall">
        <source>The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization</source>
        <target state="translated">Конструктор нулевой инициализации типа структуры по умолчанию может использоваться только в случае, если все поля типа структуры допускают инициализацию по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindIDisposable">
        <source>Couldn't find Dispose on IDisposable, or it was overloaded</source>
        <target state="translated">Не удалось найти Dispose на IDisposable, возможно, оно перегружено.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonLiteralCannotBeUsedInPattern">
        <source>This value is not a literal and cannot be used in a pattern</source>
        <target state="translated">Данное значение не является литералом и не может использоваться в шаблоне</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsReadonly">
        <source>This field is readonly</source>
        <target state="translated">Это поле доступно только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameArgumentsMustAppearLast">
        <source>Named arguments must appear after all other arguments</source>
        <target state="translated">Именованные аргументы должны появиться после всех остальных аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFunctionRequiresExplicitLambda">
        <source>This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking {0} arguments.</source>
        <target state="translated">Данное значение функции используется для конструирования типа делегата, подпись которого включает аргумент byref. Необходимо использовать явное лямбда выражение, принимающее {0} аргументов.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCannotBeEnumerated">
        <source>The type '{0}' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method</source>
        <target state="translated">Значения типа "{0}" не могут быть перечислены с помощью этого синтаксиса, так как этот тип не совместим с seq&lt;_&gt;, IEnumerable&lt;_&gt; и IEnumerable и не содержит метода GetEnumerator</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMixtureOfRecursiveForms">
        <source>This recursive binding uses an invalid mixture of recursive forms</source>
        <target state="translated">Данная рекурсивная привязка использует недопустимое совмещение рекурсивных форм</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectConstructionExpression">
        <source>This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.</source>
        <target state="translated">Это недопустимое выражение конструкции объекта. Конструкторы явных объектов должны либо вызывать альтернативный конструктор, либо инициализировать все поля объекта и указывать вызов конструктора суперкласса.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraint">
        <source>Invalid constraint</source>
        <target state="translated">Недопустимое ограничение</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstraintTypeSealed">
        <source>Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution</source>
        <target state="translated">Недопустимое ограничение: тип, использованный для ограничения, запечатан, это означает, что ограничение может быть удовлетворено максимум одним решением.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumConstraint">
        <source>An 'enum' constraint must be of the form 'enum&lt;type&gt;'</source>
        <target state="translated">Ограничение 'enum' должно иметь вид 'enum&lt;type&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNewConstraint">
        <source>'new' constraints must take one argument of type 'unit' and return the constructed type</source>
        <target state="translated">Ограничения "new" должны принять один аргумент типа "unit" и возвратить сформированный тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPropertyType">
        <source>This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -&gt; ty3'. Properties returning functions should have types of the form '(ty1 -&gt; ty2)'.</source>
        <target state="translated">Это свойство имеет недопустимый тип. Свойства, принимающие несколько аргументов индексатора, должны иметь типы 'ty1 * ty2 -&gt; ty3'. Свойства, возвращающие функции, должны иметь типы '(ty1 -&gt; ty2)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureMarkWithAttribute">
        <source>Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.</source>
        <target state="translated">Ожидается параметр единицы измерения, а не параметр типа. Явные параметры единиц измерения должны быть помечены атрибутом [&lt;Measure&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeParameter">
        <source>Expected type parameter, not unit-of-measure parameter</source>
        <target state="translated">Требуется параметр типа, а не параметр единицы измерения</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedTypeNotUnitOfMeasure">
        <source>Expected type, not unit-of-measure</source>
        <target state="translated">Требуется тип, а не единица измерения</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedUnitOfMeasureNotType">
        <source>Expected unit-of-measure, not type</source>
        <target state="translated">Требуется единица измерения, а не тип</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUnitsOfMeasurePrefix">
        <source>Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.</source>
        <target state="translated">Единицы измерения нельзя использовать как аргументы-префиксы для типа. Перепишите аргументы-постфиксы в угловых скобках.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnitsOfMeasureInvalidInTypeConstructor">
        <source>Unit-of-measure cannot be used in type constructor application</source>
        <target state="translated">Единица измерения не может быть использована в приложении конструктора типов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireBuilderMethod">
        <source>This control construct may only be used if the computation expression builder defines a '{0}' method</source>
        <target state="translated">Конструкция данного элемента управления может использоваться только в том случае, если построитель вычислительного выражения определяет метод "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoNestedTypes">
        <source>This type has no nested types</source>
        <target state="translated">Этот тип не имеет вложенных типов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSymbolInTypeExpression">
        <source>Unexpected {0} in type expression</source>
        <target state="translated">Недопустимый {0} в выражении типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeParameterInvalidAsTypeConstructor">
        <source>Type parameter cannot be used as type constructor</source>
        <target state="translated">Тип параметра нельзя использовать в качестве конструктора типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalSyntaxInTypeExpression">
        <source>Illegal syntax in type expression</source>
        <target state="translated">Недопустимый синтаксис в выражении типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousUnitsOfMeasureCannotBeNested">
        <source>Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression</source>
        <target state="translated">Не допускается вложение анонимной единицы измерения в другое выражение единицы измерения</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonymousTypeInvalidInDeclaration">
        <source>Anonymous type variables are not permitted in this declaration</source>
        <target state="translated">Использование анонимных переменных типа в этом объявлении не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedSlashInType">
        <source>Unexpected / in type</source>
        <target state="translated">Недопустимый / в типе</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedTypeArguments">
        <source>Unexpected type arguments</source>
        <target state="translated">Недопустимые аргументы типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsOnlyOnMembers">
        <source>Optional arguments are only permitted on type members</source>
        <target state="translated">Необязательные аргументы разрешены только в элементах типов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNameNotBoundInPattern">
        <source>Name '{0}' not bound in pattern context</source>
        <target state="translated">Имя "{0}" не привязано в контексте шаблона</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNonPrimitiveLiteralInPatternMatch">
        <source>Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when &lt;variable&gt; = &lt;constant&gt;' at the end of the match clause.</source>
        <target state="translated">Непримитивные числовые символьные константы не могут использоваться в выражениях сопоставления шаблонов, так как они могут быть сопоставлены различным типам с использованием модуля NumericLiteral. Замените эти константы на переменные, указав конструкцию 'when &lt;переменная&gt; = &lt;константа&gt;' в конце выражения сопоставления.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentUsage">
        <source>Type arguments cannot be specified here</source>
        <target state="translated">Аргументы типа не могут быть здесь указаны</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireActivePatternWithOneResult">
        <source>Only active patterns returning exactly one result may accept arguments</source>
        <target state="translated">Только активные шаблоны, возвращающие ровно один результат, могут принимать аргументы</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidArgForParameterizedPattern">
        <source>Invalid argument to parameterized pattern label</source>
        <target state="translated">Недопустимый аргумент в параметризованной метке шаблона</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexIntoActivePatternArray">
        <source>Internal error. Invalid index into active pattern array</source>
        <target state="translated">Внутренняя ошибка. Недопустимый индекс в массив активного шаблона</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseDoesNotTakeArguments">
        <source>This union case does not take arguments</source>
        <target state="translated">Данный случай объединения не принимает аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseRequiresOneArgument">
        <source>This union case takes one argument</source>
        <target state="translated">Данный случай объединения принимает один аргумент</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseExpectsTupledArguments">
        <source>This union case expects {0} arguments in tupled form</source>
        <target state="translated">Для данного случая объединения требуется {0} аргументов в форме кортежа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotStatic">
        <source>Field '{0}' is not static</source>
        <target state="translated">Поле "{0}" не является статическим</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNotLiteralCannotBeUsedInPattern">
        <source>This field is not a literal and cannot be used in a pattern</source>
        <target state="translated">Данное поле не является литералом и не может использоваться в шаблоне</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRequireVarConstRecogOrLiteral">
        <source>This is not a variable, constant, active recognizer or literal</source>
        <target state="translated">Это не переменная, константа, активный распознаватель или литерал</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidPattern">
        <source>This is not a valid pattern</source>
        <target state="translated">Недопустимый шаблон.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseWhenPatternGuard">
        <source>Character range matches have been removed in F#. Consider using a 'when' pattern guard instead.</source>
        <target state="translated">Совпадения диапазона символов были убраны из F#. Вместо этого рекомендуется использовать шаблон условия "when".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalPattern">
        <source>Illegal pattern</source>
        <target state="translated">Недопустимый шаблон</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxErrorUnexpectedQMark">
        <source>Syntax error - unexpected '?' symbol</source>
        <target state="translated">Ошибка синтаксиса - недопустимый символ "?"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionCountMisMatch">
        <source>Expected {0} expressions, got {1}</source>
        <target state="translated">Требуется {0} выражений, получено {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExprUndelayed">
        <source>TcExprUndelayed: delayed</source>
        <target state="translated">TcExprUndelayed: инерционность</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionRequiresSequence">
        <source>This expression form may only be used in sequence and computation expressions</source>
        <target state="translated">Данная форма выражения может использоваться только в выражениях последовательности и вычислений.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectExpressionSyntaxForm">
        <source>Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.</source>
        <target state="translated">Недопустимое выражение объекта. Объекты без переопределений или интерфейсов должны использовать форму выражения "new Type(args)" без фигурных скобок.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidObjectSequenceOrRecordExpression">
        <source>Invalid object, sequence or record expression</source>
        <target state="translated">Недопустимое выражение объекта, последовательности или записи</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSequenceExpressionSyntaxForm">
        <source>Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq {{ ... }}'</source>
        <target state="translated">Недопустимая запись, выражение последовательности или вычислительное выражение. Выражения последовательностей должны иметь форму "seq {{ ... }}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionWithIfRequiresParenthesis">
        <source>This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression</source>
        <target state="translated">Данный список выражений массива включает элемент формы "if ... then ... else". Заключите данное выражение в скобки, чтобы показать, что это отдельный элемент списка или массива, отличающийся от списка, созданного с использованием выражения последовательности</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnableToParseFormatString">
        <source>Unable to parse format string '{0}'</source>
        <target state="translated">Не удается выполнить синтаксический анализ строки формата "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcListLiteralMaxSize">
        <source>This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.</source>
        <target state="translated">Данное выражение списка превышает максимальный размер литералов списка. Для больших литералов используется массив и вызывается Array.ToList.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresObjectConstructor">
        <source>The expression form 'expr then expr' may only be used as part of an explicit object constructor</source>
        <target state="translated">Форма выражения ''expr then expr'' может использоваться только как часть конструктора явного объекта</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentsCannotBeUsedInMemberTraits">
        <source>Named arguments cannot be given to member trait calls</source>
        <target state="translated">Именованные аргументы не могут применяться к вызовам свойств элемента</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotValidEnumCaseName">
        <source>This is not a valid name for an enumeration case</source>
        <target state="translated">Недопустимое имя для случая перечисления</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldIsNotMutable">
        <source>This field is not mutable</source>
        <target state="translated">Это поле не является изменяемым</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresListArrayOrSequence">
        <source>This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq {{ ... }}', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements</source>
        <target state="translated">Использовать эту конструкцию можно только в выражениях списка, массива и последовательности, например в выражениях формы "seq {{ … }}", "[ … ]" или "[| … |]". Они создают элементы с помощью синтаксиса "for … in … do … yield…"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpressions">
        <source>This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'.</source>
        <target state="translated">Данный конструктор может быть использован только в вычислительных выражениях Для возврата значения из обычной функции просто напишите выражение без "return".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresSequenceOrComputations">
        <source>This construct may only be used within sequence or computation expressions</source>
        <target state="translated">Данный конструктор может быть использован только в вычислительных выражениях или выражениях последовательностей</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructRequiresComputationExpression">
        <source>This construct may only be used within computation expressions</source>
        <target state="translated">Данный конструктор может быть использован только в вычислительных выражениях</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidIndexerExpression">
        <source>Invalid indexer expression</source>
        <target state="translated">Недопустимое выражение индексатора</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
        <source>The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints</source>
        <target state="translated">Оператор "expr.[idx]" применялся к объекту неопределенного типа на основе информации, полученной до этой точки программы. Попробуйте добавить дополнительные ограничения типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromVariableType">
        <source>Cannot inherit from a variable type</source>
        <target state="translated">Не удается реализовать наследование от типа переменной</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsOnTypeParametersCannotTakeArguments">
        <source>Calls to object constructors on type parameters cannot be given arguments</source>
        <target state="translated">Вызовам конструкторов объектов на параметрах типа нельзя присваивать аргументы</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCompiledNameAttributeMisused">
        <source>The 'CompiledName' attribute cannot be used with this language element</source>
        <target state="translated">Атрибут "CompiledName" нельзя использовать с данным элементом языка.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedTypeRequired">
        <source>'{0}' may only be used with named types</source>
        <target state="translated">{0} может использоваться только с именованными типами</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritCannotBeUsedOnInterfaceType">
        <source>'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead.</source>
        <target state="translated">inherit не может использоваться в типах интерфейса. Рекомендуется реализовать интерфейс, используя "interface ... with ... end"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewCannotBeUsedOnInterfaceType">
        <source>'new' cannot be used on interface types. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">new не может использоваться в типах интерфейса. Вместо этого рекомендуется использовать выражение объекта "{{ new ... with ... }}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractTypeCannotBeInstantiated">
        <source>Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{{ new ... with ... }}' instead.</source>
        <target state="translated">Создание экземпляров этого типа невозможно, поскольку он помечен как abstract, и реализации представлены не для всех методов. Вместо этого рекомендуется использовать выражение объекта "{{ new ... with ... }}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIDisposableTypeShouldUseNew">
        <source>It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value</source>
        <target state="translated">Рекомендуется создавать объекты, поддерживающие интерфейс IDisposable с помощью "new Type(args)", а не "Type(args)" или "Type" в качестве значения функции, представляющего конструктор; это делается для того, чтобы указать, что ресурсы могут принадлежать созданному значению.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxCanOnlyBeUsedToCreateObjectTypes">
        <source>'{0}' may only be used to construct object types</source>
        <target state="translated">{0}" может использоваться только для формирования типов объектов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresCall">
        <source>Constructors for the type '{0}' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.</source>
        <target state="translated">Конструкторы для типа "{0}" должны напрямую или косвенно вызывать свой неявный конструктор объекта. Вместо выражения записи используйте вызов неявного конструктора объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUndefinedField">
        <source>The field '{0}' has been given a value, but is not present in the type '{1}'</source>
        <target state="translated">Значение для поля "{0}" было задано, но не представлено в типе "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresAssignment">
        <source>No assignment given for field '{0}' of type '{1}'</source>
        <target state="translated">Нет назначения для поля "{0}" типа "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExtraneousFieldsGivenValues">
        <source>Extraneous fields have been given values</source>
        <target state="translated">Посторонние поля получили значения</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
        <source>Only overrides of abstract and virtual members may be specified in object expressions</source>
        <target state="translated">В выражениях объектов могут указываться только переопределения абстрактных и виртуальных элементов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoAbstractOrVirtualMemberFound">
        <source>The member '{0}' does not correspond to any abstract or virtual method available to override or implement.</source>
        <target state="translated">Элемент "{0}" не соответствует какому-либо абстрактному или виртуальному методу, доступному для переопределения или реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberFoundIsNotAbstractOrVirtual">
        <source>The type {0} contains the member '{1}' but it is not a virtual or abstract method that is available to override or implement.</source>
        <target state="translated">Тип {0} содержит элемент "{1}", но не является виртуальным или абстрактным методом, доступным для переопределения или реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatch">
        <source>The member '{0}' does not accept the correct number of arguments. {1} argument(s) are expected, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">Члену "{0}" передано неправильное число аргументов. Ожидалось аргументов: {1}, предоставлено аргументов: {2}. Требуемая сигнатура — "{3}".{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcArgumentArityMismatchOneOverload">
        <source>The member '{0}' does not accept the correct number of arguments. One overload accepts {1} arguments, but {2} were given. The required signature is '{3}'.{4}</source>
        <target state="translated">Члену "{0}" передано неправильное число аргументов. Одна перегрузка принимает следующее число аргументов: {1}, предоставлено аргументов: {2}. Требуемая сигнатура — "{3}".{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSimpleMethodNameRequired">
        <source>A simple method name is required here</source>
        <target state="translated">Здесь требуется простое имя метода</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPredefinedTypeCannotBeUsedAsSuperType">
        <source>The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class</source>
        <target state="translated">Типы System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate и System.Array не могут использоваться в качестве супертипа в выражении объекта или классе объекта</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMustBeUsedWithNamedType">
        <source>'new' must be used with a named type</source>
        <target state="translated">new необходимо использовать с именованным типом</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCreateExtensionOfSealedType">
        <source>Cannot create an extension of a sealed type</source>
        <target state="translated">Не удается создать расширение запечатанного типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoArgumentsForRecordValue">
        <source>No arguments may be given when constructing a record value</source>
        <target state="translated">Невозможно предоставить аргументы при формировании значения записи.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoInterfaceImplementationForConstructionExpression">
        <source>Interface implementations cannot be given on construction expressions</source>
        <target state="translated">Реализации интерфейса не могут быть даны в выражениях конструкций</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionCanOnlyBeUsedInClassTypes">
        <source>Object construction expressions may only be used to implement constructors in class types</source>
        <target state="translated">Выражения конструкции объекта могут использоваться только для реализации конструкторов в типах классов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
        <source>Only simple bindings of the form 'id = expr' can be used in construction expressions</source>
        <target state="translated">Только простые привязки вида "id = expr" могут использоваться в выражениях конструкции</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectsMustBeInitializedWithObjectExpression">
        <source>Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field</source>
        <target state="translated">Объекты должны инициализироваться выражением конструкции объекта, вызывающим конструктор унаследованного объекта и назначающим значение для каждого поля</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpectedInterfaceType">
        <source>Expected an interface type</source>
        <target state="translated">Требуется интерфейсный тип</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorForInterfacesDoNotTakeArguments">
        <source>Constructor expressions for interfaces do not take arguments</source>
        <target state="translated">Выражения конструктора для интерфейсов не принимают аргументы</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorRequiresArguments">
        <source>This object constructor requires arguments</source>
        <target state="translated">Данный конструктор объекта требует аргументов.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewRequiresObjectConstructor">
        <source>'new' may only be used with object constructors</source>
        <target state="translated">new может использоваться только с конструкторами объектов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAtLeastOneOverrideIsInvalid">
        <source>At least one override did not correctly implement its corresponding abstract member</source>
        <target state="translated">Как минимум в одном переопределении неправильно реализован соответствующий абстрактный элемент</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNumericLiteralRequiresModule">
        <source>This numeric literal requires that a module '{0}' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope</source>
        <target state="translated">Данный числовой литерал требует наличия в области модуля "{0}" определяющих функций FromZero, FromOne, FromInt32, FromInt64 и FromString</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRecordConstruction">
        <source>Invalid record construction</source>
        <target state="translated">Недопустимая конструкция записи</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExpressionFormRequiresRecordTypes">
        <source>The expression form {{ expr with ... }} may only be used with record types. To build object types use {{ new Type(...) with ... }}</source>
        <target state="translated">Форма выражения {{ expr with ... }} может использоваться только с типами записи. Для сборки типов объекта используется {{ new Type(...) with ... }}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritedTypeIsNotObjectModelType">
        <source>The inherited type is not an object model type</source>
        <target state="translated">Унаследованный тип не является типом модели объекта</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
        <source>Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors</source>
        <target state="translated">Выражения конструкции объекта (напр. выражений записи со спецификациями наследования) могут использоваться только для реализации конструкторов в типах моделей объектов. Для формирования экземпляров типов моделей объектов вне конструкторов используется "new ObjectType(args)"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyRecordInvalid">
        <source>'{{ }}' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'.</source>
        <target state="translated">Выражение "{{ }}" недопустимо. Записи должны включать по меньшей мере одно поле. Пустые последовательности задаются с использованием Seq.empty или пустого списка "[]".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordTypeNeedConstructor">
        <source>This type is not a record type. Values of class and struct types must be created using calls to object constructors.</source>
        <target state="translated">Этот тип не является типом записи. Значения типов класса и структуры должны создаваться, используя вызовы конструкторов объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotARecordType">
        <source>This type is not a record type</source>
        <target state="translated">Этот тип не является типом записи</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInComputationExpression">
        <source>This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder {{ ... }}'.</source>
        <target state="translated">Этот конструктор является неоднозначным как часть вычислительного выражения. Вложенные выражения могут записываться с использованием "let _ = (...)", а вложенные вычисления - с использованием "let! res = builder {{ ... }}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructIsAmbiguousInSequenceExpression">
        <source>This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {{... }}'.</source>
        <target state="translated">Этот конструктор является неоднозначным как часть выражения последовательности. Вложенные выражения могут записываться с использованием "let _ = (...)", а вложенные последовательности - с использованием "yield! seq {{... }}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDoBangIllegalInSequenceExpression">
        <source>'do!' cannot be used within sequence expressions</source>
        <target state="translated">do! нельзя использовать в выражениях последовательности</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseForInSequenceExpression">
        <source>The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead.</source>
        <target state="translated">Использование "let! x = coll" в выражениях последовательности не разрешается. Вместо этого используется "for x in coll".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryIllegalInSequenceExpression">
        <source>'try'/'with' cannot be used within sequence expressions</source>
        <target state="translated">''try''/''with'' не могут использоваться внутри (within) выражений последовательностей</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseYieldBangForMultipleResults">
        <source>In sequence expressions, multiple results are generated using 'yield!'</source>
        <target state="translated">В выражениях последовательности множественные результаты создаются с помощью "yield!"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidAssignment">
        <source>Invalid assignment</source>
        <target state="translated">Недопустимое присваивание</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfTypeName">
        <source>Invalid use of a type name</source>
        <target state="translated">Недопустимое использование имени типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeHasNoAccessibleConstructor">
        <source>This type has no accessible object constructors</source>
        <target state="translated">Этот тип не имеет доступных конструкторов объекта</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfInterfaceType">
        <source>Invalid use of an interface type</source>
        <target state="translated">Недопустимое использование интерфейсного типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseOfDelegate">
        <source>Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'.</source>
        <target state="translated">Недопустимое использование конструктора делегата. Допустимый синтаксис: "new Type(args)" или "Type(args)".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotStatic">
        <source>Property '{0}' is not static</source>
        <target state="translated">Свойство "{0}" не является статическим</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsNotReadable">
        <source>Property '{0}' is not readable</source>
        <target state="translated">Свойство "{0}" недоступно для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLookupMayNotBeUsedHere">
        <source>This lookup cannot be used here</source>
        <target state="translated">Данный поиск не может быть использован здесь.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyIsStatic">
        <source>Property '{0}' is static</source>
        <target state="translated">Свойство "{0}" является статическим</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet1">
        <source>Property '{0}' cannot be set</source>
        <target state="translated">Нельзя задать свойство "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsCannotBeFirstClassValues">
        <source>Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</source>
        <target state="translated">Конструкторы должны применяться к аргументам и не могут использоваться как значения первого класса. При необходимости используйте анонимную функцию '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
        <source>The syntax 'expr.id' may only be used with record labels, properties and fields</source>
        <target state="translated">Синтаксис "expr.id" может использоваться только с метками записей, свойствами и полями</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsStatic">
        <source>Event '{0}' is static</source>
        <target state="translated">Событие "{0}" является статическим</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEventIsNotStatic">
        <source>Event '{0}' is not static</source>
        <target state="translated">Событие "{0}" не является статическим</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedArgumentDidNotMatch">
        <source>The named argument '{0}' did not match any argument or mutable property</source>
        <target state="translated">Именованный аргумент "{0}" не совпал ни с одним аргументом или изменяемым свойством</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverloadsCannotHaveCurriedArguments">
        <source>One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.</source>
        <target state="translated">Одна или несколько перегрузок данного метода имеет переданные аргументы. Рекомендуется изменить эти элементы так, чтобы они принимали аргументы в форме кортежа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnnamedArgumentsDoNotFormPrefix">
        <source>The unnamed arguments do not form a prefix of the arguments of the method called</source>
        <target state="translated">Аргументы без названий не образуют префикса аргументов вызываемого метода</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
        <source>Static optimization conditionals are only for use within the F# library</source>
        <target state="translated">Условия статической оптимизации используются только в библиотеке F#</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFormalArgumentIsNotOptional">
        <source>The corresponding formal argument is not optional</source>
        <target state="translated">Соответствующий формат аргумента не является необязательным.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidOptionalAssignmentToPropertyOrField">
        <source>Invalid optional assignment to a property or field</source>
        <target state="translated">Недопустимое необязательное назначение свойству или полю</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegateConstructorMustBePassed">
        <source>A delegate constructor must be passed a single function value</source>
        <target state="translated">Конструктору делегата необходимо передать отдельное значение функции</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindingCannotBeUseAndRec">
        <source>A binding cannot be marked both 'use' and 'rec'</source>
        <target state="translated">Привязка не может быть одновременно отмечена как "use" и "rec"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileOnlyOnClassLetBindings">
        <source>The 'VolatileField' attribute may only be used on 'let' bindings in classes</source>
        <target state="translated">Атрибут "VolatileField" может использоваться только в привязках "let" в классах</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesAreNotPermittedOnLetBindings">
        <source>Attributes are not permitted on 'let' bindings in expressions</source>
        <target state="translated">Использование атрибутов для привязок "let" в выражениях не допускается</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultValueAttributeRequiresVal">
        <source>The 'DefaultValue' attribute may only be used on 'val' declarations</source>
        <target state="translated">Атрибут "DefaultValue" может использоваться только в объявлениях "val"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeRequiresMembers">
        <source>The 'ConditionalAttribute' attribute may only be used on members</source>
        <target state="translated">Атрибут "ConditionalAttribute" может использоваться только с элементами</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidActivePatternName">
        <source>This is not a valid name for an active pattern</source>
        <target state="translated">Недопустимое имя для активного шаблона</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEntryPointAttributeRequiresFunctionInModule">
        <source>The 'EntryPointAttribute' attribute may only be used on function definitions in modules</source>
        <target state="translated">Атрибут "EntryPointAttribute" может использоваться только в определениях функций в модулях</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesCannotBeInline">
        <source>Mutable values cannot be marked 'inline'</source>
        <target state="translated">Изменяемые значения не могут помечаться как "inline"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesMayNotHaveGenericParameters">
        <source>Mutable values cannot have generic parameters</source>
        <target state="translated">Изменяемые значения не могут иметь базовых параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMutableValuesSyntax">
        <source>Mutable function values should be written 'let mutable f = (fun args -&gt; ...)'</source>
        <target state="translated">Изменяемые значения функций должны быть доступны для записи: 'let mutable f = (fun args -&gt; ...)'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyFunctionsCanBeInline">
        <source>Only functions may be marked 'inline'</source>
        <target state="translated">Только функции могут помечаться как "inline"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalAttributesForLiteral">
        <source>A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes</source>
        <target state="translated">Атрибутам [&lt;ThreadStatic&gt;] и [&lt;ContextStatic&gt;] не может быть присвоено значение литерала</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeMutable">
        <source>A literal value cannot be marked 'mutable'</source>
        <target state="translated">Значение литерала нельзя пометить как "mutable"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotBeInline">
        <source>A literal value cannot be marked 'inline'</source>
        <target state="translated">Значение литерала нельзя пометить как "inline"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralCannotHaveGenericParameters">
        <source>Literal values cannot have generic parameters</source>
        <target state="translated">Значения литералов не могут иметь базовых параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidConstantExpression">
        <source>This is not a valid constant expression</source>
        <target state="translated">Это недопустимое постоянное выражение.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsInaccessible">
        <source>This type is not accessible from this code location</source>
        <target state="translated">Этот тип недоступен из данного расположения в коде</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnexpectedConditionInImportedAssembly">
        <source>Unexpected condition in imported assembly: failed to decode AttributeUsage attribute</source>
        <target state="translated">Недопустимое условие в импортированной сборке: не удалось декодировать атрибут AttributeUsage</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedAttributeTarget">
        <source>Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</source>
        <target state="translated">Нераспознанная цель атрибута. Допустимыми целями атрибута являются "assembly", "module", "type", "method", "property", "return", "param", "field", "event", "constructor".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElementUseDo">
        <source>This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module.</source>
        <target state="translated">Не допускается использование этого атрибута для этого элемента языка. Атрибуты сборки необходимо присоединять к объявлению "do ()" (при необходимости внутри модуля F#).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeIsNotValidForLanguageElement">
        <source>This attribute is not valid for use on this language element</source>
        <target state="translated">Не допускается использование этого атрибута для этого элемента языка</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgumentsCannotBeUsedInCustomAttribute">
        <source>Optional arguments cannot be used in custom attributes</source>
        <target state="translated">Необязательные аргументы не могут использоваться в пользовательских атрибутах</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyCannotBeSet0">
        <source>This property cannot be set</source>
        <target state="translated">Это свойство задать нельзя</target>
        <note />
      </trans-unit>
      <trans-unit id="tcPropertyOrFieldNotFoundInAttribute">
        <source>This property or field was not found on this custom attribute type</source>
        <target state="translated">Данное свойство или поле не было найдено в этом пользовательском типе атрибута</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustBeReferenceType">
        <source>A custom attribute must be a reference type</source>
        <target state="translated">Пользовательский атрибут должен являться ссылочным типом</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeArgumentMismatch">
        <source>The number of args for a custom attribute does not match the expected number of args for the attribute constructor</source>
        <target state="translated">Количество аргументов пользовательского атрибута не совпадает с требуемым числом аргументов для конструктора атрибутов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomAttributeMustInvokeConstructor">
        <source>A custom attribute must invoke an object constructor</source>
        <target state="translated">Пользовательский атрибут должен вызывать конструктор объекта</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeExpressionsMustBeConstructorCalls">
        <source>Attribute expressions must be calls to object constructors</source>
        <target state="translated">Выражения атрибутов должны вызывать конструкторы объектов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedAttribute">
        <source>This attribute cannot be used in this version of F#</source>
        <target state="translated">Данный атрибут не может быть использован в этой версии F#</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidInlineSpecification">
        <source>Invalid inline specification</source>
        <target state="translated">Недопустимая встроенная спецификация</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBinding">
        <source>'use' bindings must be of the form 'use &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">Привязки 'use' должны иметь вид 'use &lt;var&gt; = &lt;expr&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractMembersIllegalInAugmentation">
        <source>Abstract members are not permitted in an augmentation - they must be defined as part of the type itself</source>
        <target state="translated">Использование абстрактных элементов в приращении не допускается; такие элементы должны быть определены непосредственно в самом типе</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMethodOverridesIllegalHere">
        <source>Method overrides and interface implementations are not permitted here</source>
        <target state="translated">Переопределения методов и реализации интерфейсов здесь не разрешаются</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoMemberFoundForOverride">
        <source>No abstract or interface member was found that corresponds to this override</source>
        <target state="translated">Не было найдено ни одного абстрактного элемента либо элемента интерфейса, соответствующего данному переопределению</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverrideArityMismatch">
        <source>This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:{0}</source>
        <target state="translated">Это переопределение передает другое число аргументов соответствующему абстрактному элементу. Найдены следующие абстрактные элементы: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationAlreadyExists">
        <source>This method already has a default implementation</source>
        <target state="translated">Этот метод уже имеет реализацию по умолчанию</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultAmbiguous">
        <source>The method implemented by this default is ambiguous</source>
        <target state="translated">Метод, реализованный этим вариантом по умолчанию, является неоднозначным</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoPropertyFoundForOverride">
        <source>No abstract property was found that corresponds to this override</source>
        <target state="translated">Не было найдено ни одного абстрактного свойства, соответствующего данному переопределению</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbstractPropertyMissingGetOrSet">
        <source>This property overrides or implements an abstract property but the abstract property doesn't have a corresponding {0}</source>
        <target state="translated">Это свойство переопределяет или реализует абстрактное свойство, однако абстрактное свойство не имеет соответствующего {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidSignatureForSet">
        <source>Invalid signature for set member</source>
        <target state="translated">Недопустимая сигнатура для элемента множества</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMember">
        <source>This new member hides the abstract member '{0}'. Rename the member or use 'override' instead.</source>
        <target state="translated">Этот новый элемент скрывает абстрактный элемент "{0}". Переименуйте элемент или используйте "override".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNewMemberHidesAbstractMemberWithSuffix">
        <source>This new member hides the abstract member '{0}' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead.</source>
        <target state="translated">Этот новый элемент скрывает абстрактный элемент "{0}" после удаления кортежей, функций, единиц измерения и предоставляемых типов. Переименуйте элемент или используйте override.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticInitializersIllegalInInterface">
        <source>Interfaces cannot contain definitions of static initializers</source>
        <target state="translated">Интерфейсы не могут содержать определения статических инициализаторов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcObjectConstructorsIllegalInInterface">
        <source>Interfaces cannot contain definitions of object constructors</source>
        <target state="translated">Интерфейсы не могут содержать определения конструкторов объектов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOverridesIllegalInInterface">
        <source>Interfaces cannot contain definitions of member overrides</source>
        <target state="translated">Интерфейсы не могут содержать определения переопределений элементов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConcreteMembersIllegalInInterface">
        <source>Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.</source>
        <target state="translated">Интерфейсы не могут содержать определений конкретных элементов. Чтобы указать, что тип является классом, возможно, потребуется определить конструктор для типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsDisallowedInExceptionAugmentation">
        <source>Constructors cannot be specified in exception augmentations</source>
        <target state="translated">Конструкторы нельзя указывать в приращениях исключений</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsCannotHaveConstructorWithNoArguments">
        <source>Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.</source>
        <target state="translated">Структуры не могут иметь конструктор объектов без аргументов. Это ограничение, накладываемое на все языки CLI, так как структуры автоматически поддерживают конструктор по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalForThisType">
        <source>Constructors cannot be defined for this type</source>
        <target state="translated">Для данного типа не удается определить конструкторы</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
        <source>Recursive bindings that include member specifications can only occur as a direct augmentation of a type</source>
        <target state="translated">Рекурсивные привязки, включающие спецификации элементов, могут встречаться только как прямое приращение типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlySimplePatternsInLetRec">
        <source>Only simple variable patterns can be bound in 'let rec' constructs</source>
        <target state="translated">Только простые шаблоны переменных могут быть связаны в конструкциях "let rec"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
        <source>Mutable 'let' bindings can't be recursive or defined in recursive modules or namespaces</source>
        <target state="translated">Изменяемые привязки "let" не могут быть рекурсивными или определенными в рекурсивных модулях или пространствах имен</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberIsNotSufficientlyGeneric">
        <source>This member is not sufficiently generic</source>
        <target state="translated">Данный элемент является недостаточно базовым</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralAttributeRequiresConstantValue">
        <source>A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. 'val x : int = 1'</source>
        <target state="translated">Объявление может представлять собой только атрибут [&lt;Literal&gt;], если указано значение константы, например, 'val x : int = 1'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcValueInSignatureRequiresLiteralAttribute">
        <source>A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute</source>
        <target state="translated">Объявление может быть указано только в том случае, если в объявлении есть атрибут [&lt;Literal&gt;]</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThreadStaticAndContextStaticMustBeStatic">
        <source>Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread</source>
        <target state="translated">Статические переменные потока и контекста должны быть статическими, и для них необходимо указать атрибут [&lt;DefaultValue&gt;], чтобы подчеркнуть, что их значение инициализируется значением по умолчанию для каждого нового потока</target>
        <note />
      </trans-unit>
      <trans-unit id="tcVolatileFieldsMustBeMutable">
        <source>Volatile fields must be marked 'mutable' and cannot be thread-static</source>
        <target state="translated">Временные поля должны быть помечены как "mutable"; они также не могут быть потокостатическими</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUninitializedValFieldsMustBeMutable">
        <source>Uninitialized 'val' fields must be mutable and marked with the '[&lt;DefaultValue&gt;]' attribute. Consider using a 'let' binding instead of a 'val' field.</source>
        <target state="translated">Неинициализированные поля 'val' должны быть изменяемыми и должны быть помечены атрибутом '[&lt;DefaultValue&gt;]'. Используйте привязку 'let' вместо поля 'val'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticValFieldsMustBeMutableAndPrivate">
        <source>Static 'val' fields in types must be mutable, private and marked with the '[&lt;DefaultValue&gt;]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type.</source>
        <target state="translated">Статические поля 'val' в типах должны быть изменяемыми, закрытыми и должны быть помечены атрибутом '[&lt;DefaultValue&gt;]'. Они инициализируются значениями 'null' или 'zero' для своего типа. Вы также можете использовать привязку 'static let mutable' в типе класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldRequiresName">
        <source>This field requires a name</source>
        <target state="translated">Для этого поля требуется имя</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidNamespaceModuleTypeUnionName">
        <source>Invalid namespace, module, type or union case name</source>
        <target state="translated">Недопустимое имя пространства имен, типа или ветви объединения</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalFormForExplicitTypeDeclaration">
        <source>Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -&gt; resTy'. Parentheses may be required around 'resTy'</source>
        <target state="translated">Объявления явных типов для конструкторов должны иметь вид 'ty1 * ... * tyN -&gt; resTy'. Может потребоваться заключить 'resTy' в скобки</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnTypesForUnionMustBeSameAsType">
        <source>Return types of union cases must be identical to the type being defined, up to abbreviations</source>
        <target state="translated">Типы возвращаемых значений случаев объединений должны быть идентичны определяемому типу, вплоть до сокращений</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidEnumerationLiteral">
        <source>This is not a valid value for an enumeration literal</source>
        <target state="translated">Это не является допустимым значением для литерала перечисления</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType1">
        <source>The type '{0}' is not an interface type</source>
        <target state="translated">Тип "{0}" не является интерфейсным типом</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDuplicateSpecOfInterface">
        <source>Duplicate specification of an interface</source>
        <target state="translated">Дублированная спецификация интерфейса</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldValIllegalHere">
        <source>A field/val declaration is not permitted here</source>
        <target state="translated">Объявление field/val здесь не разрешено</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritIllegalHere">
        <source>A inheritance declaration is not permitted here</source>
        <target state="translated">Объявление наследования здесь не разрешено</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleRequiresQualifiedAccess">
        <source>This declaration opens the module '{0}', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.</source>
        <target state="translated">Данное объявление открывает модуль "{0}", помеченный как "RequireQualifiedAccess". Измените код так, чтобы вместо этого использовались квалифицированные ссылки на элементы модуля, напр. 'List.map' вместо 'map'. Данное изменение обеспечит надежность кода при добавлении конструкций в библиотеки.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenUsedWithPartiallyQualifiedPath">
        <source>This declaration opens the namespace or module '{0}' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.</source>
        <target state="translated">Это объявление открывает пространство имен или модуль "{0}" через частичный путь. Измените этот код для использования полного пути пространства имен. Данное изменение обеспечит надежность кода при добавлении новых конструкций в библиотеки F# и CLI.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLocalClassBindingsCannotBeInline">
        <source>Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.</source>
        <target state="translated">Привязки локального класса нельзя пометить как "inline" Рекомендуется удалить определение из класса, или не помечать его как "inline".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsMayNotHaveMembers">
        <source>Type abbreviations cannot have members</source>
        <target state="translated">Сокращения типов не могут иметь элементов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCheckedAtCompileTime">
        <source>As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.</source>
        <target state="translated">В версии F# 4.1 доступность сокращений типов проверяется во время компиляции. Рекомендуется изменить доступность сокращений типов. Если проигнорировать это предупреждение, возможны ошибки во время выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsMayNotHaveMembers">
        <source>Enumerations cannot have members</source>
        <target state="translated">Перечисления не могут содержать элементы</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembers">
        <source>Measure declarations may have only static members</source>
        <target state="translated">Определения измерений могут иметь только статические элементы</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainDoBindings">
        <source>Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings</source>
        <target state="translated">Структуры не могут содержать привязок "do", так как конструктор по умолчанию для структур не будет выполнять эти привязки</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMayNotContainLetBindings">
        <source>Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.</source>
        <target state="translated">Структуры не могут содержать определений значений, так как конструктор по умолчанию для структур не будет выполнять эти привязки. Попробуйте добавить к первичному конструктору для типа дополнительные аргументы.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStaticLetBindingsRequireClassesWithImplicitConstructors">
        <source>Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Статические определения значений можно использовать только в типах с первичными конструкторами. Попробуйте добавить в определение типа аргументы, напр. "type X(args) = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDeclarationsRequireStaticMembersNotConstructors">
        <source>Measure declarations may have only static members: constructors are not available</source>
        <target state="translated">Определения измерений могут иметь только статические элементы: конструкторы недоступны</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberAndLocalClassBindingHaveSameName">
        <source>A member and a local class binding both have the name '{0}'</source>
        <target state="translated">Элемент и привязка локального класса имеют одно имя "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
        <source>Type abbreviations cannot have interface declarations</source>
        <target state="translated">Сокращения типов не могут иметь объявлений интерфейса</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumerationsCannotHaveInterfaceDeclaration">
        <source>Enumerations cannot have interface declarations</source>
        <target state="translated">Перечисления не могут содержать объявления элементов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeIsNotInterfaceType0">
        <source>This type is not an interface type</source>
        <target state="translated">Этот тип не является интерфейсным типом</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllImplementedInterfacesShouldBeDeclared">
        <source>All implemented interfaces should be declared on the initial declaration of the type</source>
        <target state="translated">В исходном объявлении типа должны быть объявлены все реализованные интерфейсы</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
        <source>A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type</source>
        <target state="translated">Реализация по умолчанию для данного интерфейса уже была добавлена, так как в определении типа не была указана явная реализация интерфейса</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberNotPermittedInInterfaceImplementation">
        <source>This member is not permitted in an interface implementation</source>
        <target state="translated">Этот элемент не разрешается в реализации интерфейса</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclarationElementNotPermittedInAugmentation">
        <source>This declaration element is not permitted in an augmentation</source>
        <target state="translated">Данный элемент объявления не допускается в приращении</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotContainNestedTypes">
        <source>Types cannot contain nested type definitions</source>
        <target state="translated">Типы не могут содержать вложенные определения типов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeExceptionOrModule">
        <source>type, exception or module</source>
        <target state="translated">тип, исключение или модуль</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeOrModule">
        <source>type or module</source>
        <target state="translated">тип или модуль</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIStructuralEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type.</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" явно реализует интерфейс "System.IStructuralEquatable". Необходимо применить к типу атрибут "CustomEquality".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcImplementsIEquatableExplicitly">
        <source>The struct, record or union type '{0}' implements the interface 'System.IEquatable&lt;_&gt;' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'.</source>
        <target state="translated">Тип структуры, записи или объединения '{0}' явно реализует интерфейс 'System.IEquatable&lt;_&gt;'. Примените к типу атрибут 'CustomEquality' и укажите согласованную реализацию для неуниверсальной перегрузки 'System.Object.Equals(obj)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
        <source>Explicit type specifications cannot be used for exception constructors</source>
        <target state="translated">Явные спецификации типа не могут быть использованы для конструкторов исключений</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsShouldNotHaveArgumentList">
        <source>Exception abbreviations should not have argument lists</source>
        <target state="translated">Сокращения исключений не должны иметь списков аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
        <source>Abbreviations for Common IL exceptions cannot take arguments</source>
        <target state="translated">Сокращенные формы исключений общего промежуточного языка не поддерживают получение аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionAbbreviationsMustReferToValidExceptions">
        <source>Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception</source>
        <target state="translated">Сокращения исключений должны ссылаться на существующие исключения или типы F#, производные от System.Exception</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
        <source>Abbreviations for Common IL exception types must have a matching object constructor</source>
        <target state="translated">Сокращенные формы исключений общего промежуточного языка должны иметь соответствующий конструктор объекта</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNotAnException">
        <source>Not an exception</source>
        <target state="translated">Не является исключением</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidModuleName">
        <source>Invalid module name</source>
        <target state="translated">Недопустимое имя модуля</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeExtension">
        <source>Invalid type extension</source>
        <target state="translated">Недопустимое расширение типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributesOfTypeSpecifyMultipleKindsForType">
        <source>The attributes of this type specify multiple kinds for the type</source>
        <target state="translated">Атрибуты этого типа задают несколько видов типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcKindOfTypeSpecifiedDoesNotMatchDefinition">
        <source>The kind of the type specified by its attributes does not match the kind implied by its definition</source>
        <target state="translated">Вид типа, указанный его атрибутами, не совпадает с видом, подразумеваемым его определением</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMeasureDefinitionsCannotHaveTypeParameters">
        <source>Measure definitions cannot have type parameters</source>
        <target state="translated">Определения измерений не могут иметь параметры типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeRequiresDefinition">
        <source>This type requires a definition</source>
        <target state="translated">Для этого типа требуется определение</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationHasTypeParametersMissingOnType">
        <source>This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C&lt;'a&gt; = C of ...'.</source>
        <target state="translated">Сокращенная форма типа содержит один или несколько объявляемых параметров типа, которые не появляются в сокращаемом типе. В сокращенных формах типа должны использоваться все объявляемые параметры типа для сокращаемого типа. Удалите один или несколько параметров типа или используйте определение типа, включающее базовый тип, например, 'type C&lt;'a&gt; = C of ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
        <source>Structs, interfaces, enums and delegates cannot inherit from other types</source>
        <target state="translated">Структуры, интерфейсы, перечисления и делегаты не могут наследовать от других типов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesCannotInheritFromMultipleConcreteTypes">
        <source>Types cannot inherit from multiple concrete types</source>
        <target state="translated">Типы не могут наследовать от множественных конкретных типов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
        <source>Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute</source>
        <target state="translated">Типы записей, объединений, сокращений и структур не могут иметь атрибут "AllowNullLiteral"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
        <source>Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal</source>
        <target state="translated">Типы с атрибутом "AllowNullLiteral" могут наследоваться только от типов, поддерживающих пустые литералы, и реализовать только такие типы</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGenericTypesCannotHaveStructLayout">
        <source>Generic types cannot be given the 'StructLayout' attribute</source>
        <target state="translated">Базовые типы не могут получать атрибут "StructLayout"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyStructsCanHaveStructLayout">
        <source>Only structs and classes without primary constructors may be given the 'StructLayout' attribute</source>
        <target state="translated">Атрибут StructLayout может присваиваться только структурам и классам без первичных конструкторов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRepresentationOfTypeHiddenBySignature">
        <source>The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.</source>
        <target state="translated">Представление этого типа скрыто в подписи. Необходимо добавить атрибут, например, [&lt;Sealed&gt;], [&lt;Class&gt;] или [&lt;Interface&gt;], чтобы указать характеристики типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyClassesCanHaveAbstract">
        <source>Only classes may be given the 'AbstractClass' attribute</source>
        <target state="translated">Атрибут "AbstractClass" может присваиваться только классам</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
        <source>Only types representing units-of-measure may be given the 'Measure' attribute</source>
        <target state="translated">Атрибут "Measure" может присваиваться только типам, представляющим единицы измерения</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOverridesCannotHaveVisibilityDeclarations">
        <source>Accessibility modifiers are not permitted on overrides or interface implementations</source>
        <target state="translated">Модификаторы специальных возможностей не разрешаются на переопределениях или реализациях интерфейса</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDU">
        <source>Discriminated union types are always sealed</source>
        <target state="translated">Типы различаемых объединений всегда являются запечатанными</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedRecord">
        <source>Record types are always sealed</source>
        <target state="translated">Типы записей всегда являются запечатанными</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedAssemblyCode">
        <source>Assembly code types are always sealed</source>
        <target state="translated">Типы кодов сборок всегда являются запечатанными</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedStruct">
        <source>Struct types are always sealed</source>
        <target state="translated">Типы структур всегда являются запечатанными</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedDelegate">
        <source>Delegate types are always sealed</source>
        <target state="translated">Делегатные типы всегда являются запечатанными</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypesAreAlwaysSealedEnum">
        <source>Enum types are always sealed</source>
        <target state="translated">Перечисляемые типы всегда являются запечатанными</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesAndDelegatesCannotContainFields">
        <source>Interface types and delegate types cannot contain fields</source>
        <target state="translated">Типы интерфейсов и типы делегатов не могут содержать поля</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAbbreviatedTypesCannotBeSealed">
        <source>Abbreviated types cannot be given the 'Sealed' attribute</source>
        <target state="translated">Не допускается присваивание атрибута "Sealed" сокращенным типам</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromSealedType">
        <source>Cannot inherit a sealed type</source>
        <target state="translated">Не удается реализовать наследование от запечатанного типа</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromInterfaceType">
        <source>Cannot inherit from interface type. Use interface ... with instead.</source>
        <target state="translated">Не удается реализовать наследование от типа интерфейса. Вместо этого используйте выражение "interface ... with".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructTypesCannotContainAbstractMembers">
        <source>Struct types cannot contain abstract members</source>
        <target state="translated">Типы структуры не могут содержать абстрактных элементов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfaceTypesCannotBeSealed">
        <source>Interface types cannot be sealed</source>
        <target state="translated">Типы интерфейсов не могут быть запечатаны</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidDelegateSpecification">
        <source>Delegate specifications must be of the form 'typ -&gt; typ'</source>
        <target state="translated">Спецификации делегатов должны иметь вид 'typ -&gt; typ'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDelegatesCannotBeCurried">
        <source>Delegate specifications must not be curried types. Use 'typ * ... * typ -&gt; typ' for multi-argument delegates, and 'typ -&gt; (typ -&gt; typ)' for delegates returning function values.</source>
        <target state="translated">Спецификации делегата не могут иметь каррированные типы. Используйте 'typ * ... * typ -&gt; typ' для делегатов с несколькими аргументами и 'typ -&gt; (typ -&gt; typ)' для делегатов, возвращающих значения функций.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeForLiteralEnumeration">
        <source>Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char</source>
        <target state="translated">Перечисления литералов должны иметь тип int, uint, int16, uint16, int64, uint64, byte, sbyte или char</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclic">
        <source>This type definition involves an immediate cyclic reference through an abbreviation</source>
        <target state="translated">Определение данного типа включает прямую циклическую ссылку через сокращение</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionIsCyclicThroughInheritance">
        <source>This type definition involves an immediate cyclic reference through a struct field or inheritance relation</source>
        <target state="translated">Определение данного типа включает циклическую ссылку верхнего уровня через поле структуры или отношение наследования</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReservedSyntaxForAugmentation">
        <source>The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[&lt;Sealed&gt;] attribute to the type definition in the signature</source>
        <target state="translated">Синтаксис 'type X with ...' зарезервирован для дополнений. Типы, представления которых скрыт, но у которых есть участники, теперь объявляются в подписях с использованием синтаксиса 'type X = ...'. Также может потребоваться добавить атрибут '[&lt;Sealed&gt;] в определение типа в подписи</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
        <source>Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.</source>
        <target state="translated">Элементы, расширяющие типы интерфейса, делегатов или перечисления, должны помещаться в отдельном от определения типа модуле. Данный модуль должен либо иметь атрибут AutoOpen, либо открываться явно клиентским кодом для запуска элементов расширения в области.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal">
        <source>One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '{0}'</source>
        <target state="translated">В одном объявленном параметре типа или нескольких для этого расширения типа отсутствует ограничение типа или содержится неверное ограничение типа, не совпадающее с исходными ограничениями типа для "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
        <source>Type definitions may only have one 'inherit' specification and it must be the first declaration</source>
        <target state="translated">Определения типа могут иметь только одну спецификацию inherit, и она должна являться первым объявлением</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
        <source>'let' and 'do' bindings must come before member and interface definitions in type definitions</source>
        <target state="translated">Привязки let и do должны располагаться до определений элементов и интерфейсов в определениях типов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritDeclarationMissingArguments">
        <source>This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'.</source>
        <target state="translated">Данное объявление "inherit" указывает унаследованный тип, и не указывает аргументов. Рекомендуется предоставить аргументы, напр. "inherit BaseType(args)".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInheritConstructionCallNotPartOfImplicitSequence">
        <source>This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Данное объявление inherit содержит аргументы, но не находится в типе с первичным конструктором. Попробуйте добавить в определение типа аргументы, напр. "type X(args) = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLetAndDoRequiresImplicitConstructionSequence">
        <source>This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Это определение можно использовать только в типе с первичным конструктором. Попробуйте добавить в определение типа аргумент, напр. "type X(args) = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeAbbreviationsCannotHaveAugmentations">
        <source>Type abbreviations cannot have augmentations</source>
        <target state="translated">Сокращения типов не могут иметь приращений</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbreviationForNamespace">
        <source>The path '{0}' is a namespace. A module abbreviation may not abbreviate a namespace.</source>
        <target state="translated">Путь {0} указывает на пространство имен. Сокращение модуля не может уменьшать длину пространства имен.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeUsedInInvalidWay">
        <source>The type '{0}' is used in an invalid way. A value prior to '{1}' has an inferred type involving '{2}', which is an invalid forward reference.</source>
        <target state="translated">Тип "{0}" используется недопустимо. Значение перед "{1}" имеет логически выведенный тип, включающий "{2}", что является недопустимой короткой ссылкой.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberUsedInInvalidWay">
        <source>The member '{0}' is used in an invalid way. A use of '{1}' has been inferred prior to the definition of '{2}', which is an invalid forward reference.</source>
        <target state="translated">Элемент "{0}" используется недопустимо. Использование "{1}" было логически выведено перед определением "{2}", что является недопустимой короткой ссылкой.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttributeAutoOpenWasIgnored">
        <source>The attribute 'AutoOpen(\"{0}\")' in the assembly '{1}' did not refer to a valid module or namespace in that assembly and has been ignored</source>
        <target state="translated">Атрибут "AutoOpen(\"{0}\")" в сборке "{1}" пропущен, поскольку он не ссылается на допустимые модуль или пространство имен в этой сборке</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUndefinedValue">
        <source>Undefined value '{0}'</source>
        <target state="translated">Неопределенное значение "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLabelNotFound">
        <source>Label {0} not found</source>
        <target state="translated">Метка {0} не найдена</target>
        <note />
      </trans-unit>
      <trans-unit id="ilIncorrectNumberOfTypeArguments">
        <source>Incorrect number of type arguments to local call</source>
        <target state="translated">Недопустимое число аргументов типа для локального вызова</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDynamicInvocationNotSupported">
        <source>Dynamic invocation of {0} is not supported</source>
        <target state="translated">Динамический вызов {0} не поддерживается</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfLiteralFieldIsInvalid">
        <source>Taking the address of a literal field is invalid</source>
        <target state="translated">Недопустимое получение адреса поля литерала</target>
        <note />
      </trans-unit>
      <trans-unit id="ilAddressOfValueHereIsInvalid">
        <source>This operation involves taking the address of a value '{0}' represented using a local variable or other special representation. This is invalid.</source>
        <target state="translated">В этой операции осуществляется получение адреса значения "{0}", представленного с помощью локальной переменной или другого специального представления. Это не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilCustomMarshallersCannotBeUsedInFSharp">
        <source>Custom marshallers cannot be specified in F# code. Consider using a C# helper function.</source>
        <target state="translated">Не допускается указание пользовательского маршаллера в коде F#. Рекомендуется использовать вспомогательную функцию C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMarshalAsAttributeCannotBeDecoded">
        <source>The MarshalAs attribute could not be decoded</source>
        <target state="translated">Не удается декодировать атрибут MarshalAs</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignatureForExternalFunctionContainsTypeParameters">
        <source>The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.</source>
        <target state="translated">Сигнатура этой внешней функции содержит параметры типа. Ограничьте типы аргументов и возвращаемых значений, чтобы обозначить типы соответствующих функций C.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDllImportAttributeCouldNotBeDecoded">
        <source>The DllImport attribute could not be decoded</source>
        <target state="translated">Не удается декодировать атрибут DllImport</target>
        <note />
      </trans-unit>
      <trans-unit id="ilLiteralFieldsCannotBeSet">
        <source>Literal fields cannot be set</source>
        <target state="translated">Поля литералов нельзя задавать</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStaticMethodIsNotLambda">
        <source>GenSetStorage: {0} was represented as a static method but was not an appropriate lambda expression</source>
        <target state="translated">GenSetStorage: {0} представлен как статический метод, однако не является допустимым лямбда-выражением</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMutableVariablesCannotEscapeMethod">
        <source>Mutable variables cannot escape their method</source>
        <target state="translated">Изменяемые переменные не могут обходить собственные методы</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedUnrealizedValue">
        <source>Compiler error: unexpected unrealized value</source>
        <target state="translated">Ошибка компилятора: недопустимое нереализованное значение</target>
        <note />
      </trans-unit>
      <trans-unit id="ilMainModuleEmpty">
        <source>Main module of program is empty: nothing will happen when it is run</source>
        <target state="translated">Основной модуль программы пуст: при запуске программы не будет выполнено никаких действий</target>
        <note />
      </trans-unit>
      <trans-unit id="ilTypeCannotBeUsedForLiteralField">
        <source>This type cannot be used for a literal field</source>
        <target state="translated">Этот тип не может использоваться для поля литерала</target>
        <note />
      </trans-unit>
      <trans-unit id="ilUnexpectedGetSetAnnotation">
        <source>Unexpected GetSet annotation on a property</source>
        <target state="translated">Недопустимая аннотация GetSet для свойства</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldOffsetAttributeCouldNotBeDecoded">
        <source>The FieldOffset attribute could not be decoded</source>
        <target state="translated">Не удается декодировать атрибут FieldOffset</target>
        <note />
      </trans-unit>
      <trans-unit id="ilStructLayoutAttributeCouldNotBeDecoded">
        <source>The StructLayout attribute could not be decoded</source>
        <target state="translated">Не удается декодировать атрибут StructLayout</target>
        <note />
      </trans-unit>
      <trans-unit id="ilDefaultAugmentationAttributeCouldNotBeDecoded">
        <source>The DefaultAugmentation attribute could not be decoded</source>
        <target state="translated">Не удается декодировать атрибут DefaultAugmentation</target>
        <note />
      </trans-unit>
      <trans-unit id="ilReflectedDefinitionsCannotUseSliceOperator">
        <source>Reflected definitions cannot contain uses of the prefix splice operator '%'</source>
        <target state="translated">Отраженные определения не могут включать использование оператора соединения префикса "%"</target>
        <note />
      </trans-unit>
      <trans-unit id="optsProblemWithCodepage">
        <source>Problem with codepage '{0}': {1}</source>
        <target state="translated">Неполадка с кодовой страницей "{0}": {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyright">
        <source>Copyright (c) Microsoft Corporation. All Rights Reserved.</source>
        <target state="translated">© Корпорация Майкрософт (Microsoft Corporation). Все права защищены.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCopyrightCommunity">
        <source>Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</source>
        <target state="translated">Распространяется бесплатно по лицензии MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNameOfOutputFile">
        <source>Name of the output file (Short form: -o)</source>
        <target state="translated">Имя выходного файла (краткая форма: -o)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildConsole">
        <source>Build a console executable</source>
        <target state="translated">Собрать консольный исполняемый файл</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildWindows">
        <source>Build a Windows executable</source>
        <target state="translated">Выполнить сборку исполняемого файла Windows</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildLibrary">
        <source>Build a library (Short form: -a)</source>
        <target state="translated">Собрать библиотеку (краткая форма: -a)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBuildModule">
        <source>Build a module that can be added to another assembly</source>
        <target state="translated">Сборка модуля, который может быть добавлен в другую сборку</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDelaySign">
        <source>Delay-sign the assembly using only the public portion of the strong name key</source>
        <target state="translated">Использовать отложенную подпись для сборки, используя только открытую часть ключа строгого имени</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPublicSign">
        <source>Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed</source>
        <target state="translated">Выполнить общедоступную подпись сборки, используя только открытую часть ключа строгого имени, и пометить сборку как подписанную</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWriteXml">
        <source>Write the xmldoc of the assembly to the given file</source>
        <target state="translated">Запись xmldoc сборки в заданный файл</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyFile">
        <source>Specify a strong name key file</source>
        <target state="translated">Укажите файл ключей строгого имени</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStrongKeyContainer">
        <source>Specify a strong name key container</source>
        <target state="translated">Укажите контейнер ключей строгого имени</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPlatform">
        <source>Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.</source>
        <target state="translated">Выберите платформы, на которых может выполняться этот код: x86, Itanium, x64, anycpu32bitpreferred или anycpu. По умолчанию используется любой процессор (anycpu).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoOpt">
        <source>Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.</source>
        <target state="translated">Включать только данные оптимизации, необходимые для реализации встроенных конструкций. Отключение межмодульного встраивания и повышение совместимости на уровне двоичного кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoInterface">
        <source>Don't add a resource to the generated assembly containing F#-specific metadata</source>
        <target state="translated">Не добавлять ресурс к создаваемой сборке, содержащей специальные метаданные F#</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSig">
        <source>Print the inferred interface of the assembly to a file</source>
        <target state="translated">Печатать выведенный интерфейс сборки в файл</target>
        <note />
      </trans-unit>
      <trans-unit id="optsReference">
        <source>Reference an assembly (Short form: -r)</source>
        <target state="translated">Ссылка на сборку (краткая форма: -r)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32res">
        <source>Specify a Win32 resource file (.res)</source>
        <target state="translated">Укажите файл ресурсов Win32 (.res)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWin32manifest">
        <source>Specify a Win32 manifest file</source>
        <target state="translated">Задать файл манифеста Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowin32manifest">
        <source>Do not include the default Win32 manifest</source>
        <target state="translated">Не включать манифест Win32 по умолчанию</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedAllSource">
        <source>Embed all source files in the portable PDB file</source>
        <target state="translated">Внедрить все исходные файлы в переносимый PDB-файл</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbedSource">
        <source>Embed specific source files in the portable PDB file</source>
        <target state="translated">Внедрить конкретные исходные файлы в переносимый PDB-файл</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLink">
        <source>Source link information file to embed in the portable PDB file</source>
        <target state="translated">Файл со сведениями о компоновке источников, внедряемый в переносимый PDB-файл</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmbeddedSourceRequirePortablePDBs">
        <source>--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">Параметр --embed поддерживается только при создании переносимого PDB-файла (--debug:portable или --debug:embedded).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSourceLinkRequirePortablePDBs">
        <source>--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)</source>
        <target state="translated">Параметр --sourcelink поддерживается только при создании переносимого PDB-файла (--debug:portable или --debug:embedded).</target>
        <note />
      </trans-unit>
      <trans-unit id="srcFileTooLarge">
        <source>Source file is too large to embed in a portable PDB</source>
        <target state="translated">Исходный файл слишком велик для внедрения в переносимый PDB-файл.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResource">
        <source>Embed the specified managed resource</source>
        <target state="translated">Внедрить указанный управляемый ресурс</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLinkresource">
        <source>Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]</source>
        <target state="translated">Привязка указанного ресурса к этой сборке, где формат resinfo имеет следующий вид: &lt;файл&gt;[,&lt;имя строки&gt;[,public|private]]</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebugPM">
        <source>Emit debug information (Short form: -g)</source>
        <target state="translated">Вывод отладочной информации (краткая форма: -g)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDebug">
        <source>Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file).</source>
        <target state="translated">Укажите тип отладки: full, portable, embedded, pdbonly (если тип отладки не указан, по умолчанию используется тип "{0}", позволяющий подключить отладчик к выполняющейся программе; тип portable представляет собой кроссплатформенный формат; тип embedded — кроссплатформенный формат, встроенный в выходной файл).</target>
        <note />
      </trans-unit>
      <trans-unit id="optsOptimize">
        <source>Enable optimizations (Short form: -O)</source>
        <target state="translated">Включить оптимизацию (краткая форма: -O)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTailcalls">
        <source>Enable or disable tailcalls</source>
        <target state="translated">Включение или отключение концевых вызовов</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDeterministic">
        <source>Produce a deterministic assembly (including module version GUID and timestamp)</source>
        <target state="translated">Создать детерминированную сборку (включая GUID версии модуля и метку времени)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCrossoptimize">
        <source>Enable or disable cross-module optimizations</source>
        <target state="translated">Включение или отключение межмодульной оптимизации</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserrorPM">
        <source>Report all warnings as errors</source>
        <target state="translated">Обрабатывать все предупреждения как ошибки</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnaserror">
        <source>Report specific warnings as errors</source>
        <target state="translated">Обрабатывать указанные предупреждения как ошибки</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarn">
        <source>Set a warning level (0-5)</source>
        <target state="translated">Задать уровень предупреждений (0-5)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNowarn">
        <source>Disable specific warning messages</source>
        <target state="translated">Отключить указанные предупреждения</target>
        <note />
      </trans-unit>
      <trans-unit id="optsWarnOn">
        <source>Enable specific warnings that may be off by default</source>
        <target state="translated">Включить конкретные предупреждения, которые по умолчанию могут быть отключенными</target>
        <note />
      </trans-unit>
      <trans-unit id="optsChecked">
        <source>Generate overflow checks</source>
        <target state="translated">Сформировать проверки переполнений</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDefine">
        <source>Define conditional compilation symbols (Short form: -d)</source>
        <target state="translated">Определить символы условной компиляции (краткая форма: -d)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsMlcompatibility">
        <source>Ignore ML compatibility warnings</source>
        <target state="translated">Игнорировать предупреждения многоязыковой совместимости</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNologo">
        <source>Suppress compiler copyright message</source>
        <target state="translated">Запрещает отображение сообщения компилятора об авторских правах</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelp">
        <source>Display this usage message (Short form: -?)</source>
        <target state="translated">Вывод данного сообщения об использовании (краткая форма: -?)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFile">
        <source>Read response file for more options</source>
        <target state="translated">Считывать файл ответа с дополнительными параметрами</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCodepage">
        <source>Specify the codepage used to read source files</source>
        <target state="translated">Укажите кодовую страницу, которая будет использоваться для чтения исходных файлов</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUtf8output">
        <source>Output messages in UTF-8 encoding</source>
        <target state="translated">Выводит сообщения в кодировке UTF-8</target>
        <note />
      </trans-unit>
      <trans-unit id="optsFullpaths">
        <source>Output messages with fully qualified paths</source>
        <target state="translated">Вывод сообщений с полными путями</target>
        <note />
      </trans-unit>
      <trans-unit id="optsLib">
        <source>Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)</source>
        <target state="translated">Укажите каталог для поиска включаемых файлов, который будет использоваться для разрешения исходных файлов и сборок (краткая форма: -I)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsBaseaddress">
        <source>Base address for the library to be built</source>
        <target state="translated">Базовый адрес библиотеки, для которой будет выполнена сборка</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoframework">
        <source>Do not reference the default CLI assemblies by default</source>
        <target state="translated">Не обращаться к сборкам CLI по умолчанию</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStandalone">
        <source>Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated</source>
        <target state="translated">Статическая компоновка библиотеки F# и всех зависимых от нее библиотек DLL, на которые существуют ссылки, в создаваемую сборку</target>
        <note />
      </trans-unit>
      <trans-unit id="optsStaticlink">
        <source>Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.</source>
        <target state="translated">Статическая компоновка заданной сборки и всех зависимых от нее библиотек DLL, на которые существуют ссылки. Используйте имя сборки, например, mylib, вместо имени библиотеки DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResident">
        <source>Use a resident background compilation service to improve compiler startup times.</source>
        <target state="translated">Используйте службу фоновой резидентной компиляции, чтобы сократить время запуска компилятора.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPdb">
        <source>Name the output debug file</source>
        <target state="translated">Имя выходного файла отладки</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSimpleresolution">
        <source>Resolve assembly references using directory-based rules rather than MSBuild resolution</source>
        <target state="translated">Разрешать ссылки на сборку с помощью основанных на каталоге правил вместо разрешения MSBuild</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedTarget">
        <source>Unrecognized target '{0}', expected 'exe', 'winexe', 'library' or 'module'</source>
        <target state="translated">Нераспознанный целевой формат "{0}"; требуется "exe", "winexe", "library" или "module"</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnrecognizedDebugType">
        <source>Unrecognized debug type '{0}', expected 'pdbonly' or 'full'</source>
        <target state="translated">Нераспознанный тип отладки "{0}"; требуется "pdbonly" или "full"</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidWarningLevel">
        <source>Invalid warning level '{0}'</source>
        <target state="translated">Недопустимый уровень предупреждения "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="optsShortFormOf">
        <source>Short form of '{0}'</source>
        <target state="translated">Краткая форма "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDeprecatedMsg">
        <source>The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.</source>
        <target state="translated">Параметр командной строки "--cliroot" не рекомендуется к использованию. Используйте явную ссылку на конкретную копию библиотеки mscorlib.dll.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsClirootDescription">
        <source>Use to override where the compiler looks for mscorlib.dll and framework components</source>
        <target state="translated">Используйте этот параметр, чтобы переопределить место для поиска компилятором библиотеки mscorlib.dll и компонентов инфраструктуры</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerOutputFiles">
        <source>- OUTPUT FILES -</source>
        <target state="translated">- ВЫХОДНЫЕ ФАЙЛЫ -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerInputFiles">
        <source>- INPUT FILES -</source>
        <target state="translated">- ВХОДНЫЕ ФАЙЛЫ -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerResources">
        <source>- RESOURCES -</source>
        <target state="translated">- РЕСУРСЫ -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerCodeGen">
        <source>- CODE GENERATION -</source>
        <target state="translated">- ФОРМИРОВАНИЕ КОДА -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerAdvanced">
        <source>- ADVANCED -</source>
        <target state="translated">- ДОПОЛНИТЕЛЬНО -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerMisc">
        <source>- MISCELLANEOUS -</source>
        <target state="translated">- ПРОЧЕЕ -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerLanguage">
        <source>- LANGUAGE -</source>
        <target state="translated">- ЯЗЫК -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsHelpBannerErrsAndWarns">
        <source>- ERRORS AND WARNINGS -</source>
        <target state="translated">- ОШИБКИ И ПРЕДУПРЕЖДЕНИЯ -</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownArgumentToTheTestSwitch">
        <source>Unknown --test argument: '{0}'</source>
        <target state="translated">Неизвестный аргумент --test: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUnknownPlatform">
        <source>Unrecognized platform '{0}', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'</source>
        <target state="translated">Нераспознанная платформа "{0}"; допустимые значения: x86, x64, Itanium, anycpu32bitpreferred и anycpu</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInternalNoDescription">
        <source>The command-line option '{0}' is for test purposes only</source>
        <target state="translated">Параметр командной строки "{0}" предназначен только для тестирования</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLONoDescription">
        <source>The command-line option '{0}' has been deprecated</source>
        <target state="translated">Параметр командной строки "{0}" не рекомендуется к использованию</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLODeprecatedSuggestAlternative">
        <source>The command-line option '{0}' has been deprecated. Use '{1}' instead.</source>
        <target state="translated">Параметр командной строки "{0}" не рекомендуется к использованию. Вместо этого используйте объект "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="optsDCLOHtmlDoc">
        <source>The command-line option '{0}' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.</source>
        <target state="translated">Параметр командной строки "{0}" не рекомендуется к использованию. Функции создания документа HTML теперь реализуются с помощью средства из состава пакета F# Power Pack.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsConsoleColors">
        <source>Output warning and error messages in color</source>
        <target state="translated">Цветные выходные предупреждения и сообщения об ошибках</target>
        <note />
      </trans-unit>
      <trans-unit id="optsUseHighEntropyVA">
        <source>Enable high-entropy ASLR</source>
        <target state="translated">Включить технологию ASLR с высокой энтропией</target>
        <note />
      </trans-unit>
      <trans-unit id="optsSubSystemVersion">
        <source>Specify subsystem version of this assembly</source>
        <target state="translated">Укажите версию подсистемы этой сборки</target>
        <note />
      </trans-unit>
      <trans-unit id="optsTargetProfile">
        <source>Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib</source>
        <target state="translated">Укажите профиль целевой платформы этой сборки. Допустимые значения: mscorlib, netcore и netstandard. Значение по умолчанию — mscorlib.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsEmitDebugInfoInQuotations">
        <source>Emit debug information in quotations</source>
        <target state="translated">Вывод отладочной информации в кавычках</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPreferredUiLang">
        <source>Specify the preferred output language culture name (e.g. es-ES, ja-JP)</source>
        <target state="translated">Укажите предпочитаемое имя языка и региональных параметров (например, es-ES, ja-JP)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsNoCopyFsharpCore">
        <source>Don't copy FSharp.Core.dll along the produced binaries</source>
        <target state="translated">Не копировать FSharp.Core.dll вместе с созданными двоичными файлами</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidSubSystemVersion">
        <source>Invalid version '{0}' for '--subsystemversion'. The version must be 4.00 or greater.</source>
        <target state="translated">Недопустимая версия "{0}" для "--subsystemversion". Должна быть версия 4.00 или больше.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidTargetProfile">
        <source>Invalid value '{0}' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.</source>
        <target state="translated">Недопустимое значение "{0}" параметра --targetprofile; допустимые значения: mscorlib, netcore и netstandard.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFullName">
        <source>Full name</source>
        <target state="translated">Полное имя</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoOtherOverloads">
        <source>and {0} other overloads</source>
        <target state="translated">и {0} других перегрузок</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoUnionCase">
        <source>union case</source>
        <target state="translated">ветвь объединения</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActivePatternResult">
        <source>active pattern result</source>
        <target state="translated">активный результат шаблона</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoActiveRecognizer">
        <source>active recognizer</source>
        <target state="translated">активный распознаватель</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoField">
        <source>field</source>
        <target state="translated">Поле</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoEvent">
        <source>event</source>
        <target state="translated">событие</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoProperty">
        <source>property</source>
        <target state="translated">Свойство</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoExtension">
        <source>extension</source>
        <target state="translated">Расширение</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCustomOperation">
        <source>custom operation</source>
        <target state="translated">пользовательская операция</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoArgument">
        <source>argument</source>
        <target state="translated">Аргумент</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoPatternVariable">
        <source>patvar</source>
        <target state="translated">patvar</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespace">
        <source>namespace</source>
        <target state="translated">пространство имен</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoModule">
        <source>module</source>
        <target state="translated">модуль</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoNamespaceOrModule">
        <source>namespace/module</source>
        <target state="translated">пространство имен/модуль</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromFirst">
        <source>from {0}</source>
        <target state="translated">из {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoFromNext">
        <source>also from {0}</source>
        <target state="translated">также из {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedProperty">
        <source>generated property</source>
        <target state="translated">созданное свойство</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoGeneratedType">
        <source>generated type</source>
        <target state="translated">созданный тип</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersKey">
        <source>Found by AssemblyFolders registry key</source>
        <target state="translated">Найдено по разделу реестра AssemblyFolders</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionFoundByAssemblyFoldersExKey">
        <source>Found by AssemblyFoldersEx registry key</source>
        <target state="translated">Найдено по разделу реестра AssemblyFoldersEx</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionNetFramework">
        <source>.NET Framework</source>
        <target state="translated">.NET Framework</target>
        <note />
      </trans-unit>
      <trans-unit id="assemblyResolutionGAC">
        <source>Global Assembly Cache</source>
        <target state="translated">Глобальный кэш сборок</target>
        <note />
      </trans-unit>
      <trans-unit id="recursiveClassHierarchy">
        <source>Recursive class hierarchy in type '{0}'</source>
        <target state="translated">Рекурсивная иерархия классов в типе "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRecursiveReferenceToAbstractSlot">
        <source>Invalid recursive reference to an abstract slot</source>
        <target state="translated">Недопустимая рекурсивная ссылка на абстрактный слот</target>
        <note />
      </trans-unit>
      <trans-unit id="eventHasNonStandardType">
        <source>The event '{0}' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit {1} and {2} methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent&lt;_&gt;' or 'IEvent&lt;_,_&gt;'.</source>
        <target state="translated">Событие "{0}" имеет нестандартный тип. Если это событие объявлено на другом языке CLI, для доступа к этому событию могут потребоваться явные методы {1} и {2}. Если это событие объявлено на языке F #, укажите тип инициализации события 'IDelegateEvent&lt;_&gt;' или 'IEvent&lt;_,_&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeIsNotAccessible">
        <source>The type '{0}' is not accessible from this code location</source>
        <target state="translated">Тип "{0}" недоступен из данного расположения в коде</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCasesAreNotAccessible">
        <source>The union cases or fields of the type '{0}' are not accessible from this code location</source>
        <target state="translated">Случаи объединения или поля типа "{0}" недоступны из данного расположения в коде</target>
        <note />
      </trans-unit>
      <trans-unit id="valueIsNotAccessible">
        <source>The value '{0}' is not accessible from this code location</source>
        <target state="translated">Значение "{0}" недоступно из данного расположения в коде</target>
        <note />
      </trans-unit>
      <trans-unit id="unionCaseIsNotAccessible">
        <source>The union case '{0}' is not accessible from this code location</source>
        <target state="translated">Случай объединения "{0}" недоступен из данного расположения в коде</target>
        <note />
      </trans-unit>
      <trans-unit id="fieldIsNotAccessible">
        <source>The record, struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">Поле записи, структуры или класса "{0}" недоступно из этой точки кода</target>
        <note />
      </trans-unit>
      <trans-unit id="structOrClassFieldIsNotAccessible">
        <source>The struct or class field '{0}' is not accessible from this code location</source>
        <target state="translated">Поле структуры или класса "{0}" недоступно из этой точки кода</target>
        <note />
      </trans-unit>
      <trans-unit id="experimentalConstruct">
        <source>This construct is experimental</source>
        <target state="translated">Экспериментальная конструкция</target>
        <note />
      </trans-unit>
      <trans-unit id="noInvokeMethodsFound">
        <source>No Invoke methods found for delegate type</source>
        <target state="translated">Отсутствуют методы Invoke для типа делегата</target>
        <note />
      </trans-unit>
      <trans-unit id="moreThanOneInvokeMethodFound">
        <source>More than one Invoke method found for delegate type</source>
        <target state="translated">Обнаружено более одного метода Invoke для типа делегата</target>
        <note />
      </trans-unit>
      <trans-unit id="delegatesNotAllowedToHaveCurriedSignatures">
        <source>Delegates are not allowed to have curried signatures</source>
        <target state="translated">В делегатах не поддерживаются переданные сигнатуры</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrUnexpectedTExpr">
        <source>Unexpected Expr.TyChoose</source>
        <target state="translated">Непредвиденное значение Expr.TyChoose</target>
        <note />
      </trans-unit>
      <trans-unit id="tlrLambdaLiftingOptimizationsNotApplied">
        <source>Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.</source>
        <target state="translated">Примечание. Оптимизации замыкания лямбда-выражения не были применены, так как данная локальная ограниченная универсальная функция была использована в качестве первого значения класса. Устранить эту проблему можно путем добавления ограничений типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifiersContainingAtSymbolReserved">
        <source>Identifiers containing '@' are reserved for use in F# code generation</source>
        <target state="translated">Идентификаторы, содержащие "@", зарезервированы для будущего использования при создании кода на языке F#</target>
        <note />
      </trans-unit>
      <trans-unit id="lexhlpIdentifierReserved">
        <source>The identifier '{0}' is reserved for future use by F#</source>
        <target state="translated">Идентификатор "{0}" зарезервирован для будущего использования в языке F#</target>
        <note />
      </trans-unit>
      <trans-unit id="patcMissingVariable">
        <source>Missing variable '{0}'</source>
        <target state="translated">Отсутствует переменная "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="patcPartialActivePatternsGenerateOneResult">
        <source>Partial active patterns may only generate one result</source>
        <target state="translated">Частично активные шаблоны могут возвращать только один результат</target>
        <note />
      </trans-unit>
      <trans-unit id="impTypeRequiredUnavailable">
        <source>The type '{0}' is required here and is unavailable. You must add a reference to assembly '{1}'.</source>
        <target state="translated">Требуемый здесь тип "{0}" недоступен. Следует добавить ссылку на сборку "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferencedTypeCouldNotBeFoundInAssembly">
        <source>A reference to the type '{0}' in assembly '{1}' was found, but the type could not be found in that assembly</source>
        <target state="translated">Обнаружена ссылка на тип "{0}" в сборке "{1}", который отсутствует в этой сборке</target>
        <note />
      </trans-unit>
      <trans-unit id="impNotEnoughTypeParamsInScopeWhileImporting">
        <source>Internal error or badly formed metadata: not enough type parameters were in scope while importing</source>
        <target state="translated">Внутренняя ошибка или поврежденные метаданные: недостаточно параметров типа в области видимости в процессе импорта</target>
        <note />
      </trans-unit>
      <trans-unit id="impReferenceToDllRequiredByAssembly">
        <source>A reference to the DLL {0} is required by assembly {1}. The imported type {2} is located in the first assembly and could not be resolved.</source>
        <target state="translated">Ссылка на библиотеку DLL {0} требуется для сборки {1}. Импортированный тип {2} расположен в первой сборке и не может быть разрешен.</target>
        <note />
      </trans-unit>
      <trans-unit id="impImportedAssemblyUsesNotPublicType">
        <source>An imported assembly uses the type '{0}' but that type is not public</source>
        <target state="translated">В импортированной сборке используется тип "{0}", который не является открытым</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButIncomplete">
        <source>The value '{0}' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible</source>
        <target state="translated">Значение "{0}" отмечено как "inline", однако в его реализации используется недостаточно доступная внутренняя или закрытая функция</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineButWasNotBoundInTheOptEnv">
        <source>The value '{0}' was marked inline but was not bound in the optimization environment</source>
        <target state="translated">Значение "{0}" отмечено как "inline", однако не было привязано в среде оптимизации</target>
        <note />
      </trans-unit>
      <trans-unit id="optLocalValueNotFoundDuringOptimization">
        <source>Local value {0} not found during optimization</source>
        <target state="translated">В процессе оптимизации не найдено локальное значение {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineHasUnexpectedValue">
        <source>A value marked as 'inline' has an unexpected value</source>
        <target state="translated">Недопустимое значение для значения, отмеченного как "inline"</target>
        <note />
      </trans-unit>
      <trans-unit id="optValueMarkedInlineCouldNotBeInlined">
        <source>A value marked as 'inline' could not be inlined</source>
        <target state="translated">Не удалось встроить значение, отмеченное как "inline"</target>
        <note />
      </trans-unit>
      <trans-unit id="optFailedToInlineValue">
        <source>Failed to inline the value '{0}' marked 'inline', perhaps because a recursive value was marked 'inline'</source>
        <target state="translated">Не удалось встроить значение "{0}", отмеченное как "inline", возможно, в связи с отметкой рекурсивного значения как "inline"</target>
        <note />
      </trans-unit>
      <trans-unit id="optRecursiveValValue">
        <source>Recursive ValValue {0}</source>
        <target state="translated">Рекурсивное значение ValValue {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltIncorrentIndentationOfIn">
        <source>The indentation of this 'in' token is incorrect with respect to the corresponding 'let'</source>
        <target state="translated">Недопустимый отступ токена "in" по отношению к соответствующему токену "let"</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltTokenIsOffsideOfContextStartedEarlier">
        <source>Possible incorrect indentation: this token is offside of context started at position {0}. Try indenting this token further or using standard formatting conventions.</source>
        <target state="translated">Возможно, неправильные отступы: этот токен находится вне контекста, начиная с позиции {0}. Попробуйте увеличить отступ токена или использовать стандартные соглашения о форматировании.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexfltSeparatorTokensOfPatternMatchMisaligned">
        <source>The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.</source>
        <target state="translated">Токены "|", разделяющие правила этого сопоставления шаблону, неправильно выровнены по одному столбцу. Рекомендуется выровнять код или увеличить отступ.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidModuleExprType">
        <source>Invalid module/expression/type</source>
        <target state="translated">Недопустимый модуль, выражение или тип</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationNeededToDisambiguateTypesWithSameName">
        <source>Multiple types exist called '{0}', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '{1}'.</source>
        <target state="translated">Существует несколько типов, вызываемых "{0}" и принимающих различное число универсальных параметров. Предоставьте создание экземпляра типа, чтобы однозначно определить разрешение типа, например, "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="nrTypeInstantiationIsMissingAndCouldNotBeInferred">
        <source>The instantiation of the generic type '{0}' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '{1}'.</source>
        <target state="translated">Создание экземпляра универсального типа "{0}" отсутствует и не может быть выведено из типа аргументов или возвращаемого значения этого элемента. Рекомендуется предоставить создание экземпляра типа при доступе к типу, например, "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="nrGlobalUsedOnlyAsFirstName">
        <source>'global' may only be used as the first name in a qualified path</source>
        <target state="translated">Параметр "global" может использоваться только в качестве первого имени в полном пути</target>
        <note />
      </trans-unit>
      <trans-unit id="nrIsNotConstructorOrLiteral">
        <source>This is not a constructor or literal, or a constructor is being used incorrectly</source>
        <target state="translated">Объект не является конструктором или литералом, либо конструктор используется неправильно</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnexpectedEmptyLongId">
        <source>Unexpected empty long identifier</source>
        <target state="translated">Недопустимый пустой длинный идентификатор</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordDoesNotContainSuchLabel">
        <source>The record type '{0}' does not contain a label '{1}'.</source>
        <target state="translated">Тип записи "{0}" не содержит метку "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidFieldLabel">
        <source>Invalid field label</source>
        <target state="translated">Недопустимая метка поля</target>
        <note />
      </trans-unit>
      <trans-unit id="nrInvalidExpression">
        <source>Invalid expression '{0}'</source>
        <target state="translated">Недопустимое выражение "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="nrNoConstructorsAvailableForType">
        <source>No constructors are available for the type '{0}'</source>
        <target state="translated">Недоступны конструкторы для типа "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="nrUnionTypeNeedsQualifiedAccess">
        <source>The union type for union case '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('{1}') in the name you are using.</source>
        <target state="translated">Тип объединения для ветви объединения "{0}" определен с RequireQualifiedAccessAttribute. Включите имя типа объединения ("{1}") в используемое имя.</target>
        <note />
      </trans-unit>
      <trans-unit id="nrRecordTypeNeedsQualifiedAccess">
        <source>The record type for the record field '{0}' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('{1}') in the name you are using.</source>
        <target state="translated">Тип записи для поля записи "{0}" определен с RequireQualifiedAccessAttribute. Включите имя типа записи ("{1}") в используемое имя.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingPdb">
        <source>Unexpected error creating debug information file '{0}'</source>
        <target state="translated">Непредвиденная ошибка при создании файла отладочной информации "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideIntegerRange">
        <source>This number is outside the allowable range for this integer type</source>
        <target state="translated">Это число находится вне допустимого диапазона для целого типа</target>
        <note />
      </trans-unit>
      <trans-unit id="lexCharNotAllowedInOperatorNames">
        <source>'{0}' is not permitted as a character in operator names and is reserved for future use</source>
        <target state="translated">{0} не может использоваться в качестве знака в именах операторов и зарезервирован для будущего использования</target>
        <note />
      </trans-unit>
      <trans-unit id="lexUnexpectedChar">
        <source>Unexpected character '{0}'</source>
        <target state="translated">Недопустимый символ "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="lexByteArrayCannotEncode">
        <source>This byte array literal contains characters that do not encode as a single byte</source>
        <target state="translated">Этот литерал массива байтов содержит знаки, не поддерживающие однобайтовую кодировку</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIdentEndInMarkReserved">
        <source>Identifiers followed by '{0}' are reserved for future use</source>
        <target state="translated">Идентификаторы, после которых следует "{0}", зарезервированы для будущего использования</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSigned">
        <source>This number is outside the allowable range for 8-bit signed integers</source>
        <target state="translated">Это число находится вне допустимого диапазона для 8-битных целых чисел со знаком</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitSignedHex">
        <source>This number is outside the allowable range for hexadecimal 8-bit signed integers</source>
        <target state="translated">Это число находится вне допустимого диапазона для 8-битных шестнадцатеричных целых чисел со знаком</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideEightBitUnsigned">
        <source>This number is outside the allowable range for 8-bit unsigned integers</source>
        <target state="translated">Это число находится вне допустимого диапазона для 8-битных целых чисел без знака</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitSigned">
        <source>This number is outside the allowable range for 16-bit signed integers</source>
        <target state="translated">Это число находится вне допустимого диапазона для 16-битных целых чисел со знаком</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixteenBitUnsigned">
        <source>This number is outside the allowable range for 16-bit unsigned integers</source>
        <target state="translated">Это число находится вне допустимого диапазона для 16-битных целых чисел без знака</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitSigned">
        <source>This number is outside the allowable range for 32-bit signed integers</source>
        <target state="translated">Это число находится вне допустимого диапазона для 32-битных целых чисел со знаком</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideThirtyTwoBitUnsigned">
        <source>This number is outside the allowable range for 32-bit unsigned integers</source>
        <target state="translated">Это число находится вне допустимого диапазона для 32-битных целых чисел без знака</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitSigned">
        <source>This number is outside the allowable range for 64-bit signed integers</source>
        <target state="translated">Это число находится вне допустимого диапазона для 64-битных целых чисел со знаком</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideSixtyFourBitUnsigned">
        <source>This number is outside the allowable range for 64-bit unsigned integers</source>
        <target state="translated">Это число находится вне допустимого диапазона для 64-битных целых чисел без знака</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeSigned">
        <source>This number is outside the allowable range for signed native integers</source>
        <target state="translated">Это число находится вне допустимого диапазона для собственных целых чисел со знаком</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOutsideNativeUnsigned">
        <source>This number is outside the allowable range for unsigned native integers</source>
        <target state="translated">Это число находится вне допустимого диапазона для собственных целых чисел без знака</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidFloat">
        <source>Invalid floating point number</source>
        <target state="translated">Недопустимое число с плавающей точкой</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideDecimal">
        <source>This number is outside the allowable range for decimal literals</source>
        <target state="translated">Это число находится вне допустимого диапазона для десятичных литералов</target>
        <note />
      </trans-unit>
      <trans-unit id="lexOusideThirtyTwoBitFloat">
        <source>This number is outside the allowable range for 32-bit floats</source>
        <target state="translated">Это число находится вне допустимого диапазона для 32-битных чисел с плавающей точкой</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidNumericLiteral">
        <source>This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0o1, 0b1, 1l (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</source>
        <target state="translated">Это не является допустимым числовым литералом. Допустимые числовые литералы: 1, 0x1, 0o1, 0b1, 1l (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidByteLiteral">
        <source>This is not a valid byte literal</source>
        <target state="translated">Не является допустимым байтовым литералом.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidCharLiteral">
        <source>This is not a valid character literal</source>
        <target state="translated">Не является допустимым символьным литералом.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexThisUnicodeOnlyInStringLiterals">
        <source>This Unicode encoding is only valid in string literals</source>
        <target state="translated">Эта кодировка Юникод может использоваться только в строковых литералах</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTokenReserved">
        <source>This token is reserved for future use</source>
        <target state="translated">Этот токен зарезервирован для будущего использования</target>
        <note />
      </trans-unit>
      <trans-unit id="lexTabsNotAllowed">
        <source>TABs are not allowed in F# code unless the #indent \"off\" option is used</source>
        <target state="translated">В коде F# табуляция может использоваться только при использовании параметра #indent \"off\"</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidLineNumber">
        <source>Invalid line number: '{0}'</source>
        <target state="translated">Недопустимый номер строки: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustBeFirst">
        <source>#if directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">Перед директивами #if могут находиться только знаки пробела</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseNoMatchingIf">
        <source>#else has no matching #if</source>
        <target state="translated">Отсутствует директива #if, соответствующая директиве #else</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifRequiredForElse">
        <source>#endif required for #else</source>
        <target state="translated">Для директивы #else требуется директива #endif</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashElseMustBeFirst">
        <source>#else directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">Перед директивами #else могут находиться только знаки пробела</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndingNoMatchingIf">
        <source>#endif has no matching #if</source>
        <target state="translated">Отсутствует директива #if, соответствующая директиве #endif</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashEndifMustBeFirst">
        <source>#endif directive must appear as the first non-whitespace character on a line</source>
        <target state="translated">Перед директивами #endif могут находиться только знаки пробела</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashIfMustHaveIdent">
        <source>#if directive should be immediately followed by an identifier</source>
        <target state="translated">Сразу после директивы #if необходимо указать идентификатор</target>
        <note />
      </trans-unit>
      <trans-unit id="lexWrongNestedHashEndif">
        <source>Syntax error. Wrong nested #endif, unexpected tokens before it.</source>
        <target state="translated">Синтаксическая ошибка. Неправильный вложенный #endif; недопустимые лексемы перед ним.</target>
        <note />
      </trans-unit>
      <trans-unit id="lexHashBangMustBeFirstInFile">
        <source>#! may only appear as the first line at the start of a file.</source>
        <target state="translated">#! может отображаться только в качестве первой строки в начале файла.</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexExpectedSingleLineComment">
        <source>Expected single line comment or end of line</source>
        <target state="translated">Ожидается однострочный комментарий или конец строки</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNoArguments">
        <source>Infix operator member '{0}' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Элемент инфиксного оператора "{0}" не имеет аргументов. Требуется кортеж из 2 аргументов, например: static member (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonPairArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Элемент инфиксного оператора "{0}" имеет {1} начальных аргументов. Требуется кортеж из 2 аргументов, например: static member (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithCurriedArguments">
        <source>Infix operator member '{0}' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...</source>
        <target state="translated">Элемент инфиксного оператора "{0}" имеет лишние переданные аргументы. Требуется кортеж из 2 аргументов, например: static member (+) (x,y) = ...</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFSharpCoreRequiresExplicit">
        <source>All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'</source>
        <target state="translated">Все типы записи, объединений и структур в FSharp.Core.dll должны быть явно помечены "StructuralComparison" или "NoComparison"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the type parameter '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" имеет атрибут "StructuralComparison", но параметр типа "{1}" не удовлетворяет ограничению "comparison". Рекомендуется добавить к параметру типа ограничение "comparison"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralComparisonNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralComparison' attribute but the component type '{1}' does not satisfy the 'comparison' constraint</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" имеет атрибут "StructuralComparison", но тип компонента "{1}" не удовлетворяет ограничению "comparison"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded1">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type parameter {1} does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" не сравним структурно, так как параметр типа {1} не удовлетворяет ограничению "comparison". Рекомендуется добавить к типу "{2}" атрибут "NoComparison", чтобы пояснить, что тип не является сравнимым</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoComparisonNeeded2">
        <source>The struct, record or union type '{0}' is not structurally comparable because the type '{1}' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '{2}' to clarify that the type is not comparable</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" не сравним структурно, так как тип {1} не удовлетворяет ограничению "comparison". Рекомендуется добавить к типу "{2}" атрибут "NoComparison", чтобы пояснить, что тип не является сравнимым</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded1">
        <source>The struct, record or union type '{0}' does not support structural equality because the type parameter {1} does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" не поддерживает структурное равенство, так как параметр типа {1} не удовлетворяет ограничению "equality". Рекомендуется добавить к типу "{2}" атрибут "NoEquality", чтобы пояснить, что тип не поддерживает структурное равенство</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoEqualityNeeded2">
        <source>The struct, record or union type '{0}' does not support structural equality because the type '{1}' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '{2}' to clarify that the type does not support structural equality</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" поддерживает структурное равенство, так как параметр типа {1} не удовлетворяет ограничению "equality". Рекомендуется добавить к типу "{2}" атрибут "NoEquality", чтобы пояснить, что тип не поддерживает структурное равенство</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied1">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the type parameter '{1}' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" имеет атрибут "StructuralEquality", но параметр типа "{1}" не удовлетворяет ограничению "equality". Рекомендуется добавить к параметру типа ограничение "equality"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructuralEqualityNotSatisfied2">
        <source>The struct, record or union type '{0}' has the 'StructuralEquality' attribute but the component type '{1}' does not satisfy the 'equality' constraint</source>
        <target state="translated">Тип структуры, записи или объединения "{0}" имеет атрибут "StructuralEquality", но тип компонента "{1}" не удовлетворяет ограничению "equality"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
        <source>Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct.</source>
        <target state="translated">Каждый аргумент первичного конструктора для структуры должен получить тип, например "type S(x1:int, x2: int) = ...". Эти аргументы определяют поля структуры.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedValue">
        <source>The value '{0}' is unused</source>
        <target state="translated">Значение "{0}" не используется</target>
        <note />
      </trans-unit>
      <trans-unit id="chkUnusedThisVariable">
        <source>The recursive object reference '{0}' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.</source>
        <target state="translated">Рекурсивная ссылка на объект "{0}" не используется. Наличие рекурсивных ссылок на объект увеличивает число проверок инициализации, проводимых во время выполнения для элементов этого типа и его производных типов. Рекомендуется удалить рекурсивную ссылку на объект.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsGetterAtMostOneArgument">
        <source>A getter property may have at most one argument group</source>
        <target state="translated">Свойство метода получения может иметь не более одной группы аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="parsSetterAtMostTwoArguments">
        <source>A setter property may have at most two argument groups</source>
        <target state="translated">Свойство метода присваивания значения может иметь не более двух групп аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidProperty">
        <source>Invalid property getter or setter</source>
        <target state="translated">Недопустимый метод получения или задания свойства</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIndexerPropertyRequiresAtLeastOneArgument">
        <source>An indexer property must be given at least one argument</source>
        <target state="translated">Свойству индексатора необходимо присвоить как минимум один аргумент</target>
        <note />
      </trans-unit>
      <trans-unit id="tastInvalidAddressOfMutableAcrossAssemblyBoundary">
        <source>This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation</source>
        <target state="translated">Эта операция обращается к изменяемому значению верхнего уровня, определенному в другой сборке неподдерживаемым способом. Не удается получить доступ к значению по его адресу. Рекомендуется скопировать выражение в локальную изменяемую переменную, например, "let mutable x = ...", и, при необходимости, снова присвоить это значение по завершении операции</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTypars">
        <source>Remove spaces between the type name and type parameter, e.g. \"type C&lt;'T&gt;\", not type \"C   &lt;'T&gt;\". Type parameters must be placed directly adjacent to the type name.</source>
        <target state="translated">Удалите пробелы между именем типа и параметром типа, например, \"type C&lt;'T&gt;\" вместо \"C   &lt;'T&gt;\". Параметры типа должны размещаться рядом с именем типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAdjacentTyargs">
        <source>Remove spaces between the type name and type parameter, e.g. \"C&lt;'T&gt;\", not \"C &lt;'T&gt;\". Type parameters must be placed directly adjacent to the type name.</source>
        <target state="translated">Удалите пробелы между именем типа и параметром типа, например, \"C&lt;'T&gt;\" вместо \"C &lt;'T&gt;\". Параметры типа должны указываться рядом с названием типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsNonAtomicType">
        <source>The use of the type syntax 'int C' and 'C  &lt;int&gt;' is not permitted here. Consider adjusting this type to be written in the form 'C&lt;int&gt;'</source>
        <target state="translated">Использование синтаксиса типа 'int C' и 'C  &lt;int&gt;' не допускается. Измените этот тип на 'C&lt;int&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespace">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the module/namespace '{2}'</source>
        <target state="translated">Модуль или пространство имен "{0}" из блока компиляции "{1}" не содержит модуль или пространство имен "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefVal">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the val '{2}'</source>
        <target state="translated">Модуль или пространство имен "{0}" из блока компиляции "{1}" не содержит значение "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tastUndefinedItemRefModuleNamespaceType">
        <source>The module/namespace '{0}' from compilation unit '{1}' did not contain the namespace, module or type '{2}'</source>
        <target state="translated">Модуль или пространство имен "{0}" из блока компиляции "{1}" не содержит пространство имен, модуль или тип "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseNullAsTrueValue">
        <source>The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case</source>
        <target state="translated">Флаг атрибута "UseNullAsTrueValue" может использоваться только с типами объединений, имеющими один нулевой случай и по меньшей мере один ненулевой случай.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcParameterInferredByref">
        <source>The parameter '{0}' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref&lt;int&gt;'. When used, a byref parameter is implicitly dereferenced.</source>
        <target state="translated">Для параметра '{0}' был определен тип byref. Для параметров типа byref необходимо явно объявить тип, например, 'x1: byref&lt;int&gt;'. При использовании параметра byref выполняется разрешение ссылки неявным образом.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonUniformMemberUse">
        <source>The generic member '{0}' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.</source>
        <target state="translated">Базовый элемент "{0}" использовался при неоднородном создании экземпляров ранее этой точки программы. Рассмотрите возможность изменения порядка элементов таким образом, чтобы данный элемент следовал первым. Альтернативное решение - задать полный тип элемента в явном виде, включая типы аргументов, тип возвращаемого значения и все дополнительные универсальные параметры и ограничения.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAttribArgsDiffer">
        <source>The attribute '{0}' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.</source>
        <target state="translated">Атрибут "{0}" присутствует как в реализации, так и в сигнатуре, но с разными аргументами. В скомпилированный код будет включен только атрибут из сигнатуры.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallAbstractBaseMember">
        <source>Cannot call an abstract base member: '{0}'</source>
        <target state="translated">Не удается вызвать абстрактный член базового класса: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelCannotResolveAmbiguityInUnmanaged">
        <source>Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position</source>
        <target state="translated">Не удалось разрешить неоднозначность в использовании базовой конструкции с ограничением "unmanaged" в этой позиции или рядом с ней</target>
        <note />
      </trans-unit>
      <trans-unit id="mlCompatMessage">
        <source>This construct is for ML compatibility. {0}. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'.</source>
        <target state="translated">Эта конструкция предназначена для многоязыковой совместимости. {0}. Это предупреждение можно отключить с помощью параметра "--mlcompatibility" или "--nowarn:62".</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldDoesNotHaveValidOffsetForStructureLayout">
        <source>The type '{0}' has been marked as having an Explicit layout, but the field '{1}' has not been marked with the 'FieldOffset' attribute</source>
        <target state="translated">Тип "{0}" был помечен как имеющий явно заданный макет, но поле "{1}" не было помечено атрибутом FieldOffset</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInterfacesShouldUseInheritNotInterface">
        <source>Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'</source>
        <target state="translated">Для объявления интерфейсов, наследуемых другими интерфейсами, следует использовать "inherit ...", а не "interface ..."</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperator">
        <source>Invalid prefix operator</source>
        <target state="translated">Недопустимый префиксный оператор</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidPrefixOperatorDefinition">
        <source>Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.</source>
        <target state="translated">Недопустимое определение оператора. Определения префиксных операторов должны использовать допустимые имена префиксных операторов.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildCompilingExtensionIsForML">
        <source>The file extensions '.ml' and '.mli' are for ML compatibility</source>
        <target state="translated">Расширения файлов ".ml" и ".mli" предназначены для многоязыковой совместимости</target>
        <note />
      </trans-unit>
      <trans-unit id="lexIndentOffForML">
        <source>Consider using a file with extension '.ml' or '.mli' instead</source>
        <target state="translated">Рассмотрите возможность использования файла с расширением ".ml" или ".mli"</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternIdentIsNotFunctionTyped">
        <source>Active pattern '{0}' is not a function</source>
        <target state="translated">Активный шаблон "{0}" не является функцией</target>
        <note />
      </trans-unit>
      <trans-unit id="activePatternChoiceHasFreeTypars">
        <source>Active pattern '{0}' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</source>
        <target state="translated">Активный шаблон " {0}" имеет тип результата, содержащий переменные типа, которые не определены входными данными. Обычно эта ошибка возникает, когда не упоминается тестовый случай результата, например, 'let (|A|B|) (x:int) = A x'. Чтобы исправить эту ошибку, можно ввести ограничение типа, например, 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</target>
        <note />
      </trans-unit>
      <trans-unit id="ilFieldHasOffsetForSequentialLayout">
        <source>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</source>
        <target state="translated">Атрибут FieldOffset может назначаться только членам типов, для которых используется StructLayout(LayoutKind.Explicit).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOptionalArgsMustComeAfterNonOptionalArgs">
        <source>Optional arguments must come at the end of the argument list, after any non-optional arguments</source>
        <target state="translated">Необязательные аргументы должны следовать в конце списка аргументов, после обязательных</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConditionalAttributeUsage">
        <source>Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes</source>
        <target state="translated">Атрибут System.Diagnostics.ConditionalAttribute допустим только в методах или классах атрибутов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMemberOperatorDefinitionInExtrinsic">
        <source>Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.</source>
        <target state="translated">Элементы расширения не могут предоставлять перегрузку операторов.  Вместо этого рекомендуется определить оператор как часть определения типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBFileNameCannotBeChangedWarning">
        <source>The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.</source>
        <target state="translated">MDB-файл должен иметь имя &lt;assembly-file-name&gt;.mdb. Параметр --pdb будет проигнорирован.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteMDBMemberMissing">
        <source>MDB generation failed. Could not find compatible member {0}</source>
        <target state="translated">Сбой при создании MDB-файла. Не удалось найти совместимый элемент {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ilwriteErrorCreatingMdb">
        <source>Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly.</source>
        <target state="translated">Невозможно создать сведения об отладке MDB. Не удалось загрузить тип MonoSymbolWriter из сборки Mono.CompilerServices.SymbolWriter.dll.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseNameConflictsWithGeneratedType">
        <source>The union case named '{0}' conflicts with the generated type '{1}'</source>
        <target state="translated">Ветвь объединения с именем "{0}" вступает в конфликт с созданным типом "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoReflectedDefinitionOnStructMember">
        <source>ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter</source>
        <target state="translated">Атрибут ReflectedDefinitionAttribute не может применяться к элементам экземпляров типа struct, поскольку элемент экземпляра принимает неявный параметр this byref</target>
        <note />
      </trans-unit>
      <trans-unit id="tcDllImportNotAllowed">
        <source>DLLImport bindings must be static members in a class or function definitions in a module</source>
        <target state="translated">Привязки DLLImport должны быть статическими элементами в определениях класса или функции в модуле</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedSigdataFile">
        <source>FSharp.Core.sigdata not found alongside FSharp.Core. File expected in {0}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">Ресурс FSharp.Core.sigdata не найден вместе с FSharp.Core. Файл ожидался в {0}. Рекомендуется обновление до более новой версии FSharp.Core, где этот файл не требуется.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildExpectedFileAlongSideFSharpCore">
        <source>File '{0}' not found alongside FSharp.Core. File expected in {1}. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.</source>
        <target state="translated">Файл "{0}" не найден вместе с FSharp.Core. Файл ожидался в {1}. Рекомендуется обновление до более новой версии FSharp.Core, где этот файл не требуется.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildUnexpectedFileNameCharacter">
        <source>Filename '{0}' contains invalid character '{1}'</source>
        <target state="translated">Имя файла "{0}" содержит недопустимый символ "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidUseBangBinding">
        <source>'use!' bindings must be of the form 'use! &lt;var&gt; = &lt;expr&gt;'</source>
        <target state="translated">Привязки 'use!' должны иметь вид 'use! &lt;var&gt; = &lt;expr&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoInnerGenericsInQuotations">
        <source>Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.</source>
        <target state="translated">Использование внутренних универсальных функций в выражениях в кавычках не допускается. Рекомендуется добавить ограничения типа, чтобы функция более не являлась универсальной.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEnumTypeCannotBeEnumerated">
        <source>The type '{0}' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property</source>
        <target state="translated">Тип "{0}" не является допустимым типом перечислителя, т. е. у него нет метода MoveNext(), возвращающего логическое значение, и свойства Current</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteString">
        <source>End of file in triple-quote string begun at or before here</source>
        <target state="translated">Конец файла в строке с тройными кавычками, начавшейся здесь или ранее</target>
        <note />
      </trans-unit>
      <trans-unit id="parsEofInTripleQuoteStringInComment">
        <source>End of file in triple-quote string embedded in comment begun at or before here</source>
        <target state="translated">Конец файла в строке с тройными кавычками, вставленной в комментарий, который начался здесь или ранее</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLosesMeasures">
        <source>This type test or downcast will ignore the unit-of-measure '{0}'</source>
        <target state="translated">При такой проверке типа или нисходящем приведении единица измерения "{0}" будет проигнорирована</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingTypeArgs">
        <source>Expected type argument or static argument</source>
        <target state="translated">Ожидался аргумент типа или статический аргумент</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMissingGreaterThan">
        <source>Unmatched '&lt;'. Expected closing '&gt;'</source>
        <target state="translated">Отсутствует парная скобка для '&lt;'. Ожидается закрывающая скобка '&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
        <source>Unexpected quotation operator '&lt;@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '&lt;' and '@' characters.</source>
        <target state="translated">Неожиданный оператор цитирования '&lt;@' в определении типа. Если вы хотите передать дословную строку в качестве статического аргумента поставщику типа, разделите символы '&lt;' и '@' пробелом.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsErrorParsingAsOperatorName">
        <source>Attempted to parse this as an operator name, but failed</source>
        <target state="translated">Предпринята попытка синтаксического анализа этого имени оператора, однако она завершилась неудачно</target>
        <note />
      </trans-unit>
      <trans-unit id="lexInvalidUnicodeLiteral">
        <source>\U{0} is not a valid Unicode character escape sequence</source>
        <target state="translated">\U{0} не является допустимой escape-последовательностью символов Юникода</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoWrongType">
        <source>'{0}' must be applied to an argument of type '{1}', but has been applied to an argument of type '{2}'</source>
        <target state="translated">"{0}" следует применять только к аргументу типа "{1}", но этот элемент был применен к аргументу типа "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCallerInfoNotOptional">
        <source>'{0}' can only be applied to optional arguments</source>
        <target state="translated">{0} можно применять только к дополнительным аргументам</target>
        <note />
      </trans-unit>
      <trans-unit id="toolLocationHelperUnsupportedFrameworkVersion">
        <source>The specified .NET Framework version '{0}' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
        <target state="translated">Указанная версия платформы .NET Framework ("{0}") не поддерживается. Укажите значение из перечисления Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidMagicValue">
        <source>Invalid Magic value in CLR Header</source>
        <target state="translated">Недопустимое магическое значение в заголовке CLR</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignBadImageFormat">
        <source>Bad image format</source>
        <target state="translated">Неправильный формат изображения</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignPrivateKeyExpected">
        <source>Private key expected</source>
        <target state="translated">Ожидался закрытый ключ</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignRsaKeyExpected">
        <source>RSA key expected</source>
        <target state="translated">Ожидался ключ RSA</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidBitLen">
        <source>Invalid bit Length</source>
        <target state="translated">Недопустимая длина в битах</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidRSAParams">
        <source>Invalid RSAParameters structure - '{{0}}' expected</source>
        <target state="translated">Недопустимая структура RSAParameters — ожидалось "{{0}}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidAlgId">
        <source>Invalid algId - 'Exponent' expected</source>
        <target state="translated">Недопустимый algId — ожидалось "Exponent"</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidSignatureSize">
        <source>Invalid signature size</source>
        <target state="translated">Недопустимый размер сигнатуры</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignNoSignatureDirectory">
        <source>No signature directory</source>
        <target state="translated">Нет каталога сигнатуры</target>
        <note />
      </trans-unit>
      <trans-unit id="ilSignInvalidPKBlob">
        <source>Invalid Public Key blob</source>
        <target state="translated">Недопустимый BLOB-объект открытого ключа</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTooManyErrors">
        <source>Exiting - too many errors</source>
        <target state="translated">Осуществляется выход - слишком много ошибок</target>
        <note />
      </trans-unit>
      <trans-unit id="docfileNoXmlSuffix">
        <source>The documentation file has no .xml suffix</source>
        <target state="translated">У файла документации нет суффикса .xml</target>
        <note />
      </trans-unit>
      <trans-unit id="fscNoImplementationFiles">
        <source>No implementation files specified</source>
        <target state="translated">Файлы реализации не указаны</target>
        <note />
      </trans-unit>
      <trans-unit id="fscBadAssemblyVersion">
        <source>The attribute {0} specified version '{1}', but this value is invalid and has been ignored</source>
        <target state="translated">В атрибуте {0} указана версия "{1}", однако это значение недопустимо и было проигнорировано</target>
        <note />
      </trans-unit>
      <trans-unit id="fscTwoResourceManifests">
        <source>Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used.</source>
        <target state="translated">Указаны противоречащие друг другу параметры: win32manifest и win32res. Можно использовать только один из них.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking">
        <source>The code in assembly '{0}' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">В коде сборки "{0}" используются литералы кавычек. При статическом связывании компоненты, использующие литералы кавычек, могут быть не включены, если все сборки не скомпилированы в версии F# не ниже 4.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscQuotationLiteralsStaticLinking0">
        <source>Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.</source>
        <target state="translated">В коде этой сборки используются литералы кавычек. При статическом связывании компоненты, использующие литералы кавычек, могут быть не включены, если все сборки не скомпилированы в версии F# не ниже 4.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoEXE">
        <source>Static linking may not include a .EXE</source>
        <target state="translated">Статическое связывание может не включать EXE-файл</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoMixedDLL">
        <source>Static linking may not include a mixed managed/unmanaged DLL</source>
        <target state="translated">Статическое связывание может не включать DLL-файл смешанного (управляемого и неуправляемого) типа</target>
        <note />
      </trans-unit>
      <trans-unit id="fscIgnoringMixedWhenLinking">
        <source>Ignoring mixed managed/unmanaged assembly '{0}' during static linking</source>
        <target state="translated">Игнорирование сборки смешанного (управляемого и неуправляемого) типа "{0}" во время статического связывания</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssumeStaticLinkContainsNoDependencies">
        <source>Assembly '{0}' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.</source>
        <target state="translated">Ссылка на сборку "{0}" была задана транзитивно, поэтому автоматически разрешить сборку не удалось. При статическом связывании предполагается, что у этого DLL-файла нет зависимостей от библиотеки F# или других DLL-файлов со статическим связыванием. Попробуйте добавить явную ссылку на этот DLL-файл.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyNotFoundInDependencySet">
        <source>Assembly '{0}' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.</source>
        <target state="translated">Сборка "{0}" не найдена в наборе зависимостей целевого двоичного файла. Корневые элементы со статическим связыванием должны указываться с помощью имени сборки без расширения DLL или EXE. Если сборка задана в ссылке явным образом, возможно, сборка на самом деле не требовалась для созданного двоичного файла. Это означает, что для нее не требуется статическое связывание.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileCouldNotBeOpened">
        <source>The key file '{0}' could not be opened</source>
        <target state="translated">Не удалось открыть файл ключей "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="fscProblemWritingBinary">
        <source>A problem occurred writing the binary '{0}': {1}</source>
        <target state="translated">Проблема при записи двоичного файла "{0}": {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyVersionAttributeIgnored">
        <source>The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option</source>
        <target state="translated">Атрибут AssemblyVersionAttribute был проигнорирован, поскольку версия задана с помощью параметра командной строки</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyCultureAttributeError">
        <source>Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'</source>
        <target state="translated">Ошибка при создании атрибута System.Reflection.AssemblyCultureAttribute - "Исполняемые файлы не могут быть вспомогательными сборками; свойство " Культура" должно обязательно быть пустым"</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDelaySignWarning">
        <source>Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module</source>
        <target state="translated">Параметр --delaysign переопределяет атрибут System.Reflection.AssemblyDelaySignAttribute, заданный в файле с исходным кодом или в добавленном модуле</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyFileWarning">
        <source>Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module</source>
        <target state="translated">Параметр --keyfile переопределяет атрибут System.Reflection.AssemblyKeyFileAttribute, заданный в файле с исходным кодом или в добавленном модуле</target>
        <note />
      </trans-unit>
      <trans-unit id="fscKeyNameWarning">
        <source>Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module</source>
        <target state="translated">Параметр --keycontainer переопределяет атрибут System.Reflection.AssemblyNameAttribute, заданный в файле с исходным кодом или добавленном модуле</target>
        <note />
      </trans-unit>
      <trans-unit id="fscReferenceOnCommandLine">
        <source>The assembly '{0}' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'.</source>
        <target state="translated">Сборка "{0}" указана в командной строке. Ссылки на сборки следует задавать с помощью флага командной строки, например флага "-r".</target>
        <note />
      </trans-unit>
      <trans-unit id="fscRemotingError">
        <source>The resident compilation service was not used because a problem occured in communicating with the server.</source>
        <target state="translated">Служба резидентной компиляции не использовалась, поскольку возникла проблема при взаимодействии с сервером.</target>
        <note />
      </trans-unit>
      <trans-unit id="pathIsInvalid">
        <source>Problem with filename '{0}': Illegal characters in path.</source>
        <target state="translated">Проблема с именем файла "{0}": недопустимые символы в пути.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscResxSourceFileDeprecated">
        <source>Passing a .resx file ({0}) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.</source>
        <target state="translated">Передача файла .resx ({0}) в качестве исходного файла компилятору больше не поддерживается. Используйте resgen.exe, чтобы преобразовать файл .resx в файл .resources, который необходимо передать с помощью параметра --resource. Если вы используете MSBuild, это можно сделать, указав элемент &lt;EmbeddedResource&gt; в файл проекта .fsproj.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscStaticLinkingNoProfileMismatches">
        <source>Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).</source>
        <target state="translated">Статическая компоновка не позволяет использовать сборку, которая ссылается на mscorlib (например, сборку .NET Framework), при создании сборки, которая ссылается на System.Runtime (например, сборки .NET Core или переносимой сборки).</target>
        <note />
      </trans-unit>
      <trans-unit id="fscAssemblyWildcardAndDeterminism">
        <source>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</source>
        <target state="translated">Пользователь {0} указал версию "{1}", но это значение является подстановочным знаком, а вы запросили детерминированную сборку: возник конфликт.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscDeterministicDebugRequiresPortablePdb">
        <source>Deterministic builds only support portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">Детерминированные сборки поддерживают только переносимые PDB-файлы (--debug:portable или --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInNamespaceName">
        <source>Character '{0}' is not allowed in provided namespace name '{1}'</source>
        <target state="translated">Не допускается использовать символ "{0}" в указанном имени пространства имен "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullOrEmptyMemberName">
        <source>The provided type '{0}' returned a member with a null or empty member name</source>
        <target state="translated">Предоставленный тип "{0}" вернул элемент с именем NULL или пустым именем</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMember">
        <source>The provided type '{0}' returned a null member</source>
        <target state="translated">Предоставленный тип "{0}" вернул элемент с NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringType">
        <source>The provided type '{0}' member info '{1}' has null declaring type</source>
        <target state="translated">Сведения об элементе "{1}" предоставленного типа "{0}" содержат объявляющий тип NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullMemberDeclaringTypeDifferentFromProvidedType">
        <source>The provided type '{0}' has member '{1}' which has declaring type '{2}'. Expected declaring type to be the same as provided type.</source>
        <target state="translated">Предоставленный тип "{0}" имеет элемент "{1}" с объявляющим типом "{2}". Ожидается, что объявляющий тип будет совпадать с предоставленным типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="etHostingAssemblyFoundWithoutHosts">
        <source>Referenced assembly '{0}' has assembly level attribute '{1}' but no public type provider classes were found</source>
        <target state="translated">Сборка "{0}", на которую указывает ссылка, содержит атрибут уровня сборки "{1}", однако классы поставщика открытых типов не обнаружены</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceOfTypeNotAllowed">
        <source>Type '{0}' from type provider '{1}' has an empty namespace. Use 'null' for the global namespace.</source>
        <target state="translated">Тип "{0}" поставщика типов "{1}" имеет пустое пространство имен. Используйте null для глобального пространства имен.</target>
        <note />
      </trans-unit>
      <trans-unit id="etEmptyNamespaceNotAllowed">
        <source>Empty namespace found from the type provider '{0}'. Use 'null' for the global namespace.</source>
        <target state="translated">У поставщика типов "{0}" обнаружено пустое пространство имен. Используйте null для глобального пространства имен.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeGeneric">
        <source>Provided type '{0}' has 'IsGenericType' as true, but generic types are not supported.</source>
        <target state="translated">Предоставленный тип "{0}" имеет свойство IsGenericType, равное true, однако универсальные типы не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMustNotBeAnArray">
        <source>Provided type '{0}' has 'IsArray' as true, but array types are not supported.</source>
        <target state="translated">Предоставленный тип "{0}" имеет свойство IsArray, равное true, однако типы массивов не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="etMethodHasRequirements">
        <source>Invalid member '{0}' on provided type '{1}'. Provided type members must be public, and not be generic, virtual, or abstract.</source>
        <target state="translated">Недопустимый элемент "{0}" предоставленного типа "{1}". Элементы предоставленного типа должны быть открытыми, а не универсальными, виртуальными или абстрактными.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedMemberKind">
        <source>Invalid member '{0}' on provided type '{1}'. Only properties, methods and constructors are allowed</source>
        <target state="translated">Недопустимый элемент "{0}" предоставленного типа "{1}". Разрешены только свойства, методы и конструкторы</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanReadButHasNoGetter">
        <source>Property '{0}' on provided type '{1}' has CanRead=true but there was no value from GetGetMethod()</source>
        <target state="translated">У свойства "{0}" предоставленного типа "{1}" CanRead=true, однако значение GetGetMethod() не получено</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasGetterButNoCanRead">
        <source>Property '{0}' on provided type '{1}' has CanRead=false but GetGetMethod() returned a method</source>
        <target state="translated">У свойства "{0}" предоставленного типа "{1}" CanRead=false, но метод GetGetMethod() вернул метод</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyCanWriteButHasNoSetter">
        <source>Property '{0}' on provided type '{1}' has CanWrite=true but there was no value from GetSetMethod()</source>
        <target state="translated">У свойства "{0}" предоставленного типа "{1}" CanWrite=true, однако значение GetSetMethod() не получено</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyHasSetterButNoCanWrite">
        <source>Property '{0}' on provided type '{1}' has CanWrite=false but GetSetMethod() returned a method</source>
        <target state="translated">У свойства "{0}" предоставленного типа "{1}" CanWrite=false, но метод GetSetMethod() вернул метод</target>
        <note />
      </trans-unit>
      <trans-unit id="etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
        <source>One or more errors seen during provided type setup</source>
        <target state="translated">При настройке предоставленного типа были обнаружены одна или более ошибок</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedTypeMember">
        <source>Unexpected exception from provided type '{0}' member '{1}': {2}</source>
        <target state="translated">Непредвиденное исключение, полученное из элемента "{1}" предоставленного типа "{0}": {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedConstantType">
        <source>Unsupported constant type '{0}'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal.</source>
        <target state="translated">Неподдерживаемый тип константы "{0}". Цитирования, предоставляемые поставщиками типов, могут содержать только простые константы. Может потребоваться изменить реализацию поставщика типов, переместив значение, объявленное вне предоставленного литерала цитирования, в литерал цитирования с привязкой let.</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnsupportedProvidedExpression">
        <source>Unsupported expression '{0}' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.</source>
        <target state="translated">Неподдерживаемое выражение "{0}" от поставщика типов. Если вы являетесь автором этого поставщика типов, попробуйте изменить его для предоставления другого выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedName">
        <source>Expected provided type named '{0}' but provided type has 'Name' with value '{1}'</source>
        <target state="translated">Ожидался предоставленный тип с именем "{0}", однако у предоставленного типа значение Name равнялось "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoAdd">
        <source>Event '{0}' on provided type '{1}' has no value from GetAddMethod()</source>
        <target state="translated">Событие "{0}" предоставленного типа "{1}" не имеет значения, полученного от метода GetAddMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etEventNoRemove">
        <source>Event '{0}' on provided type '{1}' has no value from GetRemoveMethod()</source>
        <target state="translated">Событие "{0}" предоставленного типа "{1}" не имеет значения, полученного от метода GetRemoveMethod()</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderHasWrongDesignerAssembly">
        <source>Assembly attribute '{0}' refers to a designer assembly '{1}' which cannot be loaded from path '{2}'. The exception reported was: {3} - {4}</source>
        <target state="translated">Атрибут сборки "{0}" ссылается на сборку конструктора "{1}", которая не может быть загружена по пути "{2}". Получено исключение: {3} — {4}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderDoesNotHaveValidConstructor">
        <source>The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected.</source>
        <target state="translated">У поставщика типов нет допустимого конструктора. Ожидался конструктор, принимающий один аргумент типа TypeProviderConfig или не принимающий ни одного аргумента этого типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderError">
        <source>The type provider '{0}' reported an error: {1}</source>
        <target state="translated">Поставщик типов "{0}" сообщил об ошибке: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectParameterExpression">
        <source>The type provider '{0}' used an invalid parameter in the ParameterExpression: {1}</source>
        <target state="translated">Поставщик типов "{0}" использовал недопустимый параметр в выражении ParameterExpression: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedMethod">
        <source>The type provider '{0}' provided a method with a name '{1}' and metadata token '{2}', which is not reported among its methods of its declaring type '{3}'</source>
        <target state="translated">Поставщик типов "{0}" предоставил метод с именем "{1}" и токеном метаданных "{2}", который отсутствует в списке методов соответствующего объявляющего типа "{3}"</target>
        <note />
      </trans-unit>
      <trans-unit id="etIncorrectProvidedConstructor">
        <source>The type provider '{0}' provided a constructor which is not reported among the constructors of its declaring type '{1}'</source>
        <target state="translated">Поставщик типов "{0}" предоставил конструктор, который не указан среди конструкторов его объявляющего типа "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="etDirectReferenceToGeneratedTypeNotAllowed">
        <source>A direct reference to the generated type '{0}' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = &lt;path&gt;'. This indicates that a type provider adds generated types to your assembly.</source>
        <target state="translated">Прямые ссылки на созданные типы "{0}" не допускаются. Вместо них используйте определение типа, например, 'type TypeAlias = &lt;путь&gt;'. При этом поставщик типа добавит созданные типы в сборку.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeHasUnexpectedPath">
        <source>Expected provided type with path '{0}' but provided type has path '{1}'</source>
        <target state="translated">Ожидался предоставленный тип с путем "{0}", однако предоставленный тип имеет путь "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedNullFromProvidedTypeMember">
        <source>Unexpected 'null' return value from provided type '{0}' member '{1}'</source>
        <target state="translated">Непредвиденное возвращаемое значение NULL, полученное из элемента "{1}" предоставленного типа "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnexpectedExceptionFromProvidedMemberMember">
        <source>Unexpected exception from member '{0}' of provided type '{1}' member '{2}': {3}</source>
        <target state="translated">Непредвиденное исключение, полученное из элемента "{0}" предоставленного типа "{1}", элемент "{2}": {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
        <source>Nested provided types do not take static arguments or generic parameters</source>
        <target state="translated">Вложенные предоставленные типы не принимают статических аргументов или универсальных параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidStaticArgument">
        <source>Invalid static argument to provided type. Expected an argument of kind '{0}'.</source>
        <target state="translated">Недопустимый статический аргумент предоставленного типа. Ожидался аргумент вида "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToType">
        <source>An error occured applying the static arguments to a provided type</source>
        <target state="translated">Ошибка при применении статических аргументов к предоставленному типу</target>
        <note />
      </trans-unit>
      <trans-unit id="etUnknownStaticArgumentKind">
        <source>Unknown static argument kind '{0}' when resolving a reference to a provided type or method '{1}'</source>
        <target state="translated">Неизвестный вид статического аргумента "{0}" при разрешении ссылки на предоставленный тип или метод "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidNamespaceForProvidedType">
        <source>invalid namespace for provided type</source>
        <target state="translated">недопустимое пространство имен для предоставленного типа</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidFullNameForProvidedType">
        <source>invalid full name for provided type</source>
        <target state="translated">недопустимое полное имя для предоставленного типа</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderReturnedNull">
        <source>The type provider returned 'null', which is not a valid return value from '{0}'</source>
        <target state="translated">Поставщик типов вернул значение NULL, которое не является допустимым возвращаемым значением для "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="etTypeProviderConstructorException">
        <source>The type provider constructor has thrown an exception: {0}</source>
        <target state="translated">Конструктор поставщика типов создал исключение: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="etNullProvidedExpression">
        <source>Type provider '{0}' returned null from GetInvokerExpression.</source>
        <target state="translated">Поставщик типов "{0}" вернул значение NULL в результате вызова метода GetInvokerExpression.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedTypeHadWrongName">
        <source>The type provider '{0}' returned an invalid type from 'ApplyStaticArguments'. A type with name '{1}' was expected, but a type with name '{2}' was returned.</source>
        <target state="translated">Поставщик типов "{0}" вернул недопустимый тип из метода ApplyStaticArguments. Ожидался тип с именем "{1}", но был возвращен тип с именем "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedAppliedMethodHadWrongName">
        <source>The type provider '{0}' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '{1}' was expected, but a method with name '{2}' was returned.</source>
        <target state="translated">Поставщик типов "{0}" вернул недействительный метод из ApplyStaticArgumentsForMethod. Предполагалось, что вернется метод "{1}" , но был возвращен метод "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestLossy">
        <source>This type test or downcast will erase the provided type '{0}' to the type '{1}'</source>
        <target state="translated">Это нисходящее приведение или проверка типа сотрет предоставленный тип "{0}" до типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeCastErased">
        <source>This downcast will erase the provided type '{0}' to the type '{1}'.</source>
        <target state="translated">Это нисходящее приведение типа сотрет предоставленный тип "{0}" до типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeTestErased">
        <source>This type test with a provided type '{0}' is not allowed because this provided type will be erased to '{1}' at runtime.</source>
        <target state="translated">Такая проверка предоставленного типа "{0}" запрещена, поскольку при этом предоставленный тип будет во время выполнения стерт до типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotInheritFromErasedType">
        <source>Cannot inherit from erased provided type</source>
        <target state="translated">Невозможно наследование от удаленного предоставленного типа</target>
        <note />
      </trans-unit>
      <trans-unit id="etInvalidTypeProviderAssemblyName">
        <source>Assembly '{0}' hase TypeProviderAssembly attribute with invalid value '{1}'. The value should be a valid assembly name</source>
        <target state="translated">У сборки "{0}" имеется атрибут TypeProviderAssembly с недопустимым значением "{1}". Значение должно представлять собой допустимое имя сборки</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidMemberNameCtor">
        <source>Invalid member name. Members may not have name '.ctor' or '.cctor'</source>
        <target state="translated">Недопустимое имя элемента. Элементы не могут иметь имя ".ctor" или ".cctor"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInferredGenericTypeGivesRiseToInconsistency">
        <source>The function or member '{0}' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '{1}'.</source>
        <target state="translated">Функция или элемент "{0}" используются таким образом, что для подтверждения согласованности выводимых типов требуются дополнительные аннотации типов при их определении. Выводимая сигнатура: "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidTypeArgumentCount">
        <source>The number of type arguments did not match: '{0}' given, '{1}' expected. This may be related to a previously reported error.</source>
        <target state="translated">Число аргументов типа не совпадает. Задано: {0}, ожидалось: {1}. Это может быть связано с ошибкой, о которой сообщалось ранее.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotOverrideSealedMethod">
        <source>Cannot override inherited member '{0}' because it is sealed</source>
        <target state="translated">Невозможно переопределить унаследованный элемент "{0}", поскольку он является запечатанным</target>
        <note />
      </trans-unit>
      <trans-unit id="etProviderErrorWithContext">
        <source>The type provider '{0}' reported an error in the context of provided type '{1}', member '{2}'. The error: {3}</source>
        <target state="translated">Поставщик типов сообщил об ошибке "{0}" в контексте предоставленного типа "{1}", элемент "{2}". Ошибка: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNameException">
        <source>An exception occurred when accessing the '{0}' of a provided type: {1}</source>
        <target state="translated">Исключение при обращении к "{0}" предоставленного типа: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeWithNullOrEmptyName">
        <source>The '{0}' of a provided type was null or empty.</source>
        <target state="translated">Значение "{0}" предоставленного типа равнялось NULL или было пустым.</target>
        <note />
      </trans-unit>
      <trans-unit id="etIllegalCharactersInTypeName">
        <source>Character '{0}' is not allowed in provided type name '{1}'</source>
        <target state="translated">Не допускается использовать символ "{0}" в указанном имени типа "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcJoinMustUseSimplePattern">
        <source>In queries, '{0}' must use a simple pattern</source>
        <target state="translated">В запросах для "{0}" следует использовать простой шаблон</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMissingCustomOperation">
        <source>A custom query operation for '{0}' is required but not specified</source>
        <target state="translated">Пользовательская операция запроса для "{0}" является обязательной, но не указана</target>
        <note />
      </trans-unit>
      <trans-unit id="etBadUnnamedStaticArgs">
        <source>Named static arguments must come after all unnamed static arguments</source>
        <target state="translated">Именованные статические аргументы должны располагаться после неименованных статических аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterRequiresAValue">
        <source>The static parameter '{0}' of the provided type or method '{1}' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '{2}&lt;{3}=...&gt;'.</source>
        <target state="translated">Необходимо указать значение статического параметра '{0}' указанного типа или метода '{1}'. Статические параметры для поставщиков типа можно указать с помощью именованных аргументов, например, '{2}&lt;{3}=...&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="etNoStaticParameterWithName">
        <source>No static parameter exists with name '{0}'</source>
        <target state="translated">Имя "{0}" не имеет статических параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="etStaticParameterAlreadyHasValue">
        <source>The static parameter '{0}' has already been given a value</source>
        <target state="translated">Для статического параметра "{0}" уже было задано значение</target>
        <note />
      </trans-unit>
      <trans-unit id="etMultipleStaticParameterWithName">
        <source>Multiple static parameters exist with name '{0}'</source>
        <target state="translated">Имя "{0}" имеет несколько статических параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
        <source>A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression</source>
        <target state="translated">Пользовательскую операцию нельзя использовать в сочетании c не содержащей значения или рекурсивной привязкой let в другой части этого выражения с вычислениями</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeUsedHere">
        <source>A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression</source>
        <target state="translated">Пользовательскую операцию нельзя использовать в сочетании с операторами use, try/with, try/finally, if/then/else и match в этом выражении с вычислениями</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationMayNotBeOverloaded">
        <source>The custom operation '{0}' refers to a method which is overloaded. The implementations of custom operations may not be overloaded.</source>
        <target state="translated">Пользовательский оператор "{0}" ссылается на перегруженный метод. Нельзя перегружать реализации пользовательских операций.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIfThenElseMayNotBeUsedWithinQueries">
        <source>An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.</source>
        <target state="translated">В запросах нельзя использовать выражения if/then/else. Попробуйте использовать выражение if/then или используйте вместо этого выражение последовательности.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
        <source>Invalid argument to 'methodhandleof' during codegen</source>
        <target state="translated">Недопустимый аргумент methodhandleof во время создания кода</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceMissingArgument">
        <source>A reference to a provided type was missing a value for the static parameter '{0}'. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">В ссылке на предоставленный тип отсутствовало значение статического параметра "{0}". Может потребоваться перекомпилировать одну или более сборок, на которые указывают ссылки.</target>
        <note />
      </trans-unit>
      <trans-unit id="etProvidedTypeReferenceInvalidText">
        <source>A reference to a provided type had an invalid value '{0}' for a static parameter. You may need to recompile one or more referenced assemblies.</source>
        <target state="translated">Ссылка на предоставленный тип имеет недопустимое значение "{0}" статического параметра. Может потребоваться перекомпилировать одну или более сборок, на которые указывают ссылки.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly">
        <source>'{0}' is not used correctly. This is a custom operation in this query or computation expression.</source>
        <target state="translated">{0} используется неверно. Это пользовательская операция в данном запросе или выражении с вычислениями.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationNotUsedCorrectly2">
        <source>'{0}' is not used correctly. Usage: {1}. This is a custom operation in this query or computation expression.</source>
        <target state="translated">"{0}" используется неверно. Использование: {1}. Это пользовательская операция в данном запросе или выражении с вычислениями.</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeJoin">
        <source>{0} var in collection {1} (outerKey = innerKey). Note that parentheses are required after '{2}'</source>
        <target state="translated">Переменная {0} в коллекции {1} (outerKey = innerKey). Обратите внимание, что после "{2}" нужны круглые скобки</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeGroupJoin">
        <source>{0} var in collection {1} (outerKey = innerKey) into group. Note that parentheses are required after '{2}'</source>
        <target state="translated">Переменная {0} из коллекции {1} (outerKey = innerKey) в группе. Обратите внимание, что после "{2}" нужны круглые скобки</target>
        <note />
      </trans-unit>
      <trans-unit id="customOperationTextLikeZip">
        <source>{0} var in collection</source>
        <target state="translated">Переменная {0} в коллекции</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresVariable">
        <source>'{0}' must be followed by a variable name. Usage: {1}.</source>
        <target state="translated">После "{0}" должно идти имя переменной. Использование: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorIncorrectSyntax">
        <source>Incorrect syntax for '{0}'. Usage: {1}.</source>
        <target state="translated">Неверный синтаксис для "{0}". Использование: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBinaryOperatorRequiresBody">
        <source>'{0}' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... {1} ...</source>
        <target state="translated">Перед "{0}" должно идти предложение выбора "for", а после — оставшаяся часть запроса. Синтаксис: … {1} …</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationHasIncorrectArgCount">
        <source>'{0}' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected {1} argument(s), but given {2}.</source>
        <target state="translated">"{0}" используется с неверным числом аргументов. Это пользовательская операция в данном запросе или выражении с вычислениями. Ожидалось аргументов: {1}. Задано аргументов: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedExpressionAfterToken">
        <source>Expected an expression after this point</source>
        <target state="translated">После этой точки ожидалось выражение</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedTypeAfterToken">
        <source>Expected a type after this point</source>
        <target state="translated">После этой точки ожидался тип</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLBrackLess">
        <source>Unmatched '[&lt;'. Expected closing '&gt;]'</source>
        <target state="translated">Отсутствует парная скобка для '[&lt;'. Ожидается закрывающая скобка '&gt;]'</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileMatch">
        <source>Unexpected end of input in 'match' expression. Expected 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</source>
        <target state="translated">Неожиданное завершение входных данных в выражении 'match'. Ожидаемое завершение: 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTry">
        <source>Unexpected end of input in 'try' expression. Expected 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;'.</source>
        <target state="translated">Неожиданное завершение входных данных в выражении 'try'. Ожидаемые варианты: 'try &lt;expr&gt; with &lt;rules&gt;' или 'try &lt;expr&gt; finally &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWhile">
        <source>Unexpected end of input in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Неожиданное завершение входных данных в выражении 'while'. Ожидаемое завершение: 'while &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFor">
        <source>Unexpected end of input in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Неожиданное завершение входных данных для выражения 'for'. Ожидаемое завершение: 'for &lt;pat&gt; в &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileWith">
        <source>Unexpected end of input in 'match' or 'try' expression</source>
        <target state="translated">Непредвиденный конец входных данных в выражении "match" или "try"</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileThen">
        <source>Unexpected end of input in 'then' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Неожиданное завершение входных данных в ветви 'then' условного выражения. Ожидаемое завершение: 'if &lt;expr&gt; then &lt;expr&gt;' или 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileElse">
        <source>Unexpected end of input in 'else' branch of conditional expression. Expected 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</source>
        <target state="translated">Неожиданное завершение входных данных ветви 'else' условного выражения. Ожидаемое завершение: 'if &lt;expr&gt; then &lt;expr&gt;' или 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileFunBody">
        <source>Unexpected end of input in body of lambda expression. Expected 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</source>
        <target state="translated">Неожиданное завершение входных данных лямбда-выражения. Ожидаемое завершение: 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeArgs">
        <source>Unexpected end of input in type arguments</source>
        <target state="translated">Непредвиденный конец входных данных в аргументах типа</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeSignature">
        <source>Unexpected end of input in type signature</source>
        <target state="translated">Непредвиденный конец входных данных в сигнатуре типа</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileTypeDefinition">
        <source>Unexpected end of input in type definition</source>
        <target state="translated">Непредвиденный конец входных данных в определении типа</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileObjectMembers">
        <source>Unexpected end of input in object members</source>
        <target state="translated">Непредвиденный конец входных данных в элементах объекта</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileDefinition">
        <source>Unexpected end of input in value, function or member definition</source>
        <target state="translated">Непредвиденный конец входных данных в определении значения, функции или элемента</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedEndOfFileExpression">
        <source>Unexpected end of input in expression</source>
        <target state="translated">Непредвиденный конец входных данных в выражении</target>
        <note />
      </trans-unit>
      <trans-unit id="parsExpectedNameAfterToken">
        <source>Unexpected end of type. Expected a name after this point.</source>
        <target state="translated">Непредвиденный конец файла. После этой точки ожидалось имя.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLet">
        <source>Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.</source>
        <target state="translated">Неполное определение значения или функции. Если оно находится в выражении, тело выражения должно располагаться с таким же отступом, что и ключевое слово let.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedLetBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword.</source>
        <target state="translated">Неполное определение значения. Если оно находится в выражении, тело выражения должно располагаться с таким же отступом, что и ключевое слово "let!".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUseBang">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword.</source>
        <target state="translated">Неполное определение значения. Если оно находится в выражении, тело выражения должно располагаться с таким же отступом, что и ключевое слово "use!".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedUse">
        <source>Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword.</source>
        <target state="translated">Неполное определение значения. Если оно находится в выражении, тело выражения должно располагаться с таким же отступом, что и ключевое слово use.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsWhileDoExpected">
        <source>Missing 'do' in 'while' expression. Expected 'while &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">В выражении "while" отсутствует "do". Ожидаемый синтаксис: 'while &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsForDoExpected">
        <source>Missing 'do' in 'for' expression. Expected 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</source>
        <target state="translated">Отсутствует выражение 'do' в выражении 'for'. Ожидается 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcInvalidRelationInJoin">
        <source>Invalid join relation in '{0}'. Expected 'expr &lt;op&gt; expr', where &lt;op&gt; is =, =?, ?= or ?=?.</source>
        <target state="translated">Недопустимое отношение соединения '{0}'. Ожидаемое отношение: 'expr &lt;оператор&gt; expr', где &lt;оператор&gt; is =, =?, ?= or ?=?.</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoCallsWord">
        <source>Calls</source>
        <target state="translated">Вызовы</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidNumberOfGenericArguments">
        <source>Invalid number of generic arguments to type '{0}' in provided type. Expected '{1}' arguments, given '{2}'.</source>
        <target state="translated">Недопустимое число универсальных аргументов для типа "{0}" в предоставленном типе. Ожидалось аргументов: "{1}", задано аргументов: "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument1">
        <source>Invalid value '{0}' for unit-of-measure parameter '{1}'</source>
        <target state="translated">Недопустимое значение "{0}" параметра единицы измерения "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="impInvalidMeasureArgument2">
        <source>Invalid value unit-of-measure parameter '{0}'</source>
        <target state="translated">Недопустимое значение параметра единицы измерения "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="etPropertyNeedsCanWriteOrCanRead">
        <source>Property '{0}' on provided type '{1}' is neither readable nor writable as it has CanRead=false and CanWrite=false</source>
        <target state="translated">Свойство "{0}" предоставленного типа "{1}" не доступно ни для чтения, ни для записи, поскольку у него CanRead=false и CanWrite=false</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIntoNeedsRestOfQuery">
        <source>A use of 'into' must be followed by the remainder of the computation</source>
        <target state="translated">После использования into должна располагаться оставшаяся часть вычислений</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorDoesntAcceptInto">
        <source>The operator '{0}' does not accept the use of 'into'</source>
        <target state="translated">Оператор "{0}" не принимает использование into</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCustomOperationInvalid">
        <source>The definition of the custom operator '{0}' does not use a valid combination of attribute flags</source>
        <target state="translated">В определении пользовательского оператора "{0}" используется недопустимое сочетание флагов атрибутов</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisTypeMayNotHaveACLIMutableAttribute">
        <source>This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute.</source>
        <target state="translated">Определение этого типа не может содержать атрибута CLIMutable. Этот атрибут можно использовать только в типах записей.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAutoPropertyRequiresImplicitConstructionSequence">
        <source>'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'.</source>
        <target state="translated">Определения "member val" разрешены только в типах с первичным конструктором. Попробуйте добавить в определение типа аргументы, напр. "type X(args) = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSet">
        <source>Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Определения свойств не могут объявляться как изменяемые. Чтобы показать, что свойство можно задавать, используйте конструкцию "member val PropertyName = expr with get,set".</target>
        <note />
      </trans-unit>
      <trans-unit id="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
        <source>To indicate that this property can be set, use 'member val PropertyName = expr with get,set'.</source>
        <target state="translated">Чтобы показать, что свойство можно задавать, используйте конструкцию "member val PropertyName = expr with get,set".</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefsOfByrefs">
        <source>Type '{0}' is illegal because in byref&lt;T&gt;, T cannot contain byref types.</source>
        <target state="translated">Тип '{0}' является недопустимым, так как byref&lt;T&gt;, T не может содержать типы byref.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastopsMaxArrayThirtyTwo">
        <source>F# supports array ranks between 1 and 32. The value {0} is not allowed.</source>
        <target state="translated">F# поддерживает массивы рангом от 1 до 32. Значение {0} не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoIntegerForLoopInQuery">
        <source>In queries, use the form 'for x in n .. m do ...' for ranging over integers</source>
        <target state="translated">В запросах используйте для перебора интервала целых чисел форму "for x in n .. m do ..."</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoWhileInQuery">
        <source>'while' expressions may not be used in queries</source>
        <target state="translated">В запросах нельзя использовать выражения while</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNoTryFinallyInQuery">
        <source>'try/finally' expressions may not be used in queries</source>
        <target state="translated">В запросах нельзя использовать выражения try/finally</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUseMayNotBeUsedInQueries">
        <source>'use' expressions may not be used in queries</source>
        <target state="translated">В запросах нельзя использовать выражения use</target>
        <note />
      </trans-unit>
      <trans-unit id="tcBindMayNotBeUsedInQueries">
        <source>'let!', 'use!' and 'do!' expressions may not be used in queries</source>
        <target state="translated">В запросах нельзя использовать выражения "let!", "'use!" и "do!"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcReturnMayNotBeUsedInQueries">
        <source>'return' and 'return!' may not be used in queries</source>
        <target state="translated">В запросах нельзя использовать "return" и "return!"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryOperator">
        <source>This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type.</source>
        <target state="translated">Это неизвестный оператора запроса. Операторы запросов представляют собой идентификаторы, такие как select, where, sortBy, thenBy, groupBy, groupValBy, join, groupJoin,sumBy и averageBy, определяемые с помощью соответствующих методов типа QueryBuilder.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTryWithMayNotBeUsedInQueries">
        <source>'try/with' expressions may not be used in queries</source>
        <target state="translated">В запросах нельзя использовать выражения try/with</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNonSimpleLetBindingInQuery">
        <source>This 'let' definition may not be used in a query. Only simple value definitions may be used in queries.</source>
        <target state="translated">Определение let нельзя использовать в запросе. В запросах можно использовать только простые определения значений.</target>
        <note />
      </trans-unit>
      <trans-unit id="etTooManyStaticParameters">
        <source>Too many static parameters. Expected at most {0} parameters, but got {1} unnamed and {2} named parameters.</source>
        <target state="translated">Слишком много статических параметров. Ожидалось не более {0} параметров, однако было получено {1} неименованных и {2} именованных параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="infosInvalidProvidedLiteralValue">
        <source>Invalid provided literal value '{0}'</source>
        <target state="translated">Недопустимое предоставленное значение литерала "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="invalidPlatformTarget">
        <source>The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead.</source>
        <target state="translated">Платформу anycpu32bitpreferred можно использовать только с целевыми файлами EXE. Вместо этого необходимо использовать платформу anycpu.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcThisValueMayNotBeInlined">
        <source>This member, function or value declaration may not be declared 'inline'</source>
        <target state="translated">Этот элемент, функция или значение не могут быть объявлены как inline</target>
        <note />
      </trans-unit>
      <trans-unit id="etErasedTypeUsedInGeneration">
        <source>The provider '{0}' returned a non-generated type '{1}' in the context of a set of generated types. Consider adjusting the type provider to only return generated types.</source>
        <target state="translated">Поставщик "{0}" вернул несоздаваемый тип "{1}" в контексте набора создаваемых типов. Попробуйте изменить поставщик типов, чтобы он возвращал только создаваемые типы.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnrecognizedQueryBinaryOperator">
        <source>Arguments to query operators may require parentheses, e.g. 'where (x &gt; y)' or 'groupBy (x.Length / 10)'</source>
        <target state="translated">Аргументы в операторах запроса может потребоваться заключить в скобки, например, 'where (x &gt; y)' или 'groupBy (x.Length / 10)'</target>
        <note />
      </trans-unit>
      <trans-unit id="crefNoSetOfHole">
        <source>A quotation may not involve an assignment to or taking the address of a captured local variable</source>
        <target state="translated">Цитата может не включать присваивание полученной локальной переменной или получение ее адреса</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloads1">
        <source>+ 1 overload</source>
        <target state="translated">+ 1 перегрузка</target>
        <note />
      </trans-unit>
      <trans-unit id="nicePrintOtherOverloadsN">
        <source>+ {0} overloads</source>
        <target state="translated">+ {0} перегрузок</target>
        <note />
      </trans-unit>
      <trans-unit id="erasedTo">
        <source>Erased to</source>
        <target state="translated">Стерт до</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnfinishedExpression">
        <source>Unexpected token '{0}' or incomplete expression</source>
        <target state="translated">Ожидался токен "{0}" или неполное выражение</target>
        <note />
      </trans-unit>
      <trans-unit id="parsAttributeOnIncompleteCode">
        <source>Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.</source>
        <target state="translated">Не удается найти целевой код для этого атрибута; возможно, это вызвано тем, что код после атрибута незавершен.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsTypeNameCannotBeEmpty">
        <source>Type name cannot be empty.</source>
        <target state="translated">Имя типа не может быть пустым.</target>
        <note />
      </trans-unit>
      <trans-unit id="buildProblemReadingAssembly">
        <source>Problem reading assembly '{0}': {1}</source>
        <target state="translated">Проблема при чтении сборки "{0}": {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTPFieldMustBeLiteral">
        <source>Invalid provided field. Provided fields of erased provided types must be literals.</source>
        <target state="translated">Недопустимое предоставляемое поле. Предоставляемые поля удаленных предоставляемых типов должны быть литералами.</target>
        <note />
      </trans-unit>
      <trans-unit id="loadingDescription">
        <source>(loading description...)</source>
        <target state="translated">(идет загрузка описания...)</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionUnavailable">
        <source>(description unavailable...)</source>
        <target state="translated">(описание недоступно...)</target>
        <note />
      </trans-unit>
      <trans-unit id="chkTyparMultipleClassConstraints">
        <source>A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.</source>
        <target state="translated">Переменная типа ограничена несколькими различными типами классов. Переменная типа может иметь только одно ограничение класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcMatchMayNotBeUsedWithQuery">
        <source>'match' expressions may not be used in queries</source>
        <target state="translated">В запросах нельзя использовать выражения match</target>
        <note />
      </trans-unit>
      <trans-unit id="memberOperatorDefinitionWithNonTripleArgument">
        <source>Infix operator member '{0}' has {1} initial argument(s). Expected a tuple of 3 arguments</source>
        <target state="translated">Элемент инфиксного оператора "{0}" имеет {1} начальных аргументов. Ожидался кортеж из 3 аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="cannotResolveNullableOperators">
        <source>The operator '{0}' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'.</source>
        <target state="translated">Не удается разрешить оператор "{0}". Попробуйте открыть модуль Microsoft.FSharp.Linq.NullableOperators.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOperatorRequiresIn">
        <source>'{0}' must be followed by 'in'. Usage: {1}.</source>
        <target state="translated">После "{0}" должно следовать "in". Использование: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsIllegalMemberVarInObjectImplementation">
        <source>Neither 'member val' nor 'override val' definitions are permitted in object expressions.</source>
        <target state="translated">В выражениях объектов не разрешены определения "member val" и "override val".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcEmptyCopyAndUpdateRecordInvalid">
        <source>Copy-and-update record expressions must include at least one field.</source>
        <target state="translated">Выражения записей копирования и обновления должны включать хотя бы одно поле.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnderscoreInvalidFieldName">
        <source>'_' cannot be used as field name</source>
        <target state="translated">Символ "_" нельзя использовать как имя поля</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGeneratedTypesShouldBeInternalOrPrivate">
        <source>The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'.</source>
        <target state="translated">Предоставленные типы, созданные в результате данного использования поставщика типов, не могут использоваться из других сборок F#, и их следует пометить модификатором internal или private. Попробуйте использовать конструкцию "type internal TypeName = ..." или "type private TypeName = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="chkGetterAndSetterHaveSamePropertyType">
        <source>A property's getter and setter must have the same type. Property '{0}' has getter of type '{1}' but setter of type '{2}'.</source>
        <target state="translated">Метод получения и метод задания свойства должны относиться к одному типу. Свойство "{0}" имеет метод получения типа "{1}" и метод задания типа "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRuntimeSuppliedMethodCannotBeUsedInUserCode">
        <source>Array method '{0}' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.</source>
        <target state="translated">Метод массива "{0}" предоставляет средой выполнения и не может использовать непосредственно в коде. Для операций с элементами используйте семейство функций GetArray/SetArray из модуля LanguagePrimitives.IntrinsicFunctions.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName">
        <source>The union case '{0}' does not have a field named '{1}'.</source>
        <target state="translated">Ветвь объединения '{0}' не содержит поля с именем '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnionCaseFieldCannotBeUsedMoreThanOnce">
        <source>Union case/exception field '{0}' cannot be used more than once.</source>
        <target state="translated">Поле "{0}" ветви объединения/исключения не может использоваться более одного раза.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameIsUsedModeThanOnce">
        <source>Named field '{0}' is used more than once.</source>
        <target state="translated">Именованное поле "{0}" используется более одного раза.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFieldNameConflictsWithGeneratedNameForAnonymousField">
        <source>Named field '{0}' conflicts with autogenerated name for anonymous field.</source>
        <target state="translated">Конфликт именованного поля "{0}" с автоматически созданным именем для анонимного поля.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastConstantExpressionOverflow">
        <source>This literal expression or attribute argument results in an arithmetic overflow.</source>
        <target state="translated">Это строковое выражение или аргумент атрибута вызывает арифметическое переполнение.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIllegalStructTypeForConstantExpression">
        <source>This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.</source>
        <target state="translated">Это выражение не является литеральным. Атрибут [&lt;Literal&gt;] будет проигнорирован.</target>
        <note />
      </trans-unit>
      <trans-unit id="fscSystemRuntimeInteropServicesIsRequired">
        <source>System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.</source>
        <target state="translated">Для использования классов UnknownWrapper\DispatchWrapper требуется сборка System.Runtime.InteropServices.</target>
        <note />
      </trans-unit>
      <trans-unit id="abImplicitHeapAllocation">
        <source>The mutable local '{0}' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.</source>
        <target state="translated">Локальная изменяемая переменная "{0}" была неявно выделена в качестве ссылочной ячейки, поскольку она попала в замыкание. Это предупреждение отображается только в ознакомительных целях, чтобы указать на неявно определенные выделения.</target>
        <note />
      </trans-unit>
      <trans-unit id="estApplyStaticArgumentsForMethodNotImplemented">
        <source>A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid</source>
        <target state="translated">Поставщик типов реализовал GetStaticParametersForMethod, но поддержка аргумента ApplyStaticArgumentsForMethod не была реализована или была реализована неправильно</target>
        <note />
      </trans-unit>
      <trans-unit id="etErrorApplyingStaticArgumentsToMethod">
        <source>An error occured applying the static arguments to a provided method</source>
        <target state="translated">Произошла ошибка при применении статических аргументов к предоставленному методу</target>
        <note />
      </trans-unit>
      <trans-unit id="pplexUnexpectedChar">
        <source>Unexpected character '{0}' in preprocessor expression</source>
        <target state="translated">Неожиданный символ "{0}" в выражении препроцессора</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsUnexpectedToken">
        <source>Unexpected token '{0}' in preprocessor expression</source>
        <target state="translated">Неожиданный токен "{0}" в выражении препроцессора</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsIncompleteExpression">
        <source>Incomplete preprocessor expression</source>
        <target state="translated">Неполное выражение препроцессора</target>
        <note />
      </trans-unit>
      <trans-unit id="ppparsMissingToken">
        <source>Missing token '{0}' in preprocessor expression</source>
        <target state="translated">Отсутствует токен "{0}" в выражении препроцессора</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleMissingDefinition">
        <source>An error occurred while reading the F# metadata node at position {0} in table '{1}' of assembly '{2}'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.</source>
        <target state="translated">Произошла ошибка при чтении узла метаданных F# в позиции {0} в таблице "{1}" сборки "{2}". В узле отсутствовало соответствующее объявление. Отправьте это предупреждение в отчете. Вам может потребоваться повторно скомпилировать сборку F#, которую вы используете.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScope">
        <source>Type inference caused the type variable {0} to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.</source>
        <target state="translated">Определение типа привело к выходу за пределы области переменной типа {0}. Попробуйте добавить явное объявление параметра типа или скорректировать код таким образом, чтобы он был менее универсальным.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkNotSufficientlyGenericBecauseOfScopeAnon">
        <source>Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.</source>
        <target state="translated">Определение типа привело к выходу за пределы области переменной типа определения. Попробуйте добавить аннотации типа, чтобы сделать код менее универсальным.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkRaiseFamilyFunctionArgumentCount">
        <source>Redundant arguments are being ignored in function '{0}'. Expected {1} but got {2} arguments.</source>
        <target state="translated">Избыточные аргументы игнорируются в функции "{0}". Ожидался аргумент {1}, но получен аргумент {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="checkLowercaseLiteralBindingInPattern">
        <source>Lowercase literal '{0}' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.</source>
        <target state="translated">Литерал в нижнем регистре "{0}" скрыт новым шаблоном с тем же именем. Только литералы в верхнем регистре и литералы с модулем в качестве префикса можно использовать в качестве именованного шаблона.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcLiteralDoesNotTakeArguments">
        <source>This literal pattern does not take arguments</source>
        <target state="translated">Этот шаблон литерала не включает аргументы.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorsIllegalInAugmentation">
        <source>Constructors are not permitted as extension members - they must be defined as part of the original definition of the type</source>
        <target state="translated">Не допускается использование конструкторов в качестве элементов расширений — они должны быть определены в рамках исходного определения типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidResponseFile">
        <source>Invalid response file '{0}' ( '{1}' )</source>
        <target state="translated">Недопустимый файл ответов "{0}" ("{1}")</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNotFound">
        <source>Response file '{0}' not found in '{1}'</source>
        <target state="translated">Файл ответа "{0}" не найден в "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="optsResponseFileNameInvalid">
        <source>Response file name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">Имя файла ответа "{0}" пустое, содержит недопустимые символы, имеет имя диска без абсолютного пути или слишком длинное.</target>
        <note />
      </trans-unit>
      <trans-unit id="fsharpCoreNotFoundToBeCopied">
        <source>Cannot find FSharp.Core.dll in compiler's directory</source>
        <target state="translated">Не удается найти FSharp.Core.dll в каталоге компилятора.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleStructMismatch">
        <source>One tuple type is a struct tuple, the other is a reference tuple</source>
        <target state="translated">Один тип кортежа является кортежем структуры, другой — эталонным кортежем</target>
        <note />
      </trans-unit>
      <trans-unit id="etMissingStaticArgumentsToMethod">
        <source>This provided method requires static parameters</source>
        <target state="translated">Этому предоставленному методу требуются статические параметры</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcast">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'.</source>
        <target state="translated">Преобразование {0} в {1} является безопасным повышением времени компиляции, а не понижением. Рекомендуется использовать "upcast" вместо "downcast".</target>
        <note />
      </trans-unit>
      <trans-unit id="considerUpcastOperator">
        <source>The conversion from {0} to {1} is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.</source>
        <target state="translated">Преобразование {0} в {1} является безопасным повышением времени компиляции, а не понижением. Рекомендуется использовать :&gt; (upcast) вместо :?&gt; (downcast).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcRecImplied">
        <source>The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored</source>
        <target state="translated">Ключевое слово "rec" в этом модуле подразумевается согласно внешнему объявлению "rec" и будет пропущено</target>
        <note />
      </trans-unit>
      <trans-unit id="tcOpenFirstInMutRec">
        <source>In a recursive declaration group, 'open' declarations must come first in each module</source>
        <target state="translated">В группе рекурсивных объявлений объявления "open" должны стоять первыми в каждом модуле</target>
        <note />
      </trans-unit>
      <trans-unit id="tcModuleAbbrevFirstInMutRec">
        <source>In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations</source>
        <target state="translated">В группе рекурсивных объявлений сокращенные формы модулей должны следовать после всех объявлений "open" и до других объявлений</target>
        <note />
      </trans-unit>
      <trans-unit id="tcUnsupportedMutRecDecl">
        <source>This declaration is not supported in recursive declaration groups</source>
        <target state="translated">Это объявление не поддерживается в группах рекурсивных объявлений</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidUseOfRec">
        <source>Invalid use of 'rec' keyword</source>
        <target state="translated">Недопустимое использование ключевого слова "rec"</target>
        <note />
      </trans-unit>
      <trans-unit id="tcStructUnionMultiCaseDistinctFields">
        <source>If a union type has more than one case and is a struct, then all fields within the union type must be given unique names.</source>
        <target state="translated">Если тип объединения имеет более одного варианта и является структурой, всем полям в типе объединения необходимо присвоить уникальные имена.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerMemberNameIsOverriden">
        <source>The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.</source>
        <target state="translated">Атрибут CallerMemberNameAttribute, примененный для параметра "{0}", не будет действовать. Он будет переопределен атрибутом CallerFilePathAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcFixedNotAllowed">
        <source>Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'</source>
        <target state="translated">Недопустимое использование выражения "fixed". Выражение "fixed" можно использовать только в объявлении формы "use x = fixed expr", где выражение является массивом, адресом поля, адресом элемента массива или строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCouldNotFindOffsetToStringData">
        <source>Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression.</source>
        <target state="translated">Не удалось найти в ссылках метод System.Runtime.CompilerServices.OffsetToStringData при создании выражения "fixed".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcNamedActivePattern">
        <source>{0} is an active pattern and cannot be treated as a discriminated union case with named fields.</source>
        <target state="translated">{0} является активным шаблоном и не может обрабатываться как различаемая ветвь объединения с именованными полями.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultParameterValueNotAppropriateForArgument">
        <source>The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'.</source>
        <target state="translated">Значение по умолчанию и аргумент имеют разные типы. Атрибут DefaultParameterValue и любые атрибуты Optional будут игнорироваться. Примечание: null необходимо аннотировать правильным типом, например DefaultParameterValue(null:obj).</target>
        <note />
      </trans-unit>
      <trans-unit id="tcGlobalsSystemTypeNotFound">
        <source>The system type '{0}' was required but no referenced system DLL contained this type</source>
        <target state="translated">Требуется системный тип "{0}", а в этом типе нет упоминаемой системой библиотеки DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelMemberHasMultiplePossibleDispatchSlots">
        <source>The member '{0}' matches multiple overloads of the same method.\nPlease restrict it to one of the following:{1}.</source>
        <target state="translated">Элемент "{0}" соответствует нескольким перегрузкам одного метода.\nНеобходимо ограничить его одним из следующих: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="methodIsNotStatic">
        <source>Method or object constructor '{0}' is not static</source>
        <target state="translated">Метод или конструктор объекта "{0}" не является статическим</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnexpectedSymbolEqualsInsteadOfIn">
        <source>Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?</source>
        <target state="translated">Непредвиденный символ = в выражении. Возможно, предполагалось использовать for x in y .. z do?</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAbstract">
        <source>Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</source>
        <target state="translated">Обозначает метод, который не имеет реализации в типе, в котором он объявлен, или является виртуальным и имеет реализацию по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="keyworkDescriptionAnd">
        <source>Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</source>
        <target state="translated">Используется во взаимно рекурсивных привязках, объявлениях свойств и с несколькими ограничениями для универсальных параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAs">
        <source>Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</source>
        <target state="translated">Используется для присвоения текущему объекту класса имени объекта. Также используется для присвоения имени всему шаблону в пределах сопоставления шаблонов.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionAssert">
        <source>Used to verify code during debugging.</source>
        <target state="translated">Используется для проверки кода во время отладки.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBase">
        <source>Used as the name of the base class object.</source>
        <target state="translated">Используется в качестве имени объекта базового класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionBegin">
        <source>In verbose syntax, indicates the start of a code block.</source>
        <target state="translated">В подробном синтаксисе обозначает начало блока кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionClass">
        <source>In verbose syntax, indicates the start of a class definition.</source>
        <target state="translated">В подробном синтаксисе обозначает начало определения класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDefault">
        <source>Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</source>
        <target state="translated">Обозначает реализацию абстрактного метода; используется вместе с объявлением абстрактного метода для создания виртуального метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDelegate">
        <source>Used to declare a delegate.</source>
        <target state="translated">Используется для объявления делегата.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDo">
        <source>Used in looping constructs or to execute imperative code.</source>
        <target state="translated">Используется в циклических конструкциях или для выполнения императивного кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDone">
        <source>In verbose syntax, indicates the end of a block of code in a looping expression.</source>
        <target state="translated">В подробном синтаксисе обозначает окончание блока кода в циклическом выражении.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDowncast">
        <source>Used to convert to a type that is lower in the inheritance chain.</source>
        <target state="translated">Используется для преобразования в тип, который находится ниже в цепочке наследования.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDownto">
        <source>In a for expression, used when counting in reverse.</source>
        <target state="translated">В выражении for используется для счета в обратном порядке.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElif">
        <source>Used in conditional branching. A short form of else if.</source>
        <target state="translated">Используется в условном ветвлении. Краткая форма else if.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionElse">
        <source>Used in conditional branching.</source>
        <target state="translated">Используется в условном ветвлении.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionEnd">
        <source>In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</source>
        <target state="translated">В определениях и расширениях типов обозначает окончание раздела определений членов. В подробном синтаксисе используется для указания окончания блока кода, который начинается с ключевого слова begin.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionException">
        <source>Used to declare an exception type.</source>
        <target state="translated">Используется для объявления типа исключения.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionExtern">
        <source>Indicates that a declared program element is defined in another binary or assembly.</source>
        <target state="translated">Указывает, что объявленный элемент программы определяется в другом двоичном файле или сборке.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTrueFalse">
        <source>Used as a Boolean literal.</source>
        <target state="translated">Используется в качестве логического литерала.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFinally">
        <source>Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</source>
        <target state="translated">Используется вместе с ключевым словом try для введения блока кода, который выполняется независимо от того, возникает ли исключение.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFor">
        <source>Used in looping constructs.</source>
        <target state="translated">Используется в циклических конструкциях.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFun">
        <source>Used in lambda expressions, also known as anonymous functions.</source>
        <target state="translated">Используется в лямбда-выражениях, также известных как анонимные функции.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionFunction">
        <source>Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</source>
        <target state="translated">Используется в качестве краткого варианта ключевого слова fun и выражения сопоставления в лямбда-выражении с сопоставлением шаблонов по одному аргументу.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionGlobal">
        <source>Used to reference the top-level .NET namespace.</source>
        <target state="translated">Используется для ссылки на пространство имен .NET верхнего уровня.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIf">
        <source>Used in conditional branching constructs.</source>
        <target state="translated">Используется в конструкциях условного ветвления.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionIn">
        <source>Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</source>
        <target state="translated">Используется для выражений последовательностей и (в подробном синтаксисе) для отделения выражений от привязок.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInherit">
        <source>Used to specify a base class or base interface.</source>
        <target state="translated">Используется для указания базового класса или базового интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInline">
        <source>Used to indicate a function that should be integrated directly into the caller's code.</source>
        <target state="translated">Используется для обозначения функции, которая должна быть интегрирована непосредственно в код вызывающего объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInterface">
        <source>Used to declare and implement interfaces.</source>
        <target state="translated">Используется для объявления и реализации интерфейсов.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionInternal">
        <source>Used to specify that a member is visible inside an assembly but not outside it.</source>
        <target state="translated">Используется для указания того, что член доступен внутри сборки, но не за ее пределами.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLazy">
        <source>Used to specify a computation that is to be performed only when a result is needed.</source>
        <target state="translated">Используется для указания вычисления, которое должно быть выполнено, только когда требуется результат.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLet">
        <source>Used to associate, or bind, a name to a value or function.</source>
        <target state="translated">Используется для связывания (или привязки) имени со значением или функцией.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLetBang">
        <source>Used in computation expressions to bind a name to the result of another computation expression.</source>
        <target state="translated">Используется в вычислительных выражениях для привязки имени к результату другого вычислительного выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatch">
        <source>Used to branch by comparing a value to a pattern.</source>
        <target state="translated">Используется для ветвления путем сравнения значения с шаблоном.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMember">
        <source>Used to declare a property or method in an object type.</source>
        <target state="translated">Используется для объявления свойства или метода в типе объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionModule">
        <source>Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</source>
        <target state="translated">Используется для связывания имени с группой соответствующих типов, значений и функций для логического отделения их от других частей кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMutable">
        <source>Used to declare a variable, that is, a value that can be changed.</source>
        <target state="translated">Используется для объявления переменной, то есть значения, которое может быть изменено.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNamespace">
        <source>Used to associate a name with a group of related types and modules, to logically separate it from other code.</source>
        <target state="translated">Используется для связывания имени с группой соответствующих типов и модулей для логического отделения их от других частей кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNew">
        <source>Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.</source>
        <target state="translated">Используется для объявления, определения или вызова конструктора, который создает или может создать объект. Также используется в ограничениях универсальных параметров, чтобы указать, что тип должен иметь определенный конструктор.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNot">
        <source>Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</source>
        <target state="translated">Не является ключевым словом. Тем не менее структура not в сочетаниях используется как ограничение универсальных параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionNull">
        <source>Indicates the absence of an object. Also used in generic parameter constraints.</source>
        <target state="translated">Указывает на отсутствие объекта. Также используется в ограничениях универсальных параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOf">
        <source>Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</source>
        <target state="translated">Используется в размеченных объединениях для обозначения типа категорий значений, а также в объявлениях делегатов и исключений.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOpen">
        <source>Used to make the contents of a namespace or module available without qualification.</source>
        <target state="translated">Используется для предоставления доступа к содержимому пространства имен или модуля без квалификации.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOr">
        <source>Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.</source>
        <target state="translated">Используется с логическими условиями в качестве логического значения или оператора. Эквивалентно ||. Также используется в ограничениях членов.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionOverride">
        <source>Used to implement a version of an abstract or virtual method that differs from the base version.</source>
        <target state="translated">Используется для реализации версии абстрактного или виртуального метода, который отличается от базовой версии.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPrivate">
        <source>Restricts access to a member to code in the same type or module.</source>
        <target state="translated">Ограничивает доступ к члену для кода в том же типе или модуле.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionPublic">
        <source>Allows access to a member from outside the type.</source>
        <target state="translated">Разрешает доступ к члену из-за пределов типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRec">
        <source>Used to indicate that a function is recursive.</source>
        <target state="translated">Используется для обозначения того, что функция является рекурсивной.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturn">
        <source>Used to provide a value for the result of the containing computation expression.</source>
        <target state="translated">Используется для указания значения для результата, содержащего вычислительное выражение.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionReturnBang">
        <source>Used to provide a value for the result of the containing computation expression, where that value itself comes from the result another computation expression.</source>
        <target state="translated">Используется для указания значения результата вычислительного выражения, если это значение поступает из результата другого вычислительного выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionSelect">
        <source>Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</source>
        <target state="translated">Используется в выражениях запроса для указания полей или столбцов для извлечения. Обратите внимание, что это контекстно-зависимое ключевое слово, то есть фактически оно не является зарезервированным словом и функционирует как ключевое слово только в соответствующем контексте.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStatic">
        <source>Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</source>
        <target state="translated">Используется для обозначения метода или свойства, которые могут вызываться без экземпляра типа, или члена значения, общего для всех экземпляров типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionStruct">
        <source>Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions.</source>
        <target state="translated">Используется для объявления типа структуры. Также используется в ограничениях универсальных параметров. Используется для обеспечения совместимости с OCaml в определениях модулей.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionThen">
        <source>Used in conditional expressions. Also used to perform side effects after object construction.</source>
        <target state="translated">Используется в условных выражениях. Также используется для выполнения побочных эффектов после создания объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTo">
        <source>Used in for loops to indicate a range.</source>
        <target state="translated">Используется в циклах for для обозначения диапазона.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTry">
        <source>Used to introduce a block of code that might generate an exception. Used together with with or finally.</source>
        <target state="translated">Используется для введения блока кода, который может создать исключение. Используется вместе с with или finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionType">
        <source>Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</source>
        <target state="translated">Используется для объявления класса, записи, структуры, размеченного объединения, типа перечисления, единицы измерения или аббревиатуры типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUpcast">
        <source>Used to convert to a type that is higher in the inheritance chain.</source>
        <target state="translated">Используется для преобразования в тип, который находится выше в цепочке наследования.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUse">
        <source>Used instead of let for values that implement IDisposable</source>
        <target state="translated">Используется вместо let для значений, которые реализуют IDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUseBang">
        <source>Used instead of let! in computation expressions for computation expression results that implement IDisposable.</source>
        <target state="translated">Используется вместо let! в вычислительных выражениях для вычисления результатов выражения, которые реализуют интерфейс IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVal">
        <source>Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</source>
        <target state="translated">Используется в сигнатуре для обозначения значения или в типе для объявления члена (в ограниченных ситуациях).</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionVoid">
        <source>Indicates the .NET void type. Used when interoperating with other .NET languages.</source>
        <target state="translated">Обозначает тип void .NET. Используется при взаимодействии с другими языками .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhen">
        <source>Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.</source>
        <target state="translated">Используется для логических условий (условий when) для сопоставлений шаблонов и для введения предложения ограничения для параметра универсального типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWhile">
        <source>Introduces a looping construct.</source>
        <target state="translated">Вводит циклическую конструкцию.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionWith">
        <source>Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</source>
        <target state="translated">Используется с ключевым словом match в выражениях сопоставления шаблонов. Также используется в выражениях объектов, выражениях копирования записей и расширениях типов для введения определений членов и обработчиков исключений.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYield">
        <source>Used in a sequence expression to produce a value for a sequence.</source>
        <target state="translated">Используется в выражении последовательности для получения значения для последовательности.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionYieldBang">
        <source>Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</source>
        <target state="translated">Используется в вычислительном выражении для добавления результата данного вычислительного выражения в набор результатов для содержащего его вычислительного выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionRightArrow">
        <source>In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions</source>
        <target state="translated">В типах функций разделяет аргументы и возвращаемые значения. Выдает выражение (в выражениях последовательности); эквивалентно ключевому слову yield. Используется в выражениях сопоставления.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionLeftArrow">
        <source>Assigns a value to a variable.</source>
        <target state="translated">Назначает значение переменной.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionCast">
        <source>Converts a type to type that is higher in the hierarchy.</source>
        <target state="translated">Преобразует тип в тип, находящийся выше в иерархии.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionDynamicCast">
        <source>Converts a type to a type that is lower in the hierarchy.</source>
        <target state="translated">Преобразует тип в тип, находящийся ниже в иерархии.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionTypedQuotation">
        <source>Delimits a typed code quotation.</source>
        <target state="translated">Отделяет типизированную цитату кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionUntypedQuotation">
        <source>Delimits a untyped code quotation.</source>
        <target state="translated">Отделяет нетипизированную цитату кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundDuringDynamicCodeGen">
        <source>{0} '{1}' not found in assembly '{2}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{0} "{1}" не найден в сборке "{2}". Это может быть вызвано несовместимостью версий. Вам может потребоваться явно сослаться на правильную версию этой сборки, чтобы ее могли использовать все указанные в ссылке компоненты.</target>
        <note />
      </trans-unit>
      <trans-unit id="itemNotFoundInTypeDuringDynamicCodeGen">
        <source>{0} '{1}' not found in type '{2}' from assembly '{3}'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.</source>
        <target state="translated">{0} "{1}" не найден в типе "{2}" из сборки "{3}". Это может быть вызвано несовместимостью версий. Вам может потребоваться явно сослаться на правильную версию этой сборки, чтобы ее могли использовать все указанные в ссылке компоненты.</target>
        <note />
      </trans-unit>
      <trans-unit id="descriptionWordIs">
        <source>is</source>
        <target state="translated">является</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunction">
        <source>This value is not a function and cannot be applied.</source>
        <target state="translated">Это значение не является функцией, и применить его невозможно.</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexerWithName">
        <source>This value is not a function and cannot be applied. Did you intend to access the indexer via {0}.[index] instead?</source>
        <target state="translated">Это значение не является функцией, и применить его невозможно. Вы хотели обратиться к индексатору с помощью {0}.[индекс]?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeIndexer">
        <source>This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?</source>
        <target state="translated">Это выражение не является функцией, и применить его невозможно. Вы хотели обратиться к индексатору с помощью &lt;выражение&gt;.[индекс]?</target>
        <note />
      </trans-unit>
      <trans-unit id="notAFunctionButMaybeDeclaration">
        <source>This value is not a function and cannot be applied. Did you forget to terminate a declaration?</source>
        <target state="translated">Данное значение не является функцией и не может быть применено. Забыли завершить объявление?</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentsInSigAndImplMismatch">
        <source>The argument names in the signature '{0}' and implementation '{1}' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling.</source>
        <target state="translated">Имена аргументов в сигнатуре "{0}" и реализации "{1}" не совпадают. Будет использоваться имя аргумента из файла сигнатуры. Это может вызвать проблемы при отладке или профилировании.</target>
        <note />
      </trans-unit>
      <trans-unit id="pickleUnexpectedNonZero">
        <source>An error occurred while reading the F# metadata of assembly '{0}'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct.</source>
        <target state="translated">Произошла ошибка при чтении метаданных F# сборки "{0}". Использовалась зарезервированная конструкция. Попробуйте обновить компилятор F# или применить более раннюю версию сборки, где конкретная конструкция не используется.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTupleMemberNotNormallyUsed">
        <source>This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.</source>
        <target state="translated">Этот метод или свойство обычно не используется в коде F#. Вместо этого используйте явный шаблон кортежа для деконструкции.</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'.</source>
        <target state="translated">Это выражение возвращает значение типа "{0}", но оно неявно отбрасывается. Чтобы привязать результат к какому-то имени, используйте "let", например: "let &lt;результат&gt; = &lt;выражение&gt;". Если вы собирались использовать выражение как значение в последовательности, используйте в явном виде "yield".</target>
        <note />
      </trans-unit>
      <trans-unit id="implicitlyDiscardedSequenceInSequenceExpression">
        <source>This expression returns a value of type '{0}' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'.</source>
        <target state="translated">Это выражение возвращает значение типа "{0}", но оно неявно отбрасывается. Чтобы привязать результат к какому-то имени, используйте "let", например: "let &lt;результат&gt; = &lt;выражение&gt;". Если вы собирались использовать выражение как значение в последовательности, используйте в явном виде "yield!".</target>
        <note />
      </trans-unit>
      <trans-unit id="keywordDescriptionMatchBang">
        <source>Used in computation expressions to pattern match directly over the result of another computation expression.</source>
        <target state="translated">Используется в выражениях вычислений для сопоставления шаблонов непосредственно с результатом другого выражения вычислений.</target>
        <note />
      </trans-unit>
      <trans-unit id="ilreadFileChanged">
        <source>The file '{0}' changed on disk unexpectedly, please reload.</source>
        <target state="translated">Файл "{0}" был неожиданно изменен на диске, повторите загрузку.</target>
        <note />
      </trans-unit>
      <trans-unit id="writeToReadOnlyByref">
        <source>The byref pointer is readonly, so this write is not permitted.</source>
        <target state="translated">Указатель byref доступен только для чтения, поэтому операция записи запрещена.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeMutable">
        <source>A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'</source>
        <target state="translated">Чтобы изменить содержимое или получить адрес типа значения, значение должно быть изменяемым, например, "let mutable x = ..."</target>
        <note />
      </trans-unit>
      <trans-unit id="readOnlyAttributeOnStructWithMutableField">
        <source>A ReadOnly attribute has been applied to a struct type with a mutable field.</source>
        <target state="translated">Атрибут ReadOnly был применен к типу структуры с изменяемым полем.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByrefReturnImplicitlyDereferenced">
        <source>A byref pointer returned by a function or method is implicitly dereferenced as of F# 4.5. To acquire the return value as a pointer, use the address-of operator, e.g. '&amp;f(x)' or '&amp;obj.Method(arg1, arg2)'.</source>
        <target state="translated">Указатель на byref, возвращаемый функцией или методом, в F# 4.5 разрешается неявно. Чтобы получить возвращаемое значение в виде указателя, используйте оператор адреса, например, '&amp;f(x)' или '&amp;obj.Method(arg1, arg2)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByRefLikeNotStruct">
        <source>A type annotated with IsByRefLike must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.</source>
        <target state="translated">Тип, помеченный аннотацией IsByRefLike, обязательно должен быть структурой. Добавьте атрибут [&lt;Struct&gt;] к типу.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAddressOfLocal">
        <source>The address of the variable '{0}' or a related expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">На этом этапе невозможно использовать адрес переменной "{0}" или связанного выражения. В этом случае гарантируется, что адрес локального значения не обходит свою область.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoWriteToLimitedSpan">
        <source>This value can't be assigned because the target '{0}' may refer to non-stack-local memory, while the expression being assigned is assessed to potentially refer to stack-local memory. This is to help prevent pointers to stack-bound memory escaping their scope.</source>
        <target state="translated">Это значение не может быть назначено, так как целевой элемент "{0}" может ссылаться на отличную от локальной для стека память, тогда как назначаемое выражение оценивается как потенциально ссылающееся на локальную для стека память. В этом случае гарантируется, что указатели на привязанную к стеку память не обходят свою область.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastValueMustBeLocal">
        <source>A value defined in a module must be mutable in order to take its address, e.g. 'let mutable x = ...'</source>
        <target state="translated">Чтобы получить свой адрес, значение, определенное в модуле, должно быть изменяемым, например "let mutable x = ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcIsReadOnlyNotStruct">
        <source>A type annotated with IsReadOnly must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.</source>
        <target state="translated">Тип с аннотацией IsReadOnly должен быть структурой. Добавьте к этому типу атрибут [&lt;Struct&gt;].</target>
        <note />
      </trans-unit>
      <trans-unit id="chkStructsMayNotReturnAddressesOfContents">
        <source>Struct members cannot return the address of fields of the struct by reference</source>
        <target state="translated">Члены структуры не могут возвращать адрес полей структуры по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefLikeFunctionCall">
        <source>The function or method call cannot be used at this point, because one argument that is a byref of a non-stack-local Span or IsByRefLike type is used with another argument that is a stack-local Span or IsByRefLike type. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">На этом этапе невозможно использовать вызов функции или метода, так как один аргумент, представляющий собой byref с отличным от локального для стека типом Span или IsByRefLike, используется с другим аргументом, имеющим локальный для стека тип Span или IsByRefLike. В этом случае гарантируется, что адрес локального значения не обходит свою область.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoByrefAddressOfValueFromExpression">
        <source>The address of a value returned from the expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">На этом этапе невозможно использовать адрес значения, возвращаемого выражением. В этом случае гарантируется, что адрес локального значения не обходит свою область.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoSpanLikeVariable">
        <source>The Span or IsByRefLike variable '{0}' cannot be used at this point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">На этом этапе невозможно использовать переменную Span или IsByRefLike "{0}". В этом случае гарантируется, что адрес локального значения не обходит свою область.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoSpanLikeValueFromExpression">
        <source>A Span or IsByRefLike value returned from the expression cannot be used at ths point. This is to ensure the address of the local value does not escape its scope.</source>
        <target state="translated">На этом этапе невозможно использовать значение Span или IsByRefLike, возвращаемое выражением. В этом случае гарантируется, что адрес локального значения не обходит свою область.</target>
        <note />
      </trans-unit>
      <trans-unit id="tastCantTakeAddressOfExpression">
        <source>Cannot take the address of the value returned from the expression. Assign the returned value to a let-bound value before taking the address.</source>
        <target state="translated">Невозможно получить адрес значения, возвращенного из выражения. Используйте возвращенное значение в качестве значения с привязкой let, прежде чем получить адрес.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsUnmatchedBraceBar">
        <source>Unmatched '{{|'</source>
        <target state="translated">Отсутствует парная скобка для '{{|'</target>
        <note />
      </trans-unit>
      <trans-unit id="typeInfoAnonRecdField">
        <source>anonymous record field</source>
        <target state="translated">поле анонимной записи</target>
        <note />
      </trans-unit>
      <trans-unit id="tcExceptionConstructorDoesNotHaveFieldWithGivenName">
        <source>The exception '{0}' does not have a field named '{1}'.</source>
        <target state="translated">Исключение "{0}" не содержит поля с именем "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="tcActivePatternsDoNotHaveFields">
        <source>Active patterns do not have fields. This syntax is invalid.</source>
        <target state="translated">Активные шаблоны не имеют полей. Этот синтаксис является недопустимым.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcConstructorDoesNotHaveFieldWithGivenName">
        <source>The constructor does not have a field named '{0}'.</source>
        <target state="translated">Конструктор не содержит поля с именем '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdCcuMismatch">
        <source>Two anonymous record types are from different assemblies '{0}' and '{1}'</source>
        <target state="translated">Два типа анонимных записей принадлежат различным сборкам '{0}' и '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="tcAnonRecdFieldNameMismatch">
        <source>This anonymous record does not exactly match the expected shape. Add the missing fields {0} and remove the extra fields {1}.</source>
        <target state="translated">Эта анонимная запись не соответствует ожидаемой форме. Добавьте недостающие поля {0} и удалите лишние поля {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotCallExtensionMethodInrefToByref">
        <source>Cannot call the byref extension method '{0}. The first parameter requires the value to be mutable or a non-readonly byref type.</source>
        <target state="translated">Не удается вызвать метод расширения byref "{0}". В качестве первого параметра необходимо указать изменяемое значение или значение типа byref, доступное не только для чтения.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcByrefsMayNotHaveTypeExtensions">
        <source>Byref types are not allowed to have optional type extensions.</source>
        <target state="translated">Типы byref не могут иметь расширения необязательного типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCannotPartiallyApplyExtensionMethodForByref">
        <source>Cannot partially apply the extension method '{0}' because the first parameter is a byref type.</source>
        <target state="translated">Не удается частично применить метод расширения "{0}", так как первый параметр имеет тип byref.</target>
        <note />
      </trans-unit>
      <trans-unit id="tcTypeDoesNotInheritAttribute">
        <source>This type does not inherit Attribute, it will not work correctly with other .NET languages.</source>
        <target state="translated">Этот тип не наследует атрибут (Attribute), он не будет корректно взаимодействовать с другими языками .NET.</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidAnonRecdExpr">
        <source>Invalid anonymous record expression</source>
        <target state="translated">Недопустимое выражение анонимной записи</target>
        <note />
      </trans-unit>
      <trans-unit id="parsInvalidAnonRecdType">
        <source>Invalid anonymous record type</source>
        <target state="translated">Недопустимый анонимный тип записи</target>
        <note />
      </trans-unit>
      <trans-unit id="tcCopyAndUpdateNeedsRecordType">
        <source>The input to a copy-and-update expression that creates an anonymous record must be either an anonymous record or a record</source>
        <target state="translated">Входные данные для выражения копирования и обновления, создающего анонимную запись, должны представлять собой анонимную или обычную запись</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidFunctionParameterType">
        <source>The parameter '{0}' has an invalid type '{1}'. This is not permitted by the rules of Common IL.</source>
        <target state="translated">Параметр "{0}" имеет недопустимый тип "{1}". Это не допускается правилами общего промежуточного языка.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkInvalidFunctionReturnType">
        <source>The function or method has an invalid return type '{0}'. This is not permitted by the rules of Common IL.</source>
        <target state="translated">Функция или метод имеет недопустимый возвращаемый тип "{0}". Это не допускается правилами общего промежуточного языка.</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveral">
        <source>No implementation was given for those members: {0}</source>
        <target state="translated">Реализация для этих членов отсутствует: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralWithSuggestion">
        <source>No implementation was given for those members: {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Реализация для этих членов отсутствует: {0}Обратите внимание, что каждый член интерфейса должен быть реализован и указан в соответствующем объявлении "interface", например, "интерфейс ... с членом ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralTruncated">
        <source>No implementation was given for those members (some results omitted): {0}</source>
        <target state="translated">Реализация для этих членов отсутствует (некоторые результаты опущены): {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="typrelNoImplementationGivenSeveralTruncatedWithSuggestion">
        <source>No implementation was given for those members (some results omitted): {0}Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'.</source>
        <target state="translated">Реализация для этих членов отсутствует (некоторые результаты опущены): {0}Обратите внимание, что каждый член интерфейса должен быть реализован и указан в соответствующем объявлении "interface", например, "интерфейс ... с членом ...".</target>
        <note />
      </trans-unit>
      <trans-unit id="expressionHasNoName">
        <source>Expression does not have a name.</source>
        <target state="translated">Выражение не имеет имени.</target>
        <note />
      </trans-unit>
      <trans-unit id="chkNoFirstClassNameOf">
        <source>Using the 'nameof' operator as a first-class function value is not permitted.</source>
        <target state="translated">Использование оператора "nameof" в качестве значения функции первого класса не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="optsPathMap">
        <source>Maps physical paths to source path names output by the compiler</source>
        <target state="translated">Сопоставляет физические пути с исходными путями в выходных данных компилятора</target>
        <note />
      </trans-unit>
      <trans-unit id="fscPathMapDebugRequiresPortablePdb">
        <source>--pathmap can only be used with portable PDBs (--debug:portable or --debug:embedded)</source>
        <target state="translated">Параметр --pathmap может использоваться только с переносимыми PDB-файлами (--debug:portable или --debug:embedded)</target>
        <note />
      </trans-unit>
      <trans-unit id="optsInvalidPathMapFormat">
        <source>Invalid path map. Mappings must be comma separated and of the format 'path=sourcePath'</source>
        <target state="translated">Недействительная карта путей. Сопоставления должны быть разделены запятыми и должны иметь формат "path=исходный_путь"</target>
        <note />
      </trans-unit>
      <trans-unit id="optsCompilerTool">
        <source>Reference an assembly or directory containing a design time tool (Short form: -t)</source>
        <target state="translated">Ссылка на сборку или каталог, содержащие инструмент времени разработки (краткая форма: -t)</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagerUnknown">
        <source>Package manager key '{0}' was not registered in {1}. Currently registered: {2}</source>
        <target state="translated">Ключ "{0}" диспетчера пакетов не был зарегистрирован в {1}. Текущий зарегистрированный ключ: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="packageManagerError">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="couldNotLoadDependencyManagerExtension">
        <source>The dependency manager extension {0} could not be loaded. Message: {1}</source>
        <target state="translated">Не удалось загрузить расширение диспетчера зависимостей {0}. Сообщение: {1}</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>