// Copyright (c) Microsoft Corporation.  All Rights Reserved.  See License.txt in the project root for license information.

%{

#nowarn "1182"  // generated code has lots of unused "parseState"

open System

open Internal.Utilities
open Internal.Utilities.Text.Parsing
open Internal.Utilities.Library
open Internal.Utilities.Library.Extras

open FSharp.Compiler
open FSharp.Compiler.AbstractIL
open FSharp.Compiler.AbstractIL
open FSharp.Compiler.DiagnosticsLogger
open FSharp.Compiler.Features
open FSharp.Compiler.ParseHelpers
open FSharp.Compiler.Syntax
open FSharp.Compiler.SyntaxTrivia
open FSharp.Compiler.Syntax.PrettyNaming
open FSharp.Compiler.SyntaxTreeOps
open FSharp.Compiler.SyntaxTreeOps
open FSharp.Compiler.Text
open FSharp.Compiler.Text.Position
open FSharp.Compiler.Text.Range
open FSharp.Compiler.Xml

#if DEBUG
let debugPrint s =
    if Internal.Utilities.Text.Parsing.Flags.debug then 
        printfn "\n%s" s
#else
let debugPrint s = ignore s
#endif

let exprFromParseError (e:SynExpr) = SynExpr.FromParseError (e, e.Range)

let patFromParseError (e:SynPat) = SynPat.FromParseError(e, e.Range)

// record bindings returned by the recdExprBindings rule has shape:
// (binding, separator-before-this-binding)
// this function converts arguments from form
// binding1 (binding2*sep1, binding3*sep2...) sepN
// to form
// binding1*sep1, binding2*sep2
let rebindRanges first fields lastSep = 
    let rec run (name, mEquals, value) l acc = 
        match l with
        | [] -> List.rev (SynExprRecordField(name, mEquals, value, lastSep) :: acc)
        | (f, m) :: xs -> run f xs (SynExprRecordField(name, mEquals, value, m) :: acc)
    run first fields []

let mkUnderscoreRecdField m = SynLongIdent([ident("_", m)], [], [None]), false

let mkRecdField lidwd = lidwd, true

// Used for 'do expr' in a class.
let mkSynDoBinding (vis, expr, m) = 
    match vis with
    | Some vis -> errorR(Error(FSComp.SR.parsDoCannotHaveVisibilityDeclarations (vis.ToString()), m))
    | None -> ()
    SynBinding(None,
             SynBindingKind.Do,
             false, false, [], PreXmlDoc.Empty, SynInfo.emptySynValData,
             SynPat.Const(SynConst.Unit, m),
             None, expr, m, DebugPointAtBinding.NoneAtDo,
             SynBindingTrivia.Zero)

let mkSynExprDecl (e: SynExpr) = 
    SynModuleDecl.Expr(e, e.Range)

let addAttribs attrs p =  SynPat.Attrib(p, attrs, p.Range)


// This function is called by the generated parser code. Returning initiates error recovery 
// It must be called precisely "parse_error_rich"
let parse_error_rich = Some (fun (ctxt: ParseErrorContext<_>) -> 
    errorR(SyntaxError(box ctxt, ctxt.ParseState.LexBuffer.LexemeRange)))

let reportParseErrorAt m s = errorR(Error(s, m))

let unionRangeWithPos (r:range) p =
    let r2 = mkRange r.FileName p p
    unionRanges r r2

let raiseParseErrorAt m s = 
    reportParseErrorAt m s; 
    // This initiates error recovery
    raise RecoverableParseError 

/// Report a good error at the end of file, e.g. for non-terminated strings
let checkEndOfFileError t = 
  match t with 
  | LexCont.IfDefSkip(_, _, _, m) ->
      reportParseErrorAt m (FSComp.SR.parsEofInHashIf())

  | LexCont.String (_, _, LexerStringStyle.SingleQuote, kind, m) -> 
     if kind.IsInterpolated then
         reportParseErrorAt m (FSComp.SR.parsEofInInterpolatedString())
     else
         reportParseErrorAt m (FSComp.SR.parsEofInString())

  | LexCont.String (_, _, LexerStringStyle.TripleQuote, kind, m) ->
     if kind.IsInterpolated then
         reportParseErrorAt m (FSComp.SR.parsEofInInterpolatedTripleQuoteString())
     else
         reportParseErrorAt m (FSComp.SR.parsEofInTripleQuoteString())

  | LexCont.String (_, _, LexerStringStyle.Verbatim, kind, m) ->
     if kind.IsInterpolated then
         reportParseErrorAt m (FSComp.SR.parsEofInInterpolatedVerbatimString())
     else
         reportParseErrorAt m (FSComp.SR.parsEofInVerbatimString())

  | LexCont.Comment (_, _, _, m) ->
     reportParseErrorAt m (FSComp.SR.parsEofInComment())

  | LexCont.SingleLineComment (_, _, _, m) ->
     reportParseErrorAt m (FSComp.SR.parsEofInComment())

  | LexCont.StringInComment (_, _, LexerStringStyle.SingleQuote, _, m) ->
     reportParseErrorAt m (FSComp.SR.parsEofInStringInComment())

  | LexCont.StringInComment (_, _, LexerStringStyle.Verbatim, _, m) ->
     reportParseErrorAt m (FSComp.SR.parsEofInVerbatimStringInComment())

  | LexCont.StringInComment (_, _, LexerStringStyle.TripleQuote, _, m) ->
     reportParseErrorAt m (FSComp.SR.parsEofInTripleQuoteStringInComment())

  | LexCont.MLOnly (_, _, m) ->
     reportParseErrorAt m (FSComp.SR.parsEofInIfOcaml())

  | LexCont.EndLine(_, _, LexerEndlineContinuation.Skip(_, m)) ->
     reportParseErrorAt m (FSComp.SR.parsEofInDirective())

  | LexCont.EndLine(endifs, nesting, LexerEndlineContinuation.Token)
  | LexCont.Token(endifs, nesting) -> 
      match endifs with 
      | [] -> ()
      | (_, m) :: _  -> reportParseErrorAt m (FSComp.SR.parsNoHashEndIfFound())
      match nesting with 
      | [] -> ()
      | (_, _, m) :: _  -> reportParseErrorAt m (FSComp.SR.parsEofInInterpolatedStringFill())

type BindingSet = BindingSetPreAttrs of range * bool * bool * (SynAttributes -> SynAccess option -> SynAttributes * SynBinding list) * range

let mkClassMemberLocalBindings(isStatic, initialRangeOpt, attrs, vis, BindingSetPreAttrs(_, isRec, isUse, declsPreAttrs, bindingSetRange)) = 
   let ignoredFreeAttrs, decls = declsPreAttrs attrs vis
   let wholeRange = 
       match initialRangeOpt with 
       | None -> bindingSetRange
       | Some m -> unionRanges m bindingSetRange
       // decls could have a leading attribute
       |> fun m -> (m, decls) ||> unionRangeWithListBy (fun (SynBinding(range = m)) -> m)
   if not (isNil ignoredFreeAttrs) then warning(Error(FSComp.SR.parsAttributesIgnored(), wholeRange));
   if isUse then errorR(Error(FSComp.SR.parsUseBindingsIllegalInImplicitClassConstructors(), wholeRange))
   SynMemberDefn.LetBindings (decls, isStatic, isRec, wholeRange)

let mkLocalBindings (mWhole, BindingSetPreAttrs(_, isRec, isUse, declsPreAttrs, _), mIn, body: SynExpr) = 
   let ignoredFreeAttrs, decls = declsPreAttrs [] None
   let mWhole =
       match decls with
       | SynBinding(xmlDoc = xmlDoc) :: _ -> unionRangeWithXmlDoc xmlDoc mWhole
       | _ -> mWhole
   if not (isNil ignoredFreeAttrs) then warning(Error(FSComp.SR.parsAttributesIgnored(), mWhole))
   let mIn =
       mIn
       |> Option.bind (fun (mIn: range) -> 
           if Position.posEq mIn.Start body.Range.Start then
              None
           else
              Some mIn)

   SynExpr.LetOrUse (isRec, isUse, decls, body, mWhole, { InKeyword = mIn }) 

let mkDefnBindings (mWhole, BindingSetPreAttrs(_, isRec, isUse, declsPreAttrs, _bindingSetRange), attrs, vis, attrsm) = 
    if isUse then warning(Error(FSComp.SR.parsUseBindingsIllegalInModules(), mWhole))
    let freeAttrs, decls = declsPreAttrs attrs vis
    // decls might have an extended range due to leading attributes
    let mWhole = (mWhole, decls) ||> unionRangeWithListBy (fun (SynBinding(range = m)) -> m)
    let letDecls = [ SynModuleDecl.Let (isRec, decls, mWhole) ] 
    let attrDecls = if not (isNil freeAttrs) then [ SynModuleDecl.Attributes (freeAttrs, attrsm) ] else [] 
    attrDecls @ letDecls

let idOfPat (parseState:IParseState) m p = 
    match p with
    | SynPat.Wild r when parseState.LexBuffer.SupportsFeature LanguageFeature.WildCardInForLoop ->
        mkSynId r "_"
    | SynPat.Named (SynIdent(id,_), false, _, _) -> id
    | SynPat.LongIdent(longDotId=SynLongIdent([id], _, _); typarDecls=None; argPats=SynArgPats.Pats []; accessibility=None) -> id
    | _ -> raiseParseErrorAt m (FSComp.SR.parsIntegerForLoopRequiresSimpleIdentifier())

let checkForMultipleAugmentations m a1 a2 = 
    if not (isNil a1) && not (isNil a2) then raiseParseErrorAt m (FSComp.SR.parsOnlyOneWithAugmentationAllowed())
    a1 @ a2

let rangeOfLongIdent(lid:LongIdent) =
    System.Diagnostics.Debug.Assert(not lid.IsEmpty, "the parser should never produce a long-id that is the empty list") 
    (lid.Head.idRange, lid) ||> unionRangeWithListBy (fun id -> id.idRange) 

%} 

// Producing these changes the lex state, e.g. string --> token, or nesting level of braces in interpolated strings
%token <byte[] * SynByteStringKind * ParseHelpers.LexerContinuation> BYTEARRAY
%token <string * SynStringKind * ParseHelpers.LexerContinuation> STRING 
%token <string * SynStringKind * ParseHelpers.LexerContinuation> INTERP_STRING_BEGIN_END
%token <string * SynStringKind * ParseHelpers.LexerContinuation> INTERP_STRING_BEGIN_PART 
%token <string * ParseHelpers.LexerContinuation> INTERP_STRING_PART 
%token <string * ParseHelpers.LexerContinuation> INTERP_STRING_END 
%token <ParseHelpers.LexerContinuation> LBRACE RBRACE

%token <string * string> KEYWORD_STRING // Like __SOURCE_DIRECTORY__
%token <string> IDENT 
%token <string> HASH_IDENT 
%token <string> INFIX_STAR_STAR_OP 
%token <string> INFIX_COMPARE_OP 
%token <string> INFIX_AT_HAT_OP 
%token <string> INFIX_BAR_OP 
%token <string> PREFIX_OP
%token <string> INFIX_STAR_DIV_MOD_OP 
%token <string> INFIX_AMP_OP 
%token <string> PLUS_MINUS_OP 
%token <string> ADJACENT_PREFIX_OP 
%token <string> FUNKY_OPERATOR_NAME

/* bool indicates if INT8 was 'bad' max_int+1, e.g. '128'  */
%token <sbyte * bool> INT8 
%token <int16 * bool> INT16
%token <int32 * bool> INT32 INT32_DOT_DOT
%token <int64 * bool> INT64
%token <int64 * bool> NATIVEINT

%token <byte> UINT8
%token <uint16> UINT16
%token <uint32> UINT32
%token <uint64> UINT64
%token <uint64> UNATIVEINT
%token <single> IEEE32
%token <double> IEEE64
%token <char> CHAR
%token <System.Decimal> DECIMAL 
%token <(string * string)> BIGNUM
%token <bool> LET YIELD YIELD_BANG AND_BANG
%token <bool> LESS GREATER /* here the bool indicates if the tokens are part of a type application or type parameter declaration, e.g. C<int>, detected by the lex filter */
%token <string> PERCENT_OP BINDER 
%token <string * bool> LQUOTE RQUOTE  RQUOTE_DOT 
%token BAR_BAR UPCAST DOWNCAST NULL RESERVED MODULE NAMESPACE DELEGATE CONSTRAINT BASE
%token AND AS ASSERT OASSERT ASR BEGIN DO DONE DOWNTO ELSE ELIF END DOT_DOT DOT_DOT_HAT
%token EXCEPTION FALSE FOR FUN FUNCTION IF IN JOIN_IN FINALLY DO_BANG 
%token LAZY OLAZY  MATCH MATCH_BANG  MUTABLE NEW OF 
%token OPEN OR REC THEN TO TRUE TRY TYPE VAL INLINE INTERFACE INSTANCE CONST
%token WHEN WHILE WITH HASH AMP AMP_AMP QUOTE LPAREN RPAREN RPAREN_COMING_SOON RPAREN_IS_HERE STAR COMMA RARROW GREATER_BAR_RBRACK LPAREN_STAR_RPAREN
%token QMARK QMARK_QMARK DOT COLON COLON_COLON COLON_GREATER  COLON_QMARK_GREATER COLON_QMARK COLON_EQUALS SEMICOLON 
%token SEMICOLON_SEMICOLON LARROW EQUALS  LBRACK  LBRACK_BAR  LBRACE_BAR  LBRACK_LESS 
%token BAR_RBRACK BAR_RBRACE UNDERSCORE
%token BAR RBRACK RBRACE_COMING_SOON RBRACE_IS_HERE MINUS DOLLAR
%token GREATER_RBRACK STRUCT SIG 
%token STATIC MEMBER CLASS ABSTRACT OVERRIDE DEFAULT CONSTRUCTOR INHERIT 
%token EXTERN VOID PUBLIC PRIVATE INTERNAL GLOBAL

/* for parser 'escape hatch' out of expression context without consuming the 'recover' token */
%token TYPE_COMING_SOON TYPE_IS_HERE MODULE_COMING_SOON MODULE_IS_HERE

/* for high-precedence tyapps and apps */
%token HIGH_PRECEDENCE_BRACK_APP   /* inserted for f[x], but not f [x] */
%token HIGH_PRECEDENCE_PAREN_APP   /* inserted for f(x) and f<int>(x), but not f (x) */
%token HIGH_PRECEDENCE_TYAPP /* inserted for x<y>, but not x<y */

/* for offside rule */
%token <bool> OLET      /* LexFilter #light converts 'LET' tokens to 'OLET' when starting (CtxtLetDecl(blockLet=true)) */
%token <string> OBINDER /* LexFilter #light converts 'BINDER' tokens to 'OBINDER' when starting (CtxtLetDecl(blockLet=true)) */
%token <bool> OAND_BANG /* LexFilter #light converts 'AND_BANG' tokens to 'OAND_BANG' when starting (CtxtLetDecl(blockLet=true)) */
%token ODO              /* LexFilter #light converts 'DO' tokens to 'ODO' */
%token ODO_BANG         /* LexFilter #light converts 'DO_BANG' tokens to 'ODO_BANG' */
%token OTHEN            /* LexFilter #light converts 'THEN' tokens to 'OTHEN' */
%token OELSE            /* LexFilter #light converts 'ELSE' tokens to 'OELSE' except if immeditely followed by 'if', when they become 'ELIF' */
%token OWITH            /* LexFilter #light converts SOME (but not all) 'WITH' tokens to 'OWITH' */ 
%token OFUNCTION        /* LexFilter #light converts 'FUNCTION' tokens to 'OFUNCTION' */ 
%token OFUN             /* LexFilter #light converts 'FUN' tokens to 'OFUN' */


%token ORESET           /* LexFilter uses internally to force a complete reset on a ';;' */

%token OBLOCKBEGIN      /* LexFilter #light inserts for:
                                  - just after first '=' or ':' when in 'CtxtModuleHead', i.e. after 'module' and sequence of dot/identifier/access tokens
                                  - just after first '=' when in 'CtxtMemberHead'
                                  - just after first '=' when in 'CtxtType' 
                                  - just after 'do' in any context (when opening CtxtDo)
                                  - just after 'finally' in any context 
                                  - just after 'with' (when opening CtxtWithAsAugment)
                                  - just after 'else' (when opening CtxtElse)
                                  - just after 'then' (when opening CtxtThen)
                                  - just after 'interface' (when pushing CtxtParen(INTERFACE), i.e. next token is DEFAULT | OVERRIDE | INTERFACE | NEW | TYPE | STATIC | END | MEMBER | ABSTRACT  | INHERIT | LBRACK_LESS)
                                  - just after 'class' (when pushing CtxtParen(CLASS)
                                  - just after 'class' 
                           But not when opening these CtxtSeqBlocks:
                                  - just after first non-dot/identifier token past 'namespace' 
                                  - just after first '=' when in 'CtxtLetDecl' or 'CtxtWithAsLet' 
                                  - just after 'lazy' in any context
                                  - just after '->' in any context                                  
                                  - when opening CtxtNamespaceHead, CtxtModuleHead 
                        */
%token OBLOCKSEP        /* LexFilter #light inserts when transforming CtxtSeqBlock(NotFirstInSeqBlock, _, AddBlockEnd) to CtxtSeqBlock(FirstInSeqBlock, _, AddBlockEnd) on exact alignment */

/*    REVIEW: merge OEND, ODECLEND, OBLOCKEND and ORIGHT_BLOCK_END into one token */
%token OEND             /* LexFilter #light inserts when closing CtxtFun, CtxtMatchClauses, CtxtWithAsLet _        */
%token ODECLEND         /* LexFilter #light inserts when closing CtxtDo and CtxtLetDecl(block) */
%token ORIGHT_BLOCK_END /* LexFilter #light inserts when closing CtxtSeqBlock(_, _, AddOneSidedBlockEnd) */
%token OBLOCKEND OBLOCKEND_COMING_SOON OBLOCKEND_IS_HERE       /* LexFilter #light inserts when closing CtxtSeqBlock(_, _, AddBlockEnd) */

%token OINTERFACE_MEMBER /* inserted for non-paranthetical use of 'INTERFACE', i.e. not INTERFACE/END */
%token FIXED
%token <token> ODUMMY

/* These are artificial */
%token <string> LEX_FAILURE
%token <ParseHelpers.LexerContinuation> COMMENT WHITESPACE HASH_LINE HASH_LIGHT INACTIVECODE LINE_COMMENT STRING_TEXT EOF
%token <range * string * ParseHelpers.LexerContinuation> HASH_IF HASH_ELSE HASH_ENDIF 

%start signatureFile implementationFile interaction typedSequentialExprEOF typEOF
%type <SynExpr> typedSequentialExprEOF
%type <ParsedImplFile> implementationFile
%type <ParsedSigFile> signatureFile
%type <ParsedScriptInteraction> interaction
%type <Ident> ident
%type <SynType> typ typEOF
%type <SynTypeDefnSig list> tyconSpfnList
%type <SynArgPats * Range> atomicPatsOrNamePatPairs
%type <SynPat list> atomicPatterns
%type <Range * SynExpr> patternResult
%type <SynExpr> declExpr
%type <SynExpr> minusExpr
%type <SynExpr> appExpr
%type <SynExpr> argExpr
%type <SynExpr> declExprBlock
%type <SynPat> headBindingPattern
%type <SynExpr> atomicExprAfterType
%type <SynExpr> typedSequentialExprBlock
%type <SynExpr * bool> atomicExpr
%type <SynTypeDefnSimpleRepr> tyconDefnOrSpfnSimpleRepr
%type <Choice<SynEnumCase, SynUnionCase> list> unionTypeRepr
%type <range * SynMemberDefns> tyconDefnAugmentation
%type <SynExceptionDefn> exconDefn
%type <SynExceptionDefnRepr> exconCore
%type <SynModuleDecl list> moduleDefnsOrExprPossiblyEmptyOrBlock
%type <SynLongIdent> path
%type <SynLongIdent> pathOp
/*     LESS    GREATER        parsedOk   typeArgs           m for each   mWhole  */
%type <range * range option * bool     * SynType list * range list * range> typeArgsActual
/*     LESS    GREATER        typeArgs           m for each   mWhole  */
%type <range * range option * SynType list * range list * range> typeArgsNoHpaDeprecated
%type <SynTypar> typar

/* About precedence rules: 
 * 
 * Tokens and dummy-terminals are given precedence below (lowest first).
 * A rule has precedence of the first token or the dummy terminal given after %prec.
 * The precedence resolve shift/reduce conflicts:
 *   (a) If either rule has no precedence:
 *       S/R: shift over reduce, and
 *       R/R: reduce earlier rule over later rule.
 *   (b) If both rules have precedence:
 *       S/R: choose highest precedence action (precedence of reduce rule vs shift token)
 *            if same precedence: leftassoc gives reduce, rightassoc gives shift, nonassoc error.
 *       R/R: reduce the rule that comes first (textually first in the yacc file)
 *
 * Advice from: http://dinosaur.compilertools.net/yacc/
 *
 *   'Conflicts resolved by precedence are not counted in the number of S/R and R/R
 *    conflicts reported by Yacc. This means that mistakes in the moduleSpfn of
 *    precedences may disguise errors in the input grammar; it is a good idea to be
 *    sparing with precedences, and use them in an essentially ``cookbook'' fashion,
 *    until some experience has been gained'
 *
 * Observation:
 *   It is possible to eliminate conflicts by giving precedence to rules and tokens.
 *   Dummy tokens can be used for the rule and the tokens also need precedence.
 *   The danger is that giving precedence to the tokens may twist the grammar elsewhere.
 *   Maybe it would be good to assign precedence at given locations, e.g.
 *
 *   order: precShort precLong
 *
 *   rule: TokA TokB %@precShort        {action1}     -- assign prec to rule.
 *       | TokA TokB TokC@precLong TokD {action2}     -- assign prec to TokC at this point.
 *
 * Observation: reduce/reduce
 *   If there is a common prefix with a reduce/reduce conflict,
 *   e.g "OPEN path" for topopens and moduleDefns then can factor
 *   opendef = "OPEN path" which can be on both paths.
 *
 * Debugging and checking precedence rules.
 *   - comment out a rule's %prec and see what conflicts are introduced.
 *
 * Dummy terminals (like prec_type_prefix) can assign precedence to a rule.
 * Doc says rule and (shift) token precedence resolves shift/reduce conflict.
 * It seems like dummy terminals can not assign precedence to the shift,
 * but including the tokens in the precedences below will order them.
 * e.g. prec_type_prefix lower precedence than RARROW, LBRACK, IDENT, STAR (all extend types).
 */

/* start with lowest */

%nonassoc prec_args_error             /* less than RPAREN */
%nonassoc prec_atomexpr_lparen_error  /* less than RPAREN */

%right AS

/* prec_wheretyp_prefix = "where typ" lower than extensions, i.e. "WHEN" */
%nonassoc prec_wheretyp_prefix        /* lower than WHEN and RPAREN */
%nonassoc RPAREN RPAREN_COMING_SOON RPAREN_IS_HERE

%right WHEN

/* prec_pat_pat_action = "pattern when expr -> expr"
 * Lower than match extensions - i.e. BAR.
 */
%nonassoc prec_pat_pat_action          /* lower than BAR */

/* "a then b" as an object constructor is very low precedence */
/* Lower than "if a then b" */
%left prec_then_before
%nonassoc prec_then_if 
%left  BAR

%right SEMICOLON  prec_semiexpr_sep OBLOCKSEP
%right prec_defn_sep

/* prec_atompat_pathop = precedence of at atomic pattern, e.g "Constructor".
 * Lower than possible pattern extensions, so "pathOp . extension" does shift not reduce.
 * possible extensions are:
 *  - constant terminals.
 *  - null
 *  - LBRACK = [
 *  - TRUE, FALSE
 
 */
%nonassoc prec_atompat_pathop
%nonassoc INT8 UINT8 INT16 UINT16 INT32 UINT32 INT64 UINT64 NATIVEINT UNATIVEINT IEEE32 IEEE64 CHAR KEYWORD_STRING STRING BYTEARRAY BIGNUM DECIMAL
%nonassoc INTERP_STRING_BEGIN INTERP_STRING_PART INTERP_STRING_END
%nonassoc LPAREN LBRACE LBRACK_BAR 
%nonassoc TRUE FALSE UNDERSCORE NULL


/* prec_typ_prefix        lower than "T  -> T  -> T" extensions.
 * prec_tuptyp_prefix     lower than "T * T * T * T" extensions.
 * prec_tuptyptail_prefix lower than "T * T * T * T" extensions.
 * Lower than possible extensions:
 *  - STAR, IDENT, RARROW
 *  - LBRACK = [ - for "base[]" types              
 * Shifts not reduces.
 */
%nonassoc prec_typ_prefix             /* lower than STAR, IDENT, RARROW etc */
%nonassoc prec_tuptyp_prefix          /* ditto */
%nonassoc prec_tuptyptail_prefix      /* ditto */
%nonassoc prec_toptuptyptail_prefix      /* ditto */
        
%right    RARROW
%nonassoc IDENT LBRACK

/* prec_opt_attributes_none = precedence of no attributes
 * These can prefix LET-moduleDefns.
 * Committing to an opt_attribute (reduce) forces the decision that a following LET is a moduleDefn.
 * At the top-level, it could turn out to be an expr, so prefer to shift and find out...
 */
%nonassoc prec_opt_attributes_none    /* lower than LET, NEW */

/* LET, NEW higher than SEMICOLON so shift
 *   "seqExpr = seqExpr; . let x = y in z"
 *   "seqExpr = seqExpr; . new...."
 */
%nonassoc LET NEW

       
/* Redundant dummies: expr_let, expr_function, expr_fun, expr_match */
/* Resolves conflict: expr_try, expr_if */
%nonassoc expr_let
%nonassoc decl_let
%nonassoc expr_function expr_fun expr_match expr_try expr_do
%nonassoc decl_match decl_do
%nonassoc expr_if                     /* lower than ELSE to disambiguate "if _ then if _ then _ else _" */
%nonassoc ELSE   

/* prec_atomtyp_path = precedence of atomType "path"
 * Lower than possible extension "path<T1, T2>" to allow "path . <" shift.
 * Extensions: LESS
 */
%nonassoc prec_atomtyp_path           /* lower than LESS */
%nonassoc prec_atomtyp_get_path       /* lower than LESS */

/* prec_no_more_attr_bindings = precedence of "moreLocalBindings = ."
 * Lower precedence than AND so further bindings are shifted.
 */
%nonassoc prec_no_more_attr_bindings  /* lower than AND */
%nonassoc OPEN

/* prec_interfaces_prefix - lower than extensions, i.e. INTERFACE */
%nonassoc prec_interfaces_prefix      /* lower than INTERFACE */
%nonassoc INTERFACE

%right LARROW 
%right COLON_EQUALS 
%nonassoc pat_tuple expr_tuple
%left COMMA
%nonassoc open_range_expr
%left DOT_DOT /* for matrix.[1..2, 3..4] the ".." has higher precedence than expression "2 COMMA 3" */
%nonassoc interpolation_fill /* "...{3,N4}..." .NET style fill has higher precedence than "e COMMA e" */
%nonassoc paren_pat_colon
%nonassoc paren_pat_attribs
%left OR BAR_BAR JOIN_IN
%left AND
%left AND_BANG
%left  AMP AMP_AMP 
%nonassoc pat_conj
%nonassoc expr_not
%left COLON_GREATER  COLON_QMARK_GREATER
%left INFIX_COMPARE_OP DOLLAR LESS GREATER EQUALS  INFIX_BAR_OP INFIX_AMP_OP 
%right INFIX_AT_HAT_OP
%right COLON_COLON
%nonassoc pat_isinst 
%left COLON_QMARK
%left PLUS_MINUS_OP MINUS expr_prefix_plus_minus ADJACENT_PREFIX_OP
%left  INFIX_STAR_DIV_MOD_OP STAR PERCENT_OP
%right INFIX_STAR_STAR_OP
%left  QMARK_QMARK
%left head_expr_adjacent_minus
%left expr_app expr_assert expr_lazy LAZY ASSERT
%left arg_expr_adjacent_minus
%left expr_args
%right matching_bar
%left pat_app
%left pat_args
%left PREFIX_OP
%left DOT QMARK
%left HIGH_PRECEDENCE_BRACK_APP
%left HIGH_PRECEDENCE_PAREN_APP
%left HIGH_PRECEDENCE_TYAPP

%nonassoc prec_interaction_empty

%%

/*--------------------------------------------------------------------------*/
/* F# Interactive */

/* A SEMICOLON_SEMICOLON (or EOF) will mark the end of all interaction blocks. */
/* The end of interaction blocks must be determined without needing to lookahead one more token. */
/* A lookahead token would be dropped between parser calls. See bug 1027. */

/* An interaction in F# Interactive */
interaction:
  | interactiveItemsTerminator
     { ParsedScriptInteraction.Definitions ($1, lhs parseState) }

  | SEMICOLON 
     { warning(Error(FSComp.SR.parsUnexpectedSemicolon(), rhs parseState 1))
       ParsedScriptInteraction.Definitions ([], lhs parseState) }

  | OBLOCKSEP
     { ParsedScriptInteraction.Definitions ([], lhs parseState) }


interactiveTerminator: 
  | SEMICOLON_SEMICOLON {}
  | EOF     { checkEndOfFileError $1 }


/* An group of items considered to be one interaction, plus a terminator */
/* Represents the sequence of items swallowed in one interaction by F# Interactive */
/* It is important to make this as large as possible given the chunk of input */
/* text. More or less identical to 'moduleDefns' but where SEMICOLON_SEMICOLON is */
/* not part of the grammar of topSeps and HASH interactions are not part of */
/* the swalloed blob, since things like #use must be processed separately. */
/* REVIEW: limiting the input chunks until the next # directive can lead to */ 
/* discrepencies between whole-file type checking in FSI and FSC. */

interactiveItemsTerminator:
  | interactiveTerminator  
     { [] }

  | interactiveDefns interactiveTerminator 
     { $1 }

  | interactiveExpr  interactiveTerminator 
     { $1 }

  | interactiveHash  interactiveTerminator 
     { $1 }

  | interactiveDefns interactiveSeparators interactiveItemsTerminator 
     { $1 @ $3 }

  | interactiveExpr  interactiveSeparators interactiveItemsTerminator 
     { $1 @ $3 }

  | interactiveHash  interactiveSeparators interactiveItemsTerminator 
     { $1 @ $3 }


/* A group of definitions as part of in one interaction in F# Interactive */
interactiveDefns:
  | moduleDefn
      { $1 }

  | moduleDefn interactiveDefns
      { $1 @ $2 }


/* An expression as part of one interaction in F# Interactive */
interactiveExpr:
  | opt_attributes opt_declVisibility declExpr
      { match $2 with
        | Some vis -> errorR(Error(FSComp.SR.parsUnexpectedVisibilityDeclaration(vis.ToString()), rhs parseState 3))
        | _ -> ()
        let attrDecls = if not (isNil $1) then [ SynModuleDecl.Attributes ($1, rangeOfNonNilAttrs $1) ] else [] in 
        attrDecls @ [ mkSynExprDecl $3 ] }

/* A #directive interaction in F# Interactive */
interactiveHash:      
  | hashDirective 
      { [SynModuleDecl.HashDirective($1, rhs parseState 1)] }


/* One or more separators between interactions in F# Interactive */
interactiveSeparators: 
  | interactiveSeparator { } 

  | interactiveSeparator interactiveSeparators { }

/* One separator between interactions in F# Interactive */
interactiveSeparator: 
  | SEMICOLON { } 
  | OBLOCKSEP { }  

/*--------------------------------------------------------------------------*/
/* #directives - used by both F# Interactive directives and #nowarn etc.    */


/* A #directive in a module, namespace or an interaction */
hashDirective:
  | HASH IDENT hashDirectiveArgs                            
     { let m = match $3 with [] -> rhs2  parseState 1 2 | _ -> rhs2  parseState 1 3
       ParsedHashDirective ($2, $3, m) }


/* The arguments to a #directive */
hashDirectiveArgs: 
  | /* EMPTY */
     { [] } 

  | hashDirectiveArgs hashDirectiveArg 
     { $1 @ [$2] }


/* One argument to a #directive */
hashDirectiveArg:
  | string 
      { let s, kind = $1
        ParsedHashDirectiveArgument.String (s, kind, lhs parseState) }
  | sourceIdentifier 
      { let c,v = $1
        ParsedHashDirectiveArgument.SourceIdentifier (c, v, lhs parseState) }


/*--------------------------------------------------------------------------*/
/* F# Language Proper - signature files */

/* The contents of a signature file */
signatureFile: 
  | fileNamespaceSpecs EOF 
     { checkEndOfFileError $2; $1 }

  | fileNamespaceSpecs error EOF 
     { $1 }

  /* If this rule fires it is kind of catastrophic: error recovery yields no results! */
  /* This will result in NO intellisense for the file! Ideally we wouldn't need this rule */
  /* Note: the compiler assumes there is at least one "fragment", so an empty one is used (see 4488) */
  | error EOF 
     { let emptySigFileFrag = ParsedSigFileFragment.AnonModule([], rhs parseState 1) in 
       ParsedSigFile ([], [emptySigFileFrag]) }     



/* The start of a module declaration */
moduleIntro: 
  | moduleKeyword opt_attributes opt_access opt_rec path
      { if not (isNil $2) then
            parseState.LexBuffer.CheckLanguageFeatureErrorRecover LanguageFeature.AttributesToRightOfModuleKeyword <| rhs parseState 4
        let mModule = rhs parseState 1
        mModule, $4, $5.LongIdent, $3, $2 }


/* The start of a namespace declaration */
namespaceIntro: 
  | NAMESPACE opt_rec path 
      { let mNamespace = rhs parseState 1
        mNamespace, $2, $3.LongIdent, grabXmlDoc(parseState, [], 1)  }


/* The contents of a signature file */
fileNamespaceSpecs: 
  | fileModuleSpec  
      { ParsedSigFile ([], [ ($1 (None, false, [], PreXmlDoc.Empty)) ]) }

  | fileModuleSpec  fileNamespaceSpecList 
      { // If there are namespaces, the first fileModuleImpl may only contain # directives 
        let decls = 
            match ($1 (None, false, [], PreXmlDoc.Empty)) with 
            | ParsedSigFileFragment.AnonModule(decls, m) -> decls  
            | ParsedSigFileFragment.NamespaceFragment(decls = decls) -> decls 
            | ParsedSigFileFragment.NamedModule(SynModuleOrNamespaceSig(range = m)) ->
                raiseParseErrorAt m (FSComp.SR.parsOnlyHashDirectivesAllowed())
        let decls = 
            decls |> List.collect (function 
                | (SynModuleSigDecl.HashDirective (hd, _)) -> [hd]
                | d ->  
                     reportParseErrorAt d.Range (FSComp.SR.parsOnlyHashDirectivesAllowed())
                     [])
        ParsedSigFile (decls, $2) } 


fileNamespaceSpecList: 
  | fileNamespaceSpec fileNamespaceSpecList 
     { $1 :: $2 }

  | fileNamespaceSpec 
     { [$1] }

fileNamespaceSpec: 
  | namespaceIntro deprecated_opt_equals fileModuleSpec 
     { let mNamespace, isRec, path, xml = $1 in ($3 (Some mNamespace, isRec, path, xml)) }


/* The single module declaration that can make up a signature file */
fileModuleSpec: 
  | opt_attributes opt_declVisibility moduleIntro moduleSpfnsPossiblyEmptyBlock 
    { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
      let m2 = rhs parseState 3
      let mDeclsAndAttrs = (List.map (fun (a: SynAttributeList) -> a.Range) $1) @ (List.map (fun (d: SynModuleSigDecl) -> d.Range) $4)
      let mModule, isRec, path2, vis, attribs2 = $3
      let xmlDoc = grabXmlDoc(parseState, $1, 1)
      let m = (m2, mDeclsAndAttrs) ||> unionRangeWithListBy id |> unionRangeWithXmlDoc xmlDoc
      (fun (mNamespaceOpt, isRec2, path, _) ->
        if not (isNil path) then errorR(Error(FSComp.SR.parsNamespaceOrModuleNotBoth(), m2))
        let lid = path@path2
        let trivia: SynModuleOrNamespaceSigTrivia = { ModuleKeyword = Some mModule; NamespaceKeyword = mNamespaceOpt }
        ParsedSigFileFragment.NamedModule(SynModuleOrNamespaceSig(lid, (isRec || isRec2), SynModuleOrNamespaceKind.NamedModule, $4, xmlDoc, $1 @ attribs2, vis, m, trivia)))  }

  | moduleSpfnsPossiblyEmptyBlock 
    { let m = (rhs parseState 1) 
      (fun (mNamespaceOpt, isRec, path, xml) -> 
        match path with
        | [] -> ParsedSigFileFragment.AnonModule($1, m)  
        | _ ->
            let lastDeclRange = List.tryLast $1 |> Option.map (fun decl -> decl.Range) |> Option.defaultValue (rhs parseState 1)
            let m = mkRange lastDeclRange.FileName (lhs parseState).Start lastDeclRange.End
            xml.MarkAsInvalid()
            let trivia = { ModuleKeyword = None; NamespaceKeyword = mNamespaceOpt }
            ParsedSigFileFragment.NamespaceFragment(path, isRec, SynModuleOrNamespaceKind.DeclaredNamespace, $1, PreXmlDoc.Empty, [], m, trivia))  } 


moduleSpfnsPossiblyEmptyBlock: 
  | moduleSpfnsPossiblyEmpty
      { $1 }

  | OBLOCKBEGIN moduleSpfnsPossiblyEmpty oblockend  opt_OBLOCKSEP
      { $2 }

  | OBLOCKBEGIN moduleSpfnsPossiblyEmpty recover 
       { // The lex filter ensures we can only get a mismatch in OBLOCKBEGIN/OBLOCKEND tokens if there was some other kind of error, hence we don't need to report this error
         // reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnClosedBlockInHashLight())   
         $2 
       }

  | OBLOCKBEGIN error oblockend                
       { [] }
      

moduleSpfnsPossiblyEmpty: 
  | moduleSpfns
      { $1 }

  | error
      { [] }

  | /* EMPTY */
      { [] }
      

moduleSpfns: 
  | moduleSpfn  opt_topSeparators moduleSpfns 
     { $1 :: $3 } 

  | error topSeparators moduleSpfns 
     { (* silent recovery *) $3 }

  | moduleSpfn  opt_topSeparators 
     { [$1] } 


moduleSpfn: 
  | hashDirective 
      { SynModuleSigDecl.HashDirective ($1, rhs2 parseState 1 1)  } 

  | valSpfn 
      { $1 }

  | opt_attributes opt_declVisibility moduleIntro colonOrEquals namedModuleAbbrevBlock 
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        let _mModule, isRec, path, vis, attribs2 = $3
        if isRec then raiseParseErrorAt (rhs parseState 3) (FSComp.SR.parsInvalidUseOfRec())
        if not (isSingleton path) then raiseParseErrorAt (rhs parseState 3) (FSComp.SR.parsModuleAbbreviationMustBeSimpleName())
        if not (isNil $1) then raiseParseErrorAt (rhs parseState 1) (FSComp.SR.parsIgnoreAttributesOnModuleAbbreviation())
        if not (isNil attribs2) then raiseParseErrorAt (rhs parseState 3) (FSComp.SR.parsIgnoreAttributesOnModuleAbbreviation())
        match vis with
        | Some vis -> raiseParseErrorAt (rhs parseState 1) (FSComp.SR.parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate(vis.ToString()))
        | _ -> SynModuleSigDecl.ModuleAbbrev(List.head path, $5, rhs2 parseState 1 5) } 

  | opt_attributes opt_declVisibility moduleIntro colonOrEquals moduleSpecBlock
      { let mModule, isRec, path, vis, attribs2 = $3
        let xmlDoc = grabXmlDoc(parseState, $1, 1)
        if not (isSingleton path) then raiseParseErrorAt (rhs parseState 3) (FSComp.SR.parsModuleDefnMustBeSimpleName())
        if isRec then raiseParseErrorAt (rhs parseState 3) (FSComp.SR.parsInvalidUseOfRec())
        let info = SynComponentInfo($1 @ attribs2, None, [], path, xmlDoc, false, vis, rhs parseState 3)
        if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        let m = (rhs2 parseState 1 4, $5)
                ||> unionRangeWithListBy (fun (d: SynModuleSigDecl) -> d.Range)
                |> unionRangeWithXmlDoc xmlDoc
        let trivia: SynModuleSigDeclNestedModuleTrivia = { ModuleKeyword = Some mModule; EqualsRange = $4 }
        SynModuleSigDecl.NestedModule(info, isRec, $5, m, trivia) }

  | opt_attributes opt_declVisibility typeKeyword tyconSpfn tyconSpfnList
      { if Option.isSome $2 then errorR (Error (FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier (), rhs parseState 2))
        let (SynTypeDefnSig (SynComponentInfo (cas, a, cs, b, _xmlDoc, d, d2, d3), equalsRange, typeRepr, withKeyword, members, range)) = $4
        _xmlDoc.MarkAsInvalid()
        let attrs = $1 @ cas
        let xmlDoc = grabXmlDoc(parseState, $1, 1)
        let mTc =
            (d3, attrs) ||> unionRangeWithListBy (fun (a: SynAttributeList) -> a.Range)
            |> unionRanges range
            |> unionRangeWithXmlDoc xmlDoc
        let tc = (SynTypeDefnSig(SynComponentInfo(attrs, a, cs, b, xmlDoc, d, d2, d3), equalsRange, typeRepr,  withKeyword, members, mTc))
        let m = (mTc, $5) ||> unionRangeWithListBy (fun (a: SynTypeDefnSig) -> a.Range) |> unionRanges (rhs parseState 3)
        SynModuleSigDecl.Types (tc :: $5, m) }

  | opt_attributes opt_declVisibility exconSpfn
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        let (SynExceptionSig(SynExceptionDefnRepr(cas, a, b, c, d, d2), withKeyword, members, range)) = $3
        let xmlDoc = grabXmlDoc(parseState, $1, 1)
        let mDefnReprWithAttributes = (d2, $1) ||> unionRangeWithListBy (fun a -> a.Range) |> unionRangeWithXmlDoc xmlDoc
        let mWhole = (mDefnReprWithAttributes, members) ||> unionRangeWithListBy (fun (m: SynMemberSig) -> m.Range)
        let ec = SynExceptionSig(SynExceptionDefnRepr($1@cas, a, b, xmlDoc, d, mDefnReprWithAttributes), withKeyword, members, mWhole)
        SynModuleSigDecl.Exception(ec, mWhole) }

  | openDecl
      { SynModuleSigDecl.Open($1, (rhs parseState 1)) }

valSpfn: 
  | opt_attributes opt_declVisibility VAL opt_attributes opt_inline opt_mutable opt_access nameop opt_explicitValTyparDecls COLON topTypeWithTypeConstraints optLiteralValueSpfn
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        let attr1, attr2, isInline, isMutable, vis2, id, doc, explicitValTyparDecls, (ty, arity), (mEquals, konst: SynExpr option) = ($1), ($4), ($5), ($6), ($7), ($8), grabXmlDoc(parseState, $1, 1), ($9), ($11), ($12)
        if not (isNil attr2) then errorR(Deprecated(FSComp.SR.parsAttributesMustComeBeforeVal(), rhs parseState 4))
        let m = 
            rhs2 parseState 1 11 
            |> unionRangeWithXmlDoc doc
            |> fun m ->
                match konst with
                | None -> m
                | Some e -> unionRanges m e.Range
        let mVal = rhs parseState 3
        let valSpfn = SynValSig((attr1@attr2), id, explicitValTyparDecls, ty, arity, isInline, isMutable, doc, vis2, konst, m, { ValKeyword = Some mVal; WithKeyword = None; EqualsRange = mEquals }) 
        SynModuleSigDecl.Val(valSpfn, m)
      }

/* The optional literal value on a literal specification in a signature */
optLiteralValueSpfn: 
  | /* EMPTY */
      { None, None }

  | EQUALS declExpr 
      { let mEquals = rhs parseState 1
        Some(mEquals), Some($2) }

  | EQUALS OBLOCKBEGIN declExpr oblockend opt_ODECLEND
      { let mEquals = rhs parseState 1
        Some(mEquals), Some($3) }
  

/* A block of definitions in a module in a signature file */
moduleSpecBlock: 

  /* #light-syntax, with no sig/end or begin/end */
  | OBLOCKBEGIN moduleSpfns oblockend 
      { $2 }

  /* #light-syntax, with sig/end or begin/end */
  | OBLOCKBEGIN sigOrBegin moduleSpfnsPossiblyEmpty END oblockend 
      { $3 }

  /* non-#light-syntax, with sig/end or begin/end */
  |             sigOrBegin moduleSpfnsPossiblyEmpty END 
      { $2 }


tyconSpfnList:  
  | AND tyconSpfn tyconSpfnList
     { let xmlDoc = grabXmlDoc(parseState, [], 1)
       let tyconSpfn =
           let (SynTypeDefnSig(SynComponentInfo (a, typars, c, lid, _xmlDoc, fixity, vis, rangeOfLid) as componentInfo, equalsRange, typeRepr, withKeyword, members, range)) = $2
           if xmlDoc.IsEmpty then
               if _xmlDoc.IsEmpty then $2 else
               let range = unionRangeWithXmlDoc _xmlDoc range
               SynTypeDefnSig(componentInfo, equalsRange, typeRepr, withKeyword, members, range)

           else
               _xmlDoc.MarkAsInvalid()
               let range = unionRangeWithXmlDoc xmlDoc range
               SynTypeDefnSig(SynComponentInfo (a, typars, c, lid, xmlDoc, fixity, vis, rangeOfLid), equalsRange, typeRepr, withKeyword, members, range)
       tyconSpfn :: $3 }

  |
     { [] }


/* A type definition in a signature */
tyconSpfn: 
  | typeNameInfo  EQUALS tyconSpfnRhsBlock 
      { let lhsm = rhs parseState 1 
        let mEquals = rhs parseState 2
        $3 lhsm $1 (Some mEquals) }
  | typeNameInfo  opt_classSpfn       
      { let mWithKwd, members = $2
        let (SynComponentInfo(range=range)) = $1
        let m =
            match members with
            | [] ->
                match mWithKwd with
                | None -> range
                | Some mWithKwd -> unionRanges range mWithKwd
            | decls ->
                (range, decls) ||> unionRangeWithListBy (fun (s: SynMemberSig) -> s.Range)
        SynTypeDefnSig($1, None, SynTypeDefnSigRepr.Simple (SynTypeDefnSimpleRepr.None m, m), mWithKwd, members, m) }


/* The right-hand-side of a type definition in a signature */
tyconSpfnRhsBlock: 
  /* This rule allows members to be given for record and union types in the #light syntax */
  /* without the use of 'with' ... 'end'. For example: */
  /*     type R = */
  /*         { a : int } */
  /*         member r.A = a */
  /* It also takes into account that any existing 'with' */
  /* block still needs to be considered and may occur indented or undented from the core type */
  /* representation. */
  | OBLOCKBEGIN  tyconSpfnRhs opt_OBLOCKSEP classSpfnMembers opt_classSpfn oblockend opt_classSpfn  
     { let m = lhs parseState 
       (fun lhsm nameInfo mEquals -> 
           let members = $4 @ (snd $5)
           $2 lhsm nameInfo mEquals (checkForMultipleAugmentations m members (snd $7))) }

  | tyconSpfnRhs opt_classSpfn
     { let m = lhs parseState 
       (fun lhsm nameInfo mEquals ->
           let _, members = $2 
           $1 lhsm nameInfo mEquals members) }


/* The right-hand-side of a type definition in a signature */
tyconSpfnRhs: 
  | tyconDefnOrSpfnSimpleRepr 
     { (fun lhsm nameInfo mEquals augmentation -> 
           let declRange = unionRanges lhsm $1.Range
           let mWhole = (declRange, augmentation) ||> unionRangeWithListBy (fun (mem: SynMemberSig) -> mem.Range)
           SynTypeDefnSig(nameInfo, mEquals, SynTypeDefnSigRepr.Simple ($1, $1.Range), None, augmentation, mWhole)) }

  | tyconClassSpfn 
     {  let needsCheck, (kind, decls) = $1
        let objectModelRange =
            match decls with
            | [] -> lhs parseState
            | decls ->
                let start = mkSynRange parseState.ResultStartPosition parseState.ResultStartPosition
                (start, decls) ||> unionRangeWithListBy (fun (s: SynMemberSig) -> s.Range)

       (fun nameRange nameInfo mEquals augmentation -> 
           if needsCheck && isNil decls then
              reportParseErrorAt nameRange (FSComp.SR.parsEmptyTypeDefinition())
           
           let declRange = unionRanges nameRange objectModelRange
           let mWhole = (declRange, augmentation) ||> unionRangeWithListBy (fun (mem: SynMemberSig) -> mem.Range)
           SynTypeDefnSig(nameInfo, mEquals, SynTypeDefnSigRepr.ObjectModel (kind, decls, objectModelRange), None, augmentation, mWhole)) }

  | DELEGATE OF topType
     { let m = lhs parseState 
       let ty, arity = $3
       let invoke = SynMemberSig.Member(SynValSig([], (SynIdent(mkSynId m "Invoke", None)), inferredTyparDecls, ty, arity, false, false, PreXmlDoc.Empty, None, None, m, SynValSigTrivia.Zero), AbstractMemberFlags SynMemberFlagsTrivia.Zero SynMemberKind.Member, m) 
       (fun nameRange nameInfo mEquals augmentation -> 
           if not (isNil augmentation) then raiseParseErrorAt m (FSComp.SR.parsAugmentationsIllegalOnDelegateType())
           let mWhole = unionRanges nameRange m
           SynTypeDefnSig(nameInfo, mEquals, SynTypeDefnSigRepr.ObjectModel (SynTypeDefnKind.Delegate (ty, arity), [invoke], m), None, [], mWhole)) }


/* The right-hand-side of an object type definition in a signature */
tyconClassSpfn: 
  | classSpfnBlockKindUnspecified
     { let needsCheck, decls = $1 
       needsCheck, (SynTypeDefnKind.Unspecified, decls) }

  | classOrInterfaceOrStruct classSpfnBlock END
     { false, ($1, $2) }

  | classOrInterfaceOrStruct classSpfnBlock recover 
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedClassInterfaceOrStruct())
       false, ($1, $2) }

  | classOrInterfaceOrStruct error END
     { // silent recovery 
       false, ($1, []) }


/* The right-hand-side of an object type definition in a signature with no explicit kind */
classSpfnBlockKindUnspecified:
  | OBLOCKBEGIN  classSpfnMembers oblockend 
     { true, $2 }

  | OBLOCKBEGIN  classSpfnMembers recover
     { if not $3 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFileTypeSignature())
       false, $2 }

  /* NOTE: these rules enable the non-#light syntax to omit the kind of a type. */
  | BEGIN  classSpfnBlock END 
     { false, $2 }

  | BEGIN  classSpfnBlock recover
     { false, $2 }


/* The right-hand-side of an object type definition in a signature */
classSpfnBlock:
  | OBLOCKBEGIN  classSpfnMembers oblockend 
      { $2 }

  | OBLOCKBEGIN  classSpfnMembers recover 
      { if not $3 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFileTypeSignature())
        $2 }
  | classSpfnMembers 
      { $1 }

/* The members of an object type definition in a signature, possibly empty */
classSpfnMembers:  
  | classSpfnMembersAtLeastOne 
     { $1 } 

  |  /* EMPTY */
     { [] }


/* The members of an object type definition in a signature */
classSpfnMembersAtLeastOne:  
  | classMemberSpfn opt_seps classSpfnMembers 
     { $1 :: $3 } 


/* A object member in a signature */
classMemberSpfn:
  | opt_attributes opt_declVisibility memberSpecFlags opt_inline opt_access nameop opt_explicitValTyparDecls COLON topTypeWithTypeConstraints classMemberSpfnGetSet optLiteralValueSpfn
     { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
       let isInline, doc, vis2, id, explicitValTyparDecls, (ty, arity), (mEquals, optLiteralValue) = $4, grabXmlDoc(parseState, $1, 1), $5, $6, $7, $9, $11
       let mWith, getSetRangeOpt, getSet = $10 
       let getSetAdjuster arity = match arity, getSet with SynValInfo([], _), SynMemberKind.Member -> SynMemberKind.PropertyGet | _ -> getSet
       let wholeRange = 
           let m = rhs parseState 3 
           match getSetRangeOpt with 
           | None -> unionRanges m ty.Range
           | Some m2 -> unionRanges m m2
           |> fun m -> (m, $1) ||> unionRangeWithListBy (fun (a: SynAttributeList) -> a.Range)
           |> unionRangeWithXmlDoc doc
           |> fun m -> 
               match optLiteralValue with
               | None -> m
               | Some e -> unionRanges m e.Range
       let valSpfn = SynValSig($1, id, explicitValTyparDecls, ty, arity, isInline, false, doc, vis2, optLiteralValue, wholeRange, { ValKeyword = None; WithKeyword = mWith; EqualsRange = mEquals })
       let _, flags = $3 
       SynMemberSig.Member(valSpfn, flags (getSetAdjuster arity), wholeRange) }

  | opt_attributes opt_declVisibility interfaceMember appType  
     { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
       SynMemberSig.Interface ($4, unionRanges (rhs parseState 3) ($4).Range) }

  | opt_attributes opt_declVisibility INHERIT appType 
     { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
       SynMemberSig.Inherit ($4, unionRanges (rhs parseState 3) ($4).Range) }

  | opt_attributes opt_declVisibility VAL fieldDecl 
     { let wholeRange = rhs2 parseState 1 4
       if Option.isSome $2 then errorR (Error (FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier (), rhs parseState 2))
       let (SynField(_, _, _, _, _, xmlDoc, _, _)) as field = $4 $1 false wholeRange
       let wholeRange = unionRangeWithXmlDoc xmlDoc wholeRange
       SynMemberSig.ValField (field, wholeRange) }

  | opt_attributes opt_declVisibility STATIC VAL fieldDecl 
     { let wholeRange = rhs2 parseState 1 5
       if Option.isSome $2 then errorR (Error (FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier (), rhs parseState 2))
       let (SynField(_, _, _, _, _, xmlDoc, _, _)) as field = $5 $1 true wholeRange
       let wholeRange = unionRangeWithXmlDoc xmlDoc wholeRange
       SynMemberSig.ValField(field, wholeRange) }

  | opt_attributes  opt_declVisibility STATIC typeKeyword tyconSpfn 
     { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
       SynMemberSig.NestedType($5, rhs2 parseState 1 5) }

  | opt_attributes opt_declVisibility NEW COLON topTypeWithTypeConstraints  
     { let vis, doc, (ty, valSynInfo) = $2, grabXmlDoc(parseState, $1, 1), $5
       let m = unionRanges (rhs parseState 1) ty.Range |> unionRangeWithXmlDoc doc
       let isInline = false 
       let valSpfn = SynValSig ($1, (SynIdent(mkSynId (rhs parseState 3) "new", None)), noInferredTypars, ty, valSynInfo, isInline, false, doc, vis, None, m, SynValSigTrivia.Zero)
       SynMemberSig.Member(valSpfn, CtorMemberFlags SynMemberFlagsTrivia.Zero, m) }


/* The optional "with get, set" on a member in a signature */
classMemberSpfnGetSet:
  | /* EMPTY */ 
    { None, None, SynMemberKind.Member }

  | WITH classMemberSpfnGetSetElements 
    { let mWith = rhs parseState 1
      Some mWith, Some (rhs2 parseState 1 2), $2 }

  | OWITH classMemberSpfnGetSetElements OEND
    { let mWith = rhs parseState 1
      Some mWith, Some (rhs2 parseState 1 2), $2 }

  | OWITH classMemberSpfnGetSetElements error
    {  let mWith = rhs parseState 1
       reportParseErrorAt mWith (FSComp.SR.parsUnmatchedWith())
       Some mWith, Some (rhs2 parseState 1 2), $2 }


/* The "get, set" on a property member in a signature */
classMemberSpfnGetSetElements:
  | nameop 
    { (let (SynIdent(id:Ident, _)) = $1 
       if id.idText = "get" then SynMemberKind.PropertyGet 
       else if id.idText = "set" then SynMemberKind.PropertySet 
       else raiseParseErrorAt (rhs parseState 1) (FSComp.SR.parsGetOrSetRequired())) }

  | nameop COMMA nameop
    { let (SynIdent(id, _)) = $1 
      let (SynIdent(id2, _)) = $3
      if not ((id.idText = "get" && id2.idText = "set") ||
              (id.idText = "set" && id2.idText = "get")) then 
         raiseParseErrorAt (rhs2 parseState 1 3) (FSComp.SR.parsGetOrSetRequired())
      SynMemberKind.PropertyGetSet }

memberSpecFlags: 
  | memberFlags { $1 }  
  | ABSTRACT
      { let mAbstract = rhs parseState 1
        (false, AbstractMemberFlags(AbstractSynMemberFlagsTrivia mAbstract)) }
  | ABSTRACT MEMBER
      { let mAbstract = rhs parseState 1
        let mMember = rhs parseState 2
        (false, AbstractMemberFlags(AbstractMemberSynMemberFlagsTrivia mAbstract mMember)) }


/* Part of an exception definition in a signature file */
exconSpfn: 
  | exconCore opt_classSpfn 
     { let mWithKwd, members = $2
       SynExceptionSig($1, mWithKwd, members, lhs parseState) }
  

/* The optional augmentation on a type definition in a signature */
opt_classSpfn: 
  | WITH classSpfnBlock declEnd 
     { let mWithKwd = rhs parseState 1
       (Some mWithKwd), $2 } 

  | /* EMPTY */                   
     { None, [] }


/*--------------------------------------------------------------------------*/
/* F# Language Proper - implementation files */

/* The contents of an implementation file */
implementationFile: 
  | fileNamespaceImpls EOF 
     { checkEndOfFileError $2; $1 }

  | fileNamespaceImpls error EOF 
     { $1 }

  /* If this rule fires it is kind of catastrophic: error recovery yields no results! */
  /* This will result in NO intellisense for the file! Ideally we wouldn't need this rule */
  /* Note: the compiler assumes there is at least one "fragment", so an empty one is used (see 4488) */
  | error EOF 
     { let emptyImplFileFrag = ParsedImplFileFragment.AnonModule([], rhs parseState 1) in 
       ParsedImplFile ([], [emptyImplFileFrag]) }


/* The sequence of namespace definitions or a single module definition that makes up an implementation file */
fileNamespaceImpls: 
  | fileModuleImpl   
      { ParsedImplFile ([], [ ($1 (None, false, [], PreXmlDoc.Empty)) ]) }

  | fileModuleImpl fileNamespaceImplList 
      { // If there are namespaces, the first fileModuleImpl may only contain # directives 
        let decls = 
            match ($1 (None, false, [], PreXmlDoc.Empty)) with 
            | ParsedImplFileFragment.AnonModule(decls, m) -> decls  
            | ParsedImplFileFragment.NamespaceFragment(decls = decls) -> decls 
            | ParsedImplFileFragment.NamedModule(SynModuleOrNamespace(range = m)) ->
                raiseParseErrorAt m (FSComp.SR.parsOnlyHashDirectivesAllowed())
        let decls = 
            decls |> List.collect (function 
                | (SynModuleDecl.HashDirective (hd, _)) -> [hd]
                | d ->  
                     reportParseErrorAt d.Range (FSComp.SR.parsOnlyHashDirectivesAllowed())
                     [])
        ParsedImplFile (decls, $2) } 


/* The sequence of namespace definitions that can make up an implementation file */
fileNamespaceImplList: 
  | fileNamespaceImpl fileNamespaceImplList 
     { $1 :: $2 }

  | fileNamespaceImpl 
     { [$1] }


/* A single namespace definition in an implementation file */
fileNamespaceImpl: 
  | namespaceIntro deprecated_opt_equals fileModuleImpl 
     { let mNamespace, isRec, path, xml = $1 in ($3 (Some mNamespace, isRec, path, xml)) }


/* A single module definition in an implementation file */
fileModuleImpl: 
  | opt_attributes opt_declVisibility moduleIntro moduleDefnsOrExprPossiblyEmptyOrBlock
    { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
      let m2 = rhs parseState 3
      let mDeclsAndAttrs = (List.map (fun (a: SynAttributeList) -> a.Range) $1) @ (List.map (fun (d: SynModuleDecl) -> d.Range) $4)
      let xmlDoc = grabXmlDoc(parseState, $1, 1)
      let m = (m2, mDeclsAndAttrs) ||> unionRangeWithListBy id |> unionRangeWithXmlDoc xmlDoc
      let mModule, isRec2, path2, vis, attribs2 = $3
      (fun (mNamespaceOpt, isRec, path, _) ->
        if not (isNil path) then errorR(Error(FSComp.SR.parsNamespaceOrModuleNotBoth(), m2))
        let lid = path@path2
        let trivia: SynModuleOrNamespaceTrivia = { ModuleKeyword = Some mModule; NamespaceKeyword = mNamespaceOpt }
        ParsedImplFileFragment.NamedModule(SynModuleOrNamespace(lid, (isRec || isRec2), SynModuleOrNamespaceKind.NamedModule, $4, xmlDoc, $1@attribs2, vis, m, trivia))) }

  | moduleDefnsOrExprPossiblyEmptyOrBlock 
    { let m = (rhs parseState 1) 
      (fun (mNamespaceOpt, isRec, path, xml) -> 
        match path with 
        | [] -> ParsedImplFileFragment.AnonModule($1, m)  
        | _ ->
            let lastDeclRange = List.tryLast $1 |> Option.map (fun decl -> decl.Range) |> Option.defaultValue (rhs parseState 1)
            let m = mkRange lastDeclRange.FileName (lhs parseState).Start lastDeclRange.End
            xml.MarkAsInvalid()
            let trivia: SynModuleOrNamespaceTrivia = { ModuleKeyword = None; NamespaceKeyword = mNamespaceOpt }
            ParsedImplFileFragment.NamespaceFragment(path, isRec, SynModuleOrNamespaceKind.DeclaredNamespace, $1, PreXmlDoc.Empty, [], m, trivia)) } 


/* A collection/block of definitions or expressions making up a module or namespace, possibly empty */
moduleDefnsOrExprPossiblyEmptyOrBlock:
  | OBLOCKBEGIN moduleDefnsOrExprPossiblyEmpty oblockend opt_OBLOCKSEP
     { $2 }

  | OBLOCKBEGIN moduleDefnsOrExprPossiblyEmpty recover 
     { // The lex filter ensures we can only get a mismatch in OBLOCKBEGIN/OBLOCKEND tokens if there was some other kind of error, hence we don't need to report this error
       // reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnClosedBlockInHashLight())   
       $2 }

  | OBLOCKBEGIN error oblockend                
     { []  }

  | moduleDefnsOrExprPossiblyEmpty
     { $1 }


/* A collection of definitions or expressions making up a module or namespace, possibly empty */
moduleDefnsOrExprPossiblyEmpty:
  | moduleDefnsOrExpr
     { $1 }

  | /* EMPTY */
     { [] }


/* A collection of definitions or expressions making up a module or namespace */
/* A naked expression is only allowed at the start of a module/file, or straight after a topSeparators */
moduleDefnsOrExpr:
  | opt_attributes opt_declVisibility declExpr topSeparators moduleDefnsOrExpr 
      { match $2 with
        | Some vis -> errorR(Error(FSComp.SR.parsUnexpectedVisibilityDeclaration(vis.ToString()), rhs parseState 3))
        | _ -> ()
        let attrDecls = if not (isNil $1) then [ SynModuleDecl.Attributes ($1, rangeOfNonNilAttrs $1) ] else [] 
        attrDecls @ mkSynExprDecl $3 :: $5 }

  | opt_attributes opt_declVisibility declExpr topSeparators
      { match $2 with
        | Some vis -> errorR(Error(FSComp.SR.parsUnexpectedVisibilityDeclaration(vis.ToString()), rhs parseState 3))
        | _ -> ()
        let attrDecls = if not (isNil $1) then [ SynModuleDecl.Attributes ($1, rangeOfNonNilAttrs $1) ] else [] 
        attrDecls @ [ mkSynExprDecl $3 ] }

  | opt_attributes opt_declVisibility declExpr
      { match $2 with
        | Some vis -> errorR(Error(FSComp.SR.parsUnexpectedVisibilityDeclaration(vis.ToString()), rhs parseState 3))
        | _ -> ()
        let attrDecls = if not (isNil $1) then [ SynModuleDecl.Attributes ($1, rangeOfNonNilAttrs $1) ] else [] 
        attrDecls @ [ mkSynExprDecl $3 ] }

  | moduleDefns 
      { $1 } 

  | opt_attributes error
     { if not (isNil $1) then [ SynModuleDecl.Attributes ($1, rangeOfNonNilAttrs $1) ] else [] }


/* A sequence of definitions in a namespace or module */
moduleDefns:
  | moduleDefnOrDirective moduleDefns 
      { $1 @ $2 } 

  | moduleDefnOrDirective topSeparators moduleDefnsOrExpr 
      { $1 @ $3 } 

  | moduleDefnOrDirective
      { $1 }

  | moduleDefnOrDirective topSeparators
      { $1 }

  | error topSeparators moduleDefnsOrExpr 
      { $3 } 


/* A single definition in a namespace, module or F# Interactive file*/
moduleDefnOrDirective:
  | moduleDefn 
      { $1  } 

  | hashDirective 
      { [ SynModuleDecl.HashDirective ($1, rhs2 parseState 1 1) ] } 


/* A single definition in a namespace, module or interaction. */
/* This is used by both "fsi" interactions and "source file" fragments defined by moduleDefns */
moduleDefn:

  /* 'let' definitions in non-#light*/
  | opt_attributes opt_declVisibility defnBindings                   %prec decl_let 
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        parseState.ResetSynArgNameGenerator()
        let (BindingSetPreAttrs(_, _, _, _, mWhole)) = $3 
        mkDefnBindings (mWhole, $3, $1, $2, mWhole)  }

  /* 'let' or 'do' definitions in #light */
  | opt_attributes opt_declVisibility hardwhiteLetBindings          %prec decl_let 
      { let hwlb, m, _ = $3
        if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        parseState.ResetSynArgNameGenerator()
        mkDefnBindings (m, hwlb, $1, $2, m)  }

  /* 'do' definitions in non-#light*/
  | opt_attributes opt_declVisibility doBinding %prec decl_let 
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        let mWhole = rhs parseState 3 
        mkDefnBindings (mWhole, $3, $1, $2, mWhole) }
  
  /* 'type' definitions */
  | opt_attributes opt_declVisibility typeKeyword tyconDefn tyconDefnList
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        let xmlDoc = grabXmlDoc(parseState, $1, 1)
        let (SynTypeDefn(SynComponentInfo(cas, a, cs, b, _xmlDoc, d, d2, d3), e, f, g, h, trivia)) = $4
        _xmlDoc.MarkAsInvalid()
        let attrs = $1@cas
        let mTc = (h, attrs) ||> unionRangeWithListBy (fun (a: SynAttributeList) -> a.Range) |> unionRangeWithXmlDoc xmlDoc
        let mType = rhs parseState 3
        let tc = (SynTypeDefn(SynComponentInfo(attrs, a, cs, b, xmlDoc, d, d2, d3), e, f, g, mTc, { trivia with TypeKeyword = Some mType }))
        let types = tc :: $5
        [ SynModuleDecl.Types(types, (rhs parseState 3, types) ||> unionRangeWithListBy (fun t -> t.Range) ) ] }

  /* 'exception' definitions */
  | opt_attributes opt_declVisibility exconDefn
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        let (SynExceptionDefn(SynExceptionDefnRepr(cas, a, b, c, d, d2), withKeyword, e, f)) = $3
        let xmlDoc = grabXmlDoc(parseState, $1, 1)
        let defnReprRange = (d2, $1) ||> unionRangeWithListBy (fun a -> a.Range) |> unionRangeWithXmlDoc xmlDoc
        let mWhole = (f, $1) ||> unionRangeWithListBy (fun a -> a.Range) |> unionRangeWithXmlDoc xmlDoc
        let ec = (SynExceptionDefn(SynExceptionDefnRepr($1@cas, a, b, xmlDoc, d, defnReprRange), withKeyword, e, mWhole))
        [ SynModuleDecl.Exception(ec, mWhole) ] }

  /* 'module' definitions */
  | opt_attributes opt_declVisibility moduleIntro EQUALS namedModuleDefnBlock
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        let attribs, (mModule, isRec, path, vis, attribs2) = $1, $3
        let xmlDoc = grabXmlDoc(parseState, $1, 1)
        match $5 with
        | Choice1Of2 eqn -> 
            if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
            if isRec then raiseParseErrorAt (rhs parseState 3) (FSComp.SR.parsInvalidUseOfRec())
            if not (isSingleton path) then raiseParseErrorAt (rhs parseState 3) (FSComp.SR.parsModuleAbbreviationMustBeSimpleName())
            if not (isNil attribs) then raiseParseErrorAt (rhs parseState 1) (FSComp.SR.parsIgnoreAttributesOnModuleAbbreviation())
            if not (isNil attribs2) then raiseParseErrorAt (rhs parseState 3) (FSComp.SR.parsIgnoreAttributesOnModuleAbbreviation())
            match vis with
            | Some vis -> raiseParseErrorAt (rhs parseState 1) (FSComp.SR.parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate(vis.ToString()))
            | None -> ()
            [ SynModuleDecl.ModuleAbbrev(List.head path, eqn, (rhs parseState 3, eqn) ||> unionRangeWithListBy (fun id -> id.idRange) ) ]
        | Choice2Of2 def -> 
            if not (isSingleton path) then raiseParseErrorAt (rhs parseState 3) (FSComp.SR.parsModuleAbbreviationMustBeSimpleName())
            let info = SynComponentInfo(attribs @ attribs2, None, [], path, xmlDoc, false, vis, rhs parseState 3)
            let mEquals = rhs parseState 4
            let trivia: SynModuleDeclNestedModuleTrivia = { ModuleKeyword = Some mModule; EqualsRange = Some mEquals }
            [ SynModuleDecl.NestedModule(info, isRec, def, false, ((rhs2 parseState 1 4, def) ||> unionRangeWithListBy (fun d -> d.Range) |> unionRangeWithXmlDoc xmlDoc), trivia)] }

  /* unattached custom attributes */
  | attributes recover
      { errorR(Error(FSComp.SR.parsAttributeOnIncompleteCode(), rhs parseState 1))
        [ SynModuleDecl.Attributes($1, rhs parseState 1) ] }

  /* 'open' declarations */
  | openDecl
      { [ SynModuleDecl.Open($1, (rhs parseState 1)) ] }

openDecl:
  /* 'open' declarations */
  | OPEN path
      { SynOpenDeclTarget.ModuleOrNamespace($2.LongIdent, (rhs parseState 2)) }

  | OPEN typeKeyword appType
      { SynOpenDeclTarget.Type($3, (rhs parseState 3)) }

/* The right-hand-side of a module abbreviation definition */ 
/* This occurs on the right of a module abbreviation (#light encloses the r.h.s. with OBLOCKBEGIN/OBLOCKEND) */
/* We don't use it in signature files */
namedModuleAbbrevBlock:
  | OBLOCKBEGIN path oblockend 
     { $2.LongIdent }

  | path 
     { $1.LongIdent  }
       

/* The right-hand-side of a module definition */ 
namedModuleDefnBlock:
  | OBLOCKBEGIN wrappedNamedModuleDefn oblockend 
     { Choice2Of2 $2  }

  | OBLOCKBEGIN wrappedNamedModuleDefn recover
     { // The lex filter ensures we can only get a mismatch in OBLOCKBEGIN/OBLOCKEND tokens if there was some other kind of error, hence we don't need to report this error
       Choice2Of2 $2 }

  | OBLOCKBEGIN moduleDefnsOrExpr oblockend 
       { // There is an ambiguity here 
         // In particular, consider the following two:
         //
         // module M2 = 
         //    System.DateTime.Now
         // module M2 = 
         //    Microsoft.FSharp.Core.List
         // The second is a module abbreviation, the first a module containing a single expression.
         // The resolution is in favour of the module abbreviation, i.e. anything of the form 
         //    module M2 = ID.ID.ID.ID
         // will be taken as a module abbreviation, regardles of the identifiers themselves.
         //
         // This is similar to the ambiguitty between 
         //    type X = int
         // and 
         //    type X = OneValue
         // However in that case we do use type name lookup to make the resolution.

         match $2 with 
         | [ SynModuleDecl.Expr (LongOrSingleIdent(false, SynLongIdent(path, _, _), None, _), _) ] -> 
             Choice1Of2  path
         | _ -> 
             Choice2Of2 $2 
       }

  | OBLOCKBEGIN moduleDefnsOrExpr recover 
     { // The lex filter ensures we can only get a mismatch in OBLOCKBEGIN/OBLOCKEND tokens if there was some other kind of error, hence we don't need to report this error
       // reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnClosedBlockInHashLight())   
       Choice2Of2 $2 }

  | OBLOCKBEGIN error oblockend                
     { Choice2Of2 [] }

  | wrappedNamedModuleDefn 
     { Choice2Of2 $1 }

  | path 
     { Choice1Of2 $1.LongIdent }


/* A module definition that includes a 'begin'...'end' (rarely used in F# with #light syntax) */ 
wrappedNamedModuleDefn:
  | structOrBegin moduleDefnsOrExprPossiblyEmpty END 
     { $2 }

  | structOrBegin moduleDefnsOrExprPossiblyEmpty recover 
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBeginOrStruct())  
       $2 }

  | structOrBegin error END                      
     { [] }


tyconDefnAugmentation: 
  | WITH classDefnBlock declEnd
     { let mWithKwd = rhs parseState 1
       mWithKwd, $2 }


/* An optional list of custom attributes */
opt_attributes:
  | attributes                                
      { $1 }

  |            %prec prec_opt_attributes_none 
      { [] }

/* A list of sets of custom attributes */
attributes: 
  | attributeList                     
     { $1 }

  | attributeList attributes
     { $1 @ $2 }


/* One set of custom attributes, including [< ... >] */
attributeList:
  | LBRACK_LESS attributeListElements opt_seps GREATER_RBRACK opt_OBLOCKSEP
      { mkAttributeList $2 (rhs2 parseState 1 4) }

  | LBRACK_LESS error GREATER_RBRACK opt_OBLOCKSEP
      { mkAttributeList [] (rhs2 parseState 1 3) }

  | LBRACK_LESS attributeListElements opt_seps ends_coming_soon_or_recover
      { if not $4 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedLBrackLess())
        mkAttributeList $2 (rhs2 parseState 1 2) }

  | LBRACK_LESS ends_coming_soon_or_recover
      { if not $2 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedLBrackLess())
        mkAttributeList [] (rhs parseState 1) }


/* One set of custom attributes, not including [< ... >] */
attributeListElements: 
  | attribute                     
     { [$1] }

  | attributeListElements seps attribute 
     { $1 @ [$3] }


/* One custom attribute */
attribute:
  /* A custom attribute */
  | path opt_HIGH_PRECEDENCE_APP opt_atomicExprAfterType 
     { let arg = match $3 with None -> mkSynUnit $1.Range | Some e -> e 
       ({ TypeName=$1; ArgExpr=arg; Target=None; AppliesToGetterAndSetter=false; Range=$1.Range } : SynAttribute) }

  /* A custom attribute with an attribute target */
  | attributeTarget path opt_HIGH_PRECEDENCE_APP opt_atomicExprAfterType 
     { let arg = match $4 with None -> mkSynUnit $2.Range | Some e -> e 
       ({ TypeName=$2; ArgExpr=arg; Target=$1; AppliesToGetterAndSetter=false; Range=$2.Range } : SynAttribute) }

  /* A custom attribute with an attribute target */
  | attributeTarget OBLOCKBEGIN path oblockend opt_HIGH_PRECEDENCE_APP opt_atomicExprAfterType 
     { let arg = match $6 with None -> mkSynUnit $3.Range | Some e -> e 
       ({ TypeName=$3; ArgExpr=arg; Target=$1; AppliesToGetterAndSetter=false; Range=$3.Range } : SynAttribute) }


/* The target of a custom attribute */
attributeTarget: 
  | moduleKeyword COLON 
      { Some(ident("module", (rhs parseState 1))) } 

  | typeKeyword COLON 
      { Some(ident("type", (rhs parseState 1))) } 

  | ident COLON { Some($1) } 

  /* return */
  | YIELD COLON 
      { if $1 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsSyntaxError())
        Some(ident("return", (rhs parseState 1))) } 

/* Flags on a member */
memberFlags: 
  | STATIC MEMBER 
      { let mStatic = rhs parseState 1
        let mMember = rhs parseState 2
        (true, StaticMemberFlags(StaticMemberSynMemberFlagsTrivia mStatic mMember)) }  
  | MEMBER
      { let mMember = rhs parseState 1
        (false, NonVirtualMemberFlags(MemberSynMemberFlagsTrivia mMember)) }
  | OVERRIDE
      { let mOverride = rhs parseState 1
        (false, OverrideMemberFlags(OverrideSynMemberFlagsTrivia mOverride)) }
  | DEFAULT
      { let mDefault = rhs parseState 1
        (false, OverrideMemberFlags(DefaultSynMemberFlagsTrivia mDefault)) }

/* The name of a type in a signature or implementation, possibly with type parameters and constraints */
typeNameInfo: 
  | opt_attributes tyconNameAndTyparDecls opt_typeConstraints
     { let typars, lid, fixity, vis = $2
       let xmlDoc = grabXmlDoc(parseState, $1, 1)
       SynComponentInfo ($1, typars, $3, lid, xmlDoc, fixity, vis, rangeOfLid lid) }

/* Part of a set of type definitions */
tyconDefnList:  
  | AND tyconDefn tyconDefnList 
     { let xmlDoc = grabXmlDoc(parseState, [], 1)
       let tyconDefn =
           let (SynTypeDefn(SynComponentInfo (a, typars, c, lid, _xmlDoc, fixity, vis, rangeOfLid) as componentInfo, typeRepr, members, implicitConstructor, range, trivia)) = $2
           if xmlDoc.IsEmpty then
               if _xmlDoc.IsEmpty then $2 else
               let range = unionRangeWithXmlDoc _xmlDoc range
               SynTypeDefn(componentInfo, typeRepr, members, implicitConstructor, range, trivia)

           else
               _xmlDoc.MarkAsInvalid()
               let range = unionRangeWithXmlDoc xmlDoc range
               SynTypeDefn(SynComponentInfo (a, typars, c, lid, xmlDoc, fixity, vis, rangeOfLid), typeRepr, members, implicitConstructor, range, trivia)
       tyconDefn :: $3 }
  |                             
     { [] }

/* A type definition */
tyconDefn: 
  | typeNameInfo 
     { SynTypeDefn($1, SynTypeDefnRepr.Simple(SynTypeDefnSimpleRepr.None($1.Range), $1.Range), [], None, $1.Range, SynTypeDefnTrivia.Zero) }

  | typeNameInfo opt_equals tyconDefnRhsBlock 
     { match $2 with
       | Some _ -> ()
       | None ->
            let (SynComponentInfo(_, _, _, lid, _, _, _, _)) = $1 
            // While the spec doesn't allow long idents here, the parser doesn't enforce this, so take one ident
            let typeNameId = List.last lid
            raiseParseErrorAt (rhs parseState 2) (FSComp.SR.parsEqualsMissingInTypeDefinition(typeNameId.ToString()))
       
       let nameRange = rhs parseState 1
       let (tcDefRepr:SynTypeDefnRepr), mWith ,members = $3 nameRange
       let declRange = unionRanges (rhs parseState 1) tcDefRepr.Range
       let mWhole = (declRange, members) ||> unionRangeWithListBy (fun (mem:SynMemberDefn) -> mem.Range)
       let trivia: SynTypeDefnTrivia = { TypeKeyword = None; EqualsRange = $2; WithKeyword = mWith }
       SynTypeDefn($1, tcDefRepr, members, None, mWhole, trivia) }

  | typeNameInfo tyconDefnAugmentation
     { let mWithKwd, classDefns = $2
       let m = (rhs parseState 1, classDefns) ||> unionRangeWithListBy (fun mem -> mem.Range)
       SynTypeDefn($1, SynTypeDefnRepr.ObjectModel(SynTypeDefnKind.Augmentation mWithKwd, [], m), classDefns, None, m, SynTypeDefnTrivia.Zero) }

  | typeNameInfo opt_attributes opt_declVisibility opt_HIGH_PRECEDENCE_APP  simplePatterns optAsSpec EQUALS tyconDefnRhsBlock
     { let vis, spats, az = $3, $5, $6
       let nameRange = rhs parseState 1
       let (tcDefRepr, mWith, members) = $8 nameRange
       let (SynComponentInfo(_, _, _, lid, _, _, _, _)) = $1
       let mEquals = rhs parseState 7
       // Gets the XML doc comments prior to the implicit constructor
       let xmlDoc = grabXmlDoc(parseState, $2, 2)
       let memberCtorPattern = SynMemberDefn.ImplicitCtor (vis, $2, spats, az, xmlDoc, rangeOfLid lid)
       let tcDefRepr = 
         match tcDefRepr with
         | SynTypeDefnRepr.ObjectModel (k, cspec, m) -> SynTypeDefnRepr.ObjectModel (k, memberCtorPattern :: cspec, m)
         | _ -> reportParseErrorAt (rhs2 parseState 1 5) (FSComp.SR.parsOnlyClassCanTakeValueArguments()); tcDefRepr
       let declRange = unionRanges (rhs parseState 1) tcDefRepr.Range
       let mWhole = (declRange, members)
                    ||> unionRangeWithListBy (fun (mem:SynMemberDefn) -> mem.Range)
                    |> unionRangeWithXmlDoc xmlDoc
       let trivia = { TypeKeyword = None; EqualsRange = Some mEquals; WithKeyword = mWith }
       SynTypeDefn($1, tcDefRepr, members, Some memberCtorPattern, mWhole, trivia) }


/* The right-hand-side of a type definition */
tyconDefnRhsBlock: 
  /* This rule allows members to be given for record and union types in the #light syntax */
  /* without the use of 'with' ... 'end'. For example: */
  /*     type R = */
  /*         { a : int } */
  /*         member r.A = a */
  /* It also takes into account that any existing 'with' */
  /* block still needs to be considered and may occur indented or undented from the core type */
  /* representation. */
  | OBLOCKBEGIN  tyconDefnRhs opt_OBLOCKSEP classDefnMembers opt_classDefn oblockend opt_classDefn  
     { let mWith, optClassDefn = $5
       let mWith2, optClassDefn2 = $7
       let m = unionRanges (rhs parseState 1) (match optClassDefn2 with [] -> (match optClassDefn with [] -> (rhs parseState 4) | _ -> (rhs parseState 5)) | _ -> (rhs parseState 7))
       (fun nameRange ->
           let tcDefRepr, members = $2 nameRange (checkForMultipleAugmentations m ($4 @ optClassDefn) optClassDefn2)
           let mWith = Option.orElse mWith2 mWith
           tcDefRepr, mWith, members) }

  | OBLOCKBEGIN  tyconDefnRhs opt_OBLOCKSEP classDefnMembers opt_classDefn recover
     { if not $6 then reportParseErrorAt (rhs parseState 6) (FSComp.SR.parsUnexpectedEndOfFileTypeDefinition())
       let mWith, optClassDefn = $5
       let m = unionRanges (rhs parseState 1) (match optClassDefn with [] -> (rhs parseState 4) | _ -> (rhs parseState 5))
       (fun nameRange ->
           let tcDefRepr, members = $2 nameRange (checkForMultipleAugmentations m ($4 @ optClassDefn) [])
           tcDefRepr, mWith, members) }

  | tyconDefnRhs opt_classDefn
     { let m = rhs parseState 1
       let mWith, optClassDefn = $2
       (fun nameRange ->
           let tcDefRepr, members = $1 nameRange optClassDefn
           tcDefRepr, mWith, members) }


/* The right-hand-side of a type definition */
tyconDefnRhs: 

  /* A simple type definition */
  | tyconDefnOrSpfnSimpleRepr 
     { let m = $1.Range
       (fun nameRange augmentation -> SynTypeDefnRepr.Simple ($1, m), augmentation) }

  /* An object type definition */
  | tyconClassDefn 
     { let needsCheck, (kind, decls), mopt = $1 
       let m = match mopt with 
               | None -> (lhs parseState).StartRange // create a zero-width range
               | Some m -> m
       (fun nameRange augmentation -> 
           if needsCheck && isNil decls then 
               reportParseErrorAt nameRange (FSComp.SR.parsEmptyTypeDefinition())
           SynTypeDefnRepr.ObjectModel (kind, decls, m), augmentation) }

  /* A delegate type definition */
  | DELEGATE OF topType
     { let m = lhs parseState 
       let ty, arity = $3
       (fun nameRange augmentation -> 
           let valSpfn = SynValSig([], (SynIdent(mkSynId m "Invoke", None)), inferredTyparDecls, ty, arity, false, false, PreXmlDoc.Empty, None, None, m, SynValSigTrivia.Zero) 
           let invoke = SynMemberDefn.AbstractSlot(valSpfn, AbstractMemberFlags SynMemberFlagsTrivia.Zero SynMemberKind.Member, m) 
           if not (isNil augmentation) then raiseParseErrorAt m (FSComp.SR.parsAugmentationsIllegalOnDelegateType())
           SynTypeDefnRepr.ObjectModel (SynTypeDefnKind.Delegate (ty, arity), [invoke], m), []) }


/* The right-hand-side of a object type definition */
tyconClassDefn: 
  | classDefnBlockKindUnspecified
     { let needsCheck, decls, mopt = $1 
       needsCheck, (SynTypeDefnKind.Unspecified, decls), mopt }

  | classOrInterfaceOrStruct classDefnBlock END 
     { false, ($1, $2), Some (rhs2 parseState 1 3) }

  | classOrInterfaceOrStruct classDefnBlock recover 
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedClassInterfaceOrStruct())
       let m = (rhs parseState 1, $2) ||> unionRangeWithListBy (fun (d:SynMemberDefn) -> d.Range)
       false, ($1, $2), Some(m) }

  | classOrInterfaceOrStruct error END
     { // silent recovery 
       false, ($1, []), Some (rhs2 parseState 1 3) }


/* The right-hand-side of a object type definition where the class/interface/struct kind has not been specified */
classDefnBlockKindUnspecified:
  | OBLOCKBEGIN  classDefnMembers recover
     { if not $3 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFileTypeDefinition())
       let mopt =
           match $2 with
           | _ :: _ -> Some( (rhs parseState 1, $2) ||> unionRangeWithListBy (fun (d:SynMemberDefn) -> d.Range) )
           | _ -> None
       false, $2, mopt }

  | OBLOCKBEGIN  classDefnMembers oblockend 
     { let mopt =
           match $2 with
           | _ :: _ -> Some( (rhs parseState 1, $2) ||> unionRangeWithListBy (fun (d:SynMemberDefn) -> d.Range) )
           | _ -> None
       true, $2, mopt }


/* The contents of an object type definition or type augmentation */
classDefnBlock:
  | OBLOCKBEGIN  classDefnMembers recover 
      { if not $3 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFileTypeDefinition())
        $2 }

  | OBLOCKBEGIN  classDefnMembers oblockend 
      { $2 }

  | classDefnMembers 
      { $1 }


/* The members of an object type definition or type augmentation, possibly empty */
classDefnMembers:  
  | classDefnMembersAtLeastOne
     { $1 }

  /* REVIEW: Error recovery rules that are followed by potentially empty productions are suspicious! */
  | error classDefnMembers 
     { $2 }

  | /* EMPTY */
     { [] }
  

/* The members of an object type definition or type augmentation */
classDefnMembersAtLeastOne:
  | classDefnMember opt_seps classDefnMembers
     { match $1, $3 with
       | [ SynMemberDefn.Interface (members=Some []; range=m) ], nextMember :: _ ->
           warning(IndentationProblem(FSComp.SR.lexfltTokenIsOffsideOfContextStartedEarlier(warningStringOfPos m.Start), nextMember.Range))
       | _ -> ()
       $1 @ $3 }


/* The "with get, set" part of a member definition */
classDefnMemberGetSet: 
  | WITH classDefnMemberGetSetElements
     { let mWithKwd = rhs parseState 1
       mWithKwd, $2  }

  | OWITH classDefnMemberGetSetElements OEND
     { let mWithKwd = rhs parseState 1
       mWithKwd, $2  }

  | OWITH classDefnMemberGetSetElements error
     { let mWithKwd = rhs parseState 1
       reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedWith())
       mWithKwd, $2  }

/* The "get, set" part of a member definition */
classDefnMemberGetSetElements: 
  | classDefnMemberGetSetElement 
     { [$1], None  }
  | classDefnMemberGetSetElement AND classDefnMemberGetSetElement
     { let mAnd = rhs parseState 2
       [$1;$3], Some mAnd }

classDefnMemberGetSetElement: 
  | opt_inline opt_attributes bindingPattern opt_topReturnTypeWithTypeConstraints EQUALS typedSequentialExprBlock 
     { let mEquals = rhs parseState 5
       let mRhs = ($6 : SynExpr).Range 
       ($1, $2, $3, $4, Some mEquals, $6, mRhs) }


/* The core of a member definition */
memberCore:  
  /* Methods and simple getter properties */
  | opt_inline bindingPattern opt_topReturnTypeWithTypeConstraints EQUALS typedSequentialExprBlock  
     { let mRhs = $5.Range 
       let optReturnType = $3
       let mEquals = rhs parseState 4
       let bindingPat, mBindLhs = $2 
       (fun vis memFlagsBuilder attrs rangeStart ->
            let xmlDoc = grabXmlDocAtRangeStart(parseState, attrs, rangeStart)
            let memberFlags = Some (memFlagsBuilder SynMemberKind.Member)
            let mWholeBindLhs = (mBindLhs, attrs) ||> unionRangeWithListBy (fun (a: SynAttributeList) -> a.Range)
            let trivia: SynBindingTrivia = { LetKeyword = None; EqualsRange = Some mEquals }
            let binding = mkSynBinding (xmlDoc, bindingPat) (vis, $1, false, mWholeBindLhs, DebugPointAtBinding.NoneAtInvisible, optReturnType, $5, mRhs, [], attrs, memberFlags, trivia)
            let memberRange = unionRanges rangeStart mRhs |> unionRangeWithXmlDoc xmlDoc
            [ SynMemberDefn.Member (binding, memberRange) ]) }

  /* Properties with explicit get/set, also indexer properties */
  | opt_inline bindingPattern opt_topReturnTypeWithTypeConstraints classDefnMemberGetSet  
     { let mWith, (classDefnMemberGetSetElements, mAnd) = $4
       let mWhole = (rhs parseState 2, classDefnMemberGetSetElements) ||> unionRangeWithListBy (fun (_, _, _, _, _, _, m2) -> m2) 
       let propertyNameBindingPat, _ = $2 
       let optPropertyType = $3 
       let isMutable = false
       (fun visNoLongerUsed memFlagsBuilder attrs rangeStart -> 
             let mutable hasGet = false
             let mutable hasSet = false
             let xmlDoc = grabXmlDocAtRangeStart(parseState, attrs, rangeStart)
             
             let tryMkSynMemberDefnMember 
                 (withPropertyKeyword: PropertyKeyword option)
                 (optInline, (optAttrs: SynAttributeList list), (bindingPat, mBindLhs), optReturnType, mEquals, expr, mExpr)
                 =
                 let optInline = $1 || optInline 
                 // optional attributes are only applied to getters and setters
                 // the "top level" attrs will be applied to both
                 let optAttrs =
                     optAttrs |> List.map (fun attrList ->
                         { attrList with Attributes = attrList.Attributes |> List.map (fun a -> { a with AppliesToGetterAndSetter = true } ) })
  
                 let attrs = attrs @ optAttrs
  
                 let trivia: SynBindingTrivia = { LetKeyword = None; EqualsRange = mEquals }
                 let binding = mkSynBinding (xmlDoc, bindingPat) (visNoLongerUsed, optInline, isMutable, mBindLhs, DebugPointAtBinding.NoneAtInvisible, optReturnType, expr, mExpr, [], attrs, Some (memFlagsBuilder SynMemberKind.Member), trivia)
                 let (SynBinding (vis, _, isInline, _, attrs, doc, valSynData, pv, _, _, mBindLhs, spBind, _)) = binding 
                 let memberKind = 
                       let getset = 
                             let rec go p = 
                                 match p with 
                                 | SynPat.LongIdent (longDotId=SynLongIdent([id], _, _)) -> id.idText
                                 | SynPat.Named (SynIdent(nm, _), _, _, _) | SynPat.As (_, SynPat.Named (SynIdent(nm, _), _, _, _), _) -> nm.idText
                                 | SynPat.Typed (p, _, _) -> go p
                                 | SynPat.Attrib (p, _, _) -> go p
                                 | _ -> raiseParseErrorAt mBindLhs (FSComp.SR.parsInvalidDeclarationSyntax()) 
                             go pv 
                       if getset = "get" then
                           if hasGet then 
                               reportParseErrorAt mBindLhs (FSComp.SR.parsGetAndOrSetRequired())
                               None
                           else
                               hasGet <- true
                               Some SynMemberKind.PropertyGet
                       else if getset = "set" then
                           if hasSet then 
                               reportParseErrorAt mBindLhs (FSComp.SR.parsGetAndOrSetRequired())
                               None
                           else
                               hasSet <- true
                               Some SynMemberKind.PropertySet
                       else
                           raiseParseErrorAt mBindLhs (FSComp.SR.parsGetAndOrSetRequired())
  
                 match memberKind with
                 | None -> None
                 | Some memberKind ->
  
                 // REVIEW: It's hard not to ignore the optPropertyType type annotation for 'set' properties. To apply it,
                 // we should apply it to the last argument, but at this point we've already pushed the patterns that 
                 // make up the arguments onto the RHS. So we just always give a warning. 
  
                 begin match optPropertyType with 
                 | Some _ -> errorR(Error(FSComp.SR.parsTypeAnnotationsOnGetSet(), mBindLhs))
                 | None -> ()
                 end
                 
                 let optReturnType = 
                     match (memberKind, optReturnType) with 
                     | SynMemberKind.PropertySet, _ -> optReturnType
                     | _, None -> optPropertyType
                     | _ -> optReturnType 
  
                 // REDO with the correct member kind 
                 let trivia: SynBindingTrivia = { LetKeyword = None; EqualsRange = mEquals }
                 let binding = mkSynBinding (PreXmlDoc.Empty, bindingPat) (vis, isInline, isMutable, mBindLhs, DebugPointAtBinding.NoneAtInvisible, optReturnType, expr, mExpr, [], attrs, Some(memFlagsBuilder memberKind), trivia)
  
                 let (SynBinding (vis, _, isInline, _, attrs, doc, valSynData, pv, rhsRetInfo, rhsExpr, mBindLhs, spBind, trivia)) = binding
                 let mWholeBindLhs = (mBindLhs, attrs) ||> unionRangeWithListBy (fun (a: SynAttributeList) -> a.Range)
              
                 let (SynValData(_, valSynInfo, _)) = valSynData 
  
                 // Setters have all arguments tupled in their internal TAST form, though they don't appear to be 
                 // tupled from the syntax
                 let memFlags : SynMemberFlags = memFlagsBuilder memberKind
  
                 let valSynInfo = 
                     let adjustValueArg valueArg = 
                         match valueArg with
                         | [_] -> valueArg
                         | _ -> SynInfo.unnamedTopArg
  
                     match memberKind, valSynInfo, memFlags.IsInstance with 
                     | SynMemberKind.PropertyGet, SynValInfo ([], _ret), false
                     | SynMemberKind.PropertyGet, SynValInfo ([_], _ret), true  -> 
                         raiseParseErrorAt mWholeBindLhs (FSComp.SR.parsGetterMustHaveAtLeastOneArgument()) 
  
                     | SynMemberKind.PropertyGet, SynValInfo (thisArg :: indexOrUnitArgs :: rest, ret), true  -> 
                         if not rest.IsEmpty then
                             reportParseErrorAt mWholeBindLhs (FSComp.SR.parsGetterAtMostOneArgument ())
                         SynValInfo ([thisArg; indexOrUnitArgs], ret)
  
                     | SynMemberKind.PropertyGet, SynValInfo (indexOrUnitArgs :: rest, ret), false ->
                         if not rest.IsEmpty then
                             reportParseErrorAt mWholeBindLhs (FSComp.SR.parsGetterAtMostOneArgument ())
                         SynValInfo ([indexOrUnitArgs], ret)
  
                     | SynMemberKind.PropertySet, SynValInfo ([thisArg;valueArg], ret), true  -> 
                         SynValInfo ([thisArg; adjustValueArg valueArg], ret)
  
                     | SynMemberKind.PropertySet, SynValInfo (thisArg :: indexArgs :: valueArg :: rest, ret), true  -> 
                         if not rest.IsEmpty then
                             reportParseErrorAt mWholeBindLhs (FSComp.SR.parsSetterAtMostTwoArguments ())
                         SynValInfo ([thisArg; indexArgs @ adjustValueArg valueArg], ret)
  
                     | SynMemberKind.PropertySet, SynValInfo ([valueArg], ret), false -> 
                         SynValInfo ([adjustValueArg valueArg], ret)
  
                     | SynMemberKind.PropertySet, SynValInfo (indexArgs :: valueArg :: rest, ret), _ -> 
                         if not rest.IsEmpty then
                             reportParseErrorAt mWholeBindLhs (FSComp.SR.parsSetterAtMostTwoArguments ())
                         SynValInfo ([indexArgs @ adjustValueArg valueArg], ret)
  
                     | _ -> 
                         // should be unreachable, cover just in case
                         raiseParseErrorAt mWholeBindLhs (FSComp.SR.parsInvalidProperty ())
  
                 let valSynData = SynValData(Some(memFlags), valSynInfo, None) 
  
                 // Fold together the information from the first lambda pattern and the get/set binding
                 // This uses the 'this' variable from the first and the patterns for the get/set binding,
                 // replacing the get/set identifier. A little gross. 
  
                 let bindingPatAdjusted, xmlDocAdjusted = 
  
                     let trivia: SynBindingTrivia = { LetKeyword = None; EqualsRange = mEquals }
                     let bindingOuter = mkSynBinding (xmlDoc, propertyNameBindingPat) (vis, optInline, isMutable, mWholeBindLhs, spBind, optReturnType, expr, mExpr, [], attrs, Some(memFlagsBuilder SynMemberKind.Member), trivia)
  
                     let (SynBinding (_, _, _, _, _, doc2, _, bindingPatOuter, _, _, _, _, _)) = bindingOuter 
                 
                     let lidOuter, lidVisOuter = 
                         match bindingPatOuter with 
                         | SynPat.LongIdent (lid, _, None, None, SynArgPats.Pats [], lidVisOuter, m) ->  lid, lidVisOuter
                         | SynPat.Named (SynIdent(id, _), _, visOuter, m) | SynPat.As(_, SynPat.Named (SynIdent(id, _), _, visOuter, m), _) -> SynLongIdent([id], [], [None]), visOuter
                         | p -> raiseParseErrorAt mWholeBindLhs (FSComp.SR.parsInvalidDeclarationSyntax()) 
  
                     // Merge the visibility from the outer point with the inner point, e.g.
                     //    member <VIS1>  this.Size with <VIS2> get ()      = m_size
                     
                     let mergeLidVisOuter lidVisInner =
                         match lidVisInner, lidVisOuter with 
                         | None, None -> None
                         | Some lidVisInner, None | None, Some lidVisInner -> Some lidVisInner
                         | Some _, Some _ ->  
                             errorR(Error(FSComp.SR.parsMultipleAccessibilitiesForGetSet(), mWholeBindLhs))
                             lidVisInner
                 
                     // Replace the "get" or the "set" with the right name
                     let rec go p = 
                         match p with 
                         | SynPat.LongIdent (longDotId=SynLongIdent([id], _, _); typarDecls=tyargs; argPats=SynArgPats.Pats args; accessibility=lidVisInner; range=m) ->  
                             // Setters have all arguments tupled in their internal form, though they don't 
                             // appear to be tupled from the syntax. Somewhat unfortunate
                             let args = 
                                 if id.idText = "set" then 
                                     match args with 
                                     | [SynPat.Paren(SynPat.Tuple (false, indexPats, _), indexPatRange);valuePat] when id.idText = "set" -> 
                                         [SynPat.Tuple(false, indexPats@[valuePat], unionRanges indexPatRange valuePat.Range)] 
                                     | [indexPat;valuePat] -> 
                                         [SynPat.Tuple(false, args, unionRanges indexPat.Range valuePat.Range)] 
                                     | [valuePat] -> 
                                         [valuePat] 
                                     | _ -> 
                                         raiseParseErrorAt m (FSComp.SR.parsSetSyntax())
                                 else 
                                     args
                             SynPat.LongIdent (lidOuter, withPropertyKeyword, Some(id), tyargs, SynArgPats.Pats args, mergeLidVisOuter lidVisInner, m)
                         | SynPat.Named (_, _, lidVisInner, m)
                         | SynPat.As (_, SynPat.Named (_, _, lidVisInner, m), _) -> SynPat.LongIdent (lidOuter, None, None, None, SynArgPats.Pats [], mergeLidVisOuter lidVisInner, m)
                         | SynPat.Typed (p, ty, m) ->  SynPat.Typed(go p, ty, m)
                         | SynPat.Attrib (p, attribs, m) ->  SynPat.Attrib(go p, attribs, m)
                         | SynPat.Wild(m) ->  SynPat.Wild(m)
                         | _ -> raiseParseErrorAt mWholeBindLhs (FSComp.SR.parsInvalidDeclarationSyntax()) 
  
                     go pv, PreXmlDoc.Merge doc2 doc
  
                 let binding = SynBinding (vis, SynBindingKind.Normal, isInline, isMutable, attrs, xmlDocAdjusted, valSynData, bindingPatAdjusted, rhsRetInfo, rhsExpr, mWholeBindLhs, spBind, trivia)
                 let memberRange = unionRanges rangeStart mWhole |> unionRangeWithXmlDoc xmlDocAdjusted
                 Some (SynMemberDefn.Member (binding, memberRange))

             // Iterate over 1 or 2 'get'/'set' entries
             match classDefnMemberGetSetElements with
             | [ h ] -> List.choose id [ tryMkSynMemberDefnMember (Some (PropertyKeyword.With mWith)) h ]
             | [ g ; s ] -> List.choose id [ tryMkSynMemberDefnMember (Some (PropertyKeyword.With mWith)) g ; tryMkSynMemberDefnMember (Option.map PropertyKeyword.And mAnd) s ]
             | _ -> [])
       }


abstractMemberFlags: 
  | ABSTRACT
      { let mAbstract = rhs parseState 1
        AbstractSynMemberFlagsTrivia mAbstract } 
  | ABSTRACT MEMBER 
      { let mAbstract = rhs parseState 1
        let mMember = rhs parseState 2
        AbstractMemberSynMemberFlagsTrivia mAbstract mMember } 


/* A member definition */
classDefnMember:
  | opt_attributes opt_declVisibility classDefnBindings
     { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
       [mkClassMemberLocalBindings(false, None, $1, $2, $3)] }
       
  | opt_attributes opt_declVisibility STATIC classDefnBindings  
     { if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
       [mkClassMemberLocalBindings(true, Some (rhs parseState 3), $1, $2, $4)] }
              
  | opt_attributes opt_declVisibility memberFlags memberCore opt_ODECLEND
     { let rangeStart = rhs parseState 1
       if Option.isSome $2 then
           errorR (Error (FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier (), rhs parseState 2))
       let _, flags = $3
       $4 $2 flags $1 rangeStart }
       
  | opt_attributes opt_declVisibility interfaceMember appType opt_interfaceImplDefn  
     {  if not (isNil $1) then errorR(Error(FSComp.SR.parsAttributesAreNotPermittedOnInterfaceImplementations(), rhs parseState 1))
        if Option.isSome $2 then errorR(Error(FSComp.SR.parsInterfacesHaveSameVisibilityAsEnclosingType(), rhs parseState 3))
        let mWithKwd, members, mWhole =
            match $5 with
            | None -> None, None, rhs2 parseState 1 4
            | Some (mWithKwd, members, m) -> Some mWithKwd, Some members, unionRanges (rhs2 parseState 1 4) m
        [ SynMemberDefn.Interface ($4, mWithKwd, members, mWhole) ] }
        
  | opt_attributes opt_declVisibility abstractMemberFlags opt_inline nameop opt_explicitValTyparDecls COLON topTypeWithTypeConstraints classMemberSpfnGetSet  opt_ODECLEND
     { let ty, arity = $8
       let isInline, doc, id, explicitValTyparDecls = $4, grabXmlDoc(parseState, $1, 1), $5, $6
       let mWith, getSetRangeOpt, getSet = $9
       let getSetAdjuster arity = match arity, getSet with SynValInfo([], _), SynMemberKind.Member -> SynMemberKind.PropertyGet | _ -> getSet
       let wholeRange = 
           let m = rhs parseState 1
           match getSetRangeOpt with 
           | None -> unionRanges m ty.Range
           | Some m2 -> unionRanges m m2
           |> unionRangeWithXmlDoc doc
       if Option.isSome $2 then errorR(Error(FSComp.SR.parsAccessibilityModsIllegalForAbstract(), wholeRange))
       let valSpfn = SynValSig($1, id, explicitValTyparDecls, ty, arity, isInline, false, doc, None, None, wholeRange, { ValKeyword = None; WithKeyword = mWith; EqualsRange = None })
       [ SynMemberDefn.AbstractSlot(valSpfn, AbstractMemberFlags $3 (getSetAdjuster arity), wholeRange) ] }
       
  | opt_attributes opt_declVisibility inheritsDefn
     {  if not (isNil $1) then errorR(Error(FSComp.SR.parsAttributesIllegalOnInherit(), rhs parseState 1))
        if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityIllegalOnInherit(), rhs parseState 1))
        [ $3 ] }

  | opt_attributes opt_declVisibility valDefnDecl opt_ODECLEND
     {  if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        let rangeStart = rhs parseState 1
        $3 rangeStart $1 false }
        
  | opt_attributes opt_declVisibility STATIC valDefnDecl opt_ODECLEND
     {  if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        let rangeStart = rhs parseState 1
        $4 rangeStart $1 true  }

  | opt_attributes opt_declVisibility memberFlags autoPropsDefnDecl opt_ODECLEND
     { let rangeStart = rhs parseState 1 
       if Option.isSome $2 then
           errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
       let isStatic, flags = $3
       $4 $1 isStatic flags rangeStart }

  | opt_attributes opt_declVisibility NEW  atomicPattern optAsSpec EQUALS typedSequentialExprBlock opt_ODECLEND
     {  let mWholeBindLhs = rhs2 parseState 1 (if Option.isSome $5 then 5 else 4)
        let xmlDoc = grabXmlDoc(parseState, $1, 1)
        let m = unionRanges mWholeBindLhs $7.Range |> unionRangeWithXmlDoc xmlDoc
        let mEquals = rhs parseState 6
        let expr = $7
        let valSynData = SynValData (Some (CtorMemberFlags SynMemberFlagsTrivia.Zero), SynValInfo([SynInfo.InferSynArgInfoFromPat $4], SynInfo.unnamedRetVal), $5) 
        let vis = $2 
        let declPat = SynPat.LongIdent (SynLongIdent([mkSynId (rhs parseState 3) "new"], [], [None]), None, None, Some noInferredTypars, SynArgPats.Pats [$4], vis, rhs parseState 3)
        // Check that 'SynPatForConstructorDecl' matches this correctly
        assert (match declPat with SynPatForConstructorDecl _ -> true | _ -> false)
        let synBindingTrivia: SynBindingTrivia = { LetKeyword = None; EqualsRange = Some mEquals }
        [ SynMemberDefn.Member(SynBinding (None, SynBindingKind.Normal, false, false, $1, xmlDoc, valSynData, declPat, None, expr, mWholeBindLhs, DebugPointAtBinding.NoneAtInvisible, synBindingTrivia), m) ] }
        
  | opt_attributes opt_declVisibility STATIC typeKeyword tyconDefn 
     {  if Option.isSome $2 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(), rhs parseState 2))
        [ SynMemberDefn.NestedType($5, None, rhs2 parseState 1 5) ] }


/* A 'val' definition in an object type definition */
valDefnDecl:
  | VAL opt_mutable opt_access ident COLON  typ 
     {  let mRhs = rhs2 parseState 4 6
        let mValDecl = rhs2 parseState 1 6
        (fun rangeStart attribs isStatic ->
            let xmlDoc = grabXmlDocAtRangeStart(parseState, attribs, rangeStart)
            let mValDecl = unionRanges rangeStart mValDecl |> unionRangeWithXmlDoc xmlDoc
            let fld = SynField(attribs, isStatic, Some $4, $6, $2, xmlDoc, $3, mRhs)
            [ SynMemberDefn.ValField(fld, mValDecl) ]) }


/* An auto-property definition in an object type definition */
autoPropsDefnDecl:
  | VAL opt_mutable opt_access ident opt_typ EQUALS typedSequentialExprBlock classMemberSpfnGetSet
     { let mWith, mGetSetOpt, getSet = $8
       let mEquals = rhs parseState 6
       if $2 then
           errorR (Error (FSComp.SR.parsMutableOnAutoPropertyShouldBeGetSet (), rhs parseState 3))
       (fun attribs isStatic flags rangeStart ->
           let xmlDoc = grabXmlDocAtRangeStart(parseState, attribs, rangeStart)
           let memberRange = unionRanges rangeStart $7.Range |> unionRangeWithXmlDoc xmlDoc
           [ SynMemberDefn.AutoProperty(attribs, isStatic, $4, $5, getSet, flags, xmlDoc, $3, mEquals, $7, mWith, mGetSetOpt, memberRange) ]) }


/* An optional type on an auto-property definition */
opt_typ:
   | /* EMPTY */ { None } 
   | COLON typ { Some $2 }


atomicPatternLongIdent:
  | UNDERSCORE DOT pathOp
     { if not (parseState.LexBuffer.SupportsFeature LanguageFeature.SingleUnderscorePattern) then
          raiseParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedSymbolDot())

       let underscore = ident("_", rhs parseState 1)
       let dotm = rhs parseState 2
       None, prependIdentInLongIdentWithTrivia (SynIdent(underscore, None)) dotm $3 }

  | GLOBAL DOT pathOp
     { let globalIdent = ident(MangledGlobalName, rhs parseState 1)
       let dotm = rhs parseState 2
       None, prependIdentInLongIdentWithTrivia (SynIdent(globalIdent, None)) dotm $3 }

  | pathOp
     { (None, $1) }

  | access UNDERSCORE DOT pathOp
     { if not (parseState.LexBuffer.SupportsFeature LanguageFeature.SingleUnderscorePattern) then
          raiseParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedSymbolDot())

       let underscore = ident("_", rhs parseState 2)
       let dotm = rhs parseState 3
       Some($1), prependIdentInLongIdentWithTrivia (SynIdent(underscore, None)) dotm $4 } 

  | access pathOp
     { (Some($1), $2) }


opt_access:
  | /* EMPTY */
     { None }

  | access
     { Some($1) } 


access:
  | PRIVATE
     { let m = rhs parseState 1
       SynAccess.Private m }

  | PUBLIC
     { let m = rhs parseState 1
       SynAccess.Public m }

  | INTERNAL
     { let m = rhs parseState 1
       SynAccess.Internal m }

/* only valid on 'NEW' */
opt_declVisibility:
  | access
     { Some($1) } 

  | /* EMPTY */
     { None }
  

opt_interfaceImplDefn:
  | WITH objectImplementationBlock declEnd
     { let mWithKwd = rhs parseState 1
       let members = $2
       let m = (rhs parseState 1, members) ||> unionRangeWithListBy (fun (mem:SynMemberDefn) -> mem.Range)
       Some (mWithKwd, members, m) }

  | WITH
     { let mWithKwd = rhs parseState 1
       Some (mWithKwd, [], mWithKwd) }

  | /* EMPTY */
     { None }


opt_classDefn: 
  | WITH classDefnBlock declEnd
     { let mWithKwd = rhs parseState 1
       (Some mWithKwd), $2 }

  | /* EMPTY */
     { None, [] }


/* An 'inherits' definition in an object type definition */
inheritsDefn: 
  | INHERIT atomTypeNonAtomicDeprecated optBaseSpec
     { let mDecl = unionRanges (rhs parseState 1) (($2): SynType).Range 
       SynMemberDefn.Inherit($2, $3, mDecl) }

  | INHERIT atomTypeNonAtomicDeprecated opt_HIGH_PRECEDENCE_APP atomicExprAfterType optBaseSpec
     { let mDecl = unionRanges (rhs parseState 1) $4.Range 
       SynMemberDefn.ImplicitInherit($2, $4, $5, mDecl) }

  | INHERIT ends_coming_soon_or_recover
     { let mDecl = (rhs parseState 1)
       if not $2 then errorR(Error(FSComp.SR.parsTypeNameCannotBeEmpty(), mDecl))
       SynMemberDefn.Inherit(SynType.LongIdent(SynLongIdent([], [], [])), None, mDecl) }

optAsSpec: 
  | asSpec
      { Some($1) } 

  | /* EMPTY */
      { None }

asSpec: 
  | AS ident
     { $2 } 

optBaseSpec: 
  | baseSpec
     { Some($1) } 

  | /* EMPTY */
     { None }

baseSpec: 
  | AS ident 
      { if ($2).idText <> "base" then 
             errorR(Error(FSComp.SR.parsInheritDeclarationsCannotHaveAsBindings(), rhs2 parseState 1 2)) 
        ident("base", rhs parseState 2) } 
        
  | AS BASE 
      { errorR(Error(FSComp.SR.parsInheritDeclarationsCannotHaveAsBindings(), rhs2 parseState 1 2)) 
        ident("base", rhs parseState 2) } 


/* The members in an object expression or interface implementation */
objectImplementationBlock:
  | OBLOCKBEGIN objectImplementationMembers oblockend  
      { $2 }

  | OBLOCKBEGIN objectImplementationMembers recover 
      { if not $3 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFileObjectMembers())
        $2 }

  | objectImplementationMembers 
      { $1 }


/* The members in an object expression or interface implementation */
objectImplementationMembers:  
  | objectImplementationMember opt_seps objectImplementationMembers 
      { $1 @  $3 }

  | objectImplementationMember opt_seps 
      { $1 }


/* One member in an object expression or interface implementation */
objectImplementationMember: 
  | opt_attributes memberOrOverride memberCore opt_ODECLEND
     { let rangeStart = rhs parseState 1
       $3 None (OverrideMemberFlags $2) $1 rangeStart }

  | opt_attributes memberOrOverride autoPropsDefnDecl opt_ODECLEND
     { let rangeStart = rhs parseState 1
       $3 $1 false (OverrideMemberFlags $2) rangeStart }

  | opt_attributes memberOrOverride error 
      { [] } 

  | opt_attributes error memberCore opt_ODECLEND 
      { [] }


memberOrOverride: 
  | MEMBER 
      { let mMember = rhs parseState 1
        MemberSynMemberFlagsTrivia mMember } 
  | OVERRIDE 
      { let mOverride = rhs parseState 1
        OverrideSynMemberFlagsTrivia mOverride }


/* The core of the right-hand-side of a simple type definition */
tyconDefnOrSpfnSimpleRepr: 

  /* type MyAlias = SomeTypeProvider<@"foo">    is a common error, special-case it */
  | opt_attributes opt_declVisibility path LQUOTE STRING recover     
     { errorR(Error(FSComp.SR.parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString(), rhs parseState 4)) 
       SynTypeDefnSimpleRepr.TypeAbbrev (ParserDetail.ErrorRecovery, SynType.LongIdent($3), unionRanges (rhs parseState 1) $3.Range)  }

  /* A type abbreviation */
  | opt_attributes opt_declVisibility typ
     { if not (isNil $1) then errorR(Error(FSComp.SR.parsAttributesIllegalHere(), rhs parseState 1))
       if Option.isSome $2 then errorR(Error(FSComp.SR.parsTypeAbbreviationsCannotHaveVisibilityDeclarations(), rhs parseState 2))
       SynTypeDefnSimpleRepr.TypeAbbrev (ParserDetail.Ok, $3, unionRanges (rhs parseState 1) $3.Range) }

  /* A union type definition */
  | opt_attributes opt_declVisibility unionTypeRepr
     { if not (isNil $1) then errorR(Error(FSComp.SR.parsAttributesIllegalHere(), rhs parseState 1))
       let rangesOf3 = $3 |> List.map (function |Choice1Of2(ec)->ec.Range | Choice2Of2(uc)->uc.Range)
       let mWhole = (rhs2 parseState 1 2, rangesOf3) ||> List.fold unionRanges 
       if $3 |> List.exists (function Choice1Of2 _ -> true | _ -> false) then (
           if Option.isSome $2 then errorR(Error(FSComp.SR.parsEnumTypesCannotHaveVisibilityDeclarations(), rhs parseState 2));
           SynTypeDefnSimpleRepr.Enum ($3 |> List.choose (function 
                                              | Choice1Of2 data ->  
                                                Some(data) 
                                              | Choice2Of2(SynUnionCase(range=m)) -> 
                                                errorR(Error(FSComp.SR.parsAllEnumFieldsRequireValues(), m)); None),
                           mWhole)
       ) else 
           SynTypeDefnSimpleRepr.Union ($2,
                            $3 |> List.choose (function Choice2Of2 data -> Some(data) | Choice1Of2 _ -> failwith "huh?"),
                            mWhole) }

  /* A record type definition */
  | opt_attributes opt_declVisibility braceFieldDeclList
     { if not (isNil $1) then errorR(Error(FSComp.SR.parsAttributesIllegalHere(), rhs parseState 1))
       SynTypeDefnSimpleRepr.Record ($2, $3, lhs parseState) }

  /* An inline-assembly type definition, for FSharp.Core library only */
  | opt_attributes opt_declVisibility LPAREN HASH string HASH rparen
     { if not (isNil $1) then errorR(Error(FSComp.SR.parsAttributesIllegalHere(), rhs parseState 1))
       let lhsm = lhs parseState
       if parseState.LexBuffer.ReportLibraryOnlyFeatures then libraryOnlyError lhsm
       if Option.isSome $2 then errorR(Error(FSComp.SR.parsInlineAssemblyCannotHaveVisibilityDeclarations(), rhs parseState 2))
       let s, _ = $5
       let ilType = ParseAssemblyCodeType s parseState.LexBuffer.ReportLibraryOnlyFeatures parseState.LexBuffer.LanguageVersion (rhs parseState 5)
       SynTypeDefnSimpleRepr.LibraryOnlyILAssembly (box ilType, lhsm)  }


/* The core of a record type definition */
braceFieldDeclList:
  | LBRACE  recdFieldDeclList rbrace
     { $2 }

  | LBRACE  recdFieldDeclList recover
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBrace()) 
       $2 }

  | LBRACE  error rbrace
     { [] }

anonRecdType:
    | STRUCT braceBarFieldDeclListCore
        { $2, true }
    | braceBarFieldDeclListCore
        { $1, false }

/* The core of a record type definition */
braceBarFieldDeclListCore:
  | LBRACE_BAR  recdFieldDeclList bar_rbrace
     { $2 }

  | LBRACE_BAR  recdFieldDeclList recover
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBraceBar()) 
       $2 }

  | LBRACE_BAR error bar_rbrace
     { [] }

classOrInterfaceOrStruct: 
  | CLASS 
     { SynTypeDefnKind.Class } 

  | INTERFACE
     { SynTypeDefnKind.Interface } 

  | STRUCT
     { SynTypeDefnKind.Struct }

interfaceMember: 
  | INTERFACE { } 
  | OINTERFACE_MEMBER    { }

tyconNameAndTyparDecls:  
  | opt_access path 
      { None, $2.LongIdent, false, $1 }

  | opt_access prefixTyparDecls  path
      { Some $2, $3.LongIdent, false, $1 }

  | opt_access path postfixTyparDecls 
      { Some $3, $2.LongIdent, true, $1 }

prefixTyparDecls:
  | typar
      { SynTyparDecls.SinglePrefix (SynTyparDecl([], $1), rhs parseState 1) }

  | LPAREN typarDeclList rparen
      { SynTyparDecls.PrefixList (List.rev $2, rhs2 parseState 1 3) }

typarDeclList: 
  | typarDeclList COMMA typarDecl { $3 :: $1 } 
  | typarDecl { [$1] }

typarDecl : 
  | opt_attributes typar 
      { SynTyparDecl($1, $2) }

/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */
/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */
postfixTyparDecls: 
  | opt_HIGH_PRECEDENCE_TYAPP LESS typarDeclList opt_typeConstraints GREATER 
      { let m = rhs2 parseState 2 5
        if not $2 then warning(Error(FSComp.SR.parsNonAdjacentTypars(), m))
        SynTyparDecls.PostfixList (List.rev $3, $4, m) }

/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */
/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */
explicitValTyparDeclsCore: 
  | typarDeclList COMMA DOT_DOT 
      { (List.rev $1, true) }

  | typarDeclList 
      { (List.rev $1, false) }

  | /* EMPTY */
      { ([], false) }

explicitValTyparDecls: 
  | opt_HIGH_PRECEDENCE_TYAPP LESS explicitValTyparDeclsCore opt_typeConstraints GREATER 
      { let m = rhs2 parseState 2 5
        if not $2 then warning(Error(FSComp.SR.parsNonAdjacentTypars(), m))
        let tps, flex = $3 
        let tps = SynTyparDecls.PostfixList (tps, $4, m)
        SynValTyparDecls(Some tps, flex) }

opt_explicitValTyparDecls: 
  | explicitValTyparDecls 
      { $1 } 
  |       
      { SynValTyparDecls(None, true) }

/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */
/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */
opt_typeConstraints:
  | /* EMPTY */
     { [] }

  | WHEN typeConstraints 
     { List.rev $2 }

/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */
/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */
typeConstraints: 
  | typeConstraints AND typeConstraint
     { $3 :: $1 } 

  | typeConstraint
     { [$1] }

/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */
/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */
typeConstraint: 
  | DEFAULT typar COLON typ 
     { if parseState.LexBuffer.ReportLibraryOnlyFeatures then libraryOnlyError (lhs parseState)
       SynTypeConstraint.WhereTyparDefaultsToType($2, $4, lhs parseState) }

  | typar COLON_GREATER typ 
     { SynTypeConstraint.WhereTyparSubtypeOfType($1, $3, lhs parseState) }

  | typar COLON STRUCT 
     { SynTypeConstraint.WhereTyparIsValueType($1, lhs parseState) }

  | typar COLON IDENT STRUCT 
     { if $3 <> "not" then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedIdentifier($3))  
       SynTypeConstraint.WhereTyparIsReferenceType($1, lhs parseState) }

  | typar COLON NULL 
     { SynTypeConstraint.WhereTyparSupportsNull($1, lhs parseState) }

  | typar COLON LPAREN classMemberSpfn rparen 
     { let tp = $1
       SynTypeConstraint.WhereTyparSupportsMember([ SynType.Var(tp, tp.Range) ], $4, lhs parseState) }

  | LPAREN typarAlts rparen COLON LPAREN classMemberSpfn rparen 
     { SynTypeConstraint.WhereTyparSupportsMember(List.rev($2), $6, lhs parseState) }

  | typar COLON DELEGATE typeArgsNoHpaDeprecated
     { let _ltm, _gtm, args, _commas, mWhole = $4
       SynTypeConstraint.WhereTyparIsDelegate($1, args, unionRanges $1.Range mWhole) }

  | typar COLON IDENT typeArgsNoHpaDeprecated
     { match $3 with 
       | "enum" ->
           let _ltm, _gtm, args, _commas, mWhole = $4
           SynTypeConstraint.WhereTyparIsEnum($1, args, unionRanges $1.Range mWhole)
       | nm -> raiseParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedIdentifier(nm)) }

  | typar COLON IDENT 
     { match $3 with 
       | "comparison" -> SynTypeConstraint.WhereTyparIsComparable($1, lhs parseState)
       | "equality" -> SynTypeConstraint.WhereTyparIsEquatable($1, lhs parseState)
       | "unmanaged" -> SynTypeConstraint.WhereTyparIsUnmanaged($1, lhs parseState)
       | nm -> raiseParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedIdentifier(nm)) }

typarAlts:
  | typarAlts OR appType
     { $3 :: $1 }

  | appType
     { [$1] }	

/* The core of a union type definition */
unionTypeRepr:
  /* Note the next three rules are required to disambiguate this from type x = y */
  /* Attributes can only appear on a single constructor if you've used a | */
  | barAndgrabXmlDoc attrUnionCaseDecls  
     { $2 $1 }

  | firstUnionCaseDeclOfMany barAndgrabXmlDoc attrUnionCaseDecls  
     { $1 :: $3 $2 }

  | firstUnionCaseDecl 
     { [$1] } 

barAndgrabXmlDoc: 
  | BAR
     { let mBar = rhs parseState 1
       grabXmlDoc(parseState, [], 1), mBar }

attrUnionCaseDecls: 
  | attrUnionCaseDecl barAndgrabXmlDoc attrUnionCaseDecls
     { (fun xmlDocAndBar -> $1 xmlDocAndBar  :: $3 $2) } 

  | attrUnionCaseDecl
     { (fun xmlDocAndBar -> [ $1 xmlDocAndBar ]) }

/* The core of a union case definition */
attrUnionCaseDecl:
  | opt_attributes opt_access unionCaseName
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsUnionCasesCannotHaveVisibilityDeclarations(), rhs parseState 2))
        let mDecl = rhs parseState 3
        (fun (xmlDoc, mBar) ->
            let trivia: SynUnionCaseTrivia = { BarRange = Some mBar }
            let mDecl = unionRangeWithXmlDoc xmlDoc mDecl
            Choice2Of2 (SynUnionCase ( $1, $3, SynUnionCaseKind.Fields [], xmlDoc, None, mDecl, trivia))) }

  | opt_attributes opt_access unionCaseName OF unionCaseRepr
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsUnionCasesCannotHaveVisibilityDeclarations(), rhs parseState 2))
        let mDecl = rhs2 parseState 1 5
        (fun (xmlDoc, mBar) ->
            let trivia: SynUnionCaseTrivia = { BarRange = Some mBar }
            let mDecl = unionRangeWithXmlDoc xmlDoc mDecl
            Choice2Of2 (SynUnionCase ( $1, $3, SynUnionCaseKind.Fields $5, xmlDoc, None, mDecl, trivia))) }

  | opt_attributes opt_access unionCaseName OF recover
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsUnionCasesCannotHaveVisibilityDeclarations(), rhs parseState 2))
        let mDecl = rhs2 parseState 1 4
        (fun (xmlDoc, mBar) -> 
            let trivia: SynUnionCaseTrivia = { BarRange = Some mBar }
            let mDecl = unionRangeWithXmlDoc xmlDoc mDecl
            Choice2Of2 (SynUnionCase ( $1, $3, SynUnionCaseKind.Fields [], xmlDoc, None, mDecl, trivia))) }

  | opt_attributes opt_access unionCaseName COLON topType
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsUnionCasesCannotHaveVisibilityDeclarations(), rhs parseState 2))
        if parseState.LexBuffer.ReportLibraryOnlyFeatures then libraryOnlyWarning(lhs parseState)
        let mDecl = rhs2 parseState 1 5
        (fun (xmlDoc, mBar) -> 
            let trivia: SynUnionCaseTrivia = { BarRange = Some mBar }
            let mDecl = unionRangeWithXmlDoc xmlDoc mDecl
            Choice2Of2 (SynUnionCase ( $1, $3, SynUnionCaseKind.FullType $5, xmlDoc, None, mDecl, trivia))) }

  | opt_attributes opt_access unionCaseName EQUALS constant
      { if Option.isSome $2 then errorR(Error(FSComp.SR.parsEnumFieldsCannotHaveVisibilityDeclarations(), rhs parseState 2))
        let mEquals = rhs parseState 4
        let mDecl = rhs2 parseState 1 5
        (fun (xmlDoc, mBar) -> 
            let trivia: SynEnumCaseTrivia = { BarRange = Some mBar; EqualsRange = mEquals }
            let mDecl = unionRangeWithXmlDoc xmlDoc mDecl
            Choice1Of2 (SynEnumCase ( $1, $3, fst $5, snd $5, xmlDoc, mDecl, trivia))) } 

/* The name of a union case */
unionCaseName: 
  | nameop  
      { $1 } 

  | LPAREN COLON_COLON rparen  
      { let lpr = rhs parseState 1
        let rpr = rhs parseState 3 
        SynIdent(ident(opNameCons, rhs parseState 2), Some(IdentTrivia.OriginalNotationWithParen(lpr, "::", rpr))) }  

  | LPAREN LBRACK RBRACK  rparen  
      { let lpr = rhs parseState 1
        let rpr = rhs parseState 3
        SynIdent(ident(opNameNil, rhs2 parseState 2 3), Some(IdentTrivia.OriginalNotationWithParen(lpr, "[]", rpr))) }  

firstUnionCaseDeclOfMany: 
  | ident opt_OBLOCKSEP
      { let trivia: SynUnionCaseTrivia = { BarRange = None }
        let xmlDoc = grabXmlDoc(parseState, [], 1)
        let mDecl = (rhs parseState 1) |> unionRangeWithXmlDoc xmlDoc
        Choice2Of2 (SynUnionCase ( [], (SynIdent($1, None)), SynUnionCaseKind.Fields [], xmlDoc, None, mDecl, trivia)) }

  | ident EQUALS constant opt_OBLOCKSEP
      { let mEquals = rhs parseState 2
        let trivia: SynEnumCaseTrivia = { BarRange = None; EqualsRange = mEquals }
        let xmlDoc = grabXmlDoc(parseState, [], 1)
        let mDecl = (rhs2 parseState 1 3) |> unionRangeWithXmlDoc xmlDoc
        Choice1Of2 (SynEnumCase ([], SynIdent($1, None), fst $3, snd $3, xmlDoc, mDecl, trivia)) }

  | firstUnionCaseDecl opt_OBLOCKSEP
      { $1 }

firstUnionCaseDecl: 
  | ident OF unionCaseRepr  
     { let trivia: SynUnionCaseTrivia = { BarRange = None }
       let xmlDoc = grabXmlDoc(parseState, [], 1)
       let mDecl = rhs2 parseState 1 3 |> unionRangeWithXmlDoc xmlDoc
       Choice2Of2 (SynUnionCase ( [], SynIdent($1, None), SynUnionCaseKind.Fields $3, xmlDoc, None, mDecl, trivia)) }

  | ident EQUALS constant opt_OBLOCKSEP
      { let mEquals = rhs parseState 2
        let trivia: SynEnumCaseTrivia = { BarRange = None; EqualsRange = mEquals }
        let xmlDoc = grabXmlDoc(parseState, [], 1)
        let mDecl = rhs2 parseState 1 3 |> unionRangeWithXmlDoc xmlDoc
        Choice1Of2 (SynEnumCase ([], SynIdent($1, None), fst $3, snd $3, xmlDoc, mDecl, trivia))  }

unionCaseReprElements:
  | unionCaseReprElement STAR unionCaseReprElements
     { $1 :: $3 }

  | unionCaseReprElement %prec prec_toptuptyptail_prefix
     { [$1] }

unionCaseReprElement:
  | ident COLON appType
     { let xmlDoc = grabXmlDoc(parseState, [], 1)
       let wholeRange = rhs2 parseState 1 3 |> unionRangeWithXmlDoc xmlDoc
       mkSynNamedField ($1, $3, xmlDoc, wholeRange) }

  | appType
     { let xmlDoc = grabXmlDoc(parseState, [], 1)
       mkSynAnonField ($1, xmlDoc) }

unionCaseRepr:
  | braceFieldDeclList
     { errorR(Deprecated(FSComp.SR.parsConsiderUsingSeparateRecordType(), lhs parseState)) 
       $1 }

  | unionCaseReprElements 
     { $1 }

/* A list of field declarations in a record type */
recdFieldDeclList: 
  | recdFieldDecl seps recdFieldDeclList 
     { $1 :: $3 } 

  | recdFieldDecl opt_seps           
     { [$1] }

/* A field declaration in a record type */
recdFieldDecl: 
  | opt_attributes fieldDecl
     { let wholeRange = rhs2 parseState 1 2
       let fld = $2 $1 false wholeRange
       let (SynField (a, b, c, d, e, xmlDoc, vis, wholeRange)) = fld
       if Option.isSome vis then errorR (Error (FSComp.SR.parsRecordFieldsCannotHaveVisibilityDeclarations (), rhs parseState 2))
       let wholeRange = unionRangeWithXmlDoc xmlDoc wholeRange
       SynField (a, b, c, d, e, xmlDoc, None, wholeRange) }

/* Part of a field or val declaration in a record type or object type */
fieldDecl: 
  | opt_mutable opt_access ident COLON  typ 
     { fun attrs stat wholeRange ->
           let xmlDoc = grabXmlDocAtRangeStart(parseState, attrs, wholeRange)
           SynField(attrs, stat, Some $3, $5, $1, xmlDoc, $2, wholeRange) }

/* An exception definition */
exconDefn: 
  | exconCore opt_classDefn 
     { let mWith, optClassDefn = $2
       SynExceptionDefn($1, mWith, optClassDefn, ($1.Range, optClassDefn) ||> unionRangeWithListBy (fun cd -> cd.Range) ) }
  
/* Part of an exception definition */
exconCore: 
  | EXCEPTION opt_attributes opt_access exconIntro exconRepr
     { SynExceptionDefnRepr($2, $4, $5, PreXmlDoc.Empty, $3, (match $5 with None -> rhs2 parseState 1 4 | Some p -> unionRanges (rangeOfLongIdent p) (rhs2 parseState 1 4))) }
  
/* Part of an exception definition */
exconIntro:
  | ident
      { SynUnionCase([], SynIdent($1, None), SynUnionCaseKind.Fields [], PreXmlDoc.Empty, None, lhs parseState, { BarRange = None }) }

  | ident OF unionCaseRepr
      { SynUnionCase([], SynIdent($1,None), SynUnionCaseKind.Fields $3, PreXmlDoc.Empty, None, lhs parseState, { BarRange = None }) }

  | ident OF recover
      { SynUnionCase([], SynIdent($1, None), SynUnionCaseKind.Fields [], PreXmlDoc.Empty, None, lhs parseState, { BarRange = None }) }

exconRepr: 
  | /* EMPTY */
     { None }

  | EQUALS path
     { Some ($2.LongIdent) }

/*-------------------------------------------------------------------------*/
/* F# Definitions, Types, Patterns and Expressions  */

/* A 'let ...' or 'do ...' statement in the non-#light syntax */
defnBindings: 
  | LET opt_rec localBindings 
      { let mLetKwd = rhs parseState 1 
        let isUse = $1
        let isRec = $2 
        let localBindingsLastRangeOpt, localBindingsBuilder = $3
        
        // Calculate the precise range of the binding set, up to the end of the last r.h.s. expression
        let bindingSetRange = 
            match localBindingsLastRangeOpt with 
            | None -> rhs2 parseState 1 2 (* there was some error - this will be an approximate range *)
            | Some lastRange -> unionRanges mLetKwd lastRange

        // The first binding swallows any attributes prior to the 'let'
        BindingSetPreAttrs(mLetKwd, isRec, isUse,
            (fun attrs vis ->
                let xmlDoc = grabXmlDoc(parseState, attrs, 1)
                // apply the builder
                let binds = localBindingsBuilder xmlDoc attrs vis mLetKwd
                if not isRec && not (isNilOrSingleton binds) then 
                      reportParseErrorAt mLetKwd (FSComp.SR.parsLetAndForNonRecBindings())
                [], binds),
            bindingSetRange) }

  | cPrototype
      { let bindRange = lhs parseState
        BindingSetPreAttrs(bindRange, false, false, $1, bindRange)  }


/* A 'do ...' statement in the non-#light syntax */
doBinding:
  | DO typedSequentialExprBlock 
      { let mDoKwd = rhs parseState 1 
        let mWhole = unionRanges mDoKwd $2.Range
        // any attributes prior to the 'let' are left free, e.g. become top-level attributes 
        // associated with the module, 'main' function or assembly depending on their target 
        BindingSetPreAttrs(mDoKwd, false, false, (fun attrs vis -> attrs, [mkSynDoBinding (vis, $2, mWhole)]), mWhole) }


/* A 'let ....' binding in the #light syntax */
hardwhiteLetBindings: 
  | OLET opt_rec localBindings hardwhiteDefnBindingsTerminator
      { let mLetKwd = rhs parseState 1 
        let isUse = $1
        let isRec = $2
        let report, mIn = $4
        report (if isUse then "use" else "let") mLetKwd  // report unterminated error 
        
        let localBindingsLastRangeOpt, localBindingsBuilder = $3
        
        // Calculate the precise range of the binding set, up to the end of the last r.h.s. expression
        let bindingSetRange = 
            match localBindingsLastRangeOpt with 
            | None -> rhs parseState 1 (* there was some error - this will be an approximate range *)
            | Some lastRange -> unionRanges mLetKwd lastRange

        // the first binding swallow any attributes prior to the 'let' 
        BindingSetPreAttrs(mLetKwd, isRec, isUse,
          (fun attrs vis ->
            let xmlDoc = grabXmlDoc(parseState, attrs, 1)
            let binds = localBindingsBuilder xmlDoc attrs vis mLetKwd
            if not isRec && not (isNilOrSingleton binds) then
                reportParseErrorAt mLetKwd (FSComp.SR.parsLetAndForNonRecBindings())
            [], binds),
          bindingSetRange),
          (unionRanges mLetKwd bindingSetRange),
          mIn }


/* A 'do ...' statement */
hardwhiteDoBinding: 
  | ODO typedSequentialExprBlock hardwhiteDefnBindingsTerminator          
      { let mLetKwd = rhs parseState 1 
        let bindingSetRange = unionRanges mLetKwd $2.Range 
        let seqPt = DebugPointAtBinding.NoneAtDo 
        // any attributes prior to the 'let' are left free, e.g. become top-level attributes 
        // associated with the module, 'main' function or assembly depending on their target 
        BindingSetPreAttrs(mLetKwd, false, false, (fun attrs vis -> attrs, [mkSynDoBinding (vis, $2, bindingSetRange)]), bindingSetRange), $2 }


/* The bindings in a class type definition */
classDefnBindings: 
  | defnBindings
     { $1 }

  | doBinding
     { $1 }

  | hardwhiteLetBindings
     { let b, m, _ = $1 in b } 

  | hardwhiteDoBinding
     { fst $1 }


/* The terminator for a 'let ....' binding in the #light syntax */
hardwhiteDefnBindingsTerminator:
  |  ODECLEND
     { let mToken = rhs parseState 1
       // In LexFilter.fs the IN token could have been transformed to an ODECLEND one.
       let mIn = if (mToken.EndColumn - mToken.StartColumn) = 2 then Some mToken else None
       (fun _ m -> ()), mIn }

  |  recover 
     { (fun kwd m ->
         let msg = 
             match kwd with 
             | "let!" -> FSComp.SR.parsUnmatchedLetBang() 
             | "use!" -> FSComp.SR.parsUnmatchedUseBang() 
             | "use" -> FSComp.SR.parsUnmatchedUse() 
             | _ (*"let" *) -> FSComp.SR.parsUnmatchedLet()
         reportParseErrorAt m msg), None }

/* An 'extern' DllImport function definition in C-style syntax */
cPrototype: 
  | EXTERN cRetType opt_access ident opt_HIGH_PRECEDENCE_APP LPAREN externArgs rparen 
      { let rty, vis, nm, args  = $2, $3, $4, $7
        let nmm = rhs parseState 3 
        let argsm = rhs parseState 6 
        let mBindLhs = lhs parseState
        let mWhole = lhs parseState
        let mRhs = lhs parseState 
        let rhsExpr =
            SynExpr.App (
                ExprAtomicFlag.NonAtomic,
                false,
                SynExpr.Ident (ident("failwith", rhs parseState 6)),
                SynExpr.Const (SynConst.String("extern was not given a DllImport attribute", SynStringKind.Regular, rhs parseState 8), rhs parseState 8),
                mRhs)
        (fun attrs _ ->
            let bindingPat = SynPat.LongIdent (SynLongIdent([nm], [], [None]), None, None, Some noInferredTypars, SynArgPats.Pats [SynPat.Tuple(false, args, argsm)], vis, nmm)
            let mWholeBindLhs = (mBindLhs, attrs) ||> unionRangeWithListBy (fun (a: SynAttributeList) -> a.Range)
            let xmlDoc = grabXmlDoc(parseState, attrs, 1)
            let binding =
                mkSynBinding 
                    (xmlDoc, bindingPat) 
                    (vis, false, false, mWholeBindLhs, DebugPointAtBinding.NoneAtInvisible, Some rty, rhsExpr, mRhs, [], attrs, None, SynBindingTrivia.Zero)
            [], [binding]) }

/* A list of arguments in an 'extern' DllImport function definition */
externArgs: 
  | externMoreArgs 
     { List.rev $1 }

  | externArg 
     { [$1] }
  |       
     { [] }
  

/* Part of the list of arguments in an 'extern' DllImport function definition */
externMoreArgs: 
  | externMoreArgs COMMA externArg 
     { $3 :: $1 }

  | externArg COMMA externArg 
     { [$3; $1] }


/* A single argument in an 'extern' DllImport function definition */
externArg: 
  | opt_attributes cType       
     { let m = lhs parseState in SynPat.Typed(SynPat.Wild m, $2, m) |> addAttribs $1 }

  | opt_attributes cType ident 
     { let m = lhs parseState in SynPat.Typed(SynPat.Named (SynIdent($3, None), false, None, m), $2, m) |> addAttribs $1 }

/* An type in an 'extern' DllImport function definition */
cType: 
  | path      
     { let m = $1.Range
       SynType.App(SynType.LongIdent($1), None, [], [], None, false, m) } 

  | cType opt_HIGH_PRECEDENCE_APP LBRACK RBRACK 
     { let m = lhs parseState 
       SynType.App(SynType.LongIdent(SynLongIdent([ident("[]", m)], [], [None])), None, [$1], [], None, true, m) } 

  | cType STAR 
     { let m = lhs parseState 
       SynType.App(SynType.LongIdent(SynLongIdent([ident("nativeptr", m)], [], [ Some (IdentTrivia.OriginalNotation "*") ])), None, [$1], [], None, true, m) } 

  | cType AMP  
     { let m = lhs parseState 
       SynType.App(SynType.LongIdent(SynLongIdent([ident("byref", m)], [], [ Some (IdentTrivia.OriginalNotation "&") ])), None, [$1], [], None, true, m) } 

  | VOID STAR 
     { let m = lhs parseState 
       SynType.App(SynType.LongIdent(SynLongIdent([ident("nativeint", m)], [], [ Some (IdentTrivia.OriginalNotation "void*") ])), None, [], [], None, true, m) } 


/* A return type in an 'extern' DllImport function definition */
cRetType: 
  | opt_attributes cType 
     { SynReturnInfo(($2, SynArgInfo($1, false, None)), rhs parseState 2) }

  | opt_attributes VOID  
     { let m = rhs parseState 2 
       SynReturnInfo((SynType.App(SynType.LongIdent(SynLongIdent([ident("unit", m)], [], [ Some (IdentTrivia.OriginalNotation "void") ])), None, [], [], None, false, m), SynArgInfo($1, false, None)), m) } 


localBindings: 
  | attr_localBinding moreLocalBindings 
      { let (moreBindings, moreBindingRanges) = List.unzip $2
        let moreLocalBindingsLastRange = if moreBindingRanges.IsEmpty then None else Some (List.last moreBindingRanges)
        match $1 with 
        | Some (localBindingRange, attrLocalBindingBuilder) -> 
           let lastRange = 
               match moreLocalBindingsLastRange with 
               | None -> localBindingRange 
               | Some m -> m
           Some lastRange, (fun xmlDoc attrs vis mLetKwd -> attrLocalBindingBuilder xmlDoc attrs vis mLetKwd true ::  moreBindings)
        | None -> 
           moreLocalBindingsLastRange, (fun _xmlDoc _attrs _vis _letm -> moreBindings) }


moreLocalBindings: 
  | AND attr_localBinding moreLocalBindings 
      { let mLetKwd = rhs parseState 1
        (match $2 with 
         | Some (localBindingRange, attrLocalBindingBuilder) ->
            let xmlDoc = grabXmlDoc(parseState, [], 1)
            let xmlDoc = if xmlDoc.IsEmpty then grabXmlDoc(parseState, [], 2) else xmlDoc
            (attrLocalBindingBuilder xmlDoc [] None mLetKwd false, localBindingRange) :: $3
         | None -> $3) }

  | %prec prec_no_more_attr_bindings 
      { [] }


/* A single binding, possibly with custom attributes */
attr_localBinding: 
  | opt_attributes localBinding 
      { let attrs2 = $1
        let localBindingRange, localBindingBuilder = $2
        let attrLocalBindingBuilder = (fun xmlDoc attrs vis mLetKwd _ -> localBindingBuilder xmlDoc (attrs@attrs2) vis mLetKwd)
        Some(localBindingRange, attrLocalBindingBuilder) }

  | error 
      { None }


/* A single binding in an expression or definition */
localBinding: 
  | opt_inline opt_mutable bindingPattern  opt_topReturnTypeWithTypeConstraints EQUALS  typedExprWithStaticOptimizationsBlock 
      { let (expr:SynExpr), opts = $6
        let mEquals = rhs parseState 5
        let mRhs = expr.Range 
        let optReturnType = $4 
        let bindingPat, mBindLhs = $3 
        let localBindingRange = unionRanges (rhs2 parseState 1 5) mRhs
        let localBindingBuilder = 
          (fun xmlDoc attrs vis mLetKwd ->
            let mWhole = (unionRanges mLetKwd mRhs, attrs) ||> unionRangeWithListBy (fun (a: SynAttributeList) -> a.Range)
            let spBind = if IsDebugPointBinding bindingPat expr then DebugPointAtBinding.Yes mWhole else DebugPointAtBinding.NoneAtLet
            let mWholeBindLhs = (mBindLhs, attrs) ||> unionRangeWithListBy (fun (a: SynAttributeList) -> a.Range)
            let trivia: SynBindingTrivia = { LetKeyword = Some mLetKwd; EqualsRange = Some mEquals }
            mkSynBinding (xmlDoc, bindingPat) (vis, $1, $2, mWholeBindLhs, spBind, optReturnType, expr, mRhs, opts, attrs, None, trivia))
        localBindingRange, localBindingBuilder }

  | opt_inline opt_mutable bindingPattern  opt_topReturnTypeWithTypeConstraints EQUALS  error
      { let mWhole = rhs2 parseState 1 5 
        let mRhs = rhs parseState 5
        let optReturnType = $4 
        let bindingPat, mBindLhs = $3
        let localBindingBuilder = 
          (fun xmlDoc attrs vis mLetKwd ->
            let mEquals = rhs parseState 5
            let zeroWidthAtEnd = mEquals.EndRange
            let rhsExpr = arbExpr("localBinding1", zeroWidthAtEnd)
            let spBind = if IsDebugPointBinding bindingPat rhsExpr then DebugPointAtBinding.Yes mWhole else DebugPointAtBinding.NoneAtLet
            let trivia: SynBindingTrivia = { LetKeyword = Some mLetKwd; EqualsRange = Some mEquals }
            mkSynBinding (xmlDoc, bindingPat) (vis, $1, $2, mBindLhs, spBind, optReturnType, rhsExpr, mRhs, [], attrs, None, trivia))
        mWhole, localBindingBuilder }

  | opt_inline opt_mutable bindingPattern  opt_topReturnTypeWithTypeConstraints recover
      { if not $5 then reportParseErrorAt (rhs parseState 5) (FSComp.SR.parsUnexpectedEndOfFileDefinition())
        let optReturnType = $4 
        let mWhole = rhs2 parseState 1 (match optReturnType with None -> 3 | _ -> 4)
        let mRhs = mWhole.EndRange  // zero-width range at end of last good token
        let bindingPat, mBindLhs = $3 
        let localBindingBuilder = 
          (fun xmlDoc attrs vis mLetKwd ->
            let spBind = DebugPointAtBinding.Yes (unionRanges mLetKwd mRhs)
            let trivia = { LetKeyword = Some mLetKwd; EqualsRange = None }
            let rhsExpr = arbExpr("localBinding2", mRhs)
            mkSynBinding (xmlDoc, bindingPat) (vis, $1, $2, mBindLhs, spBind, optReturnType, rhsExpr, mRhs, [], attrs, None, trivia))
        mWhole, localBindingBuilder }

/* A single expression with an optional type annotation, and an optional static optimization block */
typedExprWithStaticOptimizationsBlock: 
  | OBLOCKBEGIN typedExprWithStaticOptimizations oblockend 
      { $2 }

  | OBLOCKBEGIN typedExprWithStaticOptimizations recover 
      { if not $3 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFile())
        let a, b = $2
        (exprFromParseError a, b) }

  | typedExprWithStaticOptimizations 
      { $1 }

typedExprWithStaticOptimizations : 
  | typedSequentialExpr opt_staticOptimizations
      { $1, List.rev $2 }

opt_staticOptimizations: 
  | opt_staticOptimizations staticOptimization
      { $2 :: $1 } 

  | /* EMPTY */
      { [] }

staticOptimization: 
  | WHEN staticOptimizationConditions EQUALS typedSequentialExprBlock
      { ($2, $4) }

staticOptimizationConditions: 
  | staticOptimizationConditions AND staticOptimizationCondition
      { $3 :: $1 } 

  | staticOptimizationCondition
      { [$1 ] }

staticOptimizationCondition: 
  | typar COLON typ
      { SynStaticOptimizationConstraint.WhenTyparTyconEqualsTycon($1, $3, lhs parseState) }

  | typar STRUCT
      { SynStaticOptimizationConstraint.WhenTyparIsStruct($1, lhs parseState) }

rawConstant: 
  | INT8
    { if snd $1 then errorR(Error(FSComp.SR.lexOutsideEightBitSigned(), lhs parseState))
      SynConst.SByte (fst $1) } 

  | UINT8
    { SynConst.Byte $1 } 

  | INT16
    { if snd $1 then errorR(Error(FSComp.SR.lexOutsideSixteenBitSigned(), lhs parseState))
      SynConst.Int16 (fst $1) } 

  | UINT16
    { SynConst.UInt16 $1 } 

  | INT32
    { if snd $1 then errorR(Error(FSComp.SR.lexOutsideThirtyTwoBitSigned(), lhs parseState))
      SynConst.Int32 (fst $1) } 

  | UINT32
    { SynConst.UInt32 $1 } 

  | INT64
    { if snd $1 then errorR(Error(FSComp.SR.lexOutsideSixtyFourBitSigned(), lhs parseState))
      SynConst.Int64 (fst $1) } 

  | UINT64
    { SynConst.UInt64 $1 } 

  | NATIVEINT
    { if snd $1 then errorR(Error(FSComp.SR.lexOutsideNativeSigned(), lhs parseState))
      SynConst.IntPtr (fst $1) } 

  | UNATIVEINT
    { SynConst.UIntPtr $1 } 

  | IEEE32
    { SynConst.Single $1 } 

  | IEEE64
    { SynConst.Double $1 } 

  | CHAR
    { SynConst.Char $1 } 

  | DECIMAL
    { SynConst.Decimal $1 } 

  | BIGNUM
    { SynConst.UserNum $1 } 

  | string
    { let s, synStringKind = $1
      SynConst.String (s, synStringKind, lhs parseState) } 

  | sourceIdentifier
    { let c,v = $1
      SynConst.SourceIdentifier (c, v, lhs parseState) }

  | BYTEARRAY
    { let (v, synByteStringKind, _) = $1
      SynConst.Bytes (v, synByteStringKind, lhs parseState) }

rationalConstant:
  | INT32 INFIX_STAR_DIV_MOD_OP INT32
    { if $2 <> "/" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure())
      if fst $3 = 0 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsIllegalDenominatorForMeasureExponent())
      if (snd $1) || (snd $3) then errorR(Error(FSComp.SR.lexOutsideThirtyTwoBitSigned(), lhs parseState))
      SynRationalConst.Rational(fst $1, fst $3, lhs parseState) }

  | MINUS INT32 INFIX_STAR_DIV_MOD_OP INT32 
    { if $3 <> "/" then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure())
      if fst $4 = 0 then reportParseErrorAt (rhs parseState 4) (FSComp.SR.parsIllegalDenominatorForMeasureExponent())
      if (snd $2) || (snd $4) then errorR(Error(FSComp.SR.lexOutsideThirtyTwoBitSigned(), lhs parseState))
      SynRationalConst.Negate(SynRationalConst.Rational(fst $2, fst $4, lhs parseState)) }

  | INT32
    { if snd $1 then errorR(Error(FSComp.SR.lexOutsideThirtyTwoBitSigned(), lhs parseState))
      SynRationalConst.Integer(fst $1) }

  | MINUS INT32
    { if snd $2 then errorR(Error(FSComp.SR.lexOutsideThirtyTwoBitSigned(), lhs parseState))
      SynRationalConst.Negate(SynRationalConst.Integer(fst $2)) }

atomicUnsignedRationalConstant:
  | INT32 { if snd $1 then errorR(Error(FSComp.SR.lexOutsideThirtyTwoBitSigned(), lhs parseState))
            SynRationalConst.Integer(fst $1) }

  | LPAREN rationalConstant rparen
    { $2 }

atomicRationalConstant:
  | atomicUnsignedRationalConstant { $1 }

  | MINUS atomicUnsignedRationalConstant
    { SynRationalConst.Negate($2) }

constant: 
  | rawConstant
    { $1, rhs parseState 1 }

  | rawConstant HIGH_PRECEDENCE_TYAPP measureTypeArg
    { SynConst.Measure($1, rhs parseState 1, $3), lhs parseState }

bindingPattern:
  | headBindingPattern
    { $1, rhs parseState 1 }

// Subset of patterns allowed to be used in implicit ctors.
// For a better error recovery we could replace these rules with the actual SynPat parsing
// and use allowed patterns only at a later analysis stage reporting errors along the way.
simplePattern:
  | ident
      { let m = rhs parseState 1 
        SynPat.Named(SynIdent($1, None), false, None, m) }

  | QMARK ident
      { SynPat.OptionalVal($2, rhs parseState 2) }

  | simplePattern COLON typeWithTypeConstraints
      { SynPat.Typed($1, $3, lhs parseState) }

  | attributes simplePattern %prec paren_pat_attribs
      { SynPat.Attrib($2, $1, lhs parseState) }

simplePatternCommaList:
  | simplePattern
      { $1 }

  | simplePattern COMMA simplePatternCommaList
      { match $3 with
        | SynPat.Tuple(_, pats, _) -> SynPat.Tuple(false, $1 :: pats, rhs2 parseState 1 3)
        | _ -> SynPat.Tuple(false, [$1; $3], rhs2 parseState 1 3) }

simplePatterns:
  | LPAREN simplePatternCommaList rparen
      { let parenPat = SynPat.Paren($2, rhs2 parseState 1 3)
        let simplePats, _ = SimplePatsOfPat parseState.SynArgNameGenerator parenPat
        simplePats }

  | LPAREN rparen
      { let pat = SynPat.Const(SynConst.Unit, rhs2 parseState 1 2)
        let simplePats, _ = SimplePatsOfPat parseState.SynArgNameGenerator pat
        simplePats }

  | LPAREN simplePatternCommaList recover
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen())
        let parenPat = SynPat.Paren(SynPat.Tuple(false, [], rhs2 parseState 1 2), rhs2 parseState 1 2) // todo: report parsed pats anyway?
        let simplePats, _ = SimplePatsOfPat parseState.SynArgNameGenerator parenPat
        simplePats }

  | LPAREN error rparen
      { let parenPat = SynPat.Paren(SynPat.Wild(rhs parseState 2), rhs2 parseState 1 3) // silent recovery
        let simplePats, _ = SimplePatsOfPat parseState.SynArgNameGenerator parenPat
        simplePats }

  | LPAREN recover
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen())
        let pat = SynPat.Wild(lhs parseState)
        let simplePats, _ = SimplePatsOfPat parseState.SynArgNameGenerator pat
        simplePats }


headBindingPattern:
  | headBindingPattern AS constrPattern 
      { SynPat.As($1, $3, rhs2 parseState 1 3) }

  | headBindingPattern BAR headBindingPattern  
      { let mBar = rhs parseState 2
        SynPat.Or($1, $3, rhs2 parseState 1 3, { BarRange = mBar }) }

  | headBindingPattern COLON_COLON  headBindingPattern 
      { SynPat.LongIdent (SynLongIdent(mkSynCaseName (rhs parseState 2) opNameCons, [], [ Some (IdentTrivia.OriginalNotation "::") ]), None, None, None, SynArgPats.Pats [SynPat.Tuple (false, [$1;$3], rhs2 parseState 1 3)], None, lhs parseState) }

  | tuplePatternElements  %prec pat_tuple 
      { SynPat.Tuple(false, List.rev $1, lhs parseState) }

  | conjPatternElements   %prec pat_conj
      { SynPat.Ands(List.rev $1, lhs parseState) }

  | constrPattern 
      { $1 }

tuplePatternElements: 
  | tuplePatternElements COMMA headBindingPattern 
      { $3 :: $1 }

  | headBindingPattern COMMA headBindingPattern 
      { $3 :: $1 :: [] }

conjPatternElements: 
  | conjPatternElements AMP headBindingPattern 
     { $3 :: $1 }

  | headBindingPattern AMP headBindingPattern 
     { $3 :: $1 :: [] }

namePatPairs:
   | namePatPair opt_seps
     { [$1], lhs parseState }

   | namePatPair seps namePatPairs
     { let (rs, _) = $3 in ($1 :: rs), lhs parseState }

namePatPair:
   | ident EQUALS parenPattern
     { let mEquals = rhs parseState 2
       ($1, mEquals, $3) }

constrPattern:
  | atomicPatternLongIdent explicitValTyparDecls
      { let vis, lid = $1
        SynPat.LongIdent (lid, None, None, Some $2, SynArgPats.Pats [], vis, lhs parseState) }

  | atomicPatternLongIdent explicitValTyparDecls atomicPatsOrNamePatPairs %prec pat_app
      { let vis, lid = $1
        let args, argsM = $3
        let m = unionRanges (rhs2 parseState 1 2) argsM
        SynPat.LongIdent (lid, None, None, Some $2, args, vis, m) }

  | atomicPatternLongIdent explicitValTyparDecls HIGH_PRECEDENCE_PAREN_APP atomicPatsOrNamePatPairs
      { let vis, lid = $1
        let args, argsM = $4
        let m = unionRanges (rhs2 parseState 1 2) argsM
        SynPat.LongIdent (lid, None, None, Some $2, args, vis, m) }

  | atomicPatternLongIdent explicitValTyparDecls HIGH_PRECEDENCE_BRACK_APP atomicPatsOrNamePatPairs
      { let vis, lid = $1
        let args, argsM = $4
        let m = unionRanges (rhs2 parseState 1 2) argsM
        SynPat.LongIdent (lid, None, None, Some $2, args, vis, m) }

  | atomicPatternLongIdent atomicPatsOrNamePatPairs %prec pat_app
      { let vis, lid = $1
        let args, argsM = $2
        let m = unionRanges (rhs parseState 1) argsM
        SynPat.LongIdent (lid, None, None, None, args, vis, m) }

  | atomicPatternLongIdent HIGH_PRECEDENCE_PAREN_APP atomicPatsOrNamePatPairs
      { let vis, lid = $1
        let args, argsM = $3
        let m = unionRanges (rhs parseState 1) argsM
        SynPat.LongIdent (lid, None, None, None, args, vis, m) }

  | atomicPatternLongIdent HIGH_PRECEDENCE_BRACK_APP atomicPatsOrNamePatPairs
      { let vis, lid = $1
        let args, argsM = $3
        let m = unionRanges (rhs parseState 1) argsM
        SynPat.LongIdent (lid, None, None, None, args, vis, m) }

  | COLON_QMARK atomTypeOrAnonRecdType  %prec pat_isinst 
      { SynPat.IsInst($2, lhs parseState) }

  | atomicPattern 
      { $1 }

atomicPatsOrNamePatPairs:
  | LPAREN namePatPairs rparen
      { SynArgPats.NamePatPairs $2, snd $2 }

  | atomicPatterns
      { let mParsed = rhs parseState 1
        let mAll = (mParsed.StartRange, $1) ||> unionRangeWithListBy (fun p -> p.Range)
        SynArgPats.Pats $1, mAll }

atomicPatterns: 
  | atomicPattern atomicPatterns %prec pat_args 
      { $1 :: $2 } 

  | atomicPattern HIGH_PRECEDENCE_BRACK_APP atomicPatterns 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsSuccessivePatternsShouldBeSpacedOrTupled())
        $1 :: $3 } 

  | atomicPattern HIGH_PRECEDENCE_PAREN_APP atomicPatterns 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsSuccessivePatternsShouldBeSpacedOrTupled())
        $1 :: $3 } 

  | atomicPattern
      { [$1] }


atomicPattern:
  | quoteExpr 
      { SynPat.QuoteExpr($1, lhs parseState) } 

  | CHAR DOT_DOT CHAR
      { SynPat.DeprecatedCharRange ($1, $3, rhs2 parseState 1 3) }

  | LBRACE recordPatternElementsAux rbrace
      { let rs, m = $2 in SynPat.Record (rs, rhs2 parseState 1 3) }

  | LBRACK listPatternElements RBRACK
      { SynPat.ArrayOrList(false, $2, lhs parseState) }

  | LBRACK_BAR listPatternElements  BAR_RBRACK
      { SynPat.ArrayOrList(true, $2, lhs parseState) }

  | UNDERSCORE 
      { SynPat.Wild (lhs parseState) }

  | QMARK ident 
      { SynPat.OptionalVal($2, lhs parseState) } 

  | atomicPatternLongIdent %prec prec_atompat_pathop 
      { let vis, lidwd = $1 
        if not (isNilOrSingleton lidwd.LongIdent) || String.isLeadingIdentifierCharacterUpperCase (List.head lidwd.LongIdent).idText then 
            mkSynPatMaybeVar lidwd vis (lhs parseState)
        else 
           let synIdent = List.head lidwd.IdentsWithTrivia
           let (SynIdent(id, _)) = synIdent
           SynPat.Named (synIdent, false, vis, id.idRange) }

  | constant 
      { SynPat.Const (fst $1, snd $1) }

  | FALSE  
      { SynPat.Const(SynConst.Bool false, lhs parseState) } 

  | TRUE  
      { SynPat.Const(SynConst.Bool true, lhs parseState) } 

  | NULL 
      { SynPat.Null(lhs parseState) }

  | LPAREN parenPatternBody rparen
      { let m = lhs parseState
        SynPat.Paren($2 m, m) }

  | LPAREN parenPatternBody recover
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen())
        let m = rhs2 parseState 1 2
        let parenPat = SynPat.Paren($2 m, m)
        patFromParseError parenPat }

  | LPAREN error rparen
      { let innerPat = patFromParseError (SynPat.Wild (rhs parseState 2))
        SynPat.Paren(innerPat, lhs parseState) }

  | LPAREN recover
      { let parenM = rhs parseState 1
        reportParseErrorAt parenM (FSComp.SR.parsUnmatchedParen())
        let innerPat = patFromParseError (SynPat.Wild parenM.EndRange)
        let parenPat = SynPat.Paren(innerPat, parenM)
        patFromParseError parenPat }

  | STRUCT LPAREN tupleParenPatternElements rparen
      { SynPat.Tuple(true, List.rev $3, lhs parseState) }

  | STRUCT LPAREN tupleParenPatternElements recover
      { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnmatchedParen()); 
        SynPat.Tuple(true, List.rev $3, lhs parseState) }

  | STRUCT LPAREN error rparen 
      { (* silent recovery *) SynPat.Wild (lhs parseState) }

  | STRUCT LPAREN recover 
      {  reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnmatchedParen()); 
         SynPat.Wild (lhs parseState)}  

parenPatternBody: 
  | parenPattern 
      { (fun m -> $1) } 

  | /* EMPTY */
      { (fun m -> SynPat.Const(SynConst.Unit, m)) } 

/* This duplicates out 'patterns' in order to give type annotations */
/* the desired precedence w.r.t. patterns, tuple patterns in particular. */
/* Duplication requried to minimize the disturbance to the grammar, */
/* in particular the expected property that "pat" parses the same as */
/* "(pat)"!  Here are some examples: */
/*    a, b                  parses as (a, b) */
/*    (a, b)           also parses as (a, b) */
/*    (a, b : t)            parses as (a, (b:t)) */
/*    a, b as t             parses as ((a, b) as t) */
/*    (a, b as t)      also parses as ((a, b) as t) */
/*    a, b | c, d            parses as ((a, b) | (c, d)) */
/*    (a, b | c, d)     also parses as ((a, b) | (c, d)) */
/*    (a : t, b)            parses as ((a:t), b) */
/*    (a : t1, b : t2)      parses as ((a:t), (b:t2)) */
/*    (a, b as nm : t)      parses as (((a, b) as nm) : t) */
/*    (a, b :: c : t)       parses as (((a, b) :: c) : t) */
/* */
/* Probably the most unexpected thing here is that 'as nm' binds the */
/* whole pattern to the left, whereas ': t' binds only the pattern */
/* immediately preceding in the tuple. */
/* */
/* Also, it is unexpected that '(a, b : t)' in a pattern (a, (b : 't)) binds differently to */
/* '(a, b : t)' in an expression ((a, b) : 't). It's not that easy to solve that without */
/* duplicating the entire expression grammar, or making a fairly severe breaking change */
/* to the language. */
parenPattern:
  | parenPattern AS constrPattern 
      { SynPat.As($1, $3, rhs2 parseState 1 3) }

  | parenPattern BAR parenPattern  
      { let mBar = rhs parseState 2
        SynPat.Or($1, $3, rhs2 parseState 1 3, { BarRange = mBar }) }

  | tupleParenPatternElements 
      { SynPat.Tuple(false, List.rev $1, lhs parseState) }

  | conjParenPatternElements
      { SynPat.Ands(List.rev $1, rhs2 parseState 1 3) }

  | parenPattern COLON  typeWithTypeConstraints %prec paren_pat_colon
      { let lhsm = lhs parseState 
        SynPat.Typed($1, $3, lhsm) } 

  | attributes parenPattern  %prec paren_pat_attribs
      { let lhsm = lhs parseState 
        SynPat.Attrib($2, $1, lhsm) } 

  | parenPattern COLON_COLON  parenPattern 
      { SynPat.LongIdent (SynLongIdent(mkSynCaseName (rhs parseState 2) opNameCons, [], [ Some (IdentTrivia.OriginalNotation "::") ]), None, None, None, SynArgPats.Pats [ SynPat.Tuple (false, [$1;$3], rhs2 parseState 1 3) ], None, lhs parseState) }

  | constrPattern { $1 }

tupleParenPatternElements:
  | tupleParenPatternElements COMMA parenPattern  
      { $3 :: $1 }

  | parenPattern COMMA parenPattern  
      { $3 :: $1 :: [] }
  
conjParenPatternElements: 
  | conjParenPatternElements AMP parenPattern 
      { $3 :: $1 }

  | parenPattern AMP parenPattern 
      { $3 :: $1 :: [] }

recordPatternElementsAux: /* Fix 1190 */
  | recordPatternElement opt_seps                      
      { [$1], lhs parseState }

  | recordPatternElement seps recordPatternElementsAux 
      { let r = $1 in let (rs, dropMark) = $3 in (r :: rs), lhs parseState }

recordPatternElement:  
  | path EQUALS parenPattern 
    { let mEquals = rhs parseState 2
      (List.frontAndBack $1.LongIdent, mEquals, $3) }

listPatternElements:
  | /* EMPTY */                                      
      { [] }

  | parenPattern opt_seps                 
      { [$1] }

  | parenPattern seps listPatternElements 
      { $1 :: $3 }

/* The lexfilter likes to insert OBLOCKBEGIN/OBLOCKEND pairs */
typedSequentialExprBlock: 
  | OBLOCKBEGIN typedSequentialExpr oblockend 
      { $2 }

  | OBLOCKBEGIN typedSequentialExpr recover 
      { if not $3 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFileExpression())
        exprFromParseError $2 }

  | typedSequentialExpr 
      { $1 }

/* The lexfilter likes to insert OBLOCKBEGIN/OBLOCKEND pairs */
declExprBlock: 
  | OBLOCKBEGIN typedSequentialExpr oblockend 
      { $2 }

  | declExpr 
      { $1 }

/* For some constructs the lex filter can't be sure to insert a matching OBLOCKEND, e.g. "function a -> b | c -> d" all in one line */
/* for these it only inserts a trailing ORIGHT_BLOCK_END */
typedSequentialExprBlockR: 
  | typedSequentialExpr ORIGHT_BLOCK_END
    { $1 }

  | typedSequentialExpr
    { $1 }

typedSequentialExpr: 
  | sequentialExpr COLON typeWithTypeConstraints
    { SynExpr.Typed ($1, $3, unionRanges $1.Range $3.Range) }

  | sequentialExpr
    { $1 }

typedSequentialExprEOF:
  | typedSequentialExpr EOF
    { checkEndOfFileError $2; $1 }

sequentialExpr:
  | declExpr seps sequentialExpr
      { SynExpr.Sequential (DebugPointAtSequential.SuppressNeither, true, $1, $3, unionRanges $1.Range $3.Range) } 

  | declExpr seps                         
      { $1 }  

  | declExpr             %prec SEMICOLON 
      { $1 } 

  | declExpr THEN sequentialExpr %prec prec_then_before 
      { SynExpr.Sequential (DebugPointAtSequential.SuppressNeither, false, $1, $3, unionRanges $1.Range $3.Range ) }

  | declExpr OTHEN OBLOCKBEGIN typedSequentialExpr oblockend %prec prec_then_before 
      { SynExpr.Sequential (DebugPointAtSequential.SuppressNeither, false, $1, $4, unionRanges $1.Range $4.Range) }

  | hardwhiteLetBindings %prec prec_args_error
     { let hwlb, m, mIn = $1
       let mLetKwd, isUse = match hwlb with (BindingSetPreAttrs(m, _, isUse, _, _))  -> m, isUse
       let usedKeyword = if isUse then "use" else "let"
       reportParseErrorAt mLetKwd (FSComp.SR.parsExpectedExpressionAfterLet(usedKeyword, usedKeyword))
       let fauxRange = m.EndRange // zero width range at end of m
       mkLocalBindings (m, hwlb, mIn, arbExpr("seqExpr", fauxRange)) }

/* Use this as the last terminal when performing error recovery */
/* The contract for using this is that (a) if EOF occurs then the */
/* the using production must report an error and (b) the using production */
/* can report an error anyway if it is helpful, e.g. "unclosed '('" (giving two errors) */
recover: 
   | error
      { debugPrint("recovering via error"); true }  

   | EOF
      { debugPrint("recovering via EOF"); false }

moreBinders:
  | AND_BANG headBindingPattern EQUALS typedSequentialExprBlock IN moreBinders %prec expr_let
     { let spBind = DebugPointAtBinding.Yes(rhs2 parseState 1 5) (* TODO Pretty sure this is wrong *)
       let mEquals = rhs parseState 3
       let m = unionRanges (rhs parseState 1) $4.Range
       let mIn = rhs parseState 5
       SynExprAndBang(spBind, $1, true, $2, $4, m, { EqualsRange = mEquals; InKeyword = Some mIn }) :: $6 }

  | OAND_BANG headBindingPattern EQUALS typedSequentialExprBlock hardwhiteDefnBindingsTerminator opt_OBLOCKSEP moreBinders %prec expr_let
     { let report, mIn = $5
       report "and!" (rhs parseState 1)  // report unterminated error
       let spBind = DebugPointAtBinding.Yes(rhs2 parseState 1 5) (* TODO Pretty sure this is wrong *)
       let mEquals = rhs parseState 3
       let m = unionRanges (rhs parseState 1) $4.Range
       SynExprAndBang(spBind, $1, true, $2, $4, m, { EqualsRange = mEquals; InKeyword = mIn }) :: $7 }

  | %prec prec_no_more_attr_bindings
      { [] }

declExpr:
  | defnBindings IN typedSequentialExpr  %prec expr_let 
     { let mIn = rhs parseState 2 |> Some
       mkLocalBindings (unionRanges (rhs2 parseState 1 2) $3.Range, $1, mIn, $3) }

  | defnBindings IN error        %prec expr_let
     { let mIn = rhs parseState 2 |> Some
       mkLocalBindings (rhs2 parseState 1 2, $1, mIn, arbExpr("declExpr1", (rhs parseState 3))) }
/*
    FSComp.SR.parsNoMatchingInForLet() -- leave this in for now - it's an unused error string
*/

  | hardwhiteLetBindings typedSequentialExprBlock  %prec expr_let 
     { let hwlb, m, mIn = $1
       mkLocalBindings (unionRanges m $2.Range, hwlb, mIn, $2) }

  | hardwhiteLetBindings error        %prec expr_let
     { let hwlb, m, mIn = $1
       reportParseErrorAt (match hwlb with (BindingSetPreAttrs(m, _, _, _, _))  -> m) (FSComp.SR.parsErrorInReturnForLetIncorrectIndentation())
       mkLocalBindings (m, hwlb, mIn, arbExpr("declExpr2", (rhs parseState 2))) }

  | hardwhiteLetBindings OBLOCKSEP typedSequentialExprBlock  %prec expr_let 
     { let hwlb, m, mIn = $1
       mkLocalBindings (unionRanges m $3.Range, hwlb, mIn, $3) }

  | hardwhiteLetBindings OBLOCKSEP error        %prec expr_let
     { let hwlb, m, mIn = $1
       //reportParseErrorAt (match hwlb with (BindingSetPreAttrs(m, _, _, _, _))  -> m) (FSComp.SR.parsErrorInReturnForLetIncorrectIndentation())
       mkLocalBindings (unionRanges m (rhs parseState 3), hwlb, mIn, arbExpr("declExpr3", (rhs parseState 3))) }

  | hardwhiteDoBinding %prec expr_let
     { let e = snd $1
       SynExpr.Do (e, unionRanges (rhs parseState 1).StartRange e.Range) }

  | anonMatchingExpr %prec expr_function
      { $1 }

  | anonLambdaExpr  %prec expr_fun 
      { $1 }

  | MATCH typedSequentialExpr withClauses %prec expr_match
      { let mMatch = rhs parseState 1
        let mWith, (clauses, mLast) = $3
        let spBind = DebugPointAtBinding.Yes(unionRanges mMatch mWith)
        let trivia = { MatchKeyword = mMatch; WithKeyword = mWith }
        SynExpr.Match (spBind, $2, clauses, unionRanges mMatch mLast, trivia) }

  | MATCH typedSequentialExpr recover %prec expr_match
      { if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileMatch())
        // Produce approximate expression during error recovery
        exprFromParseError $2 }

  | MATCH_BANG typedSequentialExpr     withClauses              %prec expr_match 
      { let mMatch = (rhs parseState 1)
        let mWith, (clauses, mLast) = $3 
        let spBind = DebugPointAtBinding.Yes(unionRanges mMatch mWith)
        let trivia = { MatchBangKeyword = mMatch; WithKeyword = mWith }
        SynExpr.MatchBang (spBind, $2, clauses, unionRanges mMatch mLast, trivia) }

  | MATCH_BANG typedSequentialExpr     recover               %prec expr_match 
      { if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileMatch())
        // Produce approximate expression during error recovery 
        exprFromParseError $2 }
      
  | TRY typedSequentialExprBlockR withClauses              %prec expr_try 
      { let mTry = (rhs parseState 1)
        let spTry = DebugPointAtTry.Yes mTry
        let mWith, (clauses, mLast) = $3 
        let spWith = DebugPointAtWith.Yes mWith
        let mTryToWith = unionRanges mTry mWith 
        let mWithToLast = unionRanges mWith mLast 
        let mTryToLast = unionRanges mTry mLast
        let trivia: SynExprTryWithTrivia = 
            { TryKeyword = mTry
              TryToWithRange = mTryToWith
              WithKeyword = mWith
              WithToEndRange = mWithToLast }
        SynExpr.TryWith ($2, clauses, mTryToLast, spTry, spWith, trivia) }

  | TRY typedSequentialExprBlockR recover              %prec expr_try 
      { // Produce approximate expression during error recovery 
        // Include any expressions to make sure they gets type checked in case that generates useful results for intellisense 
        if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileTry())
        exprFromParseError $2 }

  | TRY typedSequentialExprBlockR FINALLY typedSequentialExprBlock %prec expr_try 
      { let mTry = rhs parseState 1 
        let spTry = DebugPointAtTry.Yes mTry
        let mFinally = rhs parseState 3
        let spFinally = DebugPointAtFinally.Yes mFinally
        let mTryToLast = unionRanges mTry $4.Range 
        let trivia = { TryKeyword = mTry; FinallyKeyword = mFinally }
        SynExpr.TryFinally ($2, $4, mTryToLast, spTry, spFinally, trivia) }

  | IF declExpr ifExprCases %prec expr_if 
      { let mIf = rhs parseState 1
        $3 $2 mIf false }

  | IF declExpr recover %prec expr_if 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsIncompleteIf()) 
        // Produce an approximate expression during error recovery. 
        // Include expressions to make sure they get type checked in case that generates useful results for intellisense. 
        // Generate a throwAway for the expression so it isn't forced to have a type 'bool' 
        // from the context it is used in. 
        exprFromParseError $2 }

  | IF recover %prec expr_if 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsIncompleteIf())
        // Produce an approximate expression during error recovery. There can still be value in doing this even
        // for this pathological case.
        let m = rhs parseState 1
        let mEnd = m.EndRange
        let spIfToThen = DebugPointAtBinding.Yes mEnd
        let trivia = { IfKeyword = m; IsElif = false; ThenKeyword = m; ElseKeyword = None; IfToThenRange = m }
        exprFromParseError (SynExpr.IfThenElse (arbExpr("ifGuard1", mEnd), arbExpr("thenBody1", mEnd), None, spIfToThen, true, m, trivia)) }

  | LAZY declExpr %prec expr_lazy 
      { SynExpr.Lazy ($2, unionRanges (rhs parseState 1) $2.Range) }

  | ASSERT declExpr %prec expr_assert 
      { SynExpr.Assert ($2, unionRanges (rhs parseState 1) $2.Range) }

  | ASSERT %prec expr_assert 
      { raiseParseErrorAt (rhs parseState 1) (FSComp.SR.parsAssertIsNotFirstClassValue()) }

  | OLAZY declExprBlock %prec expr_lazy 
      { SynExpr.Lazy ($2, unionRanges (rhs parseState 1) $2.Range) }

  | OASSERT declExprBlock %prec expr_assert 
      { SynExpr.Assert ($2, unionRanges (rhs parseState 1) $2.Range) }

  | OASSERT %prec expr_assert 
      { raiseParseErrorAt (rhs parseState 1) (FSComp.SR.parsAssertIsNotFirstClassValue()) }

  | WHILE declExpr doToken typedSequentialExprBlock doneDeclEnd 
      { let mWhileHeader = unionRanges (rhs parseState 1) $2.Range
        let spWhile = DebugPointAtWhile.Yes mWhileHeader 
        let mWhileAll = unionRanges (rhs parseState 1) $4.Range
        SynExpr.While (spWhile, $2, $4, mWhileAll) }
      
  | WHILE declExpr doToken typedSequentialExprBlock recover 
      { if not $5 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileWhile())
        let mWhileHeader = unionRanges (rhs parseState 1) $2.Range
        let spWhile = DebugPointAtWhile.Yes mWhileHeader 
        let mWhileAll = unionRanges (rhs parseState 1) $4.Range
        exprFromParseError (SynExpr.While (spWhile, $2, $4, mWhileAll)) }

  | WHILE declExpr doToken error doneDeclEnd 
      { // silent recovery 
        let mWhileHeader = unionRanges (rhs parseState 1) $2.Range
        let spWhile = DebugPointAtWhile.Yes mWhileHeader 
        let mWhileBodyArb = unionRanges (rhs parseState 4) (rhs parseState 5)
        let mWhileAll = unionRanges (rhs parseState 1) (rhs parseState 5)
        SynExpr.While (spWhile, $2, arbExpr("whileBody1", mWhileBodyArb), mWhileAll) }

  | WHILE declExpr recover 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsWhileDoExpected())
        let mWhileHeader = unionRanges (rhs parseState 1) $2.Range
        let spWhile = DebugPointAtWhile.Yes mWhileHeader 
        let mWhileBodyArb = rhs parseState 3
        let mWhileAll = unionRanges (rhs parseState 1) (rhs parseState 3)
        exprFromParseError (SynExpr.While (spWhile, $2, arbExpr("whileBody2", mWhileBodyArb), mWhileAll))  }

  | WHILE recover 
      { if not $2 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileWhile())
        arbExpr("whileLoop1", rhs parseState 1)  }

  | WHILE error doneDeclEnd 
      { //silent recovery
        let mWhileHeader = rhs parseState 1
        let spWhile = DebugPointAtWhile.Yes mWhileHeader 
        let mWhileBodyArb = rhs parseState 3
        let mWhileAll = unionRanges (rhs parseState 1) (rhs parseState 3)
        exprFromParseError (SynExpr.While (spWhile, arbExpr("whileGuard1", mWhileHeader), arbExpr("whileBody3", mWhileBodyArb), mWhileAll))  }

  | FOR forLoopBinder doToken typedSequentialExprBlock doneDeclEnd 
      { let mFor = rhs parseState 1
        let mDo = rhs parseState 3
        let spFor = DebugPointAtFor.Yes mFor
        let (a, b, _, spIn) = $2 
        SynExpr.ForEach (spFor, spIn, SeqExprOnly false, true, a, b, $4, unionRanges (rhs parseState 1) $4.Range) }

  | FOR forLoopBinder doToken typedSequentialExprBlock ends_coming_soon_or_recover
      { if not $5 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFor())
        let mFor = rhs parseState 1
        let spFor = DebugPointAtFor.Yes mFor
        let (a, b, _, spIn) = $2 
        let mForLoopAll = unionRanges (rhs parseState 1) $4.Range
        SynExpr.ForEach (spFor, spIn, SeqExprOnly false, true, a, b, $4, mForLoopAll) }  

  | FOR forLoopBinder doToken error doneDeclEnd 
      { // Silent recovery
        let mFor = rhs parseState 1
        let spFor = DebugPointAtFor.Yes mFor
        let (a, b, _, spIn) = $2 
        let mForLoopBodyArb = rhs parseState 5
        let mForLoopAll = rhs2 parseState 1 5
        SynExpr.ForEach (spFor, spIn, SeqExprOnly false, true, a, b, arbExpr("forLoopBody2a", mForLoopBodyArb), mForLoopAll) }

  | FOR forLoopBinder doToken ends_coming_soon_or_recover 
      { if not $4 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsExpectedExpressionAfterToken())
        let mFor = rhs parseState 1
        let spFor = DebugPointAtFor.Yes mFor
        let (a, b, _, spIn) = $2 
        let mForLoopBodyArb = rhs parseState 3
        let mForLoopAll = rhs2 parseState 1 3
        SynExpr.ForEach (spFor, spIn, SeqExprOnly false, true, a, b, arbExpr("forLoopBody2", mForLoopBodyArb), mForLoopAll) }

  | FOR forLoopBinder ends_coming_soon_or_recover
      { let (a, b, ok, spIn) = $2 
        if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsForDoExpected())
        let mFor = rhs parseState 1
        let spFor = DebugPointAtFor.Yes mFor
        let mForLoopBodyArb = rhs parseState 3
        let mForLoopAll = rhs2 parseState 1 3
        SynExpr.ForEach (spFor, spIn, SeqExprOnly false, true, a, b, arbExpr("forLoopBody1", mForLoopBodyArb), mForLoopAll) }

  | FOR forLoopBinder opt_OBLOCKSEP arrowThenExprR %prec expr_let 
     { let spFor = DebugPointAtFor.Yes (rhs parseState 1)
       let (a, b, _, spIn) = $2
       SynExpr.ForEach (spFor, spIn, SeqExprOnly true, true, a, b, $4, unionRanges (rhs parseState 1) $4.Range) }

  | FOR forLoopRange  doToken typedSequentialExprBlock doneDeclEnd 
      { let mFor = rhs parseState 1
        let spFor = DebugPointAtFor.Yes mFor
        let (a, b, c, d, e, spTo) = $2 
        let mForLoopAll = unionRanges (rhs parseState 1) $4.Range
        SynExpr.For (spFor, spTo, a, b, c, d, e, $4, mForLoopAll) }

  | FOR forLoopRange  doToken typedSequentialExprBlock recover 
      { if not $5 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFor())
        // Still produce an expression
        let mFor = rhs parseState 1
        let spFor = DebugPointAtFor.Yes mFor
        let (a, b, c, d, e, spTo) = $2 
        let mForLoopAll = unionRanges (rhs parseState 1) $4.Range
        exprFromParseError (SynExpr.For (spFor, spTo, a, b, c, d, e, $4, mForLoopAll)) }

  | FOR forLoopRange  doToken error doneDeclEnd 
      { // silent recovery 
        let mFor = rhs parseState 1
        let spFor = DebugPointAtFor.Yes mFor
        let (a, b, c, d, e, spTo) = $2 
        let mForLoopBodyArb = rhs parseState 5
        let mForLoopAll = rhs2 parseState 1 5
        SynExpr.For (spFor, spTo, a, b, c, d, e, arbExpr("declExpr11", mForLoopBodyArb), mForLoopAll) }

  | FOR forLoopRange  doToken recover
      { if not $4 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFor())
        let mFor = rhs parseState 1
        let spFor = DebugPointAtFor.Yes mFor
        let (a, b, c, d, e, spTo) = $2 
        let mForLoopBodyArb = rhs parseState 3
        let mForLoopAll = rhs2 parseState 1 3
        exprFromParseError (SynExpr.For (spFor, spTo, a, b, c, d, e, arbExpr("declExpr11", mForLoopBodyArb), mForLoopAll)) }

  | FOR forLoopRange recover
      { if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFor())
        let mFor = rhs parseState 1
        let spFor = DebugPointAtFor.Yes mFor
        let (a, b, c, d, e, spTo) = $2 
        let mForLoopBodyArb = (rhs parseState 2).EndRange
        let mForLoopAll = rhs2 parseState 1 2
        exprFromParseError (SynExpr.For (spFor, spTo, a, b, c, d, e, arbExpr("declExpr11", mForLoopBodyArb), mForLoopAll)) }

  | FOR error doToken typedSequentialExprBlock doneDeclEnd 
      { // silent recovery 
        let mFor = rhs parseState 1
        let spToFake = DebugPointAtInOrTo.Yes mFor
        let mForLoopAll = unionRanges (rhs parseState 1) $4.Range
        let spFor = DebugPointAtFor.Yes mFor
        SynExpr.For (spFor, spToFake, mkSynId mFor "_loopVar", None, arbExpr("startLoopRange1", mFor), true, arbExpr("endLoopRange1", rhs parseState 3), $4, mForLoopAll) }

  | FOR ends_coming_soon_or_recover
      { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsIdentifierExpected())
        arbExpr("declExpr12", (rhs parseState 1)) }

  | FOR parenPattern error doneDeclEnd 
      { reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsInOrEqualExpected())
        let mFor = rhs parseState 1
        let spFor = DebugPointAtFor.Yes mFor
        let spInFake = DebugPointAtInOrTo.Yes mFor
        let mForLoopBodyArb = rhs parseState 4
        let mForLoopAll = rhs2 parseState 1 4
        SynExpr.ForEach (spFor, spInFake, SeqExprOnly false, true, $2, arbExpr("forLoopCollection", mFor), arbExpr("forLoopBody3", mForLoopBodyArb), mForLoopAll) }

  | FOR parenPattern recover
      { if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFor())
        let mFor = rhs parseState 1
        let mIn = rhs parseState 1
        let spFor = DebugPointAtFor.Yes mFor
        let spIn = DebugPointAtInOrTo.Yes mIn
        let mForLoopBodyArb = (rhs parseState 2).EndRange
        let mForLoopAll = rhs2 parseState 1 2
        exprFromParseError (SynExpr.ForEach (spFor, spIn, SeqExprOnly false, true, $2, arbExpr("forLoopCollection", mFor), arbExpr("forLoopBody3", mForLoopBodyArb), mForLoopAll)) }

  | YIELD declExpr
     { SynExpr.YieldOrReturn (($1, not $1), $2, unionRanges (rhs parseState 1) $2.Range) } 

  | YIELD_BANG declExpr
     { SynExpr.YieldOrReturnFrom (($1, not $1), $2, unionRanges (rhs parseState 1) $2.Range) } 

  | YIELD recover
     { let mYieldAll = rhs parseState 1
       SynExpr.YieldOrReturn (($1, not $1), arbExpr("yield", mYieldAll), mYieldAll) } 

  | YIELD_BANG recover
     { let mYieldAll = rhs parseState 1
       SynExpr.YieldOrReturnFrom (($1, not $1), arbExpr("yield!", mYieldAll), mYieldAll) } 

  | BINDER headBindingPattern EQUALS typedSequentialExprBlock IN opt_OBLOCKSEP moreBinders typedSequentialExprBlock %prec expr_let
     { let spBind = DebugPointAtBinding.Yes(rhs2 parseState 1 5)
       let mEquals = rhs parseState 3
       let m = unionRanges (rhs parseState 1) $8.Range
       let trivia: SynExprLetOrUseBangTrivia = { EqualsRange = Some mEquals }
       SynExpr.LetOrUseBang(spBind, ($1 = "use"), true, $2, $4, $7, $8, m, trivia) }

  | OBINDER headBindingPattern EQUALS typedSequentialExprBlock hardwhiteDefnBindingsTerminator opt_OBLOCKSEP moreBinders typedSequentialExprBlock %prec expr_let
     { let report, mIn = $5
       report (if $1 = "use" then "use!" else "let!") (rhs parseState 1)  // report unterminated error 
       let spBind = DebugPointAtBinding.Yes(unionRanges (rhs parseState 1) $4.Range)
       let mEquals = rhs parseState 3
       let m = unionRanges (rhs parseState 1) $8.Range
       let trivia: SynExprLetOrUseBangTrivia = { EqualsRange = Some mEquals }
       SynExpr.LetOrUseBang(spBind, ($1 = "use"), true, $2, $4, $7, $8, m, trivia) }

  | OBINDER headBindingPattern EQUALS typedSequentialExprBlock hardwhiteDefnBindingsTerminator opt_OBLOCKSEP error %prec expr_let 
     { // error recovery that allows intellisense when writing incomplete computation expressions 
       let spBind = DebugPointAtBinding.Yes(unionRanges (rhs parseState 1) $4.Range) 
       let mEquals = rhs parseState 3
       let mAll = unionRanges (rhs parseState 1) (rhs parseState 7)
       let m = $4.Range.EndRange // zero-width range
       let trivia: SynExprLetOrUseBangTrivia = { EqualsRange = Some mEquals }
       SynExpr.LetOrUseBang(spBind, ($1 = "use"), true, $2, $4, [], SynExpr.ImplicitZero m, mAll, trivia) }

  | DO_BANG typedSequentialExpr IN opt_OBLOCKSEP typedSequentialExprBlock %prec expr_let 
     { let spBind = DebugPointAtBinding.NoneAtDo
       let trivia: SynExprLetOrUseBangTrivia = { EqualsRange = None }
       SynExpr.LetOrUseBang(spBind, false, true, SynPat.Const(SynConst.Unit, $2.Range), $2, [], $5, unionRanges (rhs parseState 1) $5.Range, trivia) }

  | ODO_BANG typedSequentialExprBlock hardwhiteDefnBindingsTerminator %prec expr_let 
     { SynExpr.DoBang ($2, unionRanges (rhs parseState 1) $2.Range) }

  | FIXED declExpr
     { SynExpr.Fixed ($2, (unionRanges (rhs parseState 1) $2.Range)) } 

  | RARROW typedSequentialExprBlockR 
     { errorR(Error(FSComp.SR.parsArrowUseIsLimited(), lhs parseState))
       SynExpr.YieldOrReturn ((true, true), $2, (unionRanges (rhs parseState 1) $2.Range)) } 

  | declExpr COLON_QMARK typ
     { SynExpr.TypeTest ($1, $3, unionRanges $1.Range $3.Range) }

  | declExpr COLON_GREATER typ
     { SynExpr.Upcast ($1, $3, unionRanges $1.Range $3.Range) } 

  | declExpr COLON_QMARK_GREATER typ
     { SynExpr.Downcast ($1, $3, unionRanges $1.Range $3.Range) }

  | declExpr COLON_EQUALS declExpr
     { mkSynInfix (rhs parseState 2) $1 ":=" $3 }
  
  | minusExpr LARROW declExprBlock
     { mkSynAssign $1 $3 }

  | tupleExpr  %prec expr_tuple
     { let exprs, commas = $1
       SynExpr.Tuple (false, List.rev exprs, List.rev commas, (commas.Head, exprs) ||> unionRangeWithListBy (fun e -> e.Range) ) }

  | declExpr JOIN_IN declExpr
     { SynExpr.JoinIn ($1, rhs parseState 2, $3, unionRanges $1.Range $3.Range) }

  | declExpr BAR_BAR declExpr
     { mkSynInfix (rhs parseState 2) $1 "||" $3 }

  | declExpr INFIX_BAR_OP declExpr
     { mkSynInfix (rhs parseState 2) $1 $2 $3 }

  | declExpr OR declExpr
     { mkSynInfix (rhs parseState 2) $1 "or" $3 }

  | declExpr AMP declExpr
     { mkSynInfix (rhs parseState 2) $1 "&" $3 }

  | declExpr AMP_AMP declExpr
     { mkSynInfix (rhs parseState 2) $1 "&&" $3 }

  | declExpr INFIX_AMP_OP declExpr
     { mkSynInfix (rhs parseState 2) $1 $2 $3 }

  | declExpr EQUALS declExpr
     { mkSynInfix (rhs parseState 2) $1 "=" $3 }

  | declExpr INFIX_COMPARE_OP declExpr
     { mkSynInfix (rhs parseState 2) $1 $2 $3 }

  | declExpr DOLLAR declExpr
     { mkSynInfix (rhs parseState 2) $1 "$" $3 }

  | declExpr LESS declExpr
     { mkSynInfix (rhs parseState 2) $1 "<" $3 }

  | declExpr LESS recover
     { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("<"))  
       exprFromParseError (mkSynInfix (rhs parseState 2) $1 "<" (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr GREATER declExpr
     { mkSynInfix (rhs parseState 2) $1 ">" $3 }

  | declExpr INFIX_AT_HAT_OP declExpr
     { mkSynInfix (rhs parseState 2) $1 $2 $3 }

  | declExpr PERCENT_OP declExpr
     { mkSynInfix (rhs parseState 2) $1 $2 $3 }

  | declExpr COLON_COLON declExpr
     { let tupExpr = SynExpr.Tuple (false, [$1;$3], [rhs parseState 2], unionRanges $1.Range $3.Range)
       let identExpr = mkSynOperator (rhs parseState 2) "::"
       SynExpr.App (ExprAtomicFlag.NonAtomic, true, identExpr, tupExpr, unionRanges $1.Range $3.Range) }

  | declExpr PLUS_MINUS_OP declExpr
     { mkSynInfix (rhs parseState 2) $1 $2 $3 }

  | declExpr MINUS declExpr
     { mkSynInfix (rhs parseState 2) $1 "-" $3 }

  | declExpr STAR declExpr
     { mkSynInfix (rhs parseState 2) $1 "*" $3 }

  | declExpr INFIX_STAR_DIV_MOD_OP declExpr
     { mkSynInfix (rhs parseState 2) $1 $2 $3 }

  | declExpr INFIX_STAR_STAR_OP declExpr
     { mkSynInfix (rhs parseState 2) $1 $2 $3 }

  | declExpr JOIN_IN OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("in")) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 "@in" (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr BAR_BAR OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("||")) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 "||" (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr INFIX_BAR_OP OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr OR OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("or")) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 "or" (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr AMP OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("&")) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 "&" (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr AMP_AMP OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("&&")) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 "&&" (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr INFIX_AMP_OP OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr EQUALS OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("=")) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 "=" (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr INFIX_COMPARE_OP OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr DOLLAR OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("$")) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 "$" (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr LESS OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("<")) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 "<" (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr GREATER OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression(">")) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 ">" (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr INFIX_AT_HAT_OP OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr PERCENT_OP OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr COLON_COLON OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("::"))
       let identExpr = mkSynOperator (rhs parseState 2) "::"
       let tupExpr = SynExpr.Tuple (false, [$1;(arbExpr("declExprInfix", (rhs parseState 3).StartRange))], [rhs parseState 2], unionRanges $1.Range (rhs parseState 3).StartRange)
       SynExpr.App (ExprAtomicFlag.NonAtomic, true, identExpr, tupExpr, unionRanges $1.Range (rhs parseState 3).StartRange) }

  | declExpr PLUS_MINUS_OP OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr MINUS OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("-")) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 "-" (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr STAR OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("*")) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 "*" (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr INFIX_STAR_DIV_MOD_OP OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr INFIX_STAR_STAR_OP OBLOCKEND_COMING_SOON
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)) 
       exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix", (rhs parseState 3).StartRange))) }

  | declExpr DOT_DOT declExpr 
      { let wholem = rhs2 parseState 1 3
        let opm = rhs parseState 2
        SynExpr.IndexRange(Some $1, opm, Some $3, rhs parseState 1, rhs parseState 3, wholem) }

  | declExpr DOT_DOT %prec open_range_expr   
      { let wholem = rhs2 parseState 1 2
        let opm = rhs parseState 2
        SynExpr.IndexRange(Some $1, opm, None, rhs parseState 1, opm, wholem) }

  | DOT_DOT declExpr %prec open_range_expr
      { let wholem = rhs2 parseState 1 2
        let opm = rhs parseState 1
        SynExpr.IndexRange(None, opm, Some $2, opm, rhs parseState 2, wholem) }
      
  | STAR 
      { let m = rhs parseState 1
        SynExpr.IndexRange(None, m, None, m, m, m) }

  | INFIX_AT_HAT_OP declExpr
    { if not (parseState.LexBuffer.SupportsFeature LanguageFeature.FromEndSlicing) then 
        raiseParseErrorAt (rhs parseState 1) (FSComp.SR.fromEndSlicingRequiresVFive())
      if $1 <> "^" then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsInvalidPrefixOperator())
      let m = (rhs2 parseState 1 2)
      SynExpr.IndexFromEnd($2, m) }

  | minusExpr %prec expr_prefix_plus_minus { $1 }

dynamicArg:
  | IDENT
      { let m = rhs parseState 1
        SynExpr.Ident(Ident($1, m)) }

  | LPAREN typedSequentialExpr rparen
      { let lpr = rhs parseState 1
        let rpr = rhs parseState 3
        let m = unionRanges lpr rpr
        SynExpr.Paren($2, lpr, Some rpr, m) }

withClauses:
  | WITH withPatternClauses       
      { rhs parseState 1, $2 }

  | OWITH withPatternClauses OEND 
      { rhs parseState 1, $2 }

  | OWITH withPatternClauses recover 
      { if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileWith())
        rhs parseState 1, $2 }

withPatternClauses:
  | patternClauses 
      { $1 None }

  | BAR patternClauses 
      { let mBar = rhs parseState 1 |> Some
        $2 mBar }

  | BAR error 
      { // silent recovery 
        let mLast = rhs parseState 1
        [], mLast }

  | error  
      { // silent recovery 
        let mLast = rhs parseState 1
        [], mLast }


patternAndGuard: 
  | parenPattern patternGuard 
      { $1, $2 }

patternClauses:
  | patternAndGuard patternResult %prec prec_pat_pat_action
     { let pat, guard = $1
       let mArrow, resultExpr = $2
       let mLast = resultExpr.Range
       let m = unionRanges resultExpr.Range pat.Range
       fun mBar ->
           [SynMatchClause(pat, guard, resultExpr, m, DebugPointAtTarget.Yes, { ArrowRange = Some mArrow; BarRange = mBar })], mLast }

  | patternAndGuard patternResult BAR patternClauses
     { let pat, guard = $1
       let mArrow, resultExpr = $2
       let mNextBar = rhs parseState 3 |> Some
       let clauses, mLast = $4 mNextBar
       let m = unionRanges resultExpr.Range pat.Range
       fun mBar ->
           (SynMatchClause(pat, guard, resultExpr, m, DebugPointAtTarget.Yes, { ArrowRange = Some mArrow; BarRange = mBar }) :: clauses), mLast }

  | patternAndGuard error BAR patternClauses
     { let pat, guard = $1
       let mNextBar = rhs parseState 3 |> Some
       let clauses, mLast = $4 mNextBar
       let patm = pat.Range
       let m = guard |> Option.map (fun e -> unionRanges patm e.Range) |> Option.defaultValue patm
       fun _mBar ->
           (SynMatchClause(pat, guard, arbExpr ("patternClauses1", m.EndRange), m, DebugPointAtTarget.Yes, SynMatchClauseTrivia.Zero) :: clauses), mLast }

  | patternAndGuard patternResult BAR error 
     { let pat, guard = $1
       let mArrow, resultExpr = $2
       let mLast = rhs parseState 3 
       let m = unionRanges resultExpr.Range pat.Range
       fun mBar ->
           [SynMatchClause(pat, guard, resultExpr, m, DebugPointAtTarget.Yes, { ArrowRange = Some mArrow; BarRange = mBar })], mLast }

  | patternAndGuard patternResult error
     { let pat, guard = $1
       let mArrow, resultExpr = $2
       let m = unionRanges resultExpr.Range pat.Range
       fun mBar ->
           [SynMatchClause(pat, guard, resultExpr, m, DebugPointAtTarget.Yes, { ArrowRange = Some mArrow; BarRange = mBar })], m }

  | patternAndGuard error
     { let pat, guard = $1
       let patm = pat.Range
       let m = guard |> Option.map (fun e -> unionRanges patm e.Range) |> Option.defaultValue patm
       fun mBar ->
           [SynMatchClause(pat, guard, arbExpr ("patternClauses2", m.EndRange), m, DebugPointAtTarget.Yes, { ArrowRange = None; BarRange = mBar })], m }

patternGuard: 
  | WHEN declExpr 
     { Some $2 }

  | /* EMPTY */
     { None }

patternResult: 
  | RARROW typedSequentialExprBlockR  
     { let mArrow = rhs parseState 1
       mArrow, $2 }

ifExprCases: 
  | ifExprThen ifExprElifs 
      { let exprThen, mThen = $1
        let mElse, elseExpr = $2
        (fun exprGuard mIf isElif ->
            let mIfToThen = unionRanges mIf mThen
            let lastBranch : SynExpr = match elseExpr with None -> exprThen | Some e -> e
            let mIfToEndOfLastBranch = unionRanges mIf lastBranch.Range
            let spIfToThen = DebugPointAtBinding.Yes(mIfToThen)
            let trivia = { IfKeyword = mIf; IsElif = isElif; ThenKeyword = mThen; ElseKeyword = mElse; IfToThenRange = mIfToThen }
            SynExpr.IfThenElse (exprGuard, exprThen, elseExpr, spIfToThen, false, mIfToEndOfLastBranch, trivia)) }

ifExprThen: 
  | THEN  declExpr %prec prec_then_if 
      { $2, rhs parseState 1 }

  | OTHEN  OBLOCKBEGIN typedSequentialExpr oblockend %prec prec_then_if 
      { $3, rhs parseState 1 }

  | OTHEN  OBLOCKBEGIN typedSequentialExpr recover %prec prec_then_if 
      { if not $4 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileThen())
        exprFromParseError $3, rhs parseState 1 }

ifExprElifs: 
  | /* EMPTY */
      { None, None }

  | ELSE declExpr 
      { let mElse = rhs parseState 1
        Some mElse, Some $2 }

  | OELSE  OBLOCKBEGIN typedSequentialExpr oblockend 
      { let mElse = rhs parseState 1
        Some mElse, Some $3 }

  | OELSE  OBLOCKBEGIN typedSequentialExpr recover 
      { let mElse = rhs parseState 1
        if not $4 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileElse())
        Some mElse, Some (exprFromParseError $3) }

  | ELIF declExpr ifExprCases 
      { let mElif = rhs parseState 1
        // verify if `ELIF` is not a merged token
        let length = mElif.EndColumn - mElif.StartColumn
        if length > 4 then
            let mElse = mkRange mElif.FileName (mkPos mElif.StartLine mElif.StartColumn) (mkPos mElif.StartLine (mElif.StartColumn + 4))
            let mIf = mkRange mElif.FileName (mkPos mElif.StartLine (mElif.EndColumn - 2)) (mkPos mElif.StartLine mElif.EndColumn)
            Some mElse, (Some ($3 $2 mIf false))
        else
            None, Some ($3 $2 mElif true) }

  | ELIF declExpr recover 
      { None, Some (exprFromParseError $2) }

tupleExpr: 
  | tupleExpr COMMA declExpr   
      { let exprs, commas = $1 in ($3 :: exprs), ((rhs parseState 2) :: commas) }

  | tupleExpr COMMA ends_coming_soon_or_recover
      { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedExpressionAfterToken())
        let exprs, commas = $1     
        let zeroWidthAtNextToken = (rhs parseState 3).StartRange
        ((arbExpr("tupleExpr1", zeroWidthAtNextToken)) :: exprs), (rhs parseState 2) :: commas }

  | declExpr COMMA ends_coming_soon_or_recover
      { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedExpressionAfterToken())
        let zeroWidthAtNextToken = (rhs parseState 3).StartRange 
        ((arbExpr("tupleExpr2", zeroWidthAtNextToken)) :: [$1]), [rhs parseState 2] }

  | declExpr COMMA declExpr  
      { [$3 ; $1], [rhs parseState 2] }

minusExpr: 
  | MINUS minusExpr   %prec expr_prefix_plus_minus
      { mkSynPrefix (rhs parseState 1) (unionRanges (rhs parseState 1) $2.Range) "~-" $2 }

  | PLUS_MINUS_OP minusExpr  
      { if not (IsValidPrefixOperatorUse $1) then reportParseErrorAt $2.Range (FSComp.SR.parsInvalidPrefixOperator())
        mkSynPrefix (rhs parseState 1) (unionRanges (rhs parseState 1) $2.Range) ("~" + ($1)) $2 } 

  | ADJACENT_PREFIX_OP minusExpr 
      { if not (IsValidPrefixOperatorUse $1) then reportParseErrorAt $2.Range (FSComp.SR.parsInvalidPrefixOperator())
        mkSynPrefix (rhs parseState 1) (unionRanges (rhs parseState 1) $2.Range) ("~" + ($1)) $2 }

  | PERCENT_OP minusExpr
      { if not (IsValidPrefixOperatorUse $1) then reportParseErrorAt $2.Range (FSComp.SR.parsInvalidPrefixOperator())
        mkSynPrefix (rhs parseState 1) (unionRanges (rhs parseState 1) $2.Range) ("~" + ($1)) $2 }

  | AMP  minusExpr    
      { SynExpr.AddressOf (true, $2, rhs parseState 1, unionRanges (rhs parseState 1) $2.Range) } 

  | AMP_AMP  minusExpr   
      { SynExpr.AddressOf (false, $2, rhs parseState 1, unionRanges (rhs parseState 1) $2.Range) } 

  | NEW atomTypeNonAtomicDeprecated opt_HIGH_PRECEDENCE_APP atomicExprAfterType DOT atomicExprQualification 
      { errorR (Error (FSComp.SR.parsNewExprMemberAccess (), rhs parseState 6))
        let newExpr = SynExpr.New (false, $2, $4, unionRanges (rhs parseState 1) $4.Range)
        $6 newExpr (lhs parseState) (rhs parseState 5) }

  | NEW atomTypeNonAtomicDeprecated  opt_HIGH_PRECEDENCE_APP atomicExprAfterType 
      { SynExpr.New (false, $2, $4, unionRanges (rhs parseState 1) $4.Range) }

  | NEW atomTypeNonAtomicDeprecated opt_HIGH_PRECEDENCE_APP error   
      { SynExpr.New (false, $2, arbExpr("minusExpr", (rhs parseState 4)), unionRanges (rhs parseState 1) ($2).Range) }

  | NEW error
      { arbExpr("minusExpr2", (rhs parseState 1)) }

  | UPCAST  minusExpr 
      { SynExpr.InferredUpcast ($2, unionRanges (rhs parseState 1) $2.Range) }   

  | DOWNCAST  minusExpr 
      { SynExpr.InferredDowncast ($2, unionRanges (rhs parseState 1) $2.Range)}   

  | appExpr 
      { $1 }

appExpr:
  | appExpr argExpr %prec expr_app
      { SynExpr.App (ExprAtomicFlag.NonAtomic, false, $1, $2, unionRanges $1.Range $2.Range)  }

  | atomicExpr 
      { let arg, _ = $1 
        arg }

argExpr:
  | ADJACENT_PREFIX_OP atomicExpr 
      { let arg2, hpa2 = $2 
        if not (IsValidPrefixOperatorUse $1) then reportParseErrorAt arg2.Range (FSComp.SR.parsInvalidPrefixOperator())
        if hpa2 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsSuccessiveArgsShouldBeSpacedOrTupled())
        mkSynPrefix (rhs parseState 1) (unionRanges (rhs parseState 1) arg2.Range) ("~" + ($1)) arg2 }

   | atomicExpr 
      { let arg, hpa = $1 
        if hpa then reportParseErrorAt arg.Range (FSComp.SR.parsSuccessiveArgsShouldBeSpacedOrTupled())
        arg }
    
atomicExpr:
  | atomicExpr HIGH_PRECEDENCE_BRACK_APP atomicExpr
      { let arg1, _ = $1 
        let arg2, hpa = $3 
        SynExpr.App (ExprAtomicFlag.Atomic, false, arg1, arg2, unionRanges arg1.Range arg2.Range), hpa }

  | atomicExpr HIGH_PRECEDENCE_PAREN_APP atomicExpr
      { let arg1, _ = $1 
        let arg2, _ = $3 
        SynExpr.App (ExprAtomicFlag.Atomic, false, arg1, arg2, unionRanges arg1.Range arg2.Range), true  }

  | atomicExpr HIGH_PRECEDENCE_TYAPP typeArgsActual
      { let arg1, _ = $1 
        let mLessThan, mGreaterThan, _, args, commas, mTypeArgs = $3
        let mWholeExpr = unionRanges arg1.Range mTypeArgs
        SynExpr.TypeApp (arg1, mLessThan, args, commas, mGreaterThan, mTypeArgs, mWholeExpr), false }

  | PREFIX_OP atomicExpr  
      { let arg2, hpa2 = $2 
        if not (IsValidPrefixOperatorUse $1) then reportParseErrorAt arg2.Range (FSComp.SR.parsInvalidPrefixOperator())
        mkSynPrefixPrim (rhs parseState 1) (unionRanges (rhs parseState 1) arg2.Range) $1 arg2, hpa2 }

  | atomicExpr DOT atomicExprQualification 
      { let arg1, hpa1 = $1 
        $3 arg1 (lhs parseState) (rhs parseState 2), hpa1 }

  | BASE DOT atomicExprQualification 
      { let arg1 = SynExpr.Ident (ident("base", rhs parseState 1))
        $3 arg1 (lhs parseState) (rhs parseState 2), false }

  | QMARK nameop 
      { let (SynIdent(ident, trivia)) = $2
        SynExpr.LongIdent (true, SynLongIdent([ident], [], [trivia]), None, rhs parseState 2), false }

  | atomicExpr QMARK dynamicArg
      { let m = rhs2 parseState 1 3
        let mQmark = rhs parseState 2
        let arg1, hpa1 = $1
        SynExpr.Dynamic(arg1, mQmark, $3, m), hpa1 }

  | GLOBAL
      { let m = rhs parseState 1
        let ident = ident(MangledGlobalName, m)
        SynExpr.LongIdent(false, SynLongIdent([ident], [], [Some (IdentTrivia.OriginalNotation "global")]), None, m), false }

  | identExpr
      { $1, false }

  | LBRACK listExprElements RBRACK 
      { $2 (lhs parseState), false }

  | LBRACK listExprElements recover 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBracket()) 
        exprFromParseError ($2 (rhs2 parseState 1 2)), false }

  | LBRACK error RBRACK 
      { // silent recovery 
        SynExpr.ArrayOrList (false, [ ], lhs parseState), false  } 

  | LBRACK recover
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBracket()) 
        // silent recovery 
        exprFromParseError (SynExpr.ArrayOrList (false, [ ], rhs parseState 1)), false  } 

  | STRUCT LPAREN tupleExpr rparen
      { let exprs, commas = $3
        let m = rhs2 parseState 1 4
        SynExpr.Tuple (true, List.rev exprs, List.rev commas, m), false }

  | STRUCT LPAREN tupleExpr recover
      { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnmatchedBracket());
        let exprs, commas = $3
        let m = (rhs parseState 1, exprs) ||> unionRangeWithListBy (fun e -> e.Range)
        SynExpr.Tuple (true, List.rev exprs, List.rev commas, m), false }

  | atomicExprAfterType 
      { $1, false }

atomicExprQualification:
  | identOrOp 
      { let idm = rhs parseState 1 
        (fun e lhsm dotm -> mkSynDot dotm lhsm e $1) }

  | GLOBAL
      { (fun e lhsm dotm -> 
            reportParseErrorAt (rhs parseState 3) (FSComp.SR.nrGlobalUsedOnlyAsFirstName()) 
            let fixedLhsm = mkRange lhsm.FileName lhsm.Start dotm.End // previous lhsm is wrong after 'recover'
            mkSynDotMissing dotm fixedLhsm e) }

  | /* empty */
      { (fun e lhsm dotm -> 
            reportParseErrorAt dotm (FSComp.SR.parsMissingQualificationAfterDot()) 
            let fixedLhsm = mkRange lhsm.FileName lhsm.Start dotm.End // previous lhsm is wrong after 'recover'
            mkSynDotMissing dotm fixedLhsm e) }
  | recover 
      { (fun e lhsm dotm -> 
            reportParseErrorAt dotm (FSComp.SR.parsMissingQualificationAfterDot()) 
            let fixedLhsm = mkRange lhsm.FileName lhsm.Start dotm.End // previous lhsm is wrong after 'recover'
            // Include 'e' in the returned expression but throw it away
            SynExpr.DiscardAfterMissingQualificationAfterDot (e, fixedLhsm)) }
  | LPAREN COLON_COLON rparen DOT INT32  
      { (fun e lhsm dotm -> 
            if parseState.LexBuffer.ReportLibraryOnlyFeatures then libraryOnlyError(lhs parseState)
            SynExpr.LibraryOnlyUnionCaseFieldGet (e, mkSynCaseName lhsm opNameCons, (fst $5), lhsm)) }

  | LPAREN  typedSequentialExpr rparen  
      { let lpr = rhs parseState 1
        let rpr = rhs parseState 3
        (fun e lhsm dotm -> 
            // Check for expr.( * )
            // Note that "*" is parsed as an expression (it is allowed in "foo.[3,*]")
            match $2 with
            | SynExpr.IndexRange (None, opm, None, _m1, _m2, _) ->
                mkSynDot dotm lhsm e (SynIdent(ident(CompileOpName "*", opm), Some(IdentTrivia.OriginalNotationWithParen(lpr, "*", rpr))))
            | _ ->
                if parseState.LexBuffer.SupportsFeature LanguageFeature.MLCompatRevisions then
                    mlCompatError (FSComp.SR.mlCompatMultiPrefixTyparsNoLongerSupported()) (lhs parseState) 
                else
                    mlCompatWarning (FSComp.SR.parsParenFormIsForML()) (lhs parseState) 
                mkSynDotParenGet lhsm dotm e $2) }

  | LBRACK  typedSequentialExpr RBRACK
      { (fun e lhsm dotm -> mkSynDotBrackGet lhsm dotm e $2) }

  | LBRACK  typedSequentialExpr recover
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBracket()) 
        (fun e lhsm dotm -> exprFromParseError (mkSynDotBrackGet lhsm dotm e $2)) }

  | LBRACK  error RBRACK  
      { let mArg = rhs2 parseState 1 3
        (fun e lhsm dotm -> mkSynDotBrackGet lhsm dotm e (arbExpr("indexerExpr1", mArg))) }

  | LBRACK  recover
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBracket())
        let mArg = (rhs parseState 1).EndRange 
        (fun e lhsm dotm -> exprFromParseError (mkSynDotBrackGet lhsm dotm e (arbExpr("indexerExpr2", mArg)))) }

/* the start of atomicExprAfterType must not overlap with the valid postfix tokens of the type syntax, e.g. new List<T>(...) */
atomicExprAfterType:
  | constant 
      { SynExpr.Const (fst $1, snd $1) }

  | parenExpr 
      { $1 }

  | braceExpr 
      { $1 }

  | braceBarExpr 
      { $1 }

  | interpolatedString
      { let parts, synStringKind = $1
        SynExpr.InterpolatedString(parts, synStringKind, rhs parseState 1) }

  | NULL 
      { SynExpr.Null (lhs parseState) } 

  | FALSE  
      { SynExpr.Const (SynConst.Bool false, lhs parseState) } 

  | TRUE  
      { SynExpr.Const (SynConst.Bool true, lhs parseState) } 

  | quoteExpr
      { $1 }

  | arrayExpr
      { $1 }

  | beginEndExpr
      { $1 }
  
beginEndExpr:
  | BEGIN typedSequentialExpr END 
      { SynExpr.Paren ($2, rhs parseState 1, Some(rhs parseState 3), rhs2 parseState 1 3) } 

  | BEGIN typedSequentialExpr recover 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBegin()); exprFromParseError $2 } 

  | BEGIN error END 
      { (* silent recovery *) arbExpr("beginEndExpr", (lhs parseState))  } 

  | BEGIN END 
      { mkSynUnit (lhs parseState) } 

quoteExpr:
  | LQUOTE typedSequentialExpr RQUOTE 
      { if $1 <> $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsMismatchedQuote(fst $1))
        (SynExpr.Quote (mkSynIdGet (lhs parseState) (CompileOpName (fst $1)), snd $1, $2, false, lhs parseState)) } 

  | LQUOTE typedSequentialExpr recover 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatched(fst $1))  
        let mExpr = rhs2 parseState 1 2
        exprFromParseError (SynExpr.Quote (mkSynIdGet (lhs parseState) (CompileOpName (fst $1)), snd $1, $2, false, mExpr))  } 

  | LQUOTE error RQUOTE 
      { (* silent recovery *) SynExpr.Quote (mkSynIdGet (lhs parseState) (CompileOpName (fst $1)), snd $1, arbExpr("quoteExpr", (rhs parseState 2)), false, lhs parseState)  }  

  | LQUOTE recover 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatched(fst $1))
        exprFromParseError (SynExpr.Quote (mkSynIdGet (lhs parseState) (CompileOpName (fst $1)), snd $1, arbExpr("quoteExpr2", (rhs parseState 1).EndRange), false, rhs parseState 1))  }  

arrayExpr:
  | LBRACK_BAR arrayExprElements BAR_RBRACK 
      {  $2 (lhs parseState) } 

  | LBRACK_BAR arrayExprElements recover 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBracketBar()) 
        exprFromParseError ($2 (rhs2 parseState 1 2)) }

  | LBRACK_BAR error BAR_RBRACK 
      {  (* silent recovery *) SynExpr.ArrayOrList (true, [ ], lhs parseState) }  

  | LBRACK_BAR recover
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBracketBar())  
        (* silent recovery *) 
        exprFromParseError (SynExpr.ArrayOrList (true, [ ], rhs parseState 1)) }  

parenExpr:
  | LPAREN rparen 
      { SynExpr.Const (SynConst.Unit, (rhs2 parseState 1 2)) } 

  | LPAREN parenExprBody rparen
      { let m = rhs2 parseState 1 3
        SynExpr.Paren ($2 m, rhs parseState 1, Some(rhs parseState 3), m) }

  | LPAREN parenExprBody ends_other_than_rparen_coming_soon_or_recover
      { if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen())
        let lhsm = unionRangeWithPos (rhs parseState 1) (rhs parseState 2).End
        SynExpr.Paren (exprFromParseError ($2 lhsm), rhs parseState 1, None, lhsm) }

  | LPAREN error rparen 
      { // silent recovery
        SynExpr.Paren (arbExpr("parenExpr1", (rhs parseState 1).EndRange), (rhs parseState 1), Some(rhs parseState 3), (rhs2 parseState 1 3)) } 

  | LPAREN TYPE_COMING_SOON
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen())
        let lhsm = unionRangeWithPos (rhs parseState 1) (rhs parseState 2).Start
        arbExpr("parenExpr2tcs", lhsm) }

  | LPAREN MODULE_COMING_SOON
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen())
        let lhsm = unionRangeWithPos (rhs parseState 1) (rhs parseState 2).Start
        arbExpr("parenExpr2mcs", lhsm) }

  | LPAREN RBRACE_COMING_SOON
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen())
        let lhsm = unionRangeWithPos (rhs parseState 1) (rhs parseState 2).Start
        arbExpr("parenExpr2rbcs", lhsm) }

  | LPAREN OBLOCKEND_COMING_SOON 
      { let lparenRange = (rhs parseState 1)
        reportParseErrorAt lparenRange (FSComp.SR.parsUnmatchedParen())
        SynExpr.Paren(arbExpr("parenExpr2obecs", lparenRange.EndRange), lparenRange, None, lparenRange) }

  | LPAREN recover %prec prec_atomexpr_lparen_error 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen()) 
        arbExpr("parenExpr2", (lhs parseState))  }  

        // This is really what we should be doing, but it fails because param info expects the range of the expression
        // to extend all the way over the "recover", to the end of the file if necessary
        // 
        // let mLeftParen = rhs parseState 1
        //let lhsm = if $2 then unionRangeWithPos mLeftParen (rhs parseState 2).Start else mLeftParen
        //arbExpr("parenExpr2", lhsm)  }  

parenExprBody:
  | staticallyKnownHeadTypars COLON LPAREN classMemberSpfn rparen  typedSequentialExpr 
      { (fun m -> SynExpr.TraitCall ($1, $4, $6, m)) } /* disambiguate: x $a.id(x) */

  | typedSequentialExpr
      { (fun _m -> $1) } 

  | inlineAssemblyExpr 
      { $1 }

staticallyKnownHeadTypars:
  | staticallyKnownHeadTypar 
      { [$1] }

  | LPAREN staticallyKnownHeadTyparAlts rparen 
      { List.rev $2 }

staticallyKnownHeadTyparAlts:
  | staticallyKnownHeadTyparAlts OR staticallyKnownHeadTypar
      {$3 :: $1}

  | staticallyKnownHeadTypar
      { [$1] }

braceExpr:
  | LBRACE braceExprBody rbrace 
     {  let m, r = $2 in r (rhs2 parseState 1 3) }

  | LBRACE braceExprBody recover 
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBrace())  
       let m, r = $2 
       // Note, we can't use 'exprFromParseError' because the extra syntax node interferes with some syntax-directed transformations for computation expressions
       r (unionRanges (rhs parseState 1) m) }

  | LBRACE error rbrace 
     { // silent recovery 
       arbExpr("braceExpr", rhs2 parseState 1 3)  }  

  | LBRACE recover
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBrace())  
       // Note, we can't use 'exprFromParseError' because the extra syntax node interferes with some syntax-directed transformations for computation expressions
       SynExpr.Record (None, None, [], rhs parseState 1) }

  | LBRACE rbrace 
     {  let m = rhs2 parseState 1 2 
        SynExpr.Record (None, None, [], m) }

braceExprBody:
  | recdExpr 
     {  (lhs parseState), (fun m -> let a, b, c = $1 in SynExpr.Record (a, b, c, m)) }

  | objExpr 
     { $1 }

  | computationExpr 
     { $1 }

listExprElements: 
  | sequentialExpr
     { (fun lhsm -> SynExpr.ArrayOrListComputed (false, $1, lhsm)) }

  | 
     { (fun lhsm -> SynExpr.ArrayOrList (false, [ ], lhsm)) }

arrayExprElements: 
  | sequentialExpr
     { (fun lhsm -> SynExpr.ArrayOrListComputed (true, $1, lhsm)) }

  | 
     { (fun lhsm -> SynExpr.ArrayOrList (true, [ ], lhsm)) }

computationExpr: 
  | sequentialExpr
     { $1.Range, (fun lhsm -> SynExpr.ComputationExpr (false, $1, lhsm)) }

arrowThenExprR:
  | RARROW typedSequentialExprBlockR 
     { SynExpr.YieldOrReturn ((true, false), $2, unionRanges (rhs parseState 1) $2.Range) }

forLoopBinder: 
  | parenPattern IN declExpr 
     { ($1, $3, true, DebugPointAtInOrTo.Yes (rhs parseState 2)) }

  | parenPattern IN ends_coming_soon_or_recover
     { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedExpressionAfterToken())
       ($1, arbExpr("forLoopBinder", (rhs parseState 2)), false, DebugPointAtInOrTo.Yes (rhs parseState 2)) }

  | parenPattern ends_coming_soon_or_recover
     { if not $2 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsInOrEqualExpected())
       ($1, arbExpr("forLoopBinder2", (rhs parseState 1).EndRange), false, DebugPointAtInOrTo.Yes (rhs parseState 2)) }

forLoopRange: 
  | parenPattern EQUALS declExpr forLoopDirection declExpr 
      { let mEquals = rhs parseState 2
        let spTo = DebugPointAtInOrTo.Yes (rhs parseState 4)
        idOfPat parseState (rhs parseState 1) $1, Some mEquals, $3, $4, $5, spTo }

forLoopDirection: 
  | TO     { true } 

  | DOWNTO { false }

inlineAssemblyExpr:
  | HASH string opt_inlineAssemblyTypeArg optCurriedArgExprs  optInlineAssemblyReturnTypes HASH 
      { if parseState.LexBuffer.ReportLibraryOnlyFeatures then libraryOnlyWarning (lhs parseState)
        let (s, _), sm = $2, rhs parseState 2
        (fun m ->
            let ilInstrs = ParseAssemblyCodeInstructions s parseState.LexBuffer.ReportLibraryOnlyFeatures parseState.LexBuffer.LanguageVersion sm
            SynExpr.LibraryOnlyILAssembly (box ilInstrs, $3, List.rev $4, $5, m)) }

optCurriedArgExprs:
  | optCurriedArgExprs argExpr  %prec expr_args
      { $2 :: $1 }

  | /* EMPTY */
      { [] }

opt_atomicExprAfterType: 
  | /* EMPTY */
      { None }

  | atomicExprAfterType 
      { Some($1) }

opt_inlineAssemblyTypeArg:
  | /* EMPTY */
      { [] }

  | typeKeyword LPAREN typ rparen
      {  [$3] }

optInlineAssemblyReturnTypes:
  | /* EMPTY */
     { [] }

  | COLON typ 
     { [$2] }

  | COLON LPAREN rparen  
     {  [] }

recdExpr:
  | INHERIT atomTypeNonAtomicDeprecated opt_HIGH_PRECEDENCE_APP opt_atomicExprAfterType recdExprBindings opt_seps_recd
     { let arg = match $4 with None -> mkSynUnit (lhs parseState) | Some e -> e 
       let l = List.rev $5
       let dummyField = mkRecdField (SynLongIdent([], [], [])) // dummy identifier, it will be discarded
       let l = rebindRanges (dummyField, None, None) l $6 
       let (SynExprRecordField(_, _, _, inheritsSep)) = List.head l
       let bindings = List.tail l
       (Some ($2, arg, rhs2 parseState 2 4, inheritsSep, rhs parseState 1), None, bindings) }

  | recdExprCore
    { let a, b = $1 in (None, a, b) }

recdExprCore:
  | appExpr EQUALS declExprBlock recdExprBindings opt_seps_recd
     { match $1 with 
       | LongOrSingleIdent(false, (SynLongIdent _ as f), None, m) ->  
            let f = mkRecdField f
            let mEquals = rhs parseState 2
            let l = List.rev $4
            let l = rebindRanges (f, Some mEquals, Some $3) l $5
            (None, l)
       | _ -> raiseParseErrorAt (rhs parseState 2) (FSComp.SR.parsFieldBinding()) }

/*
    handles cases when identifier can start from the underscore
*/

  | UNDERSCORE
    { let m = rhs parseState 1
      reportParseErrorAt m (FSComp.SR.parsUnderscoreInvalidFieldName())
      reportParseErrorAt m (FSComp.SR.parsFieldBinding())
      let f = mkUnderscoreRecdField m
      (None, [ SynExprRecordField(f, None, None, None)  ]) }

  | UNDERSCORE EQUALS
    { let m = rhs parseState 1
      reportParseErrorAt m (FSComp.SR.parsUnderscoreInvalidFieldName())      
      let f = mkUnderscoreRecdField m
      let mEquals = rhs parseState 2
      reportParseErrorAt (rhs2 parseState 1 2) (FSComp.SR.parsFieldBinding())
      
      (None, [ SynExprRecordField(f, Some mEquals, None, None) ]) }

  | UNDERSCORE EQUALS declExprBlock recdExprBindings opt_seps_recd
    { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnderscoreInvalidFieldName())
      let f = mkUnderscoreRecdField (rhs parseState 1)
      let mEquals = rhs parseState 2
      let l = List.rev $4
      let l = rebindRanges (f, Some mEquals, Some $3) l $5
      (None, l) }

/* handles case like {x with}  */
  | appExpr WITH recdBinding recdExprBindings opt_seps_recd
     {  let l = List.rev $4
        let l = rebindRanges $3 l $5
        (Some ($1, (rhs parseState 2, None)), l) }

  | appExpr OWITH opt_seps_recd OEND
     { (Some ($1, (rhs parseState 2, None)), []) }

  | appExpr OWITH recdBinding recdExprBindings opt_seps_recd OEND
     {  let l = List.rev $4
        let l = rebindRanges $3 l $5
        (Some ($1, (rhs parseState 2, None)), l) }

opt_seps_recd:
  | seps_recd
     { Some $1 }

  | /* EMPTY */
     { None }

seps_recd:
  | OBLOCKSEP
     { (rhs parseState 1), None }

  | SEMICOLON
     { let m = (rhs parseState 1) in (m, Some m.End) }

  | SEMICOLON OBLOCKSEP
     { (rhs2 parseState 1 2), Some (rhs parseState 1).End }

  | OBLOCKSEP SEMICOLON
     { (rhs2 parseState 1 2), Some (rhs parseState 2).End }


/* identifier can start from the underscore */
pathOrUnderscore :
  | path
    { mkRecdField $1 }

  | UNDERSCORE 
    { let m = rhs parseState 1
      reportParseErrorAt m (FSComp.SR.parsUnderscoreInvalidFieldName())
      mkUnderscoreRecdField m }

recdExprBindings: 
  | recdExprBindings seps_recd recdBinding
     { ($3, Some $2) :: $1 }

  | /* EMPTY */
     { [] }

recdBinding:
  | pathOrUnderscore EQUALS declExprBlock
     { let mEquals = rhs parseState 2
       ($1, Some mEquals, Some $3) }

  | pathOrUnderscore EQUALS
     { let mEquals = rhs parseState 2
       reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsFieldBinding())
       ($1, Some mEquals, None) }

  | pathOrUnderscore EQUALS ends_coming_soon_or_recover
     { let mEquals = rhs parseState 2
       reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsFieldBinding())
       ($1, Some mEquals, None) }

  | pathOrUnderscore
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsFieldBinding())
       ($1, None, None) }

  | pathOrUnderscore ends_coming_soon_or_recover
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsFieldBinding())
       ($1, None, None) }

/* There is a minor conflict between
       seq { new ty() }  // sequence expression with one very odd 'action' expression
  and 
       { new ty() }   // object expression with no interfaces and no overrides
Hence we make sure the latter is not permitted by the grammar
*/
objExpr:
  | objExprBaseCall objExprBindings opt_OBLOCKSEP opt_objExprInterfaces
     { let mNewExpr = rhs parseState 1
       let fullRange = match $4 with [] -> (rhs parseState 1) | _ -> (rhs2 parseState 1 4)
       let mWithKwd, bindings, members = $2
       fullRange, (fun m -> let (a, b) = $1 in SynExpr.ObjExpr (a, b, Some mWithKwd, bindings, members, $4, mNewExpr, m)) }

  | objExprBaseCall opt_OBLOCKSEP objExprInterfaces
     { let mNewExpr = rhs parseState 1 
       let fullRange = match $3 with [] -> (rhs parseState 1) | _ -> (rhs2 parseState 1 3)
       fullRange, (fun m -> let (a, b) = $1 in SynExpr.ObjExpr (a, b, None, [], [], $3, mNewExpr, m)) }

  | NEW atomTypeNonAtomicDeprecated
     { let mNewExpr = rhs parseState 1 
       (rhs2 parseState 1 2), (fun m -> let (a, b) = $2, None in SynExpr.ObjExpr (a, b, None, [], [], [], mNewExpr, m)) }

objExprBaseCall:
  | NEW atomTypeNonAtomicDeprecated  opt_HIGH_PRECEDENCE_APP atomicExprAfterType baseSpec
     { ($2, Some($4, Some($5))) }

  | NEW atomTypeNonAtomicDeprecated  opt_HIGH_PRECEDENCE_APP atomicExprAfterType 
     { ($2, Some($4, None)) }

  | NEW atomTypeNonAtomicDeprecated
     { $2, None }
 


opt_objExprBindings: 
  | objExprBindings
     { let mWithKwd, bindings, members = $1 in Some mWithKwd, bindings, members }

  | /* EMPTY */
     { None, [], [] }

objExprBindings: 
  | WITH localBindings 
      { let mWithKwd = (rhs parseState 1)
        let _localBindingsLastRange, localBindingsBuilder = $2 
        mWithKwd, (localBindingsBuilder PreXmlDoc.Empty [] None mWithKwd), [] }

  | OWITH localBindings OEND
      { let mWithKwd = (rhs parseState 1)
        let _localBindingsLastRange, localBindingsBuilder = $2 
        mWithKwd, (localBindingsBuilder PreXmlDoc.Empty [] None mWithKwd), [] }

  | WITH objectImplementationBlock opt_declEnd
      { let mWithKwd = rhs parseState 1
        let memberDefns =
            $2 |> 
            (List.choose (function 
                              | SynMemberDefn.Member _ as memberDefn -> Some memberDefn
                              | SynMemberDefn.AutoProperty(range = m) -> errorR(Error(FSComp.SR.parsIllegalMemberVarInObjectImplementation(), m)); None
                              | x -> errorR(Error(FSComp.SR.parsMemberIllegalInObjectImplementation(), x.Range)); None)) 
        mWithKwd, [], memberDefns }

objExprInterfaces:
  | objExprInterface opt_objExprInterfaces { $1 :: $2 }

opt_objExprInterfaces:
  | %prec prec_interfaces_prefix 
     { [] }

  | objExprInterface opt_objExprInterfaces 
     { $1 :: $2 }

  | error opt_objExprInterfaces 
     { (* silent recovery *) $2 }

objExprInterface:
  | interfaceMember appType opt_objExprBindings opt_declEnd opt_OBLOCKSEP
    { let mWithKwd, bindings, members = $3
      SynInterfaceImpl($2, mWithKwd, bindings, members, lhs parseState) }

braceBarExpr:
  | STRUCT braceBarExprCore
      { $2 true }

  | braceBarExprCore
      { $1 false }

braceBarExprCore:
  | LBRACE_BAR recdExprCore bar_rbrace
     { let orig, flds = $2
       let flds = 
           flds |> List.choose (function 
             | SynExprRecordField((SynLongIdent([id], _, _), _), mEquals, Some e, _) -> Some (id, mEquals, e) 
             | SynExprRecordField((SynLongIdent([id], _, _), _), mEquals, None, _) -> Some (id, mEquals, arbExpr("anonField", id.idRange)) 
             | _ -> reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsInvalidAnonRecdType()); None) 
       let m = rhs2 parseState 1 3
       (fun isStruct -> SynExpr.AnonRecd (isStruct, orig, flds, m)) }

  | LBRACE_BAR recdExprCore recover 
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBraceBar())  
       let orig, flds = $2 
       let flds = 
           flds |> List.choose (function 
             | SynExprRecordField((SynLongIdent([id], _, _), _), mEquals, Some e, _) -> Some (id, mEquals, e) 
             | SynExprRecordField((SynLongIdent([id], _, _), _), mEquals, None, _) -> Some (id, mEquals, arbExpr("anonField", id.idRange)) 
             | _ -> reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsInvalidAnonRecdType()); None) 
       let m = rhs2 parseState 1 2
       (fun isStruct -> SynExpr.AnonRecd (isStruct, orig, flds, m)) }

  | LBRACE_BAR error bar_rbrace
     { // silent recovery 
       let m = rhs2 parseState 1 3
       (fun _ -> arbExpr("braceBarExpr", m)) }  

  | LBRACE_BAR recover
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBraceBar())  
       let m = rhs2 parseState 1 1
       (fun isStruct -> SynExpr.AnonRecd (isStruct, None, [], m)) }

  | LBRACE_BAR bar_rbrace 
     { let m = rhs2 parseState 1 2
       (fun isStruct -> SynExpr.AnonRecd (isStruct, None, [], m)) }

anonLambdaExpr: 
  | FUN atomicPatterns RARROW typedSequentialExprBlock 
     { let mAll = unionRanges (rhs parseState 1) $4.Range
       let mArrow = Some (rhs parseState 3)
       mkSynFunMatchLambdas parseState.SynArgNameGenerator false mAll $2 mArrow $4 }

  | FUN atomicPatterns RARROW error
     { let mAll = rhs2 parseState 1 3
       let mArrow = Some (rhs parseState 3)
       mkSynFunMatchLambdas parseState.SynArgNameGenerator false mAll $2 mArrow (arbExpr("anonLambdaExpr1", (rhs parseState 4))) }

  | OFUN atomicPatterns RARROW typedSequentialExprBlockR OEND
     { let mAll = unionRanges (rhs parseState 1) $4.Range
       let mArrow = Some (rhs parseState 3)
       mkSynFunMatchLambdas parseState.SynArgNameGenerator false mAll $2 mArrow $4 }

  | OFUN atomicPatterns RARROW typedSequentialExprBlockR recover
     { if not $5 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFunBody());
       let mAll = unionRanges (rhs parseState 1) $4.Range
       let mArrow = Some (rhs parseState 3)
       exprFromParseError (mkSynFunMatchLambdas parseState.SynArgNameGenerator false mAll $2 mArrow $4) }

  | OFUN atomicPatterns RARROW ORIGHT_BLOCK_END OEND
     { let mLambda = rhs2 parseState 1 3
       reportParseErrorAt mLambda (FSComp.SR.parsMissingFunctionBody())
       let mArrow = Some (rhs parseState 3)
       mkSynFunMatchLambdas parseState.SynArgNameGenerator false mLambda $2 mArrow (arbExpr("anonLambdaExpr2", mLambda.EndRange)) }

  | OFUN atomicPatterns RARROW recover
     { if not $4 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFunBody())
       let mLambda = rhs2 parseState 1 3
       let mArrow = Some (rhs parseState 3)
       exprFromParseError (mkSynFunMatchLambdas parseState.SynArgNameGenerator false mLambda $2 mArrow (arbExpr("anonLambdaExpr3", mLambda.EndRange))) }

  | OFUN atomicPatterns error OEND
     { let mLambda = rhs2 parseState 1 2
       exprFromParseError (mkSynFunMatchLambdas parseState.SynArgNameGenerator false mLambda $2 None (arbExpr("anonLambdaExpr4", mLambda.EndRange))) }

  | OFUN error OEND
     { exprFromParseError (mkSynFunMatchLambdas parseState.SynArgNameGenerator false (rhs parseState 1) [] None (arbExpr("anonLambdaExpr5", (rhs parseState 2)))) }

anonMatchingExpr: 
  | FUNCTION withPatternClauses %prec expr_function
     { let clauses, mLast = $2
       let mAll = unionRanges (rhs parseState 1) mLast
       SynExpr.MatchLambda (false, (rhs parseState 1), clauses, DebugPointAtBinding.NoneAtInvisible, mAll) }

  | OFUNCTION withPatternClauses OEND %prec expr_function
     { let clauses, mLast = $2
       let mAll = unionRanges (rhs parseState 1) mLast
       SynExpr.MatchLambda (false, (rhs parseState 1), clauses, DebugPointAtBinding.NoneAtInvisible, mAll) }

/*--------------------------------------------------------------------------*/
/* TYPE ALGEBRA                                                             */

typeWithTypeConstraints:
  | typ %prec prec_wheretyp_prefix 
     { $1 }

  | typ WHEN typeConstraints 
     { SynType.WithGlobalConstraints($1, List.rev $3, lhs parseState) }

topTypeWithTypeConstraints: 
  | topType 
     { $1 }

  | topType WHEN typeConstraints 
     { let ty, arity = $1 
       // nb. it doesn't matter where the constraints go in the structure of the type. 
       SynType.WithGlobalConstraints(ty, List.rev $3, lhs parseState), arity }

opt_topReturnTypeWithTypeConstraints: 
  |             
     { None } 

  | COLON topTypeWithTypeConstraints 
     { let ty, arity = $2 
       let arity = (match arity with SynValInfo([], rmdata)-> rmdata | _ -> SynInfo.unnamedRetVal)
       Some (SynReturnInfo((ty, arity), rhs parseState 2)) }

topType: 
  | topTupleType RARROW topType 
     { let dty, dmdata= $1 
       let rty, (SynValInfo(dmdatas, rmdata)) = $3 
       SynType.Fun(dty, rty, lhs parseState), (SynValInfo(dmdata :: dmdatas, rmdata)) }

  | topTupleType 
     { let ty, rmdata = $1 in ty, (SynValInfo([], (match rmdata with [md] -> md | _ -> SynInfo.unnamedRetVal))) }

topTupleType:
  | topAppType STAR topTupleTypeElements 
     { let ty, mdata = $1 in let tys, mdatas = List.unzip $3 in (SynType.Tuple(false, List.map (fun ty -> (false, ty)) (ty :: tys), lhs parseState)), (mdata :: mdatas) }

  | topAppType                 
     { let ty, mdata = $1 in ty, [mdata] }

topTupleTypeElements:
  | topAppType STAR topTupleTypeElements       
     { $1 :: $3 }

  | topAppType %prec prec_toptuptyptail_prefix 
     { [$1] }

topAppType:
  | attributes appType COLON appType 
     { match $2 with 
       | SynType.LongIdent(SynLongIdent([id], _, _)) -> $4, SynArgInfo($1, false, Some id)
       | _ -> raiseParseErrorAt (rhs parseState 2) (FSComp.SR.parsSyntaxErrorInLabeledType())  }

  | attributes QMARK ident COLON appType 
     { $5, SynArgInfo($1, true, Some $3) }

  | attributes appType 
     { ($2, SynArgInfo($1, false, None)) }

  | appType COLON appType 
     { match $1 with 
       | SynType.LongIdent(SynLongIdent([id], _, _)) -> $3, SynArgInfo([], false, Some id)
       | _ -> raiseParseErrorAt (rhs parseState 2) (FSComp.SR.parsSyntaxErrorInLabeledType())  }

  | QMARK ident COLON appType 
     { $4, SynArgInfo([], true, Some $2) }

  | appType 
     { $1, SynArgInfo([], false, None) }

/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */
/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */
typ:
  | tupleType RARROW typ  
     { SynType.Fun($1, $3, lhs parseState) }

  | tupleType %prec prec_typ_prefix 
     { $1 }

typEOF:
  | typ EOF { checkEndOfFileError $2; $1 }


tupleType:
  | appType STAR tupleOrQuotTypeElements 
    { SynType.Tuple(false, (false, $1) :: $3, lhs parseState) }

  | INFIX_STAR_DIV_MOD_OP tupleOrQuotTypeElements
    { if $1 <> "/" then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedInfixOperator());
      SynType.Tuple(false, (true, SynType.StaticConstant (SynConst.Int32 1, lhs parseState)) :: $2, lhs parseState) }

  | appType INFIX_STAR_DIV_MOD_OP tupleOrQuotTypeElements
    { if $2 <> "/" then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedInfixOperator());
      SynType.Tuple(false, (true, $1) :: $3, lhs parseState) }

  | appType %prec prec_tuptyp_prefix 
    { $1 }

tupleOrQuotTypeElements:
  | appType STAR tupleOrQuotTypeElements              
    { (false, $1) :: $3 }

  | appType INFIX_STAR_DIV_MOD_OP tupleOrQuotTypeElements 
    { if $2 <> "/" then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedInfixOperator());
      (true, $1) :: $3 }

  | appType %prec prec_tuptyptail_prefix 
    { [(false, $1)] }

appTypeCon:
  | path %prec prec_atomtyp_path 
    { SynType.LongIdent($1) }

  | typar 
    { SynType.Var($1, lhs parseState) }

appTypeConPower:
  | appTypeCon INFIX_AT_HAT_OP atomicRationalConstant
    { if $2 <> "^" && $2 <> "^-" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedInfixOperator());
      if $2 = "^-" then SynType.MeasurePower($1, SynRationalConst.Negate($3), lhs parseState)
      else SynType.MeasurePower($1, $3, lhs parseState)  }

  | appTypeCon 
    { $1 }

appType:
  | appType arrayTypeSuffix 
      {  SynType.Array($2, $1, lhs parseState) }

  | appType HIGH_PRECEDENCE_BRACK_APP arrayTypeSuffix   /* only HPA for "name[]" allowed here */
      {  SynType.Array($3, $1, lhs parseState) }

  | appType appTypeConPower  
      /* note: use "rhs parseState 1" to deal with parens in "(int) list" */
      { SynType.App($2, None, [$1], [], None, true, unionRanges (rhs parseState 1) $2.Range) }

  | LPAREN appTypePrefixArguments rparen  appTypeConPower
      { let args, commas = $2
        if parseState.LexBuffer.SupportsFeature LanguageFeature.MLCompatRevisions then
            mlCompatError (FSComp.SR.mlCompatMultiPrefixTyparsNoLongerSupported()) (unionRanges (rhs parseState 1) $4.Range)
        else
            mlCompatWarning (FSComp.SR.parsMultiArgumentGenericTypeFormDeprecated()) (unionRanges (rhs parseState 1) $4.Range)
        SynType.App($4, None, args, commas, None, true, unionRanges (rhs parseState 1) $4.Range) }

  | powerType 
      { $1 }

  | typar COLON_GREATER typ                     
      {  let tp, typ = $1, $3 
         let m = lhs parseState 
         SynType.WithGlobalConstraints(SynType.Var (tp, rhs parseState 1), [SynTypeConstraint.WhereTyparSubtypeOfType(tp, typ, m)], m)  }

  | UNDERSCORE COLON_GREATER typ %prec COLON_GREATER 
      {  SynType.HashConstraint($3, lhs parseState) }

arrayTypeSuffix:
  | LBRACK RBRACK 
      { 1 }

  | LBRACK COMMA RBRACK 
      { 2 }

  | LBRACK COMMA COMMA RBRACK 
      { 3 }

  | LBRACK COMMA COMMA COMMA RBRACK 
      { 4 }

appTypePrefixArguments:
  | typeArgActual COMMA typeArgActual typeArgListElements 
      { let typeArgs, commas = $4 in $1 :: $3 :: List.rev typeArgs, (rhs parseState 2) :: (List.rev commas) }

typeArgListElements: 
  | typeArgListElements COMMA typeArgActual
      { let typeArgs, commas = $1
        $3 :: typeArgs, (rhs parseState 2) :: commas } 

  | typeArgListElements COMMA dummyTypeArg %prec prec_args_error  /* NOTE: no "recover" */
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsMissingTypeArgs())
       let typeArgs, commas = $1
       $3 :: typeArgs, (rhs parseState 2) :: commas } 

  |   
      { [], [] }

powerType:
  | atomTypeOrAnonRecdType
    { $1 }

  | atomTypeOrAnonRecdType INFIX_AT_HAT_OP atomicRationalConstant
     { if $2 <> "^" && $2 <> "^-" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedInfixOperator());
       if $2 = "^-" then SynType.MeasurePower($1, SynRationalConst.Negate($3), lhs parseState)
       else SynType.MeasurePower($1, $3, lhs parseState) }


/* Like appType but gives a deprecation error when a non-atomic type is used */
/* Also, doesn't start with '{|'  */
atomTypeNonAtomicDeprecated:
  | LPAREN appTypePrefixArguments rparen  appTypeConPower
      { let args, commas = $2
        if parseState.LexBuffer.SupportsFeature LanguageFeature.MLCompatRevisions then
            mlCompatError (FSComp.SR.mlCompatMultiPrefixTyparsNoLongerSupported()) (unionRanges (rhs parseState 1) $4.Range)
        else
            mlCompatWarning (FSComp.SR.parsMultiArgumentGenericTypeFormDeprecated()) (unionRanges (rhs parseState 1) $4.Range)
        SynType.App($4, None, args, commas, None, true, unionRanges (rhs parseState 1) $4.Range) }

  | atomType
      { $1 }

atomTypeOrAnonRecdType:
  | atomType
     { $1 }

  | anonRecdType
     { let flds, isStruct = $1
       let flds2 = 
           flds |> List.choose (function 
             | (SynField([], false, Some id, ty, false, _xmldoc, None, _m)) -> Some (id, ty) 
             | _ -> reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsInvalidAnonRecdType()); None)
       SynType.AnonRecd (isStruct, flds2, rhs parseState 1) }  

/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */
/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */
atomType:
  | HASH atomType 
     { SynType.HashConstraint($2, lhs parseState) }

  | appTypeConPower %prec prec_atomtyp_path 
     { $1 }

  | UNDERSCORE 
     { SynType.Anon (lhs parseState) }

  | LPAREN typ rparen
     { SynType.Paren ($2, lhs parseState) }

  | LPAREN typ recover
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen ())
       SynType.Paren ($2, lhs parseState) }

  | STRUCT LPAREN appType STAR tupleOrQuotTypeElements  rparen 
    { SynType.Tuple(true, (false, $3) :: $5, lhs parseState) }

  | STRUCT LPAREN appType STAR tupleOrQuotTypeElements  recover
    { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnmatchedParen()) 
      SynType.Tuple(true, (false, $3) :: $5, lhs parseState) }

  | STRUCT LPAREN appType STAR recover
    { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnmatchedParen()) 
      SynType.Anon (lhs parseState) }

  | STRUCT LPAREN appType recover
    { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnmatchedParen()) 
      SynType.Anon (lhs parseState) }

  | STRUCT LPAREN recover
    { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnmatchedParen()) 
      SynType.Anon (lhs parseState) }

  | rawConstant 
     { SynType.StaticConstant($1, rhs parseState 1) }

  | NULL
     { let m = rhs parseState 1
       SynType.StaticConstant(SynConst.String (null, SynStringKind.Regular, m), m) }

  | CONST atomicExpr
     {  let e, _ = $2
        SynType.StaticConstantExpr(e, lhs parseState) }

  | FALSE  
      { SynType.StaticConstant(SynConst.Bool false, lhs parseState) } 

  | TRUE  
      { SynType.StaticConstant(SynConst.Bool true, lhs parseState) } 

  | LPAREN error rparen   
     { (* silent recovery *) SynType.Anon (lhs parseState) }  

  | appTypeCon typeArgsNoHpaDeprecated %prec prec_atomtyp_path 
     { let mLessThan, mGreaterThan, args, commas, mWhole = $2 in SynType.App($1, Some(mLessThan), args, commas, mGreaterThan, false, unionRanges $1.Range mWhole) } 

  | atomType DOT path %prec prec_atomtyp_get_path 
     { SynType.LongIdentApp($1, $3, None, [], [], None, unionRanges (rhs parseState 1) $3.Range) } 

  | atomType DOT path typeArgsNoHpaDeprecated %prec prec_atomtyp_get_path 
     { let mLessThan, mGreaterThan, args, commas, mWhole = $4 
       SynType.LongIdentApp($1, $3, Some(mLessThan), args, commas, mGreaterThan, unionRanges $1.Range mWhole) } 

  | appTypeCon DOT ends_coming_soon_or_recover
     { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedNameAfterToken())
       $1 } 

typeArgsNoHpaDeprecated:
  | typeArgsActual
     { let mLessThan, mGreaterThan, parsedOk, args, commas, mAll = $1
       if parsedOk then // if someone has "foo<bar" without a closing greater-than, then the lexfilter does not introduce a HPA, even though it is adjacent
           warning(Error(FSComp.SR.parsNonAdjacentTyargs(), rhs parseState 1))
       mLessThan, mGreaterThan, args, commas, mAll } 

  | HIGH_PRECEDENCE_TYAPP typeArgsActual 
     { let mLessThan, mGreaterThan, _, args, commas, mAll = $2
       mLessThan, mGreaterThan, args, commas, mAll } 

typeArgsActual:
  | LESS typeArgActualOrDummyIfEmpty COMMA typeArgActualOrDummyIfEmpty typeArgListElements GREATER 
     { let typeArgs, commas = $5
       (rhs parseState 1), Some(rhs parseState 6), true, ($2 :: $4 :: List.rev typeArgs), (rhs parseState 3) :: (List.rev commas), lhs parseState } 

  | LESS typeArgActualOrDummyIfEmpty COMMA typeArgActualOrDummyIfEmpty typeArgListElements recover
     { if not $6 then 
           reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileTypeArgs())
       else
           reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsMissingGreaterThan())
       let typeArgs, commas = $5
       let nextToken = rhs parseState 6
       let zeroWidthAtStartOfNextToken = nextToken.StartRange
       (rhs parseState 1), None, false, ($2 :: $4 :: List.rev typeArgs), (rhs parseState 3) :: (List.rev commas), unionRanges (rhs parseState 1) zeroWidthAtStartOfNextToken } 

  | LESS typeArgActualOrDummyIfEmpty COMMA ends_coming_soon_or_recover
     { if not $4 then reportParseErrorAt (rhs parseState 4) (FSComp.SR.parsMissingTypeArgs())
       let nextToken = rhs parseState 4
       let zeroWidthAtStartOfNextToken = nextToken.StartRange
       (rhs parseState 1), None, false, [$2], [rhs parseState 3], unionRanges (rhs parseState 1) zeroWidthAtStartOfNextToken } 

  | LESS typeArgActual GREATER 
     { (rhs parseState 1), Some(rhs parseState 3), true, [$2], [], lhs parseState } 

  | LESS typeArgActual ends_coming_soon_or_recover
     { let nextToken = rhs parseState 3
       if not $3 then reportParseErrorAt nextToken (FSComp.SR.parsMissingTypeArgs())
       let zeroWidthAtStartOfNextToken = nextToken.StartRange
       (rhs parseState 1), None, false, [$2], [], unionRanges (rhs parseState 1) zeroWidthAtStartOfNextToken } 

  | LESS GREATER 
     { (rhs parseState 1), Some(rhs parseState 2), true, [], [], lhs parseState } 

  | LESS recover
     { if not $2 then  
           reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsExpectedTypeAfterToken())
       else
           reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsMissingTypeArgs())
       let nextToken = rhs parseState 2
       let zeroWidthAtStartOfNextToken = nextToken.StartRange
       (rhs parseState 1), None, false, [], [], unionRanges (rhs parseState 1) zeroWidthAtStartOfNextToken } 

typeArgActual:
  | typ
     { $1 }

  | typ EQUALS typ
     { SynType.StaticConstantNamed($1, $3, unionRanges $1.Range $3.Range) }

  | typ EQUALS /* NOTE: no "recover" */
     { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsMissingTypeArgs())
       let dummy = SynType.StaticConstant(SynConst.Int32(0), rhs parseState 2)
       SynType.StaticConstantNamed($1, dummy, (rhs2 parseState 1 2))
     }

typeArgActualOrDummyIfEmpty:
  | typeArgActual
     { $1 }

  | dummyTypeArg
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsMissingTypeArgs())
       $1 }

dummyTypeArg:
  |  /* EMPTY */
     { let m = rhs parseState 1
       let dummyStatVal = SynType.StaticConstant(SynConst.Int32(0), m)
       let dummyName = SynType.LongIdent(SynLongIdent([ident("", m)], [], [None]))
       let dummyTypeArg = SynType.StaticConstantNamed(dummyName, dummyStatVal, m)
       dummyTypeArg }

measureTypeArg:
  | LESS measureTypeExpr GREATER
     { $2 }

  | LESS UNDERSCORE GREATER
     { SynMeasure.Anon (lhs parseState) }

measureTypeAtom:
  | path 
     { SynMeasure.Named($1.LongIdent, $1.Range) }

  | typar 
     { SynMeasure.Var($1, lhs parseState) }

  | LPAREN measureTypeExpr rparen
     { let mParen = rhs2 parseState 1 3
       SynMeasure.Paren($2, mParen) }

measureTypePower:
  | measureTypeAtom 
      { $1 }

  | measureTypeAtom INFIX_AT_HAT_OP atomicRationalConstant
     { if $2 <> "^" && $2 <> "^-" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure());
       if $2 = "^-" then SynMeasure.Power($1, SynRationalConst.Negate($3), lhs parseState)
       else SynMeasure.Power($1, $3, lhs parseState) }

  | INT32
     { if fst $1 <> 1 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedIntegerLiteralForUnitOfMeasure());
       SynMeasure.One }

measureTypeSeq:
  | measureTypePower
    { [$1] }

  | measureTypePower measureTypeSeq
    { $1 :: $2 }

measureTypeExpr:
  | measureTypeSeq
    { SynMeasure.Seq($1, lhs parseState) }

  | measureTypeExpr STAR measureTypeExpr
    { SynMeasure.Product($1, $3, lhs parseState) }

  | measureTypeExpr INFIX_STAR_DIV_MOD_OP measureTypeExpr
    { if $2 <> "*" && $2 <> "/" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure());
      if $2 = "*" then SynMeasure.Product($1, $3, lhs parseState)
      else SynMeasure.Divide($1, $3, lhs parseState) }

  | INFIX_STAR_DIV_MOD_OP measureTypeExpr
     { if $1 <> "/" then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure());
       SynMeasure.Divide(SynMeasure.One, $2, lhs parseState) }
   
typar: 
  | QUOTE ident 
     {  let id = mkSynId (lhs parseState) ($2).idText
        SynTypar(id, TyparStaticReq.None, false) }

  | staticallyKnownHeadTypar 
     { $1 }

staticallyKnownHeadTypar: 
  | INFIX_AT_HAT_OP ident 
    {  if $1 <> "^" then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedTypeParameter());
       let id = mkSynId (lhs parseState) ($2).idText
       SynTypar(id, TyparStaticReq.HeadType, false) }

ident: 
  | IDENT 
     { ident($1, rhs parseState 1) } 

/* A A.B.C path used to an identifier */
path: 
  | GLOBAL
      { SynLongIdent([ident(MangledGlobalName, rhs parseState 1)], [], [None]) }

  | ident  
     { SynLongIdent([$1], [], [None]) }

  | path DOT ident  
     { let (SynLongIdent(lid, dotms, trivia)) = $1 in SynLongIdent(lid @ [$3], dotms @ [rhs parseState 2], trivia @ [None]) } 

  | path DOT ends_coming_soon_or_recover  
     { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedNameAfterToken())
       let (SynLongIdent(lid, dotms, trivia)) = $1 in SynLongIdent(lid, dotms @ [rhs parseState 2], trivia)  } 


/* An operator name, with surrounding parentheses */
opName: 
  | LPAREN operatorName rparen  
     { let lpr = rhs parseState 1
       let rpr = rhs parseState 3
       ident(CompileOpName $2, rhs parseState 2), IdentTrivia.OriginalNotationWithParen(lpr, $2, rpr) }

  | LPAREN error rparen  
     {  reportParseErrorAt (lhs parseState) (FSComp.SR.parsErrorParsingAsOperatorName())
        let lpr = rhs parseState 1
        let rpr = rhs parseState 3
        ident(CompileOpName "****", rhs parseState 2), IdentTrivia.HasParenthesis(lpr, rpr) }

  | LPAREN_STAR_RPAREN
     { let m = rhs parseState 1
       let lpr = mkFileIndexRange m.FileIndex m.Start m.Start
       let rpr = mkFileIndexRange m.FileIndex m.End m.End
       ident(CompileOpName "*", rhs parseState 1), IdentTrivia.OriginalNotationWithParen(lpr, "*", rpr) }

  /* active pattern name */
  | LPAREN activePatternCaseNames BAR rparen 
     { let lpr = rhs parseState 1
       let text = ("|" + String.concat "|" (List.rev $2) + "|")
       let rpr = rhs parseState 4
       ident(text, rhs2 parseState 2 3), IdentTrivia.HasParenthesis(lpr, rpr) }
                         
  /* partial active pattern name */
  | LPAREN activePatternCaseNames BAR UNDERSCORE BAR rparen 
     { let lpr = rhs parseState 1
       let text = ("|" + String.concat "|" (List.rev $2) + "|_|" )
       let rpr = rhs parseState 6
       ident(text, rhs2 parseState 2 5), IdentTrivia.HasParenthesis(lpr, rpr) }

/* An operator name, without surrounding parentheses */
operatorName: 
  | PREFIX_OP 
     { if not (IsValidPrefixOperatorDefinitionName $1) then 
           reportParseErrorAt (lhs parseState) (FSComp.SR.parsInvalidPrefixOperatorDefinition());
       $1 }

  | INFIX_STAR_STAR_OP
     { $1 }

  | INFIX_COMPARE_OP
     { $1 }

  | INFIX_AT_HAT_OP
     { $1 }

  | INFIX_BAR_OP
     { $1 }

  | INFIX_AMP_OP
     { $1 }

  | PLUS_MINUS_OP
     { $1 }

  | INFIX_STAR_DIV_MOD_OP
     { $1 }

  | DOLLAR
     { "$" }

  | ADJACENT_PREFIX_OP
     { $1 }

  | MINUS
     { "-" }

  | STAR
     { "*" }

  | EQUALS
     { "=" }

  | OR
     { "or" }

  | LESS
     { "<" }

  | GREATER
     { ">" }

  | QMARK
     { "?" }

  | AMP
     { "&" }

  | AMP_AMP
     { "&&" }

  | BAR_BAR
     { "||" }

  | COLON_EQUALS
     { ":=" }

  | FUNKY_OPERATOR_NAME 
     { if $1 <> ".[]"  && $1 <> ".()" && $1 <> ".()<-" then 
            deprecatedOperator (lhs parseState); 
       $1 }

  | PERCENT_OP
     { $1 }

  | DOT_DOT
     { ".." }

  | DOT_DOT DOT_DOT
     { ".. .." }

  | LQUOTE RQUOTE 
     { if $1 <> $2 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsMismatchedQuotationName(fst $1));  
       fst $1 } 

/* One part of an active pattern name */
activePatternCaseName: 
  | IDENT
     { if not (String.isLeadingIdentifierCharacterUpperCase _1) then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsActivePatternCaseMustBeginWithUpperCase());  
       if ($1.IndexOf('|') <> -1) then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsActivePatternCaseContainsPipe());  
       $1 }

/* Multiple parts of an active pattern name */
activePatternCaseNames: 
  | BAR activePatternCaseName
     { [$2] }

  | activePatternCaseNames BAR activePatternCaseName
     { $3 :: $1 }

/* A single item that is an identifier or operator name */
identOrOp: 
  | ident  
     { SynIdent($1, None) } 

  | opName 
     { let ident, trivia = $1
       SynIdent(ident, Some trivia) }

/* An A.B.C path ending in an identifier or operator name */
/* Note, only used in atomicPatternLongIdent */
pathOp: 
  | ident  
     { SynLongIdent([$1], [], [None]) }

  | opName 
     { let ident, trivia = $1
       SynLongIdent([ident], [], [Some trivia]) }

  | ident DOT pathOp 
     { prependIdentInLongIdentWithTrivia (SynIdent($1, None)) (rhs parseState 2) $3 }

  | ident DOT error
     { (* silent recovery *) SynLongIdent([$1], [rhs parseState 2], [None]) }  


/* nameop is identOrOp not used as part of a path */
nameop: 
  | identOrOp { $1 } 

identExpr:
  | ident
     { SynExpr.Ident($1) }

  | opName
     { let m = lhs parseState
       let ident, trivia = $1
       let mLparen, mRparen, trivia =
           match trivia with
           | IdentTrivia.OriginalNotation text -> 
               let mLparen = mkFileIndexRange m.FileIndex m.Start (mkPos m.StartLine (m.StartColumn + 1))
               let mRparen = mkFileIndexRange m.FileIndex (mkPos m.EndLine (m.EndColumn - 1)) m.End
               mLparen, mRparen, Some trivia
           | IdentTrivia.OriginalNotationWithParen(lpr, text, rpr) ->
               lpr, rpr, Some(IdentTrivia.OriginalNotation(text))
           | IdentTrivia.HasParenthesis(lpr, rpr) ->
               lpr, rpr, None

       match trivia with
       | None -> 
           SynExpr.Paren(SynExpr.Ident(ident), mLparen, Some mRparen, m)
       | Some trivia ->
           SynExpr.Paren(
               SynExpr.LongIdent(false, SynLongIdent([ident], [], [Some trivia]), None, m),
               mLparen, 
               Some mRparen, 
               m
           ) }

topSeparator: 
  | SEMICOLON { } 
  | SEMICOLON_SEMICOLON { }
  | OBLOCKSEP { }  

topSeparators: 
  | topSeparator { } 
  | topSeparator topSeparators { }

opt_topSeparators: 
  | topSeparator opt_topSeparators { }
  | /* EMPTY */                    { } 

/* Seprators in either #light or non-#light */
seps: 
  | OBLOCKSEP { } 
  | SEMICOLON { }
  | OBLOCKSEP SEMICOLON { }
  | SEMICOLON OBLOCKSEP { }

/* An 'end' that's optional only in #light, where an ODECLEND gets inserted, and explicit 'end's get converted to OEND */
declEnd: 
  | ODECLEND 
      { } 
  | OEND 
      {   }
  | END 
      { } 

/* An 'end' that's optional in both #light and non-#light */
opt_declEnd: 
  | ODECLEND 
      {} 
  | OEND 
      { } 
  | END 
      {} 
  | /* EMPTY */    
      {} 

opt_ODECLEND: 
  | ODECLEND    { } 
  | /* EMPTY */ { }

deprecated_opt_equals: 
  | EQUALS      { deprecatedWithError (FSComp.SR.parsNoEqualShouldFollowNamespace()) (lhs parseState); () } 
  | /* EMPTY */ {  }

opt_equals:
  | EQUALS      { let mEquals = rhs parseState 1 in (Some mEquals) }
  | /* EMPTY */ { None } 

opt_OBLOCKSEP: 
  | OBLOCKSEP   { }
  | /* EMPTY */ { } 

opt_seps: 
  | seps        { }
  | /* EMPTY */ { } 

opt_rec: 
  | REC         { true }
  | /* EMPTY */ { false } 

opt_bar: 
  | BAR         { } 
  | /* EMPTY */ { } 

opt_inline: 
  | INLINE      { true } 
  | /* EMPTY */ { false }

opt_mutable: 
  | MUTABLE     { true } 
  | /* EMPTY */ { false }

/* A 'do' token in either #light or non-#light */
doToken: 
  | DO  { }
  | ODO { }

doneDeclEnd: 
  | DONE { }
  | ODECLEND { }  /* DONE gets thrown away by the lexfilter in favour of ODECLEND */

structOrBegin: 
  | STRUCT
    { if parseState.LexBuffer.SupportsFeature LanguageFeature.MLCompatRevisions then
          mlCompatError (FSComp.SR.mlCompatStructEndNoLongerSupported()) (lhs parseState)
      else
          mlCompatWarning (FSComp.SR.parsSyntaxModuleStructEndDeprecated()) (lhs parseState)
    }
  | BEGIN { } 

sigOrBegin: 
  | SIG
    { if parseState.LexBuffer.SupportsFeature LanguageFeature.MLCompatRevisions then
          mlCompatError (FSComp.SR.mlCompatSigEndNoLongerSupported())(lhs parseState)
      else
          mlCompatWarning (FSComp.SR.parsSyntaxModuleSigEndDeprecated()) (lhs parseState)
    }
  | BEGIN { } 

colonOrEquals: 
  | COLON
    { if parseState.LexBuffer.SupportsFeature LanguageFeature.MLCompatRevisions then
          mlCompatError (FSComp.SR.mlCompatSigColonNoLongerSupported())(lhs parseState)
      else
          mlCompatWarning (FSComp.SR.parsSyntaxModuleSigEndDeprecated()) (lhs parseState)
      None
    }
  | EQUALS { let mEquals = rhs parseState 1 in Some mEquals } 

/* A literal string or a string from a keyword like __SOURCE_FILE__ */
string:
  | STRING 
     { let (s, synStringKind, _) = $1
       s, synStringKind }

sourceIdentifier:
  | KEYWORD_STRING { $1 }

interpolatedStringFill:
  | declExpr
     { ($1, None) }

  | declExpr COLON ident %prec interpolation_fill
     { ($1, Some $3) }

interpolatedStringParts:
  | INTERP_STRING_END
     { [ SynInterpolatedStringPart.String (fst $1, rhs parseState 1) ] }

  | INTERP_STRING_PART interpolatedStringFill interpolatedStringParts
     { SynInterpolatedStringPart.String (fst $1, rhs parseState 1) :: SynInterpolatedStringPart.FillExpr $2 :: $3 }

  | INTERP_STRING_PART interpolatedStringParts
     { 
       let rbrace = parseState.InputEndPosition 1
       let lbrace = parseState.InputStartPosition 2
       reportParseErrorAt (mkSynRange rbrace lbrace) (FSComp.SR.parsEmptyFillInInterpolatedString())
       SynInterpolatedStringPart.String (fst $1, rhs parseState 1) :: $2 }

/* INTERP_STRING_BEGIN_END */
/* INTERP_STRING_BEGIN_PART int32 INTERP_STRING_END */
/* INTERP_STRING_BEGIN_PART int32 INTERP_STRING_PART int32 INTERP_STRING_END */
interpolatedString:
  | INTERP_STRING_BEGIN_PART interpolatedStringFill interpolatedStringParts
    { let s, synStringKind, _ = $1
      SynInterpolatedStringPart.String (s, rhs parseState 1) :: SynInterpolatedStringPart.FillExpr $2 :: $3, synStringKind }

  | INTERP_STRING_BEGIN_END
    { let s, synStringKind, _ = $1
      [ SynInterpolatedStringPart.String (s, rhs parseState 1) ], synStringKind }

  | INTERP_STRING_BEGIN_PART interpolatedStringParts
    { 
      let s, synStringKind, _ = $1
      let rbrace = parseState.InputEndPosition 1
      let lbrace = parseState.InputStartPosition 2
      reportParseErrorAt (mkSynRange rbrace lbrace) (FSComp.SR.parsEmptyFillInInterpolatedString())
      SynInterpolatedStringPart.String (s, rhs parseState 1) :: $2, synStringKind }
  
opt_HIGH_PRECEDENCE_APP:
  | HIGH_PRECEDENCE_BRACK_APP { }
  | HIGH_PRECEDENCE_PAREN_APP { }
  | /* EMPTY */   { }

opt_HIGH_PRECEDENCE_TYAPP:
  | HIGH_PRECEDENCE_TYAPP { }
  | /* EMPTY */   { }

/* A 'type' keyword */
typeKeyword:
  | TYPE_COMING_SOON typeKeyword { }
  | TYPE_IS_HERE { }
  | TYPE { }

/* A 'module' keyword */
moduleKeyword:
  | MODULE_COMING_SOON moduleKeyword { }
  | MODULE_IS_HERE { }
  | MODULE { }

rbrace:
  | RBRACE_COMING_SOON rbrace { }
  | RBRACE_IS_HERE { }
  | RBRACE { }

bar_rbrace:
  | BAR_RBRACE { }

rparen:
  | RPAREN_COMING_SOON rparen { }
  | RPAREN_IS_HERE { }
  | RPAREN { }

oblockend:
  | OBLOCKEND_COMING_SOON oblockend { }
  | OBLOCKEND_IS_HERE { }
  | OBLOCKEND { }

ends_other_than_rparen_coming_soon_or_recover:
  | TYPE_COMING_SOON { false }
  | MODULE_COMING_SOON { false }
  | RBRACE_COMING_SOON { false }
  | OBLOCKEND_COMING_SOON { false }
  | recover { $1 }

ends_coming_soon_or_recover:
  | TYPE_COMING_SOON { false }
  | MODULE_COMING_SOON { false }
  | RBRACE_COMING_SOON { false }
  | RPAREN_COMING_SOON { false }
  | OBLOCKEND_COMING_SOON { false }
  | recover { $1 }
